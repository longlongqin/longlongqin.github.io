{"meta":{"title":"龙龙‘S BLOG","subtitle":"","description":"","author":"longlongqin","url":"https://longlongqin.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-04-19T14:35:12.699Z","updated":"2020-04-19T14:35:12.699Z","comments":true,"path":"404.html","permalink":"https://longlongqin.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-03-30T06:26:07.079Z","updated":"2020-03-30T06:26:07.079Z","comments":true,"path":"about/index.html","permalink":"https://longlongqin.github.io/about/index.html","excerpt":"","text":"路漫漫其修远兮，吾将上下而求索一个本科生化环材的跨考生，现专业软件工程。本博客主要记录自己的学习之路。现阶段学习内容：编译原理Let’s Build A Simple Interpreter计算几何邓俊辉老师的学堂在线课程C/C++基础学习：https://www.learncpp.com/"},{"title":"所有分类","date":"2020-03-16T13:58:21.496Z","updated":"2020-03-15T14:08:19.000Z","comments":true,"path":"categories/index.html","permalink":"https://longlongqin.github.io/categories/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-03-21T17:19:06.339Z","updated":"2020-03-15T14:08:19.000Z","comments":true,"path":"comment/index.html","permalink":"https://longlongqin.github.io/comment/index.html","excerpt":"","text":"欢迎前来灌水。。。"},{"title":"Projects","date":"2020-03-21T17:16:38.679Z","updated":"2020-03-15T14:08:19.000Z","comments":true,"path":"projects/index.html","permalink":"https://longlongqin.github.io/projects/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-03-16T13:21:42.616Z","updated":"2020-03-15T14:08:19.000Z","comments":true,"path":"tags/index.html","permalink":"https://longlongqin.github.io/tags/index.html","excerpt":"","text":""},{"title":"Friends","date":"2020-04-19T14:38:29.545Z","updated":"2020-04-19T14:38:29.545Z","comments":true,"path":"friends/index.html","permalink":"https://longlongqin.github.io/friends/index.html","excerpt":"","text":"欢迎和我交换友链各位大佬想交换友链的话可以在下方留言，必须要提供名称、头像和链接哦~请先将本站添加到你滴友链中喔，谢谢~友链提交模板：123456- name: 龙龙‘S Blog avatar: https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg url: https://www.longlongqin.github.io backgroundColor: '#FFA500' textColor: '#624739' tag: #你的简介背景、字体颜色可以按自己风格设置呀！"},{"title":"","date":"2020-04-19T14:38:29.545Z","updated":"2020-04-19T14:38:29.545Z","comments":true,"path":"学习笔记/index.html","permalink":"https://longlongqin.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html","excerpt":"","text":"学习笔记编译原理Let’s Build A Simple Interpreterpart1、part2、part3、part4、part5、part6、part7、part8、part9计算几何学堂在线课程-邓俊辉老师凸包：Convex-Hull-凸包、增量构造、Jarvis-March、Lower-Bound、Graham Scan、Divide-And-Conquererer计算机科学速成课2 电子计算机、3 布尔逻辑和逻辑门、32 黑客&amp;攻击C/C++C本办法学CC++1、www.learncpp.comLearnCpp描述chapter0~1chapter2functions and fileschapter4Fundamental Data Typeschapter3debugging C++ programschapter5OperatorschapterOBit Manipulation (optional chapter)chapter6Object Scope and Conversions2、基于项目学习(project-based-learning)Build an Interpreter(Chapter 14 on is written in C)Memory Allocators 101 - Write a simple memory allocator项目练习我的项目练习相应的github仓库：https://github.com/longlongqin/learnCode_based_project程序羊推荐项目描述进度CJSON一个超轻量的、可移植的、单文件的、简单到可以成为ANSI-C兼容的JSON解析器，在MIT许可下。【一些相关教程：1️⃣从零开始的 JSON 库教程，2️⃣cJson源码和源码分析】🔥进行中Tinyhttpd是J. David Blackstone在1999年写的一个不到 500 行的超轻量型 Http Server，用来学习非常不错，可以帮助我们真正理解服务器程序的本质。官网MyTinySTL基于 C++11 的 tinySTL，（学STL时，可以写一写）oatpp用C++实现的轻量级的Web框架redis这个几万行代码，现在干不动基于项目学习(project-based-learning)项目描述进度Build an Interpreter(Chapter 14 on is written in C)使用C语言写一个解释器暂停Linux鸟哥的私房菜 0.计算机概论 1.Linux是什么 2.主机规划与硬盘分割 3.安裝 CentOS7.x【未读，我直接用的阿里云服务器】 4.首次登陆与线上求助"},{"title":"","date":"2020-04-19T14:38:29.545Z","updated":"2020-04-19T14:38:29.545Z","comments":true,"path":"easysearch/about/index.html","permalink":"https://longlongqin.github.io/easysearch/about/index.html","excerpt":"","text":"关于本页丨龙龙'S BLOG 关于本页在自己电脑上建立了很多书签，但是不方便使用。就想建立一个在线的网址导航，这样无论在哪都可以方便快捷的使用导航了。powered by webstack.cc关于我longlongqin一个跨考软工的初学者努力学习C++ 2020 - 2020 | 丨 DESIGNED BY Viggo 丨 MODIFIED BY longlongqin!function(e){var c=Array.prototype.slice.call(document.querySelectorAll(\"img[data-original]\"));function i(){for(var r=0;r"},{"title":"","date":"2020-04-19T14:38:29.851Z","updated":"2020-04-19T14:38:29.851Z","comments":true,"path":"easysearch/index.html","permalink":"https://longlongqin.github.io/easysearch/index.html","excerpt":"","text":"easysearch丨龙龙'S BLOG 开发社区 代码托管 语言文档 技能训练在线平台高校平台游戏编程 HOT Pythoner文档资料博客收藏学习资源组织社区爬虫相关 HOT 学习教程在线视频博客论坛学习平台 常用工具站长工具 HOTIT工具箱文件处理 HOT设计素材效率软件 HOT 服务平台 云服务商 众包平台 更多导航 FORME计算几何C++关注的博客 HOT常用网址公众号&写作 关于本页 隐藏/显示侧边栏 博客首页 友情链接 评论留言 关于博主!function(e,t,n,a,o,i,c,r){r=function(){i=t.createElement(n),c=t.getElementsByTagName(n)[0],i.src=o,i.charset=\"utf-8\",i.async=1,c.parentNode.insertBefore(i,c)},e.SeniverseWeatherWidgetObject=a,e[a]||(e[a]=function(){(e[a].q=e[a].q||[]).push(arguments)}),e[a].l=+new Date,e.attachEvent?e.attachEvent(\"onload\",r):e.addEventListener(\"load\",r,!1)}(window,document,\"script\",\"SeniverseWeatherWidget\",\"//cdn.sencdn.com/widget2/static/js/bundle.js?t=\"+parseInt(((new Date).getTime()/1e8).toString(),10)),window.SeniverseWeatherWidget(\"show\",{flavor:\"slim\",location:\"WX4FBXXFKE4F\",geolocation:!0,language:\"auto\",unit:\"c\",theme:\"auto\",token:\"a39cd5a0-4024-4cb2-85c6-0250317058db\",hover:\"enabled\",container:\"tp-weather-widget\"})开发社区Stack Overflow全球最受程序员欢迎的开发社区V2EXV2EX = way to explore SegmentFault改变并提升人们获取知识的方式和效率，帮助更多的开发者获得成长与成功 开源中国国内最大的开源技术社区 ITeyeITeye软件开发交流社区 - Java编程 Spring框架 Ajax技术 agile敏捷软件开发 ruby on rails实践 51CTO技术成就梦想 ITPUB全球最大的学习分享平台 知乎国内最受欢迎的知识性问答社区 简书创作你的创作 云+社区来自腾讯的开发者技术分享社区云栖社区阿里云面向开发者的开放型技术平台 掘金一个帮助开发者成长的社区CSDN全球最大中文IT社区，为IT专业技术人员提供最全面的信息传播和服务平台博客园代码改变世界代码托管Github全球最大的面向开源及私有软件项目的托管平台Gitlab支持无限的公有项目和私有项目的代码托管平台Bitbucket同时支持 Git 和 Mercurial 这两个版本控制软件，免费的私有仓库，支持5人以内的合作开发SourceForge又称 SF.net，是开源软件开发者进行开发管理的集中式场所Coding国内首个一站式云端软件服务平台Gitee国内最大的开源社区 OSChina 的代码托管平台阿里云代码托管阿里云旗下代码托管平台百度效率云百度云旗下的 Git 代码托管平台语言文档Zeal脱机文档浏览器，包含196种语言API文档，支持Windows、Linux和macOSDash适用于Mac OS平台的软件编程文档管理工具,可以浏览API文档,以及管理代码片段工具。自带了丰富的API文档,涉及各种主流的编程语言和框架DevDocs在快速，有条理和可搜索的界面中结合了多个API文档，可以在移动设备上离线运行，并且可以安装在Chrome上C/C++C/C++ API 文档C#C# API 文档JavaJava API 文档.NET.NET API 文档PHPPHP API 文档JavaScriptJavaScript API 文档PythonPython API 文档AndroidAndroid API 文档iOSiOS API 文档SQLSQL API 文档SwiftSwift API 文档RubyRuby API 文档GOGO API 文档RR API 文档MATLABMATLAB API 文档Node.jsNode.js API 文档HTMLHTML API 文档CSSCSS API 文档RedisRedis API 文档MongoDBMongoDB API 文档DjangoDjango API 文档在线平台 LeetCode全球极客挚爱的技术成长平台Topcoder全世界规模最大的程序竞赛网站，也会有一些算法竞赛，适合一些高端的或者搞ACM的，也会举办一些比赛Codeforces俄罗斯最大的算法比赛网站Hihocoder技术团队来自原北京大学POJ (PKU Online Judge)开发团队，收集了全球范围内很多地区、高校举办的比赛试题， 提供365天*24小时的在线提交、评判程序的服务LintCode被称作中文版的leetcode，也是可以做为编程能力提升的一个中转站SPOJ波兰的算法刷题网站NEUQ OJ一个在线的判题平台洛谷创办于2013年，致力于为参加noip、noi、acm的选手提供清爽、快捷的编程体验牛客网中国最大的IT题库C语言网在这里可以参加包括ACM、NOI在内的各种C/C++/java程序比赛，也可以DIY举办各类程序比赛活动！计蒜客计蒜客OI题库致力于为参加noi、noip、信息学竞赛的选手提供优秀的Online Judge系统高校平台POJ北京大学程序在线评测系统FDU OJ复旦大学程序在线评测系统TJ OJ同济大学程序在线评测系统USTC OJ中国科学技术大学程序在线评测系统ZOJ浙江大学程序在线评测系统HDU OJ杭州电子科技大学程序在线评测系统CSU-ACM中南大学程序在线评测系统HOJX哈尔滨工业大学程序在线评测系统HRBUST OJ哈尔滨理工大学程序在线评测系统PowerOJ西南科技大学程序在线评测系统SCU OJ四川大学程序在线评测系统FZU CoidngOJ福州大学程序在线评测系统NBUT OJ宁波工程学院程序在线评测系统Lutece电子科技大学程序在线评测系统武汉大学 ACM 协会武汉大学 ACM 协会ZJUT OJ浙江工业大学程序在线评测系统游戏编程CheckiO面向初学者和高级程序员的编码游戏，使用Python和JavaScript解决棘手的挑战和有趣的任务，从而提高您的编码技能Coding Games支持包括PHP、C、JavaScript在内的20多种编程语言。用户界面功能强大，可以定制Codewars一个外国的在线练习编程的网站,做题的过程类似打怪,做题升级,而且可以看到别人的解法,里面有很多巧妙的写法可以学习CodeCombat一个面向学生的游戏和CS学习平台。这是一个社区项目，有数百玩家自愿提供支持。支持语言包括Java、JS、Python、Lua、CoffeeScriptScreeps在游戏中学习JavaScript。世界上第一款针对程序员的MMO沙盒游戏VIM Adventures玩游戏的时候学VIMCyber-Dojo一个提供给程序员们练习写程序的地方。支持语言包括JavaScript、Java、Python、PHP、Ruby和很多其他语言Elevator Saga电梯编程游戏，跟随关卡解决所有挑站，使用语言为JavaScriptRuby Quiz一个Ruby程序员提供的每周编程挑战项目hacker.org这项挑战由一系列本设计来强化你黑客技巧的解密、诡计、测试、烧脑环节组成。想要通关本系列，你必须学会解密、编码、渗透Ruby Warrior玩游戏学Ruby，通过Ruby脚本来控制一个Warrior通过每一关，每一关的代码难度都会有所增加，使玩家逐渐了解Ruby基本的函数、控制、变量、数组等语言特性的用法文档资料Python 官方文档Python 官方文档Python 标准库Python 标准库Python RequestsPython Requests 文档Python UrllibPython Urllib 文档Python SeleniumPython Selenium 中文翻译文档正则表达式Python 正则表达式官方文档Beautiful SoupBeautiful Soup 文档ScrapyScrapy 爬虫框架官方文档PySpiderPySpider 爬虫框架官方文档MatplotlibMatplotlib 2D绘图库 官方中文文档NumpyNumpy 科学计算 官方中文文档PandasPandas 结构化数据分析 官方中文文档博客收藏廖雪峰廖雪峰的官方网站 - 研究互联网产品和技术，提供原创中文精品教程崔庆才崔庆才的个人博客,专注PHP,Python,爬虫,深度学习,机器学习,数据分析莫烦Python专注Python、机器学习、深度学习唐松专注Python网络爬虫, 数据科学, 数据挖掘, 数据分析捕蛇者说编程、程序员、PythonFxxkPython学习python的正确姿势wistbeanPython 大佬PigleiPython 大佬TendCodePython 大佬追梦人物的博客Python Django 大佬the5fire《Django企业开发实战》作者，关注Python、Django、Vim、Linux、Web开发小明明S À DOMICILE《Python Web开发实战》作者，Python 大佬Python之禅Python 大佬Python 知识圈Python知识圈 - 实用的Python教程网站Python 教程网小詹学Python，专注Python学习烂笔头 j_hao104Python大佬咸鱼日常专注Python爬虫，有许多JS逆向文章AnShengPython 全栈大佬夏溪辰云栖社区特邀爬虫工程师，Python大佬高级农民工Python大佬云爬虫技术研究笔记Lateautumn4lin 爬虫开发工程师，多年反爬虫破解经验，沉迷数据分析和黑客增长，CSDN博客专家，华为云享专家云爬虫技术研究笔记(CSDN)Lateautumn4lin 爬虫开发工程师，多年反爬虫破解经验，沉迷数据分析和黑客增长，CSDN博客专家，华为云享专家Jack CuiCSDN博客专家，Python 大佬学习资源Python爬虫人工智能学习教程Python爬虫人工智能学习教程分享Python 中文学习大本营Python 中文学习大本营Python 资源大全中文版Python 资源大全中文版爱湃森各种 Python 教程组织社区PyChinaPython 中国社区PyCon China中国 Python 开发者大会蠎周刊蠎周刊 - 汇集全球蠎事儿爬虫相关镀金的天空GlidedSky 镀金的天空，在线爬虫练习题库夜幕爬虫安全论坛一个专注于爬虫与 PC/Web/ 移动端安全领域技术交流的社区，社区由夜幕团队 NightTeam 创办，旨在提升开发者对爬虫与软件安全防护的理解西刺免费代理IP每日更新免费HTTP代理，所有代理均为6675端口高匿代理，可隐藏IP爬虫IP代理池爬虫IP代理池云打码采用全球领先的秒传识别系统，50%图片零秒识别，人工平均处理时间0-3秒超级鹰专业的验证码云端识别服务,让验证码识别更快速、更准确、更强大八爪鱼采集器一款使用简单、功能强大的网络爬虫工具，完全可视化操作，无需编写代码，内置海量模板，支持任意网络数据抓取Python 逆向Python 逆向相关资源Python 爬虫集合Python 爬虫集合Python 入门网络爬虫之精华版Python 入门网络爬虫之精华版爬虫项目进阶实战Python3 爬虫项目进阶实战、JS加解密、逆向教程、css 加密、字体加密Python 模拟登陆一些大型网站Python 模拟登陆一些大型网站系统化学习 Python 爬虫系统化学习 Python 爬虫Python3 网络爬虫实战Python3 网络爬虫实战在线视频腾讯课堂腾讯推出的专业在线教育平台，聚合大量优质教育机构和名师网易云课堂网易旗下一个专注职业技能提升的在线学习平台。立足于实用性的要求，与多家教育培训机构和行业的专家、讲师建立合作中国大学 MOOC中国大学MOOC(慕课)，国家精品课程在线学习平台黑马程序员致力于培养中级程序员，是业内以口碑闻名的IT教育培训机构课工场更可靠的IT就业教育平台，针对大学生量身定制人工智能、大数据、云计算、区块链、Java大数据开发等大学生IT培训课程极客学院极客学院作为中国专业IT职业在线教育平台,拥有海量高清IT职业课程,涵盖30+个技术领域慕课网慕课网（IMOOC）是IT技能学习平台。慕课网(IMOOC)提供了丰富的移动端开发、php开发、web前端、android开发以及html5等视频教程资源公开课尚硅谷尚硅谷Java培训，谷粉与老学员为你推荐的Java培训、Web前端培训、前端培训、大数据培训、Python培训；0基础入学，学员就业起薪屡创新高！实验楼国内领先的IT在线编程及在线实训学习平台，专业导师提供精选的实践项目，创新的技术使得学习者无需配置繁琐的本地环境，随时在线流畅使用优达学城Udacity是来自硅谷的前沿技术平台，为广大学子提供WEB前端开发、Python/JAVA编程、IOS/Android开发、人工智能开发等一系列在线课程及实战项目，满足学员灵活的学习需求51CTO学院51CTO学院IT职业在线教育平台是依托12年行业品牌、1400万IT技术用户建立的专业IT技能学习培训平台，已签约1000多位技术专家发布了12万个自学式实战视频教程CSDN 学院CSDN 学院作为IT在线教育平台,涵盖人工智能、考试认证、移动开发、大数据技术领域职业课程老男孩IT教育隶属北京一天天教育科技有限公司,是一直专注于Linux培训、Linux系统及架构师培训、Python培训、网络安全培训，大数据实战的高端培训机构千锋教育千锋教育 - 坚持教育初心，坚持面授品质，IT培训良心品牌博客论坛鱼C工作室鱼C工作室-免费编程视频教学|Python教学|Web开发教学|全栈开发教学|C语言教学|汇编教学|Win32开发|加密与解密|Linux教学吾爱破解致力于软件安全与病毒分析的前沿，丰富的技术版块交相辉映，由无数热衷于软件加密解密及反病毒爱好者共同维护廖雪峰廖雪峰的官方网站 - 研究互联网产品和技术，提供原创中文精品教程崔庆才崔庆才的个人博客,专注PHP,Python,爬虫,深度学习,机器学习,数据分析莫烦Python专注Python、机器学习、深度学习唐松专注Python网络爬虫, 数据科学, 数据挖掘, 数据分析阮一峰上海财经大学世界经济博士研究生，计算机科普博主，对自由软件有着坚定不移的信念学习平台菜鸟教程提供了编程的基础技术教程, 介绍了HTML、CSS、Javascript、Python，Java，Ruby，C，PHP , MySQL等各种编程语言的基础知识 W3school领先的 Web 技术教程C语言网C语言网 - 领先实用的编程在线学习网站前端网前端网，最好的自学web前端网站 牛客网牛客网 - 互联网求职神器和备考学习平台How2JHow2J的Java教程, 内容涵盖J2SE、WEB前端、J2EE、框架技术等全面的Java内容站长工具新浪短网址多种后缀短网址生成百度短网址百度旗下专业的网址缩短服务站长工具 - 站长之家站长工具,SEO工具,权重查询,收录查询,PR查询,ICP备案查询,whois查询,友情链接查询,反向链接查询,网站测试,IP查询,Alexa查询阿里云 whois 查询whois查询,域名whois,域名注册信息,whois查询工具,whois信息,域名信息NnameBeta国际域名搜索、域名注册、国别域名注册、域名比价Domcomp域名比价，Domain Name Price and Availability.仿站工具箱在线仿站工具箱超级 SEO 外链工具网站自动化宣传机器/免费的超级外链工具可批量增加外链百度站长平台百度搜索资源平台 - 让网站更具价值搜狗站长平台搜狗站长平台 - 全面掌握在搜狗搜索中的数据表现360 站长平台360 站长平台 - 给网站带来更多流量和展现Google 站长平台Google 网站站长 - 支持、学习、互动交流和 Search Console – GoogleBing 网站管理员工具Bing 网站管理员工具百度广告联盟百度广告联盟为您的流量增值Google AdSenseGoogle 广告平台百度统计百度统计 — 最大的中文网站分析平台友盟+国内领先的第三方全域数据智能服务商ICP/IP地址/域名信息备案管理系统工业和信息化部ICP/IP地址/域名信息备案管理系统全国互联网安全管理服务平台公安备案网 - 全国互联网安全管理服务平台IT工具箱在线工具 - 程序员的工具箱站长工具、代码格式化、压缩、加密、解密、下载链接转换等在线工具 - OSCHINA.NET社区常用文档、常用对照表、代码处理、Html/Js/Css工具、加密/转码工具等记磊工具箱Dns检测、CSS格式化、超级Ping、端口扫描等孟坤工具箱css一键美化、文本差异比较、代码高亮等Syntax HighlightSyntax Highlight Code In Word Documents，在Word文档中插入漂亮的代码Text to ASCII Art GeneratorText to ASCII Art Generator，字符串转成 ASCII 码图案MDEditor开源在线 Markdown 编辑器临时邮箱匿名注册不常用的网站/论坛，保护隐私免骚扰SM.MSSM 免费图床，每个文件最大支持 5MB路过图床免费公共图床，支持最大10MB、批量上传Greasy Fork安全、实用的用户脚本大全Hello World 大全收集了大约481种 Hello World 程序，涵盖了目前已知的所有编程语言，另加上 67 人类语言动画展示各种路径搜索算法动画展示各种路径搜索算法IT eBooks可以下载IT电子书籍的网站（英文）GEEKTyper在线模拟黑客工作的虚拟桌面系统，提供多种黑客工作的场景免费计算机编程类中文书籍免费计算机编程类中文书籍EaseUS Partition Master磁盘分区管理软件，不用重装系统，就可以重新划分磁盘空间文件处理Convertio在线文件转换工具，支持超过309种不同的文档、图像、电子表格、电子书、文档、演示文稿、音频和视频格式Office-Converter免费在线转换视频，在线音频转换，在线图形转换，在线文档转换和在线压缩格式TinyPNGPNG/JPG图片在线压缩利器SquooshGoogle开源在线压缩、调整工具，支持WebPILoveIMG永远免费的在线图片处理工具，可在线编辑，压缩、裁剪、转换、水印等SmallpdfSmallpdf - A Free Solution to all your PDF Problems,PDF压缩、转换、分割、合并等PHOTOMOSH故障艺术在线生成，可以输出jpg、gif和视频稿定抠图免费在线抠图软件,图片快速换背景-抠白底图U钙网完全免费的LOGO在线设计制作工具SVGOMGSVG在线压缩平台在线图片透明圆角处理在线图片透明圆角处理草料二维码国内创建二维码在线应用Logaster在线免费创建简单logo及名片设计PreloadersLoading 懒加载动画在线制作Loading制作GIF、SVG、CSS加载动画图标waifu2x图片智能无损放大2倍，适合动漫、插画等智图腾讯ISUX前端团队开发的一个专门用于图片压缩和图片格式转换的平台音乐免费下载全网音乐免费下载工具OK资源采集OK资源采集-最新影视资源大全网易见外工作台针对视频、图片、文档、音频都可以进行翻译转写操作，每天两小时免费使用HiPDF一站式解决所有PDF相关的问题视频鱼在线下载各大网站视频的网站ScreenToGif开源、轻量级却非常强大的录屏软件，快速将屏幕录制成高清GIF设计素材Iconfont阿里巴巴矢量图标库，提供矢量图标下载、在线存储、格式转换等功能Font Awesome一个基于CSS 和 LESS 的字体和图标工具包Flaticon海量扁平化免费的图标库icons8独特系统平台风格和web图标库，下载免费图标，音乐千图网海量原创设计模板免费下载昵图网国内海量平面免费素材下载千库网免费 png 图片背景素材下载Pexels才华横溢的摄影作者在这里免费分享最精彩的素材照片和视频必应壁纸必应每日高清壁纸Piqsels精美的免版税图库私藏字体优质字体免费下载站第一 PPT 网免费 PPT 模板下载吾道幻灯片全新的office生产力工具，支持演示文稿、PPT模板、协同办公，可以帮助用户轻松创建具有视觉吸引力的幻灯片Mixkit免费、高质量、可商用的视频素材分享网站The Stocks对各大图片网站进行整合，免费优质图片下载极简壁纸高质量精品壁纸网站NASA Image and Video Library美国国家航天局的官方库，从此太空类的素材再也不是问题Unsplash质量超高的免费图片素材库，无需注册，直接下载WordArt文字云工具效率软件分流抢票全程自动抢票,自动抢候补,自动识别验证码,多线程秒单、稳定捡漏,支持多天、多车次、多席别、多乘客等功能PanDownload百度网盘下载神器Quicker为常用操作建立捷径，PC 快捷动作面板，让效率触手可及!万彩办公大师免费、轻松处理文档/音视频/图片的工具LICEcap简洁易用的动画屏幕录制软件，它可将屏幕录像的内容直接保存为高质量（每帧颜色数量可超过256）GIF动态图片格式Snipaste简单但强大的截图工具，支持截图 + 贴图FSCapture一个强大的，轻量级的，功能齐全的屏幕捕获工具Everything速度最快的的文件搜索工具DeskPins顶置任意窗口TrafficMonitor一个用于显示当前网速、CPU及内存利用率的桌面悬浮窗软件PicGo由 electronic-vue 构建的简单而精美的图片上传工具PowerToys微软为 Windows 系统推出的一系列免费实用小工具合集Dism++一款根据微软底层的架构结构设计的一个系统维护工具，全球第一款基于 CBS 的 Dism GUI 实现ColorPix屏幕取色小工具CCleaner一款免费的系统优化和隐私保护工具GifCam集录制与剪辑为一体的屏幕 GIF 动画制作工具，录制后的动画可以逐帧编辑EV录屏一款免费并且不添加水印的录屏工具Fliqlo一款极简主义的时钟屏保软件Fences栅栏管理桌面，使桌面更加整洁有条理Q-dir多窗口文件整理工具WGestures鼠标手势工具XMind一个全功能的思维导图和头脑风暴软件速盘免登录，自动查询提取码，极速的度盘下载工具f.lux国外开源的护眼软件，通过根据时间调节屏幕颜色，减少蓝光对视力的影响云服务商 阿里云阿里云 - 为了无法计算的价值腾讯云腾讯云 - 产业智变 云启未来百度云百度云 - 计算无限可能华为云华为云 - +智能，见未来京东云京东云 - 遇见无限可能西部数码西部数码 - 云服务器、虚拟主机、域名注册17年知名云计算服务提供商！景安云景安云 - 专业的数据中心服务商七牛云七牛云 - 国内领先的企业级云服务商又拍云又拍云 - 加速在线业务-CDN-云存储美橙互联美橙互联 - 域名注册、企业建站、云服务器、企业网络推广整体解决方案服务商！UCloudUCloud - 中立 安全 可信赖的云计算服务商AWSAWS 云服务 - 专业的大数据和云计算服务以及云解决方案提供商Microsoft AzureAzure. Invent with purpose.GoDaddyGoDaddy - 提供域名注册和互联网主机服务的美国公司CloudflareCloudflare - 网络性能和安全公司jsDelivrjsDelivr - A free, fast, and reliable Open Source CDN for npm and GitHub众包平台 猿急送专注于 IT 众包领域，职位内容大多集中于 UI 设计、产品设计、程序开发、产品运营等需求开源众包开源中国旗下外包网站，项目大多是团队的整包项目，适合多人组团接单外包大师PMCAFF旗下的一个众包开发平台，目前以技术开发为主，以众包开发和自有开发相结合形式运营人人开发集可视化开发，应用市场，威客众包，PaaS云于一体的企业级应用服务平台快码提供智能硬件、各种智能共享项目解决方案，为互联网创业者提供APP、小程序、公众号开发。我爱方案网专注于硬件类外包，电子方案开发供应链众包平台，软件外包，方案，硬件开发方案，硬件设计开发英选提供可信赖的定制开发外包服务，包括企业品牌官网、电商系统及创新定制产品开发智筹为企业&创业者提供互联网高级人才直租服务。按次直租，解决临时、突发问题；按月直租，建立长期兼职合作；按任务直租，解决有明确预算的外包任务开发邦互联网软件定制开发与软件外包开发服务，十年互联网软件定制开发经验码市Coding 推出的互联网软件外包服务平台，意在连接需求方与广大开发者。让项目的需求方快速的找到合适的开发者，完成项目开发工作自由职客自由职客是权威的IT互联网行业灵活用工交易平台，外包，众包，兼职，招聘，erp，sap解放号解放号众包平台提供软件开发外包、人力驻场服务等软件项目外包服务。解放号的软件项目交付全流程可视化监控与全生命周期管理能力程序员客栈领先的程序员自由工作平台，38万+优秀开发者，您的专属云端开发团队，BAT级别的开发者，标准化的服务和交付码易智网易联旗下IT软件服务平台，集软件商城、企业应用、电商软件、crm软件、商务服务平台于一体的一站式软件外包开发服务平台电鸭社区电鸭社区旨在推动自由工作方式在国内渐进式发展，区别于传统方式的工作职位，倡导「只工作，不上班」的工作心态Sxsoft中国最早的外包服务平台，18年口碑服务，20万程序员、100+专业软件开发公司，专注解决各类软件开发需求实现网为企业提供BAT等名企背景的、靠谱的开发设计兼职人才和自由职业者，满足企业项目外包、驻场开发、远程兼职、技术咨询等短期人力需求智城外包网零佣金开发资源平台，认证担保，全程无忧，专业的软件外包网和项目外包、项目开发、人力外派、短期招聘、人力资源交易平台更多导航 创造狮导航创造狮，一个创意工作者的导航，专注分享正版优质设计、前端、产品、运营的书签导航，设计教程、设计规范、颜色搭配、灵感创意、前端框架、开发者工具、互联网新品推荐、运营数据分析、自媒体和工具利器好用的分类导航大全大数据导航大数据导航，以大数据产业为主，大数据工具为辅，给用户提供一个更加快速找到大数据相关的工具平台优设导航优设网站导航为设计师提供ps教程、UI设计、素材下载、高清图库、配色方案、用户体验、网页设计等全方位设计师网站导航指引牛导航实用工具导航聚BT聚BT - 聚合最优质的BT、磁力资源ShareHubShareHub - 资源和工具的集合狼牌工作网址导航工具，资源，方法，All IN ONE的办公工作网址导航计算几何xuetangx邓俊辉老师的《计算几何》Tsinghua Online Judge邓俊辉老师的《计算几何》上机练习C++LearnCppC++基础教学Project Based Learninggithub中C++项目式学习CTOLIBC/C++开发项目(中文)STLSTL入门教程(中文)cppreferenceC/C++ API 文档写作坚果云好用的文件自动同步，再也不担心typora出bugfont awesomeicon图标TEA写作软件极简又极其强大的笔记应用关注的博客知名博客随机推荐推荐一些比较知名的程序开发大神和团队博客、他们的github和他们网站等，跟随大神的脚步，学习最新的程序开发知识，时刻让自己走在前面！欢迎邮箱推荐或者自荐酷壳-陈皓一个IT技术技术性BLOG。是一个分享技术见闻，知识，趋势的网站。阮一峰大佬分享IT技术、以及其他感悟廖雪峰廖雪峰的官方网站 -git教程 & 研究互联网产品和技术，提供原创中文精品教程演算法笔记诸如图论、数论、计算几何、数值方法、资料处理、诸如自然语言处理、声音处理、影像处理、计算机图学 …… 常用网址我的云书签将本地的浏览器的收藏夹转化为云书签Stack Overflow全球最受程序员欢迎的开发社区 公众号&写作微信公众平台公众号管理135编辑器功能强大的微信公众号文章排版编辑器坚果云好用的文件自动同步，再也不担心typora出bugfont awesomeicon图标TEA写作软件极简又极其强大的笔记应用COPYRIGHT 2020 - 2020 WEBSTACK 丨 DESIGNED BY VIGGO 丨 CHANGED BY longlongqin​ ​$(document).ready(function(){return $(document).on(\"click\",\".has-sub\",function(){var e=$(this);$(this).hasClass(\"expanded\")?$(\".has-sub ul\").each(function(s,i){var t=$(this);e.find(\"ul\")[0]!=i&&setTimeout(function(){t.attr(\"style\",\"\")},300)}):setTimeout(function(){e.find(\"ul\").attr(\"style\",\"\")},300)}),$(\".user-info-menu .hidden-sm\").click(function(){$(\".sidebar-menu\").hasClass(\"collapsed\")?$(\".has-sub.expanded > ul\").attr(\"style\",\"\"):$(\".has-sub.expanded > ul\").show()}),$(\"#main-menu li ul li\").click(function(){$(this).siblings(\"li\").removeClass(\"active\"),$(this).addClass(\"active\")}),$(\"a.smooth\").click(function(s){s.preventDefault(),public_vars.$mainMenu.add(public_vars.$sidebarProfile).toggleClass(\"mobile-is-visible\"),ps_destroy(),$(\"html, body\").animate({scrollTop:$($(this).attr(\"href\")).offset().top-30},{duration:500,easing:\"swing\"})}),!1});var href=\"\",pos=0;$(\"a.smooth\").click(function(s){$(\"#main-menu li\").each(function(){$(this).removeClass(\"active\")}),$(this).parent(\"li\").addClass(\"active\"),s.preventDefault(),href=$(this).attr(\"href\"),pos=$(href).position().top-30})!function(e){var c=Array.prototype.slice.call(document.querySelectorAll(\"img[data-original]\"));function i(){for(var r=0;r"}],"posts":[{"title":"C&C++/调试c++程序","slug":"C&C++/调试c++程序","date":"2020-06-01T02:16:27.348Z","updated":"2020-06-01T14:26:13.452Z","comments":true,"path":"archives/50be15c2.html","link":"","permalink":"https://longlongqin.github.io/archives/50be15c2.html","excerpt":"","text":"语法和语义错误原文：https://www.learncpp.com/cpp-tutorial/syntax-and-semantic-errors/软件错误非常普遍。制作它们很容易，但要找到它们却很难。在本章中，我们将探索与在我们的c++程序中发现和清除bug相关的主题，包括学习如何使用集成调试器(IDE的一部分)。当根据c++语言的语法编写无效的语句时，会发生语法错误。这包括错误，如缺少分号，使用未声明的变量，不匹配的括号或大括号等。例如，下面的程序包含相当多的语法错误:1234567#include &lt;iostream&gt; int main()&#123; std::cout &lt; \"Hi there\"; &lt;&lt; x; // invalid operator (&lt;), extraneous semicolon, undeclared variable (x) return 0 // missing semicolon at end of statement&#125;幸运的是，编译器通常会捕获语法错误并生成警告或错误，因此您可以轻松地识别和修复问题。然后只需重新编译，直到消除所有错误。一旦你的程序正确编译，让它实际产生你想要的结果可能会很棘手。当语句在语法上有效，但没有按照程序员的意图执行时，就会发生语义错误。123456789#include &lt;iostream&gt; int main()&#123; int a = 10; int b = 0; std::cout &lt;&lt; a &lt;&lt; \" / \" &lt;&lt; b &lt;&lt; \" = \" &lt;&lt; a / b; // 除0没有定义 return 0;&#125;现代编译器已经能够更好地检测某些类型的常见语义错误(例如使用未初始化的变量)。然而，在大多数情况下，编译器将无法捕获大多数这类问题，因为编译器的设计目的是加强语法，而不是意图。在上面的例子中，错误是很容易发现的。但是在大多数重要的程序中，通过肉眼观察代码不容易发现语义错误。这就是调试技术可以派上用场的地方。调试过程原文：https://www.learncpp.com/cpp-tutorial/the-debugging-process/假设您编写了一个程序，但是它不能正确地工作——代码编译得很好，但是当您运行它时，您将得到一个不正确的结果。你一定在什么地方犯了语义错误。你怎么找到它的?如果您一直遵循最佳实践，编写一些代码，然后对其进行测试，那么您可能已经很清楚错误在哪里了。或者你可能完全没有线索。调试的一般方法一旦发现问题，调试问题通常包括五个步骤:找出问题的根本原因(通常是不能工作的代码行)确保您理解问题发生的原因决定如何解决这个问题修复导致问题的问题重新测试以确保问题已经解决，没有出现新的问题练习：12345678910111213#include &lt;iostream&gt; // Adds two numbersint add(int x, int y)&#123; return x - y; // function is supposed to add, but it doesn't&#125; int main()&#123; std::cout &lt;&lt; add(5, 3) &lt;&lt; '\\n'; // should produce 8, but produces 2 return 0;&#125;这段代码有一点很好: 错误非常明显，因为错误的答案通过第11行打印到屏幕上。这为我们的调查提供了一个起点。Find the root cause: On line 11, we can see that we’re passing in literals for arguments (5 and 3), so there is no room for error there. Since the inputs to function add are correct, but the output isn’t, it’s pretty apparent that function add must be producing the wrong value. The only statement in function add is the return statement, which must be the culprit. We’ve found the problem line. Now that we know where to focus our attention, noticing that we’re subtracting instead of adding is something you’re likely to find via inspection.Understand the problem: In this case, it’s obvious why the wrong value is being generated – we’re using the wrong operator.Determine a fix: We’ll simply change operator- to operator+.Repair the issue: This is actually changing operator- to operator+ and ensuring the program recompiles.Retest: After implementing the change, rerunning the program will indicate that our program now produces the correct value of 8. For this simple program, that’s all the testing that’s needed.This example is trivial, but illustrates the basic process you’ll go through when diagnosing any program.调试策略原文：https://www.learncpp.com/cpp-tutorial/a-strategy-for-debugging/在调试程序时，在大多数情况下，您的大部分时间都将花在寻找错误的实际位置上。一旦发现了问题，剩下的步骤 (修复问题并验证问题是否已修复) 相比之下通常是微不足道的。通过代码检查发现问题假设你注意到一个问题，你想要找出这个问题的原因。在许多情况下(特别是在较小的程序中)，我们可以很快确定问题所在。然而，随着程序变得越来越复杂，通过代码检查发现问题也变得越来越复杂。首先，有更多的代码需要查看。在一个有数千行代码的程序中，查看每一行代码都要花费很长的时间(更不用说它是非常无聊的)。其次，代码本身往往更复杂，出错的地方也更多。第三，代码的行为可能不会给您提供很多关于哪里出了问题的线索。如果你写了一个程序来输出股票推荐，但实际上它什么也没输出，你可能就不知道从哪里开始寻找问题了。最后，错误可能是由于错误的假设造成的。几乎不可能从视觉上发现由错误假设引起的错误，因为在检查代码时，您可能会做出相同的错误假设，而不会注意到错误。因此，如果我们有一个问题，我们不能通过代码检查发现，我们如何找到它?通过运行程序发现问题幸运的是，如果我们不能通过代码检查发现问题，那么我们可以采用另一种方法:我们可以观察程序运行时的行为，并尝试从中诊断问题。这种方法可以概括为:找出重现问题的方法运行程序并收集信息以缩小问题所在重复前面的步骤，直到找到问题为止在本章的其余部分，我们将讨论促进这种方法的技术。重现问题发现问题的第一步也是最重要的一步是能够重现问题。原因很简单: 除非你能观察到问题的发生，否则很难发现问题。关注问题一旦我们可以合理地重现问题，下一步就是找出问题在代码的什么地方。根据问题的性质，这可能是容易的，也可能是困难的。基本的调试策略调试策略#1:注释掉代码如果程序显示出错误行为，减少必须搜索的代码量的一种方法是注释一些代码，看看问题是否仍然存在。如果问题仍然存在，注释掉的代码不负责。123456789int main()&#123; getNames(); // ask user to enter a bunch of names doMaintenance(); // do some random stuff sortNames(); // sort them in alphabetical order printNames(); // print the sorted list of names return 0; &#125;让我们假设这个程序应该按字母顺序打印用户输入的名称，但是它按相反的字母顺序打印它们。问题在哪里?它可以是上面的代码中的任何一个。但是我们可能怀疑doMaintenance();与这个问题没有任何关系，所以让我们注释掉它。123456789int main()&#123; getNames(); // ask user to enter a bunch of names// doMaintenance(); // do some random stuff sortNames(); // sort them in alphabetical order printNames(); // print the sorted list of names return 0;&#125;如果问题消失了，那么问题一定是由doMaintenance引起的，我们应该把注意力集中在维护上。但是，如果问题仍然存在(这种可能性更大)，那么我们就知道doMaintenance并不是错误，我们可以将该函数排除在外。这并不能帮助我们理解实际的问题是在对doMaintenance的调用之前还是之后，但是它减少了我们随后要检查的代码量。不要忘记您注释掉了哪些函数，以便稍后取消注释!调试策略#2:验证代码流在更复杂的程序中常见的另一个问题是，程序调用一个函数的次数太多或太少(包括完全不调用)。在这种情况下，将语句放在函数的顶部以打印函数名是很有帮助的。这样，当程序运行时，您就可以看到调用了哪些函数。当打印用于调试的信息时，使用std::cerr而不是std::cout。这样做的一个原因是std::cout可能会被缓冲，这意味着在您请求std::cout输出信息和它实际执行输出信息之间可能会有一个停顿。如果您使用std::cout输出，然后您的程序立即崩溃，那么std::cout可能还没有实际输出。这可能会误导你问题在哪里。另一方面，std::cerr是无缓冲的，这意味着您发送给它的任何内容都会立即输出。这有助于确保所有调试输出尽快出现(以牺牲某些性能为代价，我们通常在调试时并不关心这些性能)。如：12345678910111213#include &lt;iostream&gt; int getValue()&#123; return 4;&#125; int main()&#123; std::cout &lt;&lt; getValue; return 0;&#125;虽然我们希望这个程序打印值4，但它实际上会在不同的机器上打印不同的值。在作者的机器上，它打印:100101424让我们在这些函数中添加一些调试语句:123456789101112131415#include &lt;iostream&gt; int getValue()&#123;std::cerr &lt;&lt; \"getValue() called\\n\"; return 4;&#125; int main()&#123;std::cerr &lt;&lt; \"main() called\\n\"; std::cout &lt;&lt; getValue; return 0;&#125;在添加临时调试语句时，最好不要缩进它们。这使得以后更容易找到它们并移除。现在，当这些函数执行时，它们将输出它们的名称，表明它们被调用:12main() called00101424现在我们可以看到函数getValue从未被调用。调用函数的代码一定有问题。让我们仔细看看这句话:1std::cout &lt;&lt; getValue;看，我们忘了函数调用的括号了。应该是:123456789101112131415#include &lt;iostream&gt; int getValue()&#123;std::cerr &lt;&lt; \"getValue() called\\n\"; return 4;&#125; int main()&#123;std::cerr &lt;&lt; \"main() called\\n\"; std::cout &lt;&lt; getValue(); // added parenthesis here return 0;&#125;这将生成正确的输出：123main() calledgetValue() called4我们可以删除临时调试语句。调试策略#3:打印值对于某些类型的错误，程序可能正在计算或传递错误的值。我们还可以输出变量(包括参数)或表达式的值，以确保它们是正确的。考虑下面的程序，它本应该添加两个数字，但却不能正确工作:1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt; int add(int x, int y)&#123; return x + y;&#125; void printResult(int z)&#123; std::cout &lt;&lt; \"The answer is: \" &lt;&lt; z &lt;&lt; '\\n';&#125; int getUserInput()&#123; std::cout &lt;&lt; \"Enter a number: \"; int x&#123;&#125;; std::cin &gt;&gt; x; return x;&#125; int main()&#123; int x&#123; getUserInput() &#125;; int y&#123; getUserInput() &#125;; std::cout &lt;&lt; x &lt;&lt; \" + \" &lt;&lt; y &lt;&lt; '\\n'; int z&#123; add(x, 5) &#125;; printResult(z); return 0;&#125;下面是这个程序的一些输出:1234Enter a number: 4Enter a number: 34 + 3The answer is: 9这是不正确的。看到错误了吗?即使在这个简短的程序中，也很难发现它。让我们添加一些代码来调试我们的值:1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt; int add(int x, int y)&#123; return x + y;&#125; void printResult(int z)&#123; std::cout &lt;&lt; \"The answer is: \" &lt;&lt; z &lt;&lt; '\\n';&#125; int getUserInput()&#123; std::cout &lt;&lt; \"Enter a number: \"; int x&#123;&#125;; std::cin &gt;&gt; x; return x;&#125; int main()&#123; int x&#123; getUserInput() &#125;;std::cerr &lt;&lt; \"main::x = \" &lt;&lt; x &lt;&lt; '\\n'; int y&#123; getUserInput() &#125;;std::cerr &lt;&lt; \"main::y = \" &lt;&lt; y &lt;&lt; '\\n'; std::cout &lt;&lt; x &lt;&lt; \" + \" &lt;&lt; y &lt;&lt; '\\n'; int z&#123; add(x, 5) &#125;;std::cerr &lt;&lt; \"main::z = \" &lt;&lt; z &lt;&lt; '\\n'; printResult(z); return 0;&#125;这是上面的输出:1234567Enter a number: 4main::x = 4Enter a number: 3main::y = 34 + 3main::z = 9The answer is: 9变量x和y得到了正确的值，但变量z没有。问题必须在这两点之间，这使得函数add()成为一个关键问题。让我们修改函数add:123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt; int add(int x, int y)&#123;std::cerr &lt;&lt; \"add() called (x=\" &lt;&lt; x &lt;&lt;\", y=\" &lt;&lt; y &lt;&lt; \")\" &lt;&lt; '\\n'; //⭐ return x + y;&#125; void printResult(int z)&#123; std::cout &lt;&lt; \"The answer is: \" &lt;&lt; z &lt;&lt; '\\n';&#125; int getUserInput()&#123; std::cout &lt;&lt; \"Enter a number: \"; int x&#123;&#125;; std::cin &gt;&gt; x; return x;&#125; int main()&#123; int x&#123; getUserInput() &#125;;std::cerr &lt;&lt; \"main::x = \" &lt;&lt; x &lt;&lt; '\\n'; int y&#123; getUserInput() &#125;;std::cerr &lt;&lt; \"main::y = \" &lt;&lt; y &lt;&lt; '\\n'; std::cout &lt;&lt; x &lt;&lt; \" + \" &lt;&lt; y &lt;&lt; '\\n'; int z&#123; add(x, 5) &#125;;std::cerr &lt;&lt; \"main::z = \" &lt;&lt; z &lt;&lt; '\\n'; printResult(z); return 0;&#125;123456789Now we’ll get the output:Enter a number: 4main::x = 4Enter a number: 3main::y = 3add() called (x=4, y=5)main::z = 9The answer is: 9变量y的值是3，但是我们的函数add却得到了参数y的值5，我们一定是传递了错误的参数。果然:1int z&#123; add(x, 5) &#125;;在这里。我们传递的是文字5，而不是变量y的值作为参数。这是一个简单的修复，然后我们可以删除调试语句。为什么使用 打印语句 进行调试不是很好虽然将调试语句添加到用于诊断的程序中是一种常见的基本技术，也是一种功能性技术(特别是当调试器由于某种原因不可用时)，但它并不是很好，原因如下:调试语句使代码混乱。调试语句会使程序的输出变得混乱。在使用完调试语句之后，必须删除它们，这使得它们不可重用。调试语句需要修改代码来添加和删除，这可能会引入新的错误。我们可以做得更好。我们将在以后的课程中探索如何做到这一点。更多的调试策略对调试代码进行条件化考虑以下包含一些调试语句的程序:12345678910111213141516171819#include &lt;iostream&gt; int getUserInput()&#123;std::cerr &lt;&lt; \"getUserInput() called\\n\"; std::cout &lt;&lt; \"Enter a number: \"; int x&#123;&#125;; std::cin &gt;&gt; x; return x;&#125; int main()&#123;std::cerr &lt;&lt; \"main() called\\n\"; int x&#123; getUserInput() &#125;; std::cout &lt;&lt; \"You entered: \" &lt;&lt; x; return 0;&#125;当您完成调试语句时，您将需要删除它们，或者注释掉它们。然后，如果您稍后还想要它们，就必须将它们添加回去，或者取消注释。一种更容易在程序中禁用和启用调试的方法是使用预处理器指令使调试语句有条件:12345678910111213141516171819202122232425#include &lt;iostream&gt; #define ENABLE_DEBUG // 注释出以禁用调试 int getUserInput()&#123;#ifdef ENABLE_DEBUG //⭐std::cerr &lt;&lt; \"getUserInput() called\\n\";#endif //⭐ std::cout &lt;&lt; \"Enter a number: \"; int x&#123;&#125;; std::cin &gt;&gt; x; return x;&#125; int main()&#123;#ifdef ENABLE_DEBUG //⭐std::cerr &lt;&lt; \"main() called\\n\";#endif //⭐ int x&#123; getUserInput() &#125;; std::cout &lt;&lt; \"You entered: \" &lt;&lt; x; return 0;&#125;现在，我们可以通过 注释/取消注释 #define ENABLE_DEBUG 来启用调试。这允许我们重用以前添加的调试语句，然后在使用它们时禁用它们，而不必从代码中实际删除它们。如果这是一个多文件程序，那么#define ENABLE_DEBUG将位于一个头文件中，该头文件包含在所有代码文件中，因此我们可以在单个位置 注释/取消注 释#define，并让它传播到所有代码文件。这解决了必须删除调试语句的问题和这样做的风险：但代价是代码更加混乱。这种方法的另一个缺点是，如果您输入错误(例如拼错“DEBUG”)或忘记将头文件包含到代码文件中，那么可能无法启用该文件的部分或全部调试。使用一个日志记录器通过预处理程序进行条件化调试的另一种方法 是将调试信息发送到日志文件。日志文件是一个记录软件中发生的事件的文件(通常存储在磁盘上)。将信息写入日志文件的过程称为日志记录。大多数应用程序和操作系统编写的日志文件可用于帮助诊断发生的问题。日志文件有一些优点：因为写入日志文件的信息与程序的输出是分开的，所以可以避免将正常输出和调试输出混合在一起所造成的混乱。日志文件也可以很容易地发送给其他人进行诊断——因此，如果使用您的软件的人遇到问题，您可以让他们将日志文件发送给您，这可能会帮助您了解问题所在。虽然可以编写自己的代码来创建日志文件并向它们发送输出，但是最好使用现有的第三方日志工具之一。你用哪一个取决于你。为了便于说明，我们将展示使用plog日志记录器输出到日志记录器的内容。Plog是作为一组头文件实现的，因此很容易在任何需要的地方包含它，而且它是轻量级的，易于使用。如何使用plog日志记录器If you want to compile the above example yourself, or use plog in your own projects, you can follow these instructions to install it:First, get the latest plog release:Visit the plog repo.Click the “releases” tab (it’s in the same row as “commits”, “branches”, “packages”, etc…)Under the release tagged as “latest release” on the left, click the link “Source code (zip)” to download the latest release.Next, unzip the entire archive to `` on your hard drive.Finally, for each project, set the \\plog-\\include\\ directory as an include directory inside your IDE. There are instructions on how to do this for Visual Studio here: A.2 – Using libraries with Visual Studio and Code::Blocks here: A.3 – Using libraries with Code::Blocks.使用集成调试器: 单步调试原文：https://www.learncpp.com/cpp-tutorial/using-an-integrated-debugger-stepping/当您运行程序时，执行从主函数的顶部开始，然后一个语句接着一个语句地执行，直到程序结束。在任何时候当你的程序运行时,程序跟踪很多事情：你使用的变量的值，调用了哪些函数(当这些函数返回,程序将知道回到)，以及程序内的当前执行点(所以它知道这语句执行下一个)。所有这些被跟踪的信息都称为您的程序状态(或者简称为状态)。在以前的课程中，我们探讨了各种修改代码以帮助调试的方法，包括打印诊断信息或使用日志记录器。这些是在程序运行时检查程序状态的简单方法。尽管这些方法如果使用得当是有效的，但是它们仍然有缺点:它们需要修改代码，这需要时间，并且可能会引入新的错误，而且它们会使代码变得混乱，使现有的代码更难理解。到目前为止，我们所展示的技术背后有一个未阐明的假设:一旦我们运行代码，它就会运行到完成(只有在接受输入时才会暂停)，而我们没有机会在任何我们想要的地方干预和检查程序的结果。但是，如果我们能够去掉这个假设呢?幸运的是,我们可以。大多数现代IDE都带有一个集成的工具，称为调试器，它的设计目的就是实现这一点。调试器调试器是一种计算机程序，它允许程序员控制程序的执行方式，并在程序运行时检查程序状态。例如，程序员可以使用调试器逐行执行程序，同时检查变量的值。通过比较变量的实际值和预期值，或者观察代码的执行路径，调试器可以极大地帮助跟踪语义(逻辑)错误。调试器背后的强大功能有两方面：精确控制程序执行的能力；以及 查看(和修改，如果需要)程序状态的能力。早期的调试器(如gdb)是具有命令行接口的独立程序，程序员必须在命令行中输入晦涩难懂的命令才能工作。后来的调试器(例如Borland的 turbo debugger的早期版本)仍然是独立的，但是有了自己的“图形化”前端，使得使用它们更加容易。现在，大多数现代ide都有集成的调试器——也就是说，调试器使用与代码编辑器相同的接口，因此可以使用编写代码时使用的环境进行调试(而不必切换程序)。几乎所有现代调试器都包含相同的基本特性标准集——然而，在如何安排菜单来访问这些功能方面几乎没有一致性，键盘快捷键的一致性就更少了。本章的其余部分将用于学习如何使用调试器。不要忽视学习使用调试器。随着程序变得越来越复杂，与查找和修复问题所节省的时间相比，学习如何有效地使用集成调试器所花费的时间就显得微不足道了。Step intoIn Visual Studio, the step into command can be accessed via Debug menu &gt; Step Into, or by pressing the F11 shortcut key.step into命令在程序的正常执行路径中执行下一个语句，然后暂停程序的执行，以便我们可以使用调试器检查程序的状态。如果正在执行的语句包含一个函数调用，单步执行会导致程序跳转到正在调用的函数的顶部，并在那里暂停。当你的程序不运行，你执行第一个调试命令，你可能会看到相当多的事情发生:如果需要，程序将重新编译。程序将开始运行。因为我们的应用程序是一个控制台程序，所以应该打开控制台输出窗口。它将是空的，因为我们还没有输出任何东西。您的IDE可能会打开一些诊断窗口，这些窗口的名称可能是“诊断工具”、“调用堆栈”和“监视”。稍后我们将介绍其中的一些内容—现在您可以忽略它们。Step overIn Visual Studio, the step over command can be accessed via Debug menu &gt; Step Over, or by pressing the F10 shortcut key.与step into类似，step over命令在程序的正常执行路径中执行下一条语句。但是，step into将输入函数调用并逐行执行它们，而step over将执行整个函数而不停止并在函数执行后将控制权返回给您。Step outIn Visual Studio, the step out command can be accessed via Debug menu &gt; Step Out, or by pressing the Shift-F11 快捷键组合.与其他两个单步执行命令不同，Step out不只是执行下一行代码。相反，它执行当前正在执行的函数中的所有剩余代码，然后在函数返回时将控制权返回给您。Step back一些调试器(如Visual Studio Enterprise Edition和GDB 7.0)引入了单步调试功能，通常称为单步后退或反向调试（step back or reverse debugging）。Step back的目的是回退最后一步，这样您就可以将程序返回到先前的状态。如果您执行的操作超过了一步，或者您想重新检查刚刚执行的语句，那么这将非常有用。由于其复杂性，这种功能还没有标准化，并且会因调试器的不同而有所不同。截止到编写本文时(2019年1月)，Visual Studio Community edition和最新版本的Code::Blocks都不支持这种功能。希望在未来的某个时候，它会慢慢渗透到这些产品中，并被更广泛的使用。使用集成调试器: 运行和断点运行到光标处第一个有用的命令通常称为Run to cursor（运行到光标处）。这个Run to cursor命令执行程序，直到执行到光标所选择的语句为止。然后，它将控制权返回给您，以便您可以从该点开始调试。这是一种高效的方式，可以在代码中的特定点开始调试，或者如果已经在调试，则可以直接移动到需要进一步检查的位置。For Visual Studio users在Visual Studio中，右击代码中的语句并从上下文菜单中选择run to cursor，或者按下ctrl-F10组合键，就可以访问run to cursor命令。Continue在调试会话进行到一半时，您可能希望从那时开始运行程序。最简单的方法是使用continue命令。continue 调试命令只是继续按正常方式运行程序，直到程序终止，或者直到有东西触发控件再次返回给您(例如断点，我们将在本课后面介绍)。For Visual Studio users在Visual Studio中，可以通过Debug menu&gt; continue 或 按F5快捷键在调试程序时访问continue命令。Startcontinue命令有一个名为start的孪生兄弟。start命令执行与continue相同的操作，只是从程序的开头开始。它只能在不在调试会话中调用。在Visual Studio中，可以在不调试程序的情况下通过 Debug menu &gt; start debugging 或按下F5快捷键来访问start命令。断点本节要讨论的最后一个主题是断点。断点是一种特殊的标记，它告诉调试器在调试模式下运行时，在断点处停止程序的执行。For Visual Studio users在Visual Studio中,可以通过设置或删除断点 Debug menu &gt; Toggle Breakpoint, 或右键单击一个语句, 从上下文菜单中选择Toggle breakpoint或按 F9快捷键,或通过点击左边的行号(浅灰色区域)。设置下一条语句还有一个调试命令使用得非常不常见，但至少值得了解，即使您不经常使用它。设置下一条语句 命令允许我们将执行点更改为其他一些语句(有时也称为跳转)。这可以用来向前跳转执行点，跳过一些本来要执行的代码，或者向后跳转，让已经执行的代码重新运行。For Visual Studio users在Visual Studio中，您可以通过右键单击一个语句并从上下文菜单中选择Set next statement，或者按下Ctrl-Shift-F10快捷组合键来跳过执行点。此选项与上下文相关，仅在已经调试程序时才会出现。注意：set next statement 命令将更改执行点，但不会更改程序状态。您的变量将保留它们在跳转之前的任何值。因此，与其他情况相比，跳转可能会导致程序产生不同的值、结果或行为。明智地使用此功能(特别是向后跳转)。不应该使用set next statement 将执行点更改为其他函数。这将导致未定义的行为，并可能导致崩溃。小结现在，您了解了使用集成调试器监视和控制程序执行方式的主要方法。虽然这些命令对于诊断代码流问题非常有用(例如，确定是否调用某些函数)，但是它们只是集成调试器给表带来的好处的一部分。在下一课中，我们将开始探索检查程序状态的其他方法，您将需要这些命令作为先决条件。我们走吧!使用集成调试器: 监视变量监视变量监视变量是在程序以调试模式执行时检查变量值的过程。大多数调试器都提供了几种方法来实现这一点。检查简单变量(如x) 值的最简单方法是将鼠标悬停在变量x上。一些现代调试器支持这种检查简单变量的方法，这是最直接的方法。注意，您可以将鼠标悬停在任何变量x上，而不仅仅是当前行上的变量x。例如，如果我们将鼠标悬停在第12行x上，我们将看到相同的值:如果你在使用Visual Studio，你也可以使用QuickWatch。用鼠标高亮显示变量名x，然后从右键菜单中选择“QuickWatch”。这将打开一个包含变量当前值的子窗口:如果你打开了QuickWatch，请关闭它监视窗口如果你想知道一个变量的值在一个特定的时间点 ，使用鼠标悬停或QuickWatch方法检查变量很好。但是，它并不特别适合在运行代码时监视变量更改的值，因为您必须不断地 重新悬停/重新选择变量。为了解决这个问题，所有现代集成调试器都提供了另一个特性，称为监视窗口。监视窗口是一个窗口，您可以在其中添加您想要持续检查的变量，并且当您单步执行程序时，这些变量将被更新。当您进入调试模式时，监视窗口可能已经在您的屏幕上了，但是如果不是这样，您可以通过IDE的窗口命令(通常在视图或调试菜单中可以找到这些命令)打开它。For Visual Studio users在Visual Studio中，Debug menu &gt; Windows &gt; Watch &gt; Watch 1. 中可以找到监视菜单。请注意，要启用此选项，必须处于调试模式，因此请先进入程序。此窗口出现的位置(停靠左、右或底部)可能不同。您可以通过将Watch 1选项卡拖动到应用程序窗口的另一侧来更改其停靠位置。超出作用域的变量(例如，函数中已经返回给调用者的局部变量)将留在您的监视窗口中，但通常要么被标记为“不可用”，要么显示最后一个已知值，但显示为灰色。如果变量返回到作用域(例如再次调用函数)，它的值将再次显示。因此，即使变量不在监视范围内，也可以将它们留在监视窗口中。监视窗口可以计算表达式监视窗口还允许计算简单表达式。局部监视因为在调试时检查函数内部局部变量的值是很常见的，所以许多调试器会提供某种方式来快速监视 作用域中所有局部变量的值。For Visual Studio users在Visual Studio中，可以在局部变量窗口中看到所有局部变量的值，可以在Debug menu &gt; Windows &gt; Locals 中找到。请注意，您必须处于调试会话中才能激活此窗口。使用集成调试器: 调用栈现代调试器还包含一个调试信息窗口，它在调试程序时非常有用，即调用堆栈窗口。当您的程序调用一个函数时，您已经知道它标记了当前位置，进行了函数调用，然后返回。它怎么知道回到哪里去? 答案是它在调用堆栈中保持跟踪。调用堆栈是所有已被调用以到达当前执行点的活动函数的列表。调用堆栈包括每个被调用函数的条目，以及函数返回时将返回到哪一行代码。每当调用一个新函数时，该函数都会被添加到调用堆栈的顶部。当 当前函数返回给调用方时，它将从调用堆栈的顶部移除，而控制将返回给它下面的函数。“调用堆栈”窗口是一个显示当前调用堆栈的调试器窗口。如果没有看到“调用堆栈”窗口，则需要告诉IDE显示它。For Visual Studio users在Visual Studio中，可以通过 Debug menu &gt; Windows &gt; Call Stack。请注意，您必须处于调试会话中才能激活此窗口。祝贺您，现在您已经了解了使用集成调试器的基本知识!通过使用单步执行、断点、监视和调用堆栈窗口，您现在已经具备了调试几乎所有问题的基础知识。像许多事情一样，要想熟练使用调试器，需要一些实践和反复试验。但是，我们再次重申，花在学习如何有效使用集成调试器上的时间将比花在调试程序上的时间节省许多倍!在问题变成问题之前找到问题当您犯语义错误时，当您运行程序时，这个错误可能不会立即被发现。一个问题可能潜伏在你的代码中很长一段时间都没有被发现，直到新引入的代码或改变的环境导致它作为程序故障出现。在找到错误之前，错误在代码库中停留的时间越长，就越有可能难以找到它，本来很容易修复的错误会变成一场耗费时间和精力的调试冒险。我们能做些什么呢?不要犯错误最好的办法是一开始就不要犯错误。这里有一个不完整的清单，可以帮助避免犯错误:遵循最佳实践累了就别编程了解一门语言中常见的陷阱(我们警告过你不要做的所有事情)保持程序简单不要让函数太长尽可能使用标准库而不是编写自己的代码。使用注释重构功能当您向程序添加新功能(“行为更改”)时，您会发现一些函数的长度在增加。随着函数变长，它们变得更加复杂和难以理解。解决这个问题的一种方法是将一个长函数分解成多个短函数。在不改变代码行为(通常是为了使其更易于维护)的情况下对代码进行结构更改的过程称为重构。那么对于一个函数，多长才算长呢?一个占据一个垂直屏幕的函数通常被认为太长——如果必须滚动才能阅读整个函数，那么函数的可理解性就会显著下降。但是越短越好——函数小于10行就很好。小于5行的函数甚至更好。介绍防御性编程错误不仅可能是您自己造成的(例如，不正确的逻辑)，还可能发生在您的用户以您没有预料到的方式使用应用程序时。例如，如果您要求用户输入一个整数，而用户输入的却是字母，那么在这种情况下，您的程序是如何运行的呢?除非您预料到了这一点，并为本例添加了一些错误处理，否则情况可能不太好。防御性编程是一种实践，程序员试图预测软件可能被最终用户或使用代码的其他开发人员(包括程序员自己)滥用的所有方式。这些误用通常可以被发现，然后减轻(例如，要求输入错误输入的用户重试)。我们将在以后的课程中探索与错误处理相关的主题。快速找到错误由于在大型程序中不出错是很困难的，所以下一个最好的方法就是快速捕获您确实犯的错误。最好的方法是每次编写一点程序，然后测试代码并确保它能正常工作。然而，还有一些其他的技术我们也可以使用。测试功能介绍帮助发现程序问题的一种常见方法是编写测试函数来“练习”所编写的代码。这里有一个原始的尝试，更多的是为了说明的目的比任何东西:12345678910111213141516171819202122#include &lt;iostream&gt; int add(int x, int y)&#123; return x + y;&#125; void testadd()&#123; std::cout &lt;&lt; \"This function should print: 2 0 0 -2\\n\"; std::cout &lt;&lt; add(1, 1) &lt;&lt; \" \"; std::cout &lt;&lt; add(-1, 1) &lt;&lt; \" \"; std::cout &lt;&lt; add(1, -1) &lt;&lt; \" \"; std::cout &lt;&lt; add(-1, -1) &lt;&lt; \" \";&#125; int main()&#123; testadd(); return 0;&#125;testadd()函数通过使用不同的值调用add()函数来测试它。如果所有的值都符合我们的期望，那么我们就可以合理地确信函数是有效的。更好的是，我们可以保留这个函数，并在每次更改函数add时运行它，以确保我们没有意外地破坏它。这是单元测试的基本形式，单元测试是一种软件测试方法，通过测试小单元的源代码来确定它们是否正确。与日志记录框架一样，可以使用许多第三方单元测试框架。也可以自己编写，不过我们需要更多的语言特性来处理主题。我们将在以后的课程中对此进行讨论。约束条件介绍基于约束的技术包括添加一些额外的代码(如果需要，可以在非调试版本中编译)，以检查是否违反了一些假设或期望。例如，如果我们编写一个函数来计算一个数字的阶乘，这个函数需要一个非负参数，那么该函数可以进行检查，以确保调用者在继续之前传入了一个非负的数字。如果调用方传入一个负数，那么函数可能会立即出错，而不是生成一些不确定的结果，从而帮助确保立即捕获问题。一种常见的方法是通过assert和static_assert，我们在7.12a – Assert and static_assert.中介绍了这两个方法。","categories":[],"tags":[]},{"title":"C&C++/静态与动态链接库","slug":"C&C++/静态与动态链接库","date":"2020-05-31T06:49:00.247Z","updated":"2020-06-01T01:09:23.341Z","comments":true,"path":"archives/d30baea4.html","link":"","permalink":"https://longlongqin.github.io/archives/d30baea4.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/a1-static-and-dynamic-libraries/库(library)是一个代码包，可以被许多程序重用。通常，一个c++库分为两部分:一个头文件，定义库向使用它的程序公开(提供)的功能。预编译的二进制文件，包含预编译成机器语言的功能的实现。一些库可能被分成多个文件和/或具有多个头文件。预编译库有几个原因：首先，由于库很少更改，它们不需要经常重新编译。每次编写使用它们的程序时都重新编译库是浪费时间。其次，因为预编译对象是机器语言的，所以它阻止人们访问或更改源代码，这对于企业或不希望出于知识产权原因而提供源代码的人来说非常重要。有两种类型的库:静态库动态库静态库静态库(也称为归档库(archive))由一些例程(routines)组成，这些例程被编译并直接链接到程序中。当您编译一个使用静态库的程序时，程序所使用的静态库的所有功能都将成为可执行文件的一部分。在Windows中，静态库通常有一个.lib扩展名；而在linux上，静态库通常有一个.a(存档)扩展名。静态库的一个优点是，您只需要分发可执行文件就可以让用户运行您的程序。因为静态库成为程序的一部分，这就确保了程序总是使用正确版本的库；此外，因为静态库成为程序的一部分，所以可以像使用为自己的程序编写的功能一样使用它们。不利的一面是，由于库的副本成为使用它的每个可执行文件的一部分，这会导致大量的空间浪费。静态库也不能轻松升级——要更新库，需要替换整个可执行文件。动态库动态库(也称为共享库)由在运行时加载到应用程序中的例程组成。当您编译使用动态库的程序时，该库不会成为可执行文件的一部分——它仍然是一个单独的单元。在Windows上，动态库通常有一个.dll(动态链接库)扩展名；而在Linux上，动态库通常有一个.so(共享对象)扩展名。动态库的一个优点是许多程序可以共享一个副本，这节省了空间。也许一个更大的优点是：动态库可以升级到一个新的版本，而不需要替换使用它的所有可执行文件。缺点：因为动态库没有链接到程序中，所以使用动态库的程序必须显式地加载动态库并与之交互。这种机制可能会让人感到困惑，并使与动态库的交互变得非常棘手。为了使动态库更易于使用，可以使用导入库( import library )。导入库是一个自动加载和使用动态库过程的库。在Windows上，这通常是通过一个与动态库(.dll)同名 的 小型静态库(.lib) 来完成的。静态库在编译时链接到程序中，然后动态库的功能 就可以 像静态库一样 有效地使用。在Linux上，共享对象(.so)文件同时充当 动态库 和 导入库 。大多数链接器 可以在创建动态库时 为 动态库构建导入库。安装和使用库现在您已经了解了不同种类的库，让我们讨论一下如何在程序中实际使用库。在c++中安装一个库通常需要4个步骤:获取库。最好的选择是为您的操作系统下载一个预编译包(如果存在的话)，这样您就不必自己编译库了。如果您的操作系统没有提供这样的包，那么您必须下载一个只包含源代码的包并自己编译它(这超出了本课的范围)。在Windows上，库通常以.zip文件的形式发布。在Linux上，库通常以包的形式发布(例如. rpm)。您的包管理器可能有一些比较流行的库(例如 SDL)。已经列出了，以便于安装，所以先检查一下。安装库。在Linux上，这通常涉及调用包管理器并让它完成所有工作。在Windows上，这通常涉及到将库解压缩到您选择的目录。我们建议将所有库保存在一个位置，以便于访问。例如，使用一个名为C:\\Libs的目录，并将每个库放在它自己的子目录中。确保编译器知道在哪里查找库的头文件。在Windows上，通常这是安装库文件到的目录的include子目录(例如。如果您将您的库安装到C:\\libs\\SDL-1.2.11，头文件可能在C:\\libs\\SDL-1.2.11\\include中)。在Linux上，头文件通常安装在/usr/include中，它应该已经是包含文件搜索路径的一部分。但是，如果文件安装在其他地方，则必须告诉编译器在哪里找到它们。告诉链接器在哪里查找库文件。与步骤3一样，这通常涉及将目录添加到链接器查找库的位置列表中。在Windows上，这通常是安装库文件的目录的/lib子目录。在Linux上，库通常安装在/usr/lib上，它应该已经是库搜索路径的一部分。一旦库被安装，IDE知道到哪里去找它，通常需要为每个想要使用库的项目执行以下3个步骤:如果使用静态库或导入库，请告诉链接器要链接哪个库文件。在程序中#include 库的头文件。这将告诉编译器库所提供的所有功能，以便您的程序能够正确地编译。如果使用动态库，请确保程序知道在哪里可以找到它们。在Linux下，库通常安装在/usr/lib中，它位于LD_LIBRARY_PATH环境变量中的路径之后的默认搜索路径中。在Windows上，默认的搜索路径包括：程序运行的目录、通过调用SetDllDirectory()设置的目录、Windows、System和System32目录以及path环境变量中的目录。使用.dll的最简单方法是将.dll复制到可执行文件的位置。由于您通常会将.dll与可执行文件一起发布，因此无论如何将它们放在一起都是有意义的。步骤3-5涉及到配置IDE——幸运的是，几乎所有ide在执行这些操作时都以相同的方式工作。不幸的是，因为每个IDE都有不同的接口，所以这个过程中最困难的部分就是找到执行这些步骤的正确位置。","categories":[],"tags":[]},{"title":"C&C++/文件的随机IO","slug":"C&C++/文件的随机IO","date":"2020-05-28T02:23:18.479Z","updated":"2020-05-28T02:52:50.593Z","comments":true,"path":"archives/60adc21f.html","link":"","permalink":"https://longlongqin.github.io/archives/60adc21f.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/187-random-file-io/文件指针类中的每个文件流类都包含一个文件指针，用于跟踪当前的读/写位置文件。当从文件中读取或写入文件时，读取/写入发生在文件指针的当前位置。默认情况，当打开文件进行读写操作时，文件指针被设置为文件的开头。但是，如果以追加模式打开文件，文件指针就会移动到文件的末尾，这样写入操作就不会覆盖文件的任何当前内容。使用seekg()和seekp()随机访问文件之前，我们访问的文件都是按顺序访问的。——也就是说，我们之前是按顺序读取或写入文件内容。但是，也可以进行随机文件访问。——即，跳过文件中的各个点，来读其内容。当您的文件中充满了记录，并且您希望检索特定的记录时，这将非常有用。随机访问文件 是通过seekg()函数(用于input) 和 seekp()函数(用于output) 来操作文件指针。其中：“g”表示：get ；“p”表示：put。对于某些类型的流、seekg()(更改读位置) 和 seekp()(更改写位置) 独立操作。但是对于，文件流：读和写位置总是相同的，所以可以使用seekg和seekp互换。seekg()和seekp()函数接受两个参数。第一个参数：是决定文件指针的偏移量。第二个参数：是一个Ios标志，它指定偏移量参数应该从哪里偏移。Ios seek flagMeaningbegthe offset is relative to the begining of the file(default)curthe offset is relative to the current location of the file pointerendthe offset is relative to the end of the file正偏移量意味着将文件指针移动到文件末尾，而负偏移意味着将文件指针移动指向文件开头。12345inf.seekg(14, ios::cur); // move forward 14 bytesinf.seekg(-18, ios::cur); // move backwards 18 bytesinf.seekg(22, ios::beg); // move to 22nd byte in fileinf.seekg(24); // move to 24th byte in fileinf.seekg(-28, ios::end); // move to the 28th byte before end of the file移动到文件的开头或结尾很容易:12inf.seekg(0, ios::beg); // move to beginning of fileinf.seekg(0, ios::end); // move to end of file例子让我们使用seekg()和我们在上一课中创建的输入文件来做一个示例。这个输入文件看起来像这样:1234This is line 1This is line 2This is line 3This is line 4下面是代码：123456789101112131415161718192021222324252627int main()&#123; using namespace std; ifstream inf(\"Sample.dat\"); // If we couldn't open the input file stream for reading if (!inf) &#123; // Print an error and exit cerr &lt;&lt; \"Uh oh, Sample.dat could not be opened for reading!\" &lt;&lt; endl; exit(1); &#125; string strData; inf.seekg(5); // move to 5th character // Get the rest of the line and print it getline(inf, strData); cout &lt;&lt; strData &lt;&lt; endl; inf.seekg(8, ios::cur); // move 8 more bytes into file // Get rest of the line and print it getline(inf, strData); cout &lt;&lt; strData &lt;&lt; endl; inf.seekg(-15, ios::end); // move 15 bytes before end of file // Get rest of the line and print it getline(inf, strData); cout &lt;&lt; strData &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[]},{"title":"C&C++/文件的基本IO","slug":"C&C++/文件的基本IO","date":"2020-05-28T00:48:44.911Z","updated":"2020-05-28T01:36:17.065Z","comments":true,"path":"archives/2926b12b.html","link":"","permalink":"https://longlongqin.github.io/archives/2926b12b.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/186-basic-file-io/c++中的文件I/O的工作方式与普通I/O非常相似(只是增加了一些细微的复杂性)。在c++中有3个基本的文件I/O类:（头文件fstream中）ifstream (derived from istream),ofstream (derived from ostream),fstream (derived from iostream).这些类分别执行文件 输入、输出和 输入/输出。与cout、cin、cerr和clog流不同，文件流必须由程序员显式地设置。然而，这非常简单:要打开文件进行读取 和/或 写入，只需实例化适当文件I/O类的一个对象，以文件的名称作为参数。然后使用插入(&lt;&lt;)或提取(&gt;&gt;)操作符来写入或读取文件中的数据。一旦你完成，有几种方法来关闭一个文件:显式调用close()函数，或者只需让文件I/O变量超出范围 (文件I/O类析构函数将为您关闭文件)。文件输出要在下面的示例中执行文件输出，我们将使用ofstream类。这是非常直接的:12345678910111213141516171819202122232425#include &lt;fstream&gt;#include &lt;iostream&gt; int main()&#123; // ofstream用于编写文件 //我们将创建一个名为Sample.dat的文件 std::ofstream outf&#123; \"Sample.dat\" &#125;; // 如果我们不能打开输出文件流进行写入 if (!outf) &#123; // 打印错误并退出 std::cerr &lt;&lt; \"Uh oh, Sample.dat could not be opened for writing!\" &lt;&lt; std::endl; return 1; &#125; // 我们将在这个文件中写入两行 outf &lt;&lt; \"This is line 1\" &lt;&lt; '\\n'; outf &lt;&lt; \"This is line 2\" &lt;&lt; '\\n'; return 0; // 当outf超出范围时，ofstream析构函数将关闭文件&#125;如果查看项目目录，应该会看到一个名为Sample.dat的文件。如果您使用文本编辑器打开它，您将看到它确实包含我们写入文件的两行。注意，也可以使用put()函数将单个字符写入文件。文件输入现在，我们将获取我们在上一个示例中编写的文件，并将其从磁盘读入。注意，如果我们到达了文件的末尾(EOF)， ifstream将返回0。我们将使用这个事实来决定需要读多少。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;string&gt; int main()&#123; // ifstream用于读取文件 // 我们将从一个名为Sample.dat的文件中进行读取 std::ifstream inf&#123; \"Sample.dat\" &#125;; // If we couldn't open the output file stream for reading if (!inf) &#123; // Print an error and exit std::cerr &lt;&lt; \"Uh oh, Sample.dat could not be opened for reading!\" &lt;&lt; std::endl; return 1; &#125; // 还有很多东西要读 while (inf) &#123; // 将文件中的内容读入一个字符串并打印出来 std::string strInput; inf &gt;&gt; strInput; std::cout &lt;&lt; strInput &lt;&lt; '\\n'; &#125; return 0; // When inf goes out of scope, the ifstream // destructor will close the file&#125;/*结果*/Thisisline1Thisisline2嗯，那不是我们想要的。请记住，提取操作符会在空格处中断。为了整行读取，我们必须使用getline()函数。123456789101112131415161718192021222324252627282930313233343536#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;string&gt; int main()&#123; // ifstream is used for reading files // We'll read from a file called Sample.dat std::ifstream inf&#123; \"Sample.dat\" &#125;; // If we couldn't open the input file stream for reading if (!inf) &#123; // Print an error and exit std::cerr &lt;&lt; \"Uh oh, Sample.dat could not be opened for reading!\\n\"; return 1; &#125; // While there's still stuff left to read while (inf) &#123; // read stuff from the file into a string and print it std::string strInput; std::getline(inf, strInput); //⭐⭐⭐ std::cout &lt;&lt; strInput &lt;&lt; '\\n'; &#125; return 0; // When inf goes out of scope, the ifstream // destructor will close the file&#125;/*结果*/This is line 1This is line 2缓冲输出c++的输出可以被缓冲。这意味着输出到文件流的任何内容都可能不会立即写入磁盘。相反，几个输出操作可以成批处理并一起处理。这主要是出于性能原因。刷新缓冲区当将缓冲区写入磁盘时，这称为刷新缓冲区。关闭文件使缓冲区被刷新的一种方法是关闭文件——缓冲区的内容将被刷新到磁盘，然后文件将被关闭。缓冲通常不是问题，但在某些情况下，它会给粗心大意的人带来麻烦。这种情况下的罪魁祸首是当缓冲区中有数据时，程序立即 终止(通过崩溃或调用exit())。在这些情况下，文件流类的析构函数不会被执行，这意味着文件永远不会被关闭，这意味着缓冲区永远不会被刷新。在这种情况下，缓冲区中的数据不写入磁盘，而是永远丢失。这就是为什么在调用exit()之前显式地关闭所有打开的文件总是一个好主意。手动刷新可以使用ostream::flush()函数手动刷新缓冲区，或者将std::flush发送到输出流。这两种方法都有助于确保缓冲区的内容被立即写入磁盘，以防程序崩溃。有趣的是std::endl; 也刷新输出流。因此，过度使用std::endl(导致不必要的缓冲区刷新) 会在执行开销很大的缓冲I/O(例如写入文件)时对性能造成影响。出于这个原因，关心性能的程序员通常会使用’ \\n ‘而不是std::endl来将换行符插入到输出流中，以避免不必要的缓冲区刷新。文件模式如果我们试图写入一个已经存在的文件，会发生什么? 再次运行输出示例 表明，每次运行程序时，原始文件都被完全覆盖。如果我们想要在文件的末尾追加更多的数据，该怎么办?结果是，文件流构造函数接受一个可选的第二个参数，该参数允许您指定有关文件应该如何打开的信息。这个参数称为mode，它接受的有效标志（位于Ios类中）。Ios file modeMeaningappOpens the file in append modeateSeeks to the end of the file before reading/writingbinaryOpens the file in binary mode (instead of text mode)inOpens the file in read mode (default for ifstream)outOpens the file in write mode (default for ofstream)truncErases the file if it already exists可以通过位操作(使用|操作符)指定多个标志。在文件模式下，Ifstream默认为std::ios::in；Ofstream默认为std::ios::out文件模式。fstream 默认为std::ios::in | std::ios::out文件模式，这意味着你可以在默认情况下读和写。让我们编写一个程序，在前面创建的Sample.dat文件中追加两行代码:1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;fstream&gt; int main()&#123; // 我们会传递ios:app标志告诉ofstream去追加 // 而不是重写文件。我们不需要通过std::ios::out // 因为ofstream默认std::ios::out std::ofstream outf&#123; \"Sample.dat\", std::ios::app &#125;; // If we couldn't open the output file stream for writing if (!outf) &#123; // Print an error and exit std::cerr &lt;&lt; \"Uh oh, Sample.dat could not be opened for writing!\\n\"; return 1; &#125; outf &lt;&lt; \"This is line 3\" &lt;&lt; '\\n'; outf &lt;&lt; \"This is line 4\" &lt;&lt; '\\n'; return 0; // When outf goes out of scope, the ofstream // destructor will close the file&#125;结果：1234This is line 1This is line 2This is line 3This is line 4使用open()显式打开文件就像可以使用close()显式地关闭文件流一样，也可以使用open()显式地打开文件流。open()的工作原理与文件流构造函数类似——它接受一个文件名和一个可选的文件模式。如：123456789std::ofstream outf&#123; \"Sample.dat\" &#125;;outf &lt;&lt; \"This is line 1\" &lt;&lt; '\\n';outf &lt;&lt; \"This is line 2\" &lt;&lt; '\\n';outf.close(); // 显式关闭文件// 追加一行outf.open(\"Sample.dat\", std::ios::app);outf &lt;&lt; \"This is line 3\\n\";outf.close();其他参考文章：https://www.runoob.com/cplusplus/cpp-files-streams.html","categories":[],"tags":[]},{"title":"C&C++/流状态和输入验证","slug":"C&C++/流状态和输入验证","date":"2020-05-27T09:55:34.276Z","updated":"2020-05-27T14:09:14.278Z","comments":true,"path":"archives/ba87b609.html","link":"","permalink":"https://longlongqin.github.io/archives/ba87b609.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/185-stream-states-and-input-validation/流状态ios_base类包含几个状态标志，用来指示使用流时可能发生的各种情况:FlagMeaninggoodbitEverything is okaybadbitSome kind of fatal error occurred (e.g. the program tried to read past the end of a file)eofbitThe stream has reached the end of a filefailbitA non-fatal error occurred (eg. the user entered letters when the program was expecting an integer)虽然这些标志存在于ios_base中，因为ios是从ios_base派生而来的，而且ios比ios_base需要更少的输入，但它们通常是通过ios访问的(例如std::ios::failbit)。ios还提供了一些成员功能，以便方便地访问这些国家:Member functionMeaninggood()Returns true if the goodbit is set (the stream is ok)bad()Returns true if the badbit is set (a fatal error occurred)eof()Returns true if the eofbit is set (the stream is at the end of a file)fail()Returns true if the failbit is set (a non-fatal error occurred)clear()Clears all flags and restores the stream to the goodbit stateclear(state)Clears all flags and sets the state flag passed inrdstate()Returns the currently set flagssetstate(state)Sets the state flag passed in最常处理的位是故障位 (failbit)，它是在用户输入无效输入时设置的。例如，考虑以下程序:123std::cout &lt;&lt; \"Enter your age: \";int nAge;std::cin &gt;&gt; nAge;注意，这个程序期望用户输入一个整数。但是，如果用户输入非数字数据，如“Alex”，cin将无法提取任何数据进行计数，并设置成故障位。如果出现错误，并且将流设置为goodbit以外的任何内容。则将忽略该流上的进一步流操作。这个条件可以通过调用clear()函数来清除。输入验证输入验证是检查用户输入是否满足某些条件的过程。输入验证通常可以分为两种类型: 字符串和数字。对于字符串验证，我们接受所有用户输入作为一个字符串，然后根据其格式是否正确接受或拒绝该字符串。在大多数语言中(特别是像Perl和PHP这样的脚本语言)，这是通过正则表达式完成的。但是，c++没有内置的正则表达式支持。因此，这通常是通过检查字符串的每个字符来完成的，以确保它满足一些条件。对于数字验证，我们通常关心的是确保用户输入的数字在一个特定的范围内(例如，在0到20之间)。但是，与字符串验证不同，用户可以输入完全不是数字的内容——我们也需要处理这些情况。为了帮助我们，c++提供了许多有用的函数，我们可以使用这些函数来确定特定字符是数字还是字母。cctype头文件中有以下函数:FunctionMeaningisalnum(int)Returns non-zero if the parameter is a letter or a digitisalpha(int)Returns non-zero if the parameter is a letteriscntrl(int)Returns non-zero if the parameter is a control characterisdigit(int)Returns non-zero if the parameter is a digitisgraph(int)Returns non-zero if the parameter is printable character that is not whitespaceisprint(int)Returns non-zero if the parameter is printable character (including whitespace)ispunct(int)Returns non-zero if the parameter is neither alphanumeric nor whitespaceisspace(int)Returns non-zero if the parameter is whitespaceisxdigit(int)Returns non-zero if the parameter is a hexadecimal digit (0-9, a-f, A-F)字符串验证让我们做一个简单的字符串验证，要求用户输入他们的名字。我们的验证标准是用户只输入字母字符或空格。如果遇到其他情况，输入将被拒绝。当涉及到可变长度输入时，验证字符串的最佳方法(除了使用正则表达式库之外)是遍历字符串的每个字符，并确保它满足验证标准。这就是我们要做的。1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cctype&gt;#include &lt;cstdint&gt;#include &lt;string&gt; #include &lt;iostream&gt; int main()&#123; while (true) &#123; // Get user's name std::cout &lt;&lt; \"Enter your name: \"; std::string strName; std::getline(cin, strName); // get the entire line, including spaces bool bRejected&#123; false &#125;; // has strName been rejected? // Step through each character in the string until we either hit // the end of the string, or we rejected a character for (std::size_t nIndex&#123; 0 &#125;; nIndex &lt; strName.length() &amp;&amp; !bRejected; ++nIndex) &#123; // If the current character is an alpha character, that's fine if (std::isalpha(strName[nIndex])) continue; // If it's a space, that's fine too if (strName[nIndex] == ' ') continue; // Otherwise we're rejecting this input bRejected = true; &#125; // If the input has been accepted, exit the while loop // otherwise we're going to loop again if (!bRejected) break; &#125;&#125;数值验证在处理数字输入时，最明显的方法是使用提取操作符将输入提取为数字类型。通过检查故障位，我们可以判断用户是否输入了数字。让我们试试这个方法:123456789101112131415161718192021222324int main()&#123; int nAge; while (true) &#123; std::cout &lt;&lt; \"Enter your age: \"; std::cin &gt;&gt; nAge; if (std::cin.fail()) // no extraction took place &#123; std::cin.clear(); // reset the state bits back to goodbit so we can use ignore() std::cin.ignore(32767, '\\n'); // clear out the bad input from the stream continue; // try again &#125; if (nAge &lt;= 0) // make sure nAge is positive continue; break; &#125; std::cout &lt;&lt; \"You entered: \" &lt;&lt; nAge &lt;&lt; '\\n';&#125;如果用户输入一个数字，cin.fail()将为false，我们将按break语句，退出循环。如果用户输入以字母开头的输入，cin.fail()将为真，我们将进入条件句。更多详细的讲解，请看原文。这里先不写，说不定以后会补上~~~~","categories":[],"tags":[]},{"title":"C&C++/字符串的流(stream)类","slug":"C&C++/字符串的流(stream)类","date":"2020-05-27T03:18:36.500Z","updated":"2020-05-27T03:39:57.831Z","comments":true,"path":"archives/4be6fd59.html","link":"","permalink":"https://longlongqin.github.io/archives/4be6fd59.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/184-stream-classes-for-strings/到目前为止，您看到的所有I/O示例都是写给cout或从cin读取的。然而，还有另一组类叫做字符串的流类，它允许您使用熟悉的 插入(&lt;&lt;) 和 提取(&gt;&gt;)操作符来处理字符串。与istream和ostream一样，字符串流提供了一个保存数据的缓冲区。但是，与cin和cout不同，这些流没有连接到I/O通道(例如键盘、监视器等)。字符串流的主要用途之一是缓冲输出以便以后显示，或者逐行处理输入。字符串有六个流类，：在头文件sstream中。用于读取和写入正常字符宽度的字符串。istringstream(继承自istream)，ostringstream(继承自ostream)，stringstream(继承自iostream)用于读取和写入宽字符串。wistringstreamwostringstreamwstringstream有两种方法可以将数据导入stringstream：使用插入(&lt;&lt;)操作符:12std::stringstream os;os &lt;&lt; \"en garde!\" &lt;&lt; '\\n'; // insert \"en garde!\" into the stringstream使用str(string)函数设置缓冲区的值:12std::stringstream os;os.str(\"en garde!\"); // set the stringstream buffer to \"en garde!\"从stringstream中获取数据有两种类似的方法:使用str()函数检索缓冲区的结果:123456std::stringstream os;os &lt;&lt; \"12345 67.89\" &lt;&lt; '\\n';cout &lt;&lt; os.str();/*结果*/12345 67.89使用提取(&gt;&gt;)操作符:1234567891011std::stringstream os;os &lt;&lt; \"12345 67.89\"; // insert a string of numbers into the stream std::string strValue;os &gt;&gt; strValue; std::string strValue2;os &gt;&gt; strValue2; // print the numbers separated by a dashstd::cout &lt;&lt; strValue &lt;&lt; \" - \" &lt;&lt; strValue2 &lt;&lt; '\\n';注意，&gt;&gt;操作符遍历字符串——每次连续使用&gt;&gt;都会返回流中的下一个可提取值。另一方面，str()返回流的整个值，即使已经在流上使用了&gt;&gt;。字符串和数字之间的转换因为插入和提取操作符知道如何处理所有基本数据类型，所以我们可以使用它们将字符串转换为数字，反之亦然。首先，让我们看看如何将数字转换成字符串:12345678910111213std::stringstream os; int nValue&#123; 12345 &#125;;double dValue&#123; 67.89 &#125;;os &lt;&lt; nValue &lt;&lt; ' ' &lt;&lt; dValue; std::string strValue1, strValue2;os &gt;&gt; strValue1 &gt;&gt; strValue2; std::cout &lt;&lt; strValue1 &lt;&lt; ' ' &lt;&lt; strValue2 &lt;&lt; '\\n';/*结果*/12345 67.89现在让我们把一个 数字 字符串 转换成一个数字:1234567891011std::stringstream os;os &lt;&lt; \"12345 67.89\"; // insert a string of numbers into the streamint nValue;double dValue; os &gt;&gt; nValue &gt;&gt; dValue; cout &lt;&lt; nValue &lt;&lt; ' ' &lt;&lt; dValue &lt;&lt; '\\n';/*结果*/12345 67.89清除stringstream以便重用有几种方法可以清空stringstream的缓冲区。使用str()与一个空白c风格的字符串 将它设置为空字符串:1234567std::stringstream os;os &lt;&lt; \"Hello \"; os.str(\"\"); // erase the buffer os &lt;&lt; \"World!\";std::cout &lt;&lt; os.str();使用str()和一个空的std::string对象 将它设置为空字符串:1234567std::stringstream os;os &lt;&lt; \"Hello \"; os.str(std::string&#123;&#125;); // erase the buffer os &lt;&lt; \"World!\";cout &lt;&lt; os.str();这两个程序产生以下相同的结果:1World!当清除一个stringstream时，调用clear()函数通常也是一个好主意:12345678std::stringstream os;os &lt;&lt; \"Hello \"; os.str(\"\"); // erase the bufferos.clear(); // reset error flags os &lt;&lt; \"World!\";std::cout &lt;&lt; os.str();clear()函数 重置可能已经设置的任何错误标志，并将流返回到ok状态。在下一课中，我们将更多地讨论流状态和错误标志。","categories":[],"tags":[]},{"title":"C&C++/ostream与ios 输出","slug":"C&C++/ostream与ios 输出","date":"2020-05-27T02:02:36.147Z","updated":"2020-05-27T03:17:42.008Z","comments":true,"path":"archives/927246b0.html","link":"","permalink":"https://longlongqin.github.io/archives/927246b0.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/183-output-with-ostream-and-ios/在本节中，我们将研究iostream输出类(ostream)的各个方面。注意:本课中的所有I/O功能都位于std名称空间中。这意味着所有I/O对象和函数要么必须以“std::”为前缀，要么必须使用“using namespace std;”语句。插入操作符(&lt;&lt;)插入操作符(&lt;&lt;)用于将信息放入输出流。c++为所有内置数据类型预定义了插入操作，您已经了解了如何为您自己的类[重载插入操作符](overload the insertion operator)。在关于Input and output (I/O) streams的课程中，您看到istream和ostream都来自于一个名为ios的类。ios(和ios_base)的任务之一是控制输出的格式化选项。输出格式有两种方法来改变格式选项:标志(flag)——可以将标志看作可以打开和关闭的布尔变量。控制器(manipulator)——控制器 是放置在流中的对象，它影响输入和输出的方式。标志(flag)要打开标志，请使用setf()函数，并将适当的标志作为参数。例如，在默认情况下，c++不会在正数前面打印+符号。但是，通过使用std::ios::showpos标志，我们可以改变这个行为:12345std::cout.setf(std::ios::showpos); // turn on the std::ios::showpos flagstd::cout &lt;&lt; 27 &lt;&lt; '\\n';/*这将产生以下输出:*/+27可以使用OR(|)操作符同时打开多个ios标志:12std::cout.setf(std::ios::showpos | std::ios::uppercase); // turn on the std::ios::showpos and std::ios::uppercase flagstd::cout &lt;&lt; 27 &lt;&lt; '\\n';要关闭标志，请使用unsetf()函数:12345678std::cout.setf(std::ios::showpos); // turn on the std::ios::showpos flagstd::cout &lt;&lt; 27 &lt;&lt; '\\n';std::cout.unsetf(std::ios::showpos); // turn off the std::ios::showpos flagstd::cout &lt;&lt; 28 &lt;&lt; '\\n';/*这将产生以下输出:*/+2728在使用setf()时，还有一个需要注意的问题。许多标志属于组，称为格式组(format group)。格式组是一组执行类似 (有时互斥) 格式选项的标志。例如，名为“basefield”的格式组包含标志“oct”、“dec”和“hex”，它们控制整数值的基数。默认情况下，设置“dec”标志。因此，如果我们这样做:12345std::cout.setf(std::ios::hex); // try to turn on hex outputstd::cout &lt;&lt; 27 &lt;&lt; '\\n';/*我们得到如下输出:*/27它没有工作! 原因是setf()只打开标志——因此，当我们打开std::hex时，std::ios::dec仍然是打开的，而std::ios::dec显然是优先的。有两种方法可以解决这个问题。首先，我们可以关闭std::ios::dec，这样就只设置了std::ios::hex:123456std::cout.unsetf(std::ios::dec); // turn off decimal outputstd::cout.setf(std::ios::hex); // turn on hexadecimal outputstd::cout &lt;&lt; 27 &lt;&lt; '\\n';/*结果*/1b第二种方法是使用另一种形式的setf()，它有两个参数:第一个参数是要设置的标志，第二个是它所属的格式化组。当使用这种形式的setf()时，属于这个组的所有标志都是关闭的，只有传入的标志是打开的。123456// Turn on std::ios::hex as the only std::ios::basefield flagstd::cout.setf(std::ios::hex, std::ios::basefield);std::cout &lt;&lt; 27 &lt;&lt; '\\n';/*结果*/1b控制器(manipulator)使用setf()和unsetf()可能会有些笨拙，因此c++提供了第二种方法来更改格式化选项: 控制器(manipulator)。控制器的优点是他们足够聪明，能够打开和关闭适当的标志。这里有一个例子，使用一些控制器来改变基地:123std::cout &lt;&lt; std::hex &lt;&lt; 27 &lt;&lt; '\\n'; // print 27 in hexstd::cout &lt;&lt; 28 &lt;&lt; '\\n'; // we're still in hexstd::cout &lt;&lt; std::dec &lt;&lt; 29 &lt;&lt; '\\n'; // back to decimal这个程序产生的输出:1231b1c29通常，使用 控制器 比 设置和取消标志 要容易得多。许多选项可以通过标志和操作器(例如更改基数)来使用，但是，其他选项只能通过标志或操作器来使用，因此了解如何使用这两个选项非常重要。有用的格式器下面是一些更有用的标志、控制器和 成员函数 的列表。标记位于std::ios类中控制器位于std名称空间中，成员函数位于std::ostream类中。GroupFlagMeaningstd::ios::boolalphaIf set, booleans print “true” or “false”. If not set, booleans print 0 or 1ManipulatorMeaningstd::boolalphaBooleans print “true” or “false”std::noboolalphaBooleans print 0 or 1 (default)例子：1234567891011121314std::cout &lt;&lt; true &lt;&lt; \" \" &lt;&lt; false &lt;&lt; '\\n'; std::cout.setf(std::ios::boolalpha);std::cout &lt;&lt; true &lt;&lt; \" \" &lt;&lt; false &lt;&lt; '\\n'; std::cout &lt;&lt; std::noboolalpha &lt;&lt; true &lt;&lt; \" \" &lt;&lt; false &lt;&lt; '\\n'; std::cout &lt;&lt; std::boolalpha &lt;&lt; true &lt;&lt; \" \" &lt;&lt; false &lt;&lt; '\\n';/*结果*/1 0true false1 0true falseGroupFlagMeaningstd::ios::showposIf set, prefix positive numbers with a +ManipulatorMeaningstd::showposPrefixes positive numbers with a +std::noshowposDoesn’t prefix positive numbers with a +例子：1234567891011121314std::cout &lt;&lt; 5 &lt;&lt; '\\n'; std::cout.setf(std::ios::showpos);std::cout &lt;&lt; 5 &lt;&lt; '\\n'; std::cout &lt;&lt; std::noshowpos &lt;&lt; 5 &lt;&lt; '\\n'; std::cout &lt;&lt; std::showpos &lt;&lt; 5 &lt;&lt; '\\n';/*结果*/5+55+5GroupFlagMeaningstd::ios::uppercaseIf set, uses upper case lettersManipulatorMeaningstd::uppercaseUses upper case lettersstd::nouppercaseUses lower case letters例子：1234567891011121314std::cout &lt;&lt; 12345678.9 &lt;&lt; '\\n'; std::cout.setf(std::ios::uppercase);std::cout &lt;&lt; 12345678.9 &lt;&lt; '\\n'; std::cout &lt;&lt; std::nouppercase &lt;&lt; 12345678.9 &lt;&lt; '\\n'; std::cout &lt;&lt; std::uppercase &lt;&lt; 12345678.9 &lt;&lt; '\\n';/*结果*/1.23457e+0071.23457E+0071.23457e+0071.23457E+007GroupFlagMeaningstd::ios::basefieldstd::ios::decPrints values in decimal (default)std::ios::basefieldstd::ios::hexPrints values in hexadecimalstd::ios::basefieldstd::ios::octPrints values in octalstd::ios::basefield(none)Prints values according to leading characters of valueManipulatorMeaningstd::decPrints values in decimalstd::hexPrints values in hexadecimalstd::octPrints values in octal例子：1234567891011121314151617181920212223std::cout &lt;&lt; 27 &lt;&lt; '\\n'; std::cout.setf(std::ios::dec, std::ios::basefield);std::cout &lt;&lt; 27 &lt;&lt; '\\n'; std::cout.setf(std::ios::oct, std::ios::basefield);std::cout &lt;&lt; 27 &lt;&lt; '\\n'; std::cout.setf(std::ios::hex, std::ios::basefield);std::cout &lt;&lt; 27 &lt;&lt; '\\n'; std::cout &lt;&lt; std::dec &lt;&lt; 27 &lt;&lt; '\\n';std::cout &lt;&lt; std::oct &lt;&lt; 27 &lt;&lt; '\\n';std::cout &lt;&lt; std::hex &lt;&lt; 27 &lt;&lt; '\\n';/*结果*/2727331b27331b现在，您应该能够通过标记和控制器查看设置格式之间的关系。在以后的示例中，我们将使用控制器，除非它们不可用。精度、符号和小数点通过使用操作器(或标志)，可以更改显示浮点数的精度和格式。有几种格式化选项以某种复杂的方式组合在一起，因此我们将仔细研究这个问题。GroupFlagMeaningstd::ios::floatfieldstd::ios::fixedUses decimal notation for floating-point numbersstd::ios::floatfieldstd::ios::scientificUses scientific notation for floating-point numbersstd::ios::floatfield(none)Uses fixed for numbers with few digits, scientific otherwisestd::ios::floatfieldstd::ios::showpointAlways show a decimal point and trailing 0’s for floating-point valuesManipulatorMeaningstd::fixedUse decimal notation for valuesstd::scientificUse scientific notation for valuesstd::showpointShow a decimal point and trailing 0’s for floating-point valuesstd::noshowpointDon’t show a decimal point and trailing 0’s for floating-point valuesstd::setprecision(int)Sets the precision of floating-point numbers (defined in iomanip.h)Member functionMeaningstd::precision()Returns the current precision of floating-point numbersstd::precision(int)Sets the precision of floating-point numbers and returns old precision如果使用固定记数法或科学记数法，则精度决定了在分数中显示多少位小数。注意，如果精度小于有效数字的数目，则该数字将四舍五入。12345678910111213std::cout &lt;&lt; std::fixed &lt;&lt; '\\n';std::cout &lt;&lt; std::setprecision(3) &lt;&lt; 123.456 &lt;&lt; '\\n';std::cout &lt;&lt; std::setprecision(4) &lt;&lt; 123.456 &lt;&lt; '\\n';std::cout &lt;&lt; std::setprecision(5) &lt;&lt; 123.456 &lt;&lt; '\\n';std::cout &lt;&lt; std::setprecision(6) &lt;&lt; 123.456 &lt;&lt; '\\n';std::cout &lt;&lt; std::setprecision(7) &lt;&lt; 123.456 &lt;&lt; '\\n'; std::cout &lt;&lt; std::scientific &lt;&lt; '\\n';std::cout &lt;&lt; std::setprecision(3) &lt;&lt; 123.456 &lt;&lt; '\\n';std::cout &lt;&lt; std::setprecision(4) &lt;&lt; 123.456 &lt;&lt; '\\n';std::cout &lt;&lt; std::setprecision(5) &lt;&lt; 123.456 &lt;&lt; '\\n';std::cout &lt;&lt; std::setprecision(6) &lt;&lt; 123.456 &lt;&lt; '\\n';std::cout &lt;&lt; std::setprecision(7) &lt;&lt; 123.456 &lt;&lt; '\\n';结果：1234567891011123.456123.4560123.45600123.456000123.45600001.235e+0021.2346e+0021.23456e+0021.234560e+0021.2345600e+002如果既不使用固定数字，也不使用科学数字，则精度决定应显示多少位有效数字。同样，如果精度小于有效数字的数目，则该数字将四舍五入。12345std::cout &lt;&lt; std::setprecision(3) &lt;&lt; 123.456 &lt;&lt; '\\n';std::cout &lt;&lt; std::setprecision(4) &lt;&lt; 123.456 &lt;&lt; '\\n';std::cout &lt;&lt; std::setprecision(5) &lt;&lt; 123.456 &lt;&lt; '\\n';std::cout &lt;&lt; std::setprecision(6) &lt;&lt; 123.456 &lt;&lt; '\\n';std::cout &lt;&lt; std::setprecision(7) &lt;&lt; 123.456 &lt;&lt; '\\n';结果：12345123123.5123.46123.456123.456使用showpoint控制器器或标记，您可以让流 写入小数点和尾随零。123456std::cout &lt;&lt; std::showpoint &lt;&lt; '\\n';std::cout &lt;&lt; std::setprecision(3) &lt;&lt; 123.456 &lt;&lt; '\\n';std::cout &lt;&lt; std::setprecision(4) &lt;&lt; 123.456 &lt;&lt; '\\n';std::cout &lt;&lt; std::setprecision(5) &lt;&lt; 123.456 &lt;&lt; '\\n';std::cout &lt;&lt; std::setprecision(6) &lt;&lt; 123.456 &lt;&lt; '\\n';std::cout &lt;&lt; std::setprecision(7) &lt;&lt; 123.456 &lt;&lt; '\\n';结果：12345123.123.5123.46123.456123.4560下面是一些例子的总结表:OptionPrecision12345.00.12345Normal31.23e+0040.12341.235e+0040.12355123450.123456123450.12345Showpoint31.23e+0040.12341.235e+0040.1235512345.0.12345612345.00.123450Fixed312345.0000.123412345.00000.1235512345.000000.12345612345.0000000.123450Scientific31.235e+0041.235e-00141.2345e+0041.2345e-00151.23450e+0041.23450e-00161.234500e+0041.234500e-001宽度、填充字符和对齐通常，当您打印数字时，数字的打印与周围的空间无关。然而，向左或向右打印数字是可能的。为了做到这一点，我们必须首先定义一个字段宽度，它定义了一个值将具有的输出空间的数量。如果实际打印的数字小于字段宽度，它将被左对齐或右对齐(如指定)。如果实际数字大于字段宽度，则不会截断它——它将溢出字段。GroupFlagMeaningstd::ios::adjustfieldstd::ios::internalLeft-justifies the sign of the number, and right-justifies the valuestd::ios::adjustfieldstd::ios::leftLeft-justifies the sign and valuestd::ios::adjustfieldstd::ios::rightRight-justifies the sign and value (default)ManipulatorMeaningstd::internalLeft-justifies the sign of the number, and right-justifies the valuestd::leftLeft-justifies the sign and valuestd::rightRight-justifies the sign and valuestd::setfill(char)Sets the parameter as the fill character (defined in iomanip.h)std::setw(int)Sets the field width for input and output to the parameter (defined in iomanip.h)Member functionMeaningstd::fill()Returns the current fill characterstd::fill(char)Sets the fill character and returns the old fill characterstd::width()Returns the current field widthstd::width(int)Sets the current field width and returns old field width为了使用任何这些格式化器，我们首先必须设置字段宽度。这可以通过width(int)成员函数或setw()机械手来完成。注意，右对齐是默认的。123456789101112std::cout &lt;&lt; -12345 &lt;&lt; '\\n'; // print default value with no field widthstd::cout &lt;&lt; std::setw(10) &lt;&lt; -12345 &lt;&lt; '\\n'; // print default with field widthstd::cout &lt;&lt; std::setw(10) &lt;&lt; left &lt;&lt; -12345 &lt;&lt; '\\n'; // print left justifiedstd::cout &lt;&lt; std::setw(10) &lt;&lt; right &lt;&lt; -12345 &lt;&lt; '\\n'; // print right justifiedstd::cout &lt;&lt; std::setw(10) &lt;&lt; internal &lt;&lt; -12345 &lt;&lt; '\\n'; // print internally justified/*结果*/-12345 -12345-12345 -12345- 12345需要注意的一点是，setw()和width()只影响下一个输出语句。它们不像其他一些标志/操纵器那样持久。现在，让我们设置一个填充字符，并做同样的例子:12345678910111213std::cout.fill('*');std::cout &lt;&lt; -12345 &lt;&lt; '\\n'; // print default value with no field widthstd::cout &lt;&lt; std::setw(10) &lt;&lt; -12345 &lt;&lt; '\\n'; // print default with field widthstd::cout &lt;&lt; std::setw(10) &lt;&lt; left &lt;&lt; -12345 &lt;&lt; '\\n'; // print left justifiedstd::cout &lt;&lt; std::setw(10) &lt;&lt; right &lt;&lt; -12345 &lt;&lt; '\\n'; // print right justifiedstd::cout &lt;&lt; std::setw(10) &lt;&lt; internal &lt;&lt; -12345 &lt;&lt; '\\n'; // print internally justified/*结果*/-12345****-12345-12345********-12345-****12345请注意，字段中的所有空格都已用填充字符填充。ostream类和iostream库包含其他可能有用的输出函数、标志和操作符，这取决于您需要做什么。与istream类一样，这些主题实际上更适合于关注标准库的教程或书籍(例如Nicolai M. Josuttis的优秀书籍《c++标准模板库》)。","categories":[],"tags":[]},{"title":"C&C++/istream输入","slug":"C&C++/istream输入","date":"2020-05-27T01:28:28.965Z","updated":"2020-05-27T01:59:51.258Z","comments":true,"path":"archives/dac06bda.html","link":"","permalink":"https://longlongqin.github.io/archives/dac06bda.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/182-input-with-istream/iostream库相当复杂——因此我们无法在本教程中完整地介绍它。但是，我们将向您展示最常用的功能。在本节中，我们将研究input类(istream)的各个方面。提取操作符(&gt;&gt;)正如在许多课程中看到的，我们可以使用提取操作符(&gt;&gt;)从输入流中读取信息。c++为所有内置数据类型提供了预定义的提取操作，您已经了解了如何重载自己类的提取操作符。读取字符串时，提取操作符的一个常见问题是如何防止输入溢出缓冲区。给出以下例子:12char buf[10];std::cin &gt;&gt; buf;如果用户输入18个字符会发生什么?缓冲区溢出，就会发生不好的事情。一般来说，对用户将输入多少字符做任何假设都不是一个好主意。处理这个问题的一种方法是使用控制符。控制符是一个对象，当使用提取(&gt;&gt;)或插入(&lt;&lt;)操作符时，用于修改流。您已经广泛使用过的一个控制符是“endl”，它既打印换行字符，又刷新任何缓冲输出。c++提供了一个名为setw的机械手(在iomanip.h头文件中)，它可以用来限制从流中读取的字符的数量。要使用setw()，只需提供作为参数读取的最大字符数，并将其插入到您的输入语句中，如下所示:123#include &lt;iomanip.h&gt;char buf[10];std::cin &gt;&gt; std::setw(10) &gt;&gt; buf;这个程序现在将只从流中读取前9个字符(为终止符留出空间)。任何剩余的字符都将留在流中，直到下一次提取。提取和空白到目前为止，我们没有提到的一件事是提取操作符处理“格式化”的数据——也就是说，它跳过空白(空格、制表符和换行符)。看看下面的程序:12345678int main()&#123; char ch; while (std::cin &gt;&gt; ch) std::cout &lt;&lt; ch; return 0;&#125;当用户输入以下内容时:1Hello my name is Alex提取操作符跳过空格和换行符。因此，输出为:1HellomynameisAlex通常，您希望获得用户输入，但不放弃空格。为此，istream类提供了许多可用于此目的的函数。get()get()——最有用的函数之一是get()函数，它只从输入流中获取一个字符。下面是上面使用get()的同一个程序:12345678910111213int main()&#123; char ch; while (std::cin.get(ch)) std::cout &lt;&lt; ch; return 0;&#125;/*现在当我们使用输入:*/Hello my name is Alex/*它的结果是*/Hello my name is Alexstd::get()也有一个字符串版本，需要读取最多的字符:12345678910111213int main()&#123; char strBuf[11]; std::cin.get(strBuf, 11); std::cout &lt;&lt; strBuf &lt;&lt; '\\n'; return 0;&#125;/*现在当我们使用输入:*/Hello my name is Alex/*它的结果是*/Hello my n注意，我们只读取了前10个字符(必须留下一个字符作为终止符)。其余字符留在输入流中。关于get()需要注意的一件重要事情是，它不读取换行字符! 这可能会导致一些意想不到的结果:123456789101112int main()&#123; char strBuf[11]; // Read up to 10 characters std::cin.get(strBuf, 11); std::cout &lt;&lt; strBuf &lt;&lt; '\\n'; // Read up to 10 more characters std::cin.get(strBuf, 11); std::cout &lt;&lt; strBuf &lt;&lt; '\\n'; return 0;&#125;如果用户输入:1Hello!程序将打印:1Hello!然后终止! 为什么不要求增加10个字符呢? 答案是，因为第一个get()读到换行，然后停止。第二个get()看到cin流中仍然有输入，并试图读取它。但第一个字符是换行符，所以它立即停止。getline()因此，还有另一个名为getline()的函数，它的工作方式与get()完全相同，但它会读取换行符。123456789101112int main()&#123; char strBuf[11]; // Read up to 10 characters std::cin.getline(strBuf, 11); std::cout &lt;&lt; strBuf &lt;&lt; '\\n'; // Read up to 10 more characters std::cin.getline(strBuf, 11); std::cout &lt;&lt; strBuf &lt;&lt; '\\n'; return 0;&#125;这段代码将按照您的期望执行，即使用户输入一个带有换行符的字符串。如果需要知道getline()的最后一次调用提取了多少字符， 使用gcount () :123456789int main()&#123; char strBuf[100]; std::cin.getline(strBuf, 100); std::cout &lt;&lt; strBuf &lt;&lt; '\\n'; std::cout &lt;&lt; std::cin.gcount() &lt;&lt; \" characters were read\" &lt;&lt; endl; return 0;&#125;一些更有用的istream函数这里有一些更有用的输入函数，你可能想利用:ignore()：丢弃流中的第一个字符**。ignore(int nCount)：丢弃第一个nCount字符。peek()：允许您从流中读取字符，而无需从流中删除字符。unget()：将最后读取的字符返回到流中，以便下一个调用可以再次读取它。putback(char ch)：允许您将选择的字符放回流中，以便下一次调用读取。istream包含了许多其他的函数和上面提到的函数的变体，它们可能是有用的，这取决于你需要做什么。但是，这些主题更适合于关注标准库的教程或书籍（如 “The C++ Standard Library” by Nicolai M. Josuttis）","categories":[],"tags":[]},{"title":"C&C++/输入输出(IO)流","slug":"C&C++/输入输出(IO)流","date":"2020-05-27T00:43:46.335Z","updated":"2020-05-27T01:17:58.901Z","comments":true,"path":"archives/57266241.html","link":"","permalink":"https://longlongqin.github.io/archives/57266241.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/181-input-and-output-io-streams/输入和输出功能不是作为核心c++语言的一部分定义的，而是通过c++标准库提供的 (因此驻留在std名称空间中)。在以前的课程中，您包括了iostream库头，并使用cin和cout对象来执行简单的I/O。在这节课中，我们将更详细地了解iostream库。iostream库当您包含iostream报头时，您可以访问 负责提供I/O功能的整个类层次结构 (包括一个实际名为iostream的类)。非文件 I/O类的类层次结构如下:关于这个层次结构，您可能注意到的第一件事是它使用了多重继承(我们告诉您尽可能避免的事情)。但是，为了避免任何典型的多重继承问题，已经设计并广泛测试了iostream库，所以您可以自由地使用它。流(Streams)你可能注意到的第二件事是，“流”这个词使用得非常频繁。在最基本的方面，c++中的I/O是用流实现的。抽象地说，流就是可以按顺序访问的字节序列。随着时间的推移，流可能产生或消耗无限数量的数据。通常我们处理两种不同类型的流：输入流用于保存来自数据生成器 (如键盘、文件或网络)的输入。例如，当程序当前不期望任何输入时，用户可以按键盘上的一个键。而不是忽略用户的按键，数据被放入一个输入流，在那里它将等待，直到程序为它准备好。相反，输出流用于保存特定数据使用者 (如监视器、文件或打印机)的输出。当向输出设备写入数据时，设备可能还没有准备好接受该数据——例如，当程序将数据写入其输出流时，打印机可能仍然处于预热状态。这些数据将保存在输出流中，直到打印机开始使用它。一些设备，如文件和网络，可以同时作为输入源和输出源。流的好处是程序员只需要学习如何与流交互，就可以将数据读写到许多不同的设备上。流如何与它们所连接的实际设备进行接口的详细信息由环境或操作系统决定。在c++中的输入/输出虽然ios类通常派生自ios_base类，但ios 通常是您将直接使用的最基本的类。ios类定义了一些输入流和输出流共有的东西。我们将在以后的课程中讨论这些内容。istream类是处理输入流时使用的主要类。对于输入流，提取操作符(&gt;&gt;) 用于从流中删除值。 这是有意义的:当用户在键盘上按下一个键时，键代码就被放置在输入流中。然后，程序从流中提取值，以便使用它。ostream类是处理输出流时使用的主要类。对于输出流，使用插入操作符(&lt;&lt;)将值放入流中。这也是有意义的:您将您的值插入到流中，数据使用者(例如。监控)使用。iostream类可以处理输入和输出，允许双向I/O。最后，有一堆类以“_withassign”结束。这些 流类 派生自istream、ostream和iostream (分别)，并定义了赋值运算符，允许您将一个流分配给另一个流。在大多数情况下，您不会直接处理这些类。c++中的标准流标准流是由环境提供给计算机程序的预先连接的流。c++附带了四个预定义的标准流对象，它们已经为您的使用进行了设置。cin——与标准输入(通常是键盘)绑定的 istream_withassign类cout——与标准输出(通常是监视器)绑定的ostream_withassign类cerr—— 一个与标准错误(通常是监视器)绑定的ostream_withassign类，提供 未缓冲 的输出clog—— 一个与标准错误(通常是监视器)绑定的ostream_withassign类，提供缓冲 输出非缓冲输出通常是立即处理的，而缓冲输出通常是作为一个块存储和写入的。因为clog不是经常使用，所以它常常从标准流列表中被省略。","categories":[],"tags":[]},{"title":"C&C++/std：：string的插入","slug":"C&C++/std：：string的插入","date":"2020-05-26T15:14:08.036Z","updated":"2020-05-26T15:18:25.497Z","comments":true,"path":"archives/e56a544e.html","link":"","permalink":"https://longlongqin.github.io/archives/e56a544e.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/17-7-stdstring-inserting/可以通过insert()函数将字符插入到现有的字符串中。string&amp; string::insert (size_type index, const string&amp; str)string&amp; string::insert (size_type index, const char* str)这两个函数都将str的字符插入到索引处的字符串中两个函数都返回*this，因此它们可以被“链接”。如果索引无效，两个函数都会抛出out_of_range如果结果超过最大字符数，这两个函数都会抛出一个length_error异常。在c风格的字符串版本中，str不能为空。如：12345678string sString(\"aaaa\");cout &lt;&lt; sString &lt;&lt; endl; sString.insert(2, string(\"bbbb\"));cout &lt;&lt; sString &lt;&lt; endl; sString.insert(4, \"cccc\");cout &lt;&lt; sString &lt;&lt; endl;结果：123aaaaaabbbbaaaabbccccbbaa下面，将只给出函数的声明，具体解释，请看原文对应内容：string&amp; string::insert (size_type index, const string&amp; str, size_type startindex, size_type num)string&amp; string::insert(size_type index, const char* str, size_type len)string&amp; string::insert(size_type index, size_type num, char c)void insert(iterator it, size_type num, char c)iterator string::insert(iterator it, char c)void string::insert(iterator it, InputIterator begin, InputIterator end)","categories":[],"tags":[]},{"title":"C&C++/std：：string的末尾追加字符串","slug":"C&C++/std：：string的末尾追加字符串","date":"2020-05-26T14:50:42.447Z","updated":"2020-05-26T15:12:56.340Z","comments":true,"path":"archives/54babab5.html","link":"","permalink":"https://longlongqin.github.io/archives/54babab5.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/17-6-stdstring-appending/使用运算符+=、append()或push_back()函数可以很容易地将字符串追加到现有字符串的末尾。string&amp; string::operator+= (const string&amp; str)string&amp; string::append (const string&amp; str)这两个函数都将str的字符追加到字符串中。两个函数都返回*this，因此它们可以被“链接”。如果结果超过最大字符数，这两个函数都会抛出一个length_error异常。如：12345678string sString(\"one\"); sString += string(\" two\"); string sThree(\" three\");sString.append(sThree); cout &lt;&lt; sString &lt;&lt; endl;结果：1one two three还有一种append()方法可以附加子字符串:string&amp; string::append (const string&amp; str, size_type index, size_type num)这个函数将从str开始的num字符追加到字符串。返回*this，这样它可以被“链接”。如果索引超出范围，则抛出out_of_range如果结果超过最大字符数，则抛出length_error异常。如：12345string sString(\"one \"); const string sTemp(\"twothreefour\");sString.append(sTemp, 3, 5); // append substring of sTemp starting at index 3 of length 5cout &lt;&lt; sString &lt;&lt; endl;结果：1one three运算符+=和append()也有处理c风格字符串的版本:string&amp; string::operator+= (const char* str)string&amp; string::append (const char* str)这两个函数都将str的字符追加到字符串中。两个函数都返回*this，因此它们可以被“链接”。如果结果超过最大字符数，这两个函数都会抛出一个length_error异常。str不应该为空。如：12345string sString(\"one\"); sString += \" two\";sString.append(\" three\");cout &lt;&lt; sString &lt;&lt; endl;结果：1one two three下面还有很多，将只给出其声明，具体解释，请看原教程对应内容：string&amp; string::append (const char* str, size_type len)string&amp; string::operator+= (char c)void string::push_back (char c)string&amp; string::append (size_type num, char c)string&amp; string::append (InputIterator start, InputIterator end)","categories":[],"tags":[]},{"title":"C&C++/std：：string的赋值 与 交换","slug":"C&C++/std：：string的赋值 与 交换","date":"2020-05-26T14:34:12.818Z","updated":"2020-05-26T14:49:37.863Z","comments":true,"path":"archives/6b2ecf81.html","link":"","permalink":"https://longlongqin.github.io/archives/6b2ecf81.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/17-5-stdstring-assignment-and-swapping/字符串赋值给字符串赋值的最简单方法是使用重载的运算符=函数。还有一个assign()成员函数，它复制了某些功能。string&amp; string::operator= (const string&amp; str)string&amp; string::assign (const string&amp; str)string&amp; string::operator= (const char* str)string&amp; string::assign (const char* str)string&amp; string::operator= (char c)这些函数将各种类型的值赋给字符串。这些函数返回*this，因此它们可以被“链接”。注意，不存在接受单个字符的assign()函数。如：12345678910111213141516171819202122232425string sString; // Assign a string valuesString = string(\"One\");cout &lt;&lt; sString &lt;&lt; endl; const string sTwo(\"Two\");sString.assign(sTwo);cout &lt;&lt; sString &lt;&lt; endl; // Assign a C-style stringsString = \"Three\";cout &lt;&lt; sString &lt;&lt; endl; sString.assign(\"Four\");cout &lt;&lt; sString &lt;&lt; endl; // Assign a charsString = '5';cout &lt;&lt; sString &lt;&lt; endl; // Chain assignmentstring sOther;sString = sOther = \"Six\";cout &lt;&lt; sString &lt;&lt; \" \" &lt;&lt; sOther &lt;&lt; endl;结果：123456OneTwoThreeFour5Six Sixassign()成员函数也有其他一些版本string&amp; string::assign (const string&amp; str, size_type index, size_type len)赋值一个str的子字符串，从index开始，长度为len如果索引超出范围，则抛出out_of_range异常返回*this，这样它可以被“链接”。如：12345const string sSource(\"abcdefg\");string sDest; sDest.assign(sSource, 2, 4); // assign a substring of source from index 2 of length 4cout &lt;&lt; sDest &lt;&lt; endl;结果：1cdefstring&amp; string::assign (const char\\* chars, size_type len)从c风格的数组字符中分配len字符如果结果超过最大字符数，则抛出length_error异常返回*this，这样它可以被“链接”。如：1234string sDest; sDest.assign(\"abcdefg\", 4);cout &lt;&lt; sDest &lt;&lt; endl;结果：1abcd这个函数有潜在的危险，不建议使用它。string&amp; string::assign (size_type len, char c)使用len个字符c 来赋值如果结果超过最大字符数，则抛出length_error异常返回*this，这样它可以被“链接”。如：1234string sDest; sDest.assign(4, 'g');cout &lt;&lt; sDest &lt;&lt; endl;结果：1gggg交换如果有两个字符串，并且希望交换它们的值，那么可以使用两个名为swap()的函数。void string::swap (string &amp;str)void swap (string &amp;str1, string &amp;str2)两个函数交换两个字符串的值。成员函数交换this和str，*全局函数**交换str1和str2。这些函数是有效的，应该用来代替赋值来执行字符串交换。如：12345678string sStr1(\"red\");string sStr2(\"blue\"); cout &lt;&lt; sStr1 &lt;&lt; \" \" &lt;&lt; sStr2 &lt;&lt; endl;swap(sStr1, sStr2);cout &lt;&lt; sStr1 &lt;&lt; \" \" &lt;&lt; sStr2 &lt;&lt; endl;sStr1.swap(sStr2);cout &lt;&lt; sStr1 &lt;&lt; \" \" &lt;&lt; sStr2 &lt;&lt; endl;结果：123red blueblue redred blue","categories":[],"tags":[]},{"title":"C&C++/std：：string的字符访问 及 转换为C风格数组","slug":"C&C++/std：：string的字符访问 及 转换为C风格数组","date":"2020-05-26T14:04:03.302Z","updated":"2020-05-26T14:32:56.148Z","comments":true,"path":"archives/a3edb06.html","link":"","permalink":"https://longlongqin.github.io/archives/a3edb06.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/17-4-stdstring-character-access-and-conversion-to-c-style-arrays/访问字符重载运算符[]有两种几乎相同的方法来访问字符串中的字符。更容易使用和更快的版本是重载运算符[]:char&amp; string::operator[] (size_type nIndex)const char&amp; string::operator[] (size_type nIndex) const这两个函数都返回带有索引nIndex的字符传递无效索引将导致未定义的行为使用length()作为索引仅对const字符串有效，并返回由字符串的默认构造函数生成的值。不建议您这样做。因为char&amp;是返回类型，所以可以使用它编辑数组中的字符如：1234std::string sSource&#123; \"abcdefg\" &#125;;std::cout &lt;&lt; sSource[5] &lt;&lt; '\\n';sSource[5] = 'X';std::cout &lt;&lt; sSource &lt;&lt; '\\n';结果：12fabcdeXg非操作符版本还有一个非操作符版本。这个版本比较慢，因为它使用异常来检查nIndex是否有效。如果你不确定nIndex是否有效，你应该使用这个版本来访问数组:char&amp; string::at (size_type nIndex)const char&amp; string::at (size_type nIndex) const这两个函数都返回带有索引nIndex的字符传递无效索引将导致out_of_range异常因为char&amp;是返回类型，所以可以使用它编辑数组中的字符如：1234std::string sSource&#123; \"abcdefg\" &#125;;std::cout &lt;&lt; sSource.at(5) &lt;&lt; '\\n';sSource.at(5) = 'X';std::cout &lt;&lt; sSource &lt;&lt; '\\n';转换为c风格的数组许多函数(包括所有C函数)都希望将字符串格式化为C风格的字符串，而不是std::string。由于这个原因，std::string提供了3种不同的方法来将std::string转换成c风格的字符串。const char* string::c_str () const ⭐【推荐】以const c风格的字符串返回字符串的内容将追加一个空终止符c风格的字符串属于std::string，不应该被删除如：12std::string sSource&#123; \"abcdefg\" &#125;;std::cout &lt;&lt; std::strlen(sSource.c_str());结果：17const char* string::data () const以const c风格的字符串返回字符串的内容将追加一个空终止符。这个函数执行的操作与c_str()相同c风格的字符串属于std::string，不应该被删除如：12345678std::string sSource&#123; \"abcdefg\" &#125;;const char *szString&#123; \"abcdefg\" &#125;;// 比较两个c样式字符串的前n个字符，如果它们相等，则返回0if (std::memcmp(sSource.data(), szString, sSource.length()) == 0) std::cout &lt;&lt; \"The strings are equal\";else std::cout &lt;&lt; \"The strings are not equal\";结果：1The strings are equalsize_type string::copy(char *szBuf, size_type nLength) constsize_type string::copy(char *szBuf, size_type nLength, size_type nIndex) const这两种风格都将字符串的最多nLength字符复制到szBuf，从字符nIndex开始返回复制的字符数没有空值被追加。由调用者负责确保szBuf被初始化为NULL或使用返回的长度终止字符串调用者负责不溢出szBuf如：1234567std::string sSource&#123; \"sphinx of black quartz, judge my vow\" &#125;; char szBuf[20];int nLength&#123; static_cast&lt;int&gt;(sSource.copy(szBuf, 5, 10)) &#125;;szBuf[nLength] = '\\0'; // 确保终止缓冲区中的字符串 std::cout &lt;&lt; szBuf &lt;&lt; '\\n';结果：1black除非您需要充分利用效率，否则c_str()是这三个函数中最简单、最安全的一个。","categories":[],"tags":[]},{"title":"C&C++/std：：string长度和容量","slug":"C&C++/std：：string长度和容量","date":"2020-05-26T09:30:48.856Z","updated":"2020-05-26T14:01:51.473Z","comments":true,"path":"archives/cc14dac2.html","link":"","permalink":"https://longlongqin.github.io/archives/cc14dac2.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/17-3-stdstring-length-and-capacity/一旦创建了字符串，了解它们的长度通常是很有用的。这就是长度和容量操作发挥作用的地方。我们还将讨论将std::string转换回c风格字符串的各种方法，这样您就可以将它们用于需要char*类型的字符串的函数。字符串长度字符串的长度非常简单——它是字符串中的字符数。确定字符串长度有两个相同的函数:size_type string::length() constsize_type string::size() const这两个函数都返回字符串中的当前字符数(不包括null终止符)。12string sSource(\"012345678\");cout &lt;&lt; sSource.length() &lt;&lt; endl;确定字符串是否有字符虽然可以使用length()来确定一个字符串是否有字符，但是使用empty()函数更有效:bool string::empty() const如果字符串没有字符，则返回true，否则返回false。如：1234string sString1(\"Not Empty\");cout &lt;&lt; (sString1.empty() ? \"true\" : \"false\") &lt;&lt; endl;string sString2; // emptycout &lt;&lt; (sString2.empty() ? \"true\" : \"false\") &lt;&lt; endl;字符串可容纳最大的容量还有一个与大小相关的函数，您可能永远不会用到，但是为了完整起见，我们将在这里包括它:size_type string::max_size() const返回字符串允许的最大字符数。这个值会随着操作系统和系统架构的不同而变化。12string sString(\"MyString\");cout &lt;&lt; sString.max_size() &lt;&lt; endl;结果：12345&#x2F;&#x2F;教程中的结果4294967294&#x2F;&#x2F;在我自己电脑中的结果2147483647字符串的容量( capacity)字符串的容量反映了字符串为保存其内容而分配的内存大小。此值以字符串字符为度量，不包括NULL终止符。（例如，一个容量为8的字符串可以容纳8个字符。）size_type string::capacity() const返回一个字符串在不重新分配的情况下可以容纳的字符数。如：123string sString(\"01234567\");cout &lt;&lt; \"Length: \" &lt;&lt; sString.length() &lt;&lt; endl;cout &lt;&lt; \"Capacity: \" &lt;&lt; sString.capacity() &lt;&lt; endl;结果：12Length: 8Capacity: 15注意，容量大于字符串的长度!虽然我们的字符串长度为8，但实际上该字符串分配了足够15个字符的内存!为什么要这样做?字符串容量( capacity) 大于等于 字符串长度注意，容量大于字符串的长度!虽然我们的字符串长度为8，但实际上该字符串分配了足够15个字符的内存!为什么要这样做?如果用户想在一个字符串中放入比该字符串所能容纳的更多的字符，则必须将该字符串重新分配到更大的容量中。例如，如果一个字符串的长度和容量都为8，那么向该字符串添加任何字符都将强制重新分配。通过使容量大于实际的字符串，这就为用户提供了一些缓冲空间，以便在需要进行重新分配之前扩展字符串。事实证明，重新分配有以下几个不利原因：首先，重新分配字符串相对比较昂贵。首先，必须分配新内存。然后必须将字符串中的每个字符复制到新内存中。如果字符串很大，这可能需要很长时间。最后，旧的内存空间必须释放。如果您正在进行许多重新分配，这个过程会显著降低程序的运行速度。其次，每当重新分配一个字符串时，该字符串的内容就会更改为一个新的内存地址。这意味着对字符串的所有引用、指针和迭代器都是无效的!设置字符串的容量的下限void string::reserve(size_type unSize)void string::reserve()第一个函数特点是将字符串的容量至少设置为unSize(可以更大)。注意，这可能需要重新分配。当调用第一个函数时，但大小小于当前容量，则函数将尝试收缩容量以匹配长度。这是一个非绑定请求。1234567891011string sString(\"01234567\");cout &lt;&lt; \"Length: \" &lt;&lt; sString.length() &lt;&lt; endl;cout &lt;&lt; \"Capacity: \" &lt;&lt; sString.capacity() &lt;&lt; endl; sString.reserve(200);cout &lt;&lt; \"Length: \" &lt;&lt; sString.length() &lt;&lt; endl;cout &lt;&lt; \"Capacity: \" &lt;&lt; sString.capacity() &lt;&lt; endl; sString.reserve();cout &lt;&lt; \"Length: \" &lt;&lt; sString.length() &lt;&lt; endl;cout &lt;&lt; \"Capacity: \" &lt;&lt; sString.capacity() &lt;&lt; endl;结果：123456Length: 8Capacity: 15Length: 8Capacity: 207Length: 8Capacity: 207这个例子展示了两件有趣的事情。首先，虽然我们要求200的容量，但实际上我们得到了207的容量。容量总是保证至少与您的请求一样大，但也可能更大。然后，我们请求更改容量以适应字符串。这个请求被忽略了，因为容量没有改变。向字符串添加一个字符12345678string sString(\"0123456789abcde\");cout &lt;&lt; \"Length: \" &lt;&lt; sString.length() &lt;&lt; endl;cout &lt;&lt; \"Capacity: \" &lt;&lt; sString.capacity() &lt;&lt; endl; // Now add a new charactersString += \"f\"; ⭐⭐⭐cout &lt;&lt; \"Length: \" &lt;&lt; sString.length() &lt;&lt; endl;cout &lt;&lt; \"Capacity: \" &lt;&lt; sString.capacity() &lt;&lt; endl;结果：1234Length: 15Capacity: 15Length: 16Capacity: 31","categories":[],"tags":[]},{"title":"C&C++/std：：string构造和销毁","slug":"C&C++/std：：string构造和销毁","date":"2020-05-26T08:40:46.744Z","updated":"2020-05-26T09:27:51.826Z","comments":true,"path":"archives/550c4d87.html","link":"","permalink":"https://longlongqin.github.io/archives/550c4d87.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/17-2-stdstring-construction-and-destruction/在这节课中，我们将学习如何构造std::string的对象，以及如何从数字创建字符串，反之亦然。String 的构造string类有许多构造函数，可用于创建字符串。我们将在这里逐一介绍。注意：string::size_type解析为size_t，它与sizeof操作符返回的无符号整数类型 相同。它的实际大小因环境而异。出于本教程的目的，将它想象成一个无符号整型。string::string()这是默认的构造函数。它创建一个空字符串。如：12345std::string sSource;std::cout &lt;&lt; sSource;/*结果*/ //什么都没有，因为这是空字符串string::string(const string&amp; strString)这是复制构造函数。这个构造函数创建一个新的字符串作为strString的副本。如：123std::string sSource&#123; \"my string\" &#125;;std::string sOutput&#123; sSource &#125;;std::cout &lt;&lt; sOutput;结果：1my stringstring::string(const string&amp; strString, size_type unIndex, size_type unLength)string::string(const string&amp; strString, size_type unIndex)string::string(const string&amp; strString, size_type unIndex, size_type unLength)此构造函数创建一个新字符串，该字符串从索引 unIndex开始，最多包含来自strString的 unLength长度字符。如果遇到NULL，即使没有达到unLength，字符串复制也将结束。如果不提供unLength，则使用从unIndex开始的所有字符。如果unIndex大于字符串的大小，则会抛出out_of_range异常。如：12345std::string sSource&#123; \"my string\" &#125;;std::string sOutput&#123; sSource, 3 &#125;;std::cout &lt;&lt; sOutput&lt;&lt; '\\n';std::string sOutput2(sSource, 3, 4);std::cout &lt;&lt; sOutput2 &lt;&lt; '\\n';结果：12stringstristring::string(const char *szCString)这个构造函数从c风格的字符串szCString创建一个新字符串，直到但不包括NULL终止符。如果结果大小超过最大字符串长度，将抛出length_error异常。警告:szCString不能为空。如：123const char *szSource&#123; \"my string\" &#125;;std::string sOutput&#123; szSource &#125;;std::cout &lt;&lt; sOutput &lt;&lt; '\\n';结果：1my stringstring::string(const char *szCString, size_type unLength)这个构造函数从c样式的字符串szCString的 第一个字符开始 到 第 unLength个字符(包含它) 结束 创建一个新字符串。如果结果大小超过最大字符串长度，将抛出length_error异常。警告：仅对于此函数，在szCString中null不被视为字符串结束字符! 这意味着如果字符串的长度太大，是可以读取字符串的末尾的字符的。 注意不要溢出你的字符串缓冲区!如：123const char *szSource&#123; \"my string\" &#125;;std::string sOutput(szSource, 4);std::cout &lt;&lt; sOutput &lt;&lt; '\\n';结果：1my sstring::string(size_type nNum, char chChar)这个构造函数创建一个由nNum个 chChar字符 初始化的新字符串。如果结果大小超过最大字符串长度，将抛出length_error异常。如：12std::string sOutput(4, 'Q');cout &lt;&lt; sOutput &lt;&lt; endl;结果：1QQQQtemplate string::string(InputIterator itBeg, InputIterator itEnd)这个构造函数创建由一个范围为 [itBeg, itEnd]字符 初始化的新字符串。如果结果大小超过最大字符串长度，将抛出length_error异常。这个没有示例代码。它很模糊，你可能永远不会用到它。string 的销毁string::~string()字符串的销毁：这是破坏者。它销毁字符串并释放内存。这里也没有示例代码，因为析构函数不是显式调用的。由数字构造字符串在std::string类中一个值得注意的遗漏是缺乏从数字创建字符串的能力。例如:1std::string sFour&#123; 4 &#125;;产生以下错误:1c:vcprojectstest2test2test.cpp(10) : error C2664: &#39;std::basic_string&lt;_Elem,_Traits,_Ax&gt;::basic_string(std::basic_string&lt;_Elem,_Traits,_Ax&gt;::_Has_debug_it)&#39; : cannot convert parameter 1 from &#39;int&#39; to &#39;std::basic_string&lt;_Elem,_Traits,_Ax&gt;::_Has_debug_it&#39;还记得我说过字符串类会产生可怕的错误吗? 这里的相关信息是:不能将参数1从&#39;int&#39;转换为&#39;std::basic_string换句话说，它试图将int转换成字符串，但是失败了。将数字转换为字符串的最简单方法是使用std::ostringstream类。std::ostringstream（头文件&lt;sstream&gt;中）已经设置为接受来自各种来源的输入，包括字符、数字、字符串等…….。它同样能够输出字符串（可以通过提取操作符&gt;&gt;，也可以通过str()函数）。有关std::ostringstream的更多信息，请看18.4 – Stream classes for strings.这里有一个简单的解决方案来创建std::string从各种类型的输入:1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt; template &lt;typename T&gt;inline std::string ToString(T tX)&#123; std::ostringstream oStream; oStream &lt;&lt; tX; return oStream.str();&#125;int main()&#123; std::string sFour&#123; ToString(4) &#125;; std::string sSixPointSeven&#123; ToString(6.7) &#125;; std::string sA&#123; ToString('A') &#125;; std::cout &lt;&lt; sFour &lt;&lt; '\\n'; std::cout &lt;&lt; sSixPointSeven &lt;&lt; '\\n'; std::cout &lt;&lt; sA &lt;&lt; '\\n'; return 0;&#125;结果：12346.7A请注意，此解决方案省略了任何错误检查。将tX插入oStream可能会失败。一个适当的响应是在转换失败时抛出异常。将字符串转换为数字类似于上面的解决方案:12345678910111213141516171819#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt; template &lt;typename T&gt;inline bool FromString(const std::string&amp; sString, T &amp;tX)&#123; std::istringstream iStream(sString); return !(iStream &gt;&gt; tX).fail(); // extract value into tX, return success or not&#125;int main()&#123; double dX; if (FromString(\"3.4\", dX)) cout &lt;&lt; dX &lt;&lt; '\\n'; if (FromString(\"ABC\", dX)) cout &lt;&lt; dX &lt;&lt; '\\n'; &#125;结果：13.4注意，第二次转换失败并返回false。","categories":[],"tags":[]},{"title":"C&C++/std：：string and std：：wstring","slug":"C&C++/std：：string and std：：wstring","date":"2020-05-26T07:45:21.184Z","updated":"2020-05-26T08:35:59.014Z","comments":true,"path":"archives/67452a19.html","link":"","permalink":"https://longlongqin.github.io/archives/67452a19.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/17-1-stdstring-and-stdwstring/标准库包含许多有用的类——但最有用的可能是std::string。std::string(和std::wstring)是一个字符串类，它提供了许多操作来分配、比较和修改字符串。在本章中，我们将深入研究这些字符串类。注意:C-style字符串将被称为“C-style string”，而std::string(和std::wstring)将被简单地称为“string”。字符串类(字符串类的动机)的动机C风格字符串的缺点在 C-style strings中，我们介绍了c风格的字符串，它使用字符数组来存储字符串。如果您尝试过使用c风格的字符串做任何事情，那么您会很快得出这样的结论:使用c风格的字符串很麻烦，很容易出错，而且很难调试。c风格的字符串有很多缺点，主要是围绕这样一个事实:您必须自己完成所有的内存管理。例如，如果您想要分配字符串“hello!进入一个缓冲区，你必须先动态分配一个缓冲区的正确长度:12char *strHello = new char[7];//不要忘记说明null终止符的额外字符!然后你必须实际 复制值:12strcpy(strHello, \"hello!\"); &gt;//希望你使你的缓冲区足够大，所以没有缓冲区溢出!当然，因为字符串是动态分配的，你必须记住，当你处理完它时，要正确地释放它:12delete[] strHello; &gt;//不要忘记使用数组删除代替普通的删除!此外，C提供的用于处理数字的许多直观操作符(如赋值和比较)根本不适用于C风格的字符串。有时这些方法看似有效，但实际上产生了不正确的结果。例如：使用==比较两个c风格的字符串实际上会进行指针比较，而不是字符串比较。使用operator=将一个c风格的字符串赋值给另一个c风格的字符串，乍一看似乎可行，但实际上是在做指针复制(浅复制)，这通常不是您想要的。这类事情会导致程序崩溃，很难找到和调试!最后，处理c风格的字符串需要记住许多关于什么是安全/不安全的挑剔规则，记住一堆具有有趣名称的函数，如strcat()和strcmp()，而不是使用直观的操作符，并执行大量手工内存管理。幸运的是，c++和标准库提供了更好的处理字符串的方法: std::string和std::wstring类。通过使用c++概念，例如构造函数、析构函数和操作符重载，std::string允许您以一种直观和安全的方式创建和操作字符串! 不再需要内存管理，不再需要奇怪的函数名，灾难发生的可能性也大大降低。std::string概述位于 头文件&lt;string&gt;中实际上在字符串头中有3个不同的字符串类。第一个模板基类名为basic_string&lt;&gt;:12345namespace std&#123; template&lt;class charT, class traits = char_traits&lt;charT&gt;, class Allocator = allocator&lt;charT&gt; &gt; class basic_string;&#125;您不会直接使用这个类，所以暂时不要担心什么trait或 Allocator。在几乎所有可能的情况下，默认值就足够了。标准库提供了两种basic_string&lt;&gt;:12345namespace std&#123; typedef basic_string&lt;char&gt; string; typedef basic_string&lt;wchar_t&gt; wstring;&#125;这是您将实际使用的两个类。std::string用于 标准ascii和utf-8字 符串。std::wstring用于 宽字符/unicode (utf-16) 字符串。没有用于utf-32字符串的内置类(尽管如果需要的话，您应该能够从basic_string&lt;&gt;扩展自己的类)。尽管您将直接使用std::string和std::wstring，但所有字符串功能都是在basic_string&lt;&gt;类中实现的。通过模板化，String和wstring能够直接访问该功能。因此，本文提供的所有函数都可以用于string和wstring。这里是string类中所有函数的列表。这些函数中的大多数具有多种风格，可以处理不同类型的输入，我们将在接下来的课程中更深入地介绍这些内容。FunctionEffectCreation and destruction(constructor) (destructor)Create or copy a string Destroy a stringSize and capacitycapacity() empty() length(), size() max_size() reserve()Returns the number of characters that can be held without reallocation Returns a boolean indicating whether the string is empty Returns the number of characters in string Returns the maximum string size that can be allocated Expand or shrink the capacity of the stringElement access[], at()Accesses the character at a particular indexModification=, assign() +=, append(), push_back() insert() clear() erase() replace() resize() swap()Assigns a new value to the string Concatenates characters to end of the string Inserts characters at an arbitrary index in string Delete all characters in the string Erase characters at an arbitrary index in string Replace characters at an arbitrary index with other characters Expand or shrink the string (truncates or adds characters at end of string) Swaps the value of two stringsInput and Output&gt;&gt;, getline() &lt;&lt; c_str() copy() data()Reads values from the input stream into the string Writes string value to the output stream Returns the contents of the string as a NULL-terminated C-style string Copies contents (not NULL-terminated) to a character array Returns the contents of the string as a non-NULL-terminated character arrayString comparison==, != &lt;, &lt;=, &gt; &gt;= compare()Compares whether two strings are equal/unequal (returns bool) Compares whether two strings are less than / greater than each other (returns bool) Compares whether two strings are equal/unequal (returns -1, 0, or 1)Substrings and concatenation+ substr()Concatenates two strings Returns a substringSearchingfind() find_first_of() find_first_not_of() find_last_of() find_last_not_of() rfind()Find index of first character/substring Find index of first character from a set of characters Find index of first character not from a set of characters Find index of last character from a set of characters Find index of last character not from a set of characters Find index of last character/substringIterator and allocator supportbegin(), end() get_allocator() rbegin(), rend()Forward-direction iterator support for beginning/end of string Returns the allocator Reverse-direction iterator support for beginning/end of string虽然标准的库字符串类提供了很多功能，但有几个明显的遗漏:正则表达式用于从数字创建字符串的构造函数大写/大写/小写函数不区分大小写的比较标记化/将字符串拆分为数组获取字符串的左或右部分的简单函数空白修剪格式化一个字符串 sprintf 样式由utf-8转换为utf-16或反之亦然对于大多数情况，您必须编写自己的函数，或者将字符串转换为C样式的字符串(使用c_str())，并使用提供此功能的C函数。","categories":[],"tags":[]},{"title":"C&C++/algorithm","slug":"C&C++/algorithm","date":"2020-05-26T07:01:48.858Z","updated":"2020-05-26T07:18:20.422Z","comments":true,"path":"archives/38f02bc7.html","link":"","permalink":"https://longlongqin.github.io/archives/38f02bc7.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/16-4-stl-algorithms-overview/头文件：algorithm除了容器类和迭代器之外，STL还提供了一些用于处理容器类元素的通用算法。它们允许您执行诸如搜索、排序、插入、重新排序、删除和复制容器类的元素等操作。注意，算法是作为使用迭代器操作的函数来实现的。这意味着每个算法只需要实现一次，它通常会自动为所有提供一组迭代器的容器(包括您的自定义容器类)工作。虽然这是非常强大的，可以导致编写复杂代码的能力非常快，它也有一些缺点：某些算法和容器类型的组合可能不起作用，可能导致无限循环，或者可能起作用，但性能非常差。因此，使用这些在你的风险。STL提供了相当多的算法，在这里，我们只讨论一些更常见、更容易使用的方法。其余的(和完整的细节)将保存在关于STL算法的一章中。min_element 与 max_elementstd::min_element和std::max_element算法查找容器类中的最小和最大元素。std::iota生成一系列连续的值。在头文件：&lt;numeric&gt;中12345678910111213141516171819#include &lt;algorithm&gt; // ⭐std::min_element and std::max_element#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;numeric&gt; // std::iota int main()&#123; std::list&lt;int&gt; li(6); // 用从0开始的数字 填充li。 std::iota(li.begin(), li.end(), 0); std::cout &lt;&lt; *std::min_element(li.begin(), li.end()) &lt;&lt; ' ' &lt;&lt; *std::max_element(li.begin(), li.end()) &lt;&lt; '\\n'; return 0;&#125;/*结果：*/0 5","categories":[],"tags":[]},{"title":"C&C++/STL迭代器","slug":"C&C++/STL迭代器","date":"2020-05-26T02:47:38.727Z","updated":"2020-05-26T03:29:01.487Z","comments":true,"path":"archives/34a9aaba.html","link":"","permalink":"https://longlongqin.github.io/archives/34a9aaba.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/16-3-stl-iterators-overview/Iterator(迭代器)是一个对象，它可以遍历(迭代)一个容器类，而用户不需要知道容器是如何实现的。对于许多类(特别是列表和关联类)，迭代器是访问这些类元素的主要方式。操作符*：\\对迭代器的解引用将返回迭代器当前指向的元素。操作符++：将迭代器移动到容器中的下一个元素。（大多数迭代器还提供运算符——移动到前面的元素。）操作符==与!=：确定两个迭代器是否指向同一个元素的基本比较操作符。要比较两个迭代器所指向的值，首先取消对迭代器的引用，然后使用比较操作符。操作符=：将迭代器分配到一个新位置(通常是容器元素的开始或结束位置)。要分配迭代器所指向的元素的值，首先对迭代器解引用，然后使用赋值操作符(=)。每个容器包含四个基本的成员函数，用于操作符=:begin()：返回一个迭代器，表示容器中元素的开头。end()：返回一个迭代器，该迭代器表示元素的末尾。cbegin()：返回一个const(只读)迭代器，表示容器中元素的开头。cend()：返回一个const(只读)迭代器，表示元素的末尾。最后，所有容器都提供(至少)两种迭代器:container::iterator：提供了一个读/写迭代器container::const_iterator：提供了一个只读迭代器例子遍历一个 vector12345678910111213141516171819#include &lt;iostream&gt;#include &lt;vector&gt; int main()&#123; std::vector&lt;int&gt; vect; for (int count=0; count &lt; 6; ++count) vect.push_back(count); std::vector&lt;int&gt;::const_iterator it; // declare a read-only iterator it = vect.cbegin(); // assign it to the start of the vector while (it != vect.cend()) // while it hasn't reach the end &#123; std::cout &lt;&lt; *it &lt;&lt; \" \"; // print the value of the element it points to ++it; // and iterate to the next element &#125; std::cout &lt;&lt; '\\n';&#125;遍历list(列表)1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;list&gt; int main()&#123; std::list&lt;int&gt; li; for (int count=0; count &lt; 6; ++count) li.push_back(count); std::list&lt;int&gt;::const_iterator it; // declare an iterator it = li.cbegin(); // assign it to the start of the list while (it != li.cend()) // while it hasn't reach the end &#123; std::cout &lt;&lt; *it &lt;&lt; \" \"; // print the value of the element it points to ++it; // and iterate to the next element &#125; std::cout &lt;&lt; '\\n';&#125;注意，代码几乎与向量的情况相同，尽管向量和列表的内部实现几乎完全不同!遍历一个set(集合)在下面的例子中，我们将从6个数字创建一个集合，并使用迭代器来打印集合中的值:1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;set&gt; int main()&#123; std::set&lt;int&gt; myset; myset.insert(7); myset.insert(2); myset.insert(-6); myset.insert(8); myset.insert(1); myset.insert(-4); std::set&lt;int&gt;::const_iterator it; // declare an iterator it = myset.cbegin(); // assign it to the start of the set while (it != myset.cend()) // while it hasn't reach the end &#123; std::cout &lt;&lt; *it &lt;&lt; \" \"; // print the value of the element it points to ++it; // and iterate to the next element &#125; std::cout &lt;&lt; '\\n';&#125;注意，尽管填充集合的方式与填充 vector 和 list的方式不同，但是用于迭代集合元素的代码在本质上是相同的。遍历map(映射)这个有点复杂。Maps and multimaps 取元素对(定义为std::pair)。我们使用make_pair()辅助函数来轻松地创建对。*std::pair *允许通过第一个和第二个成员访问pair的元素。在我们的map中，我们使用first作为键，second作为值。1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;string&gt; int main()&#123; std::map&lt;int, std::string&gt; mymap; mymap.insert(std::make_pair(4, \"apple\")); mymap.insert(std::make_pair(2, \"orange\")); mymap.insert(std::make_pair(1, \"banana\")); mymap.insert(std::make_pair(3, \"grapes\")); mymap.insert(std::make_pair(6, \"mango\")); mymap.insert(std::make_pair(5, \"peach\")); auto it&#123; mymap.cbegin() &#125;; // declare a const iterator and assign to start of vector while (it != mymap.cend()) // while it hasn't reach the end &#123; std::cout &lt;&lt; it-&gt;first &lt;&lt; \"=\" &lt;&lt; it-&gt;second &lt;&lt; \" \"; // print the value of the element it points to ++it; // and iterate to the next element &#125; std::cout &lt;&lt; '\\n';&#125;请注意，迭代器很容易遍历容器的每个元素。您根本不需要关心map如何存储数据!","categories":[],"tags":[]},{"title":"C&C++/容器类STL","slug":"C&C++/容器类STL","date":"2020-05-26T01:17:51.614Z","updated":"2020-05-26T02:44:38.151Z","comments":true,"path":"archives/ef749515.html","link":"","permalink":"https://longlongqin.github.io/archives/ef749515.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/16-2-stl-containers-overview/到目前为止，STL库最常用的功能是STL容器类。如果您需要快速复习一下容器类，请查看10.6 – Container classes。STL包含许多不同的容器类，可以在不同的情况下使用。一般来说，容器类分为三个基本类别:序列容器关联容器容器适配器序列容器序列容器是维护容器中元素顺序的容器类。序列容器的一个定义特性是，您可以根据位置选择元素的插入位置。序列容器最常见的例子是数组：如果您将四个元素插入到一个数组中，那么这些元素将按照您插入它们的确切顺序排列。在c++ 11中，STL包含6个序列容器:std::vector在头文件：vector中std::deque在头文件：deque中std::arraystd::liststd::forward_liststd::basic_stringstd::vector如果你学过物理，你可能会认为矢量是同时具有大小和方向的实体。但是，STL中名为vector的类是一个动态数组，能够根据需要增长以包含它的元素。vector类允许通过操作符[]随机访问它的元素，并且插入和删除vector中末尾的元素通常是很快的。下面的程序将6个数字插入到一个向量中，并使用重载的[]运算符访问它们以打印它们。123456789101112131415161718#include &lt;vector&gt;#include &lt;iostream&gt; int main()&#123; std::vector&lt;int&gt; vect; for (int count=0; count &lt; 6; ++count) vect.push_back(10 - count); // insert at end of array for (int index=0; index &lt; vect.size(); ++index) std::cout &lt;&lt; vect[index] &lt;&lt; ' '; std::cout &lt;&lt; '\\n';&#125;/*结果*/10 9 8 7 6 5std::dequedeque类(发音为“deck”)是一个双端队列类，实现为一个可以从两端增长的动态数组。1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;deque&gt; int main()&#123; std::deque&lt;int&gt; deq; for (int count=0; count &lt; 3; ++count) &#123; deq.push_back(count); // insert at end of array deq.push_front(10 - count); // insert at front of array &#125; for (int index=0; index &lt; deq.size(); ++index) std::cout &lt;&lt; deq[index] &lt;&lt; ' '; std::cout &lt;&lt; '\\n';&#125;/*结果*/8 9 10 0 1 2std::liststd::list是一种特殊类型的序列容器，称为双链表，其中容器中的每个元素都包含指向列表中的下一个和前一个元素的指针。std::list只提供对列表的开始和结束的访问。不提供随机访问。如果您想要在中间找到一个值，您必须从一端开始并“遍历列表”，直到找到您想要找到的元素。通常使用迭代器遍历列表。列表的优点是，如果您已经知道要将元素插入到列表的何处，那么将元素插入到列表中会非常快。特殊的：string尽管STL string(和wstring)类通常不作为一种序列容器类型包含在内，但它们实际上是，因为它们可以被认为是一个带有char(或wchar)类型数据元素的向量。关联容器关联容器是在将输入插入容器时自动对其输入排序的容器。默认情况下，关联容器使用操作符&lt;比较元素。set是一个容器，它存储惟一的元素，不允许有重复的元素。元素根据它们的值排序。multiset是一个允许重复元素的集合。map(也称为关联数组)是一个集合，其中每个元素都是一对，称为键/值对。该键用于对数据进行排序和索引，并且必须是唯一的。值是实际的数据。multimap(也称为字典) 是允许重复键的映射。所有键按升序排列，你可以通过键查找值。现实生活中的字典是多种多样的:键是单词，而值是单词的含义。有些单词可以有多种含义，这就是为什么字典是多用途地图而不是地图的原因。容器适配器容器适配器是适应特定用途的特殊预定义容器。关于容器适配器的有趣之处在于，您可以选择希望它们使用的序列容器。stack(栈)是一个容器，元素在后进先出上下文中操作。栈默认使用deque作为它们的默认序列容器(这看起来很奇怪，因为vector似乎更适合)，但可以使用vector或 list。queue(队列)是一个容器，元素在FIFO(先入先出)上下文中操作，元素被插入(推入)到容器的后面，然后从前面删除(弹出)。队列默认使用deque，但也可以使用list。*priority queue(优先队列) * 是一种保持元素排序的队列(通过操作符&lt;)。推入元素时，元素在队列中排序。从前端删除一个元素将 返回 优先队列中优先级最高的项。","categories":[],"tags":[]},{"title":"C&C++/标准库","slug":"C&C++/标准库","date":"2020-05-26T00:48:20.949Z","updated":"2020-05-26T00:59:31.475Z","comments":true,"path":"archives/b054a192.html","link":"","permalink":"https://longlongqin.github.io/archives/b054a192.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/16-1-the-standard-template-library-stl/恭喜你! 您已经完成了教程的主要部分!前面的课程中，我们介绍了许多c++语言的主要特性(包括c++ 11/14/17语言扩展中的一些特性)。因此，显而易见的问题是，“下一步是什么?”你可能注意到的一件事是，很多程序都在反复使用相同的概念:循环、字符串、数组、排序等等…… 您可能还注意到，使用容器的非类版本和通用算法编写程序很容易出错。好消息是，c++附带了一个充满了可重用类的库，您可以在其中构建程序。这个库称为c++标准库。The Standard Library标准库包含一组提供模板容器、算法和迭代器的类。如果您需要一个公共类或算法，标准库中很可能就有。这样做的好处是，您可以利用这些类，而不需要自己编写和调试这些类，而且标准库很好地提供了这些类的相当有效的版本。缺点是标准库很复杂，而且可能有点吓人，因为所有东西都是模板化的。幸运的是，您可以将标准库分成小块，只使用需要的部分，而忽略其他部分，直到您准备好处理它。在接下来的几节课中，我们将从高层次上了解标准库提供的容器、算法和迭代器的类型。在以后的课程中，我们将深入探讨一些特定的类。","categories":[],"tags":[]},{"title":"C&C++/std：：shared_ptr和std：：weak_ptr的循环依赖问题","slug":"C&C++/std：：shared_ptr和std：：weak_ptr的循环依赖问题","date":"2020-05-25T14:51:17.282Z","updated":"2020-05-25T16:55:14.593Z","comments":true,"path":"archives/8cf18577.html","link":"","permalink":"https://longlongqin.github.io/archives/8cf18577.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/15-7-circular-dependency-issues-with-stdshared_ptr-and-stdweak_ptr/在上一节课中，我们了解了std::shared_ptr如何允许多个智能指针共同拥有相同的资源。然而，在某些情况下，这可能会成为问题。考虑下面的情况，两个独立对象中的共享指针都指向另一个对象:12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;memory&gt; // for std::shared_ptr#include &lt;string&gt; class Person&#123; std::string m_name; std::shared_ptr&lt;Person&gt; m_partner; // initially created empty public: Person(const std::string &amp;name): m_name(name) &#123; std::cout &lt;&lt; m_name &lt;&lt; \" created\\n\"; &#125; ~Person() &#123; std::cout &lt;&lt; m_name &lt;&lt; \" destroyed\\n\"; &#125; friend bool partnerUp(std::shared_ptr&lt;Person&gt; &amp;p1, std::shared_ptr&lt;Person&gt; &amp;p2) &#123; if (!p1 || !p2) return false; p1-&gt;m_partner = p2; p2-&gt;m_partner = p1; std::cout &lt;&lt; p1-&gt;m_name &lt;&lt; \" is now partnered with \" &lt;&lt; p2-&gt;m_name &lt;&lt; \"\\n\"; return true; &#125;&#125;; int main()&#123; auto lucy = std::make_shared&lt;Person&gt;(\"Lucy\"); // create a Person named \"Lucy\" auto ricky = std::make_shared&lt;Person&gt;(\"Ricky\"); // create a Person named \"Ricky\" partnerUp(lucy, ricky); // Make \"Lucy\" point to \"Ricky\" and vice-versa return 0;&#125;在上面的例子中，我们使用make_shared()动态分配两个person，“Lucy”和“Ricky” (以确保Lucy和Ricky在main()的末尾被销毁) 。然后我们把它们合起来(即。调用函数partnerUp)。这将std::shared_ptr内的“Lucy”指向“Ricky”，而std::shared_ptr内的“Ricky”指向“Lucy”。共享指针是用来共享的，所以lucy共享指针和Rick的m_partner共享指针都指向“lucy”是可以的(反之亦然)。但是，这个程序并没有按照预期执行:123Lucy createdRicky createdLucy is now partnered with Ricky没有按照预期进行资源释放，发生了什么？调用partnerUp()之后，有两个指向“Ricky” (ricky和lucy的m_partner) 的共享指针，以及两个指向“Lucy” (Lucy和Ricky的m_partner) 的共享指针。在函数结束时，ricky共享指针首先超出作用域。当这种情况发生时，ricky会检查是否有其他共享指针共同拥有这个Person“Ricky”。是有的(Lucy的m_partner)。正因为如此，它没有释放“Ricky”(如果释放了，那么Lucy的m_partner将以一个悬浮指针结束)。现在，我们有一个指向“Ricky”(Lucy的m_partner)的共享指针，还有两个指向“Lucy”(Lucy，和Ricky的m_partner)的共享指针。接下来，lucy共享指针超出范围，同样的事情发生了。共享指针lucy检查是否有其他共享指针共同拥有这个人“lucy”。是有的(Ricky的m_partner)，所以“Lucy”没有被释放。此时，有一个共享指针指向“Lucy”(Ricky的m_partner)，还有一个共享指针指向“Ricky”(Lucy的m_partner)。然后程序就结束了—— “Lucy” 和 “Ricky” 都没有被释放! 从本质上讲，“Lucy”最终阻止了 “Ricky”被毁灭， “Ricky”最终阻止了“Lucy”被毁灭。事实证明，这种情况在共享指针形成循环引用的任何时候都可能发生。循环引用循环引用是一系列引用，其中每个对象引用下一个对象，最后一个对象引用回第一个对象，从而导致引用循环。这些引用不需要是实际的c++引用——它们可以是指针、惟一id或任何其他标识特定对象的方法。在共享指针的上下文中，引用将是指针。这正是我们在上面的例子中看到的:“Lucy” 指向 “Ricky”；而 “Ricky” 也指向 “Lucy” 。用三个指针，当A点在B点，B点在C点，C点在A点，会得到同样的结果。共享指针形成循环的实际效果是，每个对象最终保持下一个对象为活动状态（最后一个对象保持第一个对象为活动状态。）因此，在这个系列中没有对象可以被释放，因为它们都认为其他一些对象仍然需要它!单个std::shared_ptr也可以造成循环依赖问题1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;memory&gt; // for std::shared_ptr class Resource&#123;public: std::shared_ptr&lt;Resource&gt; m_ptr; // initially created empty Resource() &#123; std::cout &lt;&lt; \"Resource acquired\\n\"; &#125; ~Resource() &#123; std::cout &lt;&lt; \"Resource destroyed\\n\"; &#125;&#125;; int main()&#123; auto ptr1 = std::make_shared&lt;Resource&gt;(); ptr1-&gt;m_ptr = ptr1; // ⭐m_ptr现在正在共享包含它自己的资源 return 0;&#125;在上面的例子中，当ptr1超出作用域时，它不会释放资源，因为资源的m_ptr正在共享资源。然后就没有人可以删除资源了(m_ptr永远不会超出作用域，所以它永远不会有机会)。因此，程序打印:1Resource acquiredstd::weak_ptr来解决循环依赖问题std::weak_ptr是为了解决上面描述的“周期性所有权”问题而设计的。std::weak_ptr是一个观察者——它可以 像std::shared_ptr一样 观察和访问(或其他std::weak_ptrs)相同的对象，但它不被视为所有者。请记住，当一个std::shared指针超出作用域时，它只考虑其他std::shared_ptr是否共同拥有该对象。std: weak_ptr不算数!让我们使用std::weak_ptr来解决本节中刚开始的例子:12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;memory&gt; // for std::shared_ptr and std::weak_ptr#include &lt;string&gt; class Person&#123; std::string m_name; std::weak_ptr&lt;Person&gt; m_partner; // ⭐⭐⭐note: This is now a std::weak_ptr public: Person(const std::string &amp;name): m_name(name) &#123; std::cout &lt;&lt; m_name &lt;&lt; \" created\\n\"; &#125; ~Person() &#123; std::cout &lt;&lt; m_name &lt;&lt; \" destroyed\\n\"; &#125; friend bool partnerUp(std::shared_ptr&lt;Person&gt; &amp;p1, std::shared_ptr&lt;Person&gt; &amp;p2) &#123; if (!p1 || !p2) return false; p1-&gt;m_partner = p2; p2-&gt;m_partner = p1; std::cout &lt;&lt; p1-&gt;m_name &lt;&lt; \" is now partnered with \" &lt;&lt; p2-&gt;m_name &lt;&lt; \"\\n\"; return true; &#125;&#125;; int main()&#123; auto lucy = std::make_shared&lt;Person&gt;(\"Lucy\"); auto ricky = std::make_shared&lt;Person&gt;(\"Ricky\"); partnerUp(lucy, ricky); return 0;&#125;结果：12345Lucy createdRicky createdLucy is now partnered with RickyRicky destroyedLucy destroyed在功能上，它的工作方式几乎与有问题的示例相同。但是，现在当ricky超出范围时，它会看到没有其他std::shared_ptr指向“ricky”(来自“Lucy”的std::weak_ptr不计算)。因此，它将释放“Ricky”。露西也是如此。std::weak_ptr 的使用std::weak_ptr缺点是不能直接使用(它们没有操作符-&gt;)。要使用std::weak_ptr，必须首先将其转换为std::shared_ptr。然后可以使用std::shared_ptr。要将std::weak_ptr转换为std::shared_ptr，可以使用lock()成员函数。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;memory&gt; // for std::shared_ptr and std::weak_ptr#include &lt;string&gt; class Person&#123; std::string m_name; std::weak_ptr&lt;Person&gt; m_partner; // note: This is now a std::weak_ptr public: Person(const std::string &amp;name) : m_name(name) &#123; std::cout &lt;&lt; m_name &lt;&lt; \" created\\n\"; &#125; ~Person() &#123; std::cout &lt;&lt; m_name &lt;&lt; \" destroyed\\n\"; &#125; friend bool partnerUp(std::shared_ptr&lt;Person&gt; &amp;p1, std::shared_ptr&lt;Person&gt; &amp;p2) &#123; if (!p1 || !p2) return false; p1-&gt;m_partner = p2; p2-&gt;m_partner = p1; std::cout &lt;&lt; p1-&gt;m_name &lt;&lt; \" is now partnered with \" &lt;&lt; p2-&gt;m_name &lt;&lt; \"\\n\"; return true; &#125; const std::shared_ptr&lt;Person&gt; getPartner() const &#123; return m_partner.lock(); &#125; //⭐⭐⭐ use lock() to convert weak_ptr to shared_ptr const std::string&amp; getName() const &#123; return m_name; &#125;&#125;; int main()&#123; auto lucy = std::make_shared&lt;Person&gt;(\"Lucy\"); auto ricky = std::make_shared&lt;Person&gt;(\"Ricky\"); partnerUp(lucy, ricky); auto partner = ricky-&gt;getPartner(); // get shared_ptr to Ricky's partner std::cout &lt;&lt; ricky-&gt;getName() &lt;&lt; \"'s partner is: \" &lt;&lt; partner-&gt;getName() &lt;&lt; '\\n'; return 0;&#125;结果：123456Lucy createdRicky createdLucy is now partnered with RickyRicky&#39;s partner is: LucyRicky destroyedLucy destroyed我们不需要担心与std::shared_ptr变量“m_partner”的循环依赖关系，因为它只是函数内部的一个局部变量。它最终将在函数结束时超出作用域，引用计数将递减1。小结std::hared_ptr可以在需要多个智能指针共享资源时使用。当最后一个std::shared_ptr超出作用域时，资源将被释放。std::weak_ptr可以在需要智能指针时使用，该指针可以查看和使用共享资源，但不参与该资源的所有权","categories":[],"tags":[]},{"title":"C&C++/智能指针“std：：shared_ptr”","slug":"C&C++/智能指针“std：：shared_ptr”","date":"2020-05-25T00:43:16.239Z","updated":"2020-05-25T08:43:42.578Z","comments":true,"path":"archives/96b73b83.html","link":"","permalink":"https://longlongqin.github.io/archives/96b73b83.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/15-6-stdshared_ptr/std::unique_ptr智能指针std::unique_ptr，旨在单独拥有和管理一种资源。而，智能指针std::shared_ptr，旨在解决需要多个智能指针共同拥有一个资源的情况。也就是说，多个std::shared_ptr指向同一个资源是没有问题的。std::shared_ptr 位于头文件&lt;memory&gt; 之中（std::unique_ptr也在该头文件中）当多个std::shared_ptr指向同一资源，使用“复制”在内部，std::shared_ptr 会跟踪共享资源的 std::shared_ptr的数量。只要有至少一个std::shared_ptr指向该资源，该资源就不会被释放，即使单个std::shared_ptr被销毁。只有在这些众多指向同一资源的 std::shared_ptr 中的最后一个 超出其作用域（或者 被重新分配指向其他东西）时，这个资源才会被释放。12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;memory&gt; // for std::shared_ptr class Resource&#123;public: Resource() &#123; std::cout &lt;&lt; \"Resource acquired\\n\"; &#125; ~Resource() &#123; std::cout &lt;&lt; \"Resource destroyed\\n\"; &#125;&#125;; int main()&#123; // 分配一个资源对象，并让std::shared_ptr 拥有它 Resource *res = new Resource; std::shared_ptr&lt;Resource&gt; ptr1(res); &#123; std::shared_ptr&lt;Resource&gt; ptr2(ptr1); // 使用复制初始化 使另一个std::shared_ptr指向相同的对象 std::cout &lt;&lt; \"Killing one shared pointer\\n\"; &#125; // ptr2超出了范围，但是什么也没有发生 std::cout &lt;&lt; \"Killing another shared pointer\\n\"; return 0;&#125; // ptr1超出了这里的范围，分配的资源被销毁结果：1234Resource acquiredKilling one shared pointerKilling another shared pointerResource destroyed在上面的代码中，我们创建了一个动态 资源对象，并设置了一个名为ptr1的std::shared_ptr来管理它。在嵌套块内部，我们使用复制初始化 (std::shared_ptr允许这样做，因为资源可以共享) 来创建第二个std::shared_ptr (ptr2)，它指向相同的资源。当ptr2超出范围时，资源不会被释放，因为ptr1仍然指向资源。当ptr1超出范围时，ptr1注意到不再有std::shared_ptr管理资源，因此它释放资源。注意，我们从第一个共享指针创建了第二个共享指针(使用复制初始化)。这是很重要的。考虑以下类似的方案:123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;memory&gt; // for std::shared_ptr class Resource&#123;public: Resource() &#123; std::cout &lt;&lt; \"Resource acquired\\n\"; &#125; ~Resource() &#123; std::cout &lt;&lt; \"Resource destroyed\\n\"; &#125;&#125;; int main()&#123; Resource *res = new Resource; std::shared_ptr&lt;Resource&gt; ptr1(res); &#123; std::shared_ptr&lt;Resource&gt; ptr2(res); // ⭐直接从res创建ptr2(而不是ptr1) std::cout &lt;&lt; \"Killing one shared pointer\\n\"; &#125; // ptr2 goes out of scope here, and the allocated Resource is destroyed std::cout &lt;&lt; \"Killing another shared pointer\\n\"; return 0;&#125; // ptr1 goes out of scope here, and the allocated Resource is destroyed again结果：12345Resource acquiredKilling one shared pointerResource destroyedKilling another shared pointerResource destroyed这里的不同之处在于，我们分别创建了两个std::shared_ptr。因此，即使它们都指向相同的资源，它们也不知道对方的存在。（具体解释在下面） 当ptr2超出范围时，它认为自己是资源的唯一所有者，并释放资源。当ptr1稍后超出范围时，它会进行相同的思考，并再次尝试删除资源。然后坏事发生了。幸运的是，当需要多个共享指针指向同一资源时，可以通过使用复制赋值或复制初始化轻松避免这种情况。规则:如果需要多个指向同一资源的std::shared_ptr，则始终复制一个现有的std::shared_ptr。std::make_shared就像std::make_unique()可以用来在c++ 14中创建一个std::unique_ptr；std::make_shared()可以用来创建一个std::shared_ptr。std::make_shared()在c++ 11中可用。这是我们最初的例子，使用std::make_shared():123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;memory&gt; // for std::shared_ptr class Resource&#123;public: Resource() &#123; std::cout &lt;&lt; \"Resource acquired\\n\"; &#125; ~Resource() &#123; std::cout &lt;&lt; \"Resource destroyed\\n\"; &#125;&#125;; int main()&#123; // 分配一个Resource对象，并将其所有权 给std::shared_ptr auto ptr1 = std::make_shared&lt;Resource&gt;(); &#123; auto ptr2 = ptr1; // 使用ptr1的复制初始化创建ptr2 std::cout &lt;&lt; \"Killing one shared pointer\\n\"; &#125; // ptr2 goes out of scope here, but nothing happens std::cout &lt;&lt; \"Killing another shared pointer\\n\"; return 0;&#125; // ptr1 goes out of scope here, and the allocated Resource is destroyed使用std::make_shared()的原因与std::make_unique()相同。std::make_shared()更简单、更安全 (但无法使用此方法直接创建指向同一资源的两个std::shared_ptr)。std::shared_ptr实际上包含两个指针std::unique_ptr，它在内部使用一个指针；而std::shared_ptr，它在内部使用两个指针。一个指针指向被管理的资源。其他的点指向一个“控制块”。它是一个动态分配的对象，跟踪一堆东西，包括有多少std::shared_ptr指向资源。当通过std::shared_ptr的构造函数 创建std::shared_ptr时，将分别分配 托管对象(通常传入) 和 控制块(构造函数创建) 的内存。但是，在使用std::make_shared()时，可以将其优化为单个内存分配，从而提高性能。独立创建两个指向相同资源的std::shared_ptr会出错这也解释了为什么独立地创建两个指向相同资源的std::shared_ptr会给我们带来麻烦。每个std::shared_ptr都有一个指向资源的指针。但是，每个std::shared_ptr将独立地分配它自己的控制块，这将表明它是唯一拥有该资源的指针。因此，当std::shared_ptr超出作用域时，它将释放资源，而没有意识到还有其他std::shared_ptr也试图管理该资源。但是，当使用复制赋值克隆std::shared_ptr时，可以适当地更新控制块中的数据，以指示现在有额外的std::shared_ptr共同管理资源。std::shared_ptr可以std::unique_ptr中创建一个std::unique_ptr可以通过一个特殊的std::shared_ptr构造函数转换成一个std::shared_ptr，这个构造函数接受一个std::unique_ptr r-value。std::unique_ptr的内容将被移动到std::shared_ptr。但是，std::shared_ptr不能安全地转换为std::unique_ptr。这意味着，如果要创建一个将返回智能指针的函数，最好返回一个std::unique_ptr，并在适当的时候将其分配给一个std::shared_ptr。std::shared_ptr的危害std::shared_ptr遇到了一些与std::unique_ptr相同的挑战：如果没有正确地处理std::shared_ptr (可能是因为它是动态分配的且从未删除，也可能是因为它是动态分配且从未删除的对象的一部分) 那么它所管理的资源也不会被释放。使用std::unique_ptr，您只需要担心一个智能指针被正确处理。对于std::shared_ptr，您必须考虑所有这些问题。如果管理资源的std::shared_ptr中的任何一个没有被正确销毁，资源将不会被正确释放。std::shared_ptr和数组在c++ 14和更早的版本中，std::shared_ptr不支持管理数组，不应该用于管理C风格的数组。从c++ 17开始，std::shared_ptr就支持数组了。但是，从c++ 17开始，std::make_shared仍然缺乏对数组的适当支持，不应该用于创建共享数组。这可能会在c++ 20中得到解决。小结std::shared_ptr是为需要多个智能指针共同管理同一资源而设计的。当管理资源的最后一个std::shared_ptr被销毁时，资源将被释放。","categories":[],"tags":[]},{"title":"C&C++/智能指针“std：：unique_ptr”","slug":"C&C++/智能指针“std：：unique_ptr”","date":"2020-05-24T02:38:03.842Z","updated":"2020-05-24T09:34:02.132Z","comments":true,"path":"archives/e8f15917.html","link":"","permalink":"https://longlongqin.github.io/archives/e8f15917.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/15-5-stdunique_ptr/智能指针是一个管理动态分配对象的类。尽管智能指针可以提供其他特性，但智能指针的定义特征是它管理动态分配的资源，并确保在适当的时间(通常是当智能指针超出范围时)正确地清理动态分配的对象。因此，智能指针永远不应该自己动态分配 (否则，智能指针可能没有被释放，这意味着它拥有的对象将不会被释放，从而导致内存泄漏)。通过在栈上分配智能指针(作为局部变量或类的组合成员)，我们可以保证当智能指针包含的函数或对象结束时，它将正确地超出作用域，确保智能指针拥有的对象被正确释放。c++ 11标准库附带了4个智能指针类:std::auto_ptr(你不应该使用它——它在c++ 17中被删除了)，std::unique_ptr, ⭐std::shared_ptrstd::weak_ptr。其中，std::unique_ptr是使用最多的智能指针类，所以，就主要讲一下这个指针类。std::unique_ptr在头文件 &lt;memory&gt; 中在C++11中，std::unique_ptr是std::auto_ptr 的替代品。它应该用于管理任何不被多个对象共享的动态分配的对象。也就是说，std::unique_ptr应该完全拥有它管理的对象，而不是与其他类共享该所有权。一个例子：1234567891011121314151617#include &lt;iostream&gt;#include &lt;memory&gt; // for std::unique_ptr class Resource&#123;public: Resource() &#123; std::cout &lt;&lt; \"Resource acquired\\n\"; &#125; ~Resource() &#123; std::cout &lt;&lt; \"Resource destroyed\\n\"; &#125;&#125;; int main()&#123; // allocate a Resource object and have it owned by std::unique_ptr std::unique_ptr&lt;Resource&gt; res&#123; new Resource() &#125;; //⭐ return 0;&#125; // res goes out of scope here, and the allocated Resource is destroyed因为std::unique_ptr是在这里的栈上分配的，所以它最终肯定会超出范围，当超出范围时，它将删除它正在管理的资源。std::unique_ptr内置使用移动语义12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;memory&gt; // for std::unique_ptr class Resource&#123;public: Resource() &#123; std::cout &lt;&lt; \"Resource acquired\\n\"; &#125; ~Resource() &#123; std::cout &lt;&lt; \"Resource destroyed\\n\"; &#125;&#125;; int main()&#123; std::unique_ptr&lt;Resource&gt; res1&#123; new Resource&#123;&#125; &#125;; // Resource created here std::unique_ptr&lt;Resource&gt; res2&#123;&#125;; // Start as nullptr std::cout &lt;&lt; \"res1 is \" &lt;&lt; (static_cast&lt;bool&gt;(res1) ? \"not null\\n\" : \"null\\n\"); std::cout &lt;&lt; \"res2 is \" &lt;&lt; (static_cast&lt;bool&gt;(res2) ? \"not null\\n\" : \"null\\n\"); // res2 = res1; //无法编译: 因为std::unique_ptr 禁止复制赋值 res2 = std::move(res1); // res2假定为 所有者，res1设置为null std::cout &lt;&lt; \"Ownership transferred\\n\"; std::cout &lt;&lt; \"res1 is \" &lt;&lt; (static_cast&lt;bool&gt;(res1) ? \"not null\\n\" : \"null\\n\"); std::cout &lt;&lt; \"res2 is \" &lt;&lt; (static_cast&lt;bool&gt;(res2) ? \"not null\\n\" : \"null\\n\"); return 0;&#125; // Resource 在res2超出作用域时被销毁结果：1234567Resource acquiredres1 is not nullres2 is nullOwnership transferredres1 is nullres2 is not nullResource destroyed因为std::unique_ptr在设计时考虑到了移动语义，所以禁用了复制初始化和复制赋值。如果要传输std::unique_ptr管理的内容，必须使用移动语义。在上面的程序中，我们通过std::move(它将res1转换为r-value，这将触发一个 移动赋值，而不是一个复制赋值)来完成这个任务。访问被管理的对象std::unique_ptr有一个重载的操作符*和操作符-&gt;，可以用来返回被管理的资源。操作符*返回对托管资源的引用；操作符-&gt;返回一个指针。请记住，std::unique_ptr可能并不总是管理一个对象 —— 这可能是因为它创建为空 (使用默认构造函数或传递nullptr作为参数)；也可能是因为它所管理的资源被移动到了另一个std::unique_ptr。因此，在使用这两种操作符之前，我们应该检查std::unique_ptr是否确实有资源。幸运的是，这很简单：std::unique_ptr有一个到bool的强制转换，如果std::unique_ptr正在管理一个资源，该转换将返回true。123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;memory&gt; // for std::unique_ptr class Resource&#123;public: Resource() &#123; std::cout &lt;&lt; \"Resource acquired\\n\"; &#125; ~Resource() &#123; std::cout &lt;&lt; \"Resource destroyed\\n\"; &#125; friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Resource &amp;res) &#123; out &lt;&lt; \"I am a resource\\n\"; return out; &#125;&#125;; int main()&#123; std::unique_ptr&lt;Resource&gt; res&#123; new Resource&#123;&#125; &#125;; if (res) // 使用隐式强制转换为bool 以确保res包含资源 std::cout &lt;&lt; *res &lt;&lt; '\\n'; // print the Resource that res is owning⭐⭐⭐ return 0;&#125;结果：123Resource acquiredI am a resourceResource destroyed注意：上面例子中的：std::cout &lt;&lt; *res &lt;&lt; &#39;\\n&#39;;这一句，实际上为：std::operator&lt;&lt;(operator&lt;&lt;(std::cout, res.operator*()), &#39;\\n&#39;);也就是说，这里的操作符* 实际上是返回的是 引用。在上面的程序中，我们使用重载操作符*获取std::unique_ptr res拥有的资源对象，然后将其发送到std::cout进行打印。std::unique_ptr和数组与std::auto_ptr不同，std::unique_ptr足够智能，可以知道是使用标量删除还是数组删除，因此std::unique_ptr可以用于标量对象和数组。但是，std::array或std::vector(或std::string )几乎总是比使用固定数组、动态数组或c风格的字符串的std::unique_ptr更好的选择。std::make_uniquec++ 14附带了一个名为std::make_unique()的附加函数。这个模板函数构造一个模板类型的对象，并用传入函数的参数对其进行初始化。123456789101112131415161718192021222324252627282930313233343536#include &lt;memory&gt; // for std::unique_ptr and std::make_unique#include &lt;iostream&gt; class Fraction&#123;private: int m_numerator&#123; 0 &#125;; int m_denominator&#123; 1 &#125;; public: Fraction(int numerator = 0, int denominator = 1) : m_numerator&#123; numerator &#125;, m_denominator&#123; denominator &#125; &#123; &#125; friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction &amp;f1) &#123; out &lt;&lt; f1.m_numerator &lt;&lt; \"/\" &lt;&lt; f1.m_denominator; return out; &#125;&#125;; int main()&#123; // 用分子3和分母5创建一个动态分配的Fraction std::unique_ptr&lt;Fraction&gt; f1&#123; std::make_unique&lt;Fraction&gt;(3, 5) &#125;; std::cout &lt;&lt; *f1 &lt;&lt; '\\n'; // 创建一个长度为4的Fraction的动态分配数组 // 在这里我们也可以使用自动类型推断来达到很好的效果 auto f2&#123; std::make_unique&lt;Fraction[]&gt;(4) &#125;; std::cout &lt;&lt; f2[0] &lt;&lt; '\\n'; return 0;&#125;结果：123&#x2F;50&#x2F;1使用std::make_unique()是可选的，但建议不要自己创建std::unique_ptr。这是因为使用std::make_unique的代码更简单，而且需要的输入也更少(与自动类型推断一起使用时)。此外，它还解决了一个异常安全问题，这个问题可能是由于c++没有指定函数参数的计算顺序而导致的。使用std::make_unique()而不是创建std::unique_ptr并自己使用new更详细的看异常安全问题对于那些想知道上面提到的“异常安全问题”是什么，这里是对这个问题的描述。考虑这样一个表达:1some_function(std::unique_ptr&lt;T&gt;(new T), function_that_can_throw_exception());编译器在处理这个调用方面有很大的灵活性。它可以创建一个新的T，然后调用function_that_can_throw_exception()，然后创建std::unique_ptr来管理动态分配的T。如果function_that_can_throw_exception()抛出异常，那么分配的T将不会被回收，因为执行回收的智能指针还没有创建。这导致了T被泄露。std::make_unique()不会遇到这个问题，因为对象T的创建和std::unique_ptr的创建都发生在std::make_unique()函数中，在这个函数中，执行顺序没有歧义。从函数返回std::unique_ptrstd::unique_ptr可以安全地从一个函数返回值:12345678910111213std::unique_ptr&lt;Resource&gt; createResource()&#123; return std::make_unique&lt;Resource&gt;();&#125; int main()&#123; std::unique_ptr&lt;Resource&gt; ptr&#123; createResource() &#125;; // do whatever return 0;&#125;在上面的代码中，createResource()按值返回std::unique_ptr。如果未将此值赋给任何值，则临时返回值将超出范围，资源将被清理。如果它被赋值 (如main()所示)，在c++ 14或更早的版本中，将使用move语义将资源从返回值转移到赋值的对象(在上面的示例ptr中)而在c++ 17或更新版本中，将省略返回。这使得通过std::unique_ptr返回资源比返回原始指针安全得多!通常，您不应该通过 指针 或 引用 返回std::unique_ptr(除非您有特定的强制理由)。,应该直接返回std::unique_ptr将std::unique_ptr传递给一个函数获得传入参数的所有权如果希望函数获得指针内容的所有权，请按值传递std::unique_ptr。注意，由于已经禁用了复制语义，因此需要使用std::move来实际传入变量（如果传入参数是左值时，需要）。12345678910111213141516171819202122232425262728293031#include &lt;memory&gt; // for std::unique_ptr class Resource&#123;public: Resource() &#123; std::cout &lt;&lt; \"Resource acquired\\n\"; &#125; ~Resource() &#123; std::cout &lt;&lt; \"Resource destroyed\\n\"; &#125; friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Resource &amp;res) &#123; out &lt;&lt; \"I am a resource\\n\"; return out; &#125;&#125;; void takeOwnership(std::unique_ptr&lt;Resource&gt; res) ⭐&#123; if (res) std::cout &lt;&lt; *res &lt;&lt; '\\n';&#125; // the Resource is destroyed here int main()&#123; auto ptr&#123; std::make_unique&lt;Resource&gt;() &#125;; // takeOwnership(ptr); 这不起作用，需要使用移动语义⭐⭐ takeOwnership(std::move(ptr)); // ok: use move semantics std::cout &lt;&lt; \"Ending program\\n\"; return 0;&#125;结果：1234Resource acquiredI am a resourceResource destroyedEnding program注意，在这种情况下，Resource的所有权被转移到takeOwnership()，因此Resource在takeOwnership()的末尾而不是main()的末尾被销毁。不获得传入参数的所有权但是，在大多数情况下，您不希望函数取得资源的所有权。虽然可以通过引用传递std::unique_ptr(这将允许函数使用对象而不拥有该对象)，但是应该只在调用的函数可能更改或改变被管理的对象时才这样做。相反，最好只传递资源本身(通过指针或引用传递，这取决于null是否为有效参数)。这允许函数不知道调用方是如何管理其资源的。要从std::unique_ptr获得原始资源指针，可以使用get()成员函数:123456789101112131415161718192021222324252627282930313233#include &lt;memory&gt; // for std::unique_ptr#include &lt;iostream&gt; class Resource&#123;public: Resource() &#123; std::cout &lt;&lt; \"Resource acquired\\n\"; &#125; ~Resource() &#123; std::cout &lt;&lt; \"Resource destroyed\\n\"; &#125; friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Resource &amp;res) &#123; out &lt;&lt; \"I am a resource\\n\"; return out; &#125;&#125;; // 该函数只使用该资源，因此我们将接受指向该资源的指针，而不是对整个std::unique_ptr&lt; resource &gt;的引用void useResource(Resource *res)&#123; if (res) std::cout &lt;&lt; *res &lt;&lt; '\\n';&#125; int main()&#123; auto ptr&#123; std::make_unique&lt;Resource&gt;() &#125;; useResource(ptr.get()); // 注意:这里使用get()获取指向资源的指针 std::cout &lt;&lt; \"Ending program\\n\"; return 0;&#125; // The Resource is destroyed here结果：1234Resource acquiredI am a resourceEnding programResource destroyedstd::unique_ptr 和 类当然，您可以使用std::unique_ptr作为类的组合成员。这样，您就不必担心类析构函数会不会删除动态内存，因为std::unique_ptr将在类对象被销毁时自动销毁。但是，请注意，如果您的类对象是动态分配的，那么对象本身就有可能没有被正确释放，在这种情况下，即使使用智能指针也无济于事。滥用std:: unique_ptr有两种容易误用std::unique_ptr的方法，这两种方法都很容易避免。首先，不要让多个类管理相同的资源。例如:123Resource *res&#123; new Resource() &#125;;std::unique_ptr&lt;Resource&gt; res1&#123; res &#125;;std::unique_ptr&lt;Resource&gt; res2&#123; res &#125;;虽然这在语法上是合法的，但是最终的结果是res1和res2都将尝试删除资源，这将导致未定义的行为。其次，不要在std::unique_ptr中手动删除资源。123Resource *res&#123; new Resource() &#125;;std::unique_ptr&lt;Resource&gt; res1&#123; res &#125;;delete res;如果这样做，那么std::unique_ptr将尝试删除已经删除的资源，再次导致未定义的行为。注意，std::make_unique()可以防止上述两种情况在无意中发生。","categories":[],"tags":[]},{"title":"C&C++/std：：move","slug":"C&C++/std：：move","date":"2020-05-24T02:00:58.451Z","updated":"2020-05-24T02:34:45.481Z","comments":true,"path":"archives/323fcdb7.html","link":"","permalink":"https://longlongqin.github.io/archives/323fcdb7.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/15-4-stdmove/一旦您开始更经常地使用move语义，您就会开始发现需要调用move语义的情况，但是您必须使用的对象是l-values，而不是r-values。以下面的swap函数为例:1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt; template&lt;class T&gt;void myswap(T&amp; a, T&amp; b) &#123; T tmp &#123; a &#125;; // invokes copy constructor a = b; // invokes copy assignment b = tmp; // invokes copy assignment&#125; int main()&#123; std::string x&#123; \"abc\" &#125;; std::string y&#123; \"de\" &#125;; std::cout &lt;&lt; \"x: \" &lt;&lt; x &lt;&lt; '\\n'; std::cout &lt;&lt; \"y: \" &lt;&lt; y &lt;&lt; '\\n'; myswap(x, y); std::cout &lt;&lt; \"x: \" &lt;&lt; x &lt;&lt; '\\n'; std::cout &lt;&lt; \"y: \" &lt;&lt; y &lt;&lt; '\\n'; return 0;&#125;传入两个类型为T的对象(在本例中是std::string)，这个函数通过创建三个副本来交换它们的值。因此，这个程序打印:1234x: abcy: dex: dey: abc正如我们上节课所示，复制的效率可能很低。这个版本的swap会复制3份。这会导致大量的字符串创建和销毁，这是缓慢的。但是，这里没有必要进行复制。我们真正要做的是交换a和b的值，用3步就可以完成! 因此，如果我们从复制语义切换到移动语义，我们可以使我们的代码更具有性能。但是，这里的问题是，参数a和b是l-value引用，而不是r-value引用，所以我们没有办法调用移动构造函数和移动赋值运算符，来替换 复制构造函数和复制赋值。默认情况下，我们获得复制构造函数和复制赋值行为。我们该怎么办?std::move在c++ 11中，std::move是一个标准的库函数，它的作用只有一个——将它的参数转换成r-value。我们可以向std::move传递一个l-value，它将返回一个r-value引用。std::move在头文件：utility中定义。下面是与上面相同的程序，但是使用了一个myswap()函数，该函数使用std::move将我们的l-values转换成r-values，这样我们就可以调用移动语义:123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;utility&gt; // for std::move⭐ template&lt;class T&gt;void myswap(T&amp; a, T&amp; b) &#123; T tmp &#123; std::move(a) &#125;; // invokes move constructor⭐ a = std::move(b); // invokes move assignment⭐ b = std::move(tmp); // invokes move assignment⭐&#125; int main()&#123; std::string x&#123; \"abc\" &#125;; std::string y&#123; \"de\" &#125;; std::cout &lt;&lt; \"x: \" &lt;&lt; x &lt;&lt; '\\n'; std::cout &lt;&lt; \"y: \" &lt;&lt; y &lt;&lt; '\\n'; myswap(x, y); std::cout &lt;&lt; \"x: \" &lt;&lt; x &lt;&lt; '\\n'; std::cout &lt;&lt; \"y: \" &lt;&lt; y &lt;&lt; '\\n'; return 0;&#125;结果：1234x: abcy: dex: dey: abc这样更有效率。初始化tmp时，我们使用std::move将l-value变量x转换为r-value，而不是复制x。由于参数是r-value，因此调用move语义，并将x移动到tmp中。通过多次交换，变量x的值被移动到y, y的值也被移动到x。在std::vector中使用std::move我们还可以在填充容器的元素时使用std::move，例如使用 l-value 填充std::vector。在接下来的程序中，我们首先使用复制语义向 向量 添加一个元素。然后使用移动语义向向量添加一个元素。12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;utility&gt; // for std::move#include &lt;vector&gt; int main()&#123; std::vector&lt;std::string&gt; v; std::string str = \"Knock\"; std::cout &lt;&lt; \"Copying str\\n\"; v.push_back(str); // calls l-value version of push_back, which copies str into the array element std::cout &lt;&lt; \"str: \" &lt;&lt; str &lt;&lt; '\\n'; std::cout &lt;&lt; \"vector: \" &lt;&lt; v[0] &lt;&lt; '\\n'; std::cout &lt;&lt; \"\\nMoving str\\n\"; v.push_back(std::move(str)); // calls r-value version of push_back, which moves str into the array element std::cout &lt;&lt; \"str: \" &lt;&lt; str &lt;&lt; '\\n'; std::cout &lt;&lt; \"vector:\" &lt;&lt; v[0] &lt;&lt; ' ' &lt;&lt; v[1] &lt;&lt; '\\n'; return 0;&#125;/*结果*/Copying strstr: Knockvector: KnockMoving strstr: //⭐⭐⭐vector: Knock Knock在第一种情况下，我们向push_back()传递一个l-value，因此它使用复制语义向向量添加一个元素。由于这个原因，str中的值被保留了。在第二种情况下，我们向push_back()传递了一个r-value (实际上是一个通过std::move转换的l值)，因此它使用move语义向向量添加一个元素。这更有效，因为向量元素可以窃取字符串的值，而不必复制它。在本例中，str为空。注意，在使用移动语义后，被使用的对象（在本例为str）中的数据会被窃取给 使用移动语义的对象。所以，移动语句执行之后，被使用的对象的值将不复存在。std::move在什么地方比较有用？在对元素数组进行排序时，std::move也很有用。许多排序算法(如选择排序和冒泡排序)都是通过交换元素对来实现的。在以前的课程中，我们不得不求助于复制语义来进行交换。现在我们可以使用移动语义，这是更有效的。如果我们希望将一个智能指针管理的内容移动到另一个智能指针，它也很有用。小结当我们想把 l-value 当作 r-value 来调用 移动语义 而不是 复制语义 时，可以使用std::move。","categories":[],"tags":[]},{"title":"C&C++/移动构造函数和移动赋值","slug":"C&C++/移动构造函数和移动赋值","date":"2020-05-23T03:35:13.868Z","updated":"2020-05-23T14:52:20.823Z","comments":true,"path":"archives/68c36619.html","link":"","permalink":"https://longlongqin.github.io/archives/68c36619.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/15-3-move-constructors-and-move-assignment/在这节课中，我们将深入了解c++ 11如何通过移动构造函数和移动赋值来解决这些问题。复制构造函数和复制赋值复制构造函数用于通过复制同一个类的对象来初始化一个类。复制赋值用于将一个类复制到另一个现有类。默认情况下，如果没有显式提供，c++将提供复制构造函数和复制赋值操作符。这些编译器提供的函数执行浅拷贝，这可能会给分配动态内存的类带来问题。因此，处理动态内存的类应该覆盖这些函数来执行深度复制。让我们回到本章第一节课（https://www.yuque.com/longlongqin/pw9qpx/pn4iny）的Auto_ptr智能指针类的例子，让我们看看一个实现了复制构造函数和复制赋值运算符的版本，**它可以进行深度复制**，以及一个执行这些操作的示例程序:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566template&lt;class T&gt;class Auto_ptr3&#123; T* m_ptr;public: Auto_ptr3(T* ptr = nullptr) :m_ptr(ptr) &#123; &#125; ~Auto_ptr3() &#123; delete m_ptr; &#125; // Copy constructor // Do deep copy of a.m_ptr to m_ptr（深度复制） Auto_ptr3(const Auto_ptr3&amp; a) &#123; m_ptr = new T; *m_ptr = *a.m_ptr; &#125; // Copy assignment // Do deep copy of a.m_ptr to m_ptr（深度复制） Auto_ptr3&amp; operator=(const Auto_ptr3&amp; a) &#123; // Self-assignment detection if (&amp;a == this) return *this; // Release any resource we're holding delete m_ptr; // Copy the resource m_ptr = new T; *m_ptr = *a.m_ptr; return *this; &#125; T&amp; operator*() const &#123; return *m_ptr; &#125; T* operator-&gt;() const &#123; return m_ptr; &#125; bool isNull() const &#123; return m_ptr == nullptr; &#125;&#125;; class Resource&#123;public: Resource() &#123; std::cout &lt;&lt; \"Resource acquired\\n\"; &#125; ~Resource() &#123; std::cout &lt;&lt; \"Resource destroyed\\n\"; &#125;&#125;; Auto_ptr3&lt;Resource&gt; generateResource()&#123; Auto_ptr3&lt;Resource&gt; res(new Resource); return res; // this return value will invoke the copy constructor&#125; int main()&#123; Auto_ptr3&lt;Resource&gt; mainres; mainres = generateResource(); // this assignment will invoke the copy assignment return 0;&#125;在这个程序中，我们使用一个名为generateResource()的函数来创建一个封装了资源的智能指针，然后将其传递回函数main()。函数main()然后将其赋值给一个现有的Auto_ptr3对象。结果：123456Resource acquiredResource acquiredResource destroyedResource acquiredResource destroyedResource destroyed对于这样一个简单的程序来说，需要创建和销毁大量的资源!这是怎么回事？让我们仔细看看。在这个程序中有6个关键步骤(每个打印消息一个):在generateResource()内部，使用动态分配的资源创建并初始化局部变量res，这将导致第一个“Resource acquired”。Res通过值返回到main()。我们在这里通过值返回，因为res是一个局部变量——它不能通过地址或引用返回，因为当generateResource()结束时res将被销毁。因此res被拷贝创建到一个临时对象中。因为我们的复制构造函数做了深度复制，所以在这里分配了一个新的资源，这将导致第二个“Resource acquired”。Res超出范围，破坏最初创建的资源，从而导致第一个“Resource destroyed”。临时对象通过复制分配被分配给mainres。由于我们的复制赋值也是深度复制，所以会分配一个新的资源，从而导致另一个“Resource acquired”。赋值表达式结束，临时对象超出表达式范围并被销毁，导致“Resource destroyed”。在main()的末尾，mainres超出范围，并显示最终的“Resource destroyed”。因此，简而言之，因为我们调用复制构造函数一次来将构造res复制到一个临时对象，而调用复制赋值一次来将临时对象复制到mainres，我们最终总共分配和销毁了3个单独的对象。效率很低，但至少它不会崩溃!移动构造函数和移动赋值但是，使用移动语义，我们可以做得更好。c++ 11定义了两个新的函数来服务于移动语义：移动构造函数、移动赋值复制构造函数和复制赋值的目的是将一个对象复制到另一个对象；它的参数要求：const l-value reference parameter（const 的左值引用 作为形参）移动构造函数和移动赋值的目标是将资源的所有权从一个对象转移到另一个对象(这比复制要便宜得多)。它的参数要求：non-const r-value reference parameters（非const 的右值引用 作为形参）这里是与上面相同的Auto_ptr3类，使用移动构造函数和移动赋值 运算符。为了进行比较，我们在深度复制复制构造函数和复制赋值操作符中留了一个。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt; template&lt;class T&gt;class Auto_ptr4&#123; T* m_ptr;public: Auto_ptr4(T* ptr = nullptr) :m_ptr(ptr) &#123; &#125; ~Auto_ptr4() &#123; delete m_ptr; &#125; // Copy constructor // Do deep copy of a.m_ptr to m_ptr Auto_ptr4(const Auto_ptr4&amp; a) &#123; m_ptr = new T; *m_ptr = *a.m_ptr; &#125; // Move constructor⭐⭐⭐ // Transfer ownership of a.m_ptr to m_ptr Auto_ptr4(Auto_ptr4&amp;&amp; a) : m_ptr(a.m_ptr) &#123; a.m_ptr = nullptr; // we'll talk more about this line below &#125; // Copy assignment // Do deep copy of a.m_ptr to m_ptr Auto_ptr4&amp; operator=(const Auto_ptr4&amp; a) &#123; // Self-assignment detection if (&amp;a == this) return *this; // Release any resource we're holding delete m_ptr; // Copy the resource m_ptr = new T; *m_ptr = *a.m_ptr; return *this; &#125; // Move assignment⭐⭐⭐ // Transfer ownership of a.m_ptr to m_ptr Auto_ptr4&amp; operator=(Auto_ptr4&amp;&amp; a) &#123; // Self-assignment detection if (&amp;a == this) return *this; // Release any resource we're holding delete m_ptr; // Transfer ownership of a.m_ptr to m_ptr m_ptr = a.m_ptr; a.m_ptr = nullptr; // we'll talk more about this line below return *this; &#125; T&amp; operator*() const &#123; return *m_ptr; &#125; T* operator-&gt;() const &#123; return m_ptr; &#125; bool isNull() const &#123; return m_ptr == nullptr; &#125;&#125;; class Resource&#123;public: Resource() &#123; std::cout &lt;&lt; \"Resource acquired\\n\"; &#125; ~Resource() &#123; std::cout &lt;&lt; \"Resource destroyed\\n\"; &#125;&#125;; Auto_ptr4&lt;Resource&gt; generateResource()&#123; Auto_ptr4&lt;Resource&gt; res(new Resource); return res; // this return value will invoke the move constructor&#125; int main()&#123; Auto_ptr4&lt;Resource&gt; mainres; mainres = generateResource(); // this assignment will invoke the move assignment return 0;&#125;移动构造函数和移动赋值操作符很简单。我们只是移动(窃取)源对象的资源，而不是将源对象(a)深度复制到隐式对象中。这涉及到将源指针浅复制到隐式对象中，然后将源指针设置为null。结果：12Resource acquiredResource destroyed这就简洁很多了。程序的流程和以前完全一样。但是，这个程序不是调用复制构造函数和复制赋值操作符，而是调用移动构造函数和移动赋值操作符。再看得深一点:在generateResource()内部，使用动态分配的资源创建并初始化局部变量res，这将导致第一个“Resource acquired”。Res通过值返回到main()。Res被构造成一个临时对象，将存储在Res中的动态创建的对象传递给临时对象。我们将在下面讨论为什么会发生这种情况。Res超出了范围。因为res不再管理指针(它被移动到临时指针)，所以这里没有什么有趣的事情发生。临时对象 被移动赋值给mainres。这将 动态创建的对象 存储到 临时对象mainres 中。赋值表达式结束，临时对象超出表达式作用域并被销毁。但是，因为临时不再管理指针(它被移动到mainres)，所以这里也没有什么有趣的事情发生。在main()的末尾，mainres超出范围，并显示最终的“Resource destroyed”。移动语义的背后现在您已经有了足够的上下文来理解移动语义背后的关键见解。如果我们构造一个对象或者做一个赋值，参数是l-value，我们唯一能做的就是*复制 *l-value。我们不能假定改变l-value是安全的，因为它可能在以后的程序中再次使用。如果我们有一个表达式“a = b”，我们就不会希望b会以任何方式改变。然而，如果我们构造一个对象或者做一个赋值，其中参数是r-value，那么我们知道r-value只是某种临时对象。与其复制它(这可能很昂贵)，我们可以简单地将它的资源(这很便宜)转移到我们正在构造或分配的对象。这样做是安全的，因为这个临时的表达式将在表达式的最后被销毁，所以我们知道它将永远不会再被使用!c++ 11，通过r-value引用，使我们能够在参数是r-value还是l-value时提供不同的行为，使我们能够更聪明、更有效地决定我们的对象应该如何行为。移动函数应该始终保持两个对象处于良好定义的状态在上面的例子中，移动构造函数 和 移动赋值函数 都将a.m_ptr设置为nullptr。这似乎无关紧要——毕竟，如果“a”是一个临时的r-value，如果参数“a”无论如何都将被销毁，为什么还要做“清除”呢?答案很简单：当“a”超出范围时，将调用a的析构函数，a.m_ptr将被删除。 如果在此时，a.m_ptr仍然指向与m_ptr相同的对象，然后m_ptr将保留为空悬指针。当包含m_ptr的对象最终被使用(或销毁)时，我们将得到未定义的行为。由“值”返回的l-value 会自动用“移动”而不是“复制”在上面Auto_ptr4示例的generateResource()函数中，当变量res由值返回时，它将被移动而不是复制，即使res是一个l-value。c++规范有一个特殊的规则，该规则说，从函数按值返回的自动对象可以移动，即使它们是l-value。这是有意义的，因为res将在函数的末尾被销毁! 我们还不如窃取它的资源，而不是制造一个昂贵且不必要的副本。虽然编译器可以移动l-value返回值，但是在某些情况下，它甚至可以通过完全省略复制来做得更好(这避免了复制或移动)。在这种情况下，既不调用复制构造函数，也不调用移动构造函数。禁用复制在上面的Auto_ptr4类中，我们将 复制构造函数 和 赋值运算符 留作比较之用。但在支持移动的类中，有时需要删除 复制构造函数 和 复制赋值函数，以确保不进行复制。在Auto_ptr类的情况下，我们不想复制我们的模板对象T——因为它很昂贵，而且不管T是什么类，都可能不支持复制!这是Auto_ptr的一个版本，支持移动语义，但不支持复制语义:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt; template&lt;class T&gt;class Auto_ptr5&#123; T* m_ptr;public: Auto_ptr5(T* ptr = nullptr) :m_ptr(ptr) &#123; &#125; ~Auto_ptr5() &#123; delete m_ptr; &#125; // Copy constructor -- no copying allowed!⭐ Auto_ptr5(const Auto_ptr5&amp; a) = delete; // Move constructor⭐⭐ // Transfer ownership of a.m_ptr to m_ptr Auto_ptr5(Auto_ptr5&amp;&amp; a) : m_ptr(a.m_ptr) &#123; a.m_ptr = nullptr; &#125; // Copy assignment -- no copying allowed!⭐ Auto_ptr5&amp; operator=(const Auto_ptr5&amp; a) = delete; // Move assignment⭐⭐ // Transfer ownership of a.m_ptr to m_ptr Auto_ptr5&amp; operator=(Auto_ptr5&amp;&amp; a) &#123; // Self-assignment detection if (&amp;a == this) return *this; // Release any resource we're holding delete m_ptr; // Transfer ownership of a.m_ptr to m_ptr m_ptr = a.m_ptr; a.m_ptr = nullptr; return *this; &#125; T&amp; operator*() const &#123; return *m_ptr; &#125; T* operator-&gt;() const &#123; return m_ptr; &#125; bool isNull() const &#123; return m_ptr == nullptr; &#125;&#125;;如果试图按值向函数传递一个 Auto_ptr5类型的l-value，编译器会报错：初始化复制构造函数参数所需的复制构造函数已被删除。这很好，因为我们可能应该通过const l-value引用传递Auto_ptr5 !Auto_ptr5是(最后)一个好的智能指针类。事实上，标准库包含一个非常类似的类(您应该使用它)，名为std::unique_ptr。我们将在本章稍后讨论std::unique_ptr。测试 使用“复制”和“移动”之间的性能差别让我们看一下另一个使用动态内存的类: 一个简单的动态模板化数组。该类包含一个深度复制复制构造函数和复制赋值操作符。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt; template &lt;class T&gt;class DynamicArray&#123;private: T* m_array; int m_length; public: DynamicArray(int length) : m_array(new T[length]), m_length(length) &#123; &#125; ~DynamicArray() &#123; delete[] m_array; &#125; // Copy constructor(深度复制) DynamicArray(const DynamicArray &amp;arr) : m_length(arr.m_length) &#123; m_array = new T[m_length]; for (int i = 0; i &lt; m_length; ++i) m_array[i] = arr.m_array[i]; &#125; // Copy assignment（深度复制） DynamicArray&amp; operator=(const DynamicArray &amp;arr) &#123; if (&amp;arr == this) return *this; delete[] m_array; m_length = arr.m_length; m_array = new T[m_length]; for (int i = 0; i &lt; m_length; ++i) m_array[i] = arr.m_array[i]; return *this; &#125; int getLength() const &#123; return m_length; &#125; T&amp; operator[](int index) &#123; return m_array[index]; &#125; const T&amp; operator[](int index) const &#123; return m_array[index]; &#125; &#125;;我们可以使用 8.16 – Timing your code中的函数，来测试：深度复制、移动语义 这两者实现的程序之间的性能的差别。具体测试代码：详见https://www.learncpp.com/cpp-tutorial/15-3-move-constructors-and-move-assignment/ 中的“Another example”板块。比较两个程序的运行时，0.0056 / 0.00825559 = 67.8%。移动版本几乎快了33% !","categories":[],"tags":[]},{"title":"C&C++/右值引用","slug":"C&C++/右值引用","date":"2020-05-22T01:51:10.157Z","updated":"2020-05-22T03:39:10.220Z","comments":true,"path":"archives/145edd42.html","link":"","permalink":"https://longlongqin.github.io/archives/145edd42.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/15-2-rvalue-references/回到第一章，我们提到了左值和右值，然后告诉你们不要太担心它们。在c++ 11之前，这是一个公平的建议。但是在c++ 11中理解移动语义需要重新审视这个主题。现在我们来做一下。左值与右值尽管在它们的名字中有“value”这个词，l-values和r-values实际上并不是值的属性，而是表达式的属性。c++中的每个表达式都有两个属性:类型(用于类型检查) 和 值类别(用于某些类型的语法检查，例如表达式的结果是否可以赋值)。在c++ 03和更早的版本中，l-值和r-值是仅有的两个可用的值类别。左值：将l-value(也称为locator值)： 视为函数或对象 (或计算结果 为函数或对象的表达式) 是最简单的。所有的左值都有指定的内存地址。当左值最初被定义时，它们被定义为“适合位于赋值表达式左侧的值”。但是，后来，const关键字被添加到语言中，左值被分为两个子类别:可修改的左值(其值可被修改)；不可修改的左值(其值不可被修改)，被const限定。右值：把右值看作 “不是左值的所有东西” 是最简单的。这显然包括文字(例如5)、临时值(例如x+1 ) 和匿名对象(例如 Fraction(5,2))。右值通常针对它们的值进行计算，具有表达式作用域(在它们所在的表达式结束时死亡)，并且不能被赋值。这个不能被赋值规则是有意义的，因为赋值会对对象产生副作用。因为右值有表达式作用域，如果我们将一个值赋值给右值，这个右值会在 我们在下一个表达式中使用它时 超出作用域。或者，我们必须在表达式中多次使用具有副作用的变量(到目前为止，您应该知道导致未定义行为的原因!)3个新的值类别为了支持移动语义，c++ 11引入了3个新的值类别:pr-values；x-values；gl-values；如果您感兴趣， cppreference.com 提供了一个广泛的表达式列表，这些表达式适用于各种值类别，以及关于它们的更多详细信息。左值引用在c++ 11之前，只有一种类型的引用存在于c++中，因此它被称为“引用”。然而，在c++ 11中，它有时被称为l-value引用。左值引用只能用 可修改的左值 初始化。L-value referenceCan be initialized withCan modifyModifiable l-valuesYesYesNon-modifiable l-valuesNoNoR-valuesNoNo被const限定的L-value对象 引用 可以用 l-values和r-values 进行初始化。但是，这些值不能修改。L-value reference to constCan be initialized withCan modifyModifiable l-valuesYesNoNon-modifiable l-valuesYesNoR-valuesYesNo对const对象的L-value引用特别有用，因为它们允许我们将任何类型的参数(L-value或r-value)传递到函数中，而不需要复制参数。右值引用c++ 11添加了一种称为 r-value引用 的新引用类型。r-value引用 是一个被设计为只能使用 r-value 来初始化的引用。左值引用 的定义使用一个&amp;符号；右值引用 的定义使用两个&amp;符号；123int x&#123;5&#125;;int &amp;lref&#123;x&#125;; //左值引用使用 左值x 来初始化int &amp;&amp;rref&#123;5&#125;; //右值引用使用 右值5 来初始化右值引用 不能使用 左值来初始化。R-value referenceCan be initialized withCan modifyModifiable l-valuesNoNoNon-modifiable l-valuesNoNoR-valuesYesYesR-value reference to constCan be initialized withCan modifyModifiable l-valuesNoNoNon-modifiable l-valuesNoNoR-valuesYesNoR-value引用有两个有用的属性。首先，r-value引用 将 初始化它们的对象 的生命周期延长 ( 对const对象的l-value引用也可以做到这一点)。非常量的右值引用 允许您修改它的右值!看一个例子：123456789101112131415161718192021222324252627282930#include &lt;iostream&gt; class Fraction&#123;private: int m_numerator; int m_denominator; public: Fraction(int numerator = 0, int denominator = 1) : m_numerator&#123; numerator &#125;, m_denominator&#123; denominator &#125; &#123; &#125; friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction &amp;f1) &#123; out &lt;&lt; f1.m_numerator &lt;&lt; '/' &lt;&lt; f1.m_denominator; return out; &#125;&#125;; int main()&#123; auto &amp;&amp;rref&#123; Fraction&#123; 3, 5 &#125; &#125;; // r-value 引用一个 临时的Fraction // f1 的operator&lt;&lt; 绑定到临时的Fraction，不创建副本。 std::cout &lt;&lt; rref &lt;&lt; '\\n'; return 0;&#125; // rref (and the temporary Fraction) goes out of scope here结果：13&#x2F;5作为一个匿名对象的Fraction(3, 5) 通常会在定义它的表达式结束时超出范围。但是，由于我们正在用它初始化一个r-value引用，它的生命周期被延长到块的末尾。然后我们可以使用r值引用来打印Fraction的值。现在让我们看一个不那么直观的例子:12345678910111213#include &lt;iostream&gt; int main()&#123; int &amp;&amp;rref&#123; 5 &#125;; // 因为我们正在用文字常量初始化一个r-value引用，所以这里创建了一个值为5的临时引用 rref = 10; std::cout &lt;&lt; rref &lt;&lt; '\\n'; return 0;&#125;/*结果*/10虽然用一个文字值初始化一个r-value引用然后能够改变那个值看起来很奇怪，但是当用一个文字值初始化一个r-value引用时，一个文字值得临时值 将被构建，所以这个引用引用的是一个临时对象，而不是一个文字值。在上述两种方式中，右值引用都不常用。右值引用作为函数参数R-value引用通常用作函数参数。当您希望对l-value和r-value参数有不同的行为时，这对于函数重载非常有用。12345678910111213141516171819202122void fun(const int &amp;lref) // l-value arguments will select this function&#123; std::cout &lt;&lt; \"l-value reference to const\\n\";&#125; void fun(int &amp;&amp;rref) // r-value arguments will select this function&#123; std::cout &lt;&lt; \"r-value reference\\n\";&#125; int main()&#123; int x&#123; 5 &#125;; fun(x); // l-value argument calls l-value version of function fun(5); // r-value argument calls r-value version of function return 0;&#125;/*将打印*/l-value reference to constr-value reference你为什么要这么做?我们将在下一课中更详细地讨论这个问题。不用说，它是移动语义的重要组成部分。注意一个有趣的东西：12int &amp;&amp;ref&#123;4&#125;;fun(ref);这实际会调用函数的l-value版本! 虽然虽然变量ref的类型是 r-value引用一个字面常量整数，但它实际上是一个l-value本身(所有命名变量都是这样)。造成这种混淆的原因是在两个不同的上下文中使用了“右值”这个词。我们可以这样想：被命名的对象 是 左值；匿名对象 是 右值。无论是 命名对象 还是 匿名对象的类型 与它本身是 左值还是右值 无关。所以，上面的ref被命名了（名字就是ref），所以 对象ref 是一个左值。也就是说：它是一个 右值引用 的被命名的对象。返回一个右值引用您几乎不应该返回一个r-value引用，同理，您几乎不应该返回一个l-value引用。在大多数情况下，当被引用的对象在函数结束时超出作用域时，您将返回一个挂起的引用。","categories":[],"tags":[]},{"title":"C&C++/智能指针与移动语义","slug":"C&C++/智能指针与移动语义","date":"2020-05-21T03:15:50.748Z","updated":"2020-05-21T09:02:33.186Z","comments":true,"path":"archives/cace6777.html","link":"","permalink":"https://longlongqin.github.io/archives/cace6777.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/15-1-intro-to-smart-pointers-move-semantics/考虑一个函数，我们动态分配一个值:12345678void someFunction()&#123; Resource *ptr = new Resource; // Resource是一个结构体或者类 //操作 delete ptr;&#125;尽管上面的代码看起来相当简单，但是很容易忘记释放ptr。即使您记得在函数结束时删除ptr，如果函数提前退出，也有许多方法可以不删除ptr。通过提前返回:1234567891011121314151617#include &lt;iostream&gt; void someFunction()&#123; Resource *ptr = new Resource; int x; std::cout &lt;&lt; \"Enter an integer: \"; std::cin &gt;&gt; x; if (x == 0) return; // 函数提前返回，ptr不会被删除! // do stuff with ptr here delete ptr;&#125;通过抛出异常:1234567891011121314151617#include &lt;iostream&gt; void someFunction()&#123; Resource *ptr = new Resource; int x; std::cout &lt;&lt; \"Enter an integer: \"; std::cin &gt;&gt; x; if (x == 0) throw 0; // 函数提前返回，ptr不会被删除! // do stuff with ptr here delete ptr;&#125;在上述两个程序中，执行早期的return或throw语句，导致函数终止而不删除变量ptr。因此，为变量ptr分配的内存现在会泄漏(并且在每次调用此函数并提前返回时将再次泄漏)。本质上，这类问题的发生是因为指针变量本身没有内在的机制来清除。智能指针类的拯救?类最好的一点是，它们包含析构函数，当类的对象超出作用域时，析构函数会自动执行。因此，如果在构造函数中分配(或获取)内存，可以在析构函数中释放内存，并确保在销毁类对象时释放内存(不管它是否超出作用域、是否被显式删除等等)。这是我们在 8.7 – Destructors中讨论的RAII编程范例的核心。那么我们可以使用一个类来帮助我们管理和清理指针吗?我们可以!考虑这样一个类，它的唯一工作就是持有并“拥有”传递给它的指针，然后在类对象超出作用域时释放该指针。只要该类的对象仅作为局部变量创建，我们就可以保证该类将适当地超出作用域(不管我们的函数何时或如何终止)，并且所拥有的指针将被销毁。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt; template&lt;class T&gt;class Auto_ptr1&#123; T* m_ptr;public: // Pass in a pointer to \"own\" via the constructor Auto_ptr1(T* ptr=nullptr) :m_ptr(ptr) &#123; &#125; // The destructor will make sure it gets deallocated ~Auto_ptr1() &#123; delete m_ptr; &#125; // Overload dereference and operator-&gt; so we can use Auto_ptr1 like m_ptr. T&amp; operator*() const &#123; return *m_ptr; &#125; T* operator-&gt;() const &#123; return m_ptr; &#125;&#125;; // A sample class to prove the above worksclass Resource&#123;public: Resource() &#123; std::cout &lt;&lt; \"Resource acquired\\n\"; &#125; ~Resource() &#123; std::cout &lt;&lt; \"Resource destroyed\\n\"; &#125;&#125;; int main()&#123; &#123;Auto_ptr1&lt;Resource&gt; res(new Resource); &#125; // 注意这里的内存分配 // ... 但不需要显式删除 // 还要注意，角括号中的资源不需要 * 符号，因为它是由模板提供的 return 0;&#125; // res超出了这里的范围，并破坏了为我们分配的资源结果：12Resource acquiredResource destroyed考虑一下这个程序和类是如何工作的。首先，我们动态创建一个 Resource，并将其作为参数传递给模板化的Auto_ptr1类。从这一点开始，我们的Auto_ptr1变量res拥有这个Resource对象。（Auto_ptr1与m_ptr有一个复合关系。）因为res被声明为一个局部变量，并且具有块作用域，所以当块结束时，它将超出作用域，并被销毁(不用担心忘记释放它)。因为它是一个类，当它被销毁时，Auto_ptr1析构函数将被调用。这个析构函数将确保它所持有的资源指针被删除!只要Auto_ptr1被定义为一个局部变量(具有自动持续时间，因此类名的“Auto”部分)，无论函数如何终止(即使它提前终止)，资源都将保证在声明它的块的末尾被销毁。这样的类称为智能指针。智能指针是一个复合类，用于管理动态分配的内存，并确保在智能指针对象超出作用域时删除内存。(与此相关的是，内置指针有时被称为“哑指针”，因为它们自己不能清理)。现在让我们回到上面的someFunction()例子，并展示一个智能指针类如何解决我们的挑战:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt; template&lt;class T&gt;class Auto_ptr1&#123; T* m_ptr;public: // Pass in a pointer to \"own\" via the constructor Auto_ptr1(T* ptr=nullptr) :m_ptr(ptr) &#123; &#125; // The destructor will make sure it gets deallocated ~Auto_ptr1() &#123; delete m_ptr; &#125; // Overload dereference and operator-&gt; so we can use Auto_ptr1 like m_ptr. T&amp; operator*() const &#123; return *m_ptr; &#125; T* operator-&gt;() const &#123; return m_ptr; &#125;&#125;; // A sample class to prove the above worksclass Resource&#123;public: Resource() &#123; std::cout &lt;&lt; \"Resource acquired\\n\"; &#125; ~Resource() &#123; std::cout &lt;&lt; \"Resource destroyed\\n\"; &#125; void sayHi() &#123; std::cout &lt;&lt; \"Hi!\\n\"; &#125;&#125;; void someFunction()&#123; Auto_ptr1&lt;Resource&gt; ptr(new Resource); // ptr now owns the Resource int x; std::cout &lt;&lt; \"Enter an integer: \"; std::cin &gt;&gt; x; if (x == 0) return; // the function returns early // do stuff with ptr here ptr-&gt;sayHi();&#125; int main()&#123; someFunction(); return 0;&#125;如果用户输入一个非零整数，上面的程序将打印:1234Resource acquiredEnter an integer: 1HiResource destroyed如果用户输入0，以上程序将提前终止，打印:123Resource acquiredEnter an integer: 0Resource destroyed注意，即使在用户输入0并且函数提前终止的情况下，资源仍然被正确释放。因为ptr变量是一个局部变量，所以当函数终止时ptr将被销毁(不管它如何终止)。因为Auto_ptr1析构函数将清理资源，所以我们确信资源将被正确清理。一个关键的缺陷Auto_ptr1类有一个严重的缺陷，隐藏在一些自动生成的代码后面。在进一步阅读之前，看看您是否能够识别它是什么。我们会等待……Rather than tell you, we’ll show you. Consider the following program:123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt; // Same as abovetemplate&lt;class T&gt;class Auto_ptr1&#123; T* m_ptr;public: Auto_ptr1(T* ptr=nullptr) :m_ptr(ptr) &#123; &#125; ~Auto_ptr1() &#123; delete m_ptr; &#125; T&amp; operator*() const &#123; return *m_ptr; &#125; T* operator-&gt;() const &#123; return m_ptr; &#125;&#125;; class Resource&#123;public: Resource() &#123; std::cout &lt;&lt; \"Resource acquired\\n\"; &#125; ~Resource() &#123; std::cout &lt;&lt; \"Resource destroyed\\n\"; &#125;&#125;; int main()&#123; Auto_ptr1&lt;Resource&gt; res1(new Resource); Auto_ptr1&lt;Resource&gt; res2(res1); // 或者，不初始化res2，然后赋值res2 = res1; return 0;&#125;这个程序打印:123Resource acquiredResource destroyedResource destroyed您的程序很可能(但不一定)会在此时崩溃。现在看到问题了吗?因为我们没有提供复制构造函数或赋值运算符，c++为我们提供了一个。它提供的函数只做浅拷贝。因此，当我们用res1初始化res2时，Auto_ptr1变量都指向相同的资源。当res2超出范围时，它会删除资源，留下一个悬空指针给res1。当res1删除它的(已删除的)资源时，崩溃!使用移动语句(Move semantics)解决如果不让我们的复制构造函数和赋值操作符复制指针(“复制语义”)，而是将指针的所有权从源对象转移/移动到目标对象会怎么样? 这是move语义背后的核心思想。移动语义 意味着该类将转移对象的所有权，而不是复制。让我们更新我们的Auto_ptr1类，以展示如何做到这一点:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt; template&lt;class T&gt;class Auto_ptr2&#123; T* m_ptr;public: Auto_ptr2(T* ptr=nullptr) :m_ptr(ptr) &#123; &#125; ~Auto_ptr2() &#123; delete m_ptr; &#125; // 由移动语义 实现的复制构造函数 Auto_ptr2(Auto_ptr2&amp; a) // note: not const &#123; m_ptr = a.m_ptr; // 将哑指针从源对象转移到本地对象 a.m_ptr = nullptr; // 确保该指针不再拥有源对象 &#125; // 实现移动语义的赋值运算符 Auto_ptr2&amp; operator=(Auto_ptr2&amp; a) // note: not const &#123; if (&amp;a == this) return *this; delete m_ptr; // 确保我们首先释放目标已经持有的指针 m_ptr = a.m_ptr; // 然后将哑指针从源对象转移到本地对象 a.m_ptr = nullptr; // 确保该指针不再拥有源对象 return *this; &#125; T&amp; operator*() const &#123; return *m_ptr; &#125; T* operator-&gt;() const &#123; return m_ptr; &#125; bool isNull() const &#123; return m_ptr == nullptr; &#125;&#125;; class Resource&#123;public: Resource() &#123; std::cout &lt;&lt; \"Resource acquired\\n\"; &#125; ~Resource() &#123; std::cout &lt;&lt; \"Resource destroyed\\n\"; &#125;&#125;; int main()&#123; Auto_ptr2&lt;Resource&gt; res1(new Resource); Auto_ptr2&lt;Resource&gt; res2; // Start as nullptr std::cout &lt;&lt; \"res1 is \" &lt;&lt; (res1.isNull() ? \"null\\n\" : \"not null\\n\"); std::cout &lt;&lt; \"res2 is \" &lt;&lt; (res2.isNull() ? \"null\\n\" : \"not null\\n\"); res2 = res1; // res2 assumes ownership, res1 is set to null std::cout &lt;&lt; \"Ownership transferred\\n\"; std::cout &lt;&lt; \"res1 is \" &lt;&lt; (res1.isNull() ? \"null\\n\" : \"not null\\n\"); std::cout &lt;&lt; \"res2 is \" &lt;&lt; (res2.isNull() ? \"null\\n\" : \"not null\\n\"); return 0;&#125;结果：1234567Resource acquiredres1 is not nullres2 is nullOwnership transferredres1 is nullres2 is not nullResource destroyed注意，我们的重载操作符=将m_ptr的所有权从res1赋予给了res2! 因此，我们不会得到指针的副本，所有东西都会被清理干净。（智能指针的）std::auto_ptr及为什么要避免使用它现在是讨论std::auto_ptr的合适时机。std::auto_ptr是在c++ 98中引入的，它是c++对标准化智能指针的第一次尝试。std::auto_ptr选择 像Auto_ptr2类 一样实现move语义。但是，std::auto_ptr(以及我们的Auto_ptr2类)有很多问题，使得使用它很危险。首先，由于std::auto_ptr通过复制构造函数和赋值操作符(=)实现了移动语义，因此按值向函数传递std::auto_ptr将导致您的资源被移动到函数参数处 (并在函数参数超出作用域时在函数末尾销毁)。然后，当您从调用方访问auto_ptr参数时(没有意识到它已被传输和删除)，您突然取消了对空指针的引用。崩溃!其次，std::auto_ptr总是使用非数组delete删除其内容。这意味着auto_ptr不能正确地处理动态分配的数组，因为它使用了错误的重新分配类型。更糟糕的是，它不能阻止您向它传递一个动态数组，然后它会错误地管理这个数组，从而导致内存泄漏。最后，auto_ptr不能很好地处理标准库中的许多其他类，包括大多数容器和算法。这是因为这些标准库类假设当它们复制一个项时，它实际上是复制 而不是移动。由于上述缺点，std::auto_ptr在c++ 11中已经被弃用，不应该使用。事实上，std::auto_ptr将作为c++ 17的一部分从标准库中完全删除!规则:std::auto_ptr是不推荐的，不应该使用。(推荐使用std::unique_ptr或std::shared_ptr)..Moving forwardauto_ptr的设计的核心问题是，在c++ 11之前，c++语言根本没有机制来区分“复制语义”和“移动语义”。覆盖复制语义 来实现移动语义 会导致奇怪的边缘情况和意外的错误。例如，您可以编写res1 = res2，却不知道res2是否会被更改!因此，在c++ 11中，“移动”的概念被正式定义，“移动语义”被添加到语言中，以正确区分复制和移动。既然我们已经为移动语义的用处做好了准备，我们将在本章的其余部分探索移动语义的主题。我们还将使用移动语义修复Auto_ptr2类。在c++ 11中，std::auto_ptr已经被一堆其他类型的 “移动感知”智能指针 所取代：std::unique_ptr,std::weak_ptr，以及std::shared_ptr。","categories":[],"tags":[]},{"title":"C&C++/异常的缺点和危险","slug":"C&C++/异常的缺点和危险","date":"2020-05-21T02:22:53.422Z","updated":"2020-05-21T02:56:04.955Z","comments":true,"path":"archives/263cd357.html","link":"","permalink":"https://longlongqin.github.io/archives/263cd357.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/148-exception-dangers-and-downsides/与几乎所有有利因素一样，例外也有一些潜在的不利因素。本文并不是全面的，只是指出在使用异常(或决定是否使用异常)时应该考虑的一些主要问题。清理资源新程序员在使用异常时遇到的最大问题之一是当异常发生时清理资源的问题。考虑下面的例子:12345678910try&#123; openFile(filename); writeFile(filename, data); closeFile(filename);&#125;catch (FileException &amp;exception)&#123; cerr &lt;&lt; \"Failed to write to file: \" &lt;&lt; exception.what() &lt;&lt; '\\n';&#125;如果WriteFile()失败并抛出一个FileException，会发生什么情况?此时，我们已经打开了文件，现在控制流跳转到FileException处理程序，打印错误并退出。注意，该文件从未关闭过!这个例子应该改写如下:12345678910111213try&#123; openFile(filename); writeFile(filename, data); closeFile(filename);&#125;catch (FileException &amp;exception)&#123; // Make sure file is closed closeFile(filename); // Then write error cerr &lt;&lt; \"Failed to write to file: \" &lt;&lt; exception.what() &lt;&lt; '\\n';&#125;在处理动态分配的内存时，这种错误通常以另一种形式出现:12345678910try&#123; Person *john &#123; new Person(\"John\", 18, PERSON_MALE) &#125;; processPerson(john); delete john;&#125;catch (PersonException &amp;exception)&#123; std::cerr&lt;&lt; \"Failed to process person: \" &lt;&lt; exception.what() &lt;&lt; '\\n';&#125;如果processPerson()抛出异常，控制流将跳转到catch处理程序。结果，john再也没有被释放了!这个示例比前一个稍微复杂一些——因为john是try块的本地对象，所以当try块退出时，它就超出了作用域。这意味着异常处理程序根本不能访问john(它已经被销毁了)，所以它无法释放内存。然而，有两种相对简单的方法来解决这个问题。首先，在try块外部声明john，这样当try块退出时，它就不会超出作用域:123456789101112Person *john = nullptr;try&#123; john &#123; new Person(\"John\", 18, PERSON_MALE) &#125;; processPerson(john); delete john;&#125;catch (PersonException &amp;exception)&#123; delete john; cerr &lt;&lt; \"Failed to process person: \" &lt;&lt; exception.what() &lt;&lt; '\\n';&#125;因为john声明在try块之外，所以它可以在try块和catch处理程序中访问。这意味着catch处理程序可以正确地进行清理。第二种方法是使用类的局部变量，该变量知道在超出作用域时如何清除自身(通常称为“智能指针”)。标准库提供了一个名为std::unique_ptr的类，可用于此目的。std::unique_ptr是一个保存指针的模板类，当指针超出作用域时释放它。1234567891011121314#include &lt;memory&gt; // for std::unique_ptrtry&#123; Person *john &#123; new Person(\"John\", 18, PERSON_MALE) &#125;; std::unique_ptr&lt;Person&gt; upJohn &#123;john&#125;; // upJohn 现在拥有 john ProcessPerson(john); // 当upJohn超出范围时，它将删除john&#125;catch (PersonException &amp;exception)&#123; std::cerr &lt;&lt; \"Failed to process person: \" &lt;&lt; exception.what() &lt;&lt; '\\n';&#125;异常和析构函数与构造函数不同，在构造函数中抛出异常是指示对象创建未成功的一种有用方法，但是异常不应该在析构函数中抛出。当栈展开过程中从析构函数引发异常时，会发生此问题。如果发生这种情况，编译器就会处于这样一种情况: 它不知道是继续 栈展开过程 还是 处理新的异常。——最终的结果是您的程序将立即终止。因此，最好的做法就是完全避免在析构函数中使用异常。而是将消息写入日志文件。性能方面异常情况确实会带来小小的性能代价。它们会增加可执行文件的大小，而且由于必须执行额外的检查，它们还可能导致运行速度变慢。 然而，异常的主要性能损失是在实际抛出异常时发生的。在这种情况下，必须释放栈并找到适当的异常处理程序，这是一个相对昂贵的操作。需要注意的是，一些现代计算机架构支持一种称为零成本异常的异常模型。零成本异常(如果受支持)在非错误情况下没有额外的运行时成本(这是我们最关心的性能情况)。然而，在发现异常的情况下，它们会招致更大的性能消耗。什么情况下使用异常？当下列各项都为真时，最好使用异常处理:正在处理的错误可能只会偶尔发生。严重的错误，并且执行无法继续。错误不能在它发生的地方处理。没有一种好的方法可以将错误代码返回给调用者。","categories":[],"tags":[]},{"title":"C&C++/函数try块","slug":"C&C++/函数try块","date":"2020-05-21T01:44:55.082Z","updated":"2020-05-21T02:21:45.149Z","comments":true,"path":"archives/2b44a8c.html","link":"","permalink":"https://longlongqin.github.io/archives/2b44a8c.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/14-7-function-try-blocks/Try和catch块在大多数情况下都能很好地工作，但是有一种特殊情况下它们是不充分的。考虑下面的例子:1234567891011121314151617181920212223242526272829303132class A&#123;private: int m_x;public: A(int x) : m_x(x) &#123; if (x &lt;= 0) throw 1; &#125;&#125;; class B : public A&#123;public: B(int x) : A(x) &#123; // What happens if creation of A fails and we want to handle it here? &#125;&#125;; int main()&#123; try &#123; B b(0); &#125; catch (int) &#123; std::cout &lt;&lt; \"Oops\\n\"; &#125;&#125;在上面的例子中，派生类B调用基类构造函数A，这会引发异常。因为对象b的创建已经放在try块中(在main()函数中)，如果A抛出异常，main的try块会捕捉到它。因此，这个程序打印:1Oops但如果我们想在B内部捕获异常呢？在调用B构造函数的主体之前，对基构造函数A的调用通过成员初始化列表进行。没有办法在它周围包装一个标准的try块。在这种情况下，我们必须使用一个稍微修改过的try块，称为函数try块。函数try块函数try块的设计允许您围绕整个函数体建立异常处理程序，而不是围绕一个代码块。函数try块的语法有点难描述，所以我们将通过例子来说明:12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt; class A&#123;private: int m_x;public: A(int x) : m_x(x) &#123; if (x &lt;= 0) throw 1; &#125;&#125;; class B : public A&#123;public: B(int x) try : A(x) // 注意这里添加了try关键字 &#123; &#125; catch (...) // 注意，这与函数本身处于同一缩进级别 &#123; // 成员初始化器列表或构造函数体中的异常在这里捕获 std::cerr &lt;&lt; \"Exception caught\\n\"; // 如果这里没有显式地抛出异常，则将隐式地重新抛出当前异常 &#125;&#125;; int main()&#123; try &#123; B b(0); &#125; catch (int) &#123; std::cout &lt;&lt; \"Oops\\n\"; &#125;&#125;当这个程序运行时，它产生的输出:12Exception caughtOops让我们更详细地研究一下这个程序。首先，注意在成员初始化器列表之前添加了“try”关键字。这表明在该点之后 (直到函数结束) 的所有内容都应该在try块中考虑。其次，请注意，关联的catch块与整个函数的缩进级别相同。在try关键字和函数体末尾之间抛出的任何异常都可以在这里捕获。最后，与普通的catch块不同，它允许您解析异常、抛出新异常或重新抛出现有异常，使用函数级try块，您必须抛出或重新抛出异常。 如果您没有显式地抛出一个新的异常，或者重新抛出当前的异常(使用throw关键字本身)，该异常将被隐式地重新抛出栈。尽管函数级try块也可以用于非成员函数，但通常不会这样做，因为很少需要这样做。它们几乎只用于构造函数!函数try块可以捕获基类和当前类的异常在上面的例子中，如果A和B的构造函数都抛出一个异常，它将被B的构造函数周围的try块捕获。我们可以在下面的例子中看到，我们从类B而不是类A抛出一个异常:123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt; class A&#123;private: int m_x;public: A(int x) : m_x(x) &#123; &#125;&#125;; class B : public A&#123;public: B(int x) try : A(x) // note addition of try keyword here &#123; if (x &lt;= 0) // 把这个从A移到B throw 1; // 这个也被移过来 &#125; catch (...) &#123; std::cerr &lt;&lt; \"Exception caught\\n\"; // If an exception isn't explicitly thrown here, the current exception will be implicitly rethrown &#125;&#125;; int main()&#123; try &#123; B b(0); &#125; catch (int) &#123; std::cout &lt;&lt; \"Oops\\n\"; &#125;&#125;结果：12Exception caughtOops不要使用函数try块来清理资源当对象构造失败时，将不调用该类的析构函数。因此，您可能会试图使用一个 函数try块 来清理一个在失败之前已经部分分配了资源的类。但是，引用失败对象的成员被认为是未定义的行为，因为在catch块执行之前对象是“死”的。 这意味着你不能在类后使用 函数try块 来清理。如果您希望在类之后进行清理，请遵循清理抛出异常的类的标准规则（参见14.5 – Exceptions, classes, and inheritance的 “当构造函数失败时(When constructor fail)” 小节）函数try主要用于在将异常传递到栈之前记录失败，或者更改抛出异常的类型。","categories":[],"tags":[]},{"title":"C&C++/重新抛出异常","slug":"C&C++/重新抛出异常","date":"2020-05-21T00:48:12.059Z","updated":"2020-05-21T01:27:56.951Z","comments":true,"path":"archives/9b640ff1.html","link":"","permalink":"https://longlongqin.github.io/archives/9b640ff1.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/14-6-rethrowing-exceptions/有时候，您可能会遇到这样的情况:您想要捕获异常，但又不想(或有能力 )在捕获它的时候完全处理它。当您想要记录一个错误，但是将问题传递给调用者实际处理时，这是很常见的。当函数可以使用返回代码时，这很简单。考虑下面的例子:1234567891011121314151617Database* createDatabase(std::string filename)&#123; try &#123; Database *d = new Database(filename); d-&gt;open(); // assume this throws an int exception on failure return d; &#125; catch (int exception) &#123; // Database creation failed // Write an error to some global logfile g_log.logError(\"Creation of Database failed\"); &#125; return nullptr;&#125;在上面的代码片段中，函数的任务是创建数据库对象、打开数据库并返回数据库对象。在出现错误的情况下(例如传入了错误的文件名)，异常处理程序记录一个错误，然后合理地返回一个空指针。现在考虑以下函数:1234567891011121314151617int getIntValueFromDatabase(Database *d, std::string table, std::string key)&#123; assert(d); try &#123; return d-&gt;getIntValue(table, key); // throws int exception on failure &#125; catch (int exception) &#123; // Write an error to some global logfile g_log.logError(\"doSomethingImportant failed\"); // However, we haven't actually handled this error // So what do we do here? &#125;&#125;在这个函数成功的情况下，它返回一个整数值——任何整数值都可以是一个有效值。但是在getIntValue()出现问题的情况下又如何呢? 在这种情况下，getIntValue()将抛出一个整数异常，该异常将被getIntValueFromDatabase()中的catch块捕获，该块将记录错误。但是，我们如何告诉getIntValueFromDatabase()的调用者出错了呢? 与上面的例子不同，这里没有一个好的返回代码可以使用(因为任何整数返回值都可能是有效的)。抛出新异常一个明显的解决方案是抛出一个新的异常。12345678910111213141516int getIntValueFromDatabase(Database *d, std::string table, std::string key)&#123; assert(d); try &#123; return d-&gt;getIntValue(table, key); // throws int exception on failure &#125; catch (int exception) &#123; // Write an error to some global logfile g_log.logError(\"doSomethingImportant failed\"); throw 'q'; // throw char exception 'q' up the stack to be handled by caller of getIntValueFromDatabase() &#125;&#125;在上面的例子中，程序从getIntValue()获取int异常，记录错误，然后用 char值’ q ‘ 抛出一个新的异常。虽然从catch块抛出异常看起来很奇怪，但这是允许的。请记住，只有在try块中抛出的异常才有资格被捕获。这意味着在catch块中抛出的异常不会被它所在的catch块捕获。相反，它将在堆栈上传播到调用者。从catch块抛出的异常可以是任何类型的异常——它不需要与刚才捕获的异常相同的类型。重新抛出异常(错误的方式)另一个选项是重新抛出相同的异常。一种方法是这样做:12345678910111213141516int getIntValueFromDatabase(Database *d, std::string table, std::string key)&#123; assert(d); try &#123; return d-&gt;getIntValue(table, key); // throws int exception on failure &#125; catch (int exception) &#123; // Write an error to some global logfile g_log.logError(\"doSomethingImportant failed\"); throw exception; &#125;&#125;尽管这种方法有效，但也有一些缺点。首先，它不会抛出与捕获到的异常完全相同的异常——而是抛出一个经过复制初始化的变量异常副本。尽管编译器可以自由地省略副本，但也有可能不这么做，因此这可能会降低性能。但值得注意的是，考虑下面的情况:12345678910111213141516int getIntValueFromDatabase(Database *d, std::string table, std::string key)&#123; assert(d); try &#123; return d-&gt;getIntValue(table, key); // throws Derived exception on failure &#125; catch (Base &amp;exception) //⭐使用引用 传入 &#123; // Write an error to some global logfile g_log.logError(\"doSomethingImportant failed\"); throw exception; // Danger: this throws a Base object, not a Derived object &#125;&#125;在本例中，getIntValue()抛出一个派生对象，但是catch块正在捕获一个基引用。可以这样，因为我们知道我们可以有一个派生对象的基引用。然而，当我们抛出异常时，抛出的异常是由变量exception复制初始化的。变量exception 是 基类型，因此复制初始化的异常 也是基类型(不是派生的!)你可以在下面的程序中看到:1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;class Base&#123;public: Base() &#123;&#125; virtual void print() &#123; std::cout &lt;&lt; \"Base\"; &#125;&#125;; class Derived: public Base&#123;public: Derived() &#123;&#125; virtual void print() &#123; std::cout &lt;&lt; \"Derived\"; &#125;&#125;; int main()&#123; try &#123; try &#123; throw Derived(); &#125; catch (Base&amp; b) &#123; std::cout &lt;&lt; \"Caught Base b, which is actually a \"; b.print(); std::cout &lt;&lt; \"\\n\"; throw b; // the Derived object gets sliced here &#125; &#125; catch (Base&amp; b) &#123; std::cout &lt;&lt; \"Caught Base b, which is actually a \"; b.print(); std::cout &lt;&lt; \"\\n\"; &#125; return 0;&#125;/*结果*/Caught Base b, which is actually a DerivedCaught Base b, which is actually a Base结果的第二行 表明Base实际上是一个Base而不是一个派生的事实 证明派生对象是被切片的。重新抛出异常(正确的方式)幸运的是，C++提供了一种方法来重新抛出与刚才捕获的异常完全相同的异常。 要做到这一点，只需使用catch块中的 throw关键字(没有关联的变量)，就像这样:1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;class Base&#123;public: Base() &#123;&#125; virtual void print() &#123; std::cout &lt;&lt; \"Base\"; &#125;&#125;; class Derived: public Base&#123;public: Derived() &#123;&#125; virtual void print() &#123; std::cout &lt;&lt; \"Derived\"; &#125;&#125;; int main()&#123; try &#123; try &#123; throw Derived(); &#125; catch (Base&amp; b) &#123; std::cout &lt;&lt; \"Caught Base b, which is actually a \"; b.print(); std::cout &lt;&lt; \"\\n\"; throw; // ⭐⭐ 注意:我们现在在这里重新抛出对象 &#125; &#125; catch (Base&amp; b) &#123; std::cout &lt;&lt; \"Caught Base b, which is actually a \"; b.print(); std::cout &lt;&lt; \"\\n\"; &#125; return 0;&#125;/*结果*/Caught Base b, which is actually a DerivedCaught Base b, which is actually a Derived ⭐这个throw关键字看起来不会抛出任何特定的东西，实际上会重新抛出刚才捕获的异常。不需要创建副本，这意味着我们不必担心性能问题。","categories":[],"tags":[]},{"title":"C&C++/异常、类、继承","slug":"C&C++/异常、类、继承","date":"2020-05-20T08:16:37.618Z","updated":"2020-05-20T10:03:20.881Z","comments":true,"path":"archives/ee7242dc.html","link":"","permalink":"https://longlongqin.github.io/archives/ee7242dc.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/145-exceptions-classes-and-inheritance/异常和成员函数在本教程中，到目前为止，您只看到了非成员函数中使用的异常。但是，异常在成员函数中同样有用，在重载操作符中更是如此。考虑以下重载的[]运算符作为一个简单整数数组类的一部分:1234int&amp; IntArray::operator[](const int index)&#123; return m_data[index];&#125;尽管只要索引是有效的数组索引，这个函数就可以很好地工作，但是这个函数严重缺乏一些良好的错误检查。我们可以添加一个assert语句来确保索引是有效的:12345int&amp; IntArray::operator[](const int index)&#123; assert (index &gt;= 0 &amp;&amp; index &lt; getLength()); return m_data[index];&#125;现在，如果用户传入一个无效索引，操作符[]将抛出一个int异常。虽然这对于向用户指出出错的地方很有用，但有时更好的做法是静默地失败，并让调用者知道出错的地方，以便他们可以适当地处理它。我们也可以让它抛出异常：1234567int&amp; IntArray::operator[](const int index)&#123; if (index &lt; 0 || index &gt;= getLength()) throw index; return m_data[index];&#125;当构造函数失败构造函数是异常在类中第二个有用的地方。如果构造函数由于某种原因必须失败(例如，用户传入了无效的输入)，只需抛出一个异常来指示对象创建失败。在这种情况下，对象的构造被中止，所有类成员(在构造函数执行之前已经创建并初始化的类成员)按照通常的方式被销毁。但是，永远不会调用类的析构函数(因为对象永远不会完成构造)。这里有一个例子:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt; class Member&#123;public: Member() &#123; std::cerr &lt;&lt; \"Member allocated some resources\\n\"; &#125; ~Member() &#123; std::cerr &lt;&lt; \"Member cleaned up\\n\"; &#125;&#125;; class A&#123;private: int m_x; Member m_member; public: A(int x) : m_x(x) &#123; if (x &lt;= 0) throw 1; &#125; ~A() &#123; std::cerr &lt;&lt; \"~A\\n\"; // should not be called &#125;&#125;; int main()&#123; try &#123; A a(0); &#125; catch (int) &#123; std::cerr &lt;&lt; \"Oops\\n\"; &#125; return 0;&#125;/*结果*/Member allocated some resourcesMember cleaned upOops在上面的程序中，当类A抛出异常时，A的所有成员都被销毁。这给了m_member一个机会来清理任何被分配的资源。这是RAII(引用:8.7 – Destructors)被如此推崇的部分原因——即使在不正常的情况下，正确实现RAII的类应该能够在之后进行清理异常类使用基本数据类型(例如int)作为异常类型的一个主要问题是，它们本质上是模糊的。一个更大的问题是，当try块中有多个语句或函数调用时，如何消除异常含义的歧义。12345678910// 使用上面的IntArray重载运算符[]try&#123; int *value = new int(array[index1] + array[index2]);&#125;catch (int value)&#123; // 我们在这里捕捉什么?&#125;在这个例子中，如果我们捕获一个int异常，它真正告诉我们什么?是否有一个数组索引超出了界限?操作符+是否导致整数溢出?操作符new是否因为内存不足而失败?不幸的是，在这种情况下，没有简单的方法来消除歧义。虽然我们可以抛出const char*异常来解决识别错误的问题，但这仍然不能为我们提供以不同的方式处理不同来源的异常的能力。解决这个问题的一种方法是使用异常类(exception class)。异常类只是一个普通的类，它是专门设计来作为异常抛出的。让我们设计一个简单的异常类与我们的IntArray类一起使用:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;string&gt; class ArrayException&#123;private: std::string m_error; public: ArrayException(std::string error) : m_error(error) &#123; &#125; const char* getError() &#123; return m_error.c_str(); &#125;&#125;; class IntArray&#123;private: int m_data[3]; // assume array is length 3 for simplicitypublic: IntArray() &#123;&#125; int getLength() &#123; return 3; &#125; int&amp; operator[](const int index) &#123; if (index &lt; 0 || index &gt;= getLength()) throw ArrayException(\"Invalid index\"); return m_data[index]; &#125; &#125;; int main()&#123; IntArray array; try &#123; int value = array[5]; &#125; catch (ArrayException &amp;exception) &#123; std::cerr &lt;&lt; \"An array exception occurred (\" &lt;&lt; exception.getError() &lt;&lt; \")\\n\"; &#125;&#125;使用这样的类，我们可以让异常 返回发生的问题的描述，它提供了出错的上下文。由于ArrayException是它自己惟一的类型，所以我们可以专门捕获数组类抛出的异常，并根据需要将它们与其他异常区别对待。注意，异常处理程序应该 通过引用 而不是通过值 来捕获类异常对象。这可以防止编译器复制异常，当异常是一个类对象时，复制异常的代价可能很高；并且在处理派生异常类时防止对象切片(稍后我们将讨论这个问题)。通常应该避免通过指针捕获异常，除非您有特定的理由这样做。异常和继承由于可以将类作为异常抛出，并且类可以从其他类派生，因此我们需要考虑当使用继承的类作为异常时会发生什么。 事实证明，异常处理程序不仅会匹配特定类型的类，还会匹配从该特定类型派生的类!考虑下面的例子:1234567891011121314151617181920212223242526272829303132class Base&#123;public: Base() &#123;&#125;&#125;; class Derived: public Base&#123;public: Derived() &#123;&#125;&#125;; int main()&#123; try &#123; throw Derived(); &#125; catch (Base &amp;base) &#123; cerr &lt;&lt; \"caught Base\"; &#125; catch (Derived &amp;derived) &#123; cerr &lt;&lt; \"caught Derived\"; &#125; return 0;&#125;/*结果*/caught Base发生了什么？首先，如上所述，派生类将由基类型的处理程序捕获。因为Derived来自于Base，所以Derived是 is-a Base(它们有一个is-a关系)。其次，当c++试图为引发的异常查找处理程序时，它按顺序执行。因此，c++做的第一件事就是检查 Base异常处理程序是否与 Derived异常匹配。因为Derived is-a Base，所以答案是yes，所以它执行 类型Base 的catch块! 在这种情况下，派生的catch块甚至从未经过测试。为了让这个例子像预期的那样工作，我们需要颠倒catch块的顺序:1234567891011121314151617181920212223242526272829class Base&#123;public: Base() &#123;&#125;&#125;; class Derived: public Base&#123;public: Derived() &#123;&#125;&#125;; int main()&#123; try &#123; throw Derived(); &#125; catch (Derived &amp;derived) //将两个catch语句顺序调换一下 &#123; cerr &lt;&lt; \"caught Derived\"; &#125; catch (Base &amp;base) &#123; cerr &lt;&lt; \"caught Base\"; &#125; return 0;&#125;这样， Derived的处理程序将首先捕获派生类型的对象(在Base的处理程序之前)。Base类型的对象将不匹配派生的处理程序(Derived is-a Base，但基不是派生的)，因此将在Base处理程序 “失败”。规则:派生异常类的处理程序应该列在基类的处理程序之前。std::exception标准库中的许多类和操作符在失败时抛出异常类。例如，如果操作符new无法分配足够的内存，则会抛出std::bad_alloc。dynamic_cast失败将抛出std::bad_cast。从c++ 17开始，可以抛出25个不同的异常类，在每个后续的语言标准中还会添加更多的异常类。好消息是，所有这些异常类都派生自一个名为std::exception的类。exception是一个很小的接口类，设计用来作为 c++标准库抛出的任何异常的基类。大多数情况下，当标准库抛出异常时，我们并不关心它是一个糟糕的分配、一个糟糕的强制转换还是其他什么。我们只关心发生了灾难性的错误，现在我们的程序正在爆炸。多亏了std::exception，我们可以设置一个异常处理程序来捕获std::exception类型的异常，最终我们将在一个地方捕获std::exception和所有(21+)派生异常。简单!1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;exception&gt; // for std::exception#include &lt;string&gt; // for this exampleint main()&#123; try &#123; // 使用标准库的代码在这里 // 为了举例，我们将故意触发其中一个异常 std::string s; s.resize(-1); // 将会触发std::length_error &#125; // 这个处理程序将捕获std::exception 和 所有派生 的异常 catch (std::exception &amp;exception) &#123; std::cerr &lt;&lt; \"Standard exception: \" &lt;&lt; exception.what() &lt;&lt; '\\n'; &#125; return 0;&#125;/*结果*/Standard exception: string too long上面的例子应该很简单。值得注意的是，std::exception有一个名为what()的虚成员函数，它返回异常 的c风格字符串描述。大多数派生类都重写what()函数来更改消息。请注意，此字符串仅用于描述性文本——不要将其用于比较，因为它不能保证在编译器之间是相同的。有时，我们希望以不同的方式处理特定类型的异常。在本例中，我们可以为该特定类型添加一个处理程序，并让所有其他的处理程序“落入”基处理程序。考虑:1234567891011121314try&#123; // 使用标准库的代码在这里&#125; // ：这个处理程序将在这里捕获std::length_error(以及由此派生的任何异常)catch (std::length_error &amp;exception)&#123; std::cerr &lt;&lt; \"You ran out of memory!\" &lt;&lt; '\\n';&#125;// 这个处理程序将捕获 落入在这里的 std::exception(以及从它派生的任何异常)catch (std::exception &amp;exception)&#123; std::cerr &lt;&lt; \"Standard exception: \" &lt;&lt; exception.what() &lt;&lt; '\\n';&#125;在这个例子中，std::length_error类型的异常将被第一个处理程序捕获并在那里处理。类型std::exception和所有其他派生类的异常将由第二个处理程序捕获。这样的继承层次结构允许我们使用特定的处理程序来针对特定的派生异常类，或者使用基类处理程序来捕获整个异常层次结构。这允许我们在一定程度上控制我们想要处理的异常类型，同时确保我们不需要做太多的工作来捕获层次结构中的“其他所有内容”直接使用标准异常没有任何东西会直接抛出std::exception，您也不应该这样做。但是，如果标准库中的其他标准异常类能够充分代表您的需求，那么您可以随意抛出它们。您可以在 cppreference上找到所有标准异常的列表。std::runtime_error(在头文件：stdexcept中) 是一个流行的选择，因为它有一个通用的名称，它的构造函数接受一个可定制的消息:1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;stdexcept&gt; int main()&#123; try &#123; throw std::runtime_error(\"Bad things happened\"); &#125; // This handler will catch std::exception and all the derived exceptions too catch (std::exception &amp;exception) &#123; std::cerr &lt;&lt; \"Standard exception: \" &lt;&lt; exception.what() &lt;&lt; '\\n'; &#125; return 0;&#125;/*结果*/Standard exception: Bad things happened从std::exception派生您自己的类当然，您可以从std::exception派生自己的类，并覆盖虚what() const成员函数。下面是与上面相同的程序，ArrayException派生自std::exception:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;exception&gt; // for std::exception class ArrayException: public std::exception&#123;private: std::string m_error; public: ArrayException(std::string error) : m_error(error) &#123; &#125; // return the std::string as a const C-style string// const char* what() const &#123; return m_error.c_str(); &#125; // pre-C++11 version const char* what() const noexcept &#123; return m_error.c_str(); &#125; // C++11 version&#125;; class IntArray&#123;private: int m_data[3]; // assume array is length 3 for simplicitypublic: IntArray() &#123;&#125; int getLength() &#123; return 3; &#125; int&amp; operator[](const int index) &#123; if (index &lt; 0 || index &gt;= getLength()) throw ArrayException(\"Invalid index\"); return m_data[index]; &#125; &#125;; int main()&#123; IntArray array; try &#123; int value = array[5]; &#125; catch (ArrayException &amp;exception) // derived catch blocks go first &#123; std::cerr &lt;&lt; \"An array exception occurred (\" &lt;&lt; exception.what() &lt;&lt; \")\\n\"; &#125; catch (std::exception &amp;exception) &#123; std::cerr &lt;&lt; \"Some other std::exception occurred (\" &lt;&lt; exception.what() &lt;&lt; \")\\n\"; &#125; return 0;&#125;/*结果*/An array exception occurred (Invalid index)在c++ 11中，虚函数what()被更新为带有说明符noexcept (这意味着函数本身承诺不抛出异常)。因此，在c++ 11和更高版本中，我们的重载应该也带有说明符noexcept。由您决定是创建自己的独立异常类、使用标准异常类，还是从std::exception派生自己的异常类。根据你的目标，所有的方法都是有效的。","categories":[],"tags":[]},{"title":"C&C++/未捕获异常、处理所有异常、异常说明符(noexcept)","slug":"C&C++/未捕获异常、处理所有异常、异常说明符(noexcept)","date":"2020-05-20T07:37:21.798Z","updated":"2020-05-20T08:11:21.991Z","comments":true,"path":"archives/f016036.html","link":"","permalink":"https://longlongqin.github.io/archives/f016036.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/144-uncaught-exceptions-catch-all-handlers-and-exception-specifiers/现在，您应该对异常如何工作有了一个合理的概念。在本课中，我们将介绍一些更有趣的异常情况。未捕获异常在过去的几个例子中，有相当多的情况下，一个函数假设它的调用者 (或者调用栈上的另一个函数)将处理异常。在下面的例子中，mySqrt()假设有人会处理它抛出的异常——但是实际上如果没有人处理，会发生什么情况呢?这是我们的平方根程序再次，减去在main()中的try块:123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;cmath&gt; // for sqrt() function // A modular square root functiondouble mySqrt(double x)&#123; // If the user entered a negative number, this is an error condition if (x &lt; 0.0) throw \"Can not take sqrt of negative number\"; // throw exception of type const char* return sqrt(x);&#125; int main()&#123; std::cout &lt;&lt; \"Enter a number: \"; double x; std::cin &gt;&gt; x; // Look ma, no exception handler! std::cout &lt;&lt; \"The sqrt of \" &lt;&lt; x &lt;&lt; \" is \" &lt;&lt; mySqrt(x) &lt;&lt; '\\n'; return 0;&#125;现在，假设用户输入-4, mySqrt(-4)引发一个异常。函数mySqrt()不处理异常，因此程序 栈展开 并将控制返回到main()。但是这里也没有异常处理程序，所以main()终止。此时，我们刚刚终止了我们的应用程序!当main()因未处理的异常而终止时，操作系统通常会通知您发生了未处理的异常错误。它如何做到这一点取决于操作系统，但可能性包括打印错误消息、弹出错误对话框或简单地崩溃。处理所有异常(Catch-all handlers)现在我们发现自己陷入了一个难题: 函数可能抛出任何数据类型的异常，如果没有捕获到异常，它将传播到程序的顶部并导致终止。既然有可能在不知道函数是如何实现的情况下调用函数(因此也不知道它们可能抛出的异常类型)，那么我们如何才能防止这种情况的发生呢?幸运的是，c++为我们提供了一种机制来捕获所有类型的异常。这就是所谓的“全部捕获（catch-all handler）”处理程序。catch-all handler 程序的工作原理与普通的catch块一样，只是它没有使用特定的类型来进行catch，而是使用省略号操作符(…) 作为要进行catch的类型。如果您回想一下第7.14课 ellipses and why to avoid them 。在以前，省略号用于向函数传递任何类型的参数。在此上下文中，它们表示任何数据类型的异常。这里有一个简单的例子:1234567891011121314151617#include &lt;iostream&gt;int main()&#123; try &#123; throw 5; // throw an int exception &#125; catch (double x) &#123; std::cout &lt;&lt; \"We caught an exception of type double: \" &lt;&lt; x &lt;&lt; '\\n'; &#125; catch (...) // catch-all handler &#123; std::cout &lt;&lt; \"We caught an exception of an undetermined type\\n\"; &#125;&#125;因为对于int类型没有特定的异常处理程序，所以catch-all handler会捕获这个异常。这个例子产生了以下结果:1We caught an exception of an undetermined typecatch-all handler 应该放在catch块链的最后。这是为了确保在异常处理程序存在的情况下，异常处理程序可以根据特定的数据类型捕获异常。Visual Studio强制执行这个约束——我不确定是否其他编译器也这样做。(根据下面评论中的读者Lonami的观点，GCC也是如此)。异常说明符：noexceptc++ 11增加了第四个异常说明符:noexcept。Noexcept是一个异常说明符，用于指示函数不能抛出异常。从语义上讲，它允许您一眼就看出一个函数不会抛出异常。它还可能启用一些编译器优化。析构函数通常是隐式noexcept（因为它们不能抛出异常）如果noexcept函数确实试图抛出异常，那么将调用std::terminate函数来终止应用程序。","categories":[],"tags":[]},{"title":"C&C++/异常、函数、栈展开","slug":"C&C++/异常、函数、栈展开","date":"2020-05-19T13:14:49.299Z","updated":"2020-05-19T15:07:28.729Z","comments":true,"path":"archives/7d1f8966.html","link":"","permalink":"https://longlongqin.github.io/archives/7d1f8966.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/143-exceptions-functions-and-stack-unwinding/在try块之外抛出(throw)异常在上一课的示例中，throw语句直接放在try块中。如果这是必要的，那么异常处理的作用将是有限的。异常处理最有用的属性之一是，由于异常在抛出时向上传播栈的方式，抛出语句不必直接放在try块中。这允许我们以更加模块化的方式使用异常处理。我们将通过重写前一课的平方根程序来演示这一点，以使用模块函数。12345678910111213141516171819202122232425262728293031#include &lt;cmath&gt; // for sqrt() function#include &lt;iostream&gt; // A modular square root functiondouble mySqrt(double x)&#123; // If the user entered a negative number, this is an error condition if (x &lt; 0.0) throw \"Can not take sqrt of negative number\"; // throw exception of type const char* return sqrt(x);&#125; int main()&#123; std::cout &lt;&lt; \"Enter a number: \"; double x; std::cin &gt;&gt; x; try // Look for exceptions that occur within try block and route to attached catch block(s) &#123; double d = mySqrt(x); std::cout &lt;&lt; \"The sqrt of \" &lt;&lt; x &lt;&lt; \" is \" &lt;&lt; d &lt;&lt; '\\n'; &#125; catch (const char* exception) // catch exceptions of type const char* &#123; std::cerr &lt;&lt; \"Error: \" &lt;&lt; exception &lt;&lt; std::endl; &#125; return 0;&#125;在这个程序中，我们将检查异常并计算平方根的代码放入名为mySqrt()的模块函数中。然后我们在try块中调用这个mySqrt()函数。让我们来验证一下它是否仍然像预期的那样工作:12Enter a number: -4Error: Can not take sqrt of negative number栈的展开让我们回顾一下异常引发时的情况。首先，程序检查异常是否可以立即处理(这意味着它是在try块中抛出的)。如果没有，当前函数将被终止，程序将检查函数的调用者是否会处理异常。如果不能，它将终止调用者并检查调用者的调用者。（一层一层的寻找处理异常的代码）每个函数按顺序终止，直到找到异常的处理程序；或者直到main()在不处理异常的情况下终止。这个过程称为栈的展开。现在，让我们详细了解一下，当从mySqrt()中引发异常时，它是如何应用于这个程序的。首先，程序检查异常是否从函数中的try块中抛出。(在这个例子中，它不是。)然后，栈开始展开。首先,mySqrt()终止，控件返回到main()。程序现在检查我们是否在一个try块中。我们是，并且有一个const char*处理程序，所以异常由main()中的try块处理。小结这个例子mySqrt()引发异常，但是main()中的try/catch块捕获并处理异常。或者，换句话说，try块不仅从try块中的语句捕捉异常，而且还从try块中调用的函数捕捉异常。上面程序中最有趣的部分是mySqrt()函数可以抛出异常，但是这个异常不是立即出现在try块中! 这本质上意味着：mySqrt愿意说:“嘿，有个问题!，但不愿自己处理问题。本质上，它是将处理异常的责任委托给它的调用者 (相当于使用返回代码将处理错误的责任传递回函数的调用者)。此时，有些人可能想知道为什么将错误传递回调用者是一个好主意。为什么不直接让MySqrt()处理它自己的错误呢?答：问题是，不同的应用程序可能希望以不同的方式处理错误。控制台应用程序可能需要打印文本消息；windows应用程序可能希望弹出一个错误对话框。在一个应用程序中，这可能是一个致命错误，而在另一个应用程序中可能不是。通过将错误传递回栈，每个应用程序都可以以最适合它的上下文方式处理来自mySqrt()的错误!最终，这将使mySqrt()尽可能模块化，并且错误处理可以放在代码中模块化程度较低的部分。另一个栈展开的例子⭐下面是另一个使用更大堆栈进行实际堆栈展开的示例。虽然这个程序很长，但它非常简单:main()调用first()、first()调用second()、second()、second()调用third()、third()调用last()和last()抛出异常。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt; void last() // called by third()&#123; std::cout &lt;&lt; \"Start last\\n\"; std::cout &lt;&lt; \"last throwing int exception\\n\"; throw -1; std::cout &lt;&lt; \"End last\\n\"; &#125; void third() // called by second()&#123; std::cout &lt;&lt; \"Start third\\n\"; last(); std::cout &lt;&lt; \"End third\\n\";&#125; void second() // called by first()&#123; std::cout &lt;&lt; \"Start second\\n\"; try &#123; third(); &#125; catch(double) &#123; std::cerr &lt;&lt; \"second caught double exception\\n\"; &#125; std::cout &lt;&lt; \"End second\\n\";&#125; void first() // called by main()&#123; std::cout &lt;&lt; \"Start first\\n\"; try &#123; second(); &#125; catch (int) &#123; std::cerr &lt;&lt; \"first caught int exception\\n\"; &#125; catch (double) &#123; std::cerr &lt;&lt; \"first caught double exception\\n\"; &#125; std::cout &lt;&lt; \"End first\\n\";&#125; int main()&#123; std::cout &lt;&lt; \"Start main\\n\"; try &#123; first(); &#125; catch (int) &#123; std::cerr &lt;&lt; \"main caught int exception\\n\"; &#125; std::cout &lt;&lt; \"End main\\n\"; return 0;&#125;更详细地看一下这个程序，看看您是否可以找出在运行时打印的内容和不打印的内容。答案:123456789Start mainStart firstStart secondStart thirdStart lastlast throwing int exceptionfirst caught int exceptionEnd firstEnd main让我们看看在这种情况下会发生什么。所有“Start”语句的打印非常简单，不需要进一步解释。函数last()打印“最后一次抛出int异常”，然后抛出一个int异常。这就是事情开始变得有趣的地方。因为last()本身不处理异常，栈开始展开。函数last()立即终止，控制权返回给调用方，即third()。函数third()不处理任何异常，因此它立即终止，控制权返回到second()。函数second()有一个try块，而对third()的调用在其中，因此程序尝试用一个适当的catch块来匹配异常。但是，这里没有int类型的异常处理程序，所以second()立即终止，控制权返回first()。注意，整数异常没有隐式转换为匹配处理double的catch块。函数first()也有一个try块，对second()的调用也在其中，因此程序会查看是否有一个用于int异常的catch处理程序。有!因此，first()处理异常，并打印“first caught int exception”。因为现在已经处理了异常，所以控制通常在first()中的catch块的末尾继续。这意味着first()打印“End first”，然后正常终止。控制权返回到main()。虽然main()有一个int的异常处理程序，但是我们的异常已经被first()处理了，所以main()中的catch块不会被执行。main()简单地打印“End main”，然后正常终止。这个例子中有很多有趣的原则:首先，函数的直接调用者抛出异常，如果不希望处理异常 则不必处理异常。在本例中，third()没有处理last()抛出的异常。它将该职责委托给栈上的一个调用者。其次，如果try块没有针对抛出的异常类型的catch处理程序，那么就会发生栈解除，就好像根本没有try块一样。在本例中，second()也没有处理异常，因为它没有正确的catch块类型。第三，一旦异常得到处理，控制流就会像正常情况一样从catch块的末尾开始。本例子中，这是通过first()处理错误，然后正常终止来演示的。当程序返回main()时，异常已经被抛出并处理了——main()甚至完全不知道存在异常!正如您所看到的，堆栈展开为我们提供了一些非常有用的行为——如果一个函数不想处理异常，它就不需要处理异常。 异常将向上传播栈，直到找到愿意这样做的人!","categories":[],"tags":[]},{"title":"C&C++/基本的异常处理","slug":"C&C++/基本的异常处理","date":"2020-05-19T08:57:53.663Z","updated":"2020-05-19T10:05:52.524Z","comments":true,"path":"archives/b215c449.html","link":"","permalink":"https://longlongqin.github.io/archives/b215c449.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/142-basic-exception-handling/在the need for exceptions中，我们讨论了如何使用返回代码使控制流和错误流混合在一起，从而对两者进行约束。**C++中的异常是使用三个相互关联的关键字实现的：throwtrycatch抛出(throw)异常我们在现实生活中一直使用信号来记录特定事件的发生。例如，在美式橄榄球比赛中，如果一个球员犯规了，裁判就会把一面旗子扔到地上，然后用哨子宣布比赛结束。然后评估并执行惩罚。一旦处罚被处理好，比赛通常会恢复正常。在c++中，throw语句 用于指示发生了异常或错误情况(考虑抛出惩罚标志)。发出 异常已经发生的 信号 通常也称为引发（raising）异常。要使用throw语句，只需使用throw关键字，后面跟一个任意数据类型的值，用来表示发生了错误。通常，该值是一个错误代码、问题描述或自定义异常类。12345throw -1; // 抛出一个文本整数值throw ENUM_INVALID_INDEX; //抛出一个枚举值throw \"Can not take square root of negative number\"; //抛出一个c样式的字符串(const char*)throw dX; //抛出一个在此之前定义的double型变量throw MyException(\"Fatal Error\"); //抛出 一个 类对象：MyException这些语句中的每一条都充当一个信号，表示需要处理的某种问题已经发生。寻找(try)异常抛出异常只是异常处理过程的一部分。让我们回到美式足球的比喻: 一旦裁判抛出了罚球，接下来会发生什么?球员们注意到处罚已经发生，于是停止比赛。足球比赛的正常秩序被打乱了。在c++中，我们使用try关键字来定义一个 语句块(称为try块)。try块充当观察者，查找try块中的任何语句 抛出的任何异常。12345try&#123; //可能引发您想要处理的异常的语句请转到这里 throw -1; //这是一个简单的抛出语句&#125;注意，try块没有定义如何处理异常。它只是告诉程序，“嘿，如果try块中的任何语句抛出异常，抓住它!”处理(catch)异常最后，美式足球的比喻到此结束: 在判罚结束，比赛停止后，裁判会对判罚进行评估并执行。换句话说，在恢复正常比赛之前，必须对点球进行处理。实际处理异常是catch块的工作。catch关键字用于 定义处理单个数据类型异常的代码块(称为catch块)。12345catch (int x)&#123; //处理一个int类型的异常 std::cerr &lt;&lt;\"We caught an int exception with value\" &lt;&lt; x &lt;&lt; '\\n';&#125;Try块和catch块一起工作——Try块检测Try块中的语句抛出的任何异常，并将它们送到到适当的catch块进行处理。一个try块必须有至少一个catch块紧跟着它，但是可以有多个catch块按顺序列出。一旦try块捕获了异常并将其送到catch块进行处理，就会认为异常已被处理，并且在catch块之后执行将恢复正常。Catch参数的工作原理与函数参数一样，在后续的Catch块中可以使用该参数。基本类型的异常可以通过值捕获，但是非基本类型的异常应该通过const引用捕获，以避免不必要的复制。就像函数一样，如果参数不在catch块中使用，变量名可以省略:1234catch (double) //注意:没有变量名，因为我们在下面的catch块中没有使用它&#123; std::cerr &lt;&lt; \"We caught an exception of type double\" &lt;&lt; '\\n';&#125;这可以防止编译器对未使用的变量发出警告。throw, try,catch 一起使用这里是一个完整的程序，使用抛出，尝试，和多个捕捉块:12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;string&gt; int main()&#123; try &#123; // 可能引发您想要处理的异常的语句请转到这里 throw -1; // here's a trivial example &#125; catch (int x) &#123; // 在上面的try块中抛出的任何int类型的异常都会被发送到这里 std::cerr &lt;&lt; \"We caught an int exception with value: \" &lt;&lt; x &lt;&lt; '\\n'; &#125; catch (double) // 没有变量名，因为我们没有在下面的catch块中使用异常本身 &#123; // 在上面的try块中，任何类型为double抛出的异常都会被发送到这里 std::cerr &lt;&lt; \"We caught an exception of type double\" &lt;&lt; '\\n'; &#125; catch (const std::string &amp;str) // 通过const引用捕获类 &#123; // 在上面的try块中抛出的任何std::string类型的异常都会被发送到这里 std::cerr &lt;&lt; \"We caught an exception of type std::string\" &lt;&lt; '\\n'; &#125; std::cout &lt;&lt; \"Continuing on our merry way\\n\"; return 0;&#125;/*结果*/We caught an int exception with value -1Continuing on our merry way异常处理小结异常处理实际上非常简单，以下两段涵盖了您需要记住的大部分内容:当抛出异常(使用throw)时，程序的执行立即跳转到最近的封闭try块 (如果需要找到一个封闭的try块，则向上传播栈——下一课我们将更详细地讨论这个问题)。如果连接到try块句柄的 任何catch处理程序出现这种类型的异常，则执行该处理程序，并认为该异常已得到处理。如果没有合适的catch处理程序存在，程序的执行将传播到下一个封闭的try块。如果在程序结束之前找不到合适的catch处理程序，程序将失败并出现异常错误。注意，当异常与catch块匹配时，编译器不会执行隐式转换或提升!例如，char异常将与int catch块不匹配。一个int异常将不匹配一个浮点捕获块。但是，将执行从派生类到其父类之一的转换。异常会立即处理下面是一个演示如何立即处理异常的简短程序:12345678910111213141516171819#include &lt;iostream&gt;int main()&#123; try &#123; throw 4.5; std::cout &lt;&lt;\"This never prints\\n\"; &#125; catch (double x) &#123; std::cerr &lt;&lt; \"We caught a double of value: \" &lt;&lt; x &lt;&lt; '\\n'; &#125; return 0;&#125;/*结果*/We caught a double of value: 4.5这个程序非常简单。情况是这样的:抛出（throw）语句是执行的第一个语句——这会引发double类型的异常。执行立即移动到最近的封闭try块，这是这个程序中惟一的try块。然后检查catch处理程序，以查看是否有匹配的处理程序。我们的异常类型是double，因此我们正在寻找类型为double的catch处理程序。我们有一个，所以它执行。注意：“This never prints” 是永远不会被打印的，因为异常导致执行路径立即跳转到 double类型的异常处理程序。一个更真实的例子让我们看一个不那么学术的例子:1234567891011121314151617181920212223#include \"math.h\" // for sqrt() function#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; \"Enter a number: \"; double x; std::cin &gt;&gt; x; try //查找try块中发生的异常，并将异常送到附加的 catch块 &#123; // 如果用户输入了一个负数，这是一个错误条件 if (x &lt; 0.0) throw \"Can not take sqrt of negative number\"; // 抛出const char*类型的异常 // 否则，打印答案 std::cout &lt;&lt; \"The sqrt of \" &lt;&lt; x &lt;&lt; \" is \" &lt;&lt; sqrt(x) &lt;&lt; '\\n'; &#125; catch (const char* exception) // 捕获const char*类型的异常 &#123; std::cerr &lt;&lt; \"Error: \" &lt;&lt; exception &lt;&lt; '\\n'; &#125;&#125;在这段代码中，要求用户输入一个数字。如果输入的是正数，则If语句不执行，不会抛出异常，并打印该数字的平方根。因为在这种情况下不会抛出异常，所以catch块中的代码永远不会执行。结果是这样的:12Enter a number: 9The sqrt of 9 is 3如果用户输入一个负数，我们抛出一个const char*类型的异常。因为我们在try块中，并且找到了匹配的异常处理程序，所以控件立即转移到const char*异常处理程序。其结果是:12Enter a number: -4Error: Can not take sqrt of negative number什么是典型的 catch块如果一个异常被送到一个catch块，即使catch块是空的，它也被认为是“已处理”的。然而，通常您会希望您的catch块做一些有用的事情。当catch块捕获异常时，通常会做三件事情:首先，catch块可能会打印错误(输出到控制台或日志文件)。其次，catch块可能会向调用者返回一个值或错误代码。第三，catch块可能抛出另一个异常。因为catch块位于try块之外，所以在这种情况下，新抛出的异常不是由前一个try块处理的——而是由下一个封闭的try块处理的。","categories":[],"tags":[]},{"title":"C&C++/异常处理","slug":"C&C++/异常处理","date":"2020-05-19T03:28:11.960Z","updated":"2020-05-19T03:57:21.595Z","comments":true,"path":"archives/800f51f0.html","link":"","permalink":"https://longlongqin.github.io/archives/800f51f0.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/141-the-need-for-exceptions/在handling errors中，我们讨论了使用assert()、cerr()和exit()来处理错误的方法。然而，我们现在将讨论：exceptions当返回码失败时在编写可重用代码时，错误处理是必要的。处理潜在错误的最常见方法之一是通过返回代码。例如:1234567891011int findFirstChar(const char* string, char ch)&#123; const std::size_t stringlength&#123;str(string)&#125;; for(std::size_t index = 0; index &lt; stringlength; ++index) &#123; if(string[index] == ch) return index; &#125; return -1;&#125;这个函数返回字符串中第一个匹配ch的字符的索引。如果找不到字符，函数将返回-1作为错误指示符。这种方法的主要优点是非常简单。然而，使用返回码有一些缺点，在非平凡的情况下很快就会变得明显:首先，返回值可能是模糊的——如果一个函数返回-1，它是试图指示一个错误，还是实际上是一个有效的返回值? 如果不深入了解函数的本质，通常很难判断。其次，函数只能返回一个值，所以当需要同时返回函数结果和错误代码时，会发生什么情况?考虑以下功能:1234double divide(int x, int y)&#123; return static_cast&lt;double&gt;(x)/y;&#125;这个函数非常需要一些错误处理，因为如果用户传入0作为参数y，它会崩溃，但是它还需要返回x/y的结果。怎么能两全其美呢?最常见的答案是，结果或错误处理必须作为引用参数传递回去，这使得使用起来更不方便。例如:1234567891011121314151617181920212223242526#include &lt;iostream&gt;double divide(int x, int y, bool &amp;success)&#123; if(y==0) &#123; success = false; return 0.0; &#125; success = true; return static_cast&lt;double&gt;(x)/y;&#125;int main()&#123; bool success; double result = divide(5,3,success); if(!success) std::cerr&lt;&lt;\"An error occurred\"&lt;&lt;std::endl; else std::cout &lt;&lt;\"The answer is \" &lt;&lt; result &lt;&lt; '\\n'; return 0;&#125;第三，在可能出错的代码序列中，必须经常检查错误代码。考虑一下下面的代码片段，它涉及到解析一个文本文件，寻找应该存在的值:12345678910111213141516171819202122232425262728234567891011121314 std::ifstream setupIni(\"setup.ini\"); // open setup.ini for reading // If the file couldn't be opened (e.g. because it was missing) return some error enum if (!setupIni) return ERROR_OPENING_FILE; // Now read a bunch of values from a file if (!readIntegerFromFile(setupIni, m_firstParameter)) // try to read an integer from the file return ERROR_READING_VALUE; // Return enum value indicating value couldn't be read if (!readDoubleFromFile(setupIni, m_secondParameter)) // try to read a double from the file return ERROR_READING_VALUE; if (!readFloatFromFile(setupIni, m_thirdParameter)) // try to read a float from the file return ERROR_READING_VALUE;我们还没有讨论文件访问，所以如果您不理解上面的工作原理，也不要担心——只需注意这样一个事实:每个调用都需要进行错误检查并返回给调用者。现在想象一下，如果有20个不同类型的参数——您实际上是在检查一个错误并返回ERROR_READING_VALUE 20次!所有这些错误检查和返回值 使得确定函数要执行的操作更加难以识别。第四，返回代码不能很好地与构造函数混合。如果你在创建一个对象，构造函数里面的一些东西出了灾难性的错误，会发生什么？构造函数没有返回类型来返回状态指示器，并且通过引用参数返回一个状态指示器是混乱的，必须显式地检查。而且，即使这样做，仍然会创建对象，然后必须处理或释放对象。最后，当向调用方返回错误代码时，调用方可能并不总是能够处理错误。如果调用者不想处理错误，它要么忽略它(在这种情况下，它将永远丢失)，要么将错误返回到调用它的函数。这可能是混乱的，并导致许多相同的问题上面提到。总之，返回代码的主要问题是错误处理代码最终复杂地链接到代码的正常控制流。这反过来又限制了代码的布局，以及如何合理地处理错误。异常异常处理提供了一种机制，可以将错误或其他异常情况的处理与代码的典型控制流分离开来。这允许在特定情况下更自由地处理错误，减轻了返回代码造成的混乱(如果不是全部的话)。","categories":[],"tags":[]},{"title":"C&C++/指针的局部模板专门化","slug":"C&C++/指针的局部模板专门化","date":"2020-05-17T08:30:44.323Z","updated":"2020-05-17T09:35:01.172Z","comments":true,"path":"archives/db2a8c7a.html","link":"","permalink":"https://longlongqin.github.io/archives/db2a8c7a.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/13-8-partial-template-specialization-for-pointers/在 13.5 – Function template specialization中，我们看了一个简单的模板化 Storage类:12345678910111213141516171819202122#include &lt;iostream&gt; template &lt;class T&gt;class Storage&#123;private: T m_value;public: Storage(T value) &#123; m_value = value; &#125; ~Storage() &#123; &#125; void print() &#123; std::cout &lt;&lt; m_value &lt;&lt; '\\n'; &#125;&#125;;我们指出，当模板参数T为char*类型时，该类会出现问题，这是因为构造函数中发生了浅拷贝/指针赋值。在那节课中，我们使用完整的模板专门化来创建char*类型的存储构造函数的专门化版本，它分配内存并创建m_value的实际深度副本。作为参考，这里是完全专门化的char*存储构造函数和析构函数:123456789101112131415161718192021222324// 您需要包含上面示例中的Storage类template &lt;&gt;Storage&lt;char*&gt;::Storage(char* value)&#123; // Figure out how long the string in value is int length=0; while (value[length] != '\\0') ++length; ++length; // +1 to account for null terminator // Allocate memory to hold the value string m_value = new char[length]; // Copy the actual value string into the m_value memory we just allocated for (int count=0; count &lt; length; ++count) m_value[count] = value[count];&#125; template&lt;&gt;Storage&lt;char*&gt;::~Storage()&#123; delete[] m_value;&#125;虽然这对于存储非常有效，但是其他指针类型(例如int*)又如何呢?很容易看出，如果T是任何指针类型，那么我们就会遇到构造函数执行指针赋值的问题，而不是创建被指向的元素的实际深度副本。因为完全的模板专门化迫使我们完全解析模板类型，为了解决这个问题，我们必须为我们想要使用Storage的每个指针类型定义一个新的专门化构造函数(和析构函数)! 这将导致大量重复的代码，正如您现在所知道的，这是我们希望尽可能避免的。指针的局部模板专门化一次只复制一个值幸运的是，局部模板专门化为我们提供了一个方便的解决方案。在本例中，我们将使用类局部模板专门化来定义用于指针值的存储类的特殊版本。这个类被认为是部分专门化的，因为我们告诉编译器它只用于指针类型，即使我们没有精确地指定底层类型。1234567891011121314151617181920212223242526#include &lt;iostream&gt; // 您需要包含上面示例中的Storage类 template &lt;typename T&gt;class Storage&lt;T*&gt; // 这是使用指针类型的 Storage的部分专门化&#123;private: T* m_value;public: Storage(T* value) // for pointer type T &#123; // 对于指针，我们将进行深度复制 m_value = new T(*value); // 它只复制一个值，而不是一个数组 &#125; ~Storage() &#123; delete m_value; // 这里我们用的是标量delete，不是数组delete &#125; void print() &#123; std::cout &lt;&lt; *m_value &lt;&lt; '\\n'; &#125;&#125;;这方面的一个例子是:123456789101112131415161718192021int main()&#123; // Declare a non-pointer Storage to show it works Storage&lt;int&gt; myint(5); myint.print(); // Declare a pointer Storage to show it works int x = 7; Storage&lt;int*&gt; myintptr(&amp;x); // 如果myintptr在x上做了一个指针赋值， // 那么改变x也会改变myintptr x = 9; myintptr.print(); return 0;&#125;/*结果*/57当myintptr使用int* template参数定义时，编译器会看到我们已经定义了一个部分专用的模板类，它可以使用任何指针类型，并使用该模板实例化一个版本的 Storage。该类的构造函数创建了参数x的深度副本。稍后，当我们将x更改为9时，将创建myintptr。m_value不受影响，因为它指向的是它自己的单独的值副本。如果部分模板专门化类不存在，myintptr将使用模板的普通(非部分专门化)版本。该类的构造函数执行一个浅复制指针赋值，这意味着myintptr。m_value和x将引用相同的地址。然后，当我们将x的值更改为9时，我们也会更改myintptr的值。复制整个字符串值得注意的是，因为这个部分专门化的存储类只为c风格的字符串分配一个值，所以只复制第一个字符。如果希望复制整个字符串，可以完全专门化char*类型的构造函数(和析构函数)。 完全专门化的版本将优先于部分专门化的版本。下面是一个示例程序，它对指针使用部分专门化，对char*使用完全专门化:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;iostream&gt;#include &lt;cstring&gt; // 非指针的Storage类template &lt;class T&gt;class Storage&#123;private: T m_value;public: Storage(T value) &#123; m_value = value; &#125; ~Storage() &#123; &#125; void print() &#123; std::cout &lt;&lt; m_value &lt;&lt; '\\n'; &#125;&#125;; // 指针的Storage类的局部专门化template &lt;class T&gt;class Storage&lt;T*&gt;&#123;private: T* m_value;public: Storage(T* value) &#123; m_value = new T(*value); &#125; ~Storage() &#123; delete m_value; &#125; void print() &#123; std::cout &lt;&lt; *m_value &lt;&lt; '\\n'; &#125;&#125;; // char*类型的构造函数的完全专门化template &lt;&gt;Storage&lt;char*&gt;::Storage(char* value)&#123; // Figure out how long the string in value is int length = 0; while (value[length] != '\\0') ++length; ++length; // +1 to account for null terminator // Allocate memory to hold the value string m_value = new char[length]; // Copy the actual value string into the m_value memory we just allocated for (int count = 0; count &lt; length; ++count) m_value[count] = value[count];&#125; // char*类型的析构函数的完全专门化template&lt;&gt;Storage&lt;char*&gt;::~Storage()&#123; delete[] m_value;&#125; // char*类型的打印功能的完全专门化//如果没有这个，打印会调用Storage&lt;T*&gt;::print()，它只打印第一个元素template&lt;&gt;void Storage&lt;char*&gt;::print()&#123; std::cout &lt;&lt; m_value;&#125; int main()&#123; // Declare a non-pointer Storage to show it works Storage&lt;int&gt; myint(5); myint.print(); // Declare a pointer Storage to show it works int x = 7; Storage&lt;int*&gt; myintptr(&amp;x); // If myintptr did a pointer assignment on x, // then changing x will change myintptr too x = 9; myintptr.print(); // Dynamically allocate a temporary string char *name = new char[40]&#123; \"Alex\" &#125;; // requires C++14 // If your compiler isn't C++14 compatible, comment out the above line and uncomment these// char *name = new char[40];// strcpy(name, \"Alex\"); // Store the name Storage&lt; char*&gt; myname(name); // Delete the temporary string delete[] name; // Print out our name myname.print();&#125;/*结果*/57Alex使用部分模板类专门化来创建类的 单独指针 和 非指针实现，当您希望类以完全透明的方式分别处理这两种情况时，这是非常有用的。","categories":[],"tags":[]},{"title":"C&C++/局部模板专门化","slug":"C&C++/局部模板专门化","date":"2020-05-17T02:46:54.815Z","updated":"2020-05-17T03:44:01.603Z","comments":true,"path":"archives/a3ee11a9.html","link":"","permalink":"https://longlongqin.github.io/archives/a3ee11a9.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/137-partial-template-specialization/本课和下一课是那些希望对c++模板有更深入了解的人的选读。局部模板专门化并不经常使用(但是在特定的情况下很有用)。一个例子让我们再看一下我们在前面的例子中使用的静态数组类:123456789101112131415template &lt;class T, int size&gt; // size is the expression parameterclass StaticArray&#123;private: // The expression parameter controls the size of the array T m_array[size]&#123;&#125;; public: T* getArray() &#123; return m_array; &#125; T&amp; operator[](int index) &#123; return m_array[index]; &#125;&#125;;该类接受两个模板参数，一个类型参数和一个表达式参数。实现打印整个数组现在，假设我们要写一个函数来输出整个数组。虽然我们可以将它作为一个成员函数来实现，但我们将它作为一个非成员函数来实现，因为它将使后续的例子更容易理解。使用模板，我们可以这样写:123456template &lt;typename T, int size&gt;void print(StaticArray&lt;T, size&gt; &amp;array)&#123; for (int count&#123; 0 &#125;; count &lt; size; ++count) std::cout &lt;&lt; array[count] &lt;&lt; ' ';&#125;这将使我们能够做到以下几点:12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstring&gt; template &lt;class T, int size&gt; // size is the expression parameterclass StaticArray&#123;private: // The expression parameter controls the size of the array T m_array[size]&#123;&#125;; public: T* getArray() &#123; return m_array; &#125; T&amp; operator[](int index) &#123; return m_array[index]; &#125;&#125;; template &lt;typename T, int size&gt;void print(StaticArray&lt;T, size&gt; &amp;array)&#123; for (int count&#123; 0 &#125;; count &lt; size; ++count) std::cout &lt;&lt; array[count] &lt;&lt; ' ';&#125; int main()&#123; // declare an int array StaticArray&lt;int, 4&gt; int4&#123;&#125;; int4[0] = 0; int4[1] = 1; int4[2] = 2; int4[3] = 3; // Print the array print(int4); return 0;&#125;/*结果*/0 1 2 3缺陷虽然这是可行的，但它有一个设计缺陷。考虑以下:123456789101112int main()&#123; // declare a char array StaticArray&lt;char, 14&gt; char14&#123;&#125;; std::strcpy(char14.getArray(), \"Hello, world!\"); // Print the array print(char14); return 0;&#125;(我们在 6.6 – C-style strings学习了std::strcpy，如果你需要复习的话)这个程序将编译、执行并生成以下值(或类似的值):1H e l l o , w o r l d !对于非char类型，在每个数组元素之间放一个空格是有意义的，这样它们就不会一起运行。但是，对于char类型，打印所有以c样式字符串运行的内容更有意义，而我们的print()函数并没有这样做。如何修复?1、模板专门化首先考虑使用模板专门化。完全模板专门化的问题是必须显式定义所有模板参数。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstring&gt; template &lt;class T, int size&gt; // size is the expression parameterclass StaticArray&#123;private: // The expression parameter controls the size of the array T m_array[size]&#123;&#125;; public: T* getArray() &#123; return m_array; &#125; T&amp; operator[](int index) &#123; return m_array[index]; &#125;&#125;; template &lt;typename T, int size&gt;void print(StaticArray&lt;T, size&gt; &amp;array)&#123; for (int count&#123; 0 &#125;; count &lt; size; ++count) std::cout &lt;&lt; array[count] &lt;&lt; ' ';&#125; // Override print() for fully specialized StaticArray&lt;char, 14&gt;// 使用模板专门化，所以必须显式的定义所有模板参数。⭐⭐template &lt;&gt;void print(StaticArray&lt;char, 14&gt; &amp;array)&#123; for (int count&#123; 0 &#125;; count &lt; 14; ++count) std::cout &lt;&lt; array[count];&#125; int main()&#123; // declare a char array StaticArray&lt;char, 14&gt; char14&#123;&#125;; std::strcpy(char14.getArray(), \"Hello, world!\"); // Print the array print(char14); return 0;&#125;如您所见，我们现在为完全专门化的StaticArray提供了一个重载的打印函数。事实上,这种打印:1Hello, world!有隐患虽然这解决了使用StaticArray调用print()的问题，但它带来了另一个问题: 使用完整的模板专门化意味着我们必须显式地定义这个函数将接受的数组的长度! 考虑下面的例子:123456789101112int main()&#123; // declare a char array StaticArray&lt;char, 12&gt; char12&#123;&#125;; std::strcpy(char12.getArray(), \"Hello, mom!\"); // Print the array print(char12); return 0;&#125;使用char12调用 print()将调用 接受StaticArray&lt;T, size&gt;的print()版本，因为char12的类型是StaticArray&lt;char, 12&gt;，而我们重载的print()只有在传递StaticArray&lt;char, 14&gt;时才会被调用。虽然我们可以创建一个print()的副本来处理StaticArray，但是当我们调用数组大小为5或22的print()时会发生什么呢?我们需要复制每个不同数组大小的函数。这是多余的。显然，完全模板专门化在这里是一种限制性太强的解决方案。我们正在寻找的解决方案是：局部模板专门化。2、局部模板专门化⭐⭐⭐局部模板专门化允许我们专门化类(但不是单独的函数!)， 其中一些(但不是所有)模板参数已被显式定义。对于上面的挑战，理想的解决方案是让重载的打印函数使用char类型的StaticArray，但保留长度表达式参数模板，以便根据需要进行更改。局部模板专门化允许我们这样做!下面是一个重载打印函数的例子，它使用了一个部分专门化的StaticArray:1234567// print()函数的重载，用于部分特殊的StaticArray&lt;char, size&gt;template &lt;int size&gt; // size仍然是一个模板化的表达式参数void print(StaticArray&lt;char, size&gt; &amp;array) // 我们在这里显式定义了char类型&#123; for (int count&#123; 0 &#125;; count &lt; size; ++count) std::cout &lt;&lt; array[count];&#125;正如您在这里看到的，我们已经明确声明这个函数只适用于char类型的StaticArray，但是size仍然是一个模板化的表达式参数，所以它适用于任何大小的char数组。就是这样!注意注意，从c++ 14开始，部分模板专门化只能用于类，而不能用于函数模板(函数必须完全专门化)。我们的void print(StaticArray &amp;array)示例可以工作，因为print函数不是部分专门化的(它只是使用了部分专门化的类参数的重载函数)。成员函数的局部模板专门化函数模板不能局部专门化在处理成员函数时，对函数局部专门化的限制可能会导致一些挑战。例如，如果我们像这样定义StaticArray呢?12345678910111213141516171819202122template &lt;class T, int size&gt; // size is the expression parameterclass StaticArray&#123;private: // The expression parameter controls the size of the array T m_array[size]&#123;&#125;; public: T* getArray() &#123; return m_array; &#125; T&amp; operator[](int index) &#123; return m_array[index]; &#125; void print() &#123; for (int i&#123; 0 &#125;; i &lt; size; ++i) std::cout &lt;&lt; m_array[i] &lt;&lt; ' '; std::cout &lt;&lt; '\\n'; &#125;&#125;;print()现在是 StaticArray&lt;T, int&gt;类的成员函数。那么，当我们想要 部分专门化print()以使其工作方式不同时，会发生什么情况呢?你可以试试这个:12345678// Doesn't worktemplate &lt;int size&gt;void StaticArray&lt;double, size&gt;::print()&#123; for (int i&#123; 0 &#125;; i &lt; size; ++i) std::cout &lt;&lt; std::scientific &lt;&lt; m_array[i] &lt;&lt; ' '; std::cout &lt;&lt; '\\n';&#125;不幸的是，这不起作用，因为我们试图部分专门化一个函数，这是不允许的。让整个类部分专门化那么我们该如何解决这个问题呢?一个明显的方法是让整个类部分专门化:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt; template &lt;class T, int size&gt; // size is the expression parameterclass StaticArray&#123;private: // The expression parameter controls the size of the array T m_array[size]&#123;&#125;; public: T* getArray() &#123; return m_array; &#125; T&amp; operator[](int index) &#123; return m_array[index]; &#125; void print() &#123; for (int i&#123; 0 &#125;; i &lt; size; ++i) std::cout &lt;&lt; m_array[i] &lt;&lt; ' '; std::cout &lt;&lt; \"\\n\"; &#125;&#125;; //局部专门化 整个类template &lt;int size&gt; // size is the expression parameterclass StaticArray&lt;double, size&gt;&#123;private: // The expression parameter controls the size of the array double m_array[size]&#123;&#125;; public: double* getArray() &#123; return m_array; &#125; double&amp; operator[](int index) &#123; return m_array[index]; &#125; void print() &#123; for (int i&#123; 0 &#125;; i &lt; size; ++i) std::cout &lt;&lt; std::scientific &lt;&lt; m_array[i] &lt;&lt; ' '; std::cout &lt;&lt; '\\n'; &#125;&#125;; int main()&#123; // declare an integer array with room for 6 integers StaticArray&lt;int, 6&gt; intArray&#123;&#125;; // Fill it up in order, then print it for (int count&#123; 0 &#125;; count &lt; 6; ++count) intArray[count] = count; intArray.print(); // declare a double buffer with room for 4 doubles StaticArray&lt;double, 4&gt; doubleArray&#123;&#125;; for (int count&#123; 0 &#125;; count &lt; 4; ++count) doubleArray[count] = (4.0 + 0.1 * count); doubleArray.print(); return 0;&#125;虽然它可以工作，但这不是一个很好的解决方案，因为我们必须复制很多代码，从StaticArray&lt;T, size&gt;至 StaticArray&lt;double, size&gt;使用一个公共基类，使派生类模板局部专门化⭐⭐⭐如果有办法在StaticArray&lt;double, size&gt;中 重用StaticArray&lt;T, size&gt;中的代码 。听起来像是继承的工作!幸运的是，有一个变通方法，通过使用一个公共基类:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt; template &lt;class T, int size&gt; // size是表达式参数class StaticArray_Base //基类⭐&#123;protected: // The expression parameter controls the size of the array T m_array[size]&#123;&#125;; public: T* getArray() &#123; return m_array; &#125; T&amp; operator[](int index) &#123; return m_array[index]; &#125; virtual void print() &#123; for (int i&#123; 0 &#125;; i &lt; size; ++i) std::cout &lt;&lt; m_array[i]; std::cout &lt;&lt; '\\n'; &#125; virtual ~StaticArray_Base() = default;&#125;; //派生类1⭐template &lt;class T, int size&gt; // size is the expression parameterclass StaticArray: public StaticArray_Base&lt;T, size&gt; &#123;public:&#125;; //派生类2⭐template &lt;int size&gt; // size is the expression parameterclass StaticArray&lt;double, size&gt;: public StaticArray_Base&lt;double, size&gt; //注意这里的格式⭐&#123;public: virtual void print() override &#123; for (int i&#123; 0 &#125;; i &lt; size; ++i) std::cout &lt;&lt; std::scientific &lt;&lt; this-&gt;m_array[i] &lt;&lt; ' ';// note: The this-&gt; prefix in the above line is needed.// See https://stackoverflow.com/a/6592617 or https://isocpp.org/wiki/faq/templates#nondependent-name-lookup-members for more info on why. std::cout &lt;&lt; '\\n'; &#125;&#125;; int main()&#123; // declare an integer array with room for 6 integers StaticArray&lt;int, 6&gt; intArray&#123;&#125;; // Fill it up in order, then print it for (int count&#123; 0 &#125;; count &lt; 6; ++count) intArray[count] = count; intArray.print(); // declare a double buffer with room for 4 doubles StaticArray&lt;double, 4&gt; doubleArray&#123;&#125;; for (int count&#123; 0 &#125;; count &lt; 4; ++count) doubleArray[count] = (4.0 + 0.1 * count); doubleArray.print(); return 0;&#125;这与上面的输出相同，但是具有明显较少的重复代码。","categories":[],"tags":[]},{"title":"C&C++/类模板定制","slug":"C&C++/类模板定制","date":"2020-05-17T00:16:04.321Z","updated":"2020-05-17T02:15:15.139Z","comments":true,"path":"archives/dad59d93.html","link":"","permalink":"https://longlongqin.github.io/archives/dad59d93.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/136-class-template-specialization/看一个例子：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;template &lt;class T&gt;class Storage8&#123;private: T m_array[8];public: void set(int index, const T value) &#123; m_array[index] = value; &#125; const T&amp; get(int index) &#123; return m_array[index]; &#125;&#125;;int main()&#123; Storage8&lt;int&gt; intStorage; for (int count = 0; count &lt; 8; ++count) intStorage.set(count, count + 1); for (int count = 0; count &lt; 8; ++count) std::cout &lt;&lt; intStorage.get(count) &lt;&lt; '\\t'; std::cout &lt;&lt; '\\n'; Storage8&lt;bool&gt; boolStorage; for (int count = 0; count &lt; 8; ++count) boolStorage.set(count, count &amp; 3); for (int count = 0; count &lt; 8; ++count) std::cout &lt;&lt; (boolStorage.get(count) ? \"true\" : \"false\") &lt;&lt; '\\t'; return 0;&#125;/*结果*/1 2 3 4 5 6 7 8false true true true false true true true虽然这个类是完全功能性的，但事实证明Storage8的实现比它需要的效率要低得多。因为所有的变量都必须有一个地址，并且CPU不能寻址任何小于一个字节的东西，所以所有的变量都必须至少有一个字节的大小。存储bool类型的变量时浪费空间：因此，bool类型的变量最终使用整个字节，即使从技术上讲，它只需要一个位来存储它的真值或假值! 因此，bool是1位有用的信息和7位浪费的空间。我们的 Storage8&lt;bool&gt;类，其中包含8个bools，即1个字节的有用信息 和7个字节的浪费空间。如何解决？1、虽然我们可以创建一个全新的类来实现这一点，但是这样做有一个主要的缺点：我们必须给它起一个不同的名字。然后程序员必须记住Storage8是用于非bool类型的，而Storage8Bool(或者我们给新类起的任何名字)是用于bools的。我们宁愿避免不必要的复杂性。幸运的是，c++为我们提供了一个更好的方法:类模板专门化。2、幸运的是，c++为我们提供了一个更好的方法：类模板专门化(Class template specialization)。类模板专门化类模板专门 化允许我们 专门化特定数据类型 (或数据类型，如果有多个模板参数) 的模板类。在本例中，我们将使用类模板专门化来编写一个自定义版本的Storage8，它将优先于通用的Storage8类。这类似于专门化函数优先于泛型模板函数。类模板专门化被视为完全独立的类，即使它们是以与模板类相同的方式分配的。这意味着我们可以改变关于专门化类的任何事情，包括它的实现方式，甚至它公开的函数，就好像它是一个独立的类一样。这是我们的专门化类:123456789101112131415161718192021222324252627282930313233 template &lt;&gt; // 下面是一个 无参数模板 的模板类class Storage8&lt;bool&gt; // we're specializing Storage8 for bool&#123;// What follows is just standard class implementation detailsprivate: unsigned char m_data; public: Storage8() : m_data(0) &#123; &#125; void set(int index, bool value) &#123; // 找出我们正在设置/取消设置的位 // 这将在我们感兴趣的 bit加1 unsigned char mask = 1 &lt;&lt; index; if (value) // If we're setting a bit m_data |= mask; // Use bitwise-or to turn that bit on else // if we're turning a bit off m_data &amp;= ~mask; // bitwise-and the inverse mask to turn that bit off &#125; bool get(int index) &#123; // Figure out which bit we're getting unsigned char mask = 1 &lt;&lt; index; // bitwise-and to get the value of the bit we're interested in // Then implicit cast to boolean return (m_data &amp; mask); &#125;&#125;;首先，注意我们从template&lt;&gt;开始。template关键字 告诉编译器下面的内容是模板化的，而空尖括号表示没有任何模板参数。在本例中，没有任何模板参数，因为我们用特定的类型(bool)替换了唯一的模板参数(typename T)。接下来，我们将&lt;bool&gt;添加到类名中，以表示我们正在专门化 Storage8类 的 bool版本。所有其他更改都只是类实现细节。为了使用这个类，您不需要了解位逻辑是如何工作的(如果您想了解它，可以复习 O.2 – Bitwise operators，但是需要复习一下位运算符是如何工作的)。请注意，这个专门化类使用一个无符号字符(1字节)，而不是一个8个bools(8字节)的数组。","categories":[],"tags":[]},{"title":"C&C++/函数模板定制","slug":"C&C++/函数模板定制","date":"2020-05-16T14:43:17.235Z","updated":"2020-05-16T15:47:26.643Z","comments":true,"path":"archives/9a78acc3.html","link":"","permalink":"https://longlongqin.github.io/archives/9a78acc3.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/13-5-function-template-specialization/当为给定类型实例化函数模板时，编译器将输出模板函数的副本，并将模板类型参数替换为变量声明中使用的实际类型。这意味着一个特定的函数对于每个实例类型都有相同的实现细节(只是使用不同的类型)。虽然大多数情况下，这正是您想要的，但是在某些情况下，为特定的数据类型实现略有不同的模板函数是有用的。成员函数模板的定制函数模板专定制 (有时称为完整或显式函数模板专门化)，实现步骤比较简单：只需定义专门的函数 (如果该函数是成员函数，则在类定义之外定义)，将模板类型替换为您希望为其重新定义函数的特定类型。例子1：12345678910111213141516171819202122232425262728293031template &lt;class T&gt;class Storage&#123;private: T m_value;public: Storage(T value) &#123; m_value = value; &#125; ~Storage() &#123; &#125; void print() &#123; std::cout &lt;&lt; m_value &lt;&lt; '\\n'; &#125;&#125;;int main()&#123; // Define some storage units Storage&lt;int&gt; nValue(5); Storage&lt;double&gt; dValue(6.7); // Print out some values nValue.print(); dValue.print();&#125;如果此时，你想让浮点类型的数以 科学计数法 的形式打印，应该怎么做？——应该使相应的打印函数特殊化：12345template &lt;&gt; //⭐⭐ 注意这里没有 模板类型参数void Storage&lt;double&gt;::print() //显式的将模板类型 替换为 我想要的类型&#123; std::cout &lt;&lt; std::scientific &lt;&lt; m_value &lt;&lt; '\\n'; //函数主体也修改了&#125;当编译器实例化Storage&lt;double&gt;::print()时，它会看到我们已经显式地定义了那个函数，它将使用我们定义的那个函数，而不是从泛型模板类中输出一个版本。template &lt;&gt;告诉编译器这是一个模板函数，但是没有模板参数 (因为在本例中，我们显式地指定了所有类型)。一些编译器可能允许您省略它，但是最好包括它。例子2：现在让我们看另一个模板专门化可能有用的例子。考虑一下，如果我们尝试使用带有数据类型char*的模板化 Storage类，会发生什么:123456789101112131415161718int main()&#123; // ：动态分配一个临时字符串 char *string = new char[40]; // Ask user for their name std::cout &lt;&lt; \"Enter your name: \"; std::cin &gt;&gt; string; // Store the name Storage&lt;char*&gt; storage(string); // Delete the temporary string delete[] string; // Print out our value storage.print(); // This will print garbage&#125;结果显示，与打印用户输入的名称不同，storage.print()打印的是垃圾! 这是怎么回事?实例化char类型的Storage时，Storage&lt;char\\&gt;的构造函数如下:12345template &lt;&gt;Storage&lt;char*&gt;::Storage(char* value)&#123; m_value = value;&#125;换句话说，这只是做一个指针赋值(浅拷贝)! 结果，m_value最终指向与string相同的内存位置。当我们删除main()中的字符串时，我们最终会删除m_value指向的值!因此，当我们试图打印那个值时，我们会得到垃圾。幸运的是，我们可以使用模板专门化来解决这个问题。我们希望构造函数复制输入的字符串，而不是复制指针。因此，让我们为数据类型char*编写一个专门的构造函数：1234567891011121314template &lt;&gt; //⭐⭐⭐Storage&lt;char*&gt;::Storage(char* value)&#123; //求value的长度 int length = 0; while(value[length] != '\\0') ++length; ++length; //+1 表示空终止符 //分配内存来保存 value字符串 m_value = new char[length]; for(int count=0; count &lt; length; ++count) //将实际的value字符串复制到我们刚刚分配的m_value内存中 m_value[count] = value[count];&#125;现在，当我们分配一个 Storage&lt;char*&gt;类型的变量时，将使用这个构造函数而不是默认的构造函数。结果，m_value将收到它自己的字符串副本。因此，当我们删除字符串时，m_value将不受影响。但是，这个类现在存在 char*类型的内存泄漏，因为当存储变量超出作用域时，m_value不会被删除。你可能已经猜到了，这也可以通过专门化 Storage&lt;char*&gt;析构函数:12345template &lt;&gt;Storage&lt;char*&gt;::~Storage()&#123; delete[] m_value; &#125;现在，当Storage类型的变量超出作用域时，在 专用构造函数中分配的内存将在 专用析构函数中删除。非成员函数模板的定制尽管上面的例子都使用了成员函数，但是也可以用同样的方法专门化非成员模板函数。","categories":[],"tags":[]},{"title":"C&C++/非类型参数模板","slug":"C&C++/非类型参数模板","date":"2020-05-16T14:20:10.932Z","updated":"2020-05-16T14:41:46.683Z","comments":true,"path":"archives/388fba4a.html","link":"","permalink":"https://longlongqin.github.io/archives/388fba4a.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/134-template-non-type-parameters/在前面的课程中，您已经学习了如何使用 模板类型参数 来创建与类型无关的函数和类。然而，模板类型参数并不是唯一可用的模板参数类型。模板类和函数可以使用另一种称为非类型参数模板的参数。非类型参数非类型参数模板是一种特殊类型的参数，它不替换类型，而是由值替换。非类型参数可以是以下任意一种:具有整型或枚举的值指向类对象的指针或引用指向函数的指针或引用指向类成员函数的指针或引用std::nullptr_t下面这个例子，我们创建类一个静态数组，使用了两个 类型参数：一个是：类型参数。它控制静态数组的数据类型。一个是：非类型参数。他控制静态数组的长度。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt; template &lt;class T, int size&gt; // size是非类型参数class StaticArray&#123;private: // 非类型参数控制数组的长度 T m_array[size]; public: T* getArray(); T&amp; operator[](int index) &#123; return m_array[index]; &#125;&#125;; // 说明如何在类外部定义具有非类型参数的类的函数 ⭐⭐⭐template &lt;class T, int size&gt;T* StaticArray&lt;T, size&gt;::getArray()&#123; return m_array;&#125; int main()&#123; //⭐ declare an integer array with room for 12 integers StaticArray&lt;int, 12&gt; intArray; // Fill it up in order, then print it backwards for (int count=0; count &lt; 12; ++count) intArray[count] = count; for (int count=11; count &gt;= 0; --count) std::cout &lt;&lt; intArray[count] &lt;&lt; \" \"; std::cout &lt;&lt; '\\n'; //⭐ declare a double buffer with room for 4 doubles StaticArray&lt;double, 4&gt; doubleArray; for (int count=0; count &lt; 4; ++count) doubleArray[count] = 4.4 + 0.1*count; for (int count=0; count &lt; 4; ++count) std::cout &lt;&lt; doubleArray[count] &lt;&lt; ' '; return 0;&#125;结果：1211 10 9 8 7 6 5 4 3 2 1 04.4 4.5 4.6 4.7关于上面的例子，值得注意的是我们不需要动态分配m_array成员变量!这是因为对于StaticArray类 的任何给定实例，size实际上都是常量。例如，如果实例化为：StaticArray&lt;int, 12&gt;，编译器将大小替换为12。因此m_array的类型是int[12]，可以静态分配。标准库类std::array就是用的这个功能。当您分配一个std::array时，int是一个类型参数，而5是一个非类型参数!","categories":[],"tags":[]},{"title":"C&C++/模板类","slug":"C&C++/模板类","date":"2020-05-16T08:55:47.873Z","updated":"2020-05-16T10:43:54.333Z","comments":true,"path":"archives/3bfe5978.html","link":"","permalink":"https://longlongqin.github.io/archives/3bfe5978.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/133-template-classes/在10.6 – Container classes中，您学习了如何使用复合来实现包含其他类的多个实例的类。作为这种容器的一个例子，我们研究了IntArray类。下面是该类的一个简化示例:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#ifndef INTARRAY_H#define INTARRAY_H #include &lt;cassert&gt; class IntArray&#123;private: int m_length&#123;&#125;; int *m_data&#123;&#125;; public: IntArray(int length) &#123; assert(length &gt; 0); m_data = new int[length]&#123;&#125;; m_length = length; &#125; // We don't want to allow copies of IntArray to be created. IntArray(const IntArray&amp;) = delete; IntArray&amp; operator=(const IntArray&amp;) = delete; ~IntArray() &#123; delete[] m_data; &#125; void Erase() &#123; delete[] m_data; // We need to make sure we set m_data to 0 here, otherwise it will // be left pointing at deallocated memory! m_data = nullptr; m_length = 0; &#125; int&amp; operator[](int index) &#123; assert(index &gt;= 0 &amp;&amp; index &lt; m_length); return m_data[index]; &#125; int getLength() const &#123; return m_length; &#125;&#125;; #endif虽然这个类提供了一种创建整数数组的简单方法，但是如果我们想要创建一个双精度数组呢?使用传统的编程方法，我们必须创建一个全新的类!下面是DoubleArray的一个例子，它是一个数组类，用于保存double。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#ifndef DOUBLEARRAY_H#define DOUBLEARRAY_H #include &lt;cassert&gt; class DoubleArray&#123;private: int m_length&#123;&#125;; double *m_data&#123;&#125;; public: DoubleArray(int length) &#123; assert(length &gt; 0); m_data = new double[length]&#123;&#125;; m_length = length; &#125; DoubleArray(const DoubleArray&amp;) = delete; DoubleArray&amp; operator=(const DoubleArray&amp;) = delete; ~DoubleArray() &#123; delete[] m_data; &#125; void Erase() &#123; delete[] m_data; // We need to make sure we set m_data to 0 here, otherwise it will // be left pointing at deallocated memory! m_data = nullptr; m_length = 0; &#125; double&amp; operator[](int index) &#123; assert(index &gt;= 0 &amp;&amp; index &lt; m_length); return m_data[index]; &#125; int getLength() const &#123; return m_length; &#125;&#125;; #endif尽管代码清单很长，但您会注意到这两个类几乎完全相同!实际上，惟一的实质性区别是所包含的数据类型(int和double)。您可能已经猜到了，这是另一个可以充分利用模板的领域，从而使我们不必创建绑定到特定数据类型的类。使用模板类创建模板类的工作方式与创建模板函数的工作方式几乎相同，因此我们将通过示例继续。这是我们的数组类，模板版本:Array.h:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#ifndef ARRAY_H#define ARRAY_H #include &lt;cassert&gt; template &lt;class T&gt;class Array&#123;private: int m_length&#123;&#125;; T *m_data&#123;&#125;; public: Array(int length) &#123; assert(length &gt; 0); m_data = new T[length]&#123;&#125;; m_length = length; &#125; Array(const Array&amp;) = delete; Array&amp; operator=(const Array&amp;) = delete; ~Array() &#123; delete[] m_data; &#125; void Erase() &#123; delete[] m_data; // 我们需要确保我们在这里设置m_data为0，否则它会 指向释放了的内存!! m_data = nullptr; m_length = 0; &#125; T&amp; operator[](int index) &#123; assert(index &gt;= 0 &amp;&amp; index &lt; m_length); return m_data[index]; &#125; // 模板函数getLength() 的定义在下面 int getLength() const; &#125;; // 定义在类外部的成员函数需要它们自己的模板声明⭐template &lt;class T&gt;int Array&lt;T&gt;::getLength() const // 注意类名是Array&lt;T&gt;，不是Array⭐&#123; return m_length;&#125; #endif正如您所看到的，这个版本与IntArray版本几乎完全相同，只是我们添加了模板声明，并将所包含的数据类型从int更改为T。注意：注意，我们还在类声明之外定义了getLength()函数。这并不是必须的，但是由于语法的原因，新程序员在第一次尝试这样做时通常会出错，所以下面的例子很有启发意义。在类声明之外声明的每个模板化成员函数都需要自己的模板声明。另外，请注意模板化数组类的名称是Array，而不是array——array将引用一个名为array的类的非模板化版本。这里是一个简短的例子使用上述模板 array类:123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include \"Array.h\" int main()&#123; Array&lt;int&gt; intArray(12); Array&lt;double&gt; doubleArray(12); for (int count&#123; 0 &#125;; count &lt; intArray.getLength(); ++count) &#123; intArray[count] = count; doubleArray[count] = count + 0.5; &#125; for (int count&#123; intArray.getLength() - 1 &#125;; count &gt;= 0; --count) std::cout &lt;&lt; intArray[count] &lt;&lt; '\\t' &lt;&lt; doubleArray[count] &lt;&lt; '\\n'; return 0;&#125;/*结果*/11 11.510 10.59 9.58 8.57 7.56 6.55 5.54 4.53 3.52 2.51 1.50 0.5模板类的实例化方法与模板函数相同模板类的实例化方式与模板函数相同——编译器根据需要 模板化一个副本，用 用户输入的实际数据类型替换 模板参数，然后编译该副本。如果您从未使用过模板类，编译器甚至不会编译它。板类确实是c++最好和最有用的特性之一模板类是实现容器类的理想对象，因为让容器跨各种数据类型工作是非常理想的，而模板允许您在不复制代码的情况下这样做。虽然语法很难看，错误消息也很隐晦，但是模板类确实是c++最好和最有用的特性之一。标准库中的模板类现在我们已经介绍了模板类，您应该理解std::vector&lt;int&gt;是什么意思了——std::vector实际上是一个模板类，int是模板的类型参数。标准库中有很多预定义的模板类可供您使用。我们将在后面的章节中讨论这些。分解模板类模板不是类，也不是函数——它是用于创建类或函数的模板。因此，它的工作方式与普通函数或类不太一样。在大多数情况下，这不是什么大问题。然而，有一个方面通常会给开发人员带来问题。为什么要分解对于非模板类，通常的过程是将类定义放在头文件中(.h)，将成员函数定义放在相同名字的代码文件中(.cpp)。通过这种方式，类的源代码(.cpp)被编译为一个单独的项目文件。但是，对于模板，这是行不通的。考虑以下:Array.h:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#ifndef ARRAY_H#define ARRAY_H #include &lt;cassert&gt; template &lt;class T&gt;class Array&#123;private: int m_length&#123;&#125;; T* m_data&#123;&#125;; public: Array(int length) &#123; assert(length &gt; 0); m_data = new T[length]&#123;&#125;; m_length = length; &#125; Array(const Array&amp;) = delete; Array&amp; operator=(const Array&amp;) = delete; ~Array() &#123; delete[] m_data; &#125; void Erase() &#123; delete[] m_data; m_data = nullptr; m_length = 0; &#125; T&amp; operator[](int index) &#123; assert(index &gt;= 0 &amp;&amp; index &lt; m_length); return m_data[index]; &#125; int getLength() const; &#125;; #endifArray.cpp:1234567#include \"Array.h\" template &lt;class T&gt;int Array&lt;T&gt;::getLength() const // note class name is Array&lt;T&gt;, not Array&#123; return m_length;&#125;main.cpp:123456789101112131415161718#include \"Array.h\" int main()&#123; Array&lt;int&gt; intArray(12); Array&lt;double&gt; doubleArray(12); for (int count&#123; 0 &#125;; count &lt; intArray.getLength(); ++count) &#123; intArray[count] = count; doubleArray[count] = count + 0.5; &#125; for (int count&#123; intArray.getLength() - 1 &#125;; count &gt;= 0; --count) std::cout &lt;&lt; intArray[count] &lt;&lt; '\\t' &lt;&lt; doubleArray[count] &lt;&lt; '\\n'; return 0;&#125;以上程序将编译，但导致链接器错误:1unresolved external symbol &quot;public: int __thiscall Array::getLength(void)&quot; (?GetLength@?$Array@H@@QAEHXZ)为了让编译器使用模板，它必须同时看到 模板定义(不仅仅是一个声明) 和 用于实例化模板的模板类型。还要记住，C++单独编译文件。当 Array.h 被包含在main中时，模板类定义 被复制到main.cpp中。当编译器看到我们需要两个模板实例，Array&lt;int&gt; 和 Array&lt;double&gt;，它将实例化它们，并将它们编译为main.cpp的一部分。但是，当单独编译Array.cpp时，它会忘记我们需要一个Array&lt;int&gt; 和 Array&lt;double&gt;，这样模板函数就不会被实例化。因此，我们得到一个链接器错误，因为编译器找不到Array&lt;int&gt;::getLength()或Array&lt;double&gt;::getLength()的定义。分解方法有很多方法可以解决这个问题。将模板类的.h 与 .cpp 文件中的代码 全部放在 .h文件中。这是我们的首选解决方案，除非编译或链接时间 开始成为问题。这样，当您#include头部时，所有的模板代码都将在一个位置。这个解决方案的优点是它很简单。这里的缺点是，如果模板类在很多地方使用，您将会得到模板类的许多本地副本，这会增加编译和链接的时间(链接器应该删除重复的定义，因此它不应该使您的可执行文件膨胀)。将xxx.cpp文件重命名为xxx.inl如果您认为将Array.cpp代码放到Array.h头文件中会使头文件太长/混乱，那么可以使用另一种方法：将Array.cpp重命名为Array.inl(.inl代表内联)，然后在Array.h中的底部 #include &quot;Array.inl&quot;。这将产生与将所有代码放入头中相同的结果，但有助于保持更简洁。在main.cpp文件中，包含模板类的.cpp文件，即#include &quot;xxx.cpp&quot;但是我们不推荐这个方法，因为这是#include的非标准用法。三文件法这个方法更有效，但是需要维护每个程序的templates.cpp文件。将模板类的定义放在.h文件中；将模板类的成员函数的定义放在.cpp文件中；最后你添加第三个文件(假设叫templates.cpp)，它包含了你需要的所有实例化类。然后在main.cpp中包含#include &quot;templates.cpp&quot;。如，下面展示了一个添加的第三个文件：templates.cpp12345678// 确保可以看到完整的数组模板定义#include \"Array.h\"#include \"Array.cpp\" //我们在这里打破了最佳实践，但只是在这个地方// 在这里包含您需要的其他.h和.cpp模板定义template class Array&lt;int&gt;; //⭐显式实例化模板Array&lt;int&gt;template class Array&lt;double&gt;; //⭐显式实例化模板Array&lt;double&gt;//在这里实例化其他模板“模板类”命令使编译器显式实例化模板类。在上面的例子中，编译器会在template .cpp中 模板印刷出Array&lt;int&gt; 和 Array&lt;double&gt;。因为templates.cpp在我们的项目中，这个将会被编译。然后可以从其他地方链接这些函数。","categories":[],"tags":[]},{"title":"C&C++/函数模板实例化","slug":"C&C++/函数模板实例化","date":"2020-05-15T13:49:12.062Z","updated":"2020-05-15T14:29:00.782Z","comments":true,"path":"archives/28492eb.html","link":"","permalink":"https://longlongqin.github.io/archives/28492eb.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/132-function-template-instances/我们有必要简要了解一下模板函数是如何在c++中实现的，因为将来的课程将以这些概念为基础。函数模板实例事实证明，c++并没有直接编译模板函数。相反，在编译时，当编译器遇到对模板函数的调用时，它复制模板函数并用实际类型替换模板类型参数。 具有实际类型的函数称为函数模板实例。让我们看一下这个过程的一个例子。首先，我们有一个模板函数:12345template &lt;typename T&gt; // 这是模板参数声明const T&amp; max(const T&amp; x, const T&amp; y)&#123; return (x &gt; y) ? x : y;&#125;编译程序时，编译器遇到一个调用模板函数:1int i&#123; max(3, 7) &#125;; // calls max(int, int)编译器会说，“哦，我们要调用max(int, int)” 编译器复制函数模板并创建模板实例max(int, int):1234const int&amp; max(const int&amp; x, const int&amp; y)&#123; return (x&gt;y) ? x : y;&#125;这现在是一个可以被编译成机器语言的“普通函数”。现在，让我们在稍后的代码中使用不同的类型再次调用max():1double d&#123;max(6.34, 18.523) &#125;; // calls max(double, double)c++自动创建一个模板实例：max(double，double):1234const double&amp; max(const double&amp; x, const double&amp; y)&#123; return (x&gt;y) ? x : y;&#125;然后编译它。编译器足够聪明，知道它只需要为每组惟一类型参数(每个文件) 创建一个模板实例。还有，如果您创建了一个模板函数，但是没有调用它，那么将不会创建任何模板实例。操作符、函数调用和函数模板模板函数可以使用内置类型(例如char、int、double等)和类。但是我们需要注意：当编译器编译模板实例时，它像普通函数一样编译它。在普通函数中，必须定义与类型一起使用的任何操作符或函数调用，否则将得到编译器错误。类似地，模板函数中的任何 操作符或函数调用 都必须为实例化函数模板的任何类型 定义。让我们更详细地看看这个：首先，我们将创建一个简单的类:12345678910class Cents&#123;private: int m_cents;public: Cents(int cents) : m_cents&#123; cents &#125; &#123; &#125;&#125;;现在，让我们看看当我们尝试调用带有Cents类的模板化max()函数时会发生什么:1234567891011121314151617181920212223242526template &lt;typename T&gt; // 这是模板参数声明const T&amp; max(const T&amp; x, const T&amp; y)&#123; return (x &gt; y) ? x : y;&#125; class Cents&#123;private: int m_cents;public: Cents(int cents) : m_cents&#123; cents &#125; &#123; &#125;&#125;; int main()&#123; Cents nickle&#123; 5 &#125;; Cents dime&#123; 10 &#125;; Cents bigger&#123; max(nickle, dime) &#125;; return 0;&#125;c++将为max()创建一个模板实例，看起来像这样:1234const Cents&amp; max(const Cents &amp;x, const Cents &amp;y)&#123; return (x &gt; y) ? x : y;&#125;然后它会尝试编译这个函数。看到问题了吗?c++不能计算x &gt; y，因为x和y是 Cents 类对象，编译器不知道如何比较它们。因此，这将产生一个编译错误，如下所示:1234561&gt;c:\\consoleapplication1\\main.cpp(4): error C2676: binary &#39;&gt;&#39;: &#39;const Cents&#39; does not define this operator or a conversion to a type acceptable to the predefined operator1&gt; c:\\consoleapplication1\\main.cpp(23): note: see reference to function template instantiation &#39;const T &amp;max(const T &amp;,const T &amp;)&#39; being compiled1&gt; with1&gt; [1&gt; T&#x3D;Cents1&gt; ]顶部的错误消息指出了这样一个事实: 对于Cents类，没有重载操作符&gt;。底部的错误指出了引发错误的模板化函数调用，以及模板化参数的类型。要解决这个问题，只需重载任何我们希望使用max()的类的&gt;操作符:1234567891011121314class Cents&#123;private: int m_cents;public: Cents(int cents) : m_cents&#123; cents &#125; &#123; &#125; friend bool operator&gt;(const Cents &amp;c1, const Cents &amp;c2) //重载操作符 &gt; ，从而模板实例中可以使用该重载操作符&gt; &#123; return (c1.m_cents &gt; c2.m_cents); &#125;现在c++将知道当x和y是Cents类的对象时，如何比较x &gt; y ! 因此，我们的max()函数现在将处理两个类型为Cents的对象。","categories":[],"tags":[]},{"title":"C&C++/函数模板","slug":"C&C++/函数模板","date":"2020-05-15T09:18:03.325Z","updated":"2020-05-15T13:48:13.072Z","comments":true,"path":"archives/454c1de9.html","link":"","permalink":"https://longlongqin.github.io/archives/454c1de9.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/131-function-templates/在前几章中，您已经学习了如何编写函数和类，这些函数和类有助于使程序更容易编写、更安全、更易于维护。虽然函数和类是有效编程的强大而灵活的工具，但在某些情况下，它们也可能有一些限制，因为c++要求指定所有参数的类型。例如，假设您想编写一个函数来计算两个数字的最大值。你可以这样做:1234int max(int x, int y)&#123; return (x &gt; y) ? x : y;&#125;这个函数对于整数非常有用。当您意识到max()函数需要使用double时，会发生什么? 传统上，解决方法是重载max()函数，并创建一个使用双精度浮点数的新版本:1234double max(double x, double y)&#123; return (x &gt; y) ? x : y;&#125;注意，max()的双版本实现的代码与max()的int版本完全相同! 事实上，这个实现适用于所有不同的类型:char、int、double ! 但是，因为c++要求您使变量具有特定的类型，所以您必须为希望使用的每种类型编写一个函数。必须为同一个函数指定不同的“风格”，其中惟一改变的是参数的类型，这可能会成为维护上的麻烦和时间上的浪费，而且也违反了一般的编程准则，即尽可能减少重复的代码。如果我们可以编写max()的一个版本，它可以处理任何类型的参数，这不是很好吗?欢迎来到模板的世界。什么是函数模板?如果你在字典中查找“template”这个词，你会发现它的定义与以下内容类似:“模板是一种模型，用作创建类似对象的模式”。在c++中，函数模板是作为创建其他类似函数的模式的函数。函数模板背后的基本思想是：创建一个函数，而不必指定某些或所有变量的确切类型。我们使用占位符类型定义函数，称为模板类型参数。一旦我们使用这些占位符类型创建了一个函数，我们就有效地创建了一个“函数模板”。当您调用一个模板函数时，编译器会“模板化”出模板的一个副本，用函数调用中的参数中的实际变量类型替换占位符类型 !使用这种方法，编译器可以从一个模板创建多个函数的“风格”! 在下一课中，我们将更详细地了解这个过程。在C++中创建函数模板此时，您可能想知道如何在c++中实际创建函数模板。事实证明，这并没有那么难。让我们再来看看max()的int版本:1234int max(int x, int y)&#123; return (x &gt; y) ? x : y;&#125;注意，有3个地方使用了特定的类型: 参数x、y和 返回值 都指定它们必须是整数。要创建函数模板，我们将用占位符类型替换这些特定类型。在这种情况下，因为我们只有一种类型需要替换(int)，所以我们只需要一个模板类型参数。您可以为占位符类型命名几乎任何您想要的名称，只要它不是保留字。然而，在c++中，习惯上将模板类型命名为字母T(“Type”的缩写)。​ 这是我们的新函数与占位符类型:1234T max(T x, T y)&#123; return (x &gt; y) ? x : y;&#125;这是一个好的开始——但是，它不会编译，因为编译器不知道“T”是什么!为了实现这一点，我们需要告诉编译器两件事:⭐⭐第一，这是一个模板定义，第二，T是一个占位符类型。我们可以在一行中完成这两件事，使用所谓的模板参数声明( template parameter declaration):12345template &lt;typename T&gt; // 这是模板参数声明 (在这里可以使用⭐ typename 或者 class)T max(T x, T y)&#123; return (x &gt; y) ? x : y;&#125;现在，让我们稍微仔细看看模板参数声明：我们从开始于：关键字template这告诉编译器，接下来的内容将是一个模板参数列表。我们将所有参数放在尖括号中(&lt;&gt;)。要创建模板类型参数，请使用关键字typename或class。这两个关键字在上下文中没有区别，所以使用哪个关键字取决于您自己。注意，如果使用class关键字，传入的类型实际上不必是一个类(它可以是一个基本变量、指针或其他匹配的东西)。然后命名您的类型(通常为“T”)。如果模板函数使用多个模板类型参数，它们可以用逗号分隔:12template &lt;typename T1, typename T2&gt;// template function here对于使用不止一种类型的，通常会看到它们被命名为“T1”和“T2”，或者其他单个大写字母的名称，例如“S”。最后一点注意:因为传入T类型的函数参数可以是一个类类型，通过值传递类通常不是一个好主意，所以最好让模板函数的参数和返回类型引用:12345template &lt;typename T&gt;const T&amp; max(const T&amp; x, const T&amp; y) ⭐&#123; return (x &gt; y) ? x : y;&#125;使用函数模板使用函数模板非常简单——您可以像使用其他函数一样使用它。这里是一个完整的程序使用我们的模板函数:1234567891011121314151617181920212223242526#include &lt;iostream&gt; template &lt;typename T&gt;const T&amp; max(const T&amp; x, const T&amp; y)&#123; return (x &gt; y) ? x : y;&#125; int main()&#123; int i = max(3, 7); // returns 7 std::cout &lt;&lt; i &lt;&lt; '\\n'; double d = max(6.34, 18.523); // returns 18.523 std::cout &lt;&lt; d &lt;&lt; '\\n'; char ch = max('a', '6'); // returns 'a' std::cout &lt;&lt; ch &lt;&lt; '\\n'; return 0;&#125;/*结果*/718.523a注意，所有这三个对max()的调用都有不同类型的参数! 因为我们调用了具有3种不同类型的函数，所以编译器将使用模板定义来创建该函数的3个不同版本：一个带有int参数(名为：max&lt;int&gt;)，一个具有double参数(名为：max&lt;double&gt;)，一个带有char参数(名为：max&lt;char&gt;)。注意，只要编译器能够从参数类型推断出模板类型，就不需要在函数名中显式地指定模板类型(例如max的部分)。小结1、正如您所看到的，模板函数可以节省大量时间，因为您只需要编写一个函数，而且它可以与许多不同的类型一起工作。一旦您习惯了编写函数模板，您就会发现编写它们实际上并不比编写具有实际类型的函数花费更多的时间。模板函数减少了代码维护，因为重复的代码明显减少。最后，模板函数可以更安全，因为当您需要函数处理新类型时，不需要手动复制函数和更改类型 !2、模板函数确实有一些缺点，如果我们不提它们，那就太不小心了：首先，一些较老的编译器没有很好的支持 模板。然而，这个缺点不再像以前那样是个大问题。其次，模板函数通常会产生看起来很疯狂的错误消息，比普通函数更难破译。第三，模板函数会增加编译时间和代码大小，因为单个模板可能会“实现”并在许多文件中重新编译(有很多方法可以解决这个问题)。然而，与模板为您的编程工具包带来的强大和灵活性相比，这些缺陷是相当小的!注意:标准库已经提供了模板化的max()函数(在头文件algorithm中)，所以你不需要自己写(除非你想写)。如果您确实编写了自己的版本，请注意，如果您使用语句“using namespace std;”，可能会出现命名冲突，因为编译器将无法判断您是想要max()版本还是std::max()版本。","categories":[],"tags":[]},{"title":"C&C++/使用操作符“《”打印继承类","slug":"C&C++/使用操作符“《”打印继承类","date":"2020-05-15T08:05:02.406Z","updated":"2020-05-15T09:09:18.717Z","comments":true,"path":"archives/1639a92e.html","link":"","permalink":"https://longlongqin.github.io/archives/1639a92e.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/12-10-printing-inherited-classes-using-operator/考虑以下使用虚拟函数的程序:123456789101112131415161718192021222324class Base&#123;public: Base() &#123;&#125; virtual void print() const &#123; std::cout &lt;&lt; \"Base\"; &#125;&#125;; class Derived : public Base&#123;public: Derived() &#123;&#125; virtual void print() const override &#123; std::cout &lt;&lt; \"Derived\"; &#125;&#125;; int main()&#123; Derived d; Base &amp;b = d; b.print(); // will call Derived::print() return 0;&#125;到目前为止，您应该已经熟悉了这样一个事实: b.print()将调用Derived::print()(因为b指向一个派生类对象，Base::print()是一个虚函数，而Derived::print()是一个覆盖函数)。虽然调用这样的成员函数来执行输出是可以的，但是这种类型的函数不能很好地与std::cout混合使用:123456789101112#include &lt;iostream&gt;int main()&#123; Derived d; Base &amp;b = d; std::cout &lt;&lt; \"b is a \"; b.print(); // 混乱，我们必须中断打印语句来调用这个函数 std::cout &lt;&lt; '\\n'; return 0;&#125;在这节课中，我们将学习如何使用继承重写运算符&lt;&lt;，这样我们就可以像预期的那样使用运算符&lt;&lt;，就像这样:1std::cout &lt;&lt; \"b is a \" &lt;&lt; b &lt;&lt; '\\n'; // much better操作符&lt;&lt;的挑战让我们从重载运算符&lt;&lt;开始，以典型的方式:12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;class Base&#123;public: Base() &#123;&#125; virtual void print() const &#123; std::cout &lt;&lt; \"Base\"; &#125; friend std::ostream&amp; operator&lt;&lt;(std::ostream &amp;out, const Base &amp;b) &#123; out &lt;&lt; \"Base\"; return out; &#125;&#125;; class Derived : public Base&#123;public: Derived() &#123;&#125; virtual void print() const override &#123; std::cout &lt;&lt; \"Derived\"; &#125; friend std::ostream&amp; operator&lt;&lt;(std::ostream &amp;out, const Derived &amp;d) &#123; out &lt;&lt; \"Derived\"; return out; &#125; &#125;; int main()&#123; Base b; std::cout &lt;&lt; b &lt;&lt; '\\n'; Derived d; std::cout &lt;&lt; d &lt;&lt; '\\n'; return 0;&#125;因为这里不需要虚拟函数解析，这个程序像我们期望的那样工作，并打印:12BaseDerived现在，考虑以下main()函数:1234567891011int main()&#123; Derived d; Base &amp;bref = d; std::cout &lt;&lt; bref &lt;&lt; '\\n'; return 0;&#125;/*结果*/Base这可能不是我们所期望的。这是因为我们的操作符&lt;&lt;处理基对象的版本不是virtual，所以std::cout &lt;&lt; bref调用操作符&lt;&lt;处理基对象而不是派生对象的版本。这就是挑战所在。我们可以让运算符&lt;&lt; virtual吗?——不可以如果这个问题是操作符&lt;&lt;不是虚的，我们不能简单地让它成为虚的吗?答案是：不可以。这有很多原因。首先，只有成员函数可以被虚拟化——这是有意义的，因为只有类可以从其他类继承，而且没有办法重写（覆盖）类之外的函数 (可以重载非成员函数，但不能覆盖它们)。因为我们通常将操作符&lt;&lt;作为 friend 实现，而friend不被认为是成员函数，所以操作符&lt;&lt;的friend版本不适合虚拟化。(为了回顾为什么我们用这种方式实现运算符&lt;&lt;，请重温 9.4 – Overloading operators using member functions)。其次，即使我们可以虚拟化运算符&lt;&lt;，也存在这样的问题: Base::operator&lt;&lt;和Derived::operator&lt;&lt; 的函数参数是不同的 (基版本将接受 一个 Base参数，派生版本将接受一个 Derived参数)。因此，派生版本不会被认为是基本版本的覆盖，因此不适合进行虚函数解析。解决办法事实证明，答案非常简单。首先，我们像往常一样在基类中将操作符&lt;&lt;设置为friend。但是，我们不让操作符&lt;&lt;自己打印，而是将此职责委托 给一个可以虚拟化的普通成员函数!看一个例子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;class Base&#123;public: Base() &#123;&#125; // 这是重载运算符&lt;&lt; friend std::ostream&amp; operator&lt;&lt;(std::ostream &amp;out, const Base &amp;b) &#123; // 将打印责任委托给 成员函数print() return b.print(out); &#125; // 我们将依赖于成员函数print()来进行实际的打印 // 因为print是一个普通的成员函数，所以它可以被虚拟化 virtual std::ostream&amp; print(std::ostream&amp; out) const &#123; out &lt;&lt; \"Base\"; return out; &#125;&#125;; class Derived : public Base&#123;public: Derived() &#123;&#125; // 面是处理派生情况的覆盖 print函数 virtual std::ostream&amp; print(std::ostream&amp; out) const override &#123; out &lt;&lt; \"Derived\"; return out; &#125;&#125;; int main()&#123; Base b; std::cout &lt;&lt; b &lt;&lt; '\\n'; Derived d; std::cout &lt;&lt; d &lt;&lt; '\\n'; // 注意，即使没有显式处理派生对象的操作符&lt;&lt;，也可以这样做 Base &amp;bref = d; std::cout &lt;&lt; bref &lt;&lt; '\\n'; return 0;&#125;结果：123BaseDerivedDerived让我们更详细地研究一下。首先，在基类Base中，我们调用操作符&lt;&lt;，它调用虚函数print()。因为我们的基引用参数指向一个基对象，b.print()解析为Base::print()，它执行打印。没什么特别的。在派生的情况下，编译器首先查看是否存在 接受派生对象的操作符&lt;&lt;。没有，因为我们没有定义。接下来，编译器查看是否存在 接受基对象的操作符&lt;&lt;。有。所以编译器隐式地将我们的派生对象向上转换为一个 Base&amp; 并调用这个函数(我们可以自己做这个向上转换，但是编译器在这方面很有帮助）。然后，这个函数调用virtual print()，它解析为Derived::print().。注意，我们不需要为每个派生类定义运算符&lt;&lt; ! 处理基对象的版本 对于基对象和从基派生的任何类都可以很好地工作!第三种情况是前两种情况的混合。首先，编译器将变量bref与接受 基的操作符&lt;&lt;匹配。 调用我们的 虚print()函数，由于基引用实际上指向一个派生对象，因此解析为Derived::print()。问题解决。","categories":[],"tags":[]},{"title":"C&C++/动态强制类型转换","slug":"C&C++/动态强制类型转换","date":"2020-05-15T06:49:35.096Z","updated":"2020-05-15T08:03:34.088Z","comments":true,"path":"archives/d7910ce1.html","link":"","permalink":"https://longlongqin.github.io/archives/d7910ce1.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/12-9-dynamic-casting/早在6.16 – Explicit type conversion (casting) and static_cast中，我们研究了强制转换的概念，以及使用static_cast将变量从一种类型转换为另一种类型。在这节课中，我们将继续研究另一种类型的转换: dynamic_cast。dynamic_cast在处理多态性时，您经常会遇到这样的情况: 您有一个指向基类的指针，但是您想要访问一些只存在于派生类中的信息。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;string&gt; class Base&#123;protected: int m_value; public: Base(int value) : m_value(value) &#123; &#125; virtual ~Base() &#123;&#125;&#125;; class Derived : public Base&#123;protected: std::string m_name; public: Derived(int value, std::string name) : Base(value), m_name(name) &#123; &#125; const std::string&amp; getName() const &#123; return m_name; &#125;&#125;; Base* getObject(bool bReturnDerived)&#123; if (bReturnDerived) return new Derived(1, \"Apple\"); else return new Base(2);&#125; int main()&#123; Base *b = getObject(true); // 如何在只有基指针的情况下打印派生对象的名称? delete b; return 0;&#125;在这个程序中，函数getObject()总是返回一个基指针，但是这个指针可以指向基指针，也可以指向派生的对象。在指针指向派生对象的情况下，我们如何调用Derived::getName()?一种方法是将一个虚函数添加到名为getName()的基函数中(因此我们可以使用一个基指针/引用来调用它，并将其动态解析为::getName())。但是如果你用一个实际指向基对象的基指针/引用来调用这个函数，它会返回什么呢?没有任何有意义的价值。此外，我们可能会用那些实际上只应该是派生类关注的东西来污染基类。我们知道c++将隐式地允许您将派生的指针转换为基指针(事实上，getObject()就是这样做的)。这个过程有时被称为向上转换(upcasting)。但是，如果有一种方法可以将基指针转换回派生指针呢? 然后，我们可以直接使用该指针调用Derived::getName()，而完全不需要担心虚函数的解析问题。有，那就是动态类型转换：dynamic_cast什么是dynamic_castc++提供了一个名为dynamic_cast的转换操作符，可用于 将即指针转换回 派生指针。尽管动态强制转换有一些不同的功能，但到目前为止，动态强制转换最常见的用途是将基类指针转换为派生类指针。——这个过程称为向下转换(downcasting)。使用dynamic_cast的工作原理与使用static_cast一样。下面是我们的例子main()，使用dynamic_cast将我们的基指针转换回派生指针:12345678910111213int main()&#123; Base *b = getObject(true); //使用动态强制转换将基指针转换为派生指针 Derived *d = dynamic_cast&lt;Derived*&gt;(b); std::cout &lt;&lt;\"The name of the Derived is: \" &lt;&lt; d-&gt;getName() &lt;&lt; '\\n'; delete b; return 0;&#125;结果：1The name of the Derived is: Apple动态强制类型转换会失败上面的例子是可行的，因为b实际上指向一个派生的对象，所以将b转换成一个派生的指针是成功的。然而，我们做了一个相当危险的假设: b指向一个派生对象。如果b不是指向一个派生对象呢?通过将参数getObject()从true更改为false，可以很容易地测试这一点。在这种情况下，getObject()将返回一个指向基对象的基指针。当我们试图将dynamic_cast转换为派生类型时，它将失败，因为转换无法进行。如果dynamic_cast失败，转换的结果将是一个空指针。因为我们还没有检查空指针结果，所以我们访问了d-&gt;getName()，它将尝试取消对空指针的引用，从而导致未定义的行为(可能导致崩溃)。为了使这个程序安全，我们需要确保dynamic_cast的结果确实成功:12345678910111213int main()&#123; Base *b = getObject(true); Derived *d = dynamic_cast&lt;Derived*&gt;(b); // 使用动态强制转换将基指针转换为派生指针 if (d) // 确保d是非空指针 std::cout &lt;&lt; \"The name of the Derived is: \" &lt;&lt; d-&gt;getName() &lt;&lt; '\\n'; delete b; return 0;&#125;注意，由于dynamic_cast在 运行时 执行一些 一致性检查(以确保可以进行转换)，使用dynamic_cast确实会导致性能损失。其他使用dynamic_cast失败的情况具有 受保护 或 私有 继承的。对于没有声明或继承任何虚函数(因此没有虚表)的类。在涉及 虚拟基类 的某些情况下(有关这些情况的示例以及如何解决它们，请参见下面链接)。https://docs.microsoft.com/en-us/cpp/cpp/dynamic-cast-operator?redirectedfrom=MSDN&amp;view=vs-2019用static_cast进行向下转换事实证明，向下转换也可以用static_cast完成。主要的区别是static_cast不执行运行时类型检查，来确保您所做的操作是有意义的。这使得使用static_cast更快，但更危险。如果将 Base* 强制转换为Derived* ，即使基指针没有指向派生对象，它也会“成功”。当您试图访问产生的派生指针(实际上是指向基对象)时，这将导致未定义的行为。如果您绝对确定向下强制转换的指针将成功，那么使用static_cast是可以接受的。确保您知道所指向的对象类型的一种方法是使用虚函数。这里有一种方法(不是很好，因为它使用了一个全局变量):1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;string&gt; // 类标识符enum ClassID&#123; BASE, DERIVED // Others can be added here later&#125;; class Base&#123;protected: int m_value; public: Base(int value) : m_value(value) &#123; &#125; virtual ~Base() &#123;&#125; virtual ClassID getClassID() const &#123; return BASE; &#125;&#125;; class Derived : public Base&#123;protected: std::string m_name; public: Derived(int value, std::string name) : Base(value), m_name(name) &#123; &#125; const std::string&amp; getName() const &#123; return m_name; &#125; virtual ClassID getClassID() const &#123; return DERIVED; &#125; &#125;; Base* getObject(bool bReturnDerived)&#123; if (bReturnDerived) return new Derived(1, \"Apple\"); else return new Base(2);&#125; int main()&#123; Base *b = getObject(true); if (b-&gt;getClassID() == DERIVED) &#123; // 我们已经证明了b指向一个派生的对象，所以这应该总是成功的 Derived *d = static_cast&lt;Derived*&gt;(b); std::cout &lt;&lt; \"The name of the Derived is: \" &lt;&lt; d-&gt;getName() &lt;&lt; '\\n'; &#125; delete b; return 0;&#125;最好还是使用dynamic_cast但是，如果您要经历实现这一点的所有困难( 并且要为调用虚函数和处理结果付出代价 )，那么最好只使用dynamic_cast。dynamic_cast和引用尽管上面所有的例子都显示了指针的动态转换(这更常见)，dynamic_cast也可以与引用一起使用。这类似于dynamic_cast处理指针的方式。123456789101112131415161718192021222324252627282930313233343536373839#include &lt;string&gt;#include &lt;iostream&gt;class Base&#123;protected: int m_value; public: Base(int value) : m_value(value) &#123; &#125; virtual ~Base() &#123;&#125;&#125;;class Derived : public Base&#123;protected: std::string m_name; public: Derived(int value, std::string name) : Base(value), m_name(name) &#123; &#125; const std::string&amp; getName() const &#123; return m_name; &#125;&#125;;int main()&#123; Derived apple(1, \"Apple\"); Base &amp;b = apple; //使用引用而不是指针进行动态转换 // 我们可以通过d访问Derived::getName std::cout &lt;&lt; \"The name of the Derived is: \" &lt;&lt; d.getName() &lt;&lt; '\\n';&#125;因为c++没有“空引用”，dynamic_cast在失败时不能返回空引用。相反，如果引用的dynamic_cast失败，则抛出std::bad_cast类型的异常。我们将在本教程的后面讨论异常。dynamic_cast 与 static_cast 的比较新程序员有时会对何时使用static_cast和dynamic_cast感到困惑。答案很简单:使用static_cast，除非是向下强制转换，在这种情况下，dynamic_cast通常是更好的选择。但是，您还应该考虑完全避免强制转换，只使用虚函数。向下转换vs虚函数有些开发人员认为dynamic_cast是邪恶的，并且是一个糟糕的类设计的象征。相反，这些程序员认为应该使用虚拟函数。一般来说，使用虚函数比向下强制转换更可取。然而，有时向下转换是更好的选择:当您不能修改基类来添加虚函数时(例如，因为基类是标准库的一部分)当您需要访问特定于派生类的内容时(例如，仅存在于派生类中的访问函数)当向基类添加虚函数没有意义时(例如，基类返回的值不合适)。如果您不需要实例化基类，那么使用纯虚函数可能是一种选择。关于dynamic_cast和RTTI的警告运行时类型信息(RTTI)是c++的一个特性，它在运行时公开有关对象数据类型的信息。dynamic_cast利用了这个功能。由于RTTI有相当大的空间性能成本，一些编译器允许您关闭RTTI作为优化。如果这样做，dynamic_cast将无法正常工作。","categories":[],"tags":[]},{"title":"C&C++/对象切片","slug":"C&C++/对象切片","date":"2020-05-15T03:01:20.179Z","updated":"2020-05-15T03:40:47.685Z","comments":true,"path":"archives/c1cd5bf1.html","link":"","permalink":"https://longlongqin.github.io/archives/c1cd5bf1.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/12-8-object-slicing/让我们回到之前看的一个例子:123456789101112131415161718192021222324252627282930313233343536373839class Base&#123;protected: int m_value&#123;&#125;; public: Base(int value) : m_value&#123; value &#125; &#123; &#125; virtual const char* getName() const &#123; return \"Base\"; &#125; int getValue() const &#123; return m_value; &#125;&#125;; class Derived: public Base&#123;public: Derived(int value) : Base&#123; value &#125; &#123; &#125; virtual const char* getName() const &#123; return \"Derived\"; &#125;&#125;; int main()&#123; Derived derived&#123; 5 &#125;; std::cout &lt;&lt; \"derived is a \" &lt;&lt; derived.getName() &lt;&lt; \" and has value \" &lt;&lt; derived.getValue() &lt;&lt; '\\n'; Base &amp;ref&#123; derived &#125;; std::cout &lt;&lt; \"ref is a \" &lt;&lt; ref.getName() &lt;&lt; \" and has value \" &lt;&lt; ref.getValue() &lt;&lt; '\\n'; Base *ptr&#123; &amp;derived &#125;; std::cout &lt;&lt; \"ptr is a \" &lt;&lt; ptr-&gt;getName() &lt;&lt; \" and has value \" &lt;&lt; ptr-&gt;getValue() &lt;&lt; '\\n'; return 0;&#125;在上面的例子中，ref引用和ptr指向derived，它有一个基部分和一个派生部分。因为ref和ptr是Base类型的，ref和ptr只能看到derived的Base部分——derived的derived部分仍然存在，但是不能通过ref或ptr看到。然而，通过使用虚函数，我们可以访问最派生的函数版本。因此，上面的程序打印:123derived is a Derived and has value 5ref is a Derived and has value 5ptr is a Derived and has value 5对象切片但是，如果不设置基引用或指向派生对象的指针，而是简单地将派生对象分配给基对象，会发生什么情况呢?12345678int main()&#123; Derived derived&#123; 5 &#125;; Base base&#123; derived &#125;; // what happens here? std::cout &lt;&lt; \"base is a \" &lt;&lt; base.getName() &lt;&lt; \" and has value \" &lt;&lt; base.getValue() &lt;&lt; '\\n'; return 0;&#125;记住，导函数有基部和导函数部。当我们将派生对象分配给基对象时，只复制派生对象的基部分。派生部分则不是。在上面的示例中，base接收派生的基本部分的副本，但不接收派生部分的副本。这个衍生的部分已经被有效地“切掉”了。因此，将派生类对象 赋值 给基类对象 称为对象切片(或简称为切片)。因为变量base没有派生部分，所以base.getName()解析为base::getName()。上面的例子打印:1base is a Base and has value 5认真使用，切片可以是良性的。然而，如果使用不当，切片可能会以许多不同的方式导致意想不到的结果。让我们来研究一下其中的一些情况：切片和函数现在，你可能觉得上面的例子有点傻。毕竟，为什么要把派生赋给base呢?你可能不会。然而，切片更可能在函数中意外发生。1234void printName(const Base base) // 注意:base是通过值传递的，而不是引用&#123; std::cout &lt;&lt; \"I am a \" &lt;&lt; base.getName() &lt;&lt; '\\n';&#125;这是一个非常简单的函数，带有一个通过值传递的const基对象参数。如果我们这样调用这个函数:1234567int main()&#123; Derived d&#123; 5 &#125;; printName(d); // 糟糕，没有意识到这是 在调用端按值传递的 return 0;&#125;在编写这个程序时，您可能没有注意到base是一个值参数，而不是引用。因此，当调用printName(d)时，我们可能期望base.getName()调用虚拟化函数getName()并打印“I am a Derived”，但实际情况并非如此。相反，派生对象d被切片，只有基部分被复制到基参数中。当base.getName()执行时，即使已经虚拟化了getName()函数，也没有类的派生部分需要解析。因此，这个程序打印:1I am a Base在这种情况下，很明显发生了什么，但是如果您的函数实际上没有打印任何像这样的标识信息，跟踪错误可能会很困难。当然，通过将函数参数设置为引用而不是按值传递，可以很容易地避免这里的切片(这也是为什么按引用传递类而不是按值传递类是一个好主意的另一个原因)。123456789101112131415void printName(const Base &amp;base) // 注意:base现在通过引用传递&#123; std::cout &lt;&lt; \"I am a \" &lt;&lt; base.getName() &lt;&lt; '\\n';&#125; int main()&#123; Derived d&#123; 5 &#125;; printName(d); return 0;&#125;/*结果*/I am a Derived切片 vector然而，新程序员在使用切片时遇到的另一个问题是试图使用std::vector实现多态性。考虑以下程序:1234567891011121314#include &lt;vector&gt; int main()&#123; std::vector&lt;Base&gt; v&#123;&#125;; v.push_back(Base&#123; 5 &#125;); // add a Base object to our vector v.push_back(Derived&#123; 6 &#125;); // add a Derived object to our vector // Print out all of the elements in our vector for (const auto&amp; element : v) std::cout &lt;&lt; \"I am a \" &lt;&lt; element.getName() &lt;&lt; \" with value \" &lt;&lt; element.getValue() &lt;&lt; '\\n'; return 0;&#125;结果：12I am a Base with value 5I am a Base with value 6与前面的示例类似，因为std::vector被声明为Base类型的向量，当派生(6)添加到该向量时，它被切片。修复这个问题有点困难。许多新程序员尝试创建一个std::vector对象的引用，像这样:1std::vector&lt;Base&amp;&gt; v&#123;&#125;;不幸的是，这无法编译。std::vector的元素必须是可赋值的，而引用不能被重新赋值(只能初始化)。解决办法：指针向量解决这个问题的一种方法是创建一个指针向量:12345678910111213141516171819#include &lt;iostream&gt;#include &lt;vector&gt; int main()&#123; std::vector&lt;Base*&gt; v&#123;&#125;; Base b&#123; 5 &#125;; // b和d不能是匿名对象 Derived d&#123; 6 &#125;; v.push_back(&amp;b); // add a Base object to our vector v.push_back(&amp;d); // add a Derived object to our vector // Print out all of the elements in our vector for (const auto* element : v) std::cout &lt;&lt; \"I am a \" &lt;&lt; element-&gt;getName() &lt;&lt; \" with value \" &lt;&lt; element-&gt;getValue() &lt;&lt; '\\n'; return 0;&#125;结果：12I am a Base with value 5I am a Derived with value 6对此有几点评论。首先，nullptr现在是一个有效的选项，这可能是可取的，也可能是不可取的。其次，现在必须处理指针语义，这可能会很麻烦。但好处是，这也允许动态内存分配的可能性，如果您的对象可能超出范围，那么动态内存分配将非常有用。The Frankenobject在上面的例子中，我们已经看到了由于派生类被切割而导致错误结果的情况。现在让我们来看另一种危险的情况，即派生对象仍然存在 !12345678910int main()&#123; Derived d1&#123; 5 &#125;; Derived d2&#123; 6 &#125;; Base &amp;b&#123; d2 &#125;; b = d1; // this line is 有问题 return 0;&#125;函数的前三行非常简单。创建两个派生对象，并设置第二个对象的基引用。第四行是误入歧途的地方：因为b指向d2，我们又把d1赋值给b，你可能会认为结果是d1会被复制到d2中。如果b是一个派生的的话，那它是对的。但是b是一个基类，c++为类提供的操作符=在默认情况下不是虚拟的。因此，只有d1的基部分被复制到d2中。结果，你会发现d2现在有了：基底部分是d1衍生部分是d2。在这个特殊的例子中，这不是问题(因为派生类没有自己的数据)，但是在大多数情况下，您只是创建了一个FrankenobjectFrankenobject：由多个对象的部分组成更糟糕的是，没有简单的方法来防止这种情况的发生 (除了尽可能避免这样的赋值)。小结尽管c++支持通过对象切片将派生对象分配给基对象，但通常情况下，这可能只会造成麻烦，您通常应该尽量避免切片。方法：确保您的函数参数是引用(或指针)，并且在涉及到派生类时尽量避免任何类型的按值传递。","categories":[],"tags":[]},{"title":"C&C++/虚拟基类","slug":"C&C++/虚拟基类","date":"2020-05-15T02:29:34.213Z","updated":"2020-05-15T02:58:37.707Z","comments":true,"path":"archives/f7358229.html","link":"","permalink":"https://longlongqin.github.io/archives/f7358229.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/128-virtual-base-classes/上一章，在11.7 – Multiple inheritance中，我们停止了对“钻石问题”的讨论。在本节中，我们将继续讨论。钻石的问题下面是我们从上节课(和一些构造函数)中得到的例子，演示了菱形问题:12345678910111213141516171819202122232425262728293031323334353637class PoweredDevice&#123;public: PoweredDevice(int power) &#123; cout &lt;&lt; \"PoweredDevice: \" &lt;&lt; power &lt;&lt; '\\n'; &#125;&#125;; class Scanner: public PoweredDevice&#123;public: Scanner(int scanner, int power) : PoweredDevice(power) &#123; cout &lt;&lt; \"Scanner: \" &lt;&lt; scanner &lt;&lt; '\\n'; &#125;&#125;; class Printer: public PoweredDevice&#123;public: Printer(int printer, int power) : PoweredDevice(power) &#123; cout &lt;&lt; \"Printer: \" &lt;&lt; printer &lt;&lt; '\\n'; &#125;&#125;; class Copier: public Scanner, public Printer&#123;public: Copier(int scanner, int printer, int power) : Scanner(scanner, power), Printer(printer, power) &#123; &#125;&#125;;尽管你可能希望得到这样的继承图:如果您要创建一个copy类对象，在默认情况下，您将得到PoweredDevice类的两个副本——一个来自Printer，另一个来自Scanner。它的结构如下:我们可以创建一个简短的例子，将在行动中显示这一点:123456int main()&#123; Copier copier(1, 2, 3); return 0;&#125;这就产生了以下结果:1234PoweredDevice: 3Scanner: 1PoweredDevice: 3Printer: 2如你所见，PoweredDevice构建了两次。虽然这通常是需要的，但有时您可能只希望扫描仪和打印机共享PoweredDevice的一个副本。虚拟基类要共享基类，只需在派生类的继承列表中插入“virtual”关键字即可。这创建了所谓的虚基类，这意味着只有一个基对象。基对象在继承树中的所有对象之间共享，并且只构造一次。下面是一个例子(为了简单，没有构造函数)，展示了如何使用virtual关键字创建一个共享基类:123456789101112131415class PoweredDevice&#123;&#125;; class Scanner: virtual public PoweredDevice&#123;&#125;; class Printer: virtual public PoweredDevice&#123;&#125;; class Copier: public Scanner, public Printer&#123;&#125;;现在，当您创建复印机类对象时，您将仅为每个复印机获得一个PoweredDevice副本，该副本将由扫描仪和打印机共享。然而，这又导致了一个问题:如果扫描仪和打印机共享一个PoweredDevice基类，谁负责创建它?答案是 Copier。Copier 构造函数 负责创建PoweredDevice。因此，这是第一次 允许Copier直接调用 非直的接父类 的构造函数：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt; class PoweredDevice&#123;public: PoweredDevice(int power) &#123; std::cout &lt;&lt; \"PoweredDevice: \" &lt;&lt; power &lt;&lt; '\\n'; &#125;&#125;; class Scanner: virtual public PoweredDevice // 注意:PoweredDevice现在是一个虚拟基类&#123;public: Scanner(int scanner, int power) : PoweredDevice(power) // 创建扫描对象需要这一行，但在本例中忽略了这一行 &#123; std::cout &lt;&lt; \"Scanner: \" &lt;&lt; scanner &lt;&lt; '\\n'; &#125;&#125;; class Printer: virtual public PoweredDevice // 注意:PoweredDevice现在是一个虚拟基类&#123;public: Printer(int printer, int power) : PoweredDevice(power) // 创建扫描对象需要这一行，但在本例中忽略了这一行 &#123; std::cout &lt;&lt; \"Printer: \" &lt;&lt; printer &lt;&lt; '\\n'; &#125;&#125;; class Copier: public Scanner, public Printer&#123;public: Copier(int scanner, int printer, int power) : PoweredDevice(power), // PoweredDevice是在这里构建的 Scanner(scanner, power), Printer(printer, power) &#123; &#125;&#125;;int main()&#123; Copier copier(1, 2, 3); return 0;&#125;结果：123PoweredDevice: 3Scanner: 1Printer: 2如您所见，PoweredDevice只构造一次。有一些细节，如果我们不提，那就是我们的疏忽：首先，虚基类总是在非虚基类之前创建，这确保了所有的基 都在它们的派生类之前创建。其次，注意Scanner 和 Printer的构造函数仍然有对PoweredDevice构造函数的调用。当创建一个copy实例时，这些构造函数调用被简单地忽略，因为copier负责创建PoweredDevice。但是，如果我们要创建一个Scanner或Printer的实例，将使用那些构造函数调用，并应用常规继承规则。第三，如果一个类继承了一个或多个具有虚父类的类，那么最派生的类负责构造虚基类。在本例中，copier继承了Printer和Scanner，它们都有一个PoweredDevice虚拟基类。copier是最派生的类，负责创建PoweredDevice。注意，即使在单个继承情况下也是如此: 如果copy是从Printer单独继承的，而Printer实际上是从PoweredDevice继承的，那么copier仍然负责创建PoweredDevice。第四，所有继承虚基类的类都将有一个虚表 (即使它们通常没有虚表) ，因此它们的大小会增大 一个指针的大小。因为Scanner and Printer 实际上是从PoweredDevice派生出来的，所以Copier将只作为一个PoweredDevice子对象。Scanner and Printer 都需要知道如何找到那个单独的PoweredDevice子对象，这样它们就可以访问它的成员(因为它们毕竟是从它派生出来的)。这通常是通过一些虚表 魔法来完成的(它实际上将每个子类的偏移量存储到PoweredDevice子对象中)。","categories":[],"tags":[]},{"title":"C&C++/纯虚函数、抽象基类、接口类","slug":"C&C++/纯虚函数、抽象基类、接口类","date":"2020-05-15T00:52:29.292Z","updated":"2020-05-15T02:20:05.199Z","comments":true,"path":"archives/82369fbe.html","link":"","permalink":"https://longlongqin.github.io/archives/82369fbe.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/126-pure-virtual-functions-abstract-base-classes-and-interface-classes/纯虚(抽象)函数与 抽象基类Pure virtual functions：纯虚函数到目前为止，我们编写的所有虚函数都有一个主体(定义)。但是，c++允许您创建一种特殊的虚函数，称为纯虚函数(或抽象函数)，它完全没有实体!一个纯虚函数只是作为一个占位符，它将被派生类重新定义。要创建一个纯虚函数，而不是为函数定义一个主体，我们只需将函数赋值为0。1234567891011class Base&#123;public: const char* sayHi() &#123; return \"Hi\"; &#125; // a normal non-virtual function virtual const char* getName() &#123; return \"Base\"; &#125; // a normal virtual function virtual int getValue() = 0; // 纯虚函数 int doSomething() = 0; // 编译错误:无法将非虚函数设置为0&#125;;当我们向类添加一个纯虚函数时，我们实际上是在说，“实现这个函数取决于派生类”。使用纯虚函数有两个主要的结果:首先，任何带有一个或多个纯虚函数的类都变成了一个抽象基类，这意味着它不能被实例化!12345678//考虑一下如果我们可以创建一个Base实例会发生什么:int mian()&#123; Base base; // 我们不能实例化一个抽象基类⭐，但是为了举例说明，假设这是允许的 base.getValue(); // what would this do? return 0;&#125;因为没有getValue()的定义，那么base.getValue()解析成什么呢?其次，任何派生类都必须为这个函数定义一个主体，否则这个派生类也会被认为是一个抽象基类。一个纯虚函数的例子让我们看一个纯虚函数的例子。在前一课中，我们编写了一个简单的动物基类，并从中派生了一个Cat类。这是我们留下的代码:12345678910111213141516171819202122232425262728#include &lt;string&gt;class Animal&#123;protected: std::string m_name; //我们使这个构造函数受保护，因为 //我们不希望人们直接创建动物对象，但是我们仍然希望派生类能够使用它。 Animal(std::string name) : m_name(name) &#123; &#125; public: std::string getName() &#123; return m_name; &#125; virtual const char* speak() &#123; return \"???\"; &#125;&#125;; class Cat: public Animal&#123;public: Cat(std::string name) : Animal(name) &#123; &#125; virtual const char* speak() &#123; return \"Meow\"; &#125;&#125;;我们通过使构造函数受保护来阻止人们分配Animal类型的对象。然而，这样做有两个问题:构造函数仍然可以从派生类中访问，这使得实例化一个Animal对象成为可能。仍然可以创建不重新定义函数speak()的派生类。如：12345678910111213141516171819202122#include &lt;iostream&gt;class Cow: public Animal&#123;public: Cow(std::string name) : Animal(name) &#123; &#125; // We forgot to redefine speak&#125;; int main()&#123; Cow cow(\"Betsy\"); std::cout &lt;&lt; cow.getName() &lt;&lt; \" says \" &lt;&lt; cow.speak() &lt;&lt; '\\n'; return 0;&#125;/*结果*/Betsy says ???发生了什么事? 我们忘记了重新定义函数speak()，因此cow.Speak()解析为Animal.speak()，这不是我们想要的。更好的解决方法是使用纯虚函数:123456789101112131415#include &lt;string&gt;class Animal // 这个动物是一个抽象基类&#123;protected: std::string m_name; public: Animal(std::string name) : m_name(name) &#123; &#125; std::string getName() &#123; return m_name; &#125; virtual const char* speak() = 0; // 注意，speak现在是一个纯虚函数&#125;;这里有几点需要注意。speak()现在是一个纯虚函数。这意味着Animal现在是一个抽象基类，不能被实例化。因此，我们不再需要使构造函数为protected(尽管它不会造成伤害)。其次，因为我们的Cow类派生自Animal，但是我们没有定义Cow::speak()， 所以Cow也是一个抽象基类。现在，当我们试图编译这段代码:12345678910111213141516171819#include &lt;iostream&gt;class Cow: public Animal&#123;public: Cow(std::string name) : Animal(name) &#123; &#125; // We forgot to redefine speak&#125;; int main()&#123; Cow cow(\"Betsy\"); std::cout &lt;&lt; cow.getName() &lt;&lt; \" says \" &lt;&lt; cow.speak() &lt;&lt; '\\n'; return 0;&#125;编译器会给我们一个警告，因为Cow是一个抽象基类，我们不能创建抽象基类的实例:123C:\\Test.cpp(141) : error C2259: 'Cow' : cannot instantiate abstract class due to following members: C:Test.cpp(128) : see declaration of 'Cow'C:\\Test.cpp(141) : warning C4259: 'const char *__thiscall Animal::speak(void)' : pure virtual function was not defined这告诉我们，只有当Cow为speak()提供了一个主体时，我们才能够实例化Cow。修改后的代码：12345678910111213141516171819202122#include &lt;iostream&gt;class Cow: public Animal&#123;public: Cow(std::string name) : Animal(name) &#123; &#125; virtual const char* speak() &#123; return \"Moo\"; &#125;&#125;; int main()&#123; Cow cow(\"Betsy\"); std::cout &lt;&lt; cow.getName() &lt;&lt; \" says \" &lt;&lt; cow.speak() &lt;&lt; '\\n'; return 0;&#125;/*结果*/Betsy says Moo当我们想要将一个函数放入基类中，但只有派生类知道它应该返回什么时，纯虚函数是有用的。纯虚函数使基类无法实例化，派生类被迫在实例化这些函数之前定义它们。这有助于确保派生类不会忘记重新定义基类所期望的函数。带有主体的纯虚函数事实证明，我们可以定义具有肉体的纯虚函数:1234567891011121314151617181920#include &lt;string&gt;class Animal // 这个Animal是一个抽象基类&#123;protected: std::string m_name; public: Animal(std::string name) : m_name(name) &#123; &#125; std::string getName() &#123; return m_name; &#125; virtual const char* speak() = 0; // The = 0 表示这个函数是纯虚函数&#125;; const char* Animal::speak() // 即使它有身体&#123; return \"buzz\";&#125;在这种情况下，speak()仍然被认为是一个纯虚函数(因为“= 0”，即使已经给了它一个主体)，Animal仍然被认为是一个抽象基类(因此不能被实例化)。任何继承自Animal的类都需要为speak()提供自己的定义，否则也会被认为是一个抽象基类。当为纯虚函数提供正文时，必须单独提供正文(不是内联的)。当您希望基类为函数提供默认实现，但仍然强制任何派生类提供它们自己的实现时，此范例非常有用。但是，如果派生类对基类提供的默认实现感到满意，它可以直接调用基类实现。例如：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;string&gt;#include &lt;iostream&gt; class Animal // This Animal is an abstract base class&#123;protected: std::string m_name; public: Animal(std::string name) : m_name(name) &#123; &#125; std::string getName() &#123; return m_name; &#125; virtual const char* speak() = 0; // note that speak is a pure virtual function&#125;; const char* Animal::speak()&#123; return \"buzz\"; // some default implementation&#125; class Dragonfly: public Animal&#123; public: Dragonfly(std::string name) : Animal(name) &#123; &#125; virtual const char* speak() //⭐ 个类不再是抽象的，因为我们定义了这个函数 &#123; return Animal::speak(); // 使用Animal的默认实现i &#125;&#125;; int main()&#123; Dragonfly dfly(\"Sally\"); std::cout &lt;&lt; dfly.getName() &lt;&lt; \" says \" &lt;&lt; dfly.speak() &lt;&lt; '\\n'; return 0;&#125;/*结果*/Sally says buzz这种功能并不常用。接口类Interface classes ： 接口类接口类是一个没有成员变量的类，其中所有的函数都是纯虚的!换句话说，该类纯粹是一个定义，没有实际的实现。当您想定义派生类必须实现的功能，但将派生类如何实现该功能的细节完全留给派生类时，接口是有用的。接口类通常以I开头。下面是一个示例接口类:123456789101112class IerrorLog&#123;public: virtual bool openLog(const char *filename) = 0; virtual bool closeLog() = 0; virtual bool writeError(const char *errorMessage) = 0; // 创建一个虚析构函数，假设我们删除一个IErrorLog指针， // 这样就可以调用正确的派生析构函数 virtual ~IErrorLog() &#123;&#125; &#125;;从IErrorLog继承的任何类必须为所有三个函数提供实现，以便实例化。您可以派生一个名为FileErrorLog的类，其中：openLog()打开磁盘上的文件，closeLog()关闭文件，writeError()将消息写入文件。您可以派生另一个名为ScreenErrorLog的类，其中openLog()和closeLog()什么都不做，writeError()在屏幕上的弹出消息框中打印消息。现在，假设您需要编写一些使用错误日志的代码。如果您编写的代码中直接包含了FileErrorLog或ScreenErrorLog，那么您实际上是在使用这种错误日志(至少在不重新编写程序的情况下)。例如，下面的函数有效地迫使mySqrt()的调用者使用FileErrorLog，这可能是他们想要的，也可能不是。1234567891011#include &lt;cmath&gt; // for sqrt()double mySqrt(double value, FileErrorLog &amp;log)&#123; if (value &lt; 0.0) &#123; log.writeError(\"Tried to take square root of value less than 0\"); return 0.0; &#125; else return sqrt(value);&#125;实现这个函数的一个更好的方法是使用IErrorLog:1234567891011#include &lt;cmath&gt; // for sqrt()double mySqrt(double value, IErrorLog &amp;log)&#123; if (value &lt; 0.0) &#123; log.writeError(\"Tried to take square root of value less than 0\"); return 0.0; &#125; else return sqrt(value);&#125;现在，调用者可以传入任何符合IErrorLog接口的类。⭐如果他们希望错误转移到文件中，他们可以传入FileErrorLog的实例。如果他们想让它显示在屏幕上，他们可以传入一个ScreenErrorLog实例。或者，如果他们想做一些您甚至没有想到的事情，比如在出现错误时向某人发送电子邮件，他们可以从IErrorLog(例如EmailErrorLog)派生一个新类并使用它的一个实例!通过使用IErrorLog，您的函数变得更加独立和灵活。不要忘记为您的接口类包含一个虚析构函数，以便在删除指向接口的指针时调用适当的派生析构函数。纯虚函数与虚表抽象类仍然有虚表，因为如果有指向抽象类的指针或引用，仍然可以使用虚表。纯虚函数的虚表条目通常要么包含一个空指针，要么指向一个泛型函数，如果没有提供覆盖，这个泛型函数会输出一个错误(有时这个函数被命名为_purecall)。","categories":[],"tags":[]},{"title":"C&C++/虚表及隐藏的指针(__vptr)","slug":"C&C++/虚表及隐藏的指针(__vptr)","date":"2020-05-14T14:37:27.654Z","updated":"2020-05-14T15:40:06.249Z","comments":true,"path":"archives/71c91a8.html","link":"","permalink":"https://longlongqin.github.io/archives/71c91a8.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/125-the-virtual-table/虚表为了实现虚函数，c++使用了一种特殊的后期绑定形式，称为虚表。虚表是用于以 动态/后期绑定方式 解析函数调用 的函数的查找表。虚表有时使用其他名称：虚函数表、调度表、….“vtable”, “virtual function table”, “virtual method table”, or “dispatch table”.虚表实际上非常简单，虽然用文字描述有点复杂。首先，每个使用虚函数的类 (或派生自使用虚函数的类) 都有自己的虚表。这个表只是编译器在编译时设置的一个静态数组。虚表包含一个条目，记录了：每个虚函数可以被调用的类的对象。这个表中的每个条目都是一个函数指针，指向该类可访问的派生程度最高的函数。其次，编译器还向基类添加了一个隐藏指针，我们称之为 *__vptr。*__vptr在创建类实例时设置(自动)，以便它指向该类的虚表。this指针，它实际上是编译器用来解析自引用的*函数参数***__vptr：是一个真实的指针，它使分配的每个类对象的大小增加一个指针。这也意味着*__vptr是由派生类继承的，这一点很重要。到目前为止，你可能对这些东西是如何组合在一起的感到困惑，所以让我们看一个简单的例子:123456789101112131415161718class Base&#123;public: virtual void function1() &#123;&#125;; virtual void function2() &#123;&#125;;&#125;; class D1: public Base&#123;public: virtual void function1() &#123;&#125;;&#125;; class D2: public Base&#123;public: virtual void function2() &#123;&#125;;&#125;;因为这里有3个类，编译器将设置3个虚表: 一个用于Base，一个用于D1，一个用于D2。隐藏指针编译器还向使用虚函数的最基类添加一个隐藏指针。虽然编译器会自动这样做，我们会把它放在下一个例子，只是为了显示它是在哪里添加的:12345678910111213141516171819class Base&#123;public: FunctionPointer *__vptr; virtual void function1() &#123;&#125;; virtual void function2() &#123;&#125;;&#125;; class D1: public Base&#123;public: virtual void function1() &#123;&#125;;&#125;; class D2: public Base&#123;public: virtual void function2() &#123;&#125;;&#125;;当创建一个类对象时，*__vptr被设置为指向该类的虚表。例如：当创建了一个Base类型的对象时，*__vptr被设置为指向Base的虚表。当构造D1或D2类型的对象时，*__vptr被设置为分别指向D1或D2的虚表。虚表如何生成的？现在，让我们讨论一下这些虚拟表是如何填写的。因为这里只有两个虚函数，每个虚表将有两个条目(一个用于function1()，另一个用于function2())。请记住，当这些虚表被填满时，每个条目都填满了该类类型的对象可以调用的派生程度最高的函数。基类对象的虚表很简单。Base类型的对象只能访问Base的成员。Base不能访问D1或D2函数。因此，function1的入口指向Base::function1()，而function2的入口指向Base::function2()。D1的虚表稍微复杂一些。类型D1的对象可以访问D1和Base的成员。但是，D1已经覆盖了function1()，使得D1::function1()比Base::function1()更派生。因此，function1的条目指向D1::function1()。D1没有覆盖function2()，因此function2的条目将指向Base::function2()。D2的虚表类似于D1，除了function1的条目指向Base::function1()，而function2的条目指向D2::function2()。就像下面这个图显示的一样：尽管这个图看起来有点疯狂，但它确实非常简单: 每个类中的* vptr指向该类的虚表。 虚表中的条目指向该类的函数对象的派生程度最高的版本。通过例子理解虚表与隐藏指针考虑一下当我们创建一个D1类型的对象时会发生什么:1234int main()&#123; D1 d1;&#125;因为d1是D1对象，d1将它的*__vptr 指向为d1虚表。现在，让我们设置一个指向D1的基指针:1234567int main()&#123; D1 d1; Base *dPtr = &amp;d1; return 0;&#125;注意，因为dPtr是一个基指针，所以它只指向d1的基部分。但是，还要注意，*__vptr位于类的基部分，因此dPtr可以访问这个指针。最后，请注意dPtr-&gt;__vptr指向D1虚表! 因此，即使dPtr的类型是Base，它仍然可以访问D1的虚拟表(通过 __vptr)。那么，当我们尝试调用dPtr-&gt;function1()时会发生什么呢?12345678int main()&#123; D1 d1; Base *dPtr = &amp;d1; dPtr-&gt;function1(); return 0;&#125;首先，程序认识到function1()是一个虚函数。其次，程序使用dPtr-&gt; vptr来访问D1的虚拟表。第三，查找function1()调用D1的虚表的版本。这已经设置为D1::function1()。因此，dPtr-&gt;function1()解析为D1::function1()!通过使用这些表，编译器和程序能够确保函数调用解析到适当的虚函数，即使您只使用一个指针或对基类的引用!调用虚函数比调用非虚函数慢1、调用虚函数比调用非虚函数慢，原因如下:首先，我们必须使用*__vptr来访问适当的虚表。其次，我们必须为虚表建立索引，以找到要调用的正确函数。只有这样我们才能调用这个函数。开始调用函数因此，我们必须执行3个操作来找到要调用的函数，而不是对普通的间接函数调用执行2个操作，或者对直接函数调用执行1个操作。然而，对于现代计算机来说，这些额外的时间通常是微不足道的。2、同样需要提醒的是，任何使用虚函数的类都有一个__vptr，因此它使分配的每个类对象的大小增加一个指针。虚拟函数非常强大，但是它们也有性能代价。","categories":[],"tags":[]},{"title":"C&C++/早起绑定与后期绑定","slug":"C&C++/早起绑定与后期绑定","date":"2020-05-14T14:14:36.723Z","updated":"2020-05-14T14:33:37.873Z","comments":true,"path":"archives/bc3a234a.html","link":"","permalink":"https://longlongqin.github.io/archives/bc3a234a.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/124-early-binding-and-late-binding/C++程序执行时CPU的工作在这节课和下节课中，我们将进一步了解虚拟函数是如何实现的。虽然这些信息对于有效地使用虚拟函数并不是严格必需的，但是它很有趣。不过，你可以把这两部分都当作可选阅读。当一个c++程序被执行时，它按顺序执行，从main()的顶部开始。当遇到函数调用时，执行点会跳转到被调用函数的开头。CPU是如何做到这一点的?编译程序时，编译器将c++程序中的每条语句转换成一行或多行机器语言。机器语言的每一行都有它自己的唯一顺序地址。这对于函数来说没有什么不同——当遇到一个函数时，它被转换成机器语言并给出下一个可用的地址。因此，每个函数都以唯一的地址结束。绑定绑定是指用于将标识符 (如变量和函数名) 转换为地址的过程。虽然绑定同时用于变量和函数，但在本节课中，我们将重点讨论函数绑定。早期绑定早期绑定（也称为静态绑定）：表示编译器(或链接器) 能够直接将 标识符名称(如函数或变量名) 与 机器地址 相关联。因此，当编译器(或链接器)遇到一个函数调用时，它会用一条机器语言指令替换该函数调用，该指令告诉CPU跳转到函数的地址。编译器遇到的大多数函数调用都是直接的函数调用。直接函数调用是直接调用函数的语句。例如:123456789101112#include &lt;iostream&gt; void printValue(int value)&#123; std::cout &lt;&lt; value;&#125; int main()&#123; printValue(5); // 这是一个直接的函数调用 return 0;&#125;直接的函数调用可以使用称为早期绑定的进程来解决。让我们看看一个使用早期绑定的简单计算器程序:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt; int add(int x, int y)&#123; return x + y;&#125; int subtract(int x, int y)&#123; return x - y;&#125; int multiply(int x, int y)&#123; return x * y;&#125; int main()&#123; int x; std::cout &lt;&lt; \"Enter a number: \"; std::cin &gt;&gt; x; int y; std::cout &lt;&lt; \"Enter another number: \"; std::cin &gt;&gt; y; int op; do &#123; std::cout &lt;&lt; \"Enter an operation (0=add, 1=subtract, 2=multiply): \"; std::cin &gt;&gt; op; &#125; while (op &lt; 0 || op &gt; 2); int result = 0; switch (op) &#123; // 直接使用早期绑定调用目标函数 case 0: result = add(x, y); break; case 1: result = subtract(x, y); break; case 2: result = multiply(x, y); break; &#125; std::cout &lt;&lt; \"The answer is: \" &lt;&lt; result &lt;&lt; std::endl; return 0;&#125;因为add()、subtract()和multiply()都是直接的函数调用，编译器将使用早期绑定来解析add()、subtract()和multiply()函数调用。编译器将用一条机器语言指令替换add()函数调用，这条指令告诉CPU跳转到add()函数的地址。对于subtract() 和 multiply()同样适用。后期绑定在某些程序中，直到运行时(程序运行时)才知道将调用哪个函数。这称为后期绑定(或动态绑定)。在c++中，获得后期绑定的一种方法是使用函数指针。简单回顾一下函数指针，函数指针 是一种指向函数而不是变量的指针。函数指针指向的函数 可以使用指针上的 函数调用操作符(())来调用。例如，下面的代码调用add()函数:123456789101112131415#include &lt;iostream&gt; int add(int x, int y)&#123; return x + y;&#125; int main()&#123; // 创建一个函数指针，使它指向 add函数 int (*pFcn)(int, int) = add; std::cout &lt;&lt; pFcn(5, 3) &lt;&lt; std::endl; // add 5 + 3 return 0;&#125;通过函数指针调用函数也称为间接函数调用。下面的计算器程序在功能上与上面的计算器例子相同，除了它使用了一个函数指针而不是直接的函数调用:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt; int add(int x, int y)&#123; return x + y;&#125; int subtract(int x, int y)&#123; return x - y;&#125; int multiply(int x, int y)&#123; return x * y;&#125; int main()&#123; int x; std::cout &lt;&lt; \"Enter a number: \"; std::cin &gt;&gt; x; int y; std::cout &lt;&lt; \"Enter another number: \"; std::cin &gt;&gt; y; int op; do &#123; std::cout &lt;&lt; \"Enter an operation (0=add, 1=subtract, 2=multiply): \"; std::cin &gt;&gt; op; &#125; while (op &lt; 0 || op &gt; 2); // 创建一个名为pFcn的函数指针(是的，语法很难看) int (*pFcn)(int, int) = nullptr; // 设置pFcn指向用户选择的函数 switch (op) &#123; case 0: pFcn = add; break; case 1: pFcn = subtract; break; case 2: pFcn = multiply; break; &#125; // 以x和y作为参数，调用pFcn指向的函数 // 这使用了后期绑定 std::cout &lt;&lt; \"The answer is: \" &lt;&lt; pFcn(x, y) &lt;&lt; std::endl; return 0;&#125;在本例中，我们没有直接调用add()、subtract()或multiply()函数，而是将pFcn设置为指向我们希望调用的函数。然后通过指针调用函数。编译器无法使用早期绑定来解析调用pFcn(x, y)的函数，因为它无法判断在编译时pFcn将指向哪个函数!对比早期绑定、后期绑定后期绑定的效率稍低一些，因为它涉及额外的间接级别。使用后期绑定，程序必须读取指针中保存的地址，然后跳转到该地址。这涉及一个额外的步骤，使它稍微慢一些。但是，后期绑定的优点是它比早期绑定更灵活，因为直到运行时才需要决定调用哪个函数。通过早期绑定，CPU可以直接跳转到函数的地址。","categories":[],"tags":[]},{"title":"C&C++/虚拟析构函数","slug":"C&C++/虚拟析构函数","date":"2020-05-14T09:53:44.600Z","updated":"2020-05-14T14:13:05.368Z","comments":true,"path":"archives/6a3f4577.html","link":"","permalink":"https://longlongqin.github.io/archives/6a3f4577.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/123-virtual-destructors-virtual-assignment-and-overriding-virtualization/虚拟虚构函数尽管c++为您的类提供了一个默认的析构函数(如果您自己不提供的话)，但有时您会希望提供自己的析构函数(特别是当类需要释放内存时)。如果要处理继承，应该始终将析构函数设为虚。当父类的析构函数是非virtual考虑下面的例子:12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;class Base&#123;public: ~Base() // note: not virtual &#123; std::cout &lt;&lt; \"Calling ~Base()\\n\"; &#125;&#125;; class Derived: public Base&#123;private: int* m_array; public: Derived(int length) &#123; m_array = new int[length]; &#125; ~Derived() // note: not virtual (your compiler may warn you about this) &#123; std::cout &lt;&lt; \"Calling ~Derived()\\n\"; delete[] m_array; &#125;&#125;; int main()&#123; Derived *derived &#123; new Derived(5) &#125;; Base *base &#123; derived &#125;; delete base; return 0;&#125;因为base是一个基指针，所以在删除base时，程序会查看基析构函数是否是虚的。它不是，所以它假设它只需要调用基析构函数。我们可以从上面的例子中看出这一点:1Calling ~Base()当父类的析构函数是virtual但是，我们确实希望delete函数调用 Derived的析构函数(它将依次调用Base的析构函数)，否则m_array将不会被删除。我们通过使基类的析构函数为虚:12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;class Base&#123;public: virtual ~Base() // note: virtual &#123; std::cout &lt;&lt; \"Calling ~Base()\\n\"; &#125;&#125;; class Derived: public Base&#123;private: int* m_array; public: Derived(int length) &#123; m_array = new int[length]; &#125; virtual ~Derived() // note: virtual &#123; std::cout &lt;&lt; \"Calling ~Derived()\\n\"; delete[] m_array; &#125;&#125;; int main()&#123; Derived *derived &#123; new Derived(5) &#125;; Base *base &#123; derived &#125;; delete base; return 0;&#125;结果：12Calling ~Derived()Calling ~Base()无论何时处理继承，都应该显式的使析构函数为虚函数与普通的虚成员函数一样，如果基类函数是虚的，则所有派生重写都将被视为虚的，而不管它们是否被指定为virtual。没有必要创建一个空的派生类析构函数来将它标记为虚的。虚拟分配可以使赋值运算符为virtual。然而，与析构函数的情况不同，虚拟化总是一个好主意，虚拟化赋值操作符实际上打开了一个充满蠕虫的包，并进入了本教程范围之外的一些高级主题。因此，为了简单起见，我们建议您暂时不要使用虚拟任务。忽视虚拟化很少会忽略函数的虚拟化。例如，考虑以下代码:1234567891011class Base&#123;public: virtual const char* getName() &#123; return \"Base\"; &#125;&#125;; class Derived: public Base&#123;public: virtual const char* getName() &#123; return \"Derived\"; &#125;&#125;;在某些情况下，您可能需要一个指向派生对象的基指针来调用Base::getName()，而不是Derived::getName()。要做到这一点，只需使用范围解析操作符:1234567891011#include &lt;iostream&gt;int main()&#123; Derived derived; Base &amp;base &#123; derived &#125;; //调用Base::GetName()而不是虚拟化的Derived::GetName() std::cout &lt;&lt; base.Base::getName() &lt;&lt; '\\n'; return 0;&#125;你可能不会经常用到它，但知道它至少是可能的是件好事。我们应该让所有析构函数都是虚的吗?这是新程序员常问的问题。如上例所述，如果基类析构函数没有标记为虚函数，那么如果程序员稍后删除指向派生对象的基类指针，程序就有内存泄漏的风险。避免这种情况的一种方法是将所有析构函数标记为虚函数。但是你应该吗?很容易说yes，这样您以后就可以将任何类用作基类——但是这样做会带来性能损失(向您的类的每个实例添加一个虚指针)。所以你必须平衡成本和你的意图。","categories":[],"tags":[]},{"title":"C&C++/说明符：override、final 及 协变返回类型","slug":"C&C++/说明符：override、final 及 协变返回类型","date":"2020-05-14T09:00:13.877Z","updated":"2020-05-14T09:51:37.263Z","comments":true,"path":"archives/f30af5b2.html","link":"","permalink":"https://longlongqin.github.io/archives/f30af5b2.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/12-2a-the-override-and-final-specifiers-and-covariant-return-types/为了解决继承的一些常见问题，c++ 11在c++中添加了两个特殊的标识符:override和 final。注意，这些标识符不是关键字——它们是在特定上下文中具有特殊意义的普通标识符。虽然final并不是经常使用，但是override是一个非常好的补充，您应该经常使用它。在这节课中，我们将看一下这两种情况，以及虚函数重写 返回类型必须匹配的规则的一个例外。override说明符正如我们在前一课中提到的，派生类虚函数只有在其签名和返回类型完全匹配时才被认为是重写。这可能会导致无意的问题：原本打算覆盖的函数实际上并不是这样。1234567891011121314151617181920212223242526class A&#123;public: virtual const char* getName1(int x) &#123; return \"A\"; &#125; virtual const char* getName2(int x) &#123; return \"A\"; &#125;&#125;; class B : public A&#123;public: virtual const char* getName1(short int x) &#123; return \"B\"; &#125; // note: parameter is a short int virtual const char* getName2(int x) const &#123; return \"B\"; &#125; // note: function is const&#125;; int main()&#123; B b; A &amp;rBase = b; std::cout &lt;&lt; rBase.getName1(1) &lt;&lt; '\\n'; std::cout &lt;&lt; rBase.getName2(2) &lt;&lt; '\\n'; return 0;&#125;/*结果*/AA因为rBase是A 引用对B对象的引用，所以这里的目的是使用虚函数来访问B::getName1()和B::getName2()。但是，因为B::getName1()接受一个不同的参数(一个短整型而不是一个整型)，所以它不被认为是对a::getName1()的覆盖。更狡猾的是，因为B::getName2()是const，而A::getName2()不是，B::getName2()不被认为是对A::getName2()的覆盖。在这个特殊的例子中，因为A和B只是打印它们的名字，很容易看出我们把重写搞砸了，并且调用了错误的虚函数。但是，在更复杂的程序中，函数有未打印的行为或返回值，这样的问题很难调试。为了帮助解决函数的重写问题，c++ 11引入了重写说明符(override specifier)。重写说明符可以应用于任何重写函数，方法是将说明符放在const要去的相同位置。如果函数没有覆盖基类函数(或应用于非虚函数)，编译器会将该函数标记为错误。1234567891011121314151617181920212223class A&#123;public: virtual const char* getName1(int x) &#123; return \"A\"; &#125; virtual const char* getName2(int x) &#123; return \"A\"; &#125; virtual const char* getName3(int x) &#123; return \"A\"; &#125;&#125;; class B : public A&#123;public: //编译错误，函数不是覆盖(因为函数的形参与父类中的不一样) virtual const char* getName1(short int x) override &#123; return \"B\"; &#125; //编译错误，函数不是覆盖(因为这个函数与父类中相应的函数不能完全平匹配，它多了一个 const) virtual const char* getName2(int x) const override &#123; return \"B\"; &#125; //好的，该函数是重写A::getName3(int) virtual const char* getName3(int x) override &#123; return \"B\"; &#125;&#125;;int main()&#123; return 0;&#125;上面的程序产生了两个编译错误:一个用于B::getName1()，另一个用于B::getName2()，因为它们都没有覆盖先前的函数。而B::getName3()会覆盖A::getName3()，因此不会为该行产生错误。使用override说明符不会导致性能损失使用覆盖说明符不会导致性能损失，而且它有助于避免意外错误。因此，我们强烈建议在您编写的每个虚函数重写中使用它，以确保您确实重写了您认为已经重写的函数。final说明符在某些情况下，您可能不希望别人能够重写一个虚函数，或者从一个类继承。final说明符 可以用来告诉编译器强制执行它。如果用户试图覆盖已指定为final的函数或类，编译器将给出一个编译错误。限制用户重写在我们想要限制用户重写函数的情况下，最终说明符( final specifier) 的位置与override specifier的位置相同，就像这样:123456789101112131415161718class A&#123;public: virtual const char* getName() &#123; return \"A\"; &#125;&#125;; class B : public A&#123;public: // 注意在后面的行中使用final说明符——这使得这个函数不再是可覆盖的 virtual const char* getName() override final &#123; return \"B\"; &#125; // okay, overrides A::getName()&#125;; class C : public B&#123;public: virtual const char* getName() override &#123; return \"C\"; &#125; // compile error: overrides B::getName(), which is final&#125;;在上面的代码中，B::getName()覆盖了A::getName()，这是可以的。但是B::getName()有final 的说明符，这意味着对该函数的任何进一步重写都应该被认为是一个错误。确实，C::getName()试图覆盖B::getName() (这里的override说明符不相关，只是为了更好的实践)，所以编译器会给出一个编译错误。限制从该类继承在我们想要防止从类继承的情况下，最后的说明符在类名后面应用:1234567891011121314151617class A&#123;public: virtual const char* getName() &#123; return \"A\"; &#125;&#125;; class B final : public A // 注意这里的 final说明符的使用&#123;public: virtual const char* getName() override &#123; return \"B\"; &#125;&#125;; class C : public B //⭐ compile error: cannot inherit from final class&#123;public: virtual const char* getName() override &#123; return \"C\"; &#125;&#125;;在上面的例子中，类B被声明为final。因此，当C试图从B继承时，编译器会给出一个编译错误。协变返回类型在一种特殊情况下，派生类虚函数重写 可能具有与基类不同的返回类型，但仍然被认为是匹配重写。如果虚函数的返回类型是指针或对类的引用，则重写函数可以返回指针或对派生类的引用。这些被称为协变返回类型。这里有一个例子:12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt; class Base&#123;public: // 这个版本的getThis()返回一个指向基类的指针 virtual Base* getThis() &#123; std::cout &lt;&lt; \"called Base::getThis()\\n\"; return this; &#125; void printType() &#123; std::cout &lt;&lt; \"returned a Base\\n\"; &#125;&#125;; class Derived : public Base&#123;public: //通常，重写函数必须返回与基函数类型相同的对象 // 但是，因为Derived是从Base派生的，所以可以返回Derived*而不是Base* virtual Derived* getThis() &#123; std::cout &lt;&lt; \"called Derived::getThis()\\n\"; return this; &#125; void printType() &#123; std::cout &lt;&lt; \"returned a Derived\\n\"; &#125;&#125;; int main()&#123; Derived d; Base *b = &amp;d; d.getThis()-&gt;printType(); // 调用Derived::getThis()，返回Derived*，再调用Derived::printType b-&gt;getThis()-&gt;printType(); //调用Derived::getThis(), 返回Base*, 再调用 Base::printType return 0;&#125;/*结果*/called Derived::getThis()returned a Derivedcalled Derived::getThis()returned a Base注意，一些较老的编译器(例如Visual Studio 6)不支持协变返回类型。关于协变返回类型有一个有趣的注意: c++不能动态选择类型，所以您总是会得到与所调用函数的基版本相匹配的类型。在上面的例子中，我们首先调用d.getThis()。由于d是派生的，因此调用了Derived::getThis()，它返回一个Derived*。然后使用这个Derived* 调用非虚函数Derived::printType()。有趣的情况是： 然后调用b-&gt;getThis()。变量b是一个指向派生对象的Base指针。Base::getThis()是虚函数，因此调用了Derived::getThis()。虽然Derived::getThis()返回一个Derived*，因为函数的基版本返回一个Base*，返回的Derived*向上转换为Base*。因此，调用Base::printType()。","categories":[],"tags":[]},{"title":"C&C++/虚函数和多态性","slug":"C&C++/虚函数和多态性","date":"2020-05-14T02:53:56.184Z","updated":"2020-05-14T08:40:51.437Z","comments":true,"path":"archives/aba94da5.html","link":"","permalink":"https://longlongqin.github.io/archives/aba94da5.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/122-virtual-functions/虚函数可用于解决的问题，详情请看：在前面关于pointers and references to the base class of derived objects中，我们看了一些例子，其中使用基类的指针或引用有可能简化代码。但是，在每种情况下，我们都会遇到这样的问题: 基指针或引用只能调用函数的基版本，而不能调用派生版本。下面是这种行为的一个简单例子:1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;string_view&gt; class Base&#123;public: std::string_view getName() const &#123; return \"Base\"; &#125;&#125;; class Derived: public Base&#123;public: std::string_view getName() const &#123; return \"Derived\"; &#125;&#125;; int main()&#123; Derived derived; Base &amp;rBase&#123; derived &#125;; std::cout &lt;&lt; \"rBase is a \" &lt;&lt; rBase.getName() &lt;&lt; '\\n'; return 0;&#125;在这节课中，我们将展示如何使用虚函数来解决这个问题。虚函数和多态性虚函数是一种特殊类型的函数，当调用虚函数时，解析为存在于基类和派生类之间的函数的最派生版本。这种能力称为多态性。例如，A继承于B，B继承于C。如果从类A中调用一个虚函数，那么该函数会解析为离A最近的虚函数。如果派生函数具有相同的签名 (名称、参数类型以及是否为const)并返回类型作为该函数的基本版本，则将该函数视为匹配。这样的函数称为覆盖。第一个例子：要使函数成为虚函数，只需将“virtual”关键字放在函数声明之前。1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string_view&gt; class Base&#123;public: virtual std::string_view getName() const &#123; return \"Base\"; &#125; // note addition of virtual keyword&#125;; class Derived: public Base&#123;public: virtual std::string_view getName() const &#123; return \"Derived\"; &#125;&#125;; int main()&#123; Derived derived; Base &amp;rBase&#123; derived &#125;; std::cout &lt;&lt; \"rBase is a \" &lt;&lt; rBase.getName() &lt;&lt; '\\n'; return 0;&#125;/*结果*/rBase is a Derived因为rBase是对派生对象的基部分的引用，所以在计算rBase.getName()时，它通常会解析为Base::getName()。但是，Base::getName()是虚的，它告诉程序去查看在Base和派生之间是否还有其他派生版本的函数可用。在本例中，它将解析为 Derived::getName()!本例中，引用的对象derived是 Derived类，使用哪个虚函数？ 我们就从Derived类开始 在这个继承树形层级结构中，找到离Derived类最近的那个虚函数。—在这个例子中就是Derived类中的那个虚函数版本（因为它离Derived类最近呀。）第二个例子：1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;string_view&gt; class A&#123;public: virtual std::string_view getName() const &#123; return \"A\"; &#125;&#125;; class B: public A&#123;public: virtual std::string_view getName() const &#123; return \"B\"; &#125;&#125;; class C: public B&#123;public: virtual std::string_view getName() const &#123; return \"C\"; &#125;&#125;; class D: public C&#123;public: virtual std::string_view getName() const &#123; return \"D\"; &#125;&#125;; int main()&#123; C c; A &amp;rBase&#123; c &#125;; std::cout &lt;&lt; \"rBase is a \" &lt;&lt; rBase.getName() &lt;&lt; '\\n'; return 0;&#125;/*你认为这个程序会输出什么?*/rBase is a C：让我们看看它是如何工作的。首先，我们实例化一个C类对象。rBase是一个引用，我们将其设置为引用C对象的一部分 的 A。最后，我们调用rBase.getName()。getName()的计算结果是A::getName()。但是，A::getName() 是虚的，因此编译器将调用A和C之间最派生的匹配。在本例中，就是C::getName()。注意，它不会调用D::getName()，因为我们的原始对象是C，而不是D，所以只考虑A和C之间的函数。使用virtual关键字如果一个函数被标记为virtual，那么所有匹配的覆盖也被认为是虚函数，即使它们没有显式地标记为虚函数。也就是说，如果父类A的某个函数被标记为virtual，以A为基类的派生类中的 相匹配的该函数的覆盖，就算不显式的标记该函数为virtual，它仍然是一个虚函数。如：12345678910111213class Base&#123;public: //父类中该函数被标记为 virtual virtual std::string_view getName() const &#123; return \"Base\"; &#125;&#125;;class Derived : public Base&#123;public: //该派生类 对该函数的覆盖 没有显式的标记它为 virtual，但它仍然是虚函数 std::string_view getName() const &#123; return \"Derived\"; &#125;&#125;;但是，在派生函数上使用关键字virtual并没有什么害处，它可以提醒您，该函数是一个虚函数，而不是一个普通的函数。因此，在派生类中对虚拟化函数使用virtual关键字通常是一个好主意，尽管这并不是严格必需的。虚函数的返回类型在正常情况下，虚函数的返回类型 及 其覆盖 必须匹配。考虑下面的例子:1234567891011class Base&#123;public: virtual int getValue() const &#123; return 5; &#125; //int&#125;; class Derived: public Base&#123;public: virtual double getValue() const &#123; return 6.78; &#125; //double&#125;;在这种情况下，Derived::getValue() 不被认为是Base::getValue()的匹配覆盖 (它被认为是一个完全独立的函数)。因为Derived::getValue()与Base::getValue()的返回类型不一样：一个为int，一个为double不要从构造函数或析构函数调用虚函数这是另一个陷阱，经常抓住不知情的新程序员。不应该从构造函数或析构函数调用虚函数。为什么?请记住，在创建派生类时，首先构造基部分。如果从基类构造函数调用虚函数，但类的派生部分还没有创建，它将无法调用函数的派生版本，因为派生函数没有要处理的派生对象。在C++中，它将调用基类版本。析构函数也存在类似的问题。如果在基类析构函数中调用虚函数，它将始终解析为函数的基类版本，因为类的派生部分已经被销毁。规则:永远不要从构造函数或析构函数调用虚函数虚函数的缺点既然大多数情况下你希望函数是虚的，为什么不让所有的函数都是虚的呢?答案是：因为它的效率很低——解析一个虚函数调用要比解析一个常规函数调用花费更长的时间。此外，编译器还必须为每个具有一个或多个虚函数的类对象分配一个额外的指针。我们将在本章以后的课程中更多地讨论这个问题。——补充——-多态性(polymorphism)可以简单地概括为“一个接口，多种方法”，它是面向对象编程领域的核心概念。多态性指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。C++支持两种多态性：编译时多态性，运行时多态性。编译时多态性（静态多态）：通过重载函数实现：先期联编 early binding运行时多态性（动态多态）：通过虚函数实现 ：滞后联编 late bindingC++运行时多态性是通过虚函数来实现的，虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖(Override)，或者称为重写。多态与非多态的实质区别就是函数地址是早绑定还是晚绑定。如果函数的调用，在编译器编译期间就可以确定函数的调用地址，并生产代码，是静态的，就是说地址是早绑定的。而如果函数调用的地址不能在编译器期间确定，需要在运行时才确定，这就属于晚绑定。多态的目的：封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了“接口重用”。也即，不论传递过来的究竟是类的哪个对象，函数都能够通过同一个接口调用到适应各自对象的实现方法。多态最常见的用法就是声明基类类型的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法。如果没有使用虚函数的话，即没有利用C++多态性，则利用基类指针调用相应的函数的时候，将总被限制在基类函数本身，而无法调用到子类中被重写过的函数。因为没有多态性，函数调用的地址将是固定的，因此将始终调用到同一个函数，这就无法实现“一个接口，多种方法”的目的了。需要注意：只有类的成员函数才能声明为虚函数，虚函数仅适用于有继承关系的类对象。普通函数不能声明为虚函数。静态成员函数不能是虚函数，因为静态成员函数不受限于某个对象。内联函数（inline）不能是虚函数，因为内联函数不能在运行中动态确定位置。构造函数不能是虚函数。析构函数可以是虚函数，而且建议声明为虚函数。重写 vs 重载：重写可以有两种，直接重写成员函数和重写虚函数，只有重写了虚函数的才能算作是体现了C++多态性。而重载则是允许有多个同名的函数，而这些函数的参数列表不同，允许参数个数不同，参数类型不同，或者两者都不同。编译器会根据这些函数的不同列表，将同名的函数的名称做修饰，从而生成一些不同名称的预处理函数，来实现同名函数调用时的重载问题。但这并没有体现多态性。隐藏：除了重载与覆盖（重写），C++还有隐藏。隐藏是指派生类的函数屏蔽了与其同名的基类函数。隐藏规则如下：如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual 关键字，基类的函数将被隐藏（注意别与重载混淆，重载是在同一个类中发生）。如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆，覆盖有virtual关键字）。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;using namespace std;class Base&#123;public: virtual void f(float x) &#123; cout&lt;&lt;\"Base::f(float)\"&lt;&lt; x &lt;&lt;endl; &#125; void g(float x) &#123; cout&lt;&lt;\"Base::g(float)\"&lt;&lt; x &lt;&lt;endl; &#125; void h(float x) &#123; cout&lt;&lt;\"Base::h(float)\"&lt;&lt; x &lt;&lt;endl; &#125;&#125;;class Derived : public Base&#123;public: //子类与基类函数同名，有virtual关键字，运行时多态 virtual void f(float x) &#123; cout&lt;&lt;\"Derived::f(float)\"&lt;&lt; x &lt;&lt;endl; //多态、覆盖 &#125; //子类与基类函数同名，且无virtual关键字，隐藏 //参数不同的隐藏 void g(int x) &#123; cout&lt;&lt;\"Derived::g(int)\"&lt;&lt; x &lt;&lt;endl; //隐藏 &#125; //参数相同的隐藏 void h(float x) &#123; cout&lt;&lt;\"Derived::h(float)\"&lt;&lt; x &lt;&lt;endl; //隐藏 &#125;&#125;;int main(void)&#123; Derived d; //子类对象 Base *pb = &amp;d; //基类类型指针，指向子类对象 Derived *pd = &amp;d; //子类类型指针，指向子类对象 // Good : behavior depends solely on type of the object pb-&gt;f(3.14f); // Derived::f(float) 3.14 调用子类方法，多态 pd-&gt;f(3.14f); // Derived::f(float) 3.14 调用自己方法 // Bad : behavior depends on type of the pointer pb-&gt;g(3.14f); // Base::g(float) 3.14 pd-&gt;g(3.14f); // Derived::g(int) 3 // Bad : behavior depends on type of the pointer pb-&gt;h(3.14f); // Base::h(float) 3.14 pd-&gt;h(3.14f); // Derived::h(float) 3.14 return 0;&#125;有virtual才可能发生多态现象，不发生多态（无virtual）调用就按原类型调用 。上面的程序中：（1）函数Derived::f(float)覆盖了Base::f(float)，发生多态重写（覆盖）。（2）函数Derived::g(int)隐藏了Base::g(float)，而不是重载。（3）函数Derived::h(float)隐藏了Base::h(float)，而不是覆盖。总结为：在基类与子类函数名相同的前提下，根据参数是否相同、是否具有vritual关键字，可分为4种情况：参数相同、有virtual关键字：多态重写；参数相同、无virtual关键字：隐藏；与重写区分。参数不同、有virtual关键字：隐藏；与重载区分。参数不同、无virtual关键字：隐藏；与重载区分。","categories":[],"tags":[]},{"title":"C&C++/指向派生对象的基类的指针和引用","slug":"C&C++/指向派生对象的基类的指针和引用","date":"2020-05-13T15:07:01.522Z","updated":"2020-05-14T02:53:23.033Z","comments":true,"path":"archives/66c8de20.html","link":"","permalink":"https://longlongqin.github.io/archives/66c8de20.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/121-pointers-and-references-to-the-base-class-of-derived-objects/在前一章中，您学习了如何使用继承从现有类派生新类的所有知识。在本章中，我们将重点讨论继承最重要和最强大的方面之一——虚拟函数。但是在我们讨论什么是虚函数之前，让我们先来设置为什么需要它们。在 construction of derived classes中，您了解了在创建派生类时，它由多个部分组成：一部分是继承的类；另一部分是它本身。例如，这里有一个简单的例子:12345678910111213141516171819202122232425262728#include &lt;string_view&gt; class Base&#123;protected: int m_value; public: Base(int value) : m_value&#123; value &#125; &#123; &#125; std::string_view getName() const &#123; return \"Base\"; &#125; int getValue() const &#123; return m_value; &#125;&#125;; class Derived: public Base&#123;public: Derived(int value) : Base&#123; value &#125; &#123; &#125; std::string_view getName() const &#123; return \"Derived\"; &#125; int getValueDoubled() const &#123; return m_value * 2; &#125;&#125;;当我们创建一个派生对象时，它包含一个基类Base 部分(首先构造) 和 一个派生Derived部分(其次构造)。请记住，继承意味着两个类之间存在一个is-a关系。因为 派生的is-a 基，所以派生的包含基部分是合适的。指针、引用和派生类这应该是相当直观的，我们可以设置派生指针和引用的派生对象:123456789101112131415#include &lt;iostream&gt; int main()&#123; Derived derived&#123; 5 &#125;; std::cout &lt;&lt; \"derived is a \" &lt;&lt; derived.getName() &lt;&lt; \" and has value \" &lt;&lt; derived.getValue() &lt;&lt; '\\n'; Derived &amp;rDerived&#123; derived &#125;; std::cout &lt;&lt; \"rDerived is a \" &lt;&lt; rDerived.getName() &lt;&lt; \" and has value \" &lt;&lt; rDerived.getValue() &lt;&lt; '\\n'; Derived *pDerived&#123; &amp;derived &#125;; std::cout &lt;&lt; \"pDerived is a \" &lt;&lt; pDerived-&gt;getName() &lt;&lt; \" and has value \" &lt;&lt; pDerived-&gt;getValue() &lt;&lt; '\\n'; return 0;&#125;指向派生类对象的基类指针与引用然而，由于Derived有一个基部分，一个更有趣的问题是c++是否会让我们设置一个基指针或引用到一个派生的对象。事实证明，我们可以!12345678910111213141516#include &lt;iostream&gt; int main()&#123; Derived derived&#123; 5 &#125;; //下面的也是合理的 Base &amp;rBase &#123;derived&#125;; Base *pBase &#123;&amp;deriverd&#125;; std::cout &lt;&lt; \"derived is a \" &lt;&lt; derived.getName() &lt;&lt; \" and has value \" &lt;&lt; derived.getValue() &lt;&lt; '\\n'; std::cout &lt;&lt; \"rBase is a \" &lt;&lt; rBase.getName() &lt;&lt; \" and has value \" &lt;&lt; rBase.getValue() &lt;&lt; '\\n'; std::cout &lt;&lt; \"pBase is a \" &lt;&lt; pBase-&gt;getName() &lt;&lt; \" and has value \" &lt;&lt; pBase-&gt;getValue() &lt;&lt; '\\n'; return 0;&#125;因为rBase和pBase是一个基类的引用和指针，所以它们只能看到基类的成员(或者基类继承的任何类)。因此，即使Derived::getName() 的阴影(隐藏)Base::getName()的派生对象，基指针/引用不能看到Derived::getName()。因此，它们调用Base::getName()，这就是为什么rBase和pBase报告说它们是基而不是派生的。注意，这也意味着不可能使用rBase或pBase调用Derived::getValueDoubled()。他们看不到任何衍生的东西。另一个例子：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;string_view&gt;class Animal&#123;protected: std::string m_name; //我们使这个构造函数受保护，因为 //我们不希望人们直接创建动物对象， //但是我们仍然希望派生类能够使用它。 Animal(const std::string &amp;name) : m_name &#123;name&#125; &#123; &#125;public: const std::string&amp; getName() const &#123; return m_name; &#125; std::string_view speak() const &#123; return \"???\"; &#125;&#125;;class Cat : public Animal&#123;public: Cat(const std::string&amp; name) : Animal&#123;name&#125; &#123; &#125; std::string_view speak() const &#123; return \"Meow\"; &#125;&#125;;class Dog : public Animal&#123;public: Dog(const std::string&amp; name) : Animal&#123;name&#125; &#123; &#125; std::string_view speak() const &#123; return \"Woof\"; &#125;&#125;;int main()&#123; Cat cat&#123; \"Freed\" &#125;; std::cout &lt;&lt; \"cat is named \" &lt;&lt; cat.getName() &lt;&lt; \", and it says\" &lt;&lt; cat.speak() &lt;&lt; '\\n'; Dog dog&#123; \"HeiHu\" &#125;; std::cout &lt;&lt; \"dog is named \" &lt;&lt; dog.getName() &lt;&lt; \", and it says \" &lt;&lt; dog.speak() &lt;&lt; '\\n'; Animal* pAnimal&#123; &amp;cat &#125;; std::cout &lt;&lt; \"pAnimal is named \" &lt;&lt; pAnimal-&gt;getName() &lt;&lt; \", and it says \" &lt;&lt; pAnimal-&gt;speak() &lt;&lt; '\\n'; pAnimal = &amp;dog; std::cout &lt;&lt; \"pAnimal is named \" &lt;&lt; pAnimal-&gt;getName() &lt;&lt; \", and it says \" &lt;&lt; pAnimal-&gt;speak() &lt;&lt; '\\n'; std::cin.clear(); std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n'); std::cin.get(); return 0;&#125;/*结果*/cat is named Fred, and it says Meowdog is named Garbo, and it says WoofpAnimal is named Fred, and it says ???pAnimal is named Garbo, and it says ???我们在这里看到了同样的问题。因为pAnimal是一个动物指针，所以它只能看到类的动物部分。因此，pAnimal-&gt;speak()调用Animal::speak()，而不是Dog:: speak()或Cat::speak()函数。用于指向基类的指针和引用现在你可能会说，“上面的例子看起来有点傻。当我可以使用派生对象时，为什么要设置一个指针或引用来指向派生对象的基类?“事实证明，有相当多的理由。首先，假设您想编写一个函数来打印动物的名字和声音。如果不使用指向基类的指针，就必须使用重载函数来编写它，如下所示:123456789void report(const Cat &amp;cat)&#123; std::cout &lt;&lt; cat.getName() &lt;&lt; \" says \" &lt;&lt; cat.speak() &lt;&lt; '\\n';&#125; void report(const Dog &amp;dog)&#123; std::cout &lt;&lt; dog.getName() &lt;&lt; \" says \" &lt;&lt; dog.speak() &lt;&lt; '\\n';&#125;不难，但是想想如果我们有30种不同的动物而不是2种，会发生什么。你必须写30个几乎相同的函数!另外，如果你添加了一种新的动物，你也必须为它写一个新的函数。考虑到唯一真正的区别是参数的类型，这是一个巨大的时间浪费。然而，因为Cat 和 Dog 派生于 Animal，Cat 和 Dog 有一个Animal的部分。因此，我们应该能够这样做是有意义的:1234void report(const Animal &amp;rAnimal)&#123; std::cout &lt;&lt; rAnimal.getName() &lt;&lt; \" says \" &lt;&lt; rAnimal.speak() &lt;&lt; '\\n';&#125;这将允许我们传入任何派生自Animal的类，甚至是我们在编写函数之后创建的类! 不是每个派生类都有一个函数，而是有一个函数可以处理所有从Animal派生的类!当然，问题是，因为rAnimal是一个 Animal 引用，所以rAnimal.speak()将调用Animal::speak()，而不是speak()的派生版本。其次，假设您有3只猫和3只狗，您希望将它们放在一个数组中，以便于访问。因为数组只能保存一种类型的对象，没有指针或对基类的引用，所以必须为每个派生类型创建不同的数组，如下所示:123456789101112131415#include &lt;iostream&gt; int main()&#123; Cat cats[]&#123; &#123; \"Fred\" &#125;, &#123; \"Misty\" &#125;, &#123; \"Zeke\" &#125; &#125;; Dog dogs[]&#123; &#123; \"Garbo\" &#125;, &#123; \"Pooky\" &#125;, &#123; \"Truffle\" &#125; &#125;; for (const auto &amp;cat : cats) std::cout &lt;&lt; cat.getName() &lt;&lt; \" says \" &lt;&lt; cat.speak() &lt;&lt; '\\n'; for (const auto &amp;dog : dogs) std::cout &lt;&lt; dog.getName() &lt;&lt; \" says \" &lt;&lt; dog.speak() &lt;&lt; '\\n'; return 0;&#125;现在，考虑一下如果你有30种不同的动物会发生什么。你需要30个数组，每种动物一个!然而，因为猫和狗都来自于动物，我们应该能够做这样的事情是有道理的:12345678910111213141516171819#include &lt;iostream&gt; int main()&#123; Cat fred&#123; \"Fred\" &#125;; Cat misty&#123; \"Misty\" &#125;; Cat zeke&#123; \"Zeke\" &#125;; Dog garbo&#123; \"Garbo\" &#125;; Dog pooky&#123; \"Pooky\" &#125;; Dog truffle&#123; \"Truffle\" &#125;; // 设置一个指向animals的 指针数组，并将这些指针设置为指向我们的Cat和Dog对象 Animal *animals[]&#123; &amp;fred, &amp;garbo, &amp;misty, &amp;pooky, &amp;truffle, &amp;zeke &#125;; for (const auto animal : animals) std::cout &lt;&lt; animal-&gt;getName() &lt;&lt; \" says \" &lt;&lt; animal-&gt;speak() &lt;&lt; '\\n'; return 0;&#125;虽然他们可编译，可执行时，不幸的是，数组“animals”的每个元素都是指向动物的指针，这意味着animals[iii]-&gt;speak()将调用Animal::speak()，而不是我们想要的speak()的派生类版本。虽然这两种技术都可以节省我们大量的时间和精力，但它们都有相同的问题。指向基类的指针或引用调用函数的基版本，而不是派生版本。如果有什么方法可以让这些基指针调用函数的派生版本而不是基版本就好了…… -————虚函数","categories":[],"tags":[]},{"title":"C&C++/多重继承","slug":"C&C++/多重继承","date":"2020-05-13T14:25:49.678Z","updated":"2020-05-13T14:43:38.445Z","comments":true,"path":"archives/38f967fd.html","link":"","permalink":"https://longlongqin.github.io/archives/38f967fd.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/117-multiple-inheritance/多重继承到目前为止，我们介绍的所有继承示例都是单继承——也就是说，每个继承的类都有且只有一个父类。然而，c++提供了进行多重继承的能力。多重继承使派生类能够从多个父类继承成员。假设，假设我们想要编写一个程序来跟踪一群老师。老师是一个人，同时也是一个雇员(如果为自己工作，他们就是自己的雇主)。多重继承可用于创建教师类，该类继承Person和Employee的属性。要使用多重继承，只需指定每个基类(就像在单继承中一样)，中间用逗号分隔。12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;string&gt; class Person&#123;private: std::string m_name; int m_age; public: Person(std::string name, int age) : m_name(name), m_age(age) &#123; &#125; std::string getName() &#123; return m_name; &#125; int getAge() &#123; return m_age; &#125;&#125;; class Employee&#123;private: std::string m_employer; double m_wage; public: Employee(std::string employer, double wage) : m_employer(employer), m_wage(wage) &#123; &#125; std::string getEmployer() &#123; return m_employer; &#125; double getWage() &#123; return m_wage; &#125;&#125;; // Teacher publicly inherits Person and Employeeclass Teacher: public Person, public Employee //⭐记得用 逗号 隔开&#123;private: int m_teachesGrade; public: Teacher(std::string name, int age, std::string employer, double wage, int teachesGrade) : Person(name, age), Employee(employer, wage), m_teachesGrade(teachesGrade) &#123; &#125;&#125;;多重继承的问题虽然多重继承看起来像是单继承的简单扩展，但是多重继承引入了很多问题，这些问题会显著增加程序的复杂性，使它们成为维护的梦魇。让我们来看看这些情况。首先，当多个基类包含具有相同名称的函数时，可能会导致歧义。例如:12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt; class USBDevice&#123;private: long m_id; public: USBDevice(long id) : m_id(id) &#123; &#125; long getID() &#123; return m_id; &#125;&#125;; class NetworkDevice&#123;private: long m_id; public: NetworkDevice(long id) : m_id(id) &#123; &#125; long getID() &#123; return m_id; &#125;&#125;; class WirelessAdapter: public USBDevice, public NetworkDevice&#123;public: WirelessAdapter(long usbId, long networkId) : USBDevice(usbId), NetworkDevice(networkId) &#123; &#125;&#125;; int main()&#123; WirelessAdapter c54G(5442, 181742); std::cout &lt;&lt; c54G.getID(); // Which getID() do we call?⭐ return 0;&#125;在编译c54G.getID()时，编译器会查看WirelessAdapter是否包含一个名为getID()的函数。它没有。然后编译器查看父类中是否有一个名为getID()的函数。看到问题了吗? 问题是，c54G实际上包含两个getID()函数:一个继承自USBDevice，另一个继承自NetworkDevice。因此，这个函数调用是不明确的，如果尝试编译它，您将收到一个编译器错误。解决办法但是，有一种方法可以解决这个问题: 您可以显式地指定要调用的版本1234567int main()&#123; WirelessAdapter c54G(5442, 181742); std::cout &lt;&lt; c54G.USBDevice::getID(); //⭐ return 0;&#125;虽然这个解决方法非常简单，但是当您的类继承了从其他类本身继承的4或6个基类时，您可以看到事情会变得多么复杂。随着继承更多的类，命名冲突的可能性呈指数级增加，并且每一个命名冲突都需要显式地解决。","categories":[],"tags":[]},{"title":"C&C++/改变继承的成员的访问级别 及 隐藏继承自父类的成员","slug":"C&C++/改变继承的成员的访问级别 及 隐藏继承自父类的成员","date":"2020-05-13T13:59:29.348Z","updated":"2020-05-13T14:23:32.685Z","comments":true,"path":"archives/c4d17f90.html","link":"","permalink":"https://longlongqin.github.io/archives/c4d17f90.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/11-6b-hiding-inherited-functionality/更改 继承成员的访问级别C++使我们能够在派生类中更改继承成员的访问说明符。这是通过使用using来声明 (限定作用域的)基类成员 在派生类的新访问说明符下 更改其访问权限。12345678910111213141516#include &lt;iostream&gt; class Base&#123;private: int m_value; public: Base(int value) : m_value(value) &#123; &#125; protected: void printValue() &#123; std::cout &lt;&lt; m_value; &#125;&#125;;因为Base::printValue()已经被声明为 protected，所以它只能被Base或它的派生类调用。让我们定义一个派生类，它将printValue() 在该派生类中的访问说明符更改为public:123456789101112class Derived: public Base&#123;public: Derived(int value) : Base(value) &#123; &#125; // Base::printValue 之前被继承为受保护的，所以公众没有权限访问 // 但我们通过 using声明 将其改为pubic using Base::printValue; // note: 没有小括号⭐&#125;;这意味着这个代码将工作:12345678int main()&#123; Derived derived(7); // printValue is public in Derived, so this is okay derived.printValue(); // prints 7 return 0;&#125;注意首先，您只能更改派生类通常能够访问的基本成员的访问说明符。因此，永远不能将基成员的访问说明符从private更改为protected或public，因为派生类不能访问基类的私有成员。其次，从c++ 11开始，using声明 是改变访问级别的首选方法。但是，您也可以通过使用“访问声明”来更改访问级别。这与using声明方法的工作方式相同，但是省略了“using”关键字。这种重新定义访问的访问声明方式现在被认为是不赞成的，但是您可能会看到使用这种模式的旧代码，因此值得了解。将功能隐藏起来在c++中，除了修改源代码外，不可能从基类中删除或限制功能。但是，在派生类中，可以隐藏基类中存在的函数，这样就不能通过派生类访问它。这可以通过更改相关的 访问说明符来完成。123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;class Base&#123;public: int m_value;&#125;; class Derived : public Base&#123;private: using Base::m_value; //⭐将Base类中的 (public)成员变量m_value 的访问属性修改为private public: Derived(int value) // 我们不能初始化m_value，因为它是一个基类的 成员(基类 必须初始化它) &#123; // 但我们可以给它赋值 m_value = value; &#125;&#125;; int main()&#123; Derived derived(7); // 因为m_value已经被重新定义为private，所以下面的代码不能用 std::cout &lt;&lt; derived.m_value; //✖ return 0;&#125;注意，这允许我们获取设计糟糕的基类，并将其数据封装在我们的派生类中。或者，与其公开继承Base的成员并通过覆盖它的访问说明符使m_value私有，我们可以私有的继承Base，这将首先导致所有的Base成员被私有继承。你也可以在派生类中 将成员函数标记为delete，这确保了它们不能通过派生对象被调用：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717223456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;class Base&#123;private: int m_value; public: Base(int value) : m_value(value) &#123; &#125; int getValue() &#123; return m_value; &#125;&#125;; class Derived : public Base&#123;public: Derived(int value) : Base(value) &#123; &#125; int getValue() = delete; //⭐ mark this function as inaccessible&#125;; int main()&#123; Derived derived(7); // The following won't work because getValue() has been deleted! std::cout &lt;&lt; derived.getValue(); return 0;&#125;在上面的例子中，我们将getValue()函数标记为deleted。这意味着当我们试图调用函数的派生版本时，编译器会发出警告。注意，getValue()的基本版本仍然是可访问的。这意味着派生对象仍然可以访问getValue()，方法是先将派生对象向上转换为基对象:123456789int main()&#123; Derived derived(7); // 我们仍然可以通过基类访问 在派生类中删除的函数 std::cout &lt;&lt; static_cast&lt;Base&gt;(derived).getValue(); //⭐ return 0;&#125;","categories":[],"tags":[]},{"title":"C&C++/调用 继承函数和覆盖行为","slug":"C&C++/调用 继承函数和覆盖行为","date":"2020-05-13T08:26:42.293Z","updated":"2020-05-13T13:51:53.734Z","comments":true,"path":"archives/cedb49a3.html","link":"","permalink":"https://longlongqin.github.io/archives/cedb49a3.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/11-6a-calling-inherited-functions-and-overriding-behavior/默认情况下，派生类继承基类中定义的所有行为。在本节课中，我们将更详细地研究如何选择成员函数，以及如何利用它来更改派生类中的行为。调用基类函数当使用派生类对象调用成员函数时，编译器首先查看该成员是否存在于派生类中。如果没有，它就开始遍历继承链并检查成员是否在任何父类中定义。它使用找到的第一个。1234567891011121314151617181920212223242526272829303132333435class Base&#123;protected: int m_value; public: Base(int value) : m_value(value) &#123; &#125; void identify() &#123; std::cout &lt;&lt; \"I am a Base\\n\"; &#125;&#125;; class Derived: public Base&#123;public: Derived(int value) : Base(value) &#123; &#125;&#125;;int main()&#123; Base base(5); base.identify(); Derived derived(7); derived.identify(); return 0;&#125;/*结果*/I am a BaseI am a Base当derived.identify()被调用时，编译器会查看Derived类中是否定义了identify()函数。它没有。然后它开始查找继承的类(在本例中是Base)。Base定义了一个identify()函数，所以它使用这个函数。换句话说，使用Base::identify()是因为派生的Derived::identify()不存在。重定义行为(重新定义父类中的函数)但是，如果我们在派生类中定义了Derived::identify()，那么就会使用它。这意味着我们可以通过在派生类中重新定义这个函数，来让函数以不同的方式工作!要修改基类中定义的函数在派生类中的工作方式，只需重新定义派生类中的函数。12345678910111213class Derived: public Base&#123;public: Derived(int value) : Base(value) &#123; &#125; int getValue() &#123; return m_value; &#125; // Here's our modified function void identify() &#123; std::cout &lt;&lt; \"I am a Derived\\n\"; &#125;&#125;;下面是与上面相同的例子，使用新的Derived::Identify()函数:12345678910int main()&#123; Base base(5); base.identify(); Derived derived(7); derived.identify(); return 0;&#125;运行结果：12I am a BaseI am a Derived注意注意，在派生类中重新定义函数时，派生函数不会继承基类中同名函数的访问说明符。它使用在派生类中定义的访问说明符。因此，在基类中定义为private的函数可以在派生类中重新定义为public，反之亦然!1234567891011121314151617181920212223242526class Base&#123;private: void print() &#123; std::cout &lt;&lt; \"Base\"; &#125;&#125;; class Derived : public Base&#123;public: void print() &#123; std::cout &lt;&lt; \"Derived \"; &#125; &#125;; int main()&#123; Derived derived; derived.print(); // calls derived::print(), which is public return 0;&#125;添加功能到现有的父类函数中有时我们并不想完全替换基类函数，而是希望向它添加额外的功能。在上面的例子中，注意派生的::identify()完全隐藏了Base::identify()! 这可能不是我们想要的。可以让我们的派生函数调用同名函数的基本版本(以便重用代码)，然后向它添加额外的功能。要让派生函数调用同名的基函数，只需执行一个普通的函数调用，但在函数前面加上作用域限定符(基类的名称和两个冒号)。下面的示例重新定义了Derived::identify()，因此它首先调用Base::identify()，然后执行它自己的附加操作。12345678910111213141516class Derived: public Base&#123;public: Derived(int value) : Base(value) &#123; &#125; int GetValue() &#123; return m_value; &#125; void identify() &#123; Base::identify(); // call Base::identify() first std::cout &lt;&lt; \"I am a Derived\\n\"; // then identify ourselves &#125;&#125;;为什么需要使用范围解析操作符(::)?如果我们像这样定义了Derived::identify():12345678910111213141516class Derived: public Base&#123;public: Derived(int value) : Base(value) &#123; &#125; int GetValue() &#123; return m_value; &#125; void identify() &#123; identify(); // Note: no scope resolution! cout &lt;&lt; \"I am a Derived\"; &#125;&#125;;没有范围解析限定符的调用函数identify()将默认为当前类中的identify()，它实际上看起来是这种形式： Derived::identify()。这将导致Derived::identify()调用自身，这将导致无限循环!在派生类调用基类的友元函数当我们试图在派生类调用基类的友元函数时，比如操作符&lt;&lt;，可能会遇到一点小麻烦。因为基类的friend函数实际上不是基类的一部分，所以使用范围解析限定符不起作用。相反，我们需要一种方法使我们的派生类暂时看起来像基类，这样就可以调用函数的正确版本。幸运的是，使用static_cast很容易做到这一点。这里有一个例子:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Base&#123;private: int m_value; public: Base(int value) : m_value(value) &#123; &#125; friend std::ostream&amp; operator&lt;&lt; (std::ostream &amp;out, const Base &amp;b) &#123; out &lt;&lt; \"In Base\\n\"; out &lt;&lt; b.m_value &lt;&lt; '\\n'; return out; &#125;&#125;; class Derived : public Base&#123;public: Derived(int value) : Base(value) &#123; &#125; friend std::ostream&amp; operator&lt;&lt; (std::ostream &amp;out, const Derived &amp;d) &#123; out &lt;&lt; \"In Derived\\n\"; // static_cast派生到一个基对象, so we call the right version of operator&lt;&lt; out &lt;&lt; static_cast&lt;Base&gt;(d); //⭐ return out; &#125;&#125;; int main()&#123; Derived derived(7); std::cout &lt;&lt; derived; return 0;&#125;/*结果*/In derived //先运行 “out &lt;&lt; \"In Derived\\n\";”In base //然后调用 基类Base中的友元函数7因为Derived类 派生自 Base类，所以我们可以将派生对象转换为基，这样就可以调用使用基的操作符&lt;&lt;的适当版本。","categories":[],"tags":[]},{"title":"C&C++/继承中的访问标识符","slug":"C&C++/继承中的访问标识符","date":"2020-05-13T03:29:26.858Z","updated":"2020-05-13T08:22:21.265Z","comments":true,"path":"archives/664c52ef.html","link":"","permalink":"https://longlongqin.github.io/archives/664c52ef.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/115-inheritance-and-access-specifiers/private、public、protectedprivate：私有成员只能由同一类或 friends 的成员函数访问。这意味着派生类不能直接访问基类的私有成员!当类中的成员没有显式的给定 访问说明符，C++则默认其为：privatepublic：任何人都可以访问公共成员protected受保护的访问说明符在处理继承类时，事情会变得有点复杂。c++有一个我们还没有讨论的第三个访问说明符：protected，因为它只在继承上下文中有用。受保护的访问说明符允许成员所属的类、朋友类和派生类访问成员。但是，受保护成员不能从类外部访问。12345678910111213141516171819202122232425262728class Base&#123;public: int m_public; // can be accessed by anybodyprotected: int m_protected; // can be accessed by Base members, friends, and derived classesprivate: int m_private; // can only be accessed by Base members and friends (but not derived classes)&#125;; class Derived: public Base&#123;public: Derived() &#123; m_public = 1; // allowed: can access public base members from derived class m_protected = 2; // allowed: can access protected base members from derived class m_private = 3; // not allowed: can not access private base members from derived class &#125;&#125;; int main()&#123; Base base; base.m_public = 1; // allowed: can access public members from outside class base.m_protected = 2; //⭐ not allowed: can not access protected members from outside class base.m_private = 3; // not allowed: can not access private members from outside class&#125;在上面的示例中，您可以看到受保护的基本成员m_protected可由派生类Derived直接访问，而不是由公共访问。何时使用受保护的访问说明符?基类中的protected属性的成员，派生类可以直接访问该成员。这意味着，如果您以后更改了关于protected属性的任何内容(类型、值的含义等等)，您可能需要同时更改基类和所有派生类。因此，当您(或您的团队)是从您自己的类派生出来的，并且派生类的数量是合理的时，使用受保护的访问说明符是最有用的。这样，如果您对基类的实现进行了更改，并且因此需要对派生类进行更新，那么您可以自己进行更新(并且更新不会永远进行，因为派生类的数量是有限的)。将成员设为私有可以提供更好的封装，并将派生类与对基类的更改隔离开来。但是，构建一个公共或受保护的接口来支持公共 和/或 派生类所需的所有访问方法或功能也是有成本的。这是额外的工作，可能不值得，除非您期望其他人是从您的类派生出来的，或者您有大量的派生类，更新它们的成本将非常昂贵。不同种类的继承及其对访问的影响首先，类从其他类继承有三种不同的方法:public、protected和private。要做到这一点，只需指定在选择要继承的类时想要的访问类型:123456789101112131415161718// Inherit from Base publiclyclass Pub: public Base&#123;&#125;; // Inherit from Base protectedlyclass Pro: protected Base&#123;&#125;; // Inherit from Base privatelyclass Pri: private Base&#123;&#125;; class Def: Base // Defaults to private inheritance&#123;&#125;;如果不选择继承类型，c++默认为私有继承(就像如果不指定其他类型，成员默认为私有访问)这给了我们9种组合:3种成员访问说明符(公共、私有和受保护)，以及3种继承类型(公共、私有和受保护)。它们之间有什么区别呢? 简而言之，当成员被继承时，继承成员的访问说明符可能会根据使用的继承类型而改变(仅在派生类中)。换句话说，基类中为公有或受保护的成员可能会更改派生类中的访问说明符。当我们逐步分析这些例子时，请记住以下规则:一个类总是可以访问它自己的(非继承的)成员。公共访问类的成员基于它正在访问的类的访问说明符。类根据从父类继承的访问说明符访问继承的成员。这取决于所使用的访问说明符和继承类型。公有继承公有继承是目前最常用的继承类型。事实上，您很少会看到或使用其他类型的继承，所以您的主要关注点应该是理解这一部分。幸运的是，公共继承也是最容易理解的。当您公开继承基类时，继承的公共成员保持为public；继承的受保护成员保持为protected。；继承的私有成员保持不可访问，因为它们在基类中是私有的。Access specifier in base classAccess specifier when inherited publiclyPublicPublicProtectedProtectedPrivateInaccessible保护继承受保护继承是最不常见的继承方法。它几乎从未被使用过，除非在非常特殊的情况下。有了受保护的继承，公共成员和受保护的成员就得到了保护；而私有成员则无法访问。因为这种形式的继承非常罕见，我们就跳过这个例子，用一个表格总结一下:Access specifier in base classAccess specifier when inherited protectedlyPublicProtectedProtectedProtectedPrivateInaccessible私有继承使用私有继承，基类的所有成员都继承为私有。这意味着私有成员保持私有；受保护 和 公共成员变 为私有。注意，这并不影响派生类访问从父类继承的成员的方式。它只影响试图通过派生类访问这些成员的代码。1234567891011121314151617181920212223242526272829303132333435363738394041class Base&#123;public: int m_public;protected: int m_protected;private: int m_private;&#125;; class Pri: private Base // note: private inheritance&#123; // Private inheritance means: // Public inherited members become private (so m_public is treated as private) // Protected inherited members become private (so m_protected is treated as private) // Private inherited members stay inaccessible (so m_private is inaccessible)public: Pri() &#123; m_public = 1; // okay: m_public is now private in Pri m_protected = 2; // okay: m_protected is now private in Pri m_private = 3; // not okay: derived classes can't access private members in the base class &#125;&#125;; int main()&#123; // Outside access uses the access specifiers of the class being accessed. // In this case, the access specifiers of base. Base base; base.m_public = 1; // okay: m_public is public in Base base.m_protected = 2; // not okay: m_protected is protected in Base base.m_private = 3; // not okay: m_private is private in Base Pri pri; pri.m_public = 1; // not okay: m_public is now private in Pri pri.m_protected = 2; // not okay: m_protected is now private in Pri pri.m_private = 3; // not okay: m_private is inaccessible in Pri return 0;&#125;以表格形式总结:Access specifier in base classAccess specifier when inherited privatelyPublicPrivateProtectedPrivatePrivateInaccessible当派生类与基类没有明显关系，但在内部使用基类实现时，私有继承可能非常有用。在这种情况下，我们可能不希望基类的公共接口通过派生类的对象公开(如果我们公开继承)。小结访问说明符、继承类型 和 派生类 相互作用的方式会引起很多混淆。尽可能多地尝试和澄清事情:首先，类(和friend )总是可以访问它自己的非继承成员。访问说明符只影响外部人员和派生类是否可以访问这些成员。其次，当派生类继承成员时，这些成员可能会更改派生类中的访问说明符。但这并不影响派生类自己的(非继承的)成员(它们有自己的访问说明符)。它只影响外部人员和派生自派生类的类是否可以访问这些继承的成员。最后要注意的是，尽管在上面的例子中，我们只展示了使用成员变量的例子，但是这些访问规则对所有成员都适用(例如，在类中声明的成员函数和类型)。下面是所有访问说明符和继承类型组合的表:Access specifier in base classAccess specifier when inherited publiclyAccess specifier when inherited privatelyAccess specifier when inherited protectedlyPublicPublicPrivateProtectedProtectedProtectedPrivateProtectedPrivateInaccessibleInaccessibleInaccessible","categories":[],"tags":[]},{"title":"C&C++/派生类的构造函数及初始化","slug":"C&C++/派生类的构造函数及初始化","date":"2020-05-13T01:30:25.627Z","updated":"2020-05-13T02:52:40.641Z","comments":true,"path":"archives/f3aa0b39.html","link":"","permalink":"https://longlongqin.github.io/archives/f3aa0b39.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/114-constructors-and-initialization-of-derived-classes/我们将深入了解构造函数在派生类初始化中的作用。为此，我们将继续使用我们在前一课中开发的简单的基类和派生类:12345678910111213141516171819202122232425class Base&#123;public: int m_id; Base(int id=0) : m_id&#123; id &#125; &#123; &#125; int getId() const &#123; return m_id; &#125;&#125;; class Derived: public Base&#123;public: double m_cost; Derived(double cost=0.0) : m_cost&#123; cost &#125; &#123; &#125; double getCost() const &#123; return m_cost; &#125;&#125;;对于非派生类，构造函数只需要担心自己的成员。例如，考虑Base。我们可以像这样创建一个基对象:123456int main()&#123; Base base&#123; 5 &#125;; // use Base(int) constructor return 0;&#125;下面是实例化base时实际发生的情况:为base 留出内存调用适当的base的 构造函数初始化列表 初始化变量构造函数的主体执行控件返回给调用方对于派生类，事情稍微复杂一些:123456int main()&#123; Derived derived&#123; 1.3 &#125;; // use Derived(double) constructor return 0;&#125;下面是实例化派生类时实际发生的情况:为derived 留出内存 (足够用于基部分和派生部分)调用适当的Derived的 构造函数首先使用适当的 基构造函数 构造 基对象。如果没有指定基构造函数，则使用默认构造函数。初始化列表 初始化变量构造函数的主体执行控件返回给调用方这种情况 与 非继承情况 之间的唯一真正区别是，在派生构造函数可以执行任何实质性操作之前，首先调用基构造函数。基构造函数设置对象的基部分，将控件返回给派生构造函数，并允许派生构造函数完成其工作。初始化基类成员我们的派生类当前的一个缺点是：当我们创建一个派生对象时，没有方法初始化m_id。如果我们想在创建派生对象时同时设置m_cost (来自对象的派生部分)和 m_id (来自对象的基本部分)，该怎么办?错误的初始化新程序员经常尝试解决这个问题如下:12345678910111213class Derived: public Base&#123;public: double m_cost; Derived(double cost=0.0, int id=0) // does not work : m_cost&#123; cost &#125;, m_id&#123; id &#125; &#123; &#125; double getCost() const &#123; return m_cost; &#125;&#125;;这是一个很好的尝试，而且几乎是正确的想法。我们确实需要向构造函数中添加另一个参数，否则c++将无法知道我们想要初始化m_id为什么值。但是，c++不允许类在构造函数的初始化列表中初始化继承的成员变量。换句话说，变量的值只能在该变量所在的那个类的 构造函数的初始化列表中设置。为啥会有这个限制？答案与const和引用变量有关。考虑一下如果m_id是常量会发生什么。因为const变量必须在创建时用一个值初始化，所以基类构造函数必须在创建变量时设置它的值。但是，当基类构造函数完成时，派生类构造函数的初始化列表就会执行。然后，每个派生类都有机会初始化该变量，可能会更改其值!通过将变量的初始化限制在这些变量所属的类的构造函数中，c++确保所有变量只初始化一次。最终的结果是上面的例子不起作用，因为m_id是从Base继承的，并且只有非继承的变量可以在初始化列表中初始化。但是，继承的变量仍然可以在构造函数体中使用赋值来更改它们的值。因此，新程序员也经常这样做:12345678910111213class Derived: public Base&#123;public: double m_cost; Derived(double cost=0.0, int id=0) : m_cost&#123; cost &#125; &#123; m_id = id; //⭐ &#125; double getCost() const &#123; return m_cost; &#125;&#125;;虽然这在这种情况是可行的，但是如果m_id是一个const或一个引用，它就不能工作(因为const值和引用必须在构造函数的初始化列表中初始化)。它的效率也很低，因为m_id被赋值两次: 一次在基类构造函数的初始化列表中，一次在派生类构造函数的主体中。最后，如果基类在构造过程中需要访问这个值，该怎么办?它没有办法访问它，因为它在派生构造函数执行之前是不设置的(基本上是最后执行)。正确初始化那么，当创建派生类对象时，我们如何正确初始化m_id呢?在到目前为止的所有示例中，当我们实例化一个派生类对象时，基类部分已经使用默认的基构造函数创建。为什么它总是使用默认的基构造函数? 因为我们从来没有让它使用其他的构造函数。幸运的是，C++允许我们显式地选择将调用哪个基类构造函数! 要做到这一点，只需在派生类的初始化列表中添加对基类构造函数的调用:12345678910111213class Derived: public Base&#123;public: double m_cost; Derived(double cost=0.0, int id=0) : Base&#123; id &#125;, // ⭐Call Base(int) constructor with value id! m_cost&#123; cost &#125; &#123; &#125; double getCost() const &#123; return m_cost; &#125;&#125;;现在，当我们执行这个代码时:123456789101112int main()&#123; Derived derived&#123; 1.3, 5 &#125;; // use Derived(double, int) constructor std::cout &lt;&lt; \"Id: \" &lt;&lt; derived.getId() &lt;&lt; '\\n'; std::cout &lt;&lt; \"Cost: \" &lt;&lt; derived.getCost() &lt;&lt; '\\n'; return 0;&#125;/*结果*/Id: 5Cost: 1.3基类构造函数base (int) 将用于初始化m_id为 5，派生类构造函数将用于初始化m_cost为1.3 !更详细的细节：分配用于派生（derived ）的内存。调用Derived(double, int)构造函数，其中cost = 1.3, id = 5编译器会查看我们是否需要一个特定的基类构造函数。我们有! 因此它调用id = 5的Base(int)。基类构造函数 初始化列表 将m_id设置为5基类构造函数body执行，它什么也不做基类构造函数返回派生类构造函数初始化列表将m_cost设置为1.3派生类构造函数body执行，它什么也不做派生类构造函数返回这看起来有点复杂，但实际上非常简单。所发生的一切就是派生构造函数调用特定的基构造函数来初始化对象的基部分。因为m_id位于对象的基部分中，所以基构造函数是惟一可以初始化该值的构造函数。注意：注意，在派生构造函数初始化列表中调用 基构造函数 的位置并不重要——因为 基构造函数 总是先执行。现在可以让我们的成员私有(private)既然知道了如何初始化基类成员，就不需要保持成员变量为公共。我们再次将成员变量设为私有，这是应该的。简单回顾一下，任何人都可以访问公共成员。私有成员只能由同一类的成员函数访问。注意，这意味着派生类不能直接访问基类的私有成员 ! 派生类将需要使用访问函数来访问基类的私有成员。123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt; class Base&#123;private: // our member is now private int m_id; public: Base(int id=0) : m_id&#123; id &#125; &#123; &#125; int getId() const &#123; return m_id; &#125;&#125;; class Derived: public Base&#123;private: // our member is now private double m_cost; public: Derived(double cost=0.0, int id=0) : Base&#123; id &#125;, // Call Base(int) constructor with value id! m_cost&#123; cost &#125; &#123; &#125; double getCost() const &#123; return m_cost; &#125;&#125;; int main()&#123; Derived derived&#123; 1.3, 5 &#125;; // use Derived(double, int) constructor std::cout &lt;&lt; \"Id: \" &lt;&lt; derived.getId() &lt;&lt; '\\n'; //⭐通过访问函数访问私有成员 std::cout &lt;&lt; \"Cost: \" &lt;&lt; derived.getCost() &lt;&lt; '\\n'; //⭐通过访问函数访问私有成员 return 0;&#125;派生类被销毁时调用析构函数的顺序当一个派生类被销毁时，每个析构函数都以相反的构造顺序被调用。也就是说，我们派生类在被创建时，构造函数的调用顺序是：先调用 最基类的构造函数—-&gt; 子类的构造函数 —-&gt;子类的子类的构造函数—-&gt;….—–&gt;最后调用 最子类的构造函数。在销毁派生类时，析构函数调用的顺序：首先调用 最子类的析构函数—-&gt;….———&gt;最后调用 最基类的析构函数","categories":[],"tags":[]},{"title":"C&C++/派生类的构造顺序","slug":"C&C++/派生类的构造顺序","date":"2020-05-12T16:07:04.304Z","updated":"2020-05-13T01:27:18.535Z","comments":true,"path":"archives/64f81817.html","link":"","permalink":"https://longlongqin.github.io/archives/64f81817.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/113-order-of-construction-of-derived-classes/首先，让我们引入一些新类来帮助我们阐明一些重要的观点：12345678910111213141516171819202122232425class Base&#123;public: int m_id; Base(int id=0) : m_id(id) &#123; &#125; int getId() const &#123; return m_id; &#125;&#125;; class Derived: public Base&#123;public: double m_cost; Derived(double cost=0.0) : m_cost(cost) &#123; &#125; double getCost() const &#123; return m_cost; &#125; &#125;在本例中，Derived类 是从 Base类 派生的。因为Derived 继承了Base的函数和变量，所以可以假设 Base的成员被复制到派生的。然而，事实并非如此。相反，我们可以将派生类考虑为两个部分的类:一个部分Derived，一个部分Base。当我们实例化一个普通(非派生)类时会发生什么:12345678int main()&#123; Base base; return 0;&#125;//Base是一个非派生类，因为它不从任何其他类继承。//c++为Base分配内存，然后调用Base的默认构造函数来进行初始化。现在让我们看看当我们实例化一个派生类时会发生什么:12345678int main()&#123; Derived derived; return 0;&#125;//当我们实例化一个Derived实例时，首先构造了Derived的 基部分(使用基默认构造函数)。一旦基本部分完成，派生部分 就被构造(使用派生的默认构造函数)。在这一点上，没有更多的派生类，所以我们完成了。派生类的构造顺序如上所述，派生实际上包括两部分: 基础部分 和 派生部分。当c++构造派生对象时，它是分阶段进行的。首先，首先构造最基本的类(在继承树的顶部)。然后按顺序构造每个子类，直到最后构造 最子类(在继承树的底部)。用一个程序来说明：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt; class Base&#123;public: int m_id; Base(int id=0) : m_id(id) &#123; std::cout &lt;&lt; \"Base\\n\"; &#125; int getId() const &#123; return m_id; &#125;&#125;; class Derived: public Base&#123;public: double m_cost; Derived(double cost=0.0) : m_cost(cost) &#123; std::cout &lt;&lt; \"Derived\\n\"; &#125; double getCost() const &#123; return m_cost; &#125;&#125;; int main()&#123; std::cout &lt;&lt; \"Instantiating Base\\n\"; Base cBase; std::cout &lt;&lt; \"Instantiating Derived\\n\"; Derived cDerived; return 0;&#125;/*结果*/Instantiating BaseBaseInstantiating DerivedBaseDerived//可以看到，当我们构造派生函数时，首先构造派生函数的基部分。//这是有道理的:从逻辑上讲，没有父元素，子元素就不能存在。//这也是一种安全的方法:子类经常使用来自父类的变量和函数，但是父类对子类一无所知。//实例化父类首先确保在创建派生类并准备使用它们时已经初始化了这些变量。","categories":[],"tags":[]},{"title":"C&C++/c++中的基本继承","slug":"C&C++/c++中的基本继承","date":"2020-05-12T15:48:27.429Z","updated":"2020-05-12T15:56:12.450Z","comments":true,"path":"archives/6a59a953.html","link":"","permalink":"https://longlongqin.github.io/archives/6a59a953.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/112-basic-inheritance-in-c/C++中的继承发生在类之间。在继承(is-a)关系中，被继承的类称为父类、基类或超类，继承的类称为子类、派生类。在上面的图中，Fruit是父类，Apple和Banana都是子类。在这个图中，Triangle既是一个子类(to Shape)，又是一父类 (to Right Triangle)。","categories":[],"tags":[]},{"title":"C&C++/继承","slug":"C&C++/继承","date":"2020-05-12T14:59:08.180Z","updated":"2020-05-12T15:03:01.915Z","comments":true,"path":"archives/1adb63dd.html","link":"","permalink":"https://longlongqin.github.io/archives/1adb63dd.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/111-introduction-to-inheritance/与通过组合和连接其他对象来创建新对象的对象组合不同，继承涉及通过直接获取其他对象的属性和行为来创建新对象，然后扩展或专门化它们。就像C++继承了C语言的许多特性，C语言是c++的基础，而C语言又继承了它之前的编程语言的许多特性。","categories":[],"tags":[]},{"title":"C&C++/使用stdinitializer_list初始化类","slug":"C&C++/使用stdinitializer_list初始化类","date":"2020-05-12T13:24:33.494Z","updated":"2020-05-12T14:52:11.537Z","comments":true,"path":"archives/cf35c829.html","link":"","permalink":"https://longlongqin.github.io/archives/cf35c829.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/10-7-stdinitializer_list/当编译器看到初始化器列表时，它会自动将其转换成std::initializer_list类型的对象。因此，如果我们创建一个接受std::initializer_list参数的构造函数，我们可以使用初始化器列表作为输入来创建对象。std::initializer_list在头文件&lt;initializer_list&gt;关于std::initializer_list，有一些事情需要了解与std::array或std::vector非常类似，您必须告诉std::initializer_list列表中的数据类型（在尖括号中表示 类型）。如：std::initializer_list&lt;int&gt;或std::initializer_list&lt;std::string&gt;std::initializer_list有一个(命名错误)size()函数，它返回列表中的元素数量。当我们需要知道传入的列表的长度时，这是很有用的。使用std::initializer_list创建一个 构造函数让我们看看如何使用一个构造函数来更新IntArray类，这个构造函数采用std::initializer_list。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cassert&gt; // for assert()#include &lt;initializer_list&gt; // for std::initializer_list#include &lt;iostream&gt; class IntArray&#123;private: int m_length&#123;&#125;; int *m_data&#123;&#125;; public: IntArray() = default; IntArray(int length) : m_length&#123; length &#125;, m_data&#123; new int[length]&#123;&#125; &#125; &#123; &#125; IntArray(std::initializer_list&lt;int&gt; list) : //⭐ 允许通过 列表初始化 来初始化IntArray IntArray(static_cast&lt;int&gt;(list.size())) // 使用委托构造函数设置初始数组 &#123; // 现在从列表中初始化我们的数组 int count&#123; 0 &#125;; for (auto element : list) &#123; m_data[count] = element; ++count; &#125; &#125; ~IntArray() &#123; delete[] m_data; // 我们不需要在这里设置m_data为null或m_length为0，因为对象将在这个函数之后立即销毁 &#125; IntArray(const IntArray&amp;) = delete; // 避免浅拷贝 IntArray&amp; operator=(const IntArray&amp; list) = delete; // 避免浅拷贝 int&amp; operator[](int index) &#123; assert(index &gt;= 0 &amp;&amp; index &lt; m_length); return m_data[index]; &#125; int getLength() const &#123; return m_length; &#125;&#125;; int main()&#123; IntArray array&#123; 5, 4, 3, 2, 1 &#125;; //⭐ initializer list for (int count&#123; 0 &#125;; count &lt; array.getLength(); ++count) std::cout &lt;&lt; array[count] &lt;&lt; ' '; return 0;&#125;工作原理现在，让我们更详细地探讨这个问题的工作原理：这是我们的IntArray构造函数，它接受std::initializer_list&lt;int&gt;。1234567891011IntArray(std::initializer_list&lt;int&gt; list): // allow IntArray to be initialized via list initialization IntArray(static_cast&lt;int&gt;(list.size())) // use delegating constructor to set up initial array&#123; // Now initialize our array from the list int count&#123; 0 &#125;; for (int element : list) &#123; m_data[count] = element; ++count; &#125;&#125;第一行：如上所述，我们必须使用尖括号来表示我们在列表中期望的元素类型。在这种情况下，因为这是一个IntArray，我们希望列表用int来填充，注意我们没有通过const引用来传递列表。很像std::string_view，std::initializer_list是非常轻量级的，而且拷贝往往比间接拷贝更便宜。第二行：我们通过委托构造函数将IntArray的内存分配委托给另一个构造函数(以减少冗余代码)。另一个构造函数需要知道数组的长度，因此我们传递给它list.size()，它包含列表中的元素数量。注意，list.size()返回一个size_t(它是无符号的)，所以我们需要在这里转换为一个有符号的int。我们使用直接初始化，而不是大括号初始化，因为大括号初始化更喜欢列表构造函数。虽然构造函数会得到正确的解析，但是如果我们不想使用list构造函数，使用直接初始化来初始化类会更安全。构造函数的主体：用于将列表中的元素复制到我们的IntArray类中。由于一些无法解释的原因，std::initializer_list不提供通过下标(operator[])访问列表元素的功能。标准委员会已多次注意到这一遗漏，但从未处理过。但是，有一些简单的方法可以解决缺少下标的问题。最简单的方法是在这里使用for-each循环。for-each循环遍历初始化列表中的每个元素，我们可以手动将这些元素复制到内部数组中。注意：初始化器列表总是优先选择匹配的initializer_list构造函数。所以，下面的：1IntArray array &#123; 5 &#125;;将匹配IntArray(std::initializer_list)，而不是IntArray(int)。如果想在定义initializer_list构造函数之后匹配IntArray(int)，则需要使用 复制初始化 或 直接初始化。使用std::initializer_list赋值类您还可以使用std::initializer_list来为类分配新值，方法是重载赋值操作符以获取std::initializer_list参数。这与上面的工作原理类似。我们将在下面的测试解决方案中展示一个如何做到这一点的例子。注意，如果您实现一个构造函数，该构造函数采用std::initializer_list，那么您应该确保至少执行以下操作之一:提供重载的列表赋值操作符提供适当的 深拷贝 复制赋值操作符12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//小测试：使用上面的IntArray类，实现一个重载赋值运算符，它接受初始化器列表。//的解决方案#include &lt;cassert&gt; // for assert()#include &lt;initializer_list&gt; // for std::initializer_list#include &lt;iostream&gt; class IntArray&#123;private: int m_length &#123;&#125;; int *m_data &#123;&#125;; public: IntArray() = default; IntArray(int length) : m_length&#123; length &#125;, m_data&#123; new int[length]&#123;&#125; &#125; &#123; &#125; IntArray(std::initializer_list&lt;int&gt; list) : // allow IntArray to be initialized via list initialization IntArray(static_cast&lt;int&gt;(list.size())) // use delegating constructor to set up initial array &#123; // Now initialize our array from the list int count&#123; 0 &#125;; for (auto element : list) &#123; m_data[count] = element; ++count; &#125; &#125; ~IntArray() &#123; delete[] m_data; // we don't need to set m_data to null or m_length to 0 here, since the object will be destroyed immediately after this function anyway &#125; IntArray(const IntArray&amp;) = delete; // to avoid shallow copies IntArray&amp; operator=(const IntArray&amp; list) = delete; // to avoid shallow copies IntArray&amp; operator=(std::initializer_list&lt;int&gt; list) //⭐ &#123; // If the new list is a different size, reallocate it int length&#123; static_cast&lt;int&gt;(list.size()) &#125;; if (length != m_length) &#123; delete[] m_data; m_length = length; m_data = new int[length]&#123;&#125;; &#125; // Now initialize our array from the list int count&#123; 0 &#125;; for (auto element : list) &#123; m_data[count] = element; ++count; &#125; return *this; &#125; int&amp; operator[](int index) &#123; assert(index &gt;= 0 &amp;&amp; index &lt; m_length); return m_data[index]; &#125; int getLength() const &#123; return m_length; &#125;&#125;; int main()&#123; IntArray array &#123; 5, 4, 3, 2, 1 &#125;; // initializer list for (int count&#123; 0 &#125;; count &lt; array.getLength(); ++count) std::cout &lt;&lt; array[count] &lt;&lt; ' '; std::cout &lt;&lt; '\\n'; array = &#123; 1, 3, 5, 7, 9, 11 &#125;; //⭐ for (int count&#123; 0 &#125;; count &lt; array.getLength(); ++count) std::cout &lt;&lt; array[count] &lt;&lt; ' '; std::cout &lt;&lt; '\\n'; return 0;&#125;","categories":[],"tags":[]},{"title":"C&C++/容器类","slug":"C&C++/容器类","date":"2020-05-12T09:00:00.508Z","updated":"2020-05-12T13:21:33.674Z","comments":true,"path":"archives/2ef705db.html","link":"","permalink":"https://longlongqin.github.io/archives/2ef705db.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/106-container-classes/在现实生活中，我们总是使用容器。你的早餐麦片装在一个盒子里，书里的书页装在封面和封皮里，你可以把任何数量的东西装在车库里的容器里。如果没有容器，使用这些对象就会非常不方便。类似地，容器类(container class)是设计来容纳和组织另一种类型 (另一种类或基本类型) 的多个实例的类。有许多不同种类的容器类，每种容器类在其使用中都有各种优点、缺点和限制。到目前为止，在编程中最常用的容器是数组，您已经看到了许多这样的例子。虽然c++有内置的数组功能，但程序员通常会使用数组容器类(std::array或std::vector)，因为它们提供了额外的好处。与内置数组不同，数组容器类通常提供动态调整大小(添加或删除元素时)，在传递给函数时记住它们的大小，并执行边界检查。这不仅使数组容器类比普通数组更方便，而且更安全。良好的容器将包括以下功能容器类通常实现一个相当标准化的最小功能集。大多数定义良好的容器将包括以下功能:创建一个空容器(通过构造函数)在容器中插入一个新对象从容器中删除对象报告容器中当前对象的数量清空容器中所有的对象提供对存储对象的访问对元素排序(可选)有时候，某些容器类会忽略某些功能。例如，数组容器类经常省略插入和删除函数，因为它们很慢，而且类设计器不希望鼓励使用它们。容器类实现成员关系。例如，数组的元素是数组的成员(属于)。注意，我们使用的是传统意义上的“member-of”，而不是c++类成员的意义。容器的类型容器类通常有两种不同的种类：Value containers：存储它们所持有的对象的副本的 compositions（这样就可以负责创建和销毁这些副本）。Reference containers：存储指向其他对象的指针或引用的aggregations （因此不负责这些对象的创建或销毁）不像在现实生活中，容器可以保存任何类型的对象。在c++中，容器通常只保存一种类型的数据。例如，如果你有一个整数数组，它将只保存整数。与其他一些语言不同，许多c++容器不允许任意混合类型。如果需要容器来保存整数和双精度数，通常需要编写两个单独的容器(或者使用模板，这是c++的一个高级特性)。尽管容器的使用受到限制，但它们非常有用，并且使编程更容易、更安全数组容器类在这个例子中，我们将从头开始编写一个整数数组类，它实现了容器应该具有的大多数常见功能。这个数组类将是一个值容器（value container），它将保存它组织的元素的副本。顾名思义，该容器将保存一个整数数组，类似于std::vector。创建过程详情请看：https://www.learncpp.com/cpp-tutorial/106-container-classes/ 的“An array container class”","categories":[],"tags":[]},{"title":"C&C++/类的拷贝初始化","slug":"C&C++/类的拷贝初始化","date":"2020-05-11T09:37:18.393Z","updated":"2020-05-11T10:00:29.477Z","comments":true,"path":"archives/5b8eb091.html","link":"","permalink":"https://longlongqin.github.io/archives/5b8eb091.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/9-12-copy-initialization/避免直接使用拷贝初始化1234567891011121314151617181920212223242526272829303132#include &lt;cassert&gt;#include &lt;iostream&gt; class Fraction&#123;private: int m_numerator; int m_denominator; public: // Default constructor Fraction(int numerator=0, int denominator=1) : m_numerator(numerator), m_denominator(denominator) &#123; assert(denominator != 0); &#125; friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction &amp;f1);&#125;; std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction &amp;f1)&#123; out &lt;&lt; f1.m_numerator &lt;&lt; \"/\" &lt;&lt; f1.m_denominator; return out;&#125;int main()&#123; Fraction six = Fraction(6); std::cout &lt;&lt; six; return 0;&#125;这种形式的拷贝初始化的工作原理是和下面的形式的工作原理一样:1Fraction six(Fraction(6));在“拷贝构造函数”中，了解到这会同时调用 Fraction(int, int) 和 Fraction拷贝构造函数 (出于性能原因，可能会省略)。但是，由于不能保证省略(在c++ 17之前，这种情况下省略是必须的)，所以最好避免拷贝类的初始化，而使用统一的初始化。其他地方使用拷贝初始化还有一些其他地方使用了复制初始化，但其中两个值得明确地提到。当按值传递或返回类时，使用拷贝初始化。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cassert&gt;#include &lt;iostream&gt; class Fraction&#123;private: int m_numerator; int m_denominator; public: // Default constructor Fraction(int numerator=0, int denominator=1) : m_numerator(numerator), m_denominator(denominator) &#123; assert(denominator != 0); &#125; // Copy constructor Fraction(const Fraction &amp;copy) : m_numerator(copy.m_numerator), m_denominator(copy.m_denominator) &#123; // no need to check for a denominator of 0 here since copy must already be a valid Fraction std::cout &lt;&lt; \"Copy constructor called\\n\"; // just to prove it works &#125; friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction &amp;f1); int getNumerator() &#123; return m_numerator; &#125; void setNumerator(int numerator) &#123; m_numerator = numerator; &#125;&#125;; std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction &amp;f1)&#123; out &lt;&lt; f1.m_numerator &lt;&lt; \"/\" &lt;&lt; f1.m_denominator; return out;&#125; Fraction makeNegative(Fraction f) // ideally we should do this by const reference&#123; f.setNumerator(-f.getNumerator()); return f;&#125; int main()&#123; Fraction fiveThirds(5, 3); std::cout &lt;&lt; makeNegative(fiveThirds); return 0;&#125;/*运行结果*/Copy constructor calledCopy constructor called-5/3第一个复制构造函数调用 发生在 fiveThirds作为参数传递给makeNegative()参数f的时候。第二个调用发生在makeNegative()的返回值被传递回main()的时候。","categories":[],"tags":[]},{"title":"C&C++/重载“下标”操作符","slug":"C&C++/重载“下标”操作符","date":"2020-05-10T13:40:11.470Z","updated":"2020-05-10T15:19:11.736Z","comments":true,"path":"archives/1f338417.html","link":"","permalink":"https://longlongqin.github.io/archives/1f338417.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/98-overloading-the-subscript-operator/123456789101112class IntList&#123;private: int m_list[10]&#123;&#125;;&#125;; int main()&#123; IntList list&#123;&#125;; // how do we access elements from m_list? return 0;&#125;因为m_list成员变量是私有的，我们不能直接从变量列表中访问它。这意味着我们无法直接获取或设置m_list数组中的值。那么我们如何获取或将元素放入我们的列表中呢?答：重载[]操作符重载[]操作符必须使用成员函数在这种情况下，更好的解决方案是重载下标操作符([])，以允许访问m_list的元素。下标操作符的重载必须使用成员函数版。重载运算符[]函数总是接受一个参数: 用户在硬括号之间放置的下标。在IntList的例子中，我们希望用户传入一个整数索引，并返回一个整数值作为结果。12345678910111213class IntList&#123;private: int m_list[10]&#123;&#125;; public: int&amp; operator[](int index);&#125;;int&amp; IntList::operator[](int index)&#123; return m_list[index];&#125;现在，每当我们在类的对象上使用下标操作符([])时，编译器将从m_list成员变量返回相应的元素!这允许我们直接获取和设置m_list的值:12345IntList list&#123;&#125;; list[2] = 3; // set a value std::cout &lt;&lt; list[2] &lt;&lt; '\\n'; // get a value return 0;从语法和理解的角度来看，这都很简单。 当list[2]计算时，编译器首先检查是否有重载的运算符[] 函数。如果有，它将方括号(本例中为2)中的值作为参数传递给函数。为什么操作符[]返回引用让我们仔细看看list[2] = 3是如何计算的。因为下标运算符具有比赋值运算符更高的优先级，所以list[2]首先计算。list[2]调用操作符[]，我们定义它来返回对list.m_list[2]的引用。因为操作符[]返回一个引用，所以它返回实际的list.m_list[2]数组元素。我们的部分求值表达式变成 list.m_list[2] = 3，这是一个简单的整数赋值。在1.3 – Introduction to variables中，您了解到赋值语句左边的任何值都必须是l-value(它是一个具有实际内存地址的变量)。因为运算符[]的结果可以在赋值语句的左边使用 (例如list[2] = 3)，所以运算符[]的返回值必须是l-value。事实证明，引用总是l-value，因为您只能引用具有内存地址的变量。所以通过返回一个引用，编译器就会确信我们返回的是一个l-value。当操作符[]按值 而不是按引用返回整数时考虑一下如果operator[] 按值 而不是 按引用返回整数 会发生什么？list[2]将调用操作符[]，它将返回list.m_list[2]的值。（例如，如果m_list[2]的值为6，操作符[]将返回值6。）list[2] = 3将会被执行为6=3这毫无意义! 如果你尝试这样做，c++编译器会抱怨:1C:VCProjectsTest.cpp(386) : error C2106: &#39;&#x3D;&#39; : left operand must be l-value处理const对象在上面的IntList例子中，操作符[]是非const的，我们可以使用它作为一个l-value来改变非const对象的状态。但是，如果我们的IntList对象是const呢?在这种情况下，我们将不能调用运算符[]的非const版本，因为这将允许我们潜在地更改const对象的状态。好消息是，我们可以分别定义运算符[]的非const版本和const版本。非const版本将与非const对象一起使用，而const版本与const对象一起使用。12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt; class IntList&#123;private: int m_list[10]&#123; 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;; // give this class some initial state for this example public: int&amp; operator[] (int index); const int&amp; operator[] (int index) const;&#125;; int&amp; IntList::operator[] (int index) // 对于非const对象: 可用于赋值&#123; return m_list[index];&#125; const int&amp; IntList::operator[] (int index) const // 对于const对象:只能用于访问&#123; return m_list[index];&#125; int main()&#123; IntList list&#123;&#125;; list[2] = 3; // okay: calls non-const version of operator[] std::cout &lt;&lt; list[2] &lt;&lt; '\\n'; const IntList clist&#123;&#125;; clist[2] = 3; // compile error: calls const version of operator[], which returns a const reference. 不能用于赋值 std::cout &lt;&lt; clist[2] &lt;&lt; '\\n'; return 0;&#125;指向对象的指针和重载操作符[]不能混淆如果试图在指向对象的指针上调用operator[]， c++会假定您正在尝试为该类型的对象数组建立索引。1234567891011121314151617181920212223242526#include &lt;cassert&gt; // for assert() class IntList&#123;private: int m_list[10]&#123;&#125;; public: int&amp; operator[] (int index);&#125;; int&amp; IntList::operator[] (int index)&#123; assert(index &gt;= 0 &amp;&amp; index &lt; 10); return m_list[index];&#125; int main()&#123; IntList *list&#123; new IntList&#123;&#125; &#125;; list [2] = 3; //错误:这将假设我们正在访问 IntLists数组中的索引为2的元素 delete list; return 0;&#125;因为我们不能将整数赋给IntList，所以这将无法编译。然而，如果分配一个整数是有效的，这将编译并运行，结果是未定义的。确保您没有试图在指向对象的指针上调用重载操作符[]。正确的语法应该是先取消对指针的引用(确保使用括号，因为运算符[]的优先级高于运算符)，*然后调用运算符[]**:12345678int main()&#123; IntList *list&#123; new IntList&#123;&#125; &#125;; (*list)[2] = 3; // get our IntList object, then call overloaded operator[] delete list; return 0;&#125;函数参数可以不是整数如上所述，C++将用户在中括号之间键入的内容作为参数传递给重载函数。在大多数情况下，这将是一个整数值。然而，这并不是必需的——事实上，您可以定义重载运算符[]取一个任意类型的值。您可以定义重载的运算符[]来接受double、std::string或其他任何您喜欢的内容。一个荒谬但是可以说明事实的例子：12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt; class Stupid&#123;private: public: void operator[] (const std::string&amp; index);&#125;; //重载运算符[]来打印一些东西是没有意义的//但是这是显示函数参数可以是非整数的最简单的方法void Stupid::operator[] (const std::string&amp; index)&#123; std::cout &lt;&lt; index;&#125; int main()&#123; Stupid stupid&#123;&#125;; stupid[\"Hello, world!\"]; return 0;&#125;/*结果*/Hello, world!重载操作符[]以获取std::string参数，在编写某些类型的类时非常有用，例如那些使用单词作为索引的类。小结通常重载下标运算符，以提供对类中包含的数组(或其他类似结构)中的单个元素的直接访问。因为字符串通常是作为字符数组实现的，所以操作符[]通常是在字符串类中实现的，以允许用户访问字符串的单个字符。","categories":[],"tags":[]},{"title":"C&C++/操作符重载","slug":"C&C++/操作符重载","date":"2020-05-10T00:31:00.633Z","updated":"2020-05-10T00:40:55.733Z","comments":true,"path":"archives/a193c39a.html","link":"","permalink":"https://longlongqin.github.io/archives/a193c39a.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/91-introduction-to-operator-overloading/在 7.6 – Function overloading中，您学习了函数重载，它提供了一种机制来创建和解析同名的多个函数的函数调用，只要每个函数有一个惟一的函数原型。在c++中，操作符被实现原理与函数相似。通过在操作符函数上使用函数重载，可以定义自己的操作符版本，这些操作符可以处理不同的数据类型(包括您编写的类)。使用函数重载来重载操作符称为操作符重载。当计算包含运算符的表达式时，编译器使用以下规则如果所有操作数都是基本数据类型，编译器将调用一个内置例程(如果存在)。如果不存在，编译器将产生一个编译器错误。如果所有操作数是用户数据类型(例如，您的一个类或枚举类型)，编译器将查看该类型是否具有可调用的匹配重载操作符函数。如果找不到，它将尝试将一个或多个用户定义的类型操作数转换为基本数据类型，以便使用匹配的内置操作符(通过重载的类型转换，我们将在本章后面介绍)。如果失败，则会产生编译错误。操作符重载的限制是什么?首先，C++中几乎所有现有的运算符都可能被重载。例外情况有:条件(? :)、sizeof、scope(::)、成员选择器(.)、成员指针选择器(.*)、typeid和转换操作符。其次，您只能重载现有的操作符。不能创建新操作符或重命名现有操作符。例如，您不能创建运算符**来做指数运算。第三，重载操作符中的至少一个操作数必须是用户定义的类型。这意味着不能重载加法运算符来处理一个整数和一个双精度数。但是，您可以重载plus操作符来处理整数和Mystring。第四，不可能更改操作符支持的操作数的数量。最后，所有操作符都保持它们的默认优先级和结合性(无论它们用于什么用途)，并且这是不可更改的。","categories":[],"tags":[]},{"title":"C&C++/匿名对象","slug":"C&C++/匿名对象","date":"2020-05-09T10:29:03.251Z","updated":"2020-05-09T13:36:55.006Z","comments":true,"path":"archives/b2f816aa.html","link":"","permalink":"https://longlongqin.github.io/archives/b2f816aa.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/814-anonymous-objects/在某些情况下，我们只需要一个临时变量。例如，考虑以下情况:1234567891011121314#include &lt;iostream&gt; int add(int x, int y)&#123; int sum = x + y; return sum;&#125; int main()&#123; std::cout &lt;&lt; add(5, 3); return 0;&#125;在函数add()中，请注意sum变量实际上仅用作临时占位符变量。它的作用不大——相反，它的唯一功能是将表达式的结果转换为返回值。匿名函数实际上，有一种更简单的方法可以使用匿名对象来编写add()函数。匿名对象本质上是一个没有名称的值。因为它们没有名称，所以除了它们被创建的地方之外，没有其他方法来引用它们。因此，它们具有“表达式范围”，这意味着它们是在一个表达式中创建、计算和销毁的。下面是使用匿名对象重写的add()函数:12345678910111213#include &lt;iostream&gt; int add(int x, int y)&#123; return x + y; // an anonymous object is created to hold and return the result of x + y&#125; int main()&#123; std::cout &lt;&lt; add(5, 3); return 0;&#125;当表达式x + y求值时，结果被放在一个匿名对象中。然后，通过值将匿名对象的副本返回给调用者，并销毁匿名对象。我们也可以在函数中使用它：123456789void printValue(int value)&#123; std::cout &lt;&lt; value;&#125;int main()&#123; printValue(5 + 3); //匿名对象 return 0;&#125;在本例中，计算表达式5 + 3以生成结果8，该结果放在匿名对象中。然后将这个匿名对象的副本传递给printValue()函数 (该函数打印值8)，然后销毁该对象。匿名类对象尽管我们前面的例子使用了内置的数据类型，但是也可以构造我们自己的类类型的匿名对象。这是通过创建像普通对象一样的对象来完成的，但是省略了变量名。12Cents cents(5); // normal variableCents(7); // anonymous object在上面的代码中，Cents(7)将创建一个匿名Cents对象，用值7初始化它，然后销毁它。在这种情况下，这对我们没有什么好处。所以，让我们来看一个例子，它可以很好地使用:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// main()函数将传递一个Cents对象(名为cents)给函数print()。#include &lt;iostream&gt; class Cents&#123;private: int m_cents; public: Cents(int cents) &#123; m_cents = cents; &#125; int getCents() const &#123; return m_cents; &#125;&#125;; void print(const Cents &amp;cents)&#123; std::cout &lt;&lt; cents.getCents() &lt;&lt; \" cents\";&#125; int main()&#123; Cents cents(6); print(cents); return 0;&#125;// 我们可以通过使用匿名对象来简化这个程序:#include &lt;iostream&gt; class Cents&#123;private: int m_cents; public: Cents(int cents) &#123; m_cents = cents; &#125; int getCents() const &#123; return m_cents; &#125;&#125;; void print(const Cents &amp;cents)&#123; std::cout &lt;&lt; cents.getCents() &lt;&lt; \" cents\";&#125; int main()&#123; print(Cents(6)); // ⭐Note: Now we're passing an anonymous Cents value return 0;&#125;结果：16 cents小结在c++中，匿名对象主要用于传递或返回值，而不需要创建大量临时变量。动态分配的内存也是匿名执行的 (这就是为什么它的地址必须分配给一个指针，否则我们将无法引用它)。同样值得注意的是，因为匿名对象具有表达式作用域，所以它们只能使用一次。如果需要在多个表达式中引用一个值，应该使用命名变量。注意: 一些编译器，例如Visual Studio，将允许您设置对匿名对象的非const引用。这是非标准行为。","categories":[],"tags":[]},{"title":"C&C++/友元函数与类","slug":"C&C++/友元函数与类","date":"2020-05-09T08:11:49.575Z","updated":"2020-05-09T10:26:14.700Z","comments":true,"path":"archives/e16eef53.html","link":"","permalink":"https://longlongqin.github.io/archives/e16eef53.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/813-friend-functions-and-classes/友元函数友元函数是一个可以访问类的私有成员的函数，就像它是该类的成员一样。除此之外，友元函数就像一个普通函数。友元函数可以是一个：普通函数，也可以是另一个类的成员函数。声明一个友元函数：只需在函数原型前使用friend关键字即可成为该类的好友。在类的private还是 public 声明friend函数并不重要。一个例子：123456789101112131415161718192021222324252627class Accumulator&#123;private: int m_value;public: Accumulator() &#123; m_value = 0; &#125; void add(int value) &#123; m_value += value; &#125; // 使reset()函数成为该类的friend⭐ [声明] friend void reset(Accumulator &amp;accumulator);&#125;;//reset()现在是Accumulator类的一个friend ⭐ [定义]void reset(Accumulator &amp;accumulator)&#123; //可以访问Accumulator对象的私有数据 accumulator.m_value = 0;&#125;int main()&#123; Accumulator acc; acc.add(5); reset(acc); return 0;&#125;因为reset()不是Accumulator类的成员，所以reset()通常不能访问Accumulator的私有成员。但是，因为Accumulator明确地声明了这个reset()函数是类的朋友，所以reset()函数被赋予了对Accumulator私有成员的访问权。注意：我们必须传递一个Accumulator对象给reset()。这是因为reset()不是一个成员函数。它没有*this指针，也没有要使用的Accumulator对象，除非给定一个。同一个函数可成为多个类的友元函数一个函数可以同时是多个类的朋友。例如，考虑下面的例子:123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt; class Humidity; //这是一个类原型，它告诉编译器我们将在将来定义一个名为Humidity的类。 class Temperature&#123;private: int m_temp;public: Temperature(int temp=0) &#123; m_temp = temp; &#125; friend void printWeather(const Temperature &amp;temperature, const Humidity &amp;humidity); //⭐&#125;; class Humidity&#123;private: int m_humidity;public: Humidity(int humidity=0) &#123; m_humidity = humidity; &#125; friend void printWeather(const Temperature &amp;temperature, const Humidity &amp;humidity); //⭐&#125;; void printWeather(const Temperature &amp;temperature, const Humidity &amp;humidity) //⭐&#123; std::cout &lt;&lt; \"The temperature is \" &lt;&lt; temperature.m_temp &lt;&lt; \" and the humidity is \" &lt;&lt; humidity.m_humidity &lt;&lt; '\\n';&#125; int main()&#123; Humidity hum(10); Temperature temp(12); printWeather(temp, hum); return 0;&#125;友元类也可以使整个类成为另一个类的friend。这使得friend类的所有成员都可以访问另一个类的私有成员。这里有一个例子:1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt; class Storage&#123;private: int m_nValue; double m_dValue;public: Storage(int nValue, double dValue) &#123; m_nValue = nValue; m_dValue = dValue; &#125; // 让 类Display 成为 类Storage 的friend ⭐ friend class Display; &#125;; class Display&#123;private: bool m_displayIntFirst; public: Display(bool displayIntFirst) &#123; m_displayIntFirst = displayIntFirst; &#125; void displayItem(const Storage &amp;storage) &#123; if (m_displayIntFirst) std::cout &lt;&lt; storage.m_nValue &lt;&lt; \" \" &lt;&lt; storage.m_dValue &lt;&lt; '\\n'; else // display double first std::cout &lt;&lt; storage.m_dValue &lt;&lt; \" \" &lt;&lt; storage.m_nValue &lt;&lt; '\\n'; &#125;&#125;; int main()&#123; Storage storage(5, 6.7); Display display(false); display.displayItem(storage); return 0;&#125;注意事项上面例子中，虽然 Display类 是 Storage类 的friend，但是Display没有直接访问Storage对象的*this指针。虽然 Display类 是 Storage类 的friend，但这并不意味着 Storage类 也是是 Display类 的friend。（如果想让这两个类互为friend，你必须在各自类中声明出来。）如果 类A 是 类B 的friend，而 类B是 类C 的friend，那并不意味着 类A是 类C 的friend。友元成员函数您可以使单个成员函数成为friend，而不是使整个类成为friend。除了使用包含className::前缀的成员函数名(例如Display::displayItem)之外，这与将普通函数作为friend类似。但是我们还需要注意：为了使成员函数成为friend，编译器必须看到friend成员函数所在类的完整定义(而不仅仅是一个向前声明)。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt; class Storage; // 提前声明 class Storage class Display&#123;private: bool m_displayIntFirst; public: Display(bool displayIntFirst) &#123; m_displayIntFirst = displayIntFirst; &#125; void displayItem(const Storage &amp;storage); // 此声明行需要前面的 提前声明&#125;; class Storage //类Storage 的完整定义&#123;private: int m_nValue; double m_dValue;public: Storage(int nValue, double dValue) &#123; m_nValue = nValue; m_dValue = dValue; &#125; //使Display::displayItem成员函数成为 //Storage类 的friend(需要查看类Display的完整声明，如下所示) friend void Display::displayItem(const Storage&amp; storage); //声明&#125;; //现在我们可以定义Display::displayItem，它需要查看 类Storage 的完整定义void Display::displayItem(const Storage &amp;storage) //定义&#123; if (m_displayIntFirst) std::cout &lt;&lt; storage.m_nValue &lt;&lt; \" \" &lt;&lt; storage.m_dValue &lt;&lt; '\\n'; else // display double first std::cout &lt;&lt; storage.m_dValue &lt;&lt; \" \" &lt;&lt; storage.m_nValue &lt;&lt; '\\n';&#125; int main()&#123; Storage storage(5, 6.7); Display display(false); display.displayItem(storage); return 0;&#125;现在一切都编译正确:1、提前声明 类Storage 足以满足 Display类中 Display::displayItem()的声明；2、Display类 的完整的定义 满足 Display::displayItem() 作为Storage 的friend；3、类Storage 的完整定义 满足 成员函数Display::displayItem() 的定义。如果这有点令人困惑，请参阅上面程序中的注释。也就是说：A类 的成员函数fun 要成为 B类 的友元函数：则：1、A类的定义 必须出现在 B类的定义之前 之前；将特定成员函数作为朋友需要首先看到成员函数所在的类的完整定义2、我们需要将 友元函数fun的声明 与 定义 分开进行。小结友元函数 或 友元类 是一个函数 或 类，它们可以访问另一个类的私有成员，就像它是这个类的成员一样。请注意，将特定成员函数作为朋友需要首先看到成员函数的类的完整定义。","categories":[],"tags":[]},{"title":"C&C++/静态成员变量","slug":"C&C++/静态成员变量","date":"2020-05-09T03:11:47.442Z","updated":"2020-05-09T08:08:36.511Z","comments":true,"path":"archives/bab62969.html","link":"","permalink":"https://longlongqin.github.io/archives/bab62969.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/812-static-member-functions/回顾关键字static在file scope and the static keyword中，您了解到静态变量保留它们的值，即使在它们超出作用域之后也不会被销毁。例如:123456789101112131415161718192021#include &lt;iostream&gt; int generateID()&#123; static int s_id&#123; 0 &#125;; return ++s_id;&#125; int main()&#123; std::cout &lt;&lt; generateID() &lt;&lt; '\\n'; std::cout &lt;&lt; generateID() &lt;&lt; '\\n'; std::cout &lt;&lt; generateID() &lt;&lt; '\\n'; return 0;&#125;/*结果*/123当应用于全局变量时，static关键字还有另一个含义——它为全局变量提供了内部链接 (这限制了它们在定义它们的文件之外被看到/使用)。因为通常会避免全局变量，所以静态关键字在这种功能中不经常使用。静态成员变量c++在应用于类时引入了static关键字的另外两种用途:静态成员变量和静态成员函数。幸运的是，这些用途相当简单。本节课我们将讨论静态成员变量，下节课我们将讨论静态成员函数。可以使用static关键字使类的成员变量变为静态。与普通成员变量不同，静态成员变量由类的所有对象共享。如：1234567891011121314151617181920212223class Something&#123;public: static int s_value; //⭐&#125;; int Something::s_value&#123; 1 &#125;; int main()&#123; Something first; Something second; first.s_value = 2; std::cout &lt;&lt; first.s_value &lt;&lt; '\\n'; std::cout &lt;&lt; second.s_value &lt;&lt; '\\n'; return 0;&#125;/*结果*/22静态成员不与类对象相关联尽管您可以通过类的对象访问静态成员 (如上面例子中first.s_value和second.s_value）。但是，即使没有实例化类的对象，静态成员仍然存在! 就像全局变量一样，它们在程序启动时创建，在程序结束时销毁。因此，最好认为静态成员属于类本身，而不是类的对象。因为s_value独立于任何类对象而存在，所以可以使用类名和范围解析操作符(在本例中是Something::s_value)直接访问它:1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;string&gt;class Something&#123;public: static int s_value; //声明静态成员变量&#125;;int Something::s_value&#123; 1 &#125;; //定义静态成员变量 (在下面会讨论)int main()&#123; //注意: 我们没有实例化任何类型的对象 Something::s_value = 2; std::cout &lt;&lt; Something::s_value; return 0;&#125;在上面的代码片段中，s_value是通过类名引用的，而不是通过对象引用的。注意，我们甚至还没有实例化类型为Something的对象，但是我们仍然能够访问和使用Something::s_value。这是访问静态成员的首选方法。定义和初始化静态成员变量当我们在一个类中声明一个静态成员变量时，我们是在告诉编译器一个静态成员变量的存在，而不是实际定义它(很像一个向前声明)。因为静态成员变量不是单个类对象的一部分(它们与全局变量的处理方式类似，并在程序启动时初始化)，所以必须在全局范围（类外部）内显式地定义静态成员。在上面的例子中，我们是这样做的:int Something::s_value{ 1 }; // defines the static member variable这一行有两个目的:它实例化静态成员变量(就像一个全局变量)，并选择性地初始化它。在本例中，我们提供初始值1。如果没有提供初始值设定项，c++会将值初始化为0。注意，这个静态成员定义不受访问控制的约束: 即使在类中声明为private(或protected)，也可以定义和初始化值。如果类是在.h文件中定义的，那么静态成员定义通常放在类的相关代码文件中(例如Something.cpp)。如果类是在.cpp文件中定义的，静态成员定义通常直接放在类的下面。不要将静态成员定义放在头文件中(很像全局变量，如果该头文件被包含多次，您将得到多个定义，这将导致编译错误)。静态成员变量的内联初始化上面有一些捷径。下面情况，静态成员可以直接在 类定义中 被初始化：第一，当静态成员是const 整型 (就包括char和bool) 或 const enum时：12345class Whatever&#123;public: static const int s_value &#123;4&#125;; //静态const int可以直接声明和初始化&#125;第二，静态的constexpr成员 可以在类定义中初始化:12345678#include &lt;array&gt;class Whatever&#123;public: static constexpr double s_value &#123;2.2&#125;; static constexpr std::array&lt;int, 3&gt; s_array&#123; 1, 2, 3 &#125;; &#125;静态成员函数原文：https://www.learncpp.com/cpp-tutorial/812-static-member-functions/在 8.11 – Static member variables中，您了解到静态成员变量是属于类的成员变量，而不是类的对象。如果静态成员变量是公共的，我们可以使用类名和范围解析操作符直接访问它们。但是如果静态成员变量是私有的呢？考虑下面的例子:12345678910111213class Something&#123;private: static int s_value; &#125;; int Something::s_value&#123; 1 &#125;; //初始化器，这是可以的，即使s_value是私有的，因为它是一个定义 int main()&#123; // how do we access Something::s_value since it is private?&#125;在这种情况下，我们不能直接从main()访问Something::s_value，因为它是私有的。通常我们通过公共成员函数访问私有成员。虽然我们可以创建一个普通的公共成员函数来访问s_value，但是我们需要实例化一个类类型的对象来使用这个函数! 我们可以做得更好。我们也可以让函数保持静态。与静态成员变量一样，静态成员函数不附加到任何特定对象。下面是上面静态成员函数访问器的例子:1234567891011121314class Something&#123;private: static int s_value;public: static int getValue() &#123; return s_value; &#125; // 静态成员函数&#125;; int Something::s_value&#123; 1 &#125;; // initializer int main()&#123; std::cout &lt;&lt; Something::getValue() &lt;&lt; '\\n'; //⭐&#125;因为静态成员函数没有附加到特定的对象，所以可以使用类名和范围解析操作符(::)直接调用它们。与静态成员变量一样，也可以通过类 类型的对象调用它们，但不建议这样做。静态成员函数没有*this指针静态成员函数有两个有趣的特性值得注意。首先，因为静态成员函数没有附加到对象上，所以它们没有this指针! ——this指针总是指向成员函数正在处理的对象。静态成员函数不处理对象，因此不需要此指针。其次，静态成员函数可以直接访问其他静态成员 (变量或函数)，但不能访问非静态成员。——这是因为非静态成员必须属于一个类对象，而静态成员函数没有可以使用的类对象!静态成员函数也可以在类声明之外定义静态成员函数也可以在类声明之外定义。这与普通成员函数的工作方式相同。123456789101112131415161718192021222324252627class IDGenerator&#123;private: static int s_nextID; // 这是一个静态成员的声明 public: static int getNextID(); // 这是一个静态函数的声明&#125;;// 下面是类外部的 静态成员的定义。注意，**在这里不需要使用static关键字**。int IDGenerator::s_nextID&#123; 1 &#125;;int IDGenerator::getNextID() &#123; return s_nextID++; &#125;int mian()&#123; for (int count&#123; 0 &#125;; count &lt; 5; ++count) std::cout &lt;&lt; \"The next ID is: \" &lt;&lt; IDGenerator::getNextID() &lt;&lt; '\\n'; return 0;&#125;/*结果*/The next ID is: 1The next ID is: 2The next ID is: 3The next ID is: 4The next ID is: 5注意，因为这个类中的所有数据和函数都是静态的，所以我们不需要实例化这个类的对象来使用它的功能! 该类利用一个静态成员变量来保存下一个要分配的ID的值，并提供一个静态成员函数来返回该ID并对其进行递增。c++不支持静态构造函数如果您可以通过构造函数初始化普通成员变量，那么通过扩展，您应该能够通过静态构造函数初始化静态成员变量，这是有意义的。尽管一些现代语言确实支持静态构造函数，但遗憾的是c++不是其中之一。如果可以直接初始化静态变量，则不需要构造函数: 我们可以直接在定义点初始化静态成员变量(即使它是私有的)。我们在上面的IDGenerator示例中执行此操作。这是另一个例子:1234567class MyClass&#123;public: static std::vector&lt;char&gt; s_mychars;&#125;; std::vector&lt;char&gt; MyClass::s_mychars&#123; 'a', 'e', 'i', 'o', 'u' &#125;; // 在定义点初始化静态变量如果初始化 静态成员变量 需要执行代码(例如，循环)，那么有许多不同的、有些笨拙的方法可以做到这一点。一种处理所有变量的方法，不管是否是静态的，都是使用一个lambda并立即调用它。123456789101112131415161718class MyClass&#123;private: static std::vector&lt;char&gt; s_mychars;&#125;;std::vector&lt;char&gt; Myclass::s_mychars&#123; []&#123; // 在lambda内部，我们可以声明另一个向量并使用循环。 std::vector&lt;char&gt; v&#123;&#125;; for (char ch&#123; 'a' &#125;; ch &lt;= 'z'; ++ch) &#123; v.push_back(ch); &#125; return v; &#125;() // 马上调用lambda使用静态成员要小心使用所有成员都是静态的类时要小心。尽管这种“纯静态类”(也称为“单状态”)可能很有用，但它们也有一些潜在的缺点。首先，因为所有静态成员只实例化一次，所以不可能有一个纯静态类的多个副本 (在 不克隆类并重命名它的情况下)。例如，如果您需要两个独立的IDGenerator对象，这对于单个纯静态类来说是不可能的。第二，在关于全局变量的课程中，您了解到全局变量是危险的，因为任何一段代码都可能改变全局变量的值，并最终破坏另一段看起来不相关的代码。对于纯静态类也是如此。因为所有成员都属于类(而不是类的对象)，而且类声明通常具有全局作用域，所以纯静态类本质上相当于 在全局可访问的命名空间中声明函数和全局变量，具有全局变量所具有的所有必需的缺点。","categories":[],"tags":[]},{"title":"C&C++/常量类对象及成员函数","slug":"C&C++/常量类对象及成员函数","date":"2020-05-08T16:22:50.511Z","updated":"2020-05-09T03:10:03.003Z","comments":true,"path":"archives/156886df.html","link":"","permalink":"https://longlongqin.github.io/archives/156886df.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/810-const-class-objects-and-member-functions/在 4.13 – Const, constexpr, and symbolic constants中，您学习了基本数据类型(int, double, char，等等)可以通过const关键字变为静态，并且所有Const变量必须在创建时初始化。在const基本数据类型的情况下，可以通过复制、直接或统一初始化来进行初始化:123const int value1 = 5; // copy initializationconst int value2(7); // direct initializationconst int value3 &#123; 9 &#125;; // uniform initialization (C++11)常量类类似地，实例化的类对象也可以通过使用const关键字 来生成const。初始化是通过类构造函数完成的:123const Date date1; // initialize using default constructorconst Date date2(2020, 10, 16); // initialize using parameterized constructorconst Date date3 &#123; 2020, 10, 16 &#125;; // initialize using parameterized constructor (C++11)一旦通过构造函数初始化了const类对象，任何修改对象成员变量的尝试都是不允许的，因为这会违反对象的const属性。“修改”既包括直接更改成员变量(如果它们是公共的)，也包括调用设置成员变量值的成员函数。如：1234567891011121314151617181920class Something&#123;public: int m_value; Something(): m_value(0) &#123; &#125; void setValue(int value) &#123; m_value = value; &#125; int getValue() &#123; return m_value ; &#125;&#125;; int main()&#123; const Something something; // calls default constructor something.m_value = 5; //✖ compiler error: violates const something.setValue(5); //✖ compiler error: violates const return 0;&#125;常量成员函数const类对象只能显式地调用const成员函数请看下面的语句：1std::cout &lt;&lt; something.getValue();也许令人惊讶的是，这也会导致一个编译错误，即使getValue()不做任何改变成员变量的事情!结果是，const类对象只能显式地调用const成员函数，而getValue()没有被标记为const成员函数。书写格式const成员函数是一个成员函数，它保证不会： 修改对象或 调用任何非const成员函数(因为它们可能修改对象)。常量成员函数 在类定义之中 定义要使getValue()成为const成员函数，我们只需将const关键字添加到函数原型中，在参数列表之后，但在函数体之前:12345678910111213class Something&#123;public: int m_value; Something(): m_value(0) &#123; &#125; void resetValue() &#123; m_value = 0; &#125; void setValue(int value) &#123; m_value = value; &#125; int getValue() const &#123;return m_value;&#125; //⭐注意:const关键字添加在参数列表之后，但是在函数体之前&#125;;常量成员函数 在类定义之外 定义对于定义在类定义之外的成员函数，必须在 类定义中的函数原型 和 函数定义上 使用const关键字:1234567891011121314151617class Something&#123;public: int m_value; Something(): m_value(0) &#123; &#125; void resetValue() &#123; m_value = 0; &#125; void setValue(int value) &#123; m_value = value; &#125; int getValue() const; //⭐ 注意这里添加了const关键字&#125;; int Something::getValue() const // ⭐这里也添加关键字const&#123; return m_value;&#125;此外，任何试图更改成员变量或调用非const成员函数 的 const成员函数 都会导致编译器错误。例如:1234567class Something&#123;public: int m_value ; void resetValue() const &#123; m_value = 0; &#125; // 编译错误, const成员函数不能修改成员变量&#125;;构造函数不能是const注意，构造函数不能标记为const。这是因为构造函数需要能够初始化它们的成员变量，而const构造函数则不能这样做。因此，不允许const构造函数。常量引用尽管实例化const类对象是创建const对象的一种方法，但更常见的方法是通过const引用将一个对象传递给一个函数。在关于 passing arguments by reference中，我们讨论了通过const引用而不是通过值传递类参数的优点。总而言之，通过值传递类参数会导致生成类的副本(这比较慢)——大多数时候，我们不需要副本，对原始参数的引用可以很好地工作，而且更有性能，因为它避免了不必要的副本。我们通常使用引用const，以确保函数不会在不经意间更改参数，并允许函数处理r-value(例如文字)，这些r-value可以作为const引用传递，但不能作为非const引用。不能在const对象上调用非const成员函数您能找出以下代码的错误吗?12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt; class Date&#123;private: int m_year; int m_month; int m_day; public: Date(int year, int month, int day) &#123; setDate(year, month, day); &#125; void setDate(int year, int month, int day) &#123; m_year = year; m_month = month; m_day = day; &#125; int getYear() &#123; return m_year; &#125; int getMonth() &#123; return m_month; &#125; int getDay() &#123; return m_day; &#125;&#125;; void printDate(const Date &amp;date)&#123; std::cout &lt;&lt; date.getYear() &lt;&lt; \"/\" &lt;&lt; date.getMonth() &lt;&lt; \"/\" &lt;&lt; date.getDay() &lt;&lt; '\\n';&#125;int main()&#123; Date date(2016, 10, 16); printDate(date);&#125;答案是，在printDate函数内部，date被视为一个const对象。使用这个常量 date，我们调用函数getYear()、getMonth()和getDay()，它们都是非const的。因为我们不能在const对象上调用非const成员函数，这将导致编译错误。解决方法：使getYear()、getMonth()和getDay()这些函数成为 const:1234567891011121314151617181920212223242526class Date&#123;private: int m_year; int m_month; int m_day; public: Date(int year, int month, int day) &#123; setDate(year, month, day); &#125; // setDate() cannot be const, modifies member variables void setDate(int year, int month, int day) &#123; m_year = year; m_month = month; m_day = day; &#125; // The following getters can all be made const⭐ int getYear() const &#123; return m_year; &#125; int getMonth() const &#123; return m_month; &#125; int getDay() const &#123; return m_day; &#125;&#125;;重载const和非const函数最后，虽然不经常这样做，但有可能重载一个函数，使其具有同一个函数的const和非const版本:12345678910111213141516#include &lt;iostream&gt;class Something&#123;private: std::string m_value; public: Something(const std::string &amp;value=\"\") &#123; m_value= value; &#125; // ⭐用于const对象的getValue() const std::string&amp; getValue() const &#123;return m_value;&#125; //⭐⭐⭐ // ⭐用于非const对象的getValue() std::string&amp; getValue() &#123;return m_value;&#125;&#125;;const std::string&amp; getValue() const {return m_value;}最左边的const是函数返回类型的一部分，表示返回了一个const引用。最右边的const表示成员函数自身是const。这意味着它不会改变对象的状态，并且可以被const类的对象调用。函数的const版本将在任何const对象上调用，而非const版本将在任何非const对象上调用:12345678int main()&#123; Something something; something.getValue() = \"Hi\"; // calls non-const getValue(); const Something something2; something2.getValue(); // calls const getValue(); &#125;使用const和非const版本的函数重载通常是在返回值需要在稳定性上有所不同时完成的。在上面的例子中：getValue()的非const版本将只与非const对象一起工作，但是更加灵活，因为我们可以使用它来读写m_value(通过分配字符串“Hi”来完成)。getValue()的const版本既可以使用const对象，也可以使用非const对象，但是返回一个const引用，以确保我们不能修改const对象的数据。","categories":[],"tags":[]},{"title":"C&C++/类的代码与头文件","slug":"C&C++/类的代码与头文件","date":"2020-05-08T15:43:56.376Z","updated":"2020-05-08T16:21:30.766Z","comments":true,"path":"archives/8605edc6.html","link":"","permalink":"https://longlongqin.github.io/archives/8605edc6.html","excerpt":"","text":"在类定义之外定义成员函数随着类变得越来越长、越来越复杂，在类中包含所有成员函数定义会使类更难管理和使用。使用一个已经编写好的类只需要了解它的公共接口(公共成员函数)，而不需要了解类的底层工作方式。成员函数实现的细节只是一个障碍。幸运的是，c++提供了一种将类的“声明”部分与“实现”部分分离的方法。这是通过在类定义之外定义类成员函数来实现的。要做到这一点，只需定义类的成员函数，就像它们是普通函数一样，但是要使用范围解析操作符(::)将类名作为函数的前缀(与名称空间相同)。一个例子：请注意，这些函数的原型仍然存在于类定义中，但是实际的实现已经移到了类定义之外123456789101112131415161718192021222324252627282930class Date&#123;private: int m_year; int m_month; int m_day; public: Date(int year, int month, int day); void SetDate(int year, int month, int day); int getYear() &#123; return m_year; &#125; int getMonth() &#123; return m_month; &#125; int getDay() &#123; return m_day; &#125;&#125;; // Date constructorDate::Date(int year, int month, int day)&#123; SetDate(year, month, day);&#125; // Date member functionvoid Date::SetDate(int year, int month, int day)&#123; m_month = month; m_day = day; m_year = year;&#125;将类定义放在头文件中在有关头文件的课程中 (header files) ，您了解到可以将函数声明放在头文件中，以便在多个文件甚至多个项目中使用这些函数。类定义也可以放在头文件中，以便于在多个文件或多个项目中重用。传统上，类定义放在与类同名的头文件中，类外部定义的成员函数放在与类同名的.cpp文件中。如：Date.h:123456789101112131415161718192021#ifndef DATE_H#define DATE_H class Date&#123;private: int m_year; int m_month; int m_day; public: Date(int year, int month, int day); void SetDate(int year, int month, int day); int getYear() &#123; return m_year; &#125; int getMonth() &#123; return m_month; &#125; int getDay() &#123; return m_day; &#125;&#125;; #endifDate.cpp:123456789101112131415#include \"Date.h\" // Date constructorDate::Date(int year, int month, int day)&#123; SetDate(year, month, day);&#125; // Date member functionvoid Date::SetDate(int year, int month, int day)&#123; m_month = month; m_day = day; m_year = year;&#125;现在，任何其他想要使用Date类的头文件或代码文件都可以简单地#include &quot;Date.h&quot;。注意，data .cpp还需要编译到任何使用Date.h的项目中，以便链接器知道如何实现Date。在头文件中定义类是否违反了one-definition规则?这是不应该的。如果您的头文件具有适当的头保护，则不应该在同一个文件中多次包含类定义。类型(包括类)不受one-definition规则的约束，该规则规定每个程序只能有一个定义。因此，在多个代码文件中包含类定义并没有问题(如果有的话，类也没有多大用处)。在头文件中定义成员函数是否违反了one-definition规则?视情况而定。在类定义中 定义的成员函数被认为是隐式内联的。内联函数不受one-definition规则中每个程序的一个定义的约束。这意味着在类定义本身内部定义普通的成员函数(例如访问函数)是没有问题的。在类定义之外定义的成员函数被视为普通函数，并且受一个定义规则中每个程序部分的一个定义的约束。因此，这些函数应该在代码文件(.cpp)中定义，而不是在头文件中定义。唯一的例外是模板函数，我们将在以后的章节中讨论。应该在头文件和cpp文件中定义什么，在类定义的内部 和 外部 定义什么?您可能会试图将所有成员函数定义放入类内的头文件中。虽然这将编译，但这样做有几个缺点：首先，如上所述，这会使类定义变得混乱。类中定义的函数是隐式内联的。对于从许多地方调用的大型函数，这会使代码膨胀。第三，如果您更改了头文件的代码，那么您需要重新编译包含该头文件的每个文件。这可能会产生连锁反应，一个微小的更改就会导致整个程序需要重新编译(这可能很慢)。(但是，你更改.cpp文件，编译器只会重新编译改动过的 .cpp文件)因此，我们建议如下:对于 仅在一个通常不重用的文件 中使用的类，直接在使用它们的单个.cpp文件中定义它们。对于在多个文件中使用的类，或者用于一般重用的类，请在与类同名的.h文件中定义它们。普通成员函数(普通构造函数或析构函数、访问函数等)可以在类中定义。非普通成员函数应该在与类同名的.cpp文件中定义。成员函数的默认参数应该在类定义中声明(头文件中)成员函数的默认参数应该在类定义中声明(在头文件中)，在那里任何人都可以看到#includes 这个头文件。库分离类定义和类实现对于可用于扩展程序的库非常常见。在您的整个程序中，你已经#included 许多标准的库，如iostream, string, vector, array等等。您的程序需要头文件的声明，以便编译器验证您正在编写的程序在语法上是正确的。注意，您不需要添加 iostream.cpp, string.cpp, vector.cpp, or array.cpp 到你的程序中。但是，属于c++标准库的类的实现包含在一个预编译文件中，该文件在链接阶段被链接进来。你永远看不到代码。除了一些开源软件(同时提供.h和.cpp文件)之外，大多数第三方库只提供头文件和预编译的库文件。这有几个原因：链接预编译的库比每次需要时重新编译要快；预编译库的单个副本可以被许多应用程序共享，而编译后的代码被编译到使用它的每个可执行文件中(增大文件大小)。知识产权原因(您不希望别人窃取您的代码)。将您自己的文件分隔为声明(头文件)和实现(代码文件)不仅是一种良好的形式，而且还使创建您自己的自定义库更加容易。创建自己的库超出了本教程的范围，但是将声明和实现分离是这样做的先决条件。","categories":[],"tags":[]},{"title":"C&C++/隐藏的“this”指针","slug":"C&C++/隐藏的“this”指针","date":"2020-05-08T14:11:56.836Z","updated":"2020-05-08T15:41:29.853Z","comments":true,"path":"archives/7d6924a1.html","link":"","permalink":"https://longlongqin.github.io/archives/7d6924a1.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/8-8-the-hidden-this-pointer/新的面向对象程序员经常问的一个关于类的问题是，“当一个成员函数被调用时，c++如何跟踪它被调用的对象?”答案是：C++使用了一个名为“this”的隐藏指针! 让我们更详细地看看“this”。下面是一个简单的类，它保存一个整数并提供一个构造函数和访问函数。注意，不需要析构函数，因为c++可以为我们清理整数成员变量。1234567891011121314class Simple&#123;private: int m_id; public: Simple(int id) &#123; setID(id); &#125; void setID(int id) &#123; m_id = id; &#125; int getID() &#123; return m_id; &#125;&#125;;下面是一个使用这个类的示例程序:1234567891011int main()&#123; Simple simple(1); simple.setID(2); std::cout &lt;&lt; simple.getID() &lt;&lt; '\\n'; return 0;&#125;/*结果*/2当我们调用simple.setID(2);时，c++知道setID()函数应该对simple对象进行操作，m_id实际上指的是simple.m_id。让我们研究一下这背后的机制。隐藏的*this指针看看上面例子中的代码行:1simple.setID(2);尽管对setID()函数的调用看起来只有一个参数，但实际上它有两个! 在编译时，编译器将转换simple.setID(2);为：1setID(&amp;simple, 2); //注意，simple已经从一个对象前缀 更改为一个函数参数!注意，这现在只是一个标准的函数调用，而 simple对象 (以前是一个对象前缀) 现在通过 地址传递 作为函数的参数。但这只是答案的一半。由于函数调用现在添加了一个新的的参数，因此需要修改成员函数定义，以接受(并使用)这个参数作为参数。因此，有以下成员函数:1234void setID(int id) &#123; m_id = id; &#125;//被转换为：⭐void setID(Simple* const this, int id) &#123;this-&gt;m_id = id;&#125;当编译器编译一个普通成员函数时，它会隐式地向函数添加一个名为“this”的新参数。this指针是一个隐藏的const指针，它保存成员函数所调用的对象的地址。还有一个细节要处理。在成员函数内部，还需要更新任何类成员(函数和变量)，以便它们引用调用成员函数的对象。这很容易做到，只要在每一个前面加上“this -&gt;”就可以了。因此，在setID()函数体中，m_id(它是一个类成员变量)被转换为this-&gt;m_id。因此，当“this”指向simple的地址时， this-&gt;m_id将解析为simple. m_id。综上所述：当我们调用simple.setID(2)，编译器实际上调用 setID(&amp;simple, 2)在setID()中，“this”指针保存了 对象simple 的地址。setID()中的任何成员变量都以“this-&gt;”作为前缀。所以当我们说m_id = id时，编译器实际上是在执行this-&gt;m_id = id，在本例中将 simple.m_id 转换为 id。好消息是，所有这些都是自动发生的，不管你是否记得它是如何工作的。您需要记住的是，所有普通成员函数都有一个“this”指针，该指针指向函数所调用的对象。“this”总是指向被操作的对象新程序员有时会对存在多少“this”指针感到困惑。每个成员函数都有一个“this”指针参数，该参数被设置为正在操作的对象的地址。请看:123456789int main()&#123; Simple A(1); // this = &amp;A 在 Simple 构造函数的内部 Simple B(2); // this = &amp;B 在 Simple 构造函数的内部 A.setID(3); // this = &amp;A 在成员函数 setID 的内部 B.setID(4); // this = &amp;B 在成员函数 setID 的内部 return 0; &#125;注意，“this”指针交替保存对象A或B的地址，这取决于我们是否在对象A或B上调用了成员函数。“this”是一个参数，它存放于栈中因为“this”只是一个函数参数，它不会向您的类添加任何内存使用 (只会添加到成员函数调用，因此该参数在函数执行时在栈上运行)。显式地引用“this”大多数时候，您不需要显式地引用“this”指针。但是，在某些情况下这样做是有用的:首先，如果你有一个构造函数(或成员函数)，它有一个与成员变量同名的参数，你可以使用“this”来消除它们的歧义:12345678910class Something&#123;private: int data;public: Something(int data) &#123; this-&gt;data = data; // this-&gt;data是成员变量，data是本地参数 &#125; &#125;;请注意，我们的构造函数接受同名的参数作为成员变量。在本例中，“data”指的是参数，“this-&gt;data”指的是成员变量。虽然这是可接受的编码实践，但我们发现在所有成员变量名上使用“m_”前缀提供了更好的解决方案，它完全防止了重复的名称!有些开发人员喜欢显式地将这个-&gt;添加到所有类成员中。我们建议您避免这样做，因为这样做会降低代码的可读性，并且没有什么好处。使用m_前缀是区分成员变量和非成员(本地)变量的一种更具可读性的方法。链接成员函数其次，有时让类成员函数返回它正在处理的对象作为返回值是有用的。这样做的主要原因是允许将一系列成员函数“链接”在一起，这样就可以在同一个对象上调用多个成员函数!其实你已经这样做了很长时间了。考虑下面这个常见的示例，在这个示例中，您使用std::cout输出了多于一位的文本:1234std::cout &lt;&lt; \"Hello, \" &lt;&lt; userName;//上面的代码，std::cout是一个对象，而操作符&lt;&lt;是操作该对象的成员函数。编译器像这样计算上面的代码片段:(std::cout &lt;&lt; \"Hello, \") &lt;&lt; userName;首先，操作符&lt;&lt; 使用std::cout和字符串文字“Hello，”将“Hello”打印到控制台。但是，由于这是表达式的一部分，操作符&lt;&lt;也需要返回一个值(或void)。如果操作符&lt;&lt;返回void，您将得到以下结果:123456(void) &lt;&lt; userName;//这显然没有任何意义(并且编译器会抛出一个错误)。//相反，操作符&lt;&lt;返回 *this，在这个上下文中是std::cout对象。//这样，在第一个运算符&lt;&lt;被求值后，我们得到:(std::cout) &lt;&lt; userName;这样，我们只需要指定对象一次(在本例中是std::cout)，每个函数调用都会将其传递给下一个要使用的函数，从而允许我们将多个命令链接在一起。我们可以自己实现这种行为：1234567891011121314class Calc&#123;private: int m_value; public: Calc() &#123;m_value = 0;&#125; void add(int value) &#123; m_value += value; &#125; void sub(int value) &#123; m_value -= value; &#125; void mult(int value) &#123; m_value *= value; &#125; int getValue() &#123; return m_value; &#125;&#125;;如果你想加5，减3，再乘以4，你必须这样做:1234567891011#include &lt;iostream&gt;int main()&#123; Calc calc; calc.add(5); // returns void calc.sub(3); // returns void calc.mult(4); // returns void std::cout &lt;&lt; calc.getValue() &lt;&lt; '\\n'; return 0;&#125;但是，如果我们让每个函数返回*this，我们可以将这些调用链接在一起。以下是新版本的Calc与“链”功能:1234567891011121314class Calc&#123;private: int m_value; public: Calc() &#123; m_value = 0; &#125; Calc&amp; add(int value) &#123;m_value += value; return *this;&#125; Calc&amp; sub(int vaule) &#123;m_value -= value; return *this;&#125; Calc&amp; mult(int value) &#123; m_value *= value; return *this; &#125; int gerValue() &#123;return m_value;&#125;&#125;;注意，add()、sub()和mult()现在返回*this。因此，这使我们能够做到以下几点:123456789#include &lt;iostream&gt;int main()&#123; Calc calc; calc.add(5).sub(3).mult(4); //⭐ std::cout &lt;&lt; calc.getValue() &lt;&lt; '\\n'; return 0;&#125;我们已经有效地将三行压缩成一个表达式! 让我们仔细看看它是如何工作的。首先，calc.add(5)被调用。它给m_value.add ()增加5，然后返回*this，它只是calc的一个引用。因此，calc将是后续计算中使用的对象。然后，calc.sub(3)被执行。从m_value中减去3，再次返回calc。最后，执行calc.mult(4)将m_value乘以4，然后返回calc。（它没有进一步使用，因此被忽略。）由于每个函数在执行时都会修改calc，所以calc的m_value现在包含值((((0 + 5)- 3)* 4)，即8。小结“this”指针是隐式添加到任何非静态成员函数的隐藏参数。大多数情况下，您不需要直接访问它。但是如果需要，您可以访问它。值得注意的是“this”是一个const指针——即，您可以更改它所指向的底层对象的值，但是您不能让它指向其他对象!","categories":[],"tags":[]},{"title":"C&C++/析构函数","slug":"C&C++/析构函数","date":"2020-05-08T13:11:26.018Z","updated":"2020-05-08T14:10:54.157Z","comments":true,"path":"archives/db2095e5.html","link":"","permalink":"https://longlongqin.github.io/archives/db2095e5.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/8-7-destructors/析构函数(Destructors)是另一种特殊的类成员函数，它在类的对象被销毁时执行。构造函数的设计目的是初始化类；而析构函数的设计目的是帮助清理类。当一个对象通常超出作用域，或者使用delete关键字显式删除动态分配的对象时，会自动调用类析构函数(如果存在的话)，以便在从内存中删除对象之前进行任何必要的清理。对于简单的类 (那些只初始化普通成员变量值的类)，不需要析构函数，因为c++会自动为您清理内存。然而,如果你的类对象持有任何资源 (如动态内存,或处理的文件或数据库) ,或者如果你需要做任何维护对象被摧毁之前, 析构函数是完美的地方，因为它通常是发生在对象被销毁之前的最后一件事。析构函数的命名和构造函数一样，析构函数也有特定的命名规则：析构函数必须具有与类相同的名称，前面有一个波浪号(~)。析构函数不能接受参数。析构函数没有返回类型。注意，规则2意味着每个类只能存在一个析构函数，因为没有重载析构函数的方法（因为它们不能根据参数彼此区分。）通常，您不应该显式地调用析构函数(因为当对象被销毁时，会自动调用它)，因为很少有需要多次清理对象的情况。然而，析构函数可以安全地调用其他成员函数，因为对象直到析构函数执行后才会被销毁。来看一个例子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;cassert&gt;#include &lt;cstddef&gt;class IntArray&#123;public: IntArray(int length) //构造函数 &#123; assert(length &gt; 0); m_array = new int[static_cast&lt;std::size_t&gt;(length)]&#123;&#125;; m_length = length; &#125; ~IntArray() //析构函数 &#123; //动态删除我们之前分配的数组 delete[] m_array; &#125; void setValue(int index, int value) &#123; m_array[index] = value; &#125; int getValue(int index) &#123; return m_array[index]; &#125; int getlength() &#123; return m_length; &#125;protected:private: int* m_array; int m_length;&#125;;int main()&#123; IntArray arr&#123; 10 &#125;; for (int count&#123; 0 &#125;; count &lt; arr.getlength(); count++) &#123; arr.setValue(count, count + 1); &#125; std::cout &lt;&lt; \"The value of element 5 is: \" &lt;&lt; arr.getValue(5) &lt;&lt; '\\n'; std::cin.clear(); std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n'); std::cin.get(); return 0;&#125; //类ar在这里被销毁，所以，析构函数~IntArray() 在这里被调用在第一行，我们实例化一个名为ar的新IntArray类对象，并传入一个长度为10的值。它调用构造函数，构造函数动态地为数组成员分配内存。我们必须在这里使用动态分配，因为在编译时我们不知道数组的长度是多少(调用者决定)。在main()的末尾，ar超出了范围。这将导致调用~IntArray()析构函数，它将删除我们在构造函数中分配的数组!进一步看构造、析构 函数被调用的时间如前所述，在创建对象时调用构造函数，在销毁对象时调用析构函数。在下面的例子中，我们在构造函数和析构函数中使用std::cout语句来说明这一点:12345678910111213141516171819202122232425262728293031323334353637class Simple&#123;private: int m_nID; public: Simple(int nID) : m_nID&#123; nID &#125; &#123; std::cout &lt;&lt; \"Constructing Simple \" &lt;&lt; nID &lt;&lt; '\\n'; &#125; ~Simple() &#123; std::cout &lt;&lt; \"Destructing Simple\" &lt;&lt; m_nID &lt;&lt; '\\n'; &#125; int getID() &#123; return m_nID; &#125;&#125;;int main()&#123; // 在栈上分配一个Simple Simple simple&#123; 1 &#125;; std::cout &lt;&lt; simple.getID() &lt;&lt; '\\n'; // 动态分配一个Simple Simple *pSimple&#123; new Simple&#123; 2 &#125; &#125;; std::cout &lt;&lt; pSimple-&gt;getID() &lt;&lt; '\\n'; // 我们动态地分配了pSimple，所以我们必须删除它。 //⭐【不推荐】请看下面的RAII中的讲解:\"规则: 如果您的类动态分配内存，请使用RAII范型，不要动态分配类的对象 \" delete pSimple; //在这里调用了析构函数 return 0;&#125; // simple goes out of scope here 再次调用析构函数这个程序产生以下结果:123456Constructing Simple 11Constructing Simple 22Destructing Simple 2Destructing Simple 1注意，“Simple 1”在“Simple 2”之后被销毁，因为我们在函数结束之前删除了pSimple，而Simple直到main()结束才被销毁。全局变量在main()之前构造，在main()之后销毁。RAII*RAII(资源获取即初始化) *是一种编程技术，通过自动持续时间(例如，非动态分配的对象)将资源使用绑定到对象的生存期。在c++中，RAII是通过具有 构造函数 和 析构函数 的类实现的。资源 (如内存、文件或数据库句柄等) 通常是在对象的构造函数中获得的(不过如果有意义的话，也可以在创建对象之后获得)。然后，可以在对象处于活动状态时使用该资源。当对象被销毁时，资源在析构函数中释放。RAII的主要优点是它有助于防止资源泄漏(例如内存未释放)，因为所有资源持有对象都被自动清除。本课顶部的IntArray类是一个实现RAII的类的例子——在构造函数中实现分配，在析构函数中实现释放。std::string和std::vector是标准库中遵循RAII的类的示例——动态内存在初始化时获得，在销毁时自动清除。规则:如果您的类动态分配内存，请使用RAII范型，不要动态分配类的对象小结：正如您所看到的，当构造函数和析构函数一起使用时，您的类可以在它们自己之后初始化和清理，而程序员不需要做任何特殊的工作! 这减少了出错的可能性，并使类更易于使用。","categories":[],"tags":[]},{"title":"C&C++/函数功能重叠--委托函数","slug":"C&C++/函数功能重叠--委托函数","date":"2020-05-08T10:35:55.356Z","updated":"2020-05-08T13:10:53.144Z","comments":true,"path":"archives/8dd10d3c.html","link":"","permalink":"https://longlongqin.github.io/archives/8dd10d3c.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/8-6-overlapping-and-delegating-constructors/Overlapping含有重叠功能的构造函数当实例化一个新对象时，对象的构造函数被C++编译器隐式地调用。拥有多个具有重叠功能的构造函数的类并不少见。考虑以下类别:12345678910111213141516//该类有两个构造函数:一个默认构造函数和一个接受整数的构造函数。因为构造函数的“执行代码”部分是两个构造函数都需要的，所以代码在每个构造函数中重复。class Foo&#123;public: Foo() &#123; // code to do A &#125; Foo(int value) &#123; // code to do A // code to do B &#125;&#125;;正如您(希望)已经了解到的，尽可能避免出现重复的代码，所以让我们来看看解决这个问题的一些方法。解决重叠功能部分显而易见的解决方案在c++ 11之前是行不通的最明显的解决方案是让Foo(int)构造函数调用Foo()构造函数来执行A部分。1234567891011121314class Foo&#123;public: Foo() &#123; // code to do A &#125; Foo(int value) &#123; Foo(); // 使用上面的构造函数执行A(不起作用) // code to do B &#125;&#125;;或者是这样：12345678910111213class Foo&#123;public: Foo() &#123; // code to do A &#125; Foo(int value): Foo() // use the above constructor to do A (在C++11之前，是行不通的) &#123; // code to do B &#125;&#125;;然而，对于预c++ 11编译器，如果您试图让一个构造函数调用另一个构造函数，它通常会编译，但它不会像您所期望的那样工作，并且您可能会花费很长时间试图找出原因，即使使用调试器也是如此。可能的一种解释：在C++ 11之前，从另一个构造函数显式地调用另一个构造函数 将创建一个临时对象，使用构造函数初始化临时对象，然后丢弃它，保持原始对象不变。使用单独的函数C++ 允许构造函数调用类中的 非构造函数。但要注意，非构造函数使用的任何成员都已经初始化了。尽管您可能会试图将代码从第一个构造函数复制到第二个构造函数，但是有重复的代码会使您的类更难于理解，维护起来也更麻烦。此问题的最佳解决方案是创建一个非构造函数来执行公共初始化，并让两个构造函数都调用该函数。1234567891011121314151617181920class Foo&#123;private: void DoA() &#123; // code to do A &#125; public: Foo() &#123; DoA(); &#125; Foo(int nValue) &#123; DoA(); // code to do B &#125; &#125;;通过这种方式，代码重复率被保持到最小。将初始化部分代码分离出来您可能会发现自己处于这样一种情况:您想要编写一个成员函数来重新初始化一个类，使其返回默认值。由于您可能已经有一个这样的构造函数，所以您可能会尝试从您的成员函数中调用构造函数。然而，试图直接调用构造函数通常会导致意外行为。许多开发人员只是简单地从初始化函数的构造函数中复制代码，这可以工作，但是会导致重复的代码。在这种情况下，最好的解决方案是将代码从构造函数移到新函数中，并让构造函数调用该函数来完成初始化数据的工作:12345678910111213141516171819class Foo&#123;public: Foo() &#123; Init(); &#125; Foo(int value) &#123; Init(); // do something with value &#125; void Init() &#123; // code to init Foo &#125;&#125;;包含一个Init()函数是相当常见的，该函数将成员变量初始化为其默认值，然后让每个构造函数在执行特定于参数的任务之前调用Init()函数。这将最小化代码重复，并允许您在任何地方显式地调用Init()。一个小警告:在使用Init()函数和 动态分配内存时要小心。因为Init()函数可以由任何人在任何时候调用，所以在调用Init()时，动态分配的内存可能已经分配，也可能还没有分配。要注意适当地处理这种情况——这可能有点令人困惑，因为非空指针可以是动态分配的内存，也可以是未初始化的指针!在c++ 11中委托构造函数从c++ 11开始，允许构造函数调用其他构造函数。这个过程称为委托构造函数(或构造函数链)。要让一个构造函数调用另一个构造函数，只需调用成员初始化器列表中的构造函数。在这种情况下，直接调用另一个构造函数是可以接受的。应用到我们上面的例子:1234567891011121314class Foo&#123;private: public: Foo() &#123; //code to do A &#125; Foo(int value) : Foo() //使用 默认构造函数Foo() 来执行A &#123; //code to do B &#125;&#125;;正如您所期望的那样。确保从成员初始化器列表调用构造函数，而不是在构造函数的主体中调用。下面是另一个使用委托构造函数来减少冗余代码的例子:12345678910111213141516171819#include &lt;iostream&gt;#include &lt;string&gt;class Employee&#123;private: int m_id; std::string m_name; public: Employee(int id=0; const std::string &amp;name=\"\") : m_id(id), m_name(name) &#123; std::cout &lt;&lt; \"Employee \" &lt;&lt; m_name &lt;&lt; \" created.\\n\"; &#125; // 使用委托构造函数来最小化冗余代码 Employee(const std::string &amp;name) : Employee(0, name) &#123;&#125;&#125;;这个类有两个构造函数，其中一个委托给Employee(int, const std::string &amp;)。通过这种方式，冗余代码的数量被最小化(我们只需要编写一个构造函数体，而不是两个)。附加说明关于委托构造函数的一些附加说明。首先，委托给另一个构造函数的构造函数本身不允许执行任何成员初始化。所以你的构造函数可以委托或初始化，但不能同时委托和初始化。其次，一个构造函数可以委托给另一个构造函数，后者再委托给第一个构造函数。这形成了一个无限循环，并将导致您的程序运行堆栈空间和崩溃。可以通过确保所有构造函数都解析为非委托的构造函数来避免这种情况。","categories":[],"tags":[]},{"title":"C&C++/非静态成员初始化","slug":"C&C++/非静态成员初始化","date":"2020-05-08T09:52:04.083Z","updated":"2020-05-08T10:10:33.316Z","comments":true,"path":"archives/4635f066.html","link":"","permalink":"https://longlongqin.github.io/archives/4635f066.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-programming/8-5b-non-static-member-initialization/当编写一个具有多个构造函数的类(大多数构造函数)时，必须为每个构造函数中的所有成员指定默认值，这会导致代码冗余。如果更新成员的默认值，则需要修改每个构造函数。从c++ 11开始，可以直接给普通的类成员变量(那些不使用static关键字的变量)一个默认的初始值:注意，使用非静态成员初始化 来 初始化成员 需要使用等号或大括号(统一)初始化器，但是直接初始化表（即，使用小括号）单在这里不起作用。12345678910111213141516171819202122232425262728#include &lt;iostream&gt;class Rectangle&#123;private: //给这些普通的类成员变量(那些不使用static关键字的变量)一个默认的初始值: //注意：你可以用：“=” 或 “大括号(统一初始化)” // 但是，\"直接初始化(即，使用小括号)\" 在这里是不能用的。⭐ double m_length&#123; 1.0 &#125;; // m_length has a default value of 1.0 double m_width&#123; 1.0 &#125;; // m_width has a default value of 1.0 public: void print() &#123; std::cout &lt;&lt; \"length: \" &lt;&lt; m_length &lt;&lt; \", width: \" &lt;&lt; m_width &lt;&lt; '\\n'; &#125;&#125;; int main()&#123; Rectangle x&#123;&#125;; // x.m_length = 1.0, x.m_width = 1.0 x.print(); return 0;&#125;/*结果*/length: 1.0, width: 1.0非静态成员初始化 (也称为类内成员初始化) 为您的成员变量提供默认值，如果构造函数没有为成员本身提供初始化值(通过成员初始化列表)，则构造函数将使用这些值。构造函数仍然决定可以创建什么类型的对象12345678910111213141516171819202122232425262728#include &lt;iostream&gt;class Rectangle&#123;private: double m_length&#123; 1.0 &#125;; double m_width&#123; 1.0 &#125;; public: //注意:本例中没有提供默认构造函数 Rectangle(double length, double width) : m_length&#123; length &#125;, m_width&#123; width &#125; &#123; // m_length and m_width 由构造函数初始化(不使用默认值) &#125; void print() &#123; std::cout &lt;&lt; \"length: \" &lt;&lt; m_length &lt;&lt; \", width: \" &lt;&lt; m_width &lt;&lt; '\\n'; &#125; &#125;;int main()&#123; Rectangle x&#123;&#125;; //✖，将不会被编译。因为不存在默认的构造函数，所以不能用这种形式。（即使成员有默认的初始化值，但是它不是默认的构造函数提供的） return 0;&#125;尽管我们为所有成员提供了默认值，但是没有提供默认构造函数，所以我们无法创建没有参数的Rectangle对象。构造函数的初始化器列表 优先于 默认初始值如果提供了默认初始值，同时也提供了 构造函数通过成员初始化器列表初始化成员，则成员初始化器列表优先。下面的例子说明了这一点:12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;class Rectangle&#123;private: double m_length&#123; 1.0 &#125;; double m_width&#123; 1.0 &#125;; public: Rectangle(double length, double width) : m_length&#123; length &#125;, m_width&#123; width &#125; &#123; //m_length and m_width 由构造函数初始化(不使用默认值) &#125; Rectangle(double length) : m_length&#123; length &#125; &#123; // m_length 由构造函数初始化. // m_width's 使用默认的值(1.0) &#125; void print() &#123; std::cout &lt;&lt; \"length: \" &lt;&lt; m_length &lt;&lt; \", width: \" &lt;&lt; m_width &lt;&lt; '\\n'; &#125; &#125;;int main()&#123; Rectangle x&#123; 2.0, 3.0 &#125;; x.print(); Rectangle y&#123; 4.0 &#125;; y.print(); return 0;&#125;/*结果*/length: 2.0, width: 3.0length: 4.0, width: 1.0","categories":[],"tags":[]},{"title":"C&C++/构造函数","slug":"C&C++/构造函数","date":"2020-05-07T16:08:55.739Z","updated":"2020-05-08T09:06:13.023Z","comments":true,"path":"archives/781f4530.html","link":"","permalink":"https://longlongqin.github.io/archives/781f4530.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/85-constructors/当一个类（或结构体）的所有成员都是public时，我们可以使用：初始化列表（initialization list ）或者，统一初始化（uniform initialization）来初始化这个类（或结构体）1234567891011121314class Foo&#123;public: int m_x; int m_y;&#125;; int main()&#123; Foo foo1 = &#123; 4, 5 &#125;; // initialization list Foo foo2 &#123; 6, 7 &#125;; // uniform initialization return 0;&#125;但是，一旦我们将任何成员变量设为私有，我们就不能再以这种方式初始化类了。这是有意义的:如果你不能直接访问一个变量(因为它是私有的)，讲道理你是不能够直接初始化它。那么我们如何用私有成员变量初始化一个类呢? 答案是通过构造函数。构造函数(Constructor)构造函数是一种特殊的 类成员函数，在实例化该类的对象时自动调用。构造函数通常用于初始化类的成员变量，使其具有适当的默认值或用户提供的值，或执行使用类所需的任何设置步骤(例如打开文件或数据库)。与普通成员函数不同，构造函数有特定的命名规则：构造函数必须具有与类相同的名字(使用相同的大小写)构造函数没有返回类型(甚至不是void)默认的构造函数不接受参数的构造函数 (或所有参数都有默认值的构造函数) 称为默认构造函数。如果没有提供 用户提供的初始化值，则调用默认构造函数。一个例子：123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;class Fraction&#123;private: int m_numerator; int m_denominator; public: Fraction() // default constructor &#123; m_numerator = 0; m_denominator = 1; &#125; int getNumerator() &#123;return m_numerator;&#125; int getDenominator() &#123;return m_denominator;&#125; double getValue &#123;return static_cast&lt;double&gt;(m_numerator) / m_denominator; &#125;&#125;;int main()&#123; Fraction frac; //由于没有实参，所以会默认调用Fraction() std::cout &lt;&lt; frac.getNumerator() &lt;&lt; \"/\" &lt;&lt; frac.getDenominator() &lt;&lt; '\\n'; return 0;&#125;/*结果*/0/1上面例子中，因为我们正在实例化一个没有参数的Fraction类型的对象，所以在为该对象分配内存之后，将立即调用默认构造函数，并初始化我们的对象。注意，我们的numerator和denominator是用默认构造函数中设置的值初始化的! 如果没有默认的构造函数，numerator和denominator就会有垃圾值，直到我们显式地为它们分配合理的值，或者通过其他方法初始化它们(记住: 默认情况下不会初始化基本变量)。接收参数的构造函数虽然默认构造函数对于确保用合理的默认值初始化类非常有用。但通常我们希望类的实例具有我们提供的特定值。幸运的是，还可以用参数声明构造函数。下面是一个构造函数的例子，它使用两个整数参数来初始化分子和分母:1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cassert&gt;class Fraction&#123;private: int m_numerator; int m_denominator;public: Fraction() // default constructor &#123; m_numerator = 0; m_denominator = 1; &#125; //带有两个形参的构造函数，其中一个形参有默认的值⭐ Fraction(int numerator, int denominator = 1) &#123; assert(denominator != 0); m_numerator = numerator; m_denominator = denominator; &#125; int getNumerator() &#123; return m_numerator; &#125; int getDenominator() &#123; return m_denominator; &#125; double getValue() &#123; return static_cast&lt;double&gt;(m_numerator) / m_denominator; &#125;&#125;;注意，我们现在有两个构造函数:一个是默认情况下调用的默认构造函数，另一个是接受两个参数的构造函数。由于函数重载，这两个构造函数可以在同一个类中和平共处。实际上，只要每个构造函数都有唯一的签名 (参数的数量和类型)， 就可以定义任意数量的构造函数。如何使用带有参数的构造函数我们可以直接使用 括号 或 直接初始化:12Fraction fiveThirds&#123; 5, 3 &#125;; // 使用大括号 initialization, calls Fraction(int, int)【推荐⭐】Fraction threeQuarters(3, 4); // 直接初始化, also calls Fraction(int, int)注意，我们给了构造函数的第二个参数一个默认值，所以下面的操作也是合法的:1Fraction six&#123; 6 &#125;; // calls Fraction(int, int) constructor, 第二个参数使用默认值在类中使用“=”来复制初始化（C++11之前）本节只在您使用比c++ 11更老的标准时才有意义。与基本变量非常相似，也可以使用复制初始化来初始化类:12Fraction six = Fraction&#123; 6 &#125;; // Copy initialize a Fraction, will call Fraction(6, 1)Fraction seven = 7; //复制初始化一个Fraction。编译器将尝试找到一种方法将7转换成Fraction，这将调用分数(7,1)构造函数。但是，我们建议您避免对类进行这种形式的初始化，因为它的效率可能比较低。虽然直接初始化、统一初始化和复制初始化与基本类型的工作方式相同，但是复制初始化与类的工作方式不同(尽管最终结果通常相同)。我们将在以后的章节中更详细地探讨这些差异减少构造函数的个数在上面的Fraction类的 双构造函数 声明中，默认构造函数实际上有些多余。我们可以将这个类简化如下:12345678910111213141516171819202122#include &lt;cassert&gt; class Fraction&#123;private: int m_numerator; int m_denominator; public: // Default constructor Fraction(int numerator=0, int denominator=1) //⭐ &#123; assert(denominator != 0); m_numerator = numerator; m_denominator = denominator; &#125; int getNumerator() &#123; return m_numerator; &#125; int getDenominator() &#123; return m_denominator; &#125; double getValue() &#123; return static_cast&lt;double&gt;(m_numerator) / m_denominator; &#125;&#125;;尽管这个构造函数仍然是一个默认的构造函数，但是现在它已经被定义为可以接受 一个 或 两个 用户提供的值。1234Fraction zero; // will call Fraction(0, 1)Fraction zero&#123;&#125;; // will call Fraction(0, 1)Fraction six&#123; 6 &#125;; // will call Fraction(6, 1)Fraction fiveThirds&#123; 5, 3 &#125;; // will call Fraction(5, 3)隐式生成的默认构造函数如果你的类没有构造函数，c++会自动为你生成一个public的默认构造函数。这有时被称为隐式构造函数(或隐式生成的构造函数)。123456789class Date&#123;private: int m_year; int m_month; int m_day; //用户没有提供构造函数，编译器将会生成一个默认的构造函数（即，不带参数的构造函数）&#125;这个特殊的隐式构造函数允许我们创建一个没有参数的Date对象，但是不初始化任何成员(因为所有的成员都是基本类型，它们在创建时不会初始化)。如果Date有自己是类类型的成员，例如std::string，那么这些成员的构造函数将被自动调用。看一个例子：（为了确保成员变量得到初始化，我们可以在它们的声明中初始化它们。）1234567class Date&#123;private: int m_year&#123; 1900 &#125;; int m_month&#123; 1 &#125;; int m_day&#123; 1 &#125;;&#125;;虽然你看不到隐式生成的构造函数，但你可以证明它的存在:12345678910111213141516class Date&#123;private: int m_year&#123; 1900 &#125;; int m_month&#123; 1 &#125;; int m_day&#123; 1 &#125;; // No constructor provided, so C++ creates a public default constructor for us&#125;; int main()&#123; Date date&#123;&#125;; // calls implicit constructor⭐ return 0;&#125;当类中有任何显式构造函数，则不会提供隐式构造函数如果您的类有任何其他构造函数，则不会提供隐式生成的构造函数。例如:12345678910111213141516171819202122232425class Date&#123; private: int m_year&#123; 1900 &#125;; int m_month&#123; 1 &#125;; int m_day&#123; 1 &#125;; public: Date(int year, int month, int day) // normal non-default constructor &#123; m_year = year; m_month = month; m_day = day; &#125; //由于上面已经有了一个显式的构造函数，所以就不会再提供隐式的构造函数了&#125;int main()&#123; Date date&#123;&#125;; //错误:不能实例化对象，因为默认构造函数不存在，编译器也不会再生成默认构造函数（因为有显式的构造函数） Date today&#123; 2020, 1, 19 &#125;; // today is initialized to Jan 19th, 2020 return 0;&#125;显式的添加默认构造函数要允许构造一个没有参数的Date，可以：向构造函数添加默认参数，添加一个空的默认构造函数，或者显式地添加一个默认构造函数。【推荐⭐】1234567891011121314151617181920212223242526class Date&#123;private: int m_year&#123; 1900 &#125;; int m_month&#123; 1 &#125;; int m_day&#123; 1 &#125;; public: //告诉编译器创建一个默认构造函数，即使还有用户提供其他的构造函数。 Date() = default; //注意这个default⭐ Date(int year, int month, int day) // normal non-default constructor &#123; m_year = year; m_month = month; m_day = day; &#125; &#125;int main()&#123; Date date&#123;&#125;; // date is initialized to Jan 1st, 1900 Date today&#123; 2020, 10, 14 &#125;; // today is initialized to Oct 14th, 2020 return 0;&#125;使用= default与添加一个空主体的默认构造函数几乎是一样的。唯一的区别是= default允许我们安全地初始化成员变量，即使它们没有初始化器:1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cassert&gt;class Date&#123;public: Date() = default; //显示的默认构造函数private: // note: 成员声明中没有初始化 int m_year; int m_month; int m_day;&#125;;class Date2&#123;public: //用户提供的空的构造函数 Date2();private: // note: 成员声明中没有初始化 int m_year; int m_month; int m_day;&#125;;int main()&#123; Date today&#123;&#125;; //将会是：0, 0, 0 ⭐ Date2 tommorrow&#123;&#125;; //tommorrow 的成员没有初始化⭐ std::cin.clear(); std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n'); std::cin.get(); return 0;&#125;类包含类一个类可以包含其他类作为成员变量。默认情况下，在构造外部类时，成员变量将调用它们的默认构造函数。这发生在构造函数体执行之前。1234567891011121314151617181920212223242526#include &lt;iostream&gt; class A&#123;public: A() &#123; std::cout &lt;&lt; \"A\\n\"; &#125;&#125;; class B&#123;private: A m_a; // B contains A as a member variable public: B() &#123; std::cout &lt;&lt; \"B\\n\"; &#125;&#125;; int main()&#123; B b; return 0;&#125;/*结果*/AB在构造变量b时，调用b()构造函数。在执行构造函数体之前，m_a被初始化 (它需要调用class A的构造函数来初始化)，这个打印“A”。然后，返回到B构造函数，并执行B构造函数的主体。当你考虑它时，这是有意义的，因为B()构造函数可能想要使用变量m_a——所以m_a最好先初始化!类类型(class-type)的成员会被初始化与前一节中最后一个示例的不同之处在于m_a是一个类类型。即使我们没有显式地初始化类类型成员，它们也会被初始化。构造函数重点许多新程序员对构造函数是否创建对象感到困惑。它们不是——编译器在构造函数调用之前为对象设置内存分配。构造函数实际上有两个用途。首先，构造函数决定谁可以创建对象。也就是说，只有在找到匹配的构造函数时才能创建类的对象。其次，构造函数可以用来初始化对象。构造函数是否进行初始化取决于程序员。从语法上来说，构造函数完全不进行初始化是有效的(构造函数的作用仍然是允许创建对象，如上所述)。最后，构造函数只在创建对象时用于初始化。您不应该尝试调用构造函数来重新初始化现有对象。虽然它可以编译，但结果不是您想要的(相反，编译器将创建一个临时对象，然后丢弃它)。————————————–构造函数的成员初始化器列表原文：https://www.learncpp.com/cpp-tutorial/8-5a-constructor-member-initializer-lists/c++提供了一种通过成员初始化列表(通常称为“成员初始化列表”)来初始化类成员变量的方法 (而不是在它们创建之后给它们赋值)。不要将它们与我们可以用来为数组赋值的类似命名的初始化器列表混淆。在 1.4 – Variable assignment and initialization中，您了解了可以通过三种方式初始化变量:复制；直接；和统一初始化。123int value = 1; //拷贝初始化double value2 (2.2); //直接吃石化char value3 &#123;'c'&#125;; //统一初始化在类中使用初始化列表 几乎与直接初始化或统一初始化相同。如：12345678910111213141516171819202122232425262728293031323334353637//1.我们之前是这样写的：class Something&#123;private: int m_value1; double m_value2; char m_value3;public: Something() &#123; // 这些都是赋值，不是初始化 m_value1 = 1; m_value2 = 2.2; m_value3 = 'c'; &#125;&#125;;/************************************************************///2.现在来改进（使用初始化列表）：#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cassert&gt;class Something&#123;private: int m_value1; double m_value2; char m_value3;public: Something() : m_value1&#123; 1 &#125;, m_value2&#123; 2 &#125;, m_value3&#123; 'c' &#125;//⭐ &#123; // 这里就不再需要赋值了 &#125;&#125;;成员初始化器列表被插入到构造函数参数之后。它以冒号(:)开头，然后列出要初始化的每个变量以及该变量的值，中间用逗号分隔，最后没有分号。⭐注意，我们不再需要在构造函数体中执行赋值，因为初始化器列表将替换该功能。还要注意，初始化器列表不是以分号结束的。当用户传入初始值时当然，当我们允许调用者传入初始值时，构造函数更有用:1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;class Something&#123;private: int m_value1; double m_value2; char m_value3; public: Something(int value1, double value2, char value3='c') : m_value1&#123; value1 &#125;, m_value2&#123; value2 &#125;, m_value3&#123; value3 &#125; //⭐ directly initialize our member variables &#123; // No need for assignment here &#125; void print() &#123; std::cout &lt;&lt; \"Something(\" &lt;&lt; m_value1 &lt;&lt; \", \" &lt;&lt; m_value2 &lt;&lt; \", \" &lt;&lt; m_value3 &lt;&lt; \")\\n\"; &#125; &#125;;int main()&#123; Something something&#123; 1, 2.2 &#125;; // value1 = 1, value2=2.2, value3 gets default value 'c' something.print(); return 0;&#125;/*结果*/Something(1, 2.2, c)注意，您可以使用默认参数来提供一个默认值，以防用户没有传入一个值。初始化const变量面是一个拥有const成员变量的类的例子:123456789class something&#123;private: const int m_value;public: something() : m_value&#123;5&#125; //✔。直接初始化我们的const成员变量 &#123; &#125;&#125;;这是可行的，因为我们可以初始化const变量 (但不能赋值给它们!)使用成员初始化器列表初始化数组成员一个有数组成员的类:123456class Something&#123;private: const int m_array[5]; &#125;;在C++ 11之前，你只能通过一个成员初始化列表使一个数组成员 归零:12345678910class something&#123;private: const int m_array[5]; public: something() : m_array&#123;&#125; &#123; &#125;&#125;;从C++11开始，你可以完全初始化一个成员数组 使用统一初始化:12345678910class something&#123;private: const int m_array[5]; public: something() : m_array&#123;1, 2, 3, 4, 5&#125; //使用统一初始化来初始化我们的成员数组 &#123; &#125;&#125;;初始化在其他类中定义的成员变量12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;class A&#123;public: A(int x) &#123; std::cout &lt;&lt;\"A \"&lt;&lt;x&lt;&lt;'\\n'; &#125;&#125;;class B&#123;private: A m_a;public: B(int y) : m_a &#123;y-1&#125; //调用 A(int)构造函数 初始化成员m_a &#123; std::cout &lt;&lt; \"B \" &lt;&lt; y &lt;&lt; '\\n'; &#125;&#125;;int main()&#123; B b&#123;5&#125;; return 0;&#125;/*结果*/A 4B 5构造变量b时，使用值5调用 b(int)构造函数。在该构造函数体执行之前，m_a先被初始化 用值4调用A(int)构造函数，即打印“A 4”。：然后，将结果返回到B构造函数，并执行B构造函数的主体，打印“B 5”。格式化初始化器列表在如何格式化初始化器列表方面，c++提供了很大的灵活性，这实际上取决于您想如何继续。但这里有一些建议:如果初始化器列表和函数名在同一行，那么把所有东西都放在一行就可以了:123456789101112class something&#123;private: int m_value1; double m_value2; char m_value3; public: something() : m_value1&#123; 1 &#125;, m_value2&#123; 2.2 &#125;, m_value3&#123; 'c' &#125; // everything on one line &#123; &#125;&#125;;如果初始化器列表与函数名不在同一行，那么在下一行应该是缩进的:12345678910111213class something&#123;private: int m_value1; double m_value2; char m_value3; public: something(int value1, double value2, char value3='c') //这一行上已经有很多东西了 : m_value1&#123; value1 &#125;, m_value2&#123; value2 &#125;, m_value3&#123; value3 &#125; //所以，我们可以把剩下的内容缩进到下一行 &#123; &#125;&#125;;如果所有的初始值设定项都不在一行中(或者初始值设定项不是普通的)，那么你可以把它们隔开，每行一个:1234567891011121314151617class Something&#123;private: int m_value1; double m_value2; char m_value3; float m_value4; public: something(int value1, double value2, char value3='c', float value4=34.6f) //这一行上已经有很多东西了 : m_value1&#123; value1 &#125;, //一行一个，每行末尾有一个逗号 m_value2&#123; value2 &#125;, m_value3&#123; value3 &#125;, m_value4&#123; value4 &#125; &#123; &#125;&#125;;初始化器列表顺序可能令人惊讶的是，初始化器列表中的变量 没有 按照初始化程序列表中指定的顺序初始化。相反，它们是按照在类中声明它们的顺序初始化的。为取得最佳效果，应遵循以下建议:不要以这样的方式初始化成员变量，即它们依赖于首先初始化的其他成员变量 (换句话说，确保您的成员变量将正确初始化，即使初始化顺序不同)。在初始化器列表中以与在类中声明变量相同的顺序初始化变量。只要遵循前面的建议，这并不是严格要求的，但是如果您不这样做，并且打开了所有警告（自己对警告级别的设置），那么编译器可能会给您一个警告。小结成员初始化器列表允许我们初始化成员，而不是给它们赋值。这是初始化那些在初始化时需要值的成员 (如const或引用成员) 的唯一方法，而且它比在构造函数体中赋值更有性能。成员初始化器列表既适用于基本类型，也适用于本身就是类的成员。","categories":[],"tags":[]},{"title":"C&C++/访问函数及封装","slug":"C&C++/访问函数及封装","date":"2020-05-07T14:58:56.597Z","updated":"2020-05-07T16:04:41.038Z","comments":true,"path":"archives/1459e5c7.html","link":"","permalink":"https://longlongqin.github.io/archives/1459e5c7.html","excerpt":"","text":"为什么要将成员变量设为私有?在前一课中，我们提到类成员变量通常是私有的。学习面向对象编程的开发人员通常很难理解为什么要这样做。为了回答这个问题，让我们从一个类比开始。在现代生活中，我们可以使用许多电子设备。你的电视有一个遥控器，你可以用它来开/关电视。你开车(或踏板车)去上班。你用智能手机拍照。这三样东西都使用一个常见的模式: 它们提供了一个简单的界面供您使用(按钮、方向盘等)来执行操作。然而，这些设备实际上是如何操作的对你来说是隐藏的。当你按下遥控器上的按钮时，你不需要知道它在做什么来和你的电视交流。当你踩下汽车的油门踏板时，你不需要知道内燃机是如何使车轮转动的。当你拍照时，你不需要知道传感器如何将光线收集到像素化的图像中。这种接口和实现的分离非常有用，因为它允许我们在不了解对象如何工作的情况下使用对象。这极大地降低了使用这些对象的复杂性，并增加了我们能够与之交互的对象的数量。出于类似的原因，实现 和 接口的分离 在编程中也很有用。封装在面向对象编程中，封装(也称为信息隐藏)是这样一个过程：它将对象实现的细节隐藏起来，不让对象的用户看到。相反，对象的用户通过公共接口访问对象。通过这种方式，用户可以使用对象，而不必了解它是如何实现的。在c++中，我们通过访问说明符来实现封装。通常，类的所有成员变量都是私有的(隐藏实现细节)，而大多数成员函数是公共的(为用户公开接口)。虽然要求类的用户使用公共接口似乎比直接提供对成员变量的公共访问更麻烦，但这样做实际上提供了大量有用的好处，有助于鼓励类的可重用性和可维护性。注意:“封装”一词有时也用来指将数据和处理该数据的函数打包在一起。我们更倾向于称之为面向对象编程。封装的好处封装类更容易使用，并降低了程序的复杂性封装类有助于保护您的数据和防止误用封装类更容易调试","categories":[],"tags":[]},{"title":"C&C++/匿名函数","slug":"C&C++/匿名函数","date":"2020-05-07T01:35:03.052Z","updated":"2020-05-07T14:26:40.173Z","comments":true,"path":"archives/5ded0966.html","link":"","permalink":"https://longlongqin.github.io/archives/5ded0966.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/introduction-to-lambdas-anonymous-functions/匿名函数：lambdas（anonymous functions）考虑一下我们在之前课程中介绍的这段代码:123456789101112131415161718192021222324252627282930313233#include &lt;algorithm&gt;#include &lt;array&gt;#include &lt;iostream&gt;#include &lt;string_view&gt;static bool containsNut(std::string_view str) // static 是指在这个上下文中的内部链接&#123; // std::string_view::find returns std::string_view::npos if it doesn't find // the substring. Otherwise it returns the index where the substring occurs // in str. return (str.find(\"nut\") != std::string_view::npos);&#125; int main()&#123; std::array&lt;std::string_view, 4&gt; arr&#123; \"apple\", \"banana\", \"walnut\", \"lemon\" &#125;; // std::find_if takes a pointer to a function auto found&#123; std::find_if(arr.begin(), arr.end(), containsNut) &#125;; if (found == arr.end()) &#123; std::cout &lt;&lt; \"No nuts\\n\"; &#125; else &#123; std::cout &lt;&lt; \"Found \" &lt;&lt; *found &lt;&lt; '\\n'; &#125; return 0;&#125;/*结果*/Found walnut其实这个可以被改进：这里问题的根源是std::find_if要求我们给它传递一个函数指针。函数不能嵌套因此，我们必须定义一个只会使用一次的函数，它必须有一个名称，并且必须放在全局范围内(因为函数不能嵌套!)这个函数也很短，从一行代码就比从名称和注释更容易看出它的功能。使用匿名函数匿名函数表达式 (也称为lambda 或 closure ) 允许我们在另一个函数中定义匿名函数。 嵌套很重要，因为它允许我们避免命名空间命名污染，并尽可能在使用它的地方定义函数(提供额外的上下文)。lambdas的语法是c++中比较奇怪的东西之一，需要一点时间来适应。Lambdas的形式是:12345678[ captureClause ] ( parameters ) -&gt; returnType&#123; statements;&#125;//如果不需要\"captureClause\"句和\"parameters\"，则它们都可以为空。//\"return type\"是可选的。如果省略它，将使用auto(即，使用类型推断来确定返回类型)。//虽然我们前面已经注意到，应该避免对函数返回类型进行类型推断，但是在这个上下文中，使用这种类型推断是可以的(因为这些函数通常都是非常琐碎的)。还要注意，lambdas没有名称，所以我们不需要提供名称。这意味着一个普通的lambda定义是这样的:12345678#include &lt;iostream&gt; int main()&#123; []() &#123;&#125;; // defines a lambda with no captures, no parameters, and no return type return 0;&#125;重新写上面的那段代码（使用匿名函数）：123456789101112131415161718192021222324252627#include &lt;algorithm&gt;#include &lt;array&gt;#include &lt;iostream&gt;#include &lt;string_view&gt;int main()&#123; std::array&lt;std::string_view, 4&gt; arr&#123; \"apple\", \"banana\", \"walnut\", \"lemon\" &#125;; // Define the function right where we use it. auto found&#123; std::find_if(arr.begin(), arr.end(), [](std::string_view str) // here's our lambda, no capture clause⭐ &#123; return (str.find(\"nut\") != std::string_view::npos); &#125;) &#125;; if (found == arr.end()) &#123; std::cout &lt;&lt; \"No nuts\\n\"; &#125; else &#123; std::cout &lt;&lt; \"Found \" &lt;&lt; *found &lt;&lt; '\\n'; &#125; return 0; &#125;这就像函数指针的情况，并产生一个相同的结果:1Found walnut注意：注意我们的 匿名函数 与我们的 containsNut函数 是多么的相似：它们都具有相同的参数和函数体。lambda没有captureClause（捕获子句）(我们将在下一课中解释捕获子句是什么)，因为它不需要捕获子句。我们在lambda中省略了末尾的返回类型(为了简洁)，但是因为是操作符 != 返回一个bool，我们的lambda也将返回一个bool。匿名函数的类型在上面的例子中，我们在需要的地方定义了一个lambda。这种对lambda的使用有时被称为函数文字（function literal）。但是上面的例子中的匿名函数的可读性很差。就像我们可以用一个文字值(或函数指针)初始化一个变量以供以后使用一样，我们也可以用一个lambda定义初始化一个lambda变量，然后再使用它。比如：（在下面的代码段中，我们使用std::all_of来检查数组中的所有元素是否为偶数:）12//我们必须读lambda来理解发生了什么。(Bad)return std::all_of (array.begin(), array.end(), [] (int i) &#123;return ((i%2) == 0);&#125;);我们可以改善可读性的这个如下:[推荐⭐]12345678910//相反，我们可以将lambda存储在指定的变量中，并将其传递给函数。auto isEven&#123; [] (int i) &#123; return ((i%2) == 0); &#125;&#125;;return std::ll_of(array.begin(), array.end(), isEven);//注意最后一行读起来有多好:“返回数组中的所有元素是否为偶数”匿名函数的类型到底是什么？但是上面的匿名函数isEven到底是什么呢？答：事实证明，lambdas没有一个我们可以明确使用的类型。当我们写一个lambda时，编译器会生成一个唯一的类型，但是不暴露给我们。虽然我们不知道lambda的类型，但是有几种方法可以存储用于post-definition（后定义？？？）的lambda。如果lambda有一个空的捕获子句，我们可以使用下面三种方式：12345678910111213141516171819202122232425262728293031323334353637#include &lt;functional&gt;int main()&#123; //⭐1：一个常规的函数指针。只对 空捕获句子(capture clause) 有效。 double (*addNumbers1) (doubel, double) &#123; [] (double a, double b) &#123; return (a+b); &#125; &#125;; addNumbers1(1,2); //⭐2： Using std::function。也可适用于匿名函数的capture clause非空的情况(下一课会讲)。 std::function addNumbers2 //注意：在C++17之前，应该这样写：std::function&lt;double(double, double)&gt; &#123; [] (double a, double b) &#123; return (a+b); &#125; &#125;; addNumbers2(3, 4); //⭐3：使用auto。存储lambda的实际类型。 auto addNumbers3 &#123; [] (double a, double b) &#123; return (a+b); &#125; &#125;; addNumbers3(5,6); return 0;&#125;使用lambda实际类型的惟一方法是使用auto。auto还具有与std::function 相比没有开销的优点。适用std::function而不适用auto的情况不幸的是，我们不能总是使用auto。在实际的lambda未知的情况下(例如，因为我们将lambda作为参数传递给一个函数，调用者决定将传递什么lambda)，我们不能使用auto。在这种情况下，应该使用std::function。123456789101112131415161718192021#include &lt;functional&gt;#incldue &lt;iostream&gt;//我们不知道fn会是什么。std::function与常规函数和lambdas一起工作。void repeat(int repetitions, const std::function&lt;void(int)&gt;&amp; fn)&#123; for (int i&#123; 0 &#125;; i &lt; repetitions; ++i ) fn(i);&#125;int main()&#123; repeat(3, [] (int i) &#123;std::cout&lt;&lt;i&lt;&lt;'\\n';&#125; ); return 0;&#125;/*结果*/012匿名函数其实不是真正的函数实际上，lambdas不是函数(这也是它们为什么在“函数不能嵌套”的规定下，可以使用的原因)。它们是一种特殊的物体，叫做函子(functor)。函子是包含重载运算符() 的对象，使其可以像函数一样调用。泛型的匿名函数（generic lambdas）在大多数情况下，lambda参数的工作原理与常规函数参数相同。一个值得注意的例外是，因为c++ 14允许我们使用auto作为参数（注意:在c++ 20中，常规函数也可以使用auto作为参数）。当一个lambda有一个或多个auto参数时，编译器将从对lambda的调用中推断出需要哪些参数类型。因为具有一个或多个auto参数的lambdas可以处理各种类型的数据，所以它们被称为generic lambdas。看一个例子：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;array&gt;#include &lt;string_view&gt;int main(int argc, char* argv[])&#123; std::array months&#123; //C++17之前，使用：std::array&lt;const char*, 12&gt; \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\" &#125;; //搜索以相同字母开头的连续两个月。 auto samelatter&#123; std::adjacent_find(months.begin(), months.end(), [](const auto&amp; a, const auto&amp; b) &#123;return (a[0] == b[0]); &#125; ) &#125;; //确保找到两个月的时间。 if (samelatter != months.end()) &#123; //std::next返回sameLetter之后的下一个迭代器 std::cout &lt;&lt;*samelatter &lt;&lt; \" and \" &lt;&lt;*std::next(samelatter) &lt;&lt; \" start with the same letter\\n\"; &#125; return 0;&#125;/*结果*/June and July start with the same letter在上面的例子中，我们使用auto类型的参数通过 const引用 来捕获字符串。因为所有的字符串类型都允许通过 操作符[] 访问它们各自的字符，所以我们不需要关心用户是否传入了std::string、c风格的字符串或其他内容。这允许我们写一个可以接受任何这些的lambda，意味着如果我们在几个月后改变类型，我们就不必重写lambda了。然而，有些情况auto，不是最好的选择：1234567891011121314151617181920212223242526272829303132333435#include &lt;algorithm&gt;#include &lt;array&gt;#include &lt;iostream&gt;#include &lt;string_view&gt; int main()&#123; std::array months&#123; // pre-C++17 use std::array&lt;const char*, 12&gt; \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\" &#125;; // Count how many months consist of 5 letters auto fiveLetterMonths&#123; std::count_if(months.begin(), months.end(), [](std::string_view str) &#123; //⭐ return (str.length() == 5); &#125;) &#125;; std::cout &lt;&lt; \"There are \" &lt;&lt; fiveLetterMonths &lt;&lt; \" months with 5 letters\\n\"; return 0;&#125;/*结果*/There are 2 months with 5 letters在本例中，使用auto将会推断出const char的类型。*c风格的字符串不容易使用(除了使用运算符[])**。在本例中，我们倾向于显式地将参数定义为std::string_view，这使我们能够更轻松地处理底层数据(例如，我们可以询问string视图的长度，即使用户传入的是c风格的数组)。泛型lambda和静态变量需要注意的一件事是，一个独一无二的匿名函数将会(被)auto解析为不同的类型。下面的例子展示了一个泛型lambda如何变成两个不同的lambda:12345678910111213141516171819202122232425262728293031323334#include &lt;algorithm&gt;#include &lt;array&gt;#include &lt;iostream&gt;#include &lt;string_view&gt;int main()&#123; //打印一个值并计算 @print被调用的次数。 auto print &#123; [] (auto value) &#123; static int callcount &#123;0&#125;; std::cout &lt;&lt; callcount++&lt;&lt; \": \" &lt;&lt; value &lt;&lt; '\\n'; &#125; &#125;; print(\"hello\"); // 0: hello print(\"world\"); // 1: world print(1); // 0: 1 print(2); // 1: 2 print (\"ding dong\"); // 2: ding dong return 0;&#125;/*结果*/0: hello1: world0: 11: 22: ding dong在上面的例子中，我们定义了一个lambda，然后使用两个不同的参数 (一个字符串文字参数 和 一个整数参数)来调用它。这将生成lambda的两个不同版本 (一个带有字符串文字参数，另一个带有整数参数)。大多数时候，这是无关紧要的。但是，请注意，如果泛型lambda使用静态持续时间变量，那么这些变量不会在生成的lambda之间共享。我们可以在上面的示例中看到这一点，其中每个类型(字符串和整数)都有自己的惟一计数!虽然我们只写了一次lambda，但是生成了两个lambda，每个lambda都有自己的callCount版本。为了在两个生成的lambda之间共享一个计数器，我们必须在lambda之外定义一个变量。现在，这意味着即使在函数外部也要定义变量。在上面的例子中，这意味着添加一个全局变量。在下一课中讨论lambda捕获之后，我们将能够避免全局变量。返回类型推导和跟踪返回类型如果使用返回类型推断，则lambda的返回类型是从lambda内部的return语句中推导出来的。如果使用返回类型推断，lambda中的所有返回语句必须返回相同的类型(否则编译器将不知道选择哪一个)。12345678910111213141516#include &lt;iostream&gt; int main()&#123; auto divide&#123; [](int x, int y, bool bInteger) &#123; // 注意:没有指定的返回类型 if (bInteger) return x / y; else return static_cast&lt;double&gt;(x) / y; // 错误:返回类型与以前的返回类型不匹配 &#125; &#125;; std::cout &lt;&lt; divide(3, 2, true) &lt;&lt; '\\n'; std::cout &lt;&lt; divide(3, 2, false) &lt;&lt; '\\n'; return 0;&#125;这将产生一个编译错误：因为第一个返回语句(int)的返回类型 与 第二个返回语句(double)的返回类型不匹配。如何解决呢？在我们返回不同类型的情况下，我们有两个选项:显式强制转换以使所有返回类型匹配；显式地为lambda指定返回类型，并让编译器进行隐式转换。【推荐⭐】12345678910111213141516171819#include &lt;iostream&gt;int main()&#123; //注意：显式指定此值将返回一个double auto divide &#123; [] (int x, int y, bool bInteger) -&gt;double //⭐ &#123; if (bInteger) return x/y; // 将做一个隐式转换为double else return static_cast&lt;double&gt;(x) / y; &#125; &#125;; std::cout &lt;&lt; divide(3, 2, true) &lt;&lt; '\\n'; std::cout &lt;&lt; divide(3, 2, false) &lt;&lt; '\\n'; return 0;&#125;就像上面一样，如果您决定更改返回类型，您(通常)只需要更改lambda的返回类型，而不需要触及lambda主体。——————————Lambda captures原文：https://www.learncpp.com/cpp-tutorial/lambda-captures/Capture clauses and capture by value现在，让我们修改nut示例，让用户选择要搜索的子字符串。这并不像你想象的那么直观。1234567891011121314151617181920212223242526272829303132#include &lt;algorithm&gt;#include &lt;array&gt;#include &lt;iostream&gt;#include &lt;string_view&gt;#include &lt;string&gt; int main()&#123; std::array&lt;std::string_view, 4&gt; arr&#123; \"apple\", \"banana\", \"walnut\", \"lemon\" &#125;; // 询问用户要搜索什么。 std::cout &lt;&lt; \"search for: \"; std::string search&#123;&#125;; std::cin &gt;&gt; search; auto found&#123; std::find_if(arr.begin(), arr.end(), [](std::string_view str) &#123; // 搜索@search而不是“nut”。 return (str.find(search) != std::string_view::npos); // 错误:search 在此范围内不可访问 &#125;) &#125;; if (found == arr.end()) &#123; std::cout &lt;&lt; \"Not found\\n\"; &#125; else &#123; std::cout &lt;&lt; \"Found \" &lt;&lt; *found &lt;&lt; '\\n'; &#125; return 0;&#125;这段代码无法编译。与嵌套块不同的是，外层块中定义的任何标识符都可以在嵌套块的范围内访问，而lambdas只能访问特定类型的标识符:全局标识符、编译时已知的实体具有静态存储持续时间的实体。search不满足这些要求，所以lambda看不到它。这就是capture clause的作用。capture clausecapture clause(捕获子句) 用于(间接地)为lambda提供对周围范围中可用变量（这些变量是它通常无法访问的）的访问，我们所需要做的就是在lambda中列出我们想要访问的实体，作为捕获子句的一部分。在这种情况下，我们想给我们的lambda访问变量search的值，所以我们把它添加到捕获子句:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859608910111213141516171819202122232425262728293031#include &lt;algorithm&gt;#include &lt;array&gt;#include &lt;iostream&gt;#include &lt;string_view&gt;#include &lt;string&gt; int main()&#123; std::array&lt;std::string_view, 4&gt; arr&#123; \"apple\", \"banana\", \"walnut\", \"lemon\" &#125;; std::cout &lt;&lt; \"search for: \"; std::string search&#123;&#125;; std::cin &gt;&gt; search; // Capture @search vvvvvv⭐ auto found&#123; std::find_if(arr.begin(), arr.end(), [search](std::string_view str) &#123; return (str.find(search) != std::string_view::npos); &#125;) &#125;; if (found == arr.end()) &#123; std::cout &lt;&lt; \"Not found\\n\"; &#125; else &#123; std::cout &lt;&lt; \"Found \" &lt;&lt; *found &lt;&lt; '\\n'; &#125; return 0;&#125;/*结果*/search for: nanaFound banana那么捕捉到底是如何工作的呢?虽然上面例子中的lambda看起来像是直接访问main的搜索变量的值，但实际情况并非如此。Lambdas的外观和功能可能与嵌套块类似，但它们的工作方式略有不同(这一点很重要)。当执行lambda定义时，对于lambda捕获的每个变量，在lambda中创建该变量的克隆(具有相同的名称)。此时，这些克隆的变量是从同名的外部作用域变量初始化的。因此，在上面的例子中，当创建lambda对象时，lambda获得它自己的克隆变量search。这个克隆的search与main的search有相同的值，所以它的行为就像我们访问main的search，但我们没有。虽然这些克隆的变量具有相同的名称，但它们不一定具有与原始变量相同的类型。注意虽然lambdas看起来像函数，但它们实际上是可以像函数一样调用的对象(这些被称为functor——我们将在以后的课程中讨论如何从头创建自己的functor)。当编译器遇到一个lambda定义时，它会为该lambda创建一个自定义对象定义。每个捕获的变量都成为该对象的数据成员。在运行时，当遇到lambda定义时，将实例化lambda对象，并在此时初始化lambda的成员。捕获默认的const值默认情况下，变量由const值捕获。这意味着在创建lambda时，lambda捕获外部作用域变量的常量副本，也就是说不允许lambda修改它们。在下面的示例中，我们捕获变量ammo并尝试递减它。1234567891011121314151617181920212223#include &lt;iostream&gt;int main()&#123; int ammo&#123;10&#125;; //定义一个lambda并将其存储在一个名为“shoot”的变量中。 auto shoot&#123; [ammo]() &#123; //✖，缴获的ammo为const copy。 --ammo; std::cout &lt;&lt; \"Pew! \" &lt;&lt; ammo &lt;&lt; \" shot(s) left.\\n\"; &#125; &#125;; //调用lambda shoot(); std::cout &lt;&lt; ammo &lt;&lt; \" shot(s) left\\n\"; return 0;&#125;在上面的例子中，当我们捕获ammo时，在lambda中创建了一个具有相同名称和值的新const变量。我们不能修改它，因为它是const，这会导致编译错误。捕获可变(mutable)的值为了允许对值捕获的变量进行修改，我们可以将lambda标记为mutable。关键字mutable会除去 从值捕获的所有变量 的const限定。123456789101112131415161718192021222324252627#include &lt;iostream&gt; int main()&#123; int ammo&#123; 10 &#125;; auto shoot&#123; //在参数列表之后添加了mutable。 [ammo]() mutable &#123; //我们现在可以修改ammo了 --ammo; std::cout &lt;&lt; \"Pew! \" &lt;&lt; ammo &lt;&lt; \" shot(s) left.\\n\"; &#125; &#125;; shoot(); shoot(); std::cout &lt;&lt; ammo &lt;&lt; \" shot(s) left\\n\"; return 0;&#125;/*结果*/Pew! 9 shot(s) left.Pew! 8 shot(s) left.10 shot(s) left //真正的ammo的值是没有变的。虽然现在可以编译，但是还是有逻辑上面的错误，什么错误呢？就是：当我们呢调用匿名函数(shoot())，这个匿名函数捕获一个ammo的副本。当匿名函数对ammo进行递减（由10到9到8），它递减的是ammo的副本，而不是真正的ammo（如何修改本真的ammo呢？就是利用“引用”来捕获）注意：ammo的值在对lambda的调用中保持不变!通过“引用” 捕获就像函数可以改变通过引用传递的参数的值一样，我们也可以通过引用捕获变量来允许lambda改变参数的值。(所以，使用引用捕获，将不再需要mutable)为了通过引用捕获变量，我们在捕获的变量名之前加上一个&amp;符号。与被值捕获的变量不同，被引用捕获的变量是非const的，除非它们捕获的变量是const。当您通常希望通过引用将参数传递给函数时(例如，对于非基本类型)，应该首选通过引用捕获而不是通过值捕获。这是上面的代码，修改为通过引用来捕获ammo:123456789101112131415161718192021222324#include &lt;iostream&gt;int main()&#123; int ammo(10); auto shoot&#123; ////我们不再需要mutable [&amp;ammo]() &#123; // &amp;ammo是指通过引用来捕获ammo //这里改变ammo会影响 main's 中的ammo --ammo; std::cout &lt;&lt; \"Pew! \" &lt;&lt; ammo &lt;&lt; \" shot(s) left.\\n\"; &#125; &#125;; shoot(); std::cout &lt;&lt; ammo &lt;&lt; \" shot(s) left\\n\"; return 0;&#125;/*结果*/Pew! 9 shot(s) left.9 shot(s) left捕获多个变量可以通过用逗号分隔多个变量来捕获它们。这可以包括由值或引用捕获的变量组合:123456int health&#123; 33 &#125;;int armor&#123; 100 &#125;;std::vector&lt;CEnemy&gt; enemies&#123;&#125;;//通过值 捕获 health、armor；通过引用捕获enemies[health, armor, &amp;enemies]()&#123;&#125;;默认捕获显式地列出想要捕获的变量可能会很麻烦。如果您修改您的lambda，您可能会忘记添加或删除捕获的变量。幸运的是，我们可以利用编译器的帮助来自动生成需要捕获的变量列表。默认捕获(也称capture-default) 捕获lambda中提到的所有变量。如果使用默认捕获，则不捕获lambda中未提到的变量。若要按值捕获所有使用的变量，请使用=的捕获值。若要通过引用捕获所有使用的变量，请使用&amp;的捕获值。看一个例子：1234567891011121314151617181920212223242526272829#include &lt;array&gt;#include &lt;iostream&gt; int main()&#123; std::array areas&#123; 100, 25, 121, 40, 56 &#125;; int width&#123;&#125;; int height&#123;&#125;; std::cout &lt;&lt; \"Enter width and height: \"; std::cin &gt;&gt; width &gt;&gt; height; auto found&#123; std::find_if(areas.begin(), areas.end(), [=](int knownArea) &#123; // will default capture width and height by value return (width * height == knownArea); // because they're mentioned here &#125;) &#125;; if (found == areas.end()) &#123; std::cout &lt;&lt; \"I don't know this area :(\\n\"; &#125; else &#123; std::cout &lt;&lt; \"Area found :)\\n\"; &#125; return 0;&#125;默认捕获可以与普通捕获混合使用。我们可以通过值捕获一些变量，通过引用捕获另一些变量，但是每个变量只能捕获一次。12345678910111213141516171819202122232425int health&#123; 33 &#125;;int armor&#123; 100 &#125;;std::vector&lt;CEnemy&gt; enemies&#123;&#125;;//根据值 捕获health和armor，根据引用捕获enemies。[health, armor, &amp;enemies]()&#123;&#125;;//通过引用来捕获enemie，通过值来捕获其他的一切。[=, &amp;enemies]()&#123;&#125;;//通过引用来捕获其他的一切，通过值来捕获armor。[&amp;, armor]()&#123;&#125;;/*下面是一些非法的*///1.我们已经说过，我们想通过引用来捕获所有信息。✖[&amp;, &amp;armor]()&#123;&#125;;//2.我们已经说过，我们希望通过值来捕获一切。✖[=, armor]()&#123;&#125;;//3.armor出现两次。✖[armor, &amp;health, &amp;armor]() &#123;&#125;;//4.默认捕获必须是捕获组中的第一个元素。✖[armor, &amp;]()&#123;&#125;; -----应该是--》[ &amp;, armor]()&#123;&#125;;在lambda-capture中定义新变量有时，我们希望通过轻微的修改来捕获一个变量，或者声明一个只在lambda作用域内可见的新变量。我们可以通过在lambda-capture中定义一个变量而不指定它的类型来做到这一点。123456789101112131415161718192021222324252627282930313233#include &lt;array&gt;#include &lt;iostream&gt; int main()&#123; std::array areas&#123; 100, 25, 121, 40, 56 &#125;; int width&#123;&#125;; int height&#123;&#125;; std::cout &lt;&lt; \"Enter width and height: \"; std::cin &gt;&gt; width &gt;&gt; height; // 我们存储areas，但用户输入宽度和高度。 // 我们需要先计算出面积，然后才能搜索它。 auto found&#123; std::find_if(areas.begin(), areas.end(), // 声明一个仅对lambda可见的新变量(userarea) // userarea的类型被自动推断为int [userArea&#123; width * height &#125;](int knownArea) &#123; return (userArea == knownArea); &#125;) &#125;; if (found == areas.end()) &#123; std::cout &lt;&lt; \"I don't know this area :(\\n\"; &#125; else &#123; std::cout &lt;&lt; \"Area found :)\\n\"; &#125; return 0;&#125;当定义了lambda时，userArea只计算一次。计算的区域存储在lambda对象中，对于每个调用都是相同的。如果lambda是可变的，并且修改了在捕获中定义的变量，则原始值将被覆盖。空悬的捕获变量变量在定义lambda的地方被捕获。如果被引用捕获的变量在lambda之前被销毁，lambda将保留一个悬空引用。如：1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;string&gt;//返回一个lambdaauto makeWalrus(const std::string&amp; name)&#123; // 通过引用捕获name并返回lambda。 return [&amp;]()&#123; std::cout&lt;&lt; \"I am a walrus, my name is \"&lt;&lt;name &lt;&lt;'\\n'; //未定义行为 &#125;;&#125;int main()&#123; // 创建一个新的walrus，它的名字叫做Roofus. // sayName是makeWalrus返回的lambda。 auto sayName &#123;makeWalrus(\"Roofus\")&#125;; // 调用makeWalrus返回的 lambda函数。 sayName(); return 0;&#125;对makeWalrus的调用将从字符串文本“Roofus”创建一个临时std::string。在makeWalrus 中的lambda 通过引用捕获了这个临时字符串。当返回makeWalrus时，临时字符串被销毁，但是lambda依然在引用它。然后当我们调用sayName，就会访问到这个空悬的引用，于是就造成了未定义行为。注意，如果按值将name传递给makeWalrus，也会发生这种情况。warning:通过引用捕获变量时要格外小心，特别是使用默认的引用捕获时。捕获的变量必须比lambda存在的时间长。未完待续~~：Unintended copies of mutable lambdas目前，本节剩下部分先不看。2020-05-07 22:26:38","categories":[],"tags":[]},{"title":"C&C++/省略号(以及为啥避免使用他)","slug":"C&C++/省略号(以及为啥避免使用他)","date":"2020-05-06T15:24:41.575Z","updated":"2020-05-06T15:50:36.833Z","comments":true,"path":"archives/5844b406.html","link":"","permalink":"https://longlongqin.github.io/archives/5844b406.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/714-ellipsis-and-why-to-avoid-them/在我们目前看到的所有函数中，必须提前知道函数将使用的参数的数量(即使它们有默认值)。但是，在某些情况下，能够向函数传递 可变数量的参数 是很有用的。c++提供了一种特殊的说明符，称为 ellipsis(省略号) (又名 “…” )，它允许我们精确地执行此操作。使用省略号的函数采用以下形式:1return_type function_name(argument_list, ...)argument_list：是一个或多个常规函数参数。(注意，使用省略号的函数必须至少有一个非省略号参数。) 传递给函数的任何参数都必须首先匹配省略号：（是由三个点组成）。必须总是函数中的最后一个参数。但是从概念上来说，把省略号看作一个数组是很有用的，这个数组包含的参数超出argument_list中的参数。一个例子：假设我们要写一个函数来计算一堆整数的平均值。我们会这样做:123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstdarg&gt; // needed to use ellipsis// 省略号必须是最后一个参数// count是我们传递了多少额外的参数double findAverage(int count, ...)&#123; double sum = 0; //我们通过va_list⭐访问省略号，因此我们声明一个 va_list list; //我们使用va_start⭐初始化va_list。 //第一个参数是要初始化的列表，第二个参数是最后一个非省略号参数 va_start(list, count); // 循环遍历所有省略号参数 for (int arg = 0; arg &lt; count; ++arg) &#123; //我们使用va_arg⭐从我们的省略号中获取参数 // 第一个参数是我们正在使用的va_list // 第二个参数是 参数的类型 sum += va_arg(list, int); //完成后清除va_list ⭐ va_end(list); return sum / count; &#125;&#125;int main()&#123; std::cout &lt;&lt; findAverage(5, 1, 2, 3, 4, 5) &lt;&lt; '\\n'; std::cout &lt;&lt; findAverage(6, 1, 2, 3, 4, 5, 6) &lt;&lt; '\\n'; &#125;/*结果*/33.5","categories":[],"tags":[]},{"title":"C&C++/命令行参数","slug":"C&C++/命令行参数","date":"2020-05-06T13:49:28.995Z","updated":"2020-05-06T15:22:04.075Z","comments":true,"path":"archives/dcba50cd.html","link":"","permalink":"https://longlongqin.github.io/archives/dcba50cd.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/714-ellipsis-and-why-to-avoid-them/在 0.4 – introduction to development，中我们学习了：当我们编译和链接我们的程序时：编译器会产生一个可执行文件；当程序运行时，执行从main()函数的顶部开始。截止到现在，我们都是这样声明一个main()函数的：1int main()注意，main()的这个版本不接受任何参数。然而，许多程序需要某种类型的输入才能使用。例如，假设您正在编写一个名为Thumbnail的程序，它读取一个图像文件，然后生成一个缩略图(图像的较小版本)。Thumbnail如何知道要读取和处理的图像? 用户必须有某种方式告诉程序打开哪个文件。为此，您可以采用以下方法:1234567891011121314//Program: Thumbnail#include &lt;iostream&gt;#include &lt;string&gt;int main()&#123; std::cout &lt;&lt; \"Please enter an image filename to create a thumbnail for: \"; std::string filename &#123;&#125;; std::cin&gt;&gt;filename; //open image file //create thumbnail //output thumbnail&#125;然而，这种方法有一个潜在的问题。每次程序运行时，程序都会等待用户输入。如果您从命令行手动运行此程序一次，这可能不是问题。但在其他情况下可能会出现问题，比如希望在许多文件上运行这个程序，或者让另一个程序运行这个程序。让我们进一步研究这些情况。考虑这样一种情况，您希望为给定目录中的所有图像文件创建缩略图。你会怎么做呢?只要目录中有图像，您就可以多次运行这个程序，手工输入每个文件名。然而，如果有数百个图像，这可能需要一整天!这里的一个很好的解决方案是编写一个程序，循环遍历目录中的每个文件名，为每个文件调用一次Thumbnail。现在考虑这样一种情况，您正在运行一个网站，您希望让您的网站在用户每次向您的网站上传图像时创建一个缩略图。这个程序不接受来自web的输入，那么在这种情况下，上传者如何输入文件名呢? 这里的一个很好的解决方案是让您的web服务器在上传后自动调用Thumbnail。在这两种情况下，我们确实需要一种方法，让外部程序在启动Thumbnail时将文件名作为输入传递给我们的Thumbnail程序，而不是让Thumbnail等待用户在启动后输入文件名。Command line arguments命令行参数是可选的字符串参数，在程序启动时由操作系统传递给程序。然后程序可以使用它们作为输入(或忽略它们)。与函数参数为函数提供向另一个函数提供输入的方法非常相似，命令行参数为用户或程序 提供向程序提供输入的方法。传递命令行参数可执行程序可以通过按名称调用命令行来运行。例如，要在Windows机器上运行位于C:驱动器根目录中的可执行文件“WordCount”，您可以输入以下命令:1C:\\&gt;WordCount为了将命令行参数传递给WordCount，我们只需在 可执行文件名称 后面列出命令行参数:1C:\\&gt;WordCount Myfile.txt现在，当WordCount执行时，Myfile.txt将作为命令行参数提供。当然，一个程序可以有多个命令行参数，用空格分隔:1C:\\&gt;WordCount Myfile.txt Myotherfile.txtIDE中输入命令行参数的方法在microsoftvisual Studio中：在“解决方案资源管理器”中右键单击项目，然后选择“属性”。打开“配置属性”树目录，选择“调试”。在右侧窗格中，有一行称为“命令参数”。您可以在那里输入命令行参数进行测试，当您运行它时，它们将自动传递给您的程序。使用命令行参数既然您已经知道了如何为程序提供命令行参数，那么下一步就是从我们的c++程序中访问它们。为此，我们使用了与以前不同的main()形式。这种新形式的main()有两个参数(按照惯例命名为argc和argv):1234int main(int argc, char *argv[]) //【推荐】int main(int argc, char** argv) //上面的其实是等价的，但是我们推荐第一种，因为它便于理解argc：是一个整数参数，包含传递给程序的参数数的数目。argc将至少为1，因为第一个参数始终是程序本身的名称。其中：argc = argument countargv：是实际的参数值存储的地方。argv实际上只是一个c风格字符串数组。这个数组的长度是argc。其中：argv = argument values，尽管它的专有名称是”argument vectors”看一个例子：12345678910111213// Program: test#include &lt;iostream&gt; int main(int argc, char *argv[])&#123; std::cout &lt;&lt; \"There are \" &lt;&lt; argc &lt;&lt; \" arguments:\\n\"; // Loop through each argument and print its number and value for (int count&#123; 0 &#125;; count &lt; argc; ++count) std::cout &lt;&lt; count &lt;&lt; \" \" &lt;&lt; argv[count] &lt;&lt; '\\n'; return 0;&#125;运行：我们似乎没有给这个程序添加命令行参数，那我们就按照添加方法添加一下吧：（添加了3个命令行参数）现在再来运行一下：参数0是当前正在运行的程序的路径和名称。在本例中，参数1和2和3是我们传入的3个命令行参数。处理数值类型的命令行参数命令行参数总是作为字符串传递，即使提供的值本质上是数值型的。若要将命令行参数用作数字，必须将其从字符串转换为数字。不幸的是，C++使这一点比它应该做到的更加困难。123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;sstream&gt; // for std::stringstream#include &lt;cstdlib&gt; // for std::exit() int main(int argc, char *argv[])&#123; if (argc &lt;= 1) &#123; // 在某些操作系统上，argv[0]可能以空字符串结束，而不是程序的名称。 // 我们将根据argv[0]是否为空来调节我们的响应。 if (argv[0]) std::cout &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \" &lt;number&gt;\" &lt;&lt; '\\n'; else std::cout &lt;&lt; \"Usage: &lt;program name&gt; &lt;number&gt;\" &lt;&lt; '\\n'; std::exit(1); &#125; //设置一个名为convert的stringstream变量，使用argv[1]的输入进行初始化 std::stringstream convert&#123; argv[1] &#125;; //⭐ int myint&#123;&#125;; if (!(convert &gt;&gt; myint)) // 执行转换(这里的‘&gt;&gt;’是提取操作符⭐) myint = 0; // 如果转换失败，将myint设置为默认值 std::cout &lt;&lt; \"Got integer: \" &lt;&lt; myint &lt;&lt; '\\n'; return 0;&#125;/*假设我们设置了一个命令行参数：567, 那么结果为：*/Got integer: 567⭐注意：在上面的std::stringstream它的工作原理和std::cin非常相似。在本例中，我们使用argv[1]的值初始化它，因此，我们可以使用操作符&gt;&gt;来提取整型变量的值(与std::cin相同)。操作系统首先解析命令行参数当您在命令行输入一些内容(或从IDE运行程序)时，操作系统负责适当 地转换和路 由该请求。这不仅涉及运行可执行文件，还涉及解析任何参数，以确定应该如何处理和传递给应用程序。通常，操作系统对 双引号 和 反斜杠 等特殊字符 的处理有特殊的规则。例如：12&#x2F;&#x2F;包含下面的命令行参数MyArgs Hello world!如果打印命令行参数，则为：(原文中的路径)1234There are 3 arguments:0 C:\\MyArgs1 Hello2 world!通常，双引号中的字符串被认为是一个字符串的整体:1MyArgs &quot;Hello world!&quot;prints:123There are 2 arguments:0 C:\\MyArgs1 Hello world!如果你想包含一个文字双引号，你必须反斜杠双引号:1MyArgs \\&quot;Hello world!\\&quot;prints:1234There are 3 arguments:0 C:\\MyArgs1 &quot;Hello2 world!&quot;小结：命令行参数为用户或其他程序在启动时向程序传递输入数据提供了一种很好的方式。考虑将程序在启动时需要的任何输入数据用于操作命令行参数。如果没有传递命令行，您总是可以检测到这一点并请求用户输入。这样，你的程序可以以任何一种方式运行。","categories":[],"tags":[]},{"title":"C&C++/处理假设性错误","slug":"C&C++/处理假设性错误","date":"2020-05-05T13:16:15.895Z","updated":"2020-05-05T13:34:48.345Z","comments":true,"path":"archives/ff8fbe02.html","link":"","permalink":"https://longlongqin.github.io/archives/ff8fbe02.html","excerpt":"","text":"原文：https://www.learncpp.com/cpp-tutorial/712-handling-errors-assert-cerr-exit-and-exceptions/既然您已经知道了假设错误通常发生在什么地方，那么让我们讨论一下在它们发生时处理它们的不同方法。没有处理错误的最佳方法——这实际上取决于问题的性质以及问题是否可以修复。以下是一些典型的方法:悄悄地跳过代码，这取决于假设是有效的:123456void printString(const char *cstring)&#123; // Only print if cstring is non-null if (cstring) std::cout &lt;&lt; cstring;&#125;在上面的例子中，如果cstring为null，则不打印任何内容。我们跳过了依赖于cstring非空的代码。如果被跳过的语句不是关键语句，并且不影响程序逻辑，那么这可能是一个不错的选择。这样做的主要挑战是调用者或用户无法识别出错的地方。如果我们在一个函数中，返回一个错误代码给调用者，让调用者处理这个问题。1234567891011#include &lt;array&gt; // assume the array only holds positive valuesint getArrayValue(const std::array&lt;int, 10&gt; &amp;array, int index)&#123; // use if statement to detect violated assumption if (index &lt; 0 || index &gt;= static_cast&lt;int&gt;(array.size())) return -1; // return error code to caller return array[index];&#125;在这种情况下，如果调用者传入一个无效的索引，函数将返回-1 (返回一个枚举值会更好)。如果我们想立即终止程序，可以使用头文件&lt;cstdlib&gt;中的exit函数向操作系统返回错误代码:1234567891011#include &lt;cstdlib&gt; // for std::exit()#include &lt;array&gt; int getArrayValue(const std::array&lt;int, 10&gt; &amp;array, int index)&#123; // use if statement to detect violated assumption if (index &lt; 0 || index &gt;= static_cast&lt;int&gt;(array.size())) std::exit(2); // terminate program and return error number 2 to OS return array[index];&#125;如果调用者传入一个无效的索引，这个程序将立即终止(没有错误消息)，并将错误代码2传递给操作系统。如果用户输入了无效的输入，请用户再次输入该输入。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;limits&gt;#include &lt;string&gt;int main()&#123; std::string hello&#123; \"hello, world!\" &#125;; int index; do //主要是这个do &#123;&#125;while()循环 &#123; std::cout &lt;&lt; \"enter an index: \"; std::cin &gt;&gt; index; //处理用户输入非整数的情况 if (std::cin.fail()) &#123; std::cin.clear(); // 重置任何错误标志 std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n'); //忽略输入缓冲区中的任何字符 index = -1; // 确保index有一个无效的值，这样循环就不会终止 continue; //这个continue看起来无关紧要，但是它明确地表示了终止这个循环迭代的意图…… //……以防我们后面添加更多东西 std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n'); &#125; &#125; while (index &lt; 0 || index &gt;= static_cast&lt;int&gt;(hello.size())); //处理用户输入的整数超出范围的情况 std::cout &lt;&lt; \"Letter #\" &lt;&lt; index &lt;&lt; \" is \" &lt;&lt; hello[index] &lt;&lt; '\\n'; /***********************************************/ std::cin.clear(); std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n'); std::cin.get(); return 0;&#125;cerr是另一种专门用于打印错误消息的机制。cerr是一个输出流(就像cout)，它在中定义。通常，cerr在屏幕上写错误消息(就像cout一样)，但是它也可以单独重定向到一个文件。12345678void printString(const char *cstring)&#123; // Only print if cstring is non-null if (cstring) std::cout &lt;&lt; cstring; else std::cerr &lt;&lt; \"function printString() received a null parameter\";&#125;在上面的示例中，我们不仅跳过了错误行，还记录了一个错误，以便用户稍后可以确定为什么程序没有按预期执行。如果在某种图形环境中工作(例如MFC, SDL, QT, etc…)。通常是弹出一个带有错误代码的消息框，然后终止程序。","categories":[],"tags":[]},{"title":"C&C++/函数重载","slug":"C&C++/函数重载","date":"2020-05-03T09:53:36.709Z","updated":"2020-05-03T10:11:58.593Z","comments":true,"path":"archives/6c7b6feb.html","link":"","permalink":"https://longlongqin.github.io/archives/6c7b6feb.html","excerpt":"","text":"函数重载是C++的一个特性，它允许我们创建具有相同名称的多个函数，它们的形参需要是不同的。具体内容请查看原文：https://www.learncpp.com/cpp-tutorial/76-function-overloading/","categories":[],"tags":[]},{"title":"C&C++/内联函数","slug":"C&C++/内联函数","date":"2020-05-03T09:12:59.630Z","updated":"2020-05-03T09:44:41.512Z","comments":true,"path":"archives/738b4cec.html","link":"","permalink":"https://longlongqin.github.io/archives/738b4cec.html","excerpt":"","text":"函数的一个主要缺点是每次调用函数时，都会出现一定数量的性能开销。这是因为CPU必须存储它正在执行的当前指令的地址(这样它就知道以后要返回到哪里)以及其他寄存器，所有的函数参数都必须创建并赋值，程序必须转移到一个新的位置。就地编写的代码要快得多。对于大型和/或执行复杂任务的函数，与函数运行所需的时间相比，函数调用的开销通常是微不足道的。然而，对于小的、常用的函数，执行函数调用所需的时间通常比实际执行函数代码所需的时间多得多。这可能导致严重的性能损失。c++提供了一种将函数的优点与就地编写代码的速度相结合的方法: 内联函数。inline关键字用于请求编译器将函数视为内联函数。当编译器编译您的代码时，所有内联函数都在适当的位置展开——也就是说，函数调用被替换为函数本身内容的副本，从而消除了函数调用的开销!缺点是，因为内联函数在每个函数调用时都被就地展开，这会使编译后的代码变得更大，特别是当内联函数很长或者有很多对内联函数的调用时。请看下面的例子：1234567891011int min(int x, int y)&#123; return x &gt; y ? y : x;&#125; int main()&#123; std::cout &lt;&lt; min(5, 6) &lt;&lt; '\\n'; std::cout &lt;&lt; min(3, 2) &lt;&lt; '\\n'; return 0;&#125;这个程序调用函数min()两次，导致函数调用开销多了两次。因为min()是一个很短的函数，它是内联的最佳选择:1234inline int min(int x, int y)&#123; return x&gt;y ? y : x;&#125;现在，当程序编译main()时，它将创建机器码，就好像main()是这样写的:123456int main()&#123; std::cout &lt;&lt; (5 &gt; 6 ? 6 : 5) &lt;&lt; '\\n'; std::cout &lt;&lt; (3 &gt; 2 ? 2 : 3) &lt;&lt; '\\n'; return 0;&#125;这将执行得快一些，代价是编译后的代码稍微大一些。由于存在代码膨胀的可能性，内联函数最适合短函数(例如，不超过几行)，这些短函数通常在循环内部调用，并且不进行分支。还要注意，inline关键字只是一个建议——如果您试图内联一个冗长的函数，编译器很可能会忽略您对内联函数的请求。现代编译器会自动设为内联函数最后，现代编译器现在非常擅长自动内联函数——在大多数情况下比人类做得更好。即使没有将函数标记为内联函数，编译器也会将它认为会导致性能提高的内联函数标记为内联函数。因此，在大多数情况下，并不需要特别使用inline关键字。让编译器为您处理内联函数。所以，不需要手动去设置，编译器会智能的自动帮我们将适当的函数设置为内联函数。","categories":[],"tags":[]},{"title":"C&C++/按值传递","slug":"C&C++/按值传递","date":"2020-05-02T23:52:02.648Z","updated":"2020-05-03T00:15:45.857Z","comments":true,"path":"archives/6b668399.html","link":"","permalink":"https://longlongqin.github.io/archives/6b668399.html","excerpt":"","text":"函数调用原文：https://www.learncpp.com/cpp-tutorial/introduction-to-functions/https://www.learncpp.com/cpp-tutorial/introduction-to-function-parameters-and-arguments/当你读一本书的时候，突然有人给你打电话。然后你就用“书签”夹在当前阅读位置，去接电话。等你电话接完，再回到你放书签的那个地方继续读书。函数调用(function call)是一个表达式。它告诉CPU中断当前函数并在这里“放一个书签”，然后执行另一个函数(就是函数调用中提及的那个函数)。当调用结束后，CPU就返回到“书签”的位置，然后再继续执行。caller：发起函数调用的函数叫做caller；callee(called function)：被调用的函数叫做callee(called function)。int main()的返回值：在int main()函数最后，会有返回值，这个值是返回到操作系统的，为了让操作系统知道这个程序执行成功与否。main函数的返回值，有一个特定名字叫做：status code （状态码）一般 return 0; 表示程序执行成功。返回非零值，表示程序执行错误。C++规定，main函数必须是int型C++标准中规定的：main函数的返回值应该定义为int类型。对于”void main(void);”这种错误形式，虽然在一些编译器中可以通过编译(如vc6)，但并非所有的编译器都支持。main()函数的原型是：1int main(int argc, char **argv, char **env)实参的值不会被函数改动原文：https://www.learncpp.com/cpp-tutorial/72-passing-arguments-by-value/默认情况下，无指针的实参是按值传递的。当实参是“按值传递”时，实参的值会被复制到函数的形参中。所以，原来的实参的值是不会被函数改动的。函数参数求值的顺序在C++中，没有规定实参匹配的顺序（顺序：从左→右，还是从右→左），因为匹配顺序不重要。1someFunction(a(), b()); // a() or b() may be called first是从右→左，还是从右→左：取决于a()和b()的功能。如果你想要规定谁先的话，你可以显示的规定匹配顺序，如：1234int avar&#123; a() &#125;; // a() will always be called firstint bvar&#123; b() &#125;; // b() will always be called second someFunction(avar, bvar); // it doesn't matter whether avar or bvar are copied first because they are just values按值传递的优劣优势：通过值传递的参数可以是变量(例如x)、文字(例如6)、表达式(例如x+1)、结构和类以及枚举数。换句话说，几乎任何事情。被调用的函数不会改变实参，这可以防止副作用。短处复制struct和class会导致严重的性能损失，特别是在多次调用函数的情况下。按值传递的使用时机使用时机：当传递基本数据类型和枚举数时，且函数不需要修改实参。不适用情况：在传递struct或类时(包括std::array、std::vector和std::string)。","categories":[],"tags":[]},{"title":"test your code","slug":"C&C++/标准库algorithm","date":"2020-05-02T10:17:47.397Z","updated":"2020-05-02T16:41:52.317Z","comments":true,"path":"archives/5937092e.html","link":"","permalink":"https://longlongqin.github.io/archives/5937092e.html","excerpt":"LearnCpp chapterLhttps://www.learncpp.com","text":"LearnCpp chapterLhttps://www.learncpp.com标准库 algorithms的介绍由于搜索、计数和排序是如此常见的操作，c++标准库提供了一组函数，只需几行代码就可以完成这些任务。此外，这些标准库函数经过了预先测试，它们是高效的，可以处理各种不同的容器类型，并且许多还支持并行化(将多个CPU线程用于同一任务以更快地完成它的能力)。算法库中提供的功能大致可分为三类:检查器——用于查看(但不修改)容器中的数据。例如搜索和计数。修改序列——用于修改容器中的数据的顺序。例如排序和变换。辅助器——用于根据数据成员的值生成结果。示例包括将值相乘的对象，或者确定元素对的排序顺序的对象。更多关于 algorithms 。注：在库“algorithm”中所有函数都使用了迭代器。使用std::fine按值查找元素std::find 用于找出 给定值 在容器中第一次的出现。它有三个参数：序列中起始元素的迭代器；序列中结束元素的迭代器；要搜索的值它的返回值：如果找到了与要搜索值相匹配的迭代器，就返回指向这个元素的迭代器；如果没找到，就返回容器的末端的迭代器。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;algorithm&gt;#include &lt;array&gt;#include &lt;iostream&gt; int main()&#123; std::array arr&#123; 13, 90, 99, 5, 40, 80 &#125;; std::cout &lt;&lt; \"Enter a value to search for and replace with: \"; int search&#123;&#125;; int replace&#123;&#125;; std::cin &gt;&gt; search &gt;&gt; replace; // Input validation omitted // std::find returns an iterator pointing to the found element (or the end of the container) // we'll store it in a variable, using type inference to deduce the type of // the iterator (since we don't care) auto found&#123; std::find(arr.begin(), arr.end(), search) &#125;; // Algorithms that don't find what they were looking for return the end iterator. // We can access it by using the end() member function. if (found == arr.end()) &#123; std::cout &lt;&lt; \"Could not find \" &lt;&lt; search &lt;&lt; '\\n'; &#125; else &#123; // Override the found element. *found = replace; &#125; for (int i : arr) &#123; std::cout &lt;&lt; i &lt;&lt; ' '; &#125; std::cout &lt;&lt; '\\n'; return 0;&#125;Sample run when the element is found12Enter a value to search for and replace with: 5 23413 90 99 234 40 80Sample run when the element isn’t found123Enter a value to search for and replace with: 0 234Could not find 013 90 99 5 40 80使用std::find_if查找与某个条件匹配的元素有时，我们想要查看容器中是否有匹配某些条件的值(例如，包含特定子字符串的字符串)，而不是确切的值。std::find_if函数的工作方式与std::find类似，但它不传递要搜索的值，而是传入一个可调用的对象（如：函数的指针）检查是否找到匹配项。std::find_if将为每个元素调用这个函数，直到找到匹配的元素，则返回该元素对应的迭代器；当没有匹配成功时，返回容器的最后一个迭代器；下面是一个例子，我们使用std::find_if来检查是否有包含子字符串“nut”的元素:1234567891011121314151617181920212223242526272829303132333435#include &lt;algorithm&gt;#include &lt;array&gt;#include &lt;iostream&gt;#include &lt;string_view&gt; // Our function will return true if the element matchesbool containsNut(std::string_view str)&#123; // std::string_view::find returns std::string_view::npos if it doesn't find // the substring. Otherwise it returns the index where the substring occurs // in str. return (str.find(\"nut\") != std::string_view::npos);&#125; int main()&#123; std::array&lt;std::string_view, 4&gt; arr&#123; \"apple\", \"banana\", \"walnut\", \"lemon\" &#125;; // Scan our array to see if any elements contain the \"nut\" substring auto found&#123; std::find_if(arr.begin(), arr.end(), containsNut) &#125;; if (found == arr.end()) &#123; std::cout &lt;&lt; \"No nuts\\n\"; &#125; else &#123; std::cout &lt;&lt; \"Found \" &lt;&lt; *found &lt;&lt; '\\n'; &#125; return 0;&#125;/*结果*/Found walnut //walnut这个字符串包含子串“nut”使用std::count和std::count_if来计算出现的次数std::cout搜索”一个元素”的所有出现情况。std::count_if搜索”一个满足条件的元素”的所有出现情况。在下面的例子中，我们将计算有多少元素包含子字符串“nut”:1234567891011121314151617181920212223#include &lt;algorithm&gt;#include &lt;array&gt;#include &lt;iostream&gt;#include &lt;string_view&gt; bool containsNut(std::string_view str)&#123; return (str.find(\"nut\") != std::string_view::npos);&#125; int main()&#123; std::array&lt;std::string_view, 5&gt; arr&#123; \"apple\", \"banana\", \"walnut\", \"lemon\", \"peanut\" &#125;; auto nuts&#123; std::count_if(arr.begin(), arr.end(), containsNut) &#125;; std::cout &lt;&lt; \"Counted \" &lt;&lt; nuts &lt;&lt; \" nut(s)\\n\"; return 0;&#125;/*结果*/Counted 2 nut(s)使用std::sort来定制排序我们以前使用std::sort按升序对数组排序，但是std::sort可以做得更多。std::sort可以让我们：它接受一个函数作为它的第三个参数，允许我们按照自己的喜好进行排序。该函数接受两个参数进行比较：如果第一个参数的顺序应该排在第二个参数之前，则返回true。默认情况下，std::sort按升序排列元素。让我们使用std::sort来使用一个名为”greater”的自定义比较函数对数组进行倒序排序:1234567891011121314151617181920212223242526272829#include &lt;algorithm&gt;#include &lt;array&gt;#include &lt;iostream&gt; bool greater(int a, int b)&#123; // Order @a before @b if @a is greater than @b. return (a &gt; b);&#125; int main()&#123; std::array arr&#123; 13, 90, 99, 5, 40, 80 &#125;; // Pass greater to std::sort std::sort(arr.begin(), arr.end(), greater); for (int i : arr) &#123; std::cout &lt;&lt; i &lt;&lt; ' '; &#125; std::cout &lt;&lt; '\\n'; return 0;&#125;/*结果*/99 90 80 40 13 5小技巧：因为按降序排序是很常见的，所以c++也为它提供了一个自定义类型(名为std::greater，在头文件&lt;functional&gt;中)。在上面的例子中：1234567891011//我们呢可以将下面语句：std::sort(arr.begin(), arr.end(), greater); // call our custom greater function//替换为：std::sort(arr.begin(), arr.end(), std::greater&#123;&#125;); // use the standard library greater comparison // Before C++17, we had to specify the element type when we create std::greaterstd::sort(arr.begin(), arr.end(), std::greater&lt;int&gt;&#123;&#125;); // use the standard library greater comparison/*注意*/std::greater&#123;&#125;的大&#123;&#125;需要花括号，因为它不是一个可调用的函数。它是一个类型，为了使用它，我们需要实例化该类型的对象。花括号实例化该类型的匿名对象(然后将其作为参数传递给std::sort)。使用std::for_each对容器的所有元素执行特定操作std::for_each接受一个列表作为输入，并对每个元素应用一个自定义函数。当我们希望对列表中的每个元素执行相同的操作时，这很有用。下面是一个例子，我们使用std::for_each来加倍数组中的所有数字:123456789101112131415161718192021222324252627#include &lt;algorithm&gt;#include &lt;array&gt;#include &lt;iostream&gt; void doubleNumber(int &amp;i)&#123; i *= 2;&#125; int main()&#123; std::array arr&#123; 1, 2, 3, 4 &#125;; std::for_each(arr.begin(), arr.end(), doubleNumber); for (int i : arr) &#123; std::cout &lt;&lt; i &lt;&lt; ' '; &#125; std::cout &lt;&lt; '\\n'; return 0;&#125;/*结果*/2 4 6 8","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://longlongqin.github.io/tags/C-C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"迭代","slug":"C&C++/迭代","date":"2020-05-02T09:12:57.000Z","updated":"2020-05-02T10:04:46.109Z","comments":true,"path":"archives/80469b0c.html","link":"","permalink":"https://longlongqin.github.io/archives/80469b0c.html","excerpt":"LearnCpp chapterLhttps://www.learncpp.com","text":"LearnCpp chapterLhttps://www.learncpp.com遍历数组的集中方法在编程中，遍历数据数组(或其他结构)是一件很常见的事情。到目前为止，我们已经介绍了许多不同的实现方法:使用循环和索引(for循环和while循环)，使用指针和指针算法，以及基于范围的for循环12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;array&gt;#include &lt;iostream&gt; int main()&#123; //在支持C++17时，可以使用： //std::array data&#123; 0, 1, 2, 3, 4, 5, 6 &#125;;//类型自动推断为std::array&lt;int, 7&gt; std::array&lt;int,7&gt; data&#123;0, 1, 2, 3, 4, 5, 6 &#125;; std::size_t length length&#123;std::size(data)&#125;; //同样需要在C++17中才可以使用 // while循环显式索引 std::size_t index&#123;0&#125;; while (index != length) &#123; std::cout &lt;&lt; data[index] &lt;&lt; ' '; ++index; &#125; std::cout &lt;&lt; '\\n'; // for循环显式索引 for (index = 0; index &lt; length; ++index) &#123; std::cout &lt;&lt; data[index] &lt;&lt; ' '; &#125; std::cout &lt;&lt;'\\n'; //带有指针的for循环(注意:ptr不能是const，因为我们需要对它递增) /*使用指针和指针运算进行循环是冗长的，而且可能会使不了解指针运算规则的读者感到困惑。 指针运算也只有在元素在内存中是连续的情况下才有效(这对于数组是正确的，但是对于其他类型 的容器，例如list、tree和map，则不是正确的)。*/ for(auto ptr &#123;&amp;data[0]&#125;; ptr!=(&amp;data[0]+length); ++ptr) &#123; std::cout &lt;&lt;*ptr&lt;&lt;'\\n'; &#125; std::cout &lt;&lt;'\\n'; //基于范围的for循环 for(int i; data) &#123; std::cout &lt;&lt;i&lt;&lt;'\\n'; &#125; std::cout &lt;&lt;'\\n'; return 0; &#125;如果我们只使用索引来访问元素，那么使用索引进行循环比需要的类型更多。它也只有在容器(例如array)提供对元素的直接访问时才有效(数组可以这样做，但是其他类型的容器，如list则不行)。基于范围的for循环更有趣一些，因为遍历容器的机制是隐藏的——但是，它们仍然适用于各种不同的结构(数组、列表、树、映射等等)。它们是如何工作的?他们使用迭代器。迭代器(iterator)迭代器是一个设计用来遍历容器的对象(例如数组中的值、字符串中的字符)，提供对每个元素的访问。容器可以提供不同种类的迭代器。例如，一个数组容器可能提供：一个按正向顺序遍历数组的正向迭代器，以及一个按反向顺序遍历数组的反向迭代器。因为c++迭代器通常使用相同的接口进行遍历 (操作符++移动到下一个元素) 和访问 (操作符*访问当前元素)，所以我们可以使用一致的方法迭代各种不同的容器类型。指针作为迭代器最简单的迭代器是指针，它(使用指针运算)对内存中顺序存储的数据起作用。让我们重新访问一个简单的数组遍历使用指针和指针运算:1234567891011121314151617181920212223#include &lt;array&gt;#include &lt;iostream&gt;int main()&#123; std::array data &#123; 0, 1, 2, 3, 4, 5, 6 &#125;; auto begin&#123;&amp;data[0]&#125;; //注意，它指向最后一个元素之外的一个点 auto end &#123;begin + std::size(data)&#125;; //带有指针的for循环 for(auto ptr&#123;begin&#125;; ptr != end; ++ptr) &#123; std::cout &lt;&lt; *ptr &lt;&lt; ' '; // 解引用 to get value of current element &#125; return 0；&#125;/*结果*/0 1 2 3 4 5 6注意：你可能会这样做：int* end {&amp;array[std::size(array)]};但是者会造成未定义行为，因为array[std::size(array)]会访问数组最后的一个元素的下一个元素。(因为 std::size(array)计算数组大小，但是要记得数组下标是从0开始的呀。)标准库中的迭代器迭代是如此常见的操作，以至于所有标准库容器都提供了对迭代的直接支持。它不需要计算我们自己的开始点和结束点，我们可以通过函数begin()和end()简单地向容器请求开始点和结束点:注意：函数``begin()和end()`得到的是 开始 和 结束的位置（即，得到的是一个地址）123456789101112131415161718192021#include &lt;array&gt;#include &lt;iostream&gt;int main()&#123; std::array&lt;int , 3&gt; a&#123; 1, 2, 3 &#125;; //向我们的数组请求开始和结束点(通过begin()和end()成员函数)。 auto bengin&#123;array.begin()&#125;; auto end &#123;array.end()&#125;; for (auto p&#123;begin&#125;; p!=end; ++p) &#123; std::cout &lt;&lt; *p &lt;&lt; ' '; // 解引用 to get value of current element. &#125; return 0;&#125;/*结果*/1 2 3头文件&lt;iterator&gt;中的std::begin、 std::end1234567891011121314151617181920#include &lt;array&gt;#include &lt;iostream&gt;#include &lt;iterator&gt; // For std::begin and std::end⭐ int main()&#123; std::array array&#123; 1, 2, 3 &#125;; // Use std::begin and std::end to get the begin and end points. auto begin&#123; std::begin(array) &#125;; //⭐ auto end&#123; std::end(array) &#125;; //⭐ for (auto p&#123; begin &#125;; p != end; ++p) // ++ to move to next element &#123; std::cout &lt;&lt; *p &lt;&lt; ' '; // dereference to get value of current element &#125; std::cout &lt;&lt; '\\n'; return 0;&#125;基于范围的for循环的begin()、end()所有具有begin()和end()成员函数的类型，或者可以与std::begin和std::end一起使用的类型，都可以在基于范围的for循环中使用。12345678910111213141516#include &lt;array&gt;#include &lt;iostream&gt; int main()&#123; std::array&lt;int,3&gt; array&#123; 1, 2, 3 &#125;; // This does exactly the same as the loop we used before. for (int i : array) &#123; std::cout &lt;&lt; i &lt;&lt; ' '; &#125; std::cout &lt;&lt; '\\n'; return 0;&#125;⭐在后台，基于范围的for循环调用要遍历的类型的begin()和end()。std::array为什么可以在基于范围的for循环中使用？答：因为std::array中含有begin()和end()成员函数，所以他可以在基于范围的for循环中使用。c风格的固定数组可以与std::begin和std::end函数一起使用，因此我们也可以使用基于范围的for循环遍历它们。动态数组不可以在基于范围的for循环中使用？答：是的，因为它们没有std::end函数(因为类型信息不包含数组的长度)。迭代器失效(空悬迭代器)就像指针和引用一样，如果 迭代的元素更改了地址 或 被销毁 时迭代器会被“悬空”。当这种情况发生时，我们说迭代器已经失效。访问无效的迭代器会产生未定义的行为。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://longlongqin.github.io/tags/C-C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"std::vector","slug":"C&C++/std：：vector","date":"2020-05-02T02:48:38.000Z","updated":"2020-05-02T08:06:51.674Z","comments":true,"path":"archives/40d82c05.html","link":"","permalink":"https://longlongqin.github.io/archives/40d82c05.html","excerpt":"LearnCpp chapterPhttps://www.learncpp.com","text":"LearnCpp chapterPhttps://www.learncpp.com介绍std::vector在c++ 03中引入的std::vector提供了处理自身内存管理的动态数组功能。这意味着您可以创建在运行时设置长度的数组，而不必使用new和delete显式地分配和释放内存。它在头文件 &lt;vector&gt;中声明及初始化std::vector123456789#include &lt;vector&gt;//不需要在初始化时指定长度std::vector&lt;int&gt; array;std::vector&lt;int&gt; array2 = &#123;9, 7, 5, 3, 1 &#125;; //使用初始化器列表初始化数组std::vector&lt;int&gt; array3 = &#123;9, 7, 5, 3, 1 &#125;; //使用统一的初始化来初始化数组(c++ 11开始)//从C++17开始，类型也可以省略std::vector array4 &#123;9, 7, 5, 3, 1 &#125;; //推导出std::vector&lt; int &gt;🐖：您不需要在编译时包含数组长度。这是因为std::vector将根据请求为其内容动态分配内存。访问数组元素就像std::array一样，你可以使用 操作符[](没有边界检测) 或者 函数at()(与边界检测功能) 来访问数组元素：12array[6] = 2; // no bounds checkingarray.at(7) = 3; // does bounds checkingC++11中为std::vector赋值从c++ 11开始，您还可以使用初始化器列表为std::vector赋值:12array = &#123; 0, 1, 2, 3, 4 &#125;; // okay, array length is now 5array = &#123; 9, 8, 7 &#125;; // okay, array length is now 3在这种情况下，vector将自调整大小以匹配提供的元素数量。自我清理可以防止内存泄漏当vector 超出它所在的范围时，它会自动释放它所控制的内存。这不仅方便(不用手动清楚除)，而且还可以防止内存泄漏。123456789101112//看一个例子void do(bool earlyExit)&#123; int *array &#123;new int[5] &#123; 9, 7, 5, 3, 1 &#125; &#125;; if(earlyExit) return; //其他代码 delete[] array; //never called&#125;//如果earlyExit被设置为true，那么就不会执行delete语句，也就是说该内存不会被释放，就会发生内存泄漏但是，如果数组是std::vector，则不会发生这种情况，因为一旦数组超出作用域，内存就会被释放(不管函数是否提前退出)。这使得std::vector比您自己分配内存要安全得多。vector记得它的长度不像内置的动态数组，它们不知道它们所指向的数组的长度，std::vector跟踪它的长度。我们可以通过size()函数求出vector的长度:123456789101112131415#include &lt;iostream&gt;#include &lt;vector&gt; void printLength(const std::vector&lt;int&gt;&amp; array)&#123; std::cout &lt;&lt; \"The length is: \" &lt;&lt; array.size() &lt;&lt; '\\n';&#125; int main()&#123; std::vector array &#123; 9, 7, 5, 3, 1 &#125;; printLength(array); return 0;&#125;注意：与std::array一样，size()返回嵌套类型size_type的值(上面例子中的完整类型是std::vector::size_type)，它是一个无符号整数。调整vector数组调整内置动态分配数组的长度非常复杂。调整std::vector的大小非常简单，只需要调用resize()函数一样简单:注意：当我们调整向量的大小时，现有的元素值将被保留!新元素初始化为类型的默认值(对于整数为0)。12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;vector&gt; int main()&#123; std::vector array &#123;0,1,2&#125;; array.resize(5); //将其长度设置为5⭐ std::cout &lt;&lt; \"The length is: \" &lt;&lt; array.size() &lt;&lt; '\\n'; for (int i : array) std::cout &lt;&lt; i &lt;&lt; ' '; std::cout &lt;&lt; '\\n'; return 0;&#125;/*结果*/The length is: 50 1 2 0 0调整vector的长度的代价很高，所以尽可能的少调整他们的长度。bool类型的压缩类型为bool的std::vector有一个特殊的实现，它将把8个布尔值压缩成一个字节! 这是在幕后发生的，不会改变您使用std::vector的方式。12345678910111213141516171819#include &lt;vector&gt;#include &lt;iostream&gt; int main()&#123; std::vector&lt;bool&gt; array &#123; true, false, false, true, true &#125;; std::cout &lt;&lt; \"The length is: \" &lt;&lt; array.size() &lt;&lt; '\\n'; for (int i : array) std::cout &lt;&lt; i &lt;&lt; ' '; std::cout &lt;&lt; '\\n'; return 0;&#125;/*结果*/The length is: 51 0 0 1 1如何理解“8布尔值为一个字节”这句话。数组的最大长度是255还是我理解错了?答：如果没有专门化，向量的每个元素将占用’ sizeof(bool) ‘字节。这浪费了很多空间，因为bool不是假就是真，所以bool只能容纳一个位。1个字节是8位，所以我们可以在1个字节中存储8个内存，这意味着我们可以存储8倍于元素数量的元素，而不需要使用更多的内存。（也就是说：std::vector的数组存储bool类型的值时，每一个值只占一个bit。）而这实现的机制是在由std::vector的设计者实现的，我们不用管","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://longlongqin.github.io/tags/C-C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"std::array","slug":"C&C++/std：：array","date":"2020-05-01T15:21:32.052Z","updated":"2020-05-02T02:42:16.602Z","comments":true,"path":"archives/c9c6ad08.html","link":"","permalink":"https://longlongqin.github.io/archives/c9c6ad08.html","excerpt":"LearnCpp chapterPhttps://www.learncpp.com","text":"LearnCpp chapterPhttps://www.learncpp.com在之前的文章中，已经提到了：“固定长度数组”：当传入函数参数时它会退化为指针，失去数组长度信息，；“动态数组”：动态数组的释放问题；为了解决这些问题，c++标准库包含了简化数组管理的功能:std::array和std::vector。这节课我们将学习std::array，下节课我们将学习std::vector。介绍std::array在c++ 11中引入的std::array提供了在传递给函数时不会退化的固定数组功能。std::array是在命名空间std中的头文件&lt;array&gt;中定义的。声明一个std::array变量123#include &lt;array&gt;std::array&lt;int , 3&gt; myarray; //声明一个整型数组，它的长度为3就像普通的固定长度数组一样，std::array定义的数组的长度也必须是“编译时常量”std::array的初始化可以使用“初始化器列表” 或者 “统一初始化”初始化器列表1std::array&lt;int,5&gt; myarray = &#123;9, 7, 5, 3, 1&#125;;统一初始化1std::array&lt;int,5&gt; myarray &#123;9, 7, 5, 3, 1&#125;;注意：初始化时不能省略数组长度不像内置的固定数组，std::array初始化数组时，不能省略数组长度：12std::array&lt;int,&gt; myarray&#123;9, 7, 5, 3, 1&#125;; //✖，需要显式的输入数组长度std::array&lt;int&gt; myarray&#123;9, 7, 5, 3, 1&#125;; //✖，需要显式的输入数组长度在C++17中，是可以的但是，由于c++ 17，允许省略类型和大小。只有在数组显式初始化的情况下，才可以同时忽略它们，但不能忽略其中一个。12std::array myarray &#123;9, 7, 5, 3, 1&#125;; //The type is deduced to std::array&lt;int, 5&gt;std::array myArray &#123; 9.7, 7.31 &#125;; // The type is deduced to std::array&lt;double, 2&gt;对std::array数组赋值可以使用初始化器列表向数组赋值：1234std::array&lt;int,5&gt; myarray;myarray = &#123; 0, 1, 2, 3, 4 &#125;; // okaymyarray = &#123; 9, 8, 7 &#125;; // okay, elements 3 and 4 are set to zero!myarray = &#123; 0, 1, 2, 3, 4, 5 &#125;; // ✖, too many elements in initializer list!边界检查(使用at()函数)与内置的固定数组一样，下标操作符不执行任何边界检查。如果提供了无效的索引，可能会发生不好的事情。但是，std::array提供了第二种访问数组元素的方法：使用函数at()。它带有检测边界的功能。第一种 就是普通的数组访问形式123std::array myArray &#123; 9, 7, 5, 3, 1 &#125;;myArray.at(1) = 6; // array element 1 valid, sets array element 1 to value 6myArray.at(9) = 10; // array element 9 is invalid, will throw an error在上面的例子中，调用array.at(1)检查以确保数组元素1是有效的，因为它是有效的，所以它返回对数组元素1的引用。然后我们给它赋值6。但是，对array.at(9)的调用失败，因为数组元素9超出了数组的界限。at()函数不是返回一个引用，而是抛出一个错误来终止程序(注意:它实际上抛出了一个std::out_of_range类型的异常——我们在第15章讨论了异常)。因为它执行边界检查，所以at()比操作符[]慢(但更安全)。std::array的数组会自动清理当std::array数组超出作用域时，它会自己清理，所以不需要做任何手动清理。数组大小（使用函数size()）size()函数可以用来检索std::数组的长度:12345std::array myArray &#123; 9.0, 7.2, 5.4, 3.6, 1.8 &#125;;std::cout &lt;&lt; \"length: \" &lt;&lt; myArray.size() &lt;&lt; '\\n';/*结果*/length: 5函数size()在函数调用中也能工作因为std::array在传递给函数时不会衰减为指针，所以size()函数即使在函数中调用也可以工作:12345678910111213141516171819#include &lt;array&gt;#include &lt;iostream&gt; void printLength(const std::array&lt;double, 5&gt; &amp;myArray)&#123; std::cout &lt;&lt; \"length: \" &lt;&lt; myArray.size() &lt;&lt; '\\n';&#125; int main()&#123; std::array myArray &#123; 9.0, 7.2, 5.4, 3.6, 1.8 &#125;; printLength(myArray); return 0;&#125;/*结果*/length: 5函数传递时使用引用传递还要注意，我们通过“引用”或“const 引用” 将std::array 数组传入函数参数。这是为了防止编译器在将std::数组传递给函数时(出于性能原因)复制std::array。std::array的排序（用std::sort）您可以使用std::sort(在头文件&lt;algorithm&gt;中)对std::array进行排序：12345678910111213141516171819#include &lt;algorithm&gt; //for std::sort#include &lt;array&gt;#include &lt;iostream&gt;int main()&#123; std::array myArray &#123; 7, 3, 1, 9, 5 &#125;; std::sort(myArray.begin(), myArray.end()); //由小到达排序 //std::sort(myArray.rbegin(), myArray.rend()); // 由大到小排序 for(int number : myArray) &#123; std::cout &lt;&lt;number&lt;&lt;' '; &#125; return 0;&#125;/*结果*/1 3 5 7 9手动索引数组(通过size_type)看下面一个例子，它错哪里了？123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt; int main()&#123; std::array&lt;int, 5&gt; myArray =&#123; 7, 3, 1, 9, 5 &#125;; // Iterate through the array and print the value of the elements for (int i&#123; 0 &#125;; i &lt; myArray.size(); ++i) std::cout &lt;&lt; myArray[i] &lt;&lt; ' '; std::cout &lt;&lt; '\\n'; return 0;&#125;答案：由于“有符号” 与 “无符号” 的冲突。“siez()函数” 和 “数组的索引参数(在操作符[]中)” 的类型叫做：size_typesize_type：由c++标准定义为无符号整数类型。我们的循环计数器/索引(变量i)是一个有符号整数。因此，在上面代码中的：i &lt; myArray.size() 与 myArray[i] 都出现了类型不匹配问题。siez_type是局部类型非常有趣的是，size_type不是一个全局类型(像int或std::size_t)。相反，它是在std::array的定义 中定义的(c++允许嵌套类型)。这意味着，当我们想要使用size_type时，我们必须在它前面加上完整的数组类型(在这方面，可以将std::array看作一个名称空间)。在上面的例子中，全前缀的“size_type”类型是std::array::size_type!所以，上面代码的正确写法为：1234567891011121314151617#include &lt;array&gt;#include &lt;iostream&gt;int main()&#123; std::array&lt;int, 5&gt; myArray =&#123; 7, 3, 1, 9, 5 &#125;; //std::array&lt;int,5&gt;::size_type 是函数size()的返回类型 //因为std::array::size_type是std::size_t的别名（由上文可知）， //所以，可以使用std::size_t来替换std::array::size_type（我这里就不替换了） for(std::array&lt;int, 5&gt;::size_type i&#123; 0 &#125;; i &lt; myArray.size(); ++i) std::cout &lt;&lt; myArray[i] &lt;&lt; ' '; std::cout &lt;&lt; '\\n'; return 0;&#125;避免手动索引数组更好的解决方案是首先避免对std::array进行手动索引。相反，如果可能的话，使用基于范围的for循环(或迭代器)。结构体数组当然std::array并不局仅仅限于数字作为元素的。可以在常规数组中使用的所有类型都可以在std::array中使用。1234567891011121314151617181920212223242526272829303132#include &lt;array&gt;#include &lt;iostream&gt; struct House&#123; int number&#123;&#125;; int stories&#123;&#125;; int roomsPerStory&#123;&#125;;&#125;; int main()&#123; std::array&lt;House, 3&gt; houses&#123;&#125;; //⭐ houses[0] = &#123; 13, 4, 30 &#125;; houses[1] = &#123; 14, 3, 10 &#125;; houses[2] = &#123; 15, 3, 40 &#125;; for (const auto&amp; house : houses) &#123; std::cout &lt;&lt; \"House number \" &lt;&lt; house.number &lt;&lt; \" has \" &lt;&lt; (house.stories * house.roomsPerStory) &lt;&lt; \" rooms\\n\"; &#125; return 0;&#125;/*结果*/House number 13 has 120 roomsHouse number 14 has 30 roomsHouse number 15 has 120 rooms错误的初始化123456// Doesn't work.std::array&lt;House, 3&gt; houses&#123; &#123; 13, 4, 30 &#125;, &#123; 14, 3, 10 &#125;, &#123; 15, 3, 40 &#125;&#125;正确的初始化注：⭐结构体数组的初始化还是不太明白，等后面再继续完善⭐—–2020-05-02 10:39:3212345678910111213141516171819202122232425262728293031#include &lt;iostream&gt; struct House&#123; int number&#123;&#125;; int stories&#123;&#125;; int roomsPerStory&#123;&#125;;&#125;; struct Array&#123; House value[3]&#123;&#125;;&#125;; int main()&#123; // With braces, this works.⭐（正确的初始化） Array houses&#123; &#123; &#123; 13, 4, 30 &#125;, &#123; 14, 3, 10 &#125;, &#123; 15, 3, 40 &#125; &#125; &#125;; for (const auto&amp; house : houses.value) &#123; std::cout &lt;&lt; \"House number \" &lt;&lt; house.number &lt;&lt; \" has \" &lt;&lt; (house.stories * house.roomsPerStory) &lt;&lt; \" rooms\\n\"; &#125; return 0;&#125;小结std::array是内置固定数组的一个很好的替代品。它是有效的，因为它不比内置的固定数组使用更多的内存。唯一的缺点std::array在内置的固定数组是一个略微尴尬的语法,你必须显式地指定数组长度(编译器不会为你计算它的初始化,除非你还省略了类型)，所以，一般建议使用std::array来替代内置类型的固定长度数组。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://longlongqin.github.io/tags/C-C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"指向指针的指针与动态多维数组","slug":"C&C++/指向指针的指针与动态多维数组","date":"2020-05-01T09:43:02.209Z","updated":"2020-05-01T15:19:42.805Z","comments":true,"path":"archives/5937092e.html","link":"","permalink":"https://longlongqin.github.io/archives/5937092e.html","excerpt":"LearnCpp chapterPhttps://www.learncpp.com","text":"LearnCpp chapterPhttps://www.learncpp.com指向指针的指针表示保存另一个指针地址的指针。一个普通的指针：1int *ptr; //指向整数的指针，一个星号指向指针的指针：1int **ptr; //一个指向整型的指针，两个星号“指向指针的指针”的解引用指向指针的指针的工作方式与普通指针一样—可以对它解引用以检访问它指向的值。由于指向指针的指针的值是另一个指针的地址，所以第一次解引用后 访问的值 是一个地址；你还可以再一次的 解引用，第二次的解引用之后 访问的就是一个值（不再是地址了）。123456789101112int value = 5;int *ptr = &amp;value;std::cout &lt;&lt; *ptr; //解引用指向int类型的指针ptr，来访问该int值int **ptrptr = &amp;ptr;std::cout &lt;&lt; **ptrptr; //第一个解引用获取指向int的指针，第二个解引用获取int值/*结果*/55不可以将“指向指针的指针”直接指向值1234int value = 5;int **ptrptr = &amp;&amp;value; //✖，因为取地址符(&amp;)需要的是 左值(l-value)，但是 &amp;value 是一个 右值(r-value)“指向指针的指针”可以被设置为null1int **ptrptr = nullptr; ////在c++ 11之前使用0指针数组指针的指针有几个用途。最常见的用法是动态分配指针数组:1int* array = new int*[10]; //分配一个有10个int型指针数组这就像一个标准的动态分配数组，除了数组元素的类型是“指向整型的指针”，而不是 整数。二维动态数组的分配指针到指针的另一个常见用法是用于：动态分配多维数组固定长度的二维数组的声明：1int array[10][5];二维动态数组的分配有点复杂。你第一时间可能会想到这样写：1int **array = new int[10][5]; //✖。正确方式：这里有两个可能的解决方案。1、最右边的数组维度是编译时常量当最右边的数组维度是编译时常量，可以这样做:最右边的数组维度是编译时常量：比如：a[ ] [5]，它数组中最右边的维度是确定的（5）12int (*array)[5] = new int [10][5];//小括号不能少，因为优先级的关系呀在C++11及之后，更推荐使用auto类型：1auto array = new int[10][5];2、最右边的数组的维度不是编译时常量时当最右边的数组的维度不是编译时常量时，就比较复杂了，我们需要：首先，我们分配一个指针数组；然后，我们遍历指针数组并为每个数组元素分配一个动态数组。我们的动态二维数组是一个动态一维数组的动态一维数组。12345int **array = new int*[10]; //分配一个包含10个整型指针的数组——这些是我们的行 for(int i=0; i&lt;10; ++i) &#123; array[i] = new int[5]; //这是我们的列 &#125;注意，因为每个数组列是独立动态分配的，所以每一行的列数可以不一样呀：12345int **array = new int*[10];for(int i=0; i&lt;10; ++i)&#123; array[i] = new int[i+1]; //这是我们的列（⭐这里的每一行的列数都不一样）&#125;释放动态二维数组使用这种方法释放一个动态分配的二维数组也需要一个循环:123for(int i=0; i&lt;10; ++i) delete[] array[i];delete[] array; //这需要放在最后注意，我们删除数组的顺序与创建它的顺序相反(首先是元素，然后是数组本身)。如果我们先删除数组，再去删除数组元素时，会导致未定义行为。因为我们在删除数组元素时必须访问数组，才知道每个数组元素。但是此时，我们早已经删除了数组，就会发生未定义行为。小结我们建议避免使用指针到指针，除非没有其他可用的选项，因为它们使用起来很复杂，而且有潜在的危险。使用普通指针来解引用空指针或悬空指针是非常容易的—使用指针来解引用指针是非常容易的，因为您必须执行两次解引用才能获得底层的值!","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://longlongqin.github.io/tags/C-C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"void 指针","slug":"C&C++/Void指针(泛型指针)","date":"2020-05-01T08:44:31.757Z","updated":"2020-05-01T09:43:59.129Z","comments":true,"path":"archives/f482f5a8.html","link":"","permalink":"https://longlongqin.github.io/archives/f482f5a8.html","excerpt":"LearnCpp chapterPhttps://www.learncpp.com","text":"LearnCpp chapterPhttps://www.learncpp.comvoid指针的声明void指针，也称为“泛型指针”。是指针的一种特殊类型，它可以指向任何数据类型的对象!void指针像普通指针一样声明，使用void关键字作为指针的类型:1void *ptr;void指针可以指向任何数据类型的对象:123456789101112131415int nValue;float fValue;struct something&#123; int n; float f;&#125;something sValue;void *ptr;ptr = &amp;nValue; //✔ptr = &amp;fValue; //✔ptr = &amp;sValue; //✔void指针不能被 解引用但是，因为void指针不知道它所指向的对象的类型，所以不能直接解引用！相反，void指针必须先显式地转换为另一种指针类型，然后才能解引用。123456789int value &#123;1&#125;;void *voidPtr &#123;&amp;value&#125;;//⭐✖，void指针 不能 解引用std::cout &lt;&lt; *voidPtr &lt;&lt; '\\n'; //⭐✔，我们可以将void指针 类型转换为 其他指针类型(这里是 int型指针)，int *intPtr &#123;static_cast&lt;int*&gt;(voidPtr)&#125;;std::cout &lt;&lt; *intPtr; ////然后就可以 解引用 了一个明显的问题当void指针不知道指向什么，我们如何转换类型，这取决于程序猿的设定：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;enum class Type&#123; INT, FLOAT, CSTRING&#125;;void printValue(void *ptr, Type type)&#123; switch(type) &#123; //转换为整型指针 并 解引用 case Type::INT: std::cout &lt;&lt;* static_cast&lt;int*&gt;(ptr)&lt;&lt;'\\n'; break; //转换为float指针 并 解引用 case Type::FLOAT: std::cout &lt;&lt;* static_cast&lt;float*&gt;(ptr)&lt;&lt;'\\n'; break; //转换为char指针 但 没有解引用⭐ case Type::CSTRING: std::cout &lt;&lt; static_cast&lt;char*&gt;(ptr)&lt;&lt;'\\n'; //std::cout知道将char*作为c风格的字符串 //如果我们要解引用的话，那就只会打印ptr所指向的单个字符 break; &#125;&#125;int main()&#123; int nValue&#123; 5 &#125;; float fValue&#123; 7.5f &#125;; char szValue[]&#123; \"Mollie\" &#125;; printValue(&amp;nValue, Type::INT); printValue(&amp;fValue, Type::FLOAT); printValue(&amp;szValue, Type::CSTRING); return 0;&#125;结果：如果，我们将第26行改为：std::cout &lt;&lt;* static_cast&lt;char*&gt;(ptr)&lt;&lt;&#39;\\n&#39;;（即，让它 解引用）。结果：可以看到：如果我们要解引用的话，那就只会打印ptr所指向的单个字符void指针可以指向空值(nullptr)1void *ptr&#123;nullptr&#125;;void指针不能做指针运算因为指针运算需要知道 指针指向的对象的大小，但是void指针就不知道它指向的是什么。所以void指针不能做指针运算（如：++，–）不存在void引用因为一个“void reference”的类型是“void &amp;”,但是它不知道它引用的值的类型。小结1.除非必要，否则避免使用void指针通常，除非绝对必要，否则避免使用void指针是一个好主意，因为它们有效地允许您避免类型检查。这允许您在不经意间做一些毫无意义的事情，而编译器也不会抱怨。例如，以下内容是有效的:123//承接上面那段函数int nValue&#123; 5 &#125;;printValue(&amp;nValue, Type::CSTRING);它的结果是未知的，在我的电脑上，结果为：2.void指针与null指针的区别void指针：是一个指针，它可以指向任何类型的对象，但不知道它指向什么类型的对象。空指针必须被显式地转换成另一种确切的类型的指针才能 解引用。null指针：空指针是不指向地址的指针。void指针可以是一个null指针","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://longlongqin.github.io/tags/C-C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"通过指针或引用访问结构体成员","slug":"C&C++/通过指针或引用访问成员变量(函数)","date":"2020-05-01T03:09:36.861Z","updated":"2020-05-01T09:43:59.135Z","comments":true,"path":"archives/7e63bcda.html","link":"","permalink":"https://longlongqin.github.io/archives/7e63bcda.html","excerpt":"LearnCpp chapterPhttps://www.learncpp.com","text":"LearnCpp chapterPhttps://www.learncpp.com众所周知，通常有一个指向结构(或类)的指针或引用。如前所述，您可以使用成员选择操作符(.)来选择结构体的成员:12345678struct Person&#123; int age; double weight;&#125;;Person person; // define a person//person.age = 5;这个语法也适用于 引用：12345678910struct Person&#123; int age; double weight;&#125;;Person person; // define a person//使用对结构体的引用来选择成员Person &amp;ref = person;ref.age = 5;但是，对于指针，您需要先解引用指针的:12345678910struct Person&#123; int age; double weight;&#125;;Person person; // define a person//使用指向结构体的指针进行成员选择Person *ptr = &amp;person;(*ptr).age = 5; //加小括号是必要的的，因为优先级的关系c++提供了第二个成员选择操作符(-&gt;)，用于从指针进行成员选择。以下两行是相等的:12(*ptr).age = 5;ptr-&gt;age = 5; //当使用指针来访问其成员时，推荐这种语法","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://longlongqin.github.io/tags/C-C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"引用与const","slug":"C&C++/引用与const","date":"2020-04-30T16:01:26.000Z","updated":"2020-05-01T09:43:59.135Z","comments":true,"path":"archives/960f81eb.html","link":"","permalink":"https://longlongqin.github.io/archives/960f81eb.html","excerpt":"LearnCpp chapterPhttps://www.learncpp.com","text":"LearnCpp chapterPhttps://www.learncpp.com引用const值就像可以声明指向const值的指针一样，也可以声明对const值的引用。这是通过使用const关键字声明引用来实现的。12const int value = 5;const int &amp;ref = value; //ref是对const值的引用对const值的引用通常被简称为const引用，尽管这确实导致了一些与指针不一致的命名法。初始化对const值的引用对非const值的引用，只能用非const l-value 初始化；⭐而对const值的引用，可以用 “非const l-value”、“constl-value”、“r-value”来初始化。1234567int x = 5;const int &amp;ref1 = x; //✔，x是一个 非const l-valueconst int y =7;const int &amp;ref2 =y; //✔，y是一个const l-valueconst int &amp;ref3 = 19; //✔，19是一个 r-value对const值的引用可以引用非const变量就像指向 const值 的指针一样，对const值的引用可以引用非const变量。其实就是说：不管你这个值原来是const值，还是 非const值。只用看我这个“引用”（或者 “指针”）是不是 对const值的引用（或者：是不是指向const值），如果是，那么不管你原来的值是不是const值，在我引用（指针指向）之后，我都把它看成是const值。关于如何判断一个引用是否引用的是const值，的方法类似于指针中的方法：就是看那个表示引用的符号“&amp;”的左边，如果左边带有关键字const，那么它就是引用的const值。对r-value的引用延长了引用值的生存期通常r-value具有表达式作用域，这意味着在创建它们的表达式结束时销毁这些值。1std::cout &lt;&lt;2+3; //2+3 的结果是 r-value 5，它会在该条语句结束时，被销毁但是，当使用r-value 初始化对const值的引用时，r-value的生存期将被延长为 引用的生存期。12345678910int dothing()&#123; const int &amp;ref = 2+3; //通常，2+3的结果具有表达式作用域，并在语句结束时销毁. //但是因为 2+3的结果现在已经被绑定到一个 对const值的引用 上面了， //所这个r-value的生命周期被延长了 std::cout &lt;&lt; ref; //我们在这还可以用它 &#125; //当const引用终止时，r-value的生存期被延长到这里const值的引用作为函数参数用作函数参数的引用也可以是常量。这允许我们在不复制实参的情况下访问参数，同时保证函数不会改变被引用的值。12345// ref是传入参数的const引用，而不是副本void changN(const int &amp;ref)&#123; ref = 6; //✖，因为ref是 const&#125;const值的引用作为函数参数很有用。因为const值的引用，可以是：non-const l-valueconst l-valuea literal表达式的结果所以，上面这四种可以通过 const值的引用 被传入函数参数。123456789101112131415161718192021#include &lt;iostream&gt;void printIt(const int &amp;x)&#123; std::cout &lt;&lt; x;&#125;int main()&#123; int a =1; printIt(a); //非const l-value const int b = 2; printIt(b); //const l-value printIt(3); //字面常量 r-value printIt(2+b); //表达式 r-value return 0;&#125;小结1、为了避免不必要的、代价昂贵的复制，通常应该通过(const)引用传递非指针非 基本数据类型(int、double等)的变量。（如structs等，可通过 引用 传入函数）2、基本数据类型应该通过值传递，当函数需要更改它们时，才使用 引用 传入函数。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://longlongqin.github.io/tags/C-C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"引用变量","slug":"C&C++/引用变量","date":"2020-04-30T12:20:43.000Z","updated":"2020-05-01T09:43:59.132Z","comments":true,"path":"archives/fa14c975.html","link":"","permalink":"https://longlongqin.github.io/archives/fa14c975.html","excerpt":"LearnCpp chapterPhttps://www.learncpp.com","text":"LearnCpp chapterPhttps://www.learncpp.com目前为止我们已经讲过两种基本变量类型：普通变量，直接保存值。指针，它持有另一个值的地址(或null)，可以解引用以获取它们指向的地址的值。现在，我们就来讲一下C++中的第三种基本类型：引用(Reference)引用的概念reference（引用）是C++变量的一个类型，它充当另一个对象或值的别名。C++支持三种种引用引用 非const值（通常简称“reference”，或 non-const reference）引用 const值（通常叫做：const reference）C++11增添了 r-value reference引用非const值引用(对非const值的引用) 是通过引用 “类型” 和”变量名”之间的&amp;来声明的:123456int value &#123;5&#125;; //普通变量//下面写法都是一样的的效果int &amp; ref&#123;value&#125;; //引用变量值int&amp; ref&#123;value&#125;;int &amp;ref&#123;value&#125;;引用作为别名引用的作用通常与它们所引用的值相同。在这个意义上，引用充当被引用对象的别名。例如:1234int x&#123;5&#125;;int &amp;y&#123;x&#125;; //y是x的引用int &amp;z&#123;y&#125;; //z也是x的引用上面的代码片段。设置或获取x、y或z的值将做相同的事情(那就是设置或获取x的值)。看一看引用的实际应用：1234567891011121314151617181920212223242526#include &lt;iostream&gt;int main()&#123; int value &#123;5&#125;; //普通的int型变量 int &amp;ref&#123;value&#125;; //引用变量value value = 6; //变量value 的值现在是6 ref = 7; //变量value 的值现在是7 std::cout &lt;&lt;value&lt;&lt;'\\n'; //结果为7 ++ref; std::cout &lt;&lt;value&lt;&lt;'\\n'; //结果为8 //看一看：value 和 ref的地址 std::cout &lt;&lt; &amp;value; std::cout &lt;&lt; &amp;ref; return 0;&#125;/*结果*/78006FFD30006FFD30在上面的例子中，ref和value被视为是相同的。(可以看到ref和value的地址都是一样的)。l-values and r-valuesl-values and r-values：左值 与 右值左值在C++中，变量是l-value（左值）的一种类型；左值是一个有地址的值(在内存中)。因为所有的变量都有地址，所以所有的变量都是左值。之所以称为l-value，是因为l-value是赋值语句左边惟一的值。当我们赋值时，赋值操作符的左边必须是I-value。所以，像这种句子： 5 = 6;将会造成编译错误，因为5不是I-value。字面值5是没有地址的（即，它不在内存中）。当一个I-value被赋值时，该内存地址的当前值将被覆盖。右值与l-value相反的是r-value。r-value是一个非l-value的表达式。r-value的例子有字面值(比如5，结果是5)和非l-value的表达式(比如 2 + x)。下面是一些例子：12345678int y; //将y定义为一个整型变量y=4; //4 的结果是4，然后赋值给yy=2+5; //2+5 的结果是7，然后赋值给yint x; //将x定义为一个整型变量x=y; //y的值是7(之前的值)，然后赋值给x。x=x; //x的结果是7，然后赋值给x(没用!)x=x+1; //x + 1 的结果等于8，然后赋值给x。分析：x=x+1x=x+1;这个语句看起来很迷糊。赋值操作符“=” 左边的“x”是一个I-value（有地址的变量）；赋值操作符“=” 右边的“x”是一个r-value，它将被计算并生成一个值（这里生成的值为7）。当c++对上述语句求值时，它的计算结果为:1x = 7 + 1; //这样就比较清晰了其实，可以分析为：在赋值操作符“=”的左侧，必须有表示内存地址的内容(例如变量)。赋值操作符“=”的右侧 的所有内容都将被计算以生成一个值。引用必须被初始化创建引用时必须初始化:12345int value &#123;5&#125;;int &amp;a &#123;value&#125;; //有效的引用，初始化为变量valueint &amp;b; //无效，因为没有被初始化不像指针可以持有空值，没有空引用这样的东西。引用 非const值 只能被初始化为非const 的左值对非const值的引用只能用非const l-value 初始化。不能使用const l-value或r-value初始化它们。123456789int x&#123;1&#125;;int &amp;a&#123;x&#125;; //✔，因为x是一个非常量的左值int &amp;b&#123;x+1&#125;; //✖，因为\"x+1\"是一个右值（它没有地址的）⭐int &amp;d&#123;6&#125;; //✖，因为6是一个右值⭐const int y&#123;2&#125;;int &amp;c&#123;y&#125;; //✖，因为y是一个 常量左值（**const l-value**）⭐引用不能被重新分配初始化后，不能将引用更改为引用另一个变量。考虑以下片段:123456int value1&#123;5&#125;;int value2&#123;7&#125;;int &amp;a&#123;value1&#125;; //✔，ref现在是value1的别名ref = vlaue2; //注意⭐：这里value2其实是一个右值。执行这个语句：就是将value2的值赋给value1。. 而不是将引用重新分配称为变量value2的别名呀~~~为了说明上面的那个语句：12345678910111213141516#include &lt;iostream&gt; //std::sortint main()&#123; int x&#123; 1 &#125;; int y&#123; 6 &#125;; std::cout &lt;&lt; \"x原来的值是：\" &lt;&lt; x &lt;&lt; '\\n'; int &amp;a&#123; x &#125;; a = y; std::cout &lt;&lt; \"引用a的值是：\" &lt;&lt; a&lt;&lt;'\\n'; std::cout &lt;&lt; \"x现在的值为：\" &lt;&lt; x &lt;&lt; '\\n'; std::cout &lt;&lt; \"因为引用‘a’是x的别名，a的值改变，所以x的值也会被改变\"; return 0;&#125;结果：引用作为函数参数在6.8 – Pointers and arrays 中，我们讨论了如何将指针参数传递给函数，使函数可以取消对指针的引用，从而直接修改参数的值。引用在这方面的工作类似。由于“引用”参数作为参数的别名，使用“引用”参数的函数可以修改传入的参数:12345678910111213141516171819202122#include &lt;iostream&gt;//ref是传入参数的 引用，而不是副本void changeN (int &amp;ref)&#123; ref = 6;&#125;int main()&#123; int n&#123;5&#125;; std::cout &lt;&lt; n &lt;&lt; '\\n'; changeN(n); //注意，这个参数不需要作为引用 std::cout &lt;&lt; n &lt;&lt; '\\n'; return 0;&#125;/*结果*/56 ⭐这里n的值变了呀当实参n被传递给函数时，函数参数ref被设置为参数n的引用。使用引用将c风格的数组传递给函数c风格数组最恼人的问题之一是，在大多数情况下，当求值时，它们会退化为指针。但是，如果通过引用传递c样式的数组，则不会发生这种退化。请注意，为了使其工作，您需要显式地在参数中定义数组大小。123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;iterator&gt;//注意:您需要在函数声明中指定数组大小void printElements(int (&amp;arr)[4] )&#123; //如果不支持C++17时，请改下面的语句（https://www.yuque.com/longlongqin/pw9qpx/dhwiyd#31df8e7e） int length &#123;static_cast&lt;int&gt;(std::size(arr))&#125;; //我们可以这样做，因为数组不会退化为指针//数组退化为指针可参考（https://www.yuque.com/longlongqin/pw9qpx/pmqm1f#Oaepi） for(int i&#123;0&#125;; i&lt;length; ++i) &#123; std::cout &lt;&lt;arr[i]&lt;&lt;'\\n'; &#125;&#125;int main()&#123; int arr[]&#123; 99, 20, 14, 80 &#125;; printElements(arr); return 0;&#125;引用和指针引用和指针之间有一种有趣的关系——引用就像一个指针，在被访问时被隐式地解引用(引用通常由编译器使用指针在内部实现)。从而得出以下结论:12345678int value &#123;1&#125;;int *const ptr &#123;&amp;value&#125;;int &amp;ref &#123;value&#125;;//可以看到：下面两个语句是相同的：*ptr = 5;ref = 5;由于必须将引用初始化为有效的对象(不能为空)，并且一旦设置就不能更改，因此使用引用通常比使用指针安全得多(因为没有取消引用空指针的风险)。如果给定的任务可以通过引用或指针来解决，那么通常应该首选引用。指针应该只在引用不足的情况下使用(比如动态分配内存)。小结引用允许我们为其他对象或值定义别名。对非const值的引用只能用非const l-value初始化。引用初始化后不能重新分配（也就是它初始化之后，就一直是那个变量的别名）。当我们想要修改参数的值时，或者当我们想要避免对参数进行昂贵的复制时，引用通常被用作函数参数。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://longlongqin.github.io/tags/C-C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"指针与const","slug":"C&C++/指针与const","date":"2020-04-30T07:29:16.000Z","updated":"2020-05-01T09:43:59.137Z","comments":true,"path":"archives/d0ade39e.html","link":"","permalink":"https://longlongqin.github.io/archives/d0ade39e.html","excerpt":"LearnCpp chapterPhttps://www.learncpp.com","text":"LearnCpp chapterPhttps://www.learncpp.com前言注：此文中的类型以int为例，当然也可以换成其他类型，如：double…..非const指针1、int *ptr123const int value = 5;int *ptr = &amp;value; //类型转换错误。✖//不能将“const int”类型（&amp;value）转换为“int *”（ptr）这很容易理解，假设上面片段可以编译成功。那也就是说，我们可以解引用这个非const的指针来改变这个值。这将会与const变量本质冲突（const的变量的值是不可以更改的）。2、const int *ptr若要声明指向const值的指针，请在数据类型之前使用const关键字:123const int value = 5; //一个int类型的变量value（值为5），value是\"const int\"const int *ptr = &amp;value; //✔，ptr是一个非const的指针，它指向一个“const int”*ptr = 6; //不允许，我们不能改变一个常量值在这里，不允许通过解引用指针 来改变value的值。ptr是一个非const的指针，它指向一个“const int” 就说明了，指针指向的是常量值，不能改变的奥指向const int 的指针，也可以指向非常量变量12int value = 5; //value 不是常量const int *ptr = &amp;value; //这样也是可以的我们可以这样想：一个指向const变量的指针在通过该指针访问该变量时将该变量视为常量，而不管变量最初是否定义为const(即，与变量最初是否为const无关)。因为指向const值的指针不是const本身(它只是指向一个const值)，所以可以将指针重定向到指向其他值:12345int value1 = 5;const int *ptr = &amp;value1; // ptr points to a const int int value2 = 6;ptr = &amp;value2; // ✔, ptr now points at some other const int当指向const int 的指针，它指向非const变量时：不可以通过 解引用该指针 来改变该非常量变量的值；但可以通过 直接对通过 变量的标识符 来改变该非常量变量的值。12345678910//可以int value = 5;const int *ptr = &amp;value;value = 6; //✔。因为当通过非const标识符（value是非const的标识符）访问时，//该值是非const的（所以我们可以直接通过变量的标识符来改变其值）//不可以int value = 5;const int *ptr = &amp;value; // ptr points to a \"const int\"*ptr = 6; // ✖。因为指针ptr将其值视为常量，因此通过ptr更改值是不合法的const指针const指针是指初始化后其值（即，它指向的地址）不能改变的指针。也就是说，const指针：只不过是该指针的值（它的值就是一个地址）不能被改变。（即，它只能指向初始化时给定的变量）但是，它指向变量的值是可以被修改的。声明const指针要声明一个const指针，请在”星号”和”指针名称”之间使用const关键字:12int value = 5;int * const ptr = &amp;value;与普通的const变量一样，const指针必须在声明时初始化为一个值这意味着const指针总是指向相同的地址。在上述情况下，ptr将始终指向value的地址(直到ptr goes out of scope并被销毁)。123456int a =5;int b =2;int * const ptr = &amp;a; //✔，这个const指针被初始化为变量a的地址；ptr = &amp;b; //✖，因为指针ptr是const。所以它一旦被初始化之后，该指针的值（它指向的地址）就不能被改变。但是，由于所指向的值仍然是非const的，所以可以通过解引用 const指针的来更改所指向的值:123int value = 5;int *const ptr = &amp;value; // ptr will always point to value*ptr = 6; // ✔，因为ptr指向的是一个非const的int型变量指向Const值的const指针我们可以把它差分成两部分：首先是一个 const指针（假如是int类型，变量标识符为a）：int * const a;(将这一部分看成大写字母A)然后是一个const的值：const A —–&gt;const int * const a;也就是在：类型（type）之前 和 变量名之前 使用关键字const 来声明一个指向Const值的const指针：12int value = 5;const int * const ptr = &amp;value;注意：指向const值的const指针不能设置为指向另一个地址，它所指向的值也不能通过指针进行更改。小结《请记住：const类型的变量（不管是指针还是正常变量）的声明与初始化是在一起完成的。》总而言之，你只需要记住4条规则，它们都很符合逻辑:一个非const指针可以被重定向到其他地址。12345int value1 =5;int *ptr1 = &amp;value1; //是 非const指针。（它指向的是非const变量的地址）int value2 =6;const int *ptr2 = &amp;value2;//也是 非const指针。（不过它指向的是 const变量的地址）一个const指针在初始化之后，它指向的地址就不能被改变了。12int value = 5;int * const ptr =&amp;value; //是 const指针。（它指向的是非const变量的地址）指向非const值的指针可以更改它所指向的值。但是这些指针不能指向一个常量(const)值。指向const值的const指针将该值视为const(即使它不是)，因此不能更改它所指向的值。12345678//1️⃣指向const值的指针将该值视为const(该值不是const)int value1 = 5;const int * const ptr1 = &amp;value; //ptr是一个指向const值的const指针，//所以，它指向的这个value1的值是不能被改变的。//2️⃣指向const值的指针将该值视为const(该值是const)const int value2 = 6;const int * const ptr2 = &amp;value2; //同样指针ptr2指向的value2的值也不能被改变保持声明语法的正确性是很有挑战性的。只要记住指针指向的值的类型总是在最左边:1234int value = 5;const int *ptr1 = &amp;value; //ptr1指向“const int”,这是一个指向const值的指针。int * const ptr2 = &amp;value; //ptr2指向“int”,这是一个指向非const值的const指针。const int * const ptr3 = &amp;value; //ptr3指向“const int” ,这是一个指向const值的const指针图示：突然想到：1、若要声明指向const值的指针，请在数据类型之前使用const关键字。（如下图的①、③）2、下面的①、②、③都可以指向 “非const 值”；3、是否可以通过指针的解引用来改变指针所指向的值。需要看该指针指向的值 是“const int” 还是 “int”？如果是“const int”，那就不能 解引用指针 去改变它所指向的值。如果是“int”，那就可以。4、一个指向const变量的指针在通过该指针访问该变量时将该变量视为常量(const)，而不管变量最初是否定义为const (即，与变量最初是否为const无关)。5、当指向“const int” 的指针，它指向非const变量时：不可以通过 解引用该指针 来改变该非常量变量的值；但可以通过 直接对通过 变量的标识符 来改变该非常量变量的值。再次提醒：本文只是以“int”类型来作为说明，我们可以换成其他类型，如：double等等用一个程序来说明：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt; int main()&#123; /************非const的变量***************/ int value1 = 1; int value2 = 2; int value3 = 3; int value4 = 4; //初始化 int *ptr1 = &amp;value1; const int *ptr2 = &amp;value2; int * const ptr3 = &amp;value3; const int *const ptr4 = &amp;value4; //通过指针的解引用，改变变量的值 *ptr1 = 10; *ptr2 = 20; //✖，因为ptr2是非const指针（它指向“const int”，即，它指向的值不可以通过解引用指针被改变） *ptr3 = 30; *ptr4 = 40; //✖，因为ptr4它指向“const int”（是const指针），但是value是“int”.类型不匹配 /************const的变量***************/ const int value5 = 5; const int value6 = 6; const int value7 = 7; const int value8 = 8; int *ptr5 = &amp;value5; //✖，非const指针（它指向“int”），所以不能指向“const int”的值value5 const int *ptr6 = &amp;value6; int * const ptr7 = &amp;value7; //✖，const指针（它指向“int”）,但是value7 是“const int”。所以不匹配 const int *const ptr8 = &amp;value8; //防止在visual studio 软件中闪退 std::cin.clear(); std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n'); std::cin.get(); return 0;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://longlongqin.github.io/tags/C-C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"指针与数组","slug":"C&C++/指针与数组(P)","date":"2020-04-29T00:42:27.000Z","updated":"2020-05-01T09:43:59.134Z","comments":true,"path":"archives/13ba6384.html","link":"","permalink":"https://longlongqin.github.io/archives/13ba6384.html","excerpt":"LearnCpp chapterLhttps://www.learncpp.com","text":"LearnCpp chapterLhttps://www.learncpp.com误区误区：在c++中，一个常见的谬误是认为数组和指向数组的指针是相同的。真实情况是：在下面例子中，数组的类型为：int[5]；数组的“值”就是数组的元素。指向数组的指针的类型为：int*；它的值是数组第一个元素的地址。12345678910111213141516171819#include &lt;iostream&gt; int main()&#123; int array[5]&#123; 9, 7, 5, 3, 1 &#125;; // print address of the array's first element std::cout &lt;&lt; \"Element 0 has address: \" &lt;&lt; &amp;array[0] &lt;&lt; '\\n'; // print the value of the pointer the array decays to std::cout &lt;&lt; \"The array decays to a pointer holding address: \" &lt;&lt; array &lt;&lt; '\\n'; return 0;&#125;/*结果*/Element 0 has address: 0042FD5CThe array decays to a pointer holding address: 0042FD5Carray decays to a pointer：数组在某些情况下将退化为指针注意：数组退化为指针时，它是指向第一个元素的指针。解引用数组1234567int array[5]&#123; 9, 7, 5, 3, 1 &#125;; // dereferencing an array returns the first element (element 0)std::cout &lt;&lt; *array; // will print 9! char name[]&#123; \"Jason\" &#125;; // C-style string (also an array)std::cout &lt;&lt; *name &lt;&lt; '\\n'; // will print 'J'⭐注意，我们并不是真正的解引用数组本身。真实情况是：数组(类型为int[5])被隐式转换为指针(类型为int *)，我们其实是解引用这个指针来获得指针所在的内存地址的值(数组第一个元素的值)。指定一个指针指向数组123456789101112#include &lt;iostream&gt; int main()&#123; int array[5]&#123; 9, 7, 5, 3, 1 &#125;; std::cout &lt;&lt; *array &lt;&lt; '\\n'; // will print 9 int *ptr&#123; array &#125;; std::cout &lt;&lt; *ptr &lt;&lt; '\\n'; // will print 9 return 0;&#125;数组退化为一个指针(类型为int*)，我们的指针(类型也是int*)也有相同的类型。指针与定长数组的区别使用sizeof()的区别当在固定数组上使用时，sizeof返回整个数组的大小(数组长度*元素大小)。在指针上使用时，sizeof返回内存地址的大小(以字节为单位)。下面的程序说明了这一点:1234567891011121314151617#Include &lt;iostream&gt;int main()&#123; int array[5] &#123; 9, 7, 5, 3, 1&#125;; std::cout &lt;&lt;sizeof(array) &lt;&lt;'\\n'; //：打印sizeof(int) *数组大小 int *ptr &#123;array&#125;; std::cout &lt;&lt;sizeof(ptr)&lt;&lt;'\\n'; // 将打印指针的大小 return 0;&#125;/*结果*/204使用取地址操作符(&amp;)的区别获取指针的地址会得到指针变量的内存地址。获取数组地址将返回一个指向整个数组的指针。这个指针也指向数组的第一个元素，但是类型信息不同(在上面的例子中，是int(*)[5])。你不太可能需要用到这个。————————————–指针的运算与数组的索引指针的+、-1234567891011121314151617181920#include &lt;iostream&gt; int main()&#123; int value&#123; 7 &#125;; int *ptr&#123; &amp;value &#125;; std::cout &lt;&lt; ptr &lt;&lt; '\\n'; std::cout &lt;&lt; ptr+1 &lt;&lt; '\\n'; std::cout &lt;&lt; ptr+2 &lt;&lt; '\\n'; std::cout &lt;&lt; ptr+3 &lt;&lt; '\\n'; return 0;&#125;/*结果*/0012FF7C0012FF800012FF840012FF88注意：注意，ptr + 1并不返回ptr之后的内存地址，而是ptr所指向类型的下一个对象的内存地址。如果ptr指向一个整数(假设为4个字节)，ptr + 3表示ptr之后有3个整数(12个字节)。如果ptr指向一个1字节的字符，ptr + 3表示ptr之后有3个字符(3字节)。在计算指针算术表达式的结果时，编译器总是将整数操作数乘以所指向对象的大小。这叫做缩放。就像上面的例子一样。每个地址相差4 (7C + 4 = 80 in hexadecimal)。这是因为在作者的机器上一个整数是4字节。数组在内存中按顺序排列通过取地址符(&amp;)我们可以看到数组在内存中是按顺序排列的。也就是说，元素0、1、2、…按顺序都是相邻的。1234567891011121314151617181920#include &lt;iostram&gt;int main()&#123; int array[] &#123;9, 7, 5, 3, 1&#125;; std::cout &lt;&lt; \"Element 0 is at address: \" &lt;&lt; &amp;array[0] &lt;&lt; '\\n'; std::cout &lt;&lt; \"Element 1 is at address: \" &lt;&lt; &amp;array[1] &lt;&lt; '\\n'; std::cout &lt;&lt; \"Element 2 is at address: \" &lt;&lt; &amp;array[2] &lt;&lt; '\\n'; std::cout &lt;&lt; \"Element 3 is at address: \" &lt;&lt; &amp;array[3] &lt;&lt; '\\n'; return 0;&#125;/*结果*/Element 0 is at address: 0041FE9CElement 1 is at address: 0041FEA0Element 2 is at address: 0041FEA4Element 3 is at address: 0041FEA8//注意，每个内存地址之间相隔4个字节，这是作者机器上的整数大小。数组的+数组的+和指针的运算相似：向数组添加1应该指向数组的第二个元素(元素1)。如下所示：1234567891011121314#include &lt;iostream&gt; int main()&#123; int array []&#123; 9, 7, 5, 3, 1 &#125;; std::cout &lt;&lt; &amp;array[1] &lt;&lt; '\\n'; // print memory address of array element 1 std::cout &lt;&lt; array+1 &lt;&lt; '\\n'; // print memory address of array pointer + 1 std::cout &lt;&lt; array[1] &lt;&lt; '\\n'; // prints 7 std::cout &lt;&lt; *(array+1) &lt;&lt; '\\n'; // prints 7 (note the 小括号 required here) return 0;&#125;上面例子证明：中括号操作符([ ]) ，就是先将其转化为指针的加法，然后对指针解引用(就是访问其指向内存的值)。如： array[n] 就等同于 *(array+n)使用指针遍历数组我们可以使用指针和指针运算来遍历数组。（虽然这个不常用，但是这里只是告诉你可以这样用）使用下标通常更容易阅读和更少的错误倾向","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://longlongqin.github.io/tags/C-C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"指针","slug":"C&C++/指针(P)","date":"2020-04-28T10:27:34.000Z","updated":"2020-05-01T09:43:59.133Z","comments":true,"path":"archives/73608288.html","link":"","permalink":"https://longlongqin.github.io/archives/73608288.html","excerpt":"LearnCpp chapterPhttps://www.learncpp.com","text":"LearnCpp chapterPhttps://www.learncpp.com介绍指针在1.3 – a first look at variables中，我们讲到：变量：是保存值的一段内存的名称。当我们的程序实例化一个变量时，一个空闲内存地址被自动分配给这个变量。我们赋给该变量的任何值都存储在这个内存地址中。1234567int x;/*********************************************************//*当CPU执行这条语句时，会从RAM中留出一块内存。为了便于举例，假设变量x被分配了内存位置140。当程序在表达式或语句中看到变量x时，它知道应该在内存位置140中查找该值。*/变量的好处是我们不需要担心分配了什么特定的内存地址。我们只是根据给定的标识符引用变量，编译器将这个名称转换为适当分配的内存地址。取地址操作符(&amp;)取地址操作符(&amp;)：允许我们查看分配给变量的内存地址。12345678910111213#include &lt;iostream&gt; int main()&#123; int x = 5; std::cout &lt;&lt; x &lt;&lt; '\\n'; // print the value of variable x std::cout &lt;&lt; &amp;x &lt;&lt; '\\n'; // print the memory address of variable x return 0;&#125;/*结果*/50027FEA0解引用操作符(*)Dereferencing pointers解引用操作符(*)：允许我们访问特定地址的值。12345678910111213141516#include &lt;iostream&gt; int main()&#123; int x = 5; std::cout &lt;&lt; x &lt;&lt; '\\n'; // print the value of variable x std::cout &lt;&lt; &amp;x &lt;&lt; '\\n'; // print the memory address of variable x std::cout &lt;&lt; *(&amp;x) &lt;&lt; '\\n'; /// print the value at the memory address of variable x (parenthesis not required, but make it easier to read) return 0;&#125;/*结果*/50027FEA05指针指针是一个变量，它将一个内存地址作为其值。声明一个指针指针变量的声明与普通变量一样，只是数据类型和变量名之间有一个星号(*)。注意，这个星号不是间接寻址操作符。它是指针声明语法的一部分。123456789101112//1️⃣星号* 紧跟在变量名之前int *iPtr; // a pointer to an integer valuedouble *dPtr; // a pointer to a double value //2️⃣ 星号* 紧跟在类型之后int* iPtr2; // also valid syntax (acceptable, but not favored)//3️⃣星号* 在类型与变量名之间int * iPtr3; // also valid syntax (but don't do this) //注意，定义指针时，每个指针变量前面都需要有*int *iPtr4, *iPtr5; // declare two pointers to integer variables因此，在声明变量时，我们建议在变量名旁边加上星号（即，推荐1️⃣）。当从一个函数返回一个指针时，在返回类型旁边加上星号会更清楚:12int* doSomething();//这表明函数返回的是int*类型的值，而不是int类型的值。声明时不初始化就像普通的变量一样，指针在声明时是不初始化的。如果没有使用值初始化，它们将包含垃圾。为指针赋值由于指针只包含地址，当我们为指针赋值时，该值必须是地址。使用指针最常见的方法之一是让指针保存另一个变量的地址。12int v = 5;int *ptr = &amp;v; // initialize ptr with address of variable v上面代码片段，就像下面的图所显示的一样：指针的名字就是从这里来的——ptr保存变量值的地址，所以我们说ptr“指向”v。指针的类型必须与被指向的变量的类型相匹配:1234567int iValue = 5;double dValue = 7.0; int *iPtr = &amp;iValue; // okdouble *dPtr = &amp;dValue; // okiPtr = &amp;dValue; // wrong -- int pointer cannot point to the address of a double variabledPtr = &amp;iValue; // wrong -- double pointer cannot point to the address of an int variablec++也不允许直接分配文字内存地址给指针:1234int *ptr = 5; //这是因为指针只能保存地址，而整数literal 5没有内存地址。//如果您尝试这样做，编译器将告诉您它不能将整数转换为整数指针。double *dPtr = 0x0012FF7C; //不可以，编译器将会视为赋值整数文字取地址操作符(&amp;)返回指针值得注意的是取地址操作符(&amp;)并没有将其操作数的地址作为文字返回。相反，它返回一个包含操作数地址的指针，该操作数的类型是从参数中派生出来的(例如，获取一个int类型的地址将返回它的地址到一个int型的指针中)。12345678910111213#include &lt;iostream&gt;#include &lt;typeinfo&gt; int main()&#123; int x(4); std::cout &lt;&lt; typeid(&amp;x).name(); return 0;&#125;/* 结果（在vs2013中）*/int *指针的声明与解引用指针解引用指针：Dereferencing pointers12345678910int *p; //声明一个整型指针p= &amp;a; //p指向了a的地址 （&amp;取地址）//上面两句=下面这一句：int *p= &amp;a; //定义一个整型指针 p 并且p指向了a的地址 （&amp;取地址）*p=10; //解引用， 即 给a赋值10；p=&amp;b; // p指向了 b的地址*p=200; //解引用， 即 给b赋值200；解引用中的 “*”的作用是引用指针指向的变量值，引用其实就是引用该变量的地址，”解”就是把该地址对应的东西解开，解出来，就像打开一个包裹一样，那就是该变量的值了，所以称为”解引用”。12345678910111213int value = 5;std::cout &lt;&lt; &amp;value; // prints address of valuestd::cout &lt;&lt; value; // prints contents of value int *ptr = &amp;value; // ptr points to valuestd::cout &lt;&lt; ptr; // prints address held in ptr, which is &amp;valuestd::cout &lt;&lt; *ptr; // dereference ptr (get the value that ptr is pointing to)/*结果*/0012FF7C50012FF7C5这就是指针必须有类型的原因。如果没有类型，指针就不知道在解引用时如何解释它所指向的内容。这也是为什么指针的类型和赋值给它的变量地址必须匹配的原因。如果他们不这样做，当指针被解引用时，它会将bits误读为另一种类型。指针的大小指针的大小取决于可执行文件的编译体系结构——32位可执行文件使用32位内存地址——因此，32位机器上的指针是32位(4字节)。对于64位的可执行文件，指针应该是64位(8字节)。请注意，这是固定的，与指针的类型无关。1234567891011char *chPtr; // chars are 1 byteint *iPtr; // ints are usually 4 bytesstruct Something&#123; int nX, nY, nZ;&#125;;Something *somethingPtr; // Something is probably 12 bytes std::cout &lt;&lt; sizeof(chPtr) &lt;&lt; '\\n'; // prints 4std::cout &lt;&lt; sizeof(iPtr) &lt;&lt; '\\n'; // prints 4std::cout &lt;&lt; sizeof(somethingPtr) &lt;&lt; '\\n'; // prints 4可以看到，指针的大小总是相同的。这是因为指针只是一个内存地址，而访问给定机器上的内存地址所需的比特数总是恒定的。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://longlongqin.github.io/tags/C-C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"数组、字符串、指针和引用","slug":"C&C++/数组（P）","date":"2020-04-28T10:26:38.000Z","updated":"2020-05-01T09:43:59.136Z","comments":true,"path":"archives/122ff534.html","link":"","permalink":"https://longlongqin.github.io/archives/122ff534.html","excerpt":"LearnCpp chapterPhttps://www.learncpp.com","text":"LearnCpp chapterPhttps://www.learncpp.comP6.1 定长数组（Ⅰ）数组长度：在数组变量声明中，我们使用方括号( [ ] )告诉编译器这是一个数组变量(而不是普通的变量)，以及要分配多少变量(称为数组长度)。固定长度的数组：固定数组(也称为固定长度数组或固定大小数组)是在编译时长度已知的数组。当testScore被实例化时，编译器将分配30个整数。1int testScore[30]; // allocate 30 integer variables in a fixed array数组元素和下标数组中的每个变量都称为元素。元素没有自己单独的名称。为了访问数组的各个元素，我们使用数组名、下标操作符([])和一个称为下标(或索引)的参数，它告诉编译器我们需要哪个元素。重要提示:与我们通常从1开始计数的日常生活不同，*在c++中，数组总是从0开始计数!***由结构体构成的数组123456struct Rectangle&#123; int length; int width;&#125;;Rectangle rects[5]; // declare an array of 5 Rectangle要访问数组元素的struct成员，首先选择你想要的数组元素，然后使用成员选择操作符( . )来选择你想要的struct成员：rects[0].length = 24;数组下标（详细）在c++中，数组下标必须始终是整数类型。这包括char、short、int、long、long long等等，奇怪的是，bool(其中false的索引为0,true的索引为1). 数组下标可以是一个文字值、一个变量(常量或非常量)，或者一个计算结果为整数类型的表达式。123456789101112131415161718int array[5]; // declare an array of length 5// using a literal (constant) index:array[1] = 7; // ok // using an enum (constant) indexenum Animals&#123; ANIMAL_CAT = 2&#125;;array[ANIMAL_CAT] = 4; // ok // using a variable (non-constant) index:short index = 3;array[index] = 7; // ok // using an expression that evaluates to an integer index:array[1+2] = 7; // ok定长数组的声明在声明固定数组时，数组的长度(方括号之间)必须是编译时常量（compile-time）。这是因为在编译时必须知道固定数组的长度。这里有一些不同的方法来声明固定数组:1234567891011121314151617// using a literal constantint array[5]; // Ok // using a macro symbolic constant#define ARRAY_LENGTH 5int array[ARRAY_LENGTH]; // Syntactically okay, but don't do this // using a symbolic constantconst int arrayLength = 5;int array[arrayLength]; // Ok // using an enumeratorenum ArrayElements&#123; MAX_ARRAY_LENGTH = 5&#125;;int array[MAX_ARRAY_LENGTH]; // Ok注意，非常量变量或运行时常量（runtime constants）不能使用:123456789//using a non-const variableint length;std::cin&gt;&gt;length;int array[length]; //不行，length 不是编译时常量!// using a runtime const variableint temp = 5;const int length =temp; //length的值直到运行时才知道，所以这是一个运行时常量，而不是编译时常量!int array[length]; //不可以注意，在最后两种情况下，应该会产生一个错误，因为长度不是编译时常数。一些编译器可能允许这些类型的数组(为了C99的兼容性)，但是根据c++标准，它们是无效的，不应该在c++程序中使用。关于动态数组的说明因为固定数组在编译时分配了内存，这就引入了两个限制:固定数组的长度不能基于用户输入或运行时计算的其他值。固定数组的长度是固定的，不能改变。在许多情况下，这些限制是有问题的。幸运的是，c++支持第二种类型的数组，称为动态数组。动态数组的长度可以在运行时设置，也可以更改其长度。但是，动态数组的实例化要复杂一些，因此我们将在本章的后面部分介绍它们。小结固定数组提供了一种简单的方法来分配和使用相同类型的多个变量，只要在编译时知道数组的长度即可。P6.2 定长数组（Ⅱ）c++通过使用初始化器列表提供了一种更方便的方法来初始化整个数组。下面的例子是等价的：12345678int prime[5] = &#123; 2, 3, 5, 7, 11 &#125;; // use initializer list to initialize the fixed array【推荐】 int prime[5]; // hold the first 5 prime numbers【不推荐】 prime[0] = 2; prime[1] = 3; prime[2] = 5; prime[3] = 7; prime[4] = 11;零值初始化当列表中的初始化器比数组所能容纳的少，那么，其余的元素会被初始化为0。（或者将0转换为非整数基本类型的任何值——例如0.0转换为double）123456789101112131415161718192021#include &lt;iostream&gt; int main()&#123; int array[5] = &#123; 7, 4, 5 &#125;; // only initialize first 3 elements std::cout &lt;&lt; array[0] &lt;&lt; '\\n'; std::cout &lt;&lt; array[1] &lt;&lt; '\\n'; std::cout &lt;&lt; array[2] &lt;&lt; '\\n'; std::cout &lt;&lt; array[3] &lt;&lt; '\\n'; std::cout &lt;&lt; array[4] &lt;&lt; '\\n'; return 0;&#125;/*结果*/7450012345// Initialize all elements to 0int array[5] = &#123; &#125;; // Initialize all elements to 0.0double array[5] = &#123; &#125;;从c++ 11开始，应该使用统一的初始化语法:12int prime[5] &#123; 2, 3, 5, 7, 11 &#125;; //使用统一初始化来初始化固定数组,//注意这个语法中没有等号省略长度如果使用初始化器列表初始化一个固定的元素数组，编译器可以为您计算出数组的长度，您可以省略显式声明数组的长度。12int array[5] = &#123; 0, 1, 2, 3, 4 &#125;; // 显式的 define length of the arrayint array[] = &#123; 0, 1, 2, 3, 4 &#125;; // let initializer list set length of the array数组和枚举1234567891011121314enum StudentsNames&#123; qin, //0 zhi, //1 Long,//2 student_num, //3&#125;;int main()&#123; int testScores[student_num]; //allocate 3 integers testScores[qin] = 76; return 0;&#125;数组和枚举类枚举类不会隐式的将枚举器转换为整数，所以如果你尝试以下:12345678910111213141516enum class StudentNames&#123; KENNY, // 0 KYLE, // 1 STAN, // 2 BUTTERS, // 3 CARTMAN, // 4 WENDY, // 5 MAX_STUDENTS // 6&#125;;int main()&#123; int testScores[StudentNames::MAX_STUDENTS]; // allocate 6 integers testScores[StudentNames::STAN] = 76;&#125;你会得到一个编译错误。解决：这可以通过使用static_cast将枚举数转换为整数来解决:1234567int main()&#123; int testScores[static_cast&lt;int&gt;(StudentNames::MAX_STUDENTS)]; // allocate 6 integers testScores[static_cast&lt;int&gt;(StudentNames::STAN)] = 76; return 0;&#125;改进：在命名空间中使用标准的enum可能更好:123456789101112131415161718192021nmaespace studentName&#123; enum studentnames &#123; KENNY, // 0 KYLE, // 1 STAN, // 2 BUTTERS, // 3 CARTMAN, // 4 WENDY, // 5 MAX_STUDENTS // 6 &#125;;&#125;int main()&#123; int testScores[studentName::MAX_STUDENTS]; testScores[StudentNames::STAN] = 76; return 0;&#125;将数组传递给函数传递数组给函数 VS 传递普通的变量给函数 的区别：传递数组给函数：当通过值传递一个普通变量时，c++将参数的值复制到函数参数中。因为参数是副本，所以更改参数的值并不会更改原始参数的值。传递数组给函数：当一个数组被传递给一个函数时，c++不会复制一个数组。而是传递实际的数组。这样做的副作用是允许函数直接改变数组元素的值!1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt; //传递普通参数void passValue(int value) // value is a copy of the argument&#123; value = 99; // so changing it here won't change the value of the argument&#125; //传递数组void passArray(int prime[5]) // prime is the actual array&#123; prime[0] = 11; // so changing it here will change the original argument! prime[1] = 7; prime[2] = 5; prime[3] = 3; prime[4] = 2;&#125; int main()&#123; int value = 1; std::cout &lt;&lt; \"before passValue: \" &lt;&lt; value &lt;&lt; \"\\n\"; passValue(value); std::cout &lt;&lt; \"after passValue: \" &lt;&lt; value &lt;&lt; \"\\n\"; int prime[5] = &#123; 2, 3, 5, 7, 11 &#125;; std::cout &lt;&lt; \"before passArray: \" &lt;&lt; prime[0] &lt;&lt; \" \" &lt;&lt; prime[1] &lt;&lt; \" \" &lt;&lt; prime[2] &lt;&lt; \" \" &lt;&lt; prime[3] &lt;&lt; \" \" &lt;&lt; prime[4] &lt;&lt; \"\\n\"; passArray(prime); std::cout &lt;&lt; \"after passArray: \" &lt;&lt; prime[0] &lt;&lt; \" \" &lt;&lt; prime[1] &lt;&lt; \" \" &lt;&lt; prime[2] &lt;&lt; \" \" &lt;&lt; prime[3] &lt;&lt; \" \" &lt;&lt; prime[4] &lt;&lt; \"\\n\"; return 0;&#125;/*结果*/before passValue: 1after passValue: 1 （普通变量不会被修改）before passArray: 2 3 5 7 11after passArray: 11 7 5 3 2 （数组会被修改）注意：如果你想确保一个函数不修改数组元素传递给它，你可以对数组使用const:12345678910// even though prime is the actual array, within this function it should be treated as a constantvoid passArray(const int prime[5])&#123; // so each of these lines will cause a 编译错误! prime[0] = 11; prime[1] = 7; prime[2] = 5; prime[3] = 3; prime[4] = 2;&#125;sizeof和数组可以对数组使用sizeof操作符，它将返回数组的总大小（数组长度乘以元素大小）注意，由于c++将数组传递给函数的方式，对于已传递给函数的数组，这将无法正常工作!123456789101112131415161718void printSize(int array[])&#123; std::cout &lt;&lt; sizeof(array) &lt;&lt; '\\n'; // prints the size of a pointer, not the size of the array!(将数组传递给函数，它显示的大小只是数组的指针（我的vs2013中，指针大小为4byte）)&#125; int main()&#123; int array[] = &#123; 1, 1, 2, 3, 5, 8, 13, 21 &#125;; std::cout &lt;&lt; sizeof(array) &lt;&lt; '\\n'; // will print the size of the array（没有传递给函数，所以会正常显示数组的大小） printSize(array); return 0;&#125;/*结果*///在我的vs2013中，int是4byte，int指针是4byte324指针大小与类型无关数组大小≠数组长度；数组大小 = 数组长度*元素大小在c++ 17之前确定一个固定数组的长度我们可以通过 整个数组的大小 除以 数组元素的大小 来确定一个固定数组的长度:12345678910111213#include &lt;iostream&gt; //for std::coutint main()&#123; int array[] = &#123; 1, 1, 2, 3, 5, 8, 13, 21 &#125;; std::cout &lt;&lt;\"The array has: \" &lt;&lt; sizeof(array) / sizeof(array[0]) &lt;&lt; \" elements\\n\"; //sizeof(array[0])是元素的大小 return 0;&#125;/*结果*/The array has 8 elements在c++ 17/ c++ 20中确定一个固定数组的长度在c++ 17中，更好的选择是使用std::size()函数，它是在头文件&lt;iterator&gt;中。如果您试图在传递给函数的固定数组上使用它，则会导致编译器错误!注意，std::size返回一个无符号值。12345678910111213#include &lt;iostream&gt; // for std::cout#include &lt;iterator&gt; // for std::size int main()&#123; int array[] = &#123; 1, 1, 2, 3, 5, 8, 13, 21 &#125;; std::cout &lt;&lt; \"The array has: \" &lt;&lt; std::size(array) &lt;&lt; \" elements\\n\"; return 0;&#125;/*结果*/The array has 8 elements在c++ 20中，std::ssize甚至更可取，因为它返回一个带符号的值。小结：如果你的编译器是c++ 17/ c++ 20的能力，那么你可以使用std::size (c++ 17)或者std::ssize(c++ 20)来进行数组长度的确定。P6.4 使用选择排序对数组排序数组元素交换在C++标准库中，提供了元素值的交换函数：std::swap()在头文件algorithm中（如果是C++11，则在头文件utility中）123456789101112131415#include &lt;algorithm&gt; // for std::swap, use &lt;utility&gt; instead if C++11#include &lt;iostream&gt; int main()&#123; int x&#123; 2 &#125;; int y&#123; 4 &#125;; std::cout &lt;&lt; \"Before swap: x = \" &lt;&lt; x &lt;&lt; \", y = \" &lt;&lt; y &lt;&lt; '\\n'; std::swap(x, y); // swap the values of x and y std::cout &lt;&lt; \"After swap: x = \" &lt;&lt; x &lt;&lt; \", y = \" &lt;&lt; y &lt;&lt; '\\n';&#125;/*结果*/Before swap: x = 2, y = 4After swap: x = 4, y = 2在c++中的选择排序1234567891011121314151617181920212223242526272829303132333435363738#include &lt;algorithm&gt; // for std::swap, use &lt;utility&gt; instead if C++11#include &lt;iostream&gt; int main()&#123; constexpr int length&#123; 5 &#125;; int array[length]&#123; 30, 50, 20, 10, 40 &#125;; // Step through each element of the array // (except the last one, which will already be sorted by the time we get there) for (int startIndex&#123; 0 &#125;; startIndex &lt; length - 1; ++startIndex) &#123; // smallestIndex is the index of the smallest element we’ve encountered this iteration // Start by assuming the smallest element is the first element of this iteration int smallestIndex&#123; startIndex &#125;; // Then look for a smaller element in the rest of the array for (int currentIndex&#123; startIndex + 1 &#125;; currentIndex &lt; length; ++currentIndex) &#123; // If we've found an element that is smaller than our previously found smallest if (array[currentIndex] &lt; array[smallestIndex]) // then keep track of it smallestIndex = currentIndex; &#125; // smallestIndex is now the smallest element in the remaining array // swap our start element with our smallest element (this sorts it into the correct place) std::swap(array[startIndex], array[smallestIndex]); &#125; // Now that the whole array is sorted, print our sorted array as proof it works for (int index&#123; 0 &#125;; index &lt; length; ++index) std::cout &lt;&lt; array[index] &lt;&lt; ' '; std::cout &lt;&lt; '\\n'; return 0;&#125;std::sort(C++中自带排序函数)默认情况下，std::sort按升序排序，使用操作符&lt;来比较元素对，并在必要时交换它们(很像上面的选择排序示例)。1234567891011121314151617#include &lt;algorithm&gt; // for std::sort#include &lt;iostream&gt;#include &lt;iterator&gt; // for std::size int main()&#123; int array[]&#123; 30, 50, 20, 10, 40 &#125;; std::sort(std::begin(array), std::end(array)); for (int i&#123; 0 &#125;; i &lt; static_cast&lt;int&gt;(std::size(array)); ++i) std::cout &lt;&lt; array[i] &lt;&lt; ' '; std::cout &lt;&lt; '\\n'; return 0;&#125;P6.5 多维数组数组的元素可以是任何数据类型，包括数组。数组的数组称为多维数组。二维数组1int array[3][5]; // a 3-element array of 5-element arrays在二维数组中，可以方便地将第一个(左)下标视为行，第二个(右)下标视为列。这叫做行-主序。在概念上，上述二维数组的布局如下:123[0][0] [0][1] [0][2] [0][3] [0][4] &#x2F;&#x2F; row 0[1][0] [1][1] [1][2] [1][3] [1][4] &#x2F;&#x2F; row 1[2][0] [2][1] [2][2] [2][3] [2][4] &#x2F;&#x2F; row 2二维数组初始化要初始化一个二维数组，最简单的方法是使用嵌套大括号，每组数字代表一行:123456int array[3][5]&#123; &#123; 1, 2, 3, 4, 5 &#125;, // row 0 &#123; 6, 7, 8, 9, 10 &#125;, // row 1 &#123; 11, 12, 13, 14, 15 &#125; // row 2&#125;;当然你也可以省略左(行)下标。注意，如果想省略下标，你只能省略左(行)下标，而右(列)下标不允许省略。12345678910111213int array[][5] //只能省略左(行)下标 ✔&#123; &#123; 1, 2, 3, 4, 5 &#125;, &#123; 6, 7, 8, 9, 10 &#125;, &#123; 11, 12, 13, 14, 15 &#125;&#125;;int array[][] //不能省略右(列)下标 ✖&#123; &#123; 1, 2, 3, 4, 5 &#125;, &#123; 6, 7, 8, 9, 10 &#125;, &#123; 11, 12, 13, 14, 15 &#125;&#125;;多维数组（大于2维）多维数组可以大于二维。这是一个三维数组的声明:1int array[1][2][3];使用初始化器列表很难以任何直观的方式初始化三维数组，因此通常最好将数组初始化为0，并使用嵌套循环显式地分配值。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://longlongqin.github.io/tags/C-C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"C风格字符串","slug":"C&C++/字符串(P)","date":"2020-04-28T07:04:46.000Z","updated":"2020-05-01T09:43:59.131Z","comments":true,"path":"archives/21aba888.html","link":"","permalink":"https://longlongqin.github.io/archives/21aba888.html","excerpt":"LearnCpp chapterLhttps://www.learncpp.com","text":"LearnCpp chapterLhttps://www.learncpp.comC风格字符串在4.4b – An introduction to std::string的介绍中，我们将字符串定义为连续字符的集合，比如“Hello, world!”字符串是我们在c++中处理文本的主要方式，而std::string使在c++中处理字符串变得很容易。现代c++支持两种不同类型的字符串:std::string(作为标准库的一部分)和C风格的字符串(从C语言继承而来)。原来std::string是使用c风格的字符串实现的。在这节课中，我们将进一步了解c风格的字符串。c风格的字符串只是一个使用空终止符(null terminator)的字符数组。空终止符是一个特殊字符(&#39; \\0 &#39;， ascii码为 0)C风格字符串，只需声明一个char数组，并初始化它的字符串文字:123char myString[]&#123; \"string\" &#125;;//虽然“string”只有6个字母，但c++会自动为我们在字符串的末尾添加一个空终止符//(我们自己不需要包含它)。因此，myString实际上是一个长度为7的数组!下面我们来证明它的实际长度：12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;iterator&gt; // for std::size(如果不支持C++17，就不用加该头文件) int main()&#123; char myString[]&#123; \"string\" &#125;; const int length&#123; static_cast&lt;int&gt;(std::size(myString)) &#125;;// 如果你的编译器不支持C++17，请使用下面语句来替换// const int length&#123; sizeof(myString) / sizeof(myString[0]) &#125;; std::cout &lt;&lt; myString&lt;&lt; \" has \" &lt;&lt; length &lt;&lt; \" characters.\\n\"; for (int index&#123; 0 &#125;; index &lt; length; ++index) std::cout &lt;&lt; static_cast&lt;int&gt;(myString[index]) &lt;&lt; \" \"; std::cout &lt;&lt; '\\n'; return 0;&#125;/*结果*/string has 7 characters.115 116 114 105 110 103 0该0是已附加到字符串末尾的空终止符的ASCII代码。需要注意的重要一点是，C风格的字符串遵循与数组相同的所有规则。这意味着您可以在创建时初始化字符串，但不能在此之后使用赋值操作符为其赋值!12char myString[]&#123; \"string\" &#125;; // okmyString = \"rope\"; // not ok!但是你可以改变它字符串数组中的单个字符：12char myString[]&#123; \"string\" &#125;; myString[0] = 'q'; //这样是可以的覆盖字符串的空终止符在打印c风格的字符串时，std::cout将打印字符，直到遇到空终止符为止。如果您意外地覆盖了一个字符串中的null结束符(例如，通过向myString[6]分配一些内容)，您不仅会获得字符串中的所有字符，而且std::cout将继续打印相邻内存插槽中的所有内容，直到它刚好碰到一个0!12345678910#include &lt;iostream&gt; int main()&#123; char name[20]&#123; \"Alex\" &#125;; // only use 5 characters (4 letters + null terminator) std::cout &lt;&lt; \"My name is: \" &lt;&lt; name &lt;&lt; '\\n'; return 0;&#125;//在本例中，将打印字符串“Alex”，std::cout将在null结束符处停止。数组中的其余字符将被忽略。C-style与std::cin当我们不知道一个字符串将会有多长。在这种情况下，我们可以声明一个大于我们需要的数组:1234567891011#include &lt;iostream&gt; int main()&#123; char name[255]; // declare array large enough to hold 255 characters std::cout &lt;&lt; \"Enter your name: \"; std::cin &gt;&gt; name; std::cout &lt;&lt; \"You entered: \" &lt;&lt; name &lt;&lt; '\\n'; return 0;&#125;但是这种输入字符串的方法，不好。因为，我们不能阻止用户输入字符串的长度，即使它输入超过255，我们也不能阻止用户。比如：我故意输入超过3个字符，结果会是怎样的呢？结果就是即使超过了原本字符串数组的长度，还是会全部打印出来：改进：std::cin.getline推荐使用：std::cin.getline( 字符串数组名字, 字符串数组长度)123456789101112#include &lt;iostream&gt;#include &lt;iterator&gt;int main()&#123; char name[255]; std::cout&lt;&lt;\"enter your name:\"; std::cin.getline(name, std::size(name)); //这里还是需要支持C++17才能这样用的 std::cout &lt;&lt; \"You entered: \" &lt;&lt; name &lt;&lt; '\\n'; return 0;&#125;这个对cingetline()的调用将把最多254个字符读入name(为 空结束符 留出空间!) 任何多余的字符都将被丢弃。这样，我们保证不会溢出数组!操纵c风格的字符串(#include &lt;cstring&gt;)在cstring头文件中，c++提供了许多函数来操作C风格的字符串：strcpy()strcpy()允许将一个字符串复制到另一个字符串：std::strcpy(dest, source)注意，如果目的字符串dest长度小于将要复制的字符串的长度，会发生溢出。许多程序员建议使用strncpy()，它允许您指定缓冲区的大小，并确保不会发生溢出。不幸的是，strncpy()不能确保字符串以null结尾，这仍然为数组溢出留下了大量空间。strcpy_s() 【改进】在C++中，使用strcp_s()更安全。它添加了一个参数来确定目标字符串的大小。strcpy_s(dest, number, source);但是，并不是所有的编译器都支持这个函数，要使用它，您必须使用整数值1定义__STDC_WANT_LIB_EXT1__。即：#define __STDC_WANT_LIB_EXT1__ 11234567891011#define __STDC_WANT_LIB_EXT1__ 1#include &lt;cstring&gt; // for strcpy_sint main()&#123; char source[]&#123; \"Copy this!\" &#125;; char dest[5]; // note that the length of dest is only 5 chars! strcpy_s(dest, 5, source); // A runtime error will occur in debug mode std::cout &lt;&lt; dest &lt;&lt; '\\n'; return 0;&#125;strlcpy() 【再改进】因为strcpy_s()不是所有编译器都支持。所以，strlcpy() 是一个更好的选择。因为它是非标准的，所以没有包含在许多编译器中。它也有自己的一套问题。简而言之，如果您需要复制c风格的字符串，这里没有普遍推荐的解决方案。strlen()：返回字符串长度此函数返回c样式字符串的长度(不包含空终止符)：（不是返回该字符串数组全部的长度，而是只返回已存入字符的长度）123456789101112131415161718#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;iterator&gt;int main()&#123; char name[20] &#123;\"Alex\"&#125;; //// only use 5 characters (4 letters + null terminator) std::cout &lt;&lt; \"My name is: \" &lt;&lt; name &lt;&lt; '\\n'; std::cout &lt;&lt; name &lt;&lt; \" has \" &lt;&lt; std::strlen(name) &lt;&lt; \" letters.\\n\"; std::cout &lt;&lt; name &lt;&lt; \" has \" &lt;&lt; std::size(name) &lt;&lt; \" characters in the array.\\n\"; // use sizeof(name) / sizeof(name[0]) if not C++17 capable return 0;&#125;/*结果*/My name is: AlexAlex has 4 letters. (不包含终止符)Alex has 20 characters in the array.注意：strlen()、std::size()的区别：strlen()打印null结束符之前的字符数，size() C++17 . sizeof(name) / sizeof(name[0]) 不支持C++17的写法返回整个数组的大小，不管里面是什么。其他函数：strcat()——将一个字符串追加到另一个字符串(危险)strncat()——将一个字符串追加到另一个字符串(使用缓冲区检查长度)strcmp()——比较两个字符串(如果相等则返回0)strncmp()——比较两个字符串到特定数目的字符(如果相等，则返回0)Don’t use C-style strings了解c风格的字符串很重要，因为它们在很多代码中都有使用。然而，现在我们已经解释了它们的工作原理，我们将建议您尽可能地避免使用它们! 除非您有特定的、令人信服的理由来使用c样式的字符串，否则应该使用std::string(在头文件 &lt;string&gt; 中定义)。std::string更容易，更安全，更灵活。在极少数情况下，您确实需要使用固定的缓冲区大小和c风格的字符串(例如，对于内存有限的设备)。我们建议使用经过良好测试的第三方字符串库，即std::string_view，这将在下一课中介绍。用std::string_view替代C-style 字符串std::string_view之前，讲的C风格字符串（原文链接），以及使用它们的危险。c风格的字符串速度很快，但是它们不像std::string那样容易使用和安全。但是std::string(我们在 S.4.4b – An introduction to std::string（也就是本文开头的介绍std::string）的介绍中已经介绍过了)也有它自己的缺点，尤其是涉及到const字符串时。std::string会修改const的字符串看下面一个例子：12345678910111213141516#include &lt;iostream&gt;#include &lt;string&gt; int main()&#123; char text[]&#123; \"hello\" &#125;; std::string str&#123; text &#125;; std::string more&#123; str &#125;; std::cout &lt;&lt; text &lt;&lt; ' ' &lt;&lt; str &lt;&lt; ' ' &lt;&lt; more &lt;&lt; '\\n'; return 0;&#125;/*结果*/hello hello hello在内部，main将字符串“hello”复制3次，结果得到4个副本。首先是字符串文字“hello”，它在编译时已知，并存储在二进制文件中。当我们创建char[]时，会创建一个副本。接下来的两个std::string对象分别创建该字符串的一个副本。因为std::string被设计为可修改的，所以每个std::string必须包含其自身的字符串副本，以便可以修改给定的std::string而不影响任何其他std::string对象。所以，即使，是 const std::string，也是会被修改的。std::string_view想象一下你房子里的一扇窗户，看着停在街上的一辆车。你可以透过窗户看到那辆车，但你不能触摸或移动那辆车。你的窗口只是提供了一个汽车的视图，这是一个完全独立的对象。c++ 17引入了另一种使用字符串的方法，std::string_view，它位于头文件&lt;string_view&gt;中。与std::string不同的是，std::string_view保存了自己的字符串副本，它提供了在其他地方定义的字符串的视图。修改上面的例子：12345678910111213141516#include &lt;iostream&gt;#include &lt;string_view&gt;int main()&#123; std::string_view text&#123;\"hello\"&#125;; // view the text \"hello\", which is stored in the binary std::string_view str&#123; text &#125;; // view of the same \"hello\" std::string_view more&#123; str &#125;; // view of the same \"hello\" std::cout &lt;&lt; text &lt;&lt; ' ' &lt;&lt; str &lt;&lt; ' ' &lt;&lt; more &lt;&lt; '\\n'; return 0;&#125;/*结果*/hello hello hello这两个例子结果相同。但是此例子不再创建字符串“hello”的副本。当我们复制std::string_view时，新的std::string_view观察到的字符串与复制自std::string_view的字符串相同。优点string_view不仅速度快，而且有许多我们从std::string中了解到的函数。string_view没有创建字符串的副本因为std::string_view并不创建字符串的副本，如果我们更改所查看的字符串，则更改将反映在std::string_view中。1234567891011121314151617#include &lt;iostream&gt;#include &lt;string_view&gt; int main()&#123; char arr[]&#123; \"Gold\" &#125;; std::string_view str&#123; arr &#125;; std::cout &lt;&lt; str &lt;&lt; '\\n'; // Gold // Change 'd' to 'f' in arr arr[3] = 'f'; std::cout &lt;&lt; str &lt;&lt; '\\n'; // Golf return 0;&#125;我们修改了arr，但是str似乎也在改变。这是因为：这是因为arr和str共享它们的字符串。适用情况尽量使用std::string_view 来替代C风格字符串。对于只读字符串，最好使用std::string_view而不是std::string，除非您已经使用了std::string。std::string_view的修改函数回到我们的窗户类比，考虑一个有窗帘的窗户。我们可以关闭左边或右边的窗帘来减少我们能看到的东西。我们不改变外面的东西，我们只是减少可见的面积。类似地，std::string_view包含一些函数，这些函数允许我们操作字符串的视图。这允许我们在不修改所查看的字符串的情况下更改视图。这函数就是：remove_prefix：从视图左侧删除字符remove_suffix：从视图右侧删除字符。123456789101112131415161718192021222324#include &lt;cstring&gt; //for std::strlen#include &lt;iostream&gt;#include &lt;string_view&gt;int main()&#123; std::string_view str&#123;\"peach\"&#125;; std::cout&lt;&lt;str&lt;&lt;'\\n'; // Ignore the first characters. str.remove_prefix(1); std::cout&lt;&lt;str&lt;&lt;'\\n'; // Ignore the last 2 characters. str.remove_suffix(2); std::cout&lt;&lt;str&lt;&lt;'\\n'; return 0;&#125;/*结果*/Peacheachea与真正的窗帘不同，std::string_view不能打开备份。一旦你改变了可见区域，你就回不去了(有些技巧我们不会去做)。std::string_view与非空终止的字符串与C-style字符串和std::string 不同，std::string_view的字符串是不使用空终止符来标记字符串的结束。相反，它知道字符串的结束位置，因为它跟踪字符串的长度。1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;iterator&gt; // For std::size#include &lt;string_view&gt; int main()&#123; // No null-terminator. char vowels[]&#123; 'a', 'e', 'i', 'o', 'u' &#125;; // vowels isn't null-terminated. We need to pass the length manually. // Because vowels is an array, we can use std::size to get its length. std::string_view str&#123; vowels, std::size(vowels) &#125;; std::cout &lt;&lt; str &lt;&lt; '\\n'; // This is safe. std::cout knows how to print std::string_views. return 0;&#125;/*结果*/aeiou所有制的问题作为一个视图，std::string_view的生存期独立于它所查看的字符串的生存期。如果所查看的字符串超出其生命周期范围，那么std::string_view没有什么要观察的，访问它会导致未定义的行为。123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;string_view&gt;std::string_view askForName()&#123; std::cout&lt;&lt;\"what's your name?\\n\"; //使用std::string，因为std::cin需要修改它。 std::string str&#123;&#125;; std::cin &gt;&gt; str; // 我们将切换到std::string_view，仅用于演示目的。 // 如果你已经有一个std::string，没有理由切换到std:: string_view。 std::string_view view&#123;str&#125;; std::cout &lt;&lt; \"Hello \" &lt;&lt; view &lt;&lt; '\\n'; return view; &#125; // str消失了，str创建的字符串也消失了。int main()&#123; std::string_view view&#123; askForName() &#125;; // view is observing a string that already died. std::cout &lt;&lt; \"Your name is \" &lt;&lt; view &lt;&lt; '\\n'; // Undefined behavior return 0; &#125;/*结果*/What's your name?nascardriverHello nascardriverYour name is �P@�P@ （因为这里访问的时候，view已经“死了”）将std::string_view转换为std::stringstring_view不会隐式地转换为std::string，但是可以显式地转换为:1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;string_view&gt; void print(std::string s)&#123; std::cout &lt;&lt; s &lt;&lt; '\\n';&#125; int main()&#123; std::string_view sv&#123; \"balloon\" &#125;; sv.remove_suffix(3); // print(sv); // compile error: won't implicitly convert std::string str&#123; sv &#125;; // explicit conversion print(str); // okay print(static_cast&lt;std::string&gt;(sv)); // okay return 0;&#125;/*结果*/ballball将std::string_view转换为c风格的字符串一些旧的函数(如旧的strlen函数)仍然期望c风格的字符串。要将std::string_view转换为c风格的字符串，我们可以首先将其转换为std::string:12345678910111213141516171819202122232425#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;string_view&gt; int main()&#123; std::string_view sv&#123; \"balloon\" &#125;; sv.remove_suffix(3); // Create a std::string from the std::string_view std::string str&#123; sv &#125;; // Get the null-terminated C-style string. auto szNullTerminated&#123; str.c_str() &#125;; // Pass the null-terminated string to the function that we want to use. std::cout &lt;&lt; str &lt;&lt; \" has \" &lt;&lt; std::strlen(szNullTerminated) &lt;&lt; \" letter(s)\\n\"; return 0;&#125;/*结果*/ball has 4 letter(s)但是，每次我们希望将std::string_view作为c风格的字符串传递时，创建一个std::string是非常消耗资源的，因此应该尽可能避免这种情况。data()函数可以使用data()函数访问std::string_view所查看的字符串，该函数返回一个c风格的字符串。这提供了对正在查看的字符串(作为c字符串)的快速访问。但是它也应该只在std::string_view的视图没有被修改(例如通过remove_prefix或remove_suffix)并且被查看的字符串以null结尾的情况下使用。在下面的例子中，std::strlen不知道std::string_view是什么，所以我们需要传递它str.data():12345678910111213141516171819202122#include &lt;cstring&gt; // For std::strlen#include &lt;iostream&gt;#include &lt;string_view&gt; int main()&#123; std::string_view str&#123; \"balloon\" &#125;; std::cout &lt;&lt; str &lt;&lt; '\\n'; // We use std::strlen because it's simple, this could be any other function // that needs a null-terminated string. // It's okay to use data() because we haven't modified the view, and the // string is null-terminated. std::cout &lt;&lt; std::strlen(str.data()) &lt;&lt; '\\n'; return 0;&#125;/*结果*/balloon7当修改了std::string_view之后，data()并不总是做我们希望它做的事情。下面的例子演示了在修改视图后访问data()时会发生什么:【所以，此时不建议使用data()函数】123456789101112131415161718192021#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;string_view&gt; int main()&#123; std::string_view str&#123; \"balloon\" &#125;; // Remove the \"b\" str.remove_prefix(1); // remove the \"oon\" str.remove_suffix(3); // Remember that the above doesn't modify the string, it only changes // the region that str is observing. std::cout &lt;&lt; str &lt;&lt; \" has \" &lt;&lt; std::strlen(str.data()) &lt;&lt; \" letter(s)\\n\"; std::cout &lt;&lt; \"str.data() is \" &lt;&lt; str.data() &lt;&lt; '\\n'; std::cout &lt;&lt; \"str is \" &lt;&lt; str &lt;&lt; '\\n'; return 0;&#125;很明显，这不是我们想要的，这是试图访问已修改的std::string_view的数据()的结果。在访问data()时，有关字符串的长度信息将丢失。std::strlen和std::cout不断地从底层字符串中读取字符，直到它们找到空终止符，也就是“balloon”的结尾。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://longlongqin.github.io/tags/C-C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"std::cin（输入）","slug":"C&C++/cin(输入)","date":"2020-04-26T08:36:52.000Z","updated":"2020-05-01T09:43:59.131Z","comments":true,"path":"archives/a4b39f57.html","link":"","permalink":"https://longlongqin.github.io/archives/a4b39f57.html","excerpt":"std::cin（输入）https://www.learncpp.com","text":"std::cin（输入）https://www.learncpp.com我们可以使用std::cin来输入文本；因为文本输入是自由格式的(用户可以输入任何内容)，所以用户很容易输入不需要的内容。在编写程序时，您应该始终考虑用户将如何(无意中或以其他方式)滥用您的程序。一个编写良好的程序可以预测用户将如何滥用它，并优雅地处理这些情况，或者在一开始就防止它们发生(如果可能的话)。一个能很好地处理错误情况的程序是robust(健壮的)。在本节课中，我们将专门研究用户通过std::cin输入无效文本的方法，并向您展示处理这些情况的一些不同方法。std::cin, buffers, and extraction为了讨论std::cin和操作符&gt;&gt;是如何失败的，首先需要了解一下它们是如何工作的。当我们使用操作符&gt;&gt;来获取用户的输入，然后将该输入放进一个变量中，这个过程叫做：extraction(提取)。此时操作符&gt;&gt;也就叫做 提取操作符。buffer当用户响应提取操作输入数据时，该数据被放置在std::cin中的buffer（缓冲区)中。一个buffer(也称：data buffer)：就是在数据从一个地方移动到另一个地方时用来临时存储数据的一块内存。所以，在这里的缓冲区就用来 当用户输入的内容还没有被提取到变量中时 保存它。当你使用提取操作符时，会发生以下过程：如果在输入缓冲区中已经有数据，那么这个数据是准备被提取的；如果输入缓冲区中没有数据，那么要求用户输入数据以进行提取(大多数情况下都是这样)。当用户回车时，一个’ \\n ‘字符将被放入输入缓冲区。操作符&gt;&gt; 会从输入缓冲区提取尽可能多的数据到变量中(会忽略的空白字符，如空格、制表符或’ \\n ‘。)不能提取缓冲区中留给下一次提取的数据。提取数据成功只要在输入缓冲区中提取到一个字符就算成功。那些剩下的不符合本次提取的数据会留着下一次提取。12345int x;std::cin &gt;&gt; x;//比如用户输入：5a 给变量x;//将提取5，并将其转换为整数，赋值给变量x，“a\\n”将留在输入流中进行下一次提取。提取数据失败如果输入数据与要提取的变量的类型不匹配，则提取失败。例如:1234int x;std::cin &gt;&gt; x;//如果用户输入“b”，提取将失败，因为“b”不能提取为整数变量。输入验证检查用户输入是否符合程序期望的过程称为input validation(输入验证)。进行输入验证有三种基本方法:内联(作为用户类型)首先防止用户输入无效的输入。输入后(在用户输入之后)让用户在字符串中输入他们想要的任何内容，然后验证该字符串是否正确，如果正确，则将该字符串转换为最终的变量类型。让用户输入他们想要的任何东西，让std::cin和操作符&gt;&gt;尝试提取它，并处理错误情况。一些图形用户界面和高级文本界面将允许您在用户输入时验证输入(逐个字符)。一般来说，程序员提供一个验证函数，该函数接受用户目前输入的输入，如果输入有效则返回true，否则返回false。每当用户按下一个键时，都会调用这个函数。如果验证函数返回true，则接受用户刚刚按下的键。如果验证函数返回false，则丢弃用户刚刚输入的字符(并且不显示在屏幕上)。不幸的是，std::cin不支持这种类型的验证。由于字符串对可以输入什么字符没有任何限制，所以提取一定会成功(但是请记住，std::cin在第一个非前导空格字符处停止提取)。一旦输入了一个字符串，程序就可以解析该字符串，看看它是否有效。然而，解析字符串并将字符串输入转换为其他类型(例如数字)可能会很困难，所以这只在极少数情况下才会完成。大多数情况下，我们让std::cin和提取操作符&gt;&gt;来做这个工作。在这种方法下，我们让用户输入他们想要的任何东西，让std::cin和操作符&gt;&gt;尝试提取它，如果它失败了，就编写程序处理它们。一个例子：12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt; double getDouble()&#123; std::cout &lt;&lt; \"Enter a double value: \"; double x; std::cin &gt;&gt; x; return x;&#125; char getOperator()&#123; std::cout &lt;&lt; \"Enter one of the following: +, -, *, or /: \"; char op; std::cin &gt;&gt; op; return op;&#125; void printResult(double x, char op, double y)&#123; if (op == '+') std::cout &lt;&lt; x &lt;&lt; \" + \" &lt;&lt; y &lt;&lt; \" is \" &lt;&lt; x + y &lt;&lt; '\\n'; else if (op == '-') std::cout &lt;&lt; x &lt;&lt; \" - \" &lt;&lt; y &lt;&lt; \" is \" &lt;&lt; x - y &lt;&lt; '\\n'; else if (op == '*') std::cout &lt;&lt; x &lt;&lt; \" * \" &lt;&lt; y &lt;&lt; \" is \" &lt;&lt; x * y &lt;&lt; '\\n'; else if (op == '/') std::cout &lt;&lt; x &lt;&lt; \" / \" &lt;&lt; y &lt;&lt; \" is \" &lt;&lt; x / y &lt;&lt; '\\n';&#125; int main()&#123; double x = getDouble(); char op = getOperator(); double y = getDouble(); printResult(x, op, y); return 0;&#125;用户正常输入：1234Enter a double value: 5Enter one of the following: +, -, *, or &#x2F;: *Enter a double value: 75 * 7 is 35用户输入无效文本1. 输入提取成功，但输入对程序没有意义(例如，输入“k”作为你的数学运算符)。123Enter a double value: 5Enter one of the following: +, -, *, or &#x2F;: kEnter a double value: 7解决办法：增加判断用户输入是否符合预期值的代码，当不符合时，重新输入：123456789101112131415char getOperator()&#123; while (true) // Loop until user enters a valid input &#123; std::cout &lt;&lt; \"Enter one of the following: +, -, *, or /: \"; char op; std::cin &gt;&gt; op; // Check whether the user entered meaningful input if (op == '+' || op == '-' || op == '*' || op == '/') return op; // return it to the caller else // otherwise tell the user what went wrong std::cout &lt;&lt; \"Oops, that input is invalid. Please try again.\\n\"; &#125; // and try again&#125;2. 提取成功，但是有额外的输入如：Enter a double value: 5*7运行结果是：(程序打印正确的答案，但格式却一团糟。这是为什么呢？)当用户输入“5*7”作为输入时，该输入将进入缓冲区。然后操作符&gt;&gt;将5提取到变量x中，在缓冲区中留下“*7\\n”。接下来，程序输出“Enter one of the following: +, -, *, or /:”。但是，当调用提取操作符时，它会看到“*7\\n”在缓冲区中等待提取，因此它使用该操作符而不是询问用户更多的输入。因此，它提取“*”字符，在缓冲区中留下“7\\n”。在要求用户输入另一个双精度值之后，缓冲区中的“7”被提取出来，而不需要询问用户。由于用户从未有机会输入其他数据并按下回车键(导致换行)，所以输出提示将一起运行在同一行上，即使输出是正确的。12Enter a double value: 5*7Enter one of the following: +, -, *, or &#x2F;: Enter a double value: 5 * 7 is 35解决办法：使用std::cin.ignore(32767, &#39;\\n&#39;);关于cin.jgnore(32767 , &#39;\\n&#39;);的详细解释：https://www.yuque.com/longlongqin/pw9qpx/uap4n0#km6jq12345678double getDouble()&#123; std::cout &lt;&lt; \"Enter a double value: \"; double x; std::cin &gt;&gt; x; std::cin.ignore(32767, '\\n'); // clear (up to 32767) characters out of the buffer until a '\\n' character is removed return x;&#125;3. 提取失败如：Enter a double value: a运行结果：当用户输入“a”时，该字符被放置在缓冲区中。然后，操作符&gt;&gt;尝试将’ a ‘提取到变量x中，该变量的类型为double。由于’ a ‘不能被转换成double，所以操作符&gt;&gt;不能进行提取。此时会发生两件事:’ a ‘留在缓冲区中，std::cin进入“failure mode(故障模式)”。一旦进入“故障模式”，未来的输入提取请求将以静悄悄的失败。因此，在我们的计算器程序中，输出提示仍然打印，但是任何进一步提取的请求都会被忽略。程序简单地运行到最后，然后终止(不打印结果，因为我们从来没有读过有效的数学运算)。12Enter a double value: aEnter one of the following: +, -, *, or &#x2F;: Enter a double value:解决方法：123456if (std::cin.fail()) // has a previous extraction failed? ⭐&#123; // yep, so let's handle the failure std::cin.clear(); // put us back in 'normal' operation mode ⭐ std::cin.ignore(32767,'\\n'); // and remove the bad input&#125;现在将这三种错误的解决办法结合起来：123456789101112131415161718192021double getDouble()&#123; while (true) // Loop until user enters a valid input &#123; std::cout &lt;&lt; \"Enter a double value: \"; double x; std::cin &gt;&gt; x; if (std::cin.fail()) // has a previous extraction failed? ⭐3 &#123; // yep, so let's handle the failure std::cin.clear(); // put us back in 'normal' operation mode ⭐3 std::cin.ignore(32767,'\\n'); // and remove the bad input ⭐2 &#125; else // else our extraction succeeded &#123; std::cin.ignore(32767, '\\n'); // clear (up to 32767) characters out of the buffer until a '\\n' character is removed ⭐2 return x; // so return the value we extracted &#125; &#125;&#125;注：在C++11之前，如果这个变量已经被初始化过，那么失败的提取不会修改被提取到的变量的初始值。在C++11及之后，由输入无效而导致提取失败将导致变量初始化为零。(0初始化意味着变量被设置为0, 0.0，” “，或者0转换为该类型的任何值。)4. 提取成功，但是提取的值溢出1234567891011121314151617181920#include &lt;cstdint&gt;#include &lt;iostream&gt; int main()&#123; std::int16_t x &#123; 0 &#125;; // x is 16 bits, holds from -32768 to 32767 std::cout &lt;&lt; \"Enter a number between -32768 and 32767: \"; std::cin &gt;&gt; x; std::int16_t y &#123; 0 &#125;; // y is 16 bits, holds from -32768 to 32767 std::cout &lt;&lt; \"Enter another number between -32768 and 32767: \"; std::cin &gt;&gt; y; std::cout &lt;&lt; \"The sum is: \" &lt;&lt; x + y &lt;&lt; '\\n'; return 0;&#125;/*如果输入的数过大，会发生什么呢？（比如输入40000）*/Enter a number between -32768 and 32767: 40000Enter another number between -32768 and 32767: The sum is: 32767在上面的例子中，std::cin会立即进入“故障模式”，但也会将最接近的范围内值赋给变量。因此，x的赋值为32767。跳过其他输入，让y的初始值为0。我们可以使用与提取失败相同的方法来处理这种错误。注在c++ 11之前，失败的提取不会修改被提取到的变量。这意味着如果一个变量没有初始化，那么在失败的提取情况下，它将保持未初始化状态。(比如y，这里它会保持初始值0)从c++ 11开始，超过范围(out-of-range)时失败的提取将导致变量被设置为最接近的范围内值。在我的vs2013中，测试上面的代码，得到的结果是：这说明我的“故障模式”下，变量将会被初始化为0修改后的例子：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt; double getDouble()&#123; while (true) // Loop until user enters a valid input &#123; std::cout &lt;&lt; \"Enter a double value: \"; double x; std::cin &gt;&gt; x; // Check for failed extraction if (std::cin.fail()) // has a previous extraction failed? &#123; // yep, so let's handle the failure std::cin.clear(); // put us back in 'normal' operation mode std::cin.ignore(32767,'\\n'); // and remove the bad input std::cout &lt;&lt; \"Oops, that input is invalid. Please try again.\\n\"; &#125; else &#123; std::cin.ignore(32767,'\\n'); // remove any extraneous input // the user can't enter a meaningless double value, so we don't need to worry about validating that return x; &#125; &#125;&#125; char getOperator()&#123; while (true) // Loop until user enters a valid input &#123; std::cout &lt;&lt; \"Enter one of the following: +, -, *, or /: \"; char op; std::cin &gt;&gt; op; // Chars can accept any single input character, so no need to check for an invalid extraction here std::cin.ignore(32767,'\\n'); // remove any extraneous input // Check whether the user entered meaningful input if (op == '+' || op == '-' || op == '*' || op == '/') return op; // return it to the caller else // otherwise tell the user what went wrong std::cout &lt;&lt; \"Oops, that input is invalid. Please try again.\\n\"; &#125; // and try again&#125; void printResult(double x, char op, double y)&#123; if (op == '+') std::cout &lt;&lt; x &lt;&lt; \" + \" &lt;&lt; y &lt;&lt; \" is \" &lt;&lt; x + y &lt;&lt; '\\n'; else if (op == '-') std::cout &lt;&lt; x &lt;&lt; \" - \" &lt;&lt; y &lt;&lt; \" is \" &lt;&lt; x - y &lt;&lt; '\\n'; else if (op == '*') std::cout &lt;&lt; x &lt;&lt; \" * \" &lt;&lt; y &lt;&lt; \" is \" &lt;&lt; x * y &lt;&lt; '\\n'; else if (op == '/') std::cout &lt;&lt; x &lt;&lt; \" / \" &lt;&lt; y &lt;&lt; \" is \" &lt;&lt; x / y &lt;&lt; '\\n'; else // Being robust means handling unexpected parameters as well, even though getOperator() guarantees op is valid in this particular program std::cout &lt;&lt; \"Something went wrong: printResult() got an invalid operator.\"; &#125; int main()&#123; double x = getDouble(); char op = getOperator(); double y = getDouble(); printResult(x, op, y); return 0;&#125;总结在编写程序时，要考虑用户如何误用程序，特别是在文本输入方面。对于文本输入的每个点，请考虑:提取是否失败？用户是否会输入比预期更多的文本？用户是否会输入没有意义的文本？用户是否会输出溢出的值？您可以使用if语句和布尔逻辑来测试输入是否是预期的和有意义的。修复提取失败&amp;溢出123456if (std::cin.fail()) // has a previous extraction failed or overflowed?&#123; // yep, so let's handle the failure std::cin.clear(); // put us back in 'normal' operation mode std::cin.ignore(32767,'\\n'); // and remove the bad input&#125;清除额外的输入1std::cin.ignore(32767,'\\n'); // and remove the bad input最后，如果原始输入无效，使用循环要求用户重新输入输入。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://longlongqin.github.io/tags/C-C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"C&C++/------","slug":"C&C++/------","date":"2020-04-26T08:36:13.397Z","updated":"2020-05-26T15:19:14.956Z","comments":true,"path":"archives/3f9a28c4.html","link":"","permalink":"https://longlongqin.github.io/archives/3f9a28c4.html","excerpt":"","text":"原文：","categories":[],"tags":[]},{"title":"LearnCpp chapter8","slug":"C&C++/LearnCpp-chapter8","date":"2020-04-19T08:54:17.000Z","updated":"2020-05-07T14:45:15.421Z","comments":true,"path":"archives/c812a74c.html","link":"","permalink":"https://longlongqin.github.io/archives/c812a74c.html","excerpt":"LearnCpp-chapter8https://www.learncpp.com未完待续~~","text":"LearnCpp-chapter8https://www.learncpp.com未完待续~~8.1 介绍面向对象编程Object-oriented programming (OOP)在 1.3 – Introduction to variables中，我们在c++中将一个对象定义为“一段可用来存储值的内存”。具有名称的对象称为变量。在传统编程中(我们在此之前一直在做的工作)，程序基本上是计算机的指令列表，这些指令定义数据(通过对象)，然后处理数据(通过语句和函数)。数据和处理该数据的函数是独立的实体，它们组合在一起以产生所需的结果。由于这种分离，传统的编程通常不能提供对现实的非常直观的表示。由程序员以适当的方式管理和连接 属性(变量)和行为(函数)，这就致使代码变成这样：1driveTo(you, work);什么是面向对象编程？和许多事物一样，它可能最容易通过类比来理解。看看你的周围–你看到的每一个地方都是object：书籍、建筑物、食物，甚至你自己。object有两个主要的部分：（properties）相关属性的列表（e.g. weight, color, size, solidity, shape, etc…）（behavior）这些属性能表现出的一些行为（e.g. being opened, making something else hot, etc…）这些属性和行为是不可分割的。Object-oriented programming (OOP) 为我们提供了创建对象的能力，这些对象将属性和行为绑定到一个自包含的、可重用的包中。这导致代码看起来更像这样:1you.driveto(work);这不仅读起来更清晰，还使主语(您)和被调用的行为(在某处驾驶)更清晰。不是专注于编写函数，而是专注于定义具有定义良好的行为集的对象。这就是为什么这个范例被称为“面向对象”。优点这允许以更模块化的方式编写程序，这使它们更容易编写和理解，还提供了更高程度的代码可重用性。这些对象还提供了一种 通过允许我们定义如何与对象交互以及如何与其他对象交互，来更直观的方式来处理数据。请注意，OOP并没有取代传统的编程方法。相反，它在编程工具带中为您提供了额外的工具，以便在需要时管理复杂性。object请注意，术语“object”被稍微重载了一些，这导致了一些混淆。在传统编程中，对象是用来存储值的一块内存。在面向对象编程中，“对象”意味着它包含 传统编程意义上的对象，又是属性和行为的组合。从现在开始，当我们使用“对象”这个术语时，我们将在面向对象的意义上引用“对象”。8.2 类&amp;类成员虽然C++提供一些基本的数据类型（e.g. char, int, long, float, double, etc…），它们可以解决一些简单的问题。但是在解决复杂问题的时候这些基本数据类型就不够用了。C++也提供：允许用户自定义数据类型，如之前学的： enumerated types、structs在C++，中class与 struct本质上相同。如下面的两个是等价的：1234567891011121314struct DateStruct&#123; int year; int month; int day;&#125;; class DateClass&#123;public: int m_year; int m_month; int m_day;&#125;;注意，惟一显著的区别是public:关键字在类中类(和结构体)定义就像一个蓝图——它们描述结果对象的样子，但是它们实际上并不创建对象。要实际创建类的对象，必须定义该类类型的变量:1DateClass today &#123; 2020, 10, 14 &#125;; // declare a variable of class DateClass成员函数除了保存数据，类(和结构)还可以包含函数! 在类内部定义的函数称为成员函数 (有时也称为方法)。成员函数&amp;非成员函数eg：12345678910111213141516//非成员函数：函数不能调用定义在它下面的函数(没有前向声明):void x()&#123; // You can't call y() from here unless the compiler has already seen a forward declaration for y()&#125;void y()&#123; &#125;//成员函数：成员函数没有这个限制class foo&#123;public: void x() &#123;y()&#125; ;// okay to call y() here, even though y() isn't defined until later in this class void y() &#123;&#125;;&#125;成员类型除了成员变量和成员函数外，类还可以具有成员类型或嵌套类型(包括类型别名)。在下面的例子中，我们创建了一个计算器，如果需要，我们可以快速地更改它所使用的数字类型。1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;vertor&gt;class Calculator&#123;public: using number_t = int; //这是一个嵌套类型的别名 std::vector&lt;number_t&gt; m_result&#123;&#125;; number_t add (number_t a, number_t b) &#123; //auto的原理就是根据后面的值，来自己推测前面的类型是什么。 auto result &#123;a+b&#125;; m_result.push_back (result); return result; &#125;&#125;;int main()&#123; Calculator calculator &#123;&#125;; std::cout &lt;&lt; calculator.add(3, 4) &lt;&lt; '\\n'; //7 return 0;&#125;在这样的上下文中，类名实际上充当嵌套类型的，命名空间。在类内部，我们只需要引用number_t。在类之外，我们可以通过Calculator::number_t访问类型。关于C++中的struct的说明在C语言中，结构体只能保存数据，没有成员函数。但是咋C++中，两者都可以有。经过考虑，他决定他们应该有一个统一的规则集。因此，虽然我们使用class关键字编写了上述程序，但我们可以使用struct关键字。所以，建议：对只包含数据的结构使用struct关键字。对同时具有数据和函数的对象使用class关键字。8.3 访问说明符 piblicVS privatepublic：class和struct的public member 可以在 它们的外部访问；由关键字struct构成的数据类型，默认是public。private：只能被类的其他成员访问；由class构成的数据类型，默认是private。通常，成员变量通常是private的，而成员函数通常是public的。eg：123456789101112131415161718192021222324252627282930313233struct DateStruct // members are public by default&#123; int month; // public by default, can be accessed by anyone int day; // public by default, can be accessed by anyone int year; // public by default, can be accessed by anyone&#125;;int main()&#123; DateStruct date; date.month = 10; date.day = 14; date.year= 2020; return 0;&#125;------------------------------------class DateClass // members are private by default&#123; int m_month; // private by default, can only be accessed by other members int m_day; // private by default, can only be accessed by other members int m_year; // private by default, can only be accessed by other members&#125;; int main()&#123; DateClass date; date.m_month = 10; // error date.m_day = 14; // error date.m_year = 2020; // error return 0;&#125;类的public member通常被看作 public interface（公共接口）：因为只有public mebmber才可以在类外部被访问，但是public member可以直接访问类中的private和protected的成员。所以利用public member 可以间接访问类的private和protected的成员。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://longlongqin.github.io/tags/C-C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"LearnCpp chapterL","slug":"C&C++/LearnCpp-chapterL","date":"2020-04-18T02:13:00.000Z","updated":"2020-04-23T08:14:32.228Z","comments":true,"path":"archives/9f7a1269.html","link":"","permalink":"https://longlongqin.github.io/archives/9f7a1269.html","excerpt":"LearnCpp-chapterLhttps://www.learncpp.com未完待续~~","text":"LearnCpp-chapterLhttps://www.learncpp.com未完待续~~L5.1 控制流当程序运行时，CPU开始从mian()函数执行，然后执行它里面的语句，最后结束于main()函数结尾。CPU执行语句的顺序叫做：程序执行路径(execution path)。停止(halt)但程序运行并不总是将main()函数中的语句全部执行。它可以被停止。在C++中，可以使用头文件cstdlib中的std::exit()函数，来终止程序。exit函数接受一个整数参数，该参数作为std::exit代码返回给操作系统，这与main()的返回值非常相似。eg:12345678910111213141516171819#include &lt;cstdlib&gt; //for std::exit()#include &lt;iostream&gt;void cleanup()&#123; //code here to do any kind of cleanup required&#125;int main()&#123; std::cout&lt;&lt; 1 &lt;&lt; '\\n'; cleanup(); std::exit(0); //程序在此结束，并且向操作系统返回0 //所以下面的语句将不会执行 std::cout&lt;&lt;2&lt;&lt;'\\n'; return 0;&#125;注意，std::exit()无论从哪个函数调用(甚至是main以外的函数)都可以工作。还要注意，std::exit()使用最少的清理立即终止程序。所以，在使用std::exit()之前，您应该考虑是否需要进行任何手动清理(例如将用户的游戏保存到磁盘)。通常，std::exit()用于在发生灾难性的、不可恢复的错误时立即终止程序。L5.1 if语句最基本的条件分支就是 if 语句。隐式的块我们需要注意，隐式的块中的一些陷阱，陷阱1：1234567891011121314#include &lt;iostream&gt; int main()&#123; if (true) int x = 5; else int x = 6; std::cout &lt;&lt; x; return 0;&#125;//因为上面的x是在一个块中被定义的(这个块没有显式的写出来，但它确实是一个块)上面这个程序会出错，原因：（这将无法编译，编译器将生成标识符x未定义的错误）123456789101112131415161718//上面的程序和这个程序相等。这个程序将块显式的表示出来了#include &lt;iostream&gt; int main()&#123; if (true) &#123; int x = 5; &#125; // x destroyed here else &#123; int x = 6; &#125; // x destroyed here std::cout &lt;&lt; x; // x isn't defined here return 0;&#125;陷阱2：程序1：123456789101112131415161718#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; \"Enter a number: \"; int x; std::cin &gt;&gt; x; if (x &gt;= 10) &#123; if (x &lt;= 20) std::cout &lt;&lt; x &lt;&lt; \"is between 10 and 20\\n\"; &#125; else // attached to outer if statement std::cout &lt;&lt; x &lt;&lt; \"is less than 10\\n\"; return 0;&#125;程序2：（去掉大括号）123456789101112131415161718#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; \"Enter a number: \"; int x; std::cin &gt;&gt; x; if (x &gt;= 10) //删除大括号 if (x &lt;= 20) std::cout &lt;&lt; x &lt;&lt; \"is between 10 and 20\\n\"; else // attached to outer if statement std::cout &lt;&lt; x &lt;&lt; \"is less than 10\\n\"; return 0;&#125;程序1和2是否一样呢？答：不一样。程序1中的最后的else语句是与第一个if语句匹配；程序2中的最后的else语句是与它最近的if语句匹配。if中的初始化语句如果需要在If语句中使用变量，而不是在If语句之外，那么可以在条件之前使用init语句(在C++17中添加的）。1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;int main()&#123; std::string firstname&#123;&#125;; std::string lastname&#123;&#125;; std::cout &lt;&lt; \"First name: \"; std::cin &gt;&gt; firstName; std::cout &lt;&lt; \"Last name: \"; std::cin &gt;&gt; lastName; if(std::string fullname &#123;firsstname + ' ' + lastname&#125;; fullname.length()&gt;20) &#123; std::cout &lt;&lt; '\"'&lt;&lt;fullname &lt;&lt;'\\\" is to long \\n'; &#125; else &#123; std::cout &lt;&lt;\"your name is: \" &lt;&lt;fullname; &#125; return 0; &#125;变量fullname在整个if语句中是可以访问的。L5.2 switch语句C++ 中 switch 语句的语法：123456789101112switch(expression)&#123; case constant-expression : statement(s); break; // 可选的 case constant-expression : statement(s); break; // 可选的 // 您可以有任意数量的 case 语句 default : // 可选的 statement(s);&#125;switch 语句必须遵循下面的规则：switch 语句中的 expression 必须是一个integral type(整数类型)或浮点类型，或者是一个 class 类型，其中 class 有一个单一的转换函数将其转换为整型或枚举类型。整数类型有：char, short, int, long, long long, or enum注意，在C/C++中，char是属于整数类型的。在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。case 的 constant-expression 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 break 语句为止。当遇到 break 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。不是每一个 case 都需要包含 break。如果 case 语句不包含 break，控制流将会 继续 后续的 case，直到遇到 break 为止。一个 switch 语句可以有一个可选的 default case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 break 语句不是必需的。break在case语句中有、无 break 的效果在 switch 语句中，每个 case 语句的结尾不要忘记添加 break 语句，否则将导致多个分支重叠。当然，除非有意使多个分支重叠，这样可以免去 break 语句。下面我们来看一个实际示例。1234567891011121314151617181920212223242526272829303132333435363738394041424344//有breakswitch (2)&#123; case 1: // Does not match std::cout &lt;&lt; 1 &lt;&lt; '\\n'; // skipped break; case 2: // Match! std::cout &lt;&lt; 2 &lt;&lt; '\\n'; // Execution begins here break; case 3: std::cout &lt;&lt; 3 &lt;&lt; '\\n'; // This is also executed break; case 4: std::cout &lt;&lt; 4 &lt;&lt; '\\n'; // This is also executed break; default: std::cout &lt;&lt; 5 &lt;&lt; '\\n'; // This is also executed break;&#125;/**结果******/2 //无breakswitch (2)&#123; case 1: // Does not match std::cout &lt;&lt; 1 &lt;&lt; '\\n'; // skipped case 2: // Match! std::cout &lt;&lt; 2 &lt;&lt; '\\n'; // Execution begins here case 3: std::cout &lt;&lt; 3 &lt;&lt; '\\n'; // This is also executed case 4: std::cout &lt;&lt; 4 &lt;&lt; '\\n'; // This is also executed default: std::cout &lt;&lt; 5 &lt;&lt; '\\n'; // This is also executed&#125;/******结果***********/2345case语句中变量的声明&amp;定义你可以在switch语句中声明变量(但不能够初始化)。在case之前或之后均可：12345678910111213141516171819202122switch (1)&#123; int a; // okay, declaration is allowed before the case labels int b = 5; // illegal, initialization is not allowed before the case labels case 1: int y; // okay, declaration is allowed within a case y = 4; // okay, 这个是赋值(不是初始化) break; case 2: y = 5; // okay, y was declared above, so we can use it here too break; case 3: int z = 4; // illegal, 不能再这里面对变量初始化 break; default: std::cout &lt;&lt; \"default case\" &lt;&lt; std::endl; break;&#125;因为在switch语句中，不存在隐式的块。所以，在switch语句内，所有语句的范围都一样(存在于switch的内部)。所以，在case 1：声明的变量y，可以在case 2：中被访问但是，不允许直接在case标签下面初始化变量，这会导致编译错误。这是因为初始化变量需要执行（声明语句不会执行），而包含初始化的case语句可能不会执行!但是我们可以在case块中，初始化变量：123456789101112switch (1)&#123; case 1: &#123; // note addition of block here int x = 4; // okay, variables can be initialized inside a block inside a case std::cout &lt;&lt; x; break; &#125; default: std::cout &lt;&lt; \"default case\" &lt;&lt; std::endl; break;&#125;L5.4 goto 语句goto语句是一个控制流语句，它使CPU跳到代码中的另一个位置。这个位置是通过使用statement label（语句标签）来标识的。eg:12345678910111213141516#include &lt;iostream&gt;#include &lt;cmath&gt; // for sqrt() function int main()&#123; double x;tryAgain: // this is a statement label std::cout &lt;&lt; \"Enter a non-negative number\"; std::cin &gt;&gt; x; if (x &lt; 0.0) goto tryAgain; // this is the goto statement std::cout &lt;&lt; \"The sqrt of \" &lt;&lt; x &lt;&lt; \" is \" &lt;&lt; sqrt(x) &lt;&lt; std::endl; return 0;&#125;如果用户输入的数是负数，那它会一直goto到这个语句标签，直到你输入一个合格的非负数。陷阱：12345678int main()&#123; goto skip; // invalid forward jump int x = 5;skip: x += 3; // what would this even evaluate to? return 0;&#125;我们不能这样使用 语句标签。因为我们跳转到标签语句skip中时，程序还没执行到int x = 5;这个语句。所以，会报错：如何改正：我们可以让int x=5;这个语句放在 goto skip;语句之前，就可以了。不建议使用goto语句goto的主要问题是，它允许程序员任意地在执行点上跳转。因此很难理解这种代码的逻辑。L5.7 for语句123//形式for (init-statement; condition-expression; end-expression) statement多重声明有时for循环需要多个变量。当这种情况发生时，程序员可以使用逗号操作符来分配(在init-statement中)或更改(在end-statement中)多个变量的值:12345678910 int iii&#123;&#125;; int jjj&#123;&#125;; for (iii = 0, jjj = 9; iii &lt; 10; ++iii, --jjj) std::cout &lt;&lt; iii &lt;&lt; ' ' &lt;&lt; jjj &lt;&lt; '\\n';//更常用的写法是：for(int iii&#123;0&#125;, jjj&#123;9&#125;; iii&lt;10; ++iii, --jjj)&#123; std::cout &lt;&lt;iii &lt;&lt;' ' &lt;&lt;jjj &lt;&lt; '\\n';&#125;L5.8 break 和 continuebreak与returnbreak语句是终止switch语句 或者 其他循环语句，然后继续执行该语句下面的语句。return语句终止循环所在的整个函数，并在调用函数的地方继续执行。请看下面例子：12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt; int breakOrReturn()&#123; while (true) // infinite loop &#123; std::cout &lt;&lt; \"Enter 'b' to break or 'r' to return: \"; char ch; std::cin &gt;&gt; ch; if (ch == 'b') break; // execution will continue at the first statement beyond the loop if (ch == 'r') return 1; // return will cause the function to immediately return to the caller (in this case, main()) &#125; // breaking the loop causes execution to resume here std::cout &lt;&lt; \"We broke out of the loop\\n\"; return 0;&#125; int main()&#123; int returnValue&#123; breakOrReturn() &#125;; std::cout &lt;&lt; \"Function breakOrReturn returned \" &lt;&lt; returnValue &lt;&lt; '\\n'; return 0;&#125;continuecontinue语句提供了一种方便的方法来跳转到当前迭代（当前这一层循环）的循环体的末尾。当我们想要提前终止当前的迭代时，这是很有用的。123456789101112for (int count&#123; 0 &#125;; count &lt; 20; ++count)&#123; // if the number is divisible by 4, skip this iteration if ((count % 4) == 0) continue; // jump to end of loop body // If the number is not divisible by 4, keep going std::cout &lt;&lt; count &lt;&lt; std::endl;------------------------------------------------------ // The continue statement jumps to here------------------------------------------------------&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://longlongqin.github.io/tags/C-C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"LearnCpp chapterP","slug":"C&C++/LearnCpp-chapterS","date":"2020-04-14T08:48:27.000Z","updated":"2020-04-28T06:53:21.411Z","comments":true,"path":"archives/67343d3.html","link":"","permalink":"https://longlongqin.github.io/archives/67343d3.html","excerpt":"LearnCpp chapterPhttps://www.learncpp.com","text":"LearnCpp chapterPhttps://www.learncpp.comS.4.4b 介绍std::string字符串在程序中很常见，大部分现代编程语言都包括一个内置的字符串数据类型。C++包括一个，不是作为核心语言的一部分，而是作为标准库的一部分。std::string如果想在C++中使用string类型。需要加入头文件#include &lt;string&gt;来声明std::string。只要有这个头文件，我们就可以在程序中使用string类型。12#include &lt;string&gt;std::string myName;就像其他类型一样，你可以为字符串类型的变量进行初始化 或者 复制：12std::string myName&#123; \"Alex\" &#125;; // initialize myName with string literal \"Alex\"myName = \"John\"; // assign variable myName the string literal \"John\"字符串也可以保存数字：1std::string myID&#123; \"45\" &#125;; // \"45\" is not the same as integer 45!字符串格式的 数字，其实是文本形式，而不是 数字形式。输入输出字符串12345678910111213#include &lt;string&gt;#include &lt;iostream&gt; int main()&#123; std::string myName&#123; \"Alex\" &#125;; std::cout &lt;&lt; \"My name is: \" &lt;&lt; myName &lt;&lt; '\\n'; return 0;&#125;/************打印***********/My name is: Alex但是，使用std::cin来输入字符串，可能会产生异常：1234567891011121314151617#include &lt;string&gt;#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; \"Enter your full name: \"; std::string name; std::cin &gt;&gt; name; // this won't work as expected since std::cin breaks on whitespace std::cout &lt;&lt; \"Enter your age: \"; std::string age; std::cin &gt;&gt; age; std::cout &lt;&lt; \"Your name is \" &lt;&lt; name &lt;&lt; \" and your age is \" &lt;&lt; age &lt;&lt; '\\n'; return 0;&#125;结果：可以看到，大 魔头中间有空格。然后就会被自动截断，前一部分赋值给变量name；第二半段赋值给age。也就是说：那是不对的!发生了什么事?结果表明，当使用操作符&gt;&gt;从cin提取字符串时，操作符&gt;&gt;只返回它遇到的第一个空格之前的字符。其他字符留在cin中，等待下一次提取。用std::getline()输入文本要将整行输入读入字符串，我们最好需要使用std::getline()函数。std::getline()含有两个形参：第一个是std::cin；第二个是我们输入的字符串的变量12345678910111213141516171819202122#include &lt;string&gt;#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; \"Enter your full name: \"; std::string name&#123;&#125;; std::getline(std::cin, name); // read a full line of text into name std::cout &lt;&lt; \"Enter your age: \"; std::string age&#123;&#125;; std::getline(std::cin, age); // read a full line of text into age std::cout &lt;&lt; \"Your name is \" &lt;&lt; name &lt;&lt; \" and your age is \" &lt;&lt; age &lt;&lt; '\\n'; return 0;&#125;/********结果**************/Enter your full name: John DoeEnter your age: 23Your name is John Doe and your age is 23混合使用std::cin、std::getline()混合使用他俩，可能会产生异常：1234567891011121314151617#include &lt;string&gt;#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; \"Pick 1 or 2: \"; int choice&#123;&#125;; std::cin &gt;&gt; choice; std::cout &lt;&lt; \"Now enter your name: \"; std::string name&#123;&#125;; std::getline(std::cin, name); std::cout &lt;&lt; \"Hello, \" &lt;&lt; name &lt;&lt; \", you picked \" &lt;&lt; choice &lt;&lt; '\\n'; return 0;&#125;这个程序首先要求您输入1或2，然后等待您这样做。到目前为止一切顺利。然后它会要求你输入你的名字。然而，它实际上不会等待您输入您的名字！相反，它打印“Hello”行，然后退出。发生了什么事?结果是，当您使用cin输入一个值时，cin不仅捕获值，还捕获换行符。当我们输入2时，cin实际上会得到字符串“2\\n”。然后提取2到变量选择，使换行留在输入流中。然后，当std::getline()去读取名称时，它会看到“\\n”已经在流中，并且认为我们必须输入一个空字符串!绝对不是我们想要的。一个好方法：使用std::cin读取完值 之后，将换行 从输入流中删除：std::cin.ignore(32767, &#39;\\n&#39;); //忽略不超过32767个字符，直到删除一个\\n.关于32767请看下一节如下，在main函数中，增加一句std::cin.ignore(32767, &#39;\\n&#39;);：1234567891011121314151617int main()&#123; std::cout &lt;&lt; \"Pick 1 or 2: \"; int choice&#123;&#125;; std::cin &gt;&gt; choice; //新加 std::cin.ignore(32767, '\\n'); // ignore up to 32767 characters until a \\n is removed std::cout &lt;&lt; \"Now enter your name: \"; std::string name; std::getline(std::cin, name); std::cout &lt;&lt; \"Hello, \" &lt;&lt; name &lt;&lt; \", you picked \" &lt;&lt; choice &lt;&lt; '\\n'; return 0;&#125;规则:如果使用std::cin读取值，最好使用std:: cin .ignore()来删除多余的换行符。32767代表什么这告诉std::cin.ignore()要忽略多少字符。我们选择32767是因为它是保证在所有平台上都适合(2字节)整数的最大有符号值。从技术上讲，忽略无限量输入的正确方法如下:12345#include &lt;limits&gt; ... std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n'); // ignore unlimited characters until a \\n is removed但是，相比之下，这样的方式太复杂了。而且还需要加上头文件limits字符串的“加法”12345678910111213141516171819#include &lt;string&gt;#include &lt;iostream&gt; int main()&#123; std::string a&#123; \"45\" &#125;; std::string b&#123; \"11\" &#125;; std::cout &lt;&lt; a + b &lt;&lt; '\\n'; // a and b will be concatenated a += \"volts\"; std::cout &lt;&lt; a; return 0;&#125;/*****结果********/451145volts注意，如果你想对字符串减法，是不可以的熬字符串长度12345678910#include &lt;string&gt;#include &lt;iostream&gt; int main()&#123; std::string myName&#123; \"Alex\" &#125;; std::cout &lt;&lt; myName &lt;&lt; \" has \" &lt;&lt; myName.length() &lt;&lt; \" characters\\n\"; std::cout &lt;&lt; myName &lt;&lt; \" has \" &lt;&lt; length(myName) &lt;&lt; \" characters\\n\";//error:未定义标识符 length return 0;&#125;注意，我们不是将字符串长度作为length(myName)，而是使用myName.length()。length函数不是我们目前使用的一个普通的独立函数，它是属于std::string的一种特殊类型的函数，称为成员函数。S.4.4c 使用语言参考本节原文地址：S.4.4c — Using a language reference其中一个资源是Stack Overflow，你可以在这里提问；另一个就是语言参考文档： cppreference；S.4.5 枚举类型c++包含允许程序员创建自己的数据类型的功能。这些数据类型称为用户定义的数据类型。枚举类型(也称为enumeration或enum)是一种数据类型，其中每个可能的值都被定义为符号常量(称为enumerator(枚举器))。枚举是通过enum关键字定义的。让我们来看一个例子:注意，每个枚举数由逗号分隔，整个枚举以分号结束。1234567891011121314151617181920// Define a new enumeration named Colorenum Color&#123; // Here are the enumerators // These define all the possible values this type can hold // Each enumerator is separated by a comma, not a semicolon COLOR_BLACK, COLOR_RED, COLOR_BLUE, COLOR_GREEN, COLOR_WHITE, COLOR_CYAN, COLOR_YELLOW, COLOR_MAGENTA, // see note about trailing comma on the last enumerator below&#125;; // however the enum itself must end with a semicolon // Define a few variables of enumerated type ColorColor paint = COLOR_WHITE;Color house(COLOR_BLUE);Color apple &#123; COLOR_RED &#125;;定义一个枚举类型(也可以说，定义一个用户自定义类型)时，是不会给它分配内存的；只有当定义了枚举类型的变量(如上面示例中的变量paint)时，才会为该变量分配内存。在c++ 11之前，不允许在最后一个枚举数之后使用逗号(例如，在COLOR_MAGENTA之后)(尽管许多编译器都接受了逗号)。但是，从c++ 11开始，允许使用逗号结尾。现在c++ 11编译器更加流行了，一般认为在最后一个元素后面使用逗号是可以接受的。枚举的命名和枚举器枚举的命名是可选的，通常，没有名字的枚举有时被称为匿名枚举。枚举的名字通常以大写字母开头。枚举器(枚举常量)是必须要给出名字的。它的名字通常是大写字母(如，COLOR_WHITE)，或者以大写字母K为前缀(如， kColorWhite)枚举常量的范围因为枚举常量被放在与枚举相同的命名空间中，所以，枚举常量名字不能用于同一命名空间内的多个枚举:12345678910111213enum Color&#123;RED,BLUE, // BLUE is put into the global namespaceGREEN&#125;; enum Feeling&#123;HAPPY,TIRED,BLUE // error, BLUE was already used in enum Color in the global namespace&#125;;枚举常量的值每个枚举器根据其在枚举列表中的位置自动分配一个整数值。默认情况下，第一个枚举数被赋值为整数值0，随后的每个枚举数的值都比前一个枚举数大1:1234567891011121314151617enum Color&#123; COLOR_BLACK, // assigned 0 COLOR_RED, // assigned 1 COLOR_BLUE, // assigned 2 COLOR_GREEN, // assigned 3 COLOR_WHITE, // assigned 4 COLOR_CYAN, // assigned 5 COLOR_YELLOW, // assigned 6 COLOR_MAGENTA // assigned 7&#125;; Color paint(COLOR_WHITE);std::cout &lt;&lt; paint;/*********结果*********/4你也可以显式定义枚举数的值。这些整数值可以是正的，也可以是负的，并且可以与其他枚举数共享相同的值。任何未定义的枚举数都被赋予一个比前一个枚举数大1的值。12345678910// define a new enum named Animalenum Animal&#123; ANIMAL_CAT = -3, ANIMAL_DOG, // assigned -2 ANIMAL_PIG, // assigned -1 ANIMAL_HORSE = 5, ANIMAL_GIRAFFE = 5, // shares same value as ANIMAL_HORSE ANIMAL_CHICKEN // assigned 6&#125;;注意到：ANIMAL_HORSE和ANIMAL_GIRAFFE的值相同。这表示他们两个可以互换。即，它俩没区别。虽然，C++允许这样，但是不建议将枚举常量赋值位相同的值。枚举类型的input/output因为枚举值是整数类型的，所以它们可以被赋值给整型变量。这意味着它们可以 以integers形式被output，因为std::cout知道如何输出整数。12345int mypet = ANIMAL_PIG;std::cout &lt;&lt; ANIMAL_PIG;//evaluates to integer before being passed to std::cout/*******结果*****/5编译器不会隐式的将整型转变为枚举类型值。1234Animal animal = 5; // will cause compiler error//但是我们可以使用 static_cast 来强制转换Color color = static_cast&lt;Color&gt;(5); // ugly编译器也不会让你输入一个枚举类型：1234567891011121314151617181920enum Color&#123; COLOR_BLACK, // assigned 0 COLOR_RED, // assigned 1 COLOR_BLUE, // assigned 2 COLOR_GREEN, // assigned 3 COLOR_WHITE, // assigned 4 COLOR_CYAN, // assigned 5 COLOR_YELLOW, // assigned 6 COLOR_MAGENTA // assigned 7&#125;; Color color;std::cin &gt;&gt; color; // will cause compiler error//但是，我们可以通过读取一个整型，并使用static_cast来强制编译器将整型值放入枚举类型中：int inputColor;std::cin&gt;&gt; inpitColor;Color color&#123; static_cast&lt;Color&gt;(inputColor) &#125;;每个枚举类型都被认为是不同的类型。因此，试图将枚举数从一个枚举类型分配到另一个枚举类型将导致编译错误:1Animal animal&#123; COLOR_BLUE &#125;; // will cause compiler error如果您想为枚举器使用不同的整数类型，你可以您可以在enum声明中指定它：1234567// Use an 8 bit unsigned integer as the enum base.enum Color : std::uint_least8_t&#123; COLOR_BLACK, COLOR_RED, // ...&#125;;枚举类型的提前声明。12345678910111213enum Color; // Errorenum Color : int; // Okay // ... // Because Color was forward declared with a fixed base, we// need to specify the base again at the definition.enum Color : int&#123; COLOR_BLACK, COLOR_RED, // ...&#125;;Enum分配和提前声明Enum类型被认为是整数类型家族的一部分，它由编译器决定为Enum变量分配多少内存。c++标准要求枚举的大小必须足够大，以表示所有枚举值。通常，它会使enum变量的大小与标准int相同。因为编译器知道给枚举类型分配多少内存，所以您只能在指定固定基数时，才可以提前声明它们。枚举器有什么用?当需要表示特定的预定义状态集时，枚举类型对于代码文档和可读性非常有用。如：1234567891011int readFileContents()&#123; if (!openFile()) return -1; if (!readFile()) return -2; if (!parseFile()) return -3; return 0; // success&#125;负数用来表示不同的可能的错误代码。如上面：-1 -2 -3然而，使用像这样的神奇数字并不是很有描述性。另一种方法是使用枚举类型：这种方法可读性更强。12345678910111213141516171819enum ParseResult&#123; SUCCESS = 0, ERROR_OPENING_FILE = -1, ERROR_READING_FILE = -2, ERROR_PARSING_FILE = -3&#125;; ParseResult readFileContents()&#123; if (!openFile()) return ERROR_OPENING_FILE; if (!readFile()) return ERROR_READING_FILE; if (!parsefile()) return ERROR_PARSING_FILE; return SUCCESS;&#125;调用者可以根据适当的枚举器测试函数的返回值，这比测试特定整数值的返回结果更容易理解。如：12345678if (readFileContents() == SUCCESS) &#123; // do something &#125;else &#123; // print error message &#125;许多语言使用枚举定义布尔值。布尔值本质上就是一个有两个枚举器的枚举:false和true!然而，在c++中，true和false被定义为关键字，而不是枚举数。S.4.6 枚举类C++11定义了一个新概念，enum class(枚举类)，也称 scoped enumeration（作用域枚举）。我们在enum之后使用关键字 class来构造枚举类：1234567891011121314151617181920212223242526#include &lt;iostream&gt; int main()&#123; enum class Color // \"enum class\" defines this as a scoped enumeration instead of a standard enumeration &#123; red, // red is inside the scope of Color blue &#125;; enum class Fruit &#123; banana, // banana is inside the scope of Fruit apple &#125;; Color color&#123; Color::red &#125;; // note: red is not directly accessible any more, we have to use Color::red Fruit fruit&#123; Fruit::banana &#125;; // note: banana is not directly accessible any more, we have to use Fruit::banana if (color == fruit) // compile error here, as the compiler doesn't know how to compare different types Color and Fruit std::cout &lt;&lt; \"color and fruit are equal\\n\"; else std::cout &lt;&lt; \"color and fruit are not equal\\n\"; return 0;&#125;对于正常的枚举，枚举器被放置在与枚举本身相同的范围内。所以，我们可以直接访问枚举器(枚举常量). (e.g. red).因为枚举器是enum类的一部分，所以不需要在枚举器名称前面加上前缀(例如，可以使用red而不是COLOR_red，因为Color::COLOR_red是多余的)。但是，在枚举类中，严格的范围规则意味着所有的枚举器(枚举常量)是枚举的一部分。所以，我们必须使用必须使用范围限定符来访问枚举器(例如，Color::red)。这有助于降低名称污染和名称冲突的可能性。强类型规则意味着每个enum类都被认为是唯一的类型。这意味着编译器不会隐式地比较来自不同枚举的枚举数。如果尝试这样做，编译器将抛出一个错误，如上面的示例所示。然而，你仍然可以在同一枚举类 内部进行 枚举常量的比较(因为让门属于同一类型)：12345678910111213141516171819#include &lt;iostream&gt; int main()&#123; enum class Color &#123; red, blue &#125;; Color color&#123; Color::red &#125;; if (color == Color::red) // this is okay(这样是可以的) std::cout &lt;&lt; \"The color is red!\\n\"; else if (color == Color::blue) std::cout &lt;&lt; \"The color is blue!\\n\"; return 0;&#125;使用enum类，编译器将不再隐式地将枚举数值转换为整数。这基本上是一件好事。但是，在某些情况下，这样做是有用的。在这些情况下，可以使用static_cast将enum类枚举数显式转换为整数:1234567891011121314151617#include &lt;iostream&gt; int main()&#123; enum class Color &#123; red, blue &#125;; Color color&#123; Color::blue &#125;; std::cout &lt;&lt; color; // won't work, because there's no implicit conversion to int std::cout &lt;&lt; static_cast&lt;int&gt;(color); // will print 1 return 0;&#125;【note】万一你遇到它，“enum struct”相当于“enum class”。但这种用法不推荐，也不常用。S.4.7 structc++允许我们创建自己的用户定义的aggregate data types(聚集数据类型)。聚集数据类型：是将多个单独变量分组在一起的数据类型struct就是聚集数据类型的最简单之一。struct的定义&amp;声明因为structs是用户自定义的，所以我们首先要在使用它之前，必须要告诉编译器我们的struct是什么样的。我们使用struct关键字声明结构体。12345678//告诉编译器我们定义了一个结构体，名为Employeestruct Employee&#123; short id; int age; double wage;&#125;;//这些结构中的变量称为 **成员(或字段)**。记住，上面的Employee只是一个声明。尽管我们告诉编译器结构体将有成员变量，但此时没有分配内存。按照惯例，结构名以大写字母开头，以便与变量名区分开来。为了使用Employee结构，我们只需声明一个类型为Employee的变量:1Employee joe; // struct Employee is capitalized, variable joe is not这定义了一个名为joe的Employee类型的变量。与普通变量一样，定义结构变量为该变量分配内存。访问结构体成员当我们定义一个变量如Employee joe时，joe引用整个结构(包含成员变量)。为了访问各个成员，我们使用member selection operator(成员选择操作符)。下面是一个使用成员选择操作符初始化每个成员变量的例子:123456789Employee joe; // create an Employee struct for Joejoe.id = 14; // assign a value to member id within struct joejoe.age = 32; // assign a value to member age within struct joejoe.wage = 24.15; // assign a value to member wage within struct joe Employee frank; // create an Employee struct for Frankfrank.id = 15; // assign a value to member id within struct frankfrank.age = 28; // assign a value to member age within struct frankfrank.wage = 18.27; // assign a value to member wage within struct frank与普通变量一样，结构成员变量没有初始化，通常会包含垃圾。我们必须手动初始化它们。Struct成员变量的作用就像普通变量一样，所以可以对它们进行普通操作:1234567891011121314int totalAge&#123; joe.age + frank.age &#125;; if (joe.wage &gt; frank.wage) std::cout &lt;&lt; \"Joe makes more than Frank\\n\";else if (joe.wage &lt; frank.wage) std::cout &lt;&lt; \"Joe makes less than Frank\\n\";else std::cout &lt;&lt; \"Joe and Frank make the same amount\\n\"; // Frank got a promotionfrank.wage += 2.50; // Today is Joe's birthday++joe.age; // use pre-increment to increment Joe's age by 1初始化结构体通过逐个成员分配值来初始化结构有点麻烦，因此，c++支持使用initializer list(初始化列表)来初始化结构体的更快方法:123456789struct Employee&#123; short id; int age; double wage;&#125;; Employee joe&#123; 1, 32, 60000.0 &#125;; // joe.id = 1, joe.age = 32, joe.wage = 60000.0Employee frank&#123; 2, 28 &#125;; // frank.id = 2, frank.age = 28, frank.wage = 0.0 (default initialization)在C++11/14中: Non-static member initialization从c++ 11开始，可以给非静态(普通)结构成员一个默认值:1234567891011121314struct Rectangle&#123; double length&#123; 1.0 &#125;; double width&#123; 1.0 &#125;;&#125;; int main()&#123; Rectangle x; // length = 1.0, width = 1.0 x.length = 2.0; // you can assign other values like normal return 0;&#125;不幸的是，在c++ 11中，非静态成员初始化语法与初始化列表和统一的初始化语法不兼容。例如，在c++ 11中，以下程序无法编译:123456789101112struct Rectangle&#123; double length&#123; 1.0 &#125;; // non-static member initialization double width&#123; 1.0 &#125;;&#125;; int main()&#123; Rectangle x&#123; 2.0, 2.0 &#125;; // uniform initialization/initializer list【推荐】 return 0;&#125;因此，在c++ 11中，您必须决定是使用非静态成员初始化还是使用统一初始化。统一初始化更加灵活，因此我们建议坚持使用这种方法。然而，在c++ 14中，这个限制被取消了，两者都可以使用。如果两者都提供了，则优先使用初始化列表/统一初始化语法（即：initializer list）。在上面的例子中，矩形x的length和width将用2.0进行初始化。在c++ 14中，两者都使用应该是首选的，因为它允许您声明具有或不具有初始化参数的结构，并确保成员已初始化对结构体赋值12345678910111213141516171819202122struct Employee&#123; short id; int age; double wage;&#125;; Employee joe;joe = &#123; 1, 32, 60000.0 &#125;; // C++11 only(只在C++11中可以使用)//在C++11之前struct Employee&#123; short id; int age; double wage;&#125;; Employee joe;joe.id = 1;joe.age = 32;joe.wage = 60000.0;结构体与函数与单个变量相比，使用struct的一大好处是，我们可以将整个struct传递给一个需要与成员协同工作的函数:这避免了我们必须单独传递每个变量。12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt; struct Employee&#123; short id; int age; double wage;&#125;; void printInformation(Employee employee)&#123; std::cout &lt;&lt; \"ID: \" &lt;&lt; employee.id &lt;&lt; '\\n'; std::cout &lt;&lt; \"Age: \" &lt;&lt; employee.age &lt;&lt; '\\n'; std::cout &lt;&lt; \"Wage: \" &lt;&lt; employee.wage &lt;&lt; '\\n';&#125; int main()&#123; Employee joe &#123; 14, 32, 24.15 &#125;; Employee frank &#123; 15, 28, 18.27 &#125;; // Print Joe's information printInformation(joe); std::cout &lt;&lt; '\\n'; // Print Frank's information printInformation(frank); return 0;&#125;/******结果*********/ID: 14Age: 32Wage: 24.15ID: 15Age: 28Wage: 18.27我们将整个Employee结构传递给printInformation() (通过值传递，这意味着实参被复制到形参中)。函数的返回可以是一个结构体：一个函数也可以返回一个结构体，这是使一个函数返回多个变量的几种方法之一。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt; struct Point3d&#123; double x; double y; double z;&#125;; Point3d getZeroPoint()&#123; // We can create a variable and return the variable. Point3d temp &#123; 0.0, 0.0, 0.0 &#125;; return temp;&#125; Point3d getZeroPoint2()&#123; // We can return directly. We already specified the type // at the function declaration (Point3d), so we don't need // it again here. return &#123; 0.0, 0.0, 0.0 &#125;;&#125; Point3d getZeroPoint3()&#123; // We can use empty curly braces to zero-initialize all // members of `Point3d`. return &#123;&#125;;&#125; int main()&#123; Point3d zero&#123; getZeroPoint() &#125;; if (zero.x == 0.0 &amp;&amp; zero.y == 0.0 &amp;&amp; zero.z == 0.0) std::cout &lt;&lt; \"The point is zero\\n\"; else std::cout &lt;&lt; \"The point is not zero\\n\"; return 0;&#125;结构体嵌套结构体可以包含其他结构体。例如:12345678910111213141516struct Employee&#123; short id; int age; double wage;&#125;; struct Company&#123; Employee CEO; // Employee is a struct within the Company struct int numberOfEmployees;&#125;; Company myCompany;//我们可以使用初始化列表初始化它们：//Company myCompany&#123;&#123; 1, 42, 60000.0 &#125;, 5 &#125;;结构体的大小结构体的大小是所有成员大小的总和，但这不是一定的。12345678910111213141516struct Employee&#123; short id; int age; double wage;&#125;; int main()&#123; std::cout &lt;&lt; \"The size of Employee is \" &lt;&lt; sizeof(Employee) &lt;&lt; '\\n'; return 0;&#125;/*******结果*************/The size of Employee is 16结果是，我们只能说结构体的大小至少与它所包含的所有变量的大小一样大。但它可以更大! 出于性能原因，编译器有时会在结构中添加空白(这称为padding(填充))。事实上，上面程序中的Employee结构体中，编译器在成员id的后面添加了2个字节的填充(这是不可见的)。所以才导结构的大小为16字节，而不是14字节。本课介绍的结构有时被称为plain old data structs(普通旧数据结构)(或POD结构)，因为成员都是数据(变量)成员。将来(当我们讨论类时)，我们将讨论其他类型的成员","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://longlongqin.github.io/tags/C-C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"【转】Github下载提速","slug":"实用技巧/[转]Github克隆&下载提速","date":"2020-04-13T15:21:08.000Z","updated":"2020-04-19T14:38:29.546Z","comments":true,"path":"archives/260c7660.html","link":"","permalink":"https://longlongqin.github.io/archives/260c7660.html","excerpt":"Github克隆&下载提速以上内容转载于：https://mp.weixin.qq.com/s/SYR4zvjhAH1mX9fxdp8cbA原作者：codesheep","text":"Github克隆&下载提速以上内容转载于：https://mp.weixin.qq.com/s/SYR4zvjhAH1mX9fxdp8cbA原作者：codesheep一个痛点众所周知，GitHub是一个巨大的开源宝库，以及程序员和编程爱好者的聚集地，包括我之前推荐的诸多优秀的开源项目全部都是位于GitHub上。但是每当我们看到优秀的开源项目，准备去下（bai）载（piao）时，会发现 git clone的速度异常之慢！就我个人而言，在我家里200M移动宽带的环境下，我克隆开源项目就没发现速度大于过 20.00KiB/s的时候，这简直太难受了。小项目倒还好，我等几分钟无所谓；一旦项目庞大起来，或者项目文件数目一多， git clone 大概率会失败！当然网上常见的诸如修改hosts、代理等方式实际使用效果并不一定好，而且也不稳定。“码云”是个好东西接下来就介绍一种GitHub下载的加速方法：通过国内码云平台的转接，来完成GitHub上项目的下载加速。感谢公众号小伙伴ioc提供思路（1）首先确保码云上有账户，可以正常使用，没有的可以自行注册一下。（2）点击右上角新建仓库的加号 +，选择“从 GitHub/GitLab导入仓库”菜单（3）然后填写位于 GitHub上你想 clone的仓库地址并导入这一步交给码云来做速度是非常快的，一会儿功夫，码云就克隆出了一份和GitHub上一模一样的项目！（4）接下来我们通过码云上的项目地址，将项目 clone到本地，这时候的clone速度就很快了，几 MB/s的速度是没问题的，很快项目就下载下来了。按道理讲这时候我们的目的已经达到了，不过不要忘了，还有一件事没做。重新关联远端地址要知道，这时候克隆到本地的项目关联的是码云Gitee的地址，已经和原来的GitHub项目完全脱离了，是另外一个副本。在必要情况下（比如我们就是要给GitHub上的某个项目提 PR），我们还需要重新将我们本地的项目关联到原来的GitHub项目上去，做法如下：（1）首先找到位于本地仓库目录下的隐藏文件夹 .git（2）用文本编辑器打开 .git文件夹中的 config配置文件将配置文件中的 [remote&quot;origin&quot;].url字段重新关联到原来位于GitHub上的GitHub项目地址当然你也可以通过命令行来修改远端地址，效果一样的至此大功告成，本地项目就相当于是 clone自GitHub，后续提代码，提 PR到GitHub上都没有问题。以上内容转载于：https://mp.weixin.qq.com/s/SYR4zvjhAH1mX9fxdp8cbA","categories":[{"name":"实用技巧","slug":"实用技巧","permalink":"https://longlongqin.github.io/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"github","slug":"github","permalink":"https://longlongqin.github.io/tags/github/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"【转】配置方法集合","slug":"配置/【转】配置方法集合","date":"2020-04-13T15:21:08.000Z","updated":"2020-04-19T14:38:29.546Z","comments":true,"path":"archives/6de95ae.html","link":"","permalink":"https://longlongqin.github.io/archives/6de95ae.html","excerpt":"","text":"WSL 使用指南：https://zhuanlan.zhihu.com/p/36482795OpenCV安装配置： http://blog.csdn.net/poem_qianmo/article/details/19809337onedrive无法启动：https://blog.ooolg.com/index.php/20190121/568=568.html","categories":[{"name":"配置","slug":"配置","permalink":"https://longlongqin.github.io/categories/%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"配置","slug":"配置","permalink":"https://longlongqin.github.io/tags/%E9%85%8D%E7%BD%AE/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"C&C++/LearnCpp-chapter6","slug":"C&C++/LearnCpp-chapter6","date":"2020-04-06T05:59:00.000Z","updated":"2020-04-19T14:38:29.547Z","comments":true,"path":"archives/2faa8a4b.html","link":"","permalink":"https://longlongqin.github.io/archives/2faa8a4b.html","excerpt":"LearnCpp chapter6https://www.learncpp.com","text":"LearnCpp chapter6https://www.learncpp.com6.2 用户自定义namespace在2.9 – Naming collisions and an introduction to namespaces中讲解了命名冲突和命名空间的内容。现在再次看一下命名冲突。下面的foo.cpp和goo.cpp两个源文件，中的函数有着不同的功能，但是它们的名字却是一样的：foo.cpp12345//this dosomething() adds the value of its parametersint dosomething(intx, int y)&#123; return x+y;&#125;goo.cpp12345//this dosomething() subtracts the value of its parametersint doSomething(int x, int y)&#123; return x - y;&#125;main.cpp123456789#include &lt;iostream&gt;int dosomething(int x, int y); //forward declaration for dosomethingint main()&#123; std::cout &lt;&lt; dosometing(4, 3) &lt;&lt;'\\n'; //which dosometing will we get? return 0;&#125;此时，编译器会将foo.cpp和goo.cpp都编译在同一个程序中。因为它们俩里面中的函数的名字、参数都一样，而且又在同一个范围中(global scope)，这将会造成“命名冲突”。结果就是，链接器工作时，将会发生错误：goo.cpp:3: multiple definition of &quot;doSomething(int, int)&quot;; foo.cpp:3: first defined here一个较好的解决办法就是，将你的函数放在你自己定义的“命名空间namespace **”中。定义自己的namespaceC++允许我们使用关键字namespace来定义自己的命名空间。由用户自定义的命名空间，叫：user-defined namespaces。而 由C++提供的命名空间，如 global namespace；或者由库提供的，如namespace std；它们就不是user-defined namespaces。命名空间的标识符通常 不大写。下面是对上面命名冲突的函数的改写：foo.cpp12345678namespace foo //定义一个命名空间，名字为：foo&#123; //this dosomething() belongs to namespace foo int dosomething(int x, int y) &#123; return x+y; &#125;&#125;goo.cpp12345678namespace goo //定义一个命名空间，名字为：goo&#123; //this dosomething() belongs namespace goo int dosomething(int x, int y) &#123; return x+y; &#125;&#125;main.cpp1234567int dosomething(int x, int y) //提前对函数dosomething()进行声明 int main()&#123; std::cout &lt;&lt;dosomething(4, 3)&lt;&lt;'\\n'; //which dosomething will we get? return 0;&#125;现在这个两个dosomething()函数都分别属于不同的命名空间了。让我们来运行一下。😂，新问题又出现了：ConsoleApplication1.obj : error LNK2019: unresolved external symbol &quot;int __cdecl doSomething(int,int)&quot; (?doSomething@@YAHHH@Z) referenced in function _main在这个改版中，其实编译器是满意的(因为我们已经进行提前声明)。但是链接器找不到一个在global namespace中的dosomething的定义。这是因为我们虽然为两个dosomething分别声明在不同的命名空间，可惜的是这两个命名空间都不属于 全局命名空间 中。这里有两个解决方案：1.使用scope resolution operator；2.通过using statements*使用范围解析操作符(::)访问名称空间 *【范围解析操作符：scope resolution operator(::)】告诉编译器在特定名称空间中查找标识符的最佳方法是使用scope resolution operator(::)“::”，它告诉编译器：应该在该操作符的 左操作数表示的范围中查找 操作符右边的操作数(也就是要找的标识符)下面是一个例子：对于后面的示例，为了便于阅读，我们将把示例压缩为一个文件解决方案。12345678910111213141516171819202122232425#include &lt;iostream&gt; namespace foo // define a namespace named foo&#123; // This doSomething() belongs to namespace foo int doSomething(int x, int y) &#123; return x + y; &#125;&#125; namespace goo // define a namespace named goo&#123; // This doSomething() belongs to namespace goo int doSomething(int x, int y) &#123; return x - y; &#125;&#125; int main()&#123; std::cout &lt;&lt; foo::doSomething(4, 3) &lt;&lt; '\\n'; // use the doSomething() that exists in namespace foo return 0;&#125;可以注意到main函数中的这个语句：std::cout &lt;&lt; foo::doSomething(4, 3) &lt;&lt; &#39;\\n&#39;;，就是用了“范围解析符 :: ”。该标识符的左操作数：foo，表示命名空间的名字。右操作数表示标识符。所以，foo::dosomething(4,3)，就表示：调用的函数dosomething()是来源于命名空间foo中的。小结解决命名冲突的步骤为：为这些同名的函数，均设置自己的命名空间；在使用这个同名函数的时候，还需要加上“范围解析符 :: ”没有前缀的范围解析符格式：:: 标识符没有前缀的范围解析符，就相当于它的范围是全局命名空间。例子：12345678910111213141516171819202122#include &lt;iostream&gt;void print() //this print lives in the global namespace&#123; std::cout &lt;&lt; \"there\"&lt;&lt;'\\n';&#125;namespace foo&#123; void print() // this print lives in the foo namespace &#123; std::cout &lt;&lt; \"Hello\"; &#125;&#125;int main()&#123; foo::print(); // call foo::print() ::print(); // call print() in global namespace (same as just calling print() in this case) return 0; &#125;允许多个命名空间块：Multiple namespace blocks allowed在多个位置(跨多个文件，或同一文件中的多个位置)声明名称空间块是合法的。命名空间内的所有声明都被认为是命名空间的一部分。例子1（多文件中）：circle.h123456789#if !defined(CIRCLE_H)#define CIRCLE_H namespace basicMath&#123; inline constexpr double pi&#123; 3.14 &#125;;&#125; #endifgrowth.h12345678910#if !defined(GROWTH_H)#define GROWTH_H namespace basicMath&#123; // the constant e is also part of namespace basicMath inline constexpr double e&#123; 2.7 &#125;;&#125; #endifmain.cpp123456789101112#include \"circle.h\" // for basicMath::pi#include \"growth.h\" // for basicMath::e #include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; basicMath::pi &lt;&lt; '\\n'; std::cout &lt;&lt; basicMath::e &lt;&lt; '\\n'; return 0;&#125;结果：3.142.7标准库充就分利用了这个特性，因为每个标准库头文件都将其声明包含在该头文件中包含的 命名空间std 块中。否则，整个标准库必须在一个头文件中定义!【note】：尽管你可以利用这个功能，将你写的函数添加到std namespace中，但是std namespace有一个规则，那就是禁止用户将自己的函数扩展到它的里面。例子2如果你将你的代码分离再多个文件中，你就必须在头文件和原文件中使用命名空间。add.h12345678910#if !defined(ADD_H)#define ADD_H namespace basicMath&#123; // function add() is part of namespace basicMath int add(int x, int y);&#125; #endifadd.cpp12345678910#include \"add.h\" namespace basicMath&#123; // define the function add() int add(int x, int y) &#123; return x + y; &#125;&#125;main.cpp12345678910#include \"add.h\" // for basicMath::add() #include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; basicMath::add(4, 3) &lt;&lt; '\\n'; return 0;&#125;如果在add.cpp中省略了namespace，将会导致链接器找不到basicMath::add。因为这个源文件在缺少namespace时，对add的定义是在全局命名空间中的。如果在add.h中省略namespace，将会导致在“main.cpp”中不能使用basicMath::add因为这个头文件在缺少namespace时，对add的声明是在全局命名空间中的。嵌套命名空间如：123456789101112131415161718#include &lt;iostream&gt; namespace foo&#123; namespace goo // goo is a namespace inside the foo namespace &#123; int add(int x, int y) &#123; return x + y; &#125; &#125;&#125; int main()&#123; std::cout &lt;&lt; foo::goo::add() &lt;&lt; '\\n'; return 0;&#125;所以，当我们要调用函数add的时候，我们使用格式为：foo::goo::add在C++17中，嵌套的命名空间也可以这样声明：123456789101112131415#include &lt;iostream&gt; namespace foo::goo // goo is a namespace inside the foo namespace (C++17 style)&#123; int add(int x, int y) &#123; return x + y; &#125;&#125; int main()&#123; std::cout &lt;&lt; foo::goo::add() &lt;&lt; '\\n'; return 0;&#125;给命名空间设置别名：namespace aliases在使用嵌套的命名空间的函数或变量时，我们需要将命名空间层级都全部写完整，这样会很麻烦，如果我们给这个嵌套的命名空间起一个别名就省事多了：123456789101112131415161718192021#include &lt;iostream&gt; namespace foo&#123; namespace goo &#123; int add(int x, int y) &#123; return x + y; &#125; &#125;&#125; int main()&#123; namespace boo = foo::goo; // boo now refers to foo::goo std::cout &lt;&lt; boo::add() &lt;&lt; '\\n'; // This is really foo::goo::add() return 0;&#125; // The boo alias ends here6.3 局部变量在 2.4 – Introduction to local scope,介绍了局部变量，它是在函数中的形参。局部变量的块范围标识符的范围决定了标识符在源码中可获得的区域。范围是一个“编译时间”的属性。局部变量的 块范围(block scope)，中的范围就是：从他们定义开始，到这个块结束 的这个范围。如：1234567#include &lt;iostream&gt;&#123; int i &#123;5&#125;; //i enters scope here double d &#123;4.0&#125;; // d enters scope here return 0;&#125;// i and d go out of scope here虽然函数的形参没有被定义在函数体的内部，但是对于典型函数而言，形参可以被看成，是属于函数体块的范围内。如下：1234567int max(int x, int y) //x and y enter scope here&#123; //将x、y中较大者分配给max int max&#123;(x&gt;y) ? x : y&#125;; //max enters scope here return max;&#125;// x, y and max leave scope here同一范围内的变量名不相同下面的函数在编译时会出错，因为该范围内的变量名相同了：1234void someFunction(int x)&#123; int x&#123;&#125;; //编译时会出错，因为这里的x和形参x之间命名冲突了&#125;局部变量的自动存储期变量的存储期(storage duration),也叫持续时长(duration)决定了什么时间以及如何创造和销毁它。通常，变量的存储器直接决定了它的“生命周期(lifetime)”例如，局部变量的存储器，意味着它在被定义时就被创建，然后在他被定义的范围块的尾部被销毁：1234567int main()&#123; int i &#123;5&#125;; //i created and initialized here double d &#123;4.0&#125;; //d created and initialized here return 0;&#125; // i and d are destoryed here由于这个原因，局部变量 有时也被称为：自动变量嵌套快中的局部变量局部变量可以被定义在嵌套块中，这和在函数体块中的局部变量工作流程相同：1234567891011int main() //外部块&#123; int x&#123;5&#125;; //x enters scope and is created here &#123; //嵌套块 int y &#123;7&#125;; //y enters scope and is created here &#125; // y goes out of scope and is destroyed here //此时，y就不能再被用了，因为它不属于现在所在的范围 return 0;&#125; // x goes out of scope and is destoryed here注意：变量x的范围是整个mian函数块中，自然，在嵌套块中，变量x也是有效的，即也可以访问它。局部变量的无连接标识符的另一个属性就是：“连接(linkage)”。一个标识符的linkage决定了该标识符的其他声明是否引用的是相同的对象。局部变量没有关联性，也就是说对一个标识符的每一个声明都代表不同的对象如：12345678int main()&#123; int x &#123;2&#125;; // local variable, no linkage &#123; int x &#123;3&#125;; //这个标识符x与上面的标识符x，表示的是不同对象(尽管他们名字相同) //但是现在嵌套外部的变量x被隐藏起来了(在6.5节会讲到变量隐藏) &#125;&#125;变量定义的范围如果一个变量仅在嵌套块中使用，那它就应该旨在嵌套块中被定义：1234567891011121314#include &lt;iostream&gt;int main()&#123; //don't define y here &#123; //y只在这个块中被使用，所以在这里定义它 int y&#123;5&#125;; std::cout &lt;&lt;y&lt;&lt;'\\n'; &#125; return 0;&#125;所以，我们尽量把变量定义在，使用它的范围内部。6.4 全局变量全局变量的声明通常，全局变量声明是在：头文件的下面，在其他代码的上面。123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;//在函数外面声明的变量是全局变量int g_x &#123;&#125;; // global variable g_xvoid doSomething()&#123; // global variables can be seen and used everywhere in the file g_x = 3; std::cout &lt;&lt; g_x &lt;&lt; '\\n';&#125;int main()&#123; doSomething(); std::cout &lt;&lt; g_x &lt;&lt; '\\n'; // global variables can be seen and used everywhere in the file g_x = 5; std::cout &lt;&lt; g_x &lt;&lt; '\\n'; return 0;&#125;// g_x goes out of scope here/********结果*****/335按照惯例， 在全局变量名字加上前缀“g”或者“g_”，来便于是显示的说明它是 全局变量全局变量的file scope&amp;静态持续时间file scope也叫：全局范围(global scope)或者全局命名空间范围(global namespace scope)因为全局变量是在函数外部定义的，所以也被视为“全局命名空间(global namespace)”的一部分。所以，才有global namespace scope这个叫法。也就是说，它们从被定义开始，到所在文件的结束期间 都是有效的。全局变量在程序开始被创建，在程序结束时被销毁。这成为“静态持续时间(static duration)”有着‘static duration’的变量，也被称为：“静态变量(static variable)”局部变量默认是不被初始化的，全局变量默认是被初始化为0的全局变量的初始化123int g_x; //没有显示的初始化变量(所以默认初始化为0)int g_y&#123;&#125;; //初始化为0int g_z&#123;3&#125;; //显示的初始化为3常量局部变量与局部变量一样，全局变量也可以是常量。只要是常量，那它就必须被初始化。1234567891011121314151617181920212223242526#include &lt;iostream&gt;const int g_x; //error:常量型的变量必须要被初始化constexpr int g_w; //error:常量型的变量必须要被初始化（constexpr，表示它是 编译时常量）const int g_y &#123;1&#125;; //正确，初始化了constexpr int g_z &#123;2&#125;; //正确，初始化了void dosomething()&#123; //全局变量在这个文件中的每一个地方都是有效的(可以被看见和使用) std::cout &lt;&lt; g_y &lt;&lt; '\\n'; std::cout &lt;&lt; g_z &lt;&lt; '\\n'; &#125;int main()&#123; dosomething(); //全局变量在这个文件中的每一个地方都是有效的(可以被看见和使用) std::cout &lt;&lt; g_y &lt;&lt; '\\n'; std::cout &lt;&lt; g_z &lt;&lt; '\\n'; return 0;&#125;// g_y and g_z goes out of scope here小结123456789101112// Non-constant global variables(非常量的全局变量)int g_x; // defines non-initialized global variable (zero initialized by default)int g_x &#123;&#125;; // defines explicitly zero-initialized global variableint g_x &#123; 1 &#125;; // defines explicitly initialized global variable // Const global variablesconst int g_y; // error: const variables must be initializedconst int g_y &#123; 2 &#125;; // defines initialized global constant // Constexpr global variablesconstexpr int g_y; // error: constexpr variables must be initializedconstexpr int g_y &#123; 3 &#125;; // defines initialized global const6.5 变量被隐藏局部变量被隐藏123456789101112131415161718192021#include &lt;iostream&gt;int main()&#123;// outer block int apples &#123; 5 &#125;; // 嵌套外部的apples &#123;// nested block std::cout &lt;&lt;apples&lt;&lt;'\\n'; //这里的apples是嵌套外部的 int apples &#123;0&#125;; //在嵌套内部定义变量apples //现在的apples指的是嵌套内部 的apples.嵌套外部的apples现在被隐藏起来了 apples = 10; //现在被赋值的apples指的是嵌套内部的apples std::cout &lt;&lt; apples &lt;&lt;'\\n'' &#125; //嵌套块内部的apples被销毁 std::cout &lt;&lt;apples&lt;&lt;'\\n'; //这个apples指的是嵌套外部的apples(因为现在，嵌套内部的apples已经被销毁) return 0；&#125; //嵌套外部的apples被销毁运行结果：1235105全局变量被隐藏就像局部变量中的，嵌套块中的变量可以将嵌套外部的同名变量以藏起来 一样。局部变量可以将全局中的同名变量隐藏起来:123456789101112131415161718#include &lt;iostream&gt;int a &#123;5&#125;; //全局变量 void foo() &#123; std::cout &lt;&lt;\"global variable a：\"&lt;&lt;a&lt;&lt;'\\n';//此时，全局变量a还没有被隐藏。即，这里的变量a，指的是全局变量 &#125;int main()&#123; int a &#123;7&#125;; //此时，全局变量a就被这里的局部变量a 隐藏起来了 ++a; //局部变量a加1，而不是全局变量 std::cout &lt;&lt; \"local variable a: \" &lt;&lt; a &lt;&lt; '\\n'; foo(); return 0;&#125; // 局部变量a被销毁运行结果:12local variable a: 8global variable a: 5然而啊，全局变量是属于全局的命名空间。所以，我们可以使用 范围解析符(::)（不带前缀的，即默认是在全局命名空间）来告诉编译器我们使用的是全局变量：123456789101112131415#include &lt;iostream&gt;int a &#123;5&#125;; //全局变量int main()&#123; int a &#123;7&#125;; //此时，将全局变量a隐藏起来了 ++a； //局部变量a加1，而不是全局变量 --(::a); //此时是对于全局变量，减一 std::cout &lt;&lt; \"local variable a: \" &lt;&lt; a &lt;&lt; '\\n'; std::cout &lt;&lt; \"global variable a: \" &lt;&lt; ::a &lt;&lt; '\\n'; return 0; &#125;//local a 被销毁运行结果：12local variable a: 8global variable a: 4避免变量被隐藏通常应该避免局部变量的隐藏，因为它会在使用或修改错误的变量时导致无意的错误。一些编译器会在变量被隐藏时发出警告。6.6 内部连接在 6.3 – Local variables中，讲到：“一个标识符的连接决定了该名称的其他声明是否引用同一对象”和“局部变量的无连接”全局变量和函数标识符有：内部链接(internal linkage)和外部链接(external linkage)。本节主要讲内部链接。一个标识若是内部连接，那它就只能在这一个文件中有效(可以被看到和使用)；而不可以在其他文件中看到和使用【也就是说，它没有暴露给链接器】。也就是说，如果有两个文件，它们分别含有一个相同名字的标识符(而且这这个同名的标识符是 内部连接)，那么这个同名的标识符就被看待成相互独立的。全局变量内部连接全局变量是内部链接时，也被称为：内部变量(internal variables)。让 非常量的全局变量 成为内部变量，需要使用关键字static；（因为非常量的全局变量默认是 外部链接 的）而 常量的全局变量 默认的就是 内部变量。如：123456789static int g_x; //非常量的全局变量默认是 外部链接。但是加上关键字static后，就变成内部连接const int g_y &#123;1&#125;; //const 的全局变量默认是 内部连接constexpr int g_z &#123;2&#125;; //constexpr 的全局变量默认是 内部连接int main()&#123; return 0;&#125;const和constexpr的全局变量默认是 内部连接(所以，不需要加 关键字static)一个定义规则和内部连接还记得在 2.7 – Forward declarations and definitions,中讲到一个定义的规则：在文件或程序中，*一个*对象或者函数只能有一个定义。然而，这一个我们却在一个程序中对一个对象或函数进行了“多次定义”，这是否违背了上面的规则呢？答：不违背。因为本节中我们将它们设置为内部连接，此时虽然它们的名字相同，但是相互独立（即，它们相当于不同的对象或函数，只是名字相同。就好像两个同名的人一样）。所以不违背上面的定义规则。函数内部连接因为“连接(linkage)”是标识符的属性(标识符不仅仅只代表变量(☄⊙ω⊙)☄，因为函数的名字也是标识符)。所以，函数标识符也具有 内部连接 的属性。如：add.cpp123456//这个函数前使用关键字static，表示它现在只在这个文件中有效//如果，企图通过函数提前声明从，从另一个文件访问它，将失败static int add (int x, int y)&#123; return x+y;&#125;main.cpp123456789#include &lt;iostream&gt;int add (int x, int y); //对函数add，提前声明int main()&#123; std::cout &lt;&lt; add(3, 4) &lt;&lt;'\\n'; return 0;&#125;上面的程序，在链接器连接时，将会出错。因为函数add在main.cpp中不可访问小结123456789// Internal global variables definitions:static int g_x; // defines non-initialized internal global variable (zero initialized by default)static int g_x&#123; 1 &#125;; // defines initialized internal global variable const int g_y &#123; 2 &#125;; // defines initialized internal global const variableconstexpr int g_y &#123; 3 &#125;; // defines initialized internal global constexpr variable // Internal function definitions:static int foo() &#123;&#125;; // defines internal function6.7 外部连接一个标识符具有 外部连接(external linkage)的属性，那么它就可以在整个程序中(不仅仅只在一个文件中)被看见和访问。（在其他文件中，可以通过提前声明来访问它）所以，具有外部连接属性的表示符，才是真正的“全局”变量函数默认是外部链接在 2.8 – Programs with multiple code files中，讲到我们可以从其他文件中调用函数，这是因为这个函数默认是“外部链接”的。在从其他文件中调用函数时，我们必须要对这个函数进行 提前声明(forward declaration)因为，提前声明可以告诉编译器这个函数的存在；而链接器则是将函数调用连接到实际的函数定义如：a.cpp123456#include &lt;iostream&gt;void sayHi() //这个函数默认是 外部连接，所以他可以在整个程序(包括其他文件)中被看见&#123; std::cout &lt;&lt; \"hi\";&#125;main.cpp12345678void sayHi(); //对函数进行提前声明，使得该函数在这个文件中可以被访问int main()&#123; sayHi(); //这里是从其他文件中调用此函数，链接器将把这个调用连接到函数定义 return 0;&#125;运行结果:1hi全局变量外部连接全局变量具有外部连接属性时，也称为：外部变量(external variables)非常量的全局变量默认是 外部变量；常量的全局变量 要想成为外部变量，需要使用关键字extern如：123456789int g_x &#123;2&#125;; //非常量的全局变量默认是 外部变量；extern const int g_y &#123;3&#125;;//const 的全局变量可以被定义成 外部变量，需要加关键字externextern constexpr int g_z &#123;3&#125;; //constexpr 的全局变量可以被定义成 外部变量,需要加关键字externint main()&#123; return 0;&#125;默认情况下，非const全局变量是外部变量(如果使用，extern关键字将被忽略)。extern提前声明变量要实际使用在另一个文件中定义的外部全局变量，我们需要在使用它的文件中对全局变量进行提前声明。对于变量，在创建一个提前声明时，也是需要使用关键字extern的(没有初始化值)：如：a.cpp123//全局变量的定义int g_x &#123;2&#125;; //非常量的全局变量默认是 外部链接extern const int g_y &#123;3&#125;; //常量的全局变量是内部连接，但使用关键字extern后，变为 外部链接main.cpp12345678910#include &lt;iostream&gt;extern int g_x; //对变量g_x的提前声明。它的定义在其他文件中extern const int g_y; //对常量变量g_y的提前声明。它的定义在其他文件中int main()&#123; std&lt;&lt; g_x; //结果为2 return 0;&#125;函数提前声明不用extern函数的提前声明不需要关键字extern编译器能搞告诉你这个函数在哪定义，也可以根据是否提供函数体来进行提前声明。变量的提前声明必须要用关键字extern，来帮助区分 变量定义 和 变量提前声明(它们看起来是一样的):如：1234567//非常量int g_x; //变量的定义(如果需要，可进行初始化)extern int g_x; //变量的提前声明(提前声明 不带初始化)//常量extern const int g_y &#123;1&#125;;//定义变量(常量的定义必须要进行初始化)extern const int g_y; //提前声明(提前声明 不带初始化)file范围VS.global范围看下面的例子：global.cpp12int g_x &#123;2&#125;; //（非常量的变量）默认是外部连接//g_x goes out scope heremain.cpp12345678extern int g_x; //对变量g_x的提前声明。可以在此文件中使用g_xint main()&#123; std::cout &lt;&lt; g_x; //应该输出 2 return 0;&#125;//g_x的提前声明 goes out of scope here变量g_x的文件范围(file scope)是在global.cpp中。它在该文件中定义之后，就可以被使用。但是它不能直接在其他文件中使用。如果要在其他文件中使用g_x，我们要在其他文件中对它进行提前声明(记得要使用关键字extern)也就是说，“文件范围”通常用于具有内部连接属性的全局变量；“全局范围”更多用于具有外部连接属性的全局变量(因为，它被提前声明之后，就可以在其他地方使用)全局变量初始化顺序问题全局变量的初始化是程序启动的一部分，在执行mian函数之前，这个过程分为两部分：第一部分，称为 static initialization静态初始化。在静态初始化中，带有constexpr初始化器(包括字面值(literal))的全局变量被初始化为给定的值[因为，constexpr和字面值常量定义时自带有初始值]；eg,const a {1};那么a就被初始化为1constexpr a{1};那么a就被初始化为1定义时没有给定初始值的全局变量(也使常量的全局变量，但没有显示初始化为0)被默认初始化为0。const a {};那么a就默认被初始化为0constexpr a{};那么a就默认被初始化为0第二部分，称为 dynamic initialization动态初始化。这部分，比较复杂，它的要点是：初始化那些“不带有constexpr初始化器的全局变量”(即，就是 非常量的全局变量)。例如：123456int init()&#123; return 5;&#125;int g_something &#123;init()&#125;; //非常量的变量初始化在单位件的程序中，全局变量按照定义的顺序被初始化这个规则有几个例外。考虑到这一点，您需要小心不要让变量依赖于其他变量的初始化值，这些变量要到稍后才会初始化。例如:12345678910111213141516171819202122232425#include &lt;iostream&gt; int initx(); // forward declarationint inity(); // forward declaration int g_x&#123; initx() &#125;; // g_x is initialized firstint g_y&#123; inity() &#125;; int initx()&#123; return g_y; // g_y isn't initialized when this is called&#125; int inity()&#123; return 5;&#125; int main()&#123; std::cout &lt;&lt; g_x &lt;&lt; ' ' &lt;&lt; g_y &lt;&lt; '\\n';&#125;/******结果*******/0 5再多文件程序中，不同文件之间的初始化顺序是没有规定的。例如，有两个文件a.cpp和b.cpp，它们两个文件谁先被初始化是不确定的。所以，如果在a.cpp中有一个变量的值是依赖于b.cpp。那么就有50%的可能这些变量还没有被初始化。注意：C++中，全局变量的动态初始化会造成很多问题。所以避免使用。小结：123456789// External global variable definitions:int g_x; // defines non-initialized external global variable (zero initialized by default)extern const int g_x&#123; 1 &#125;; // defines initialized const external global variableextern constexpr int g_x&#123; 2 &#125;; // defines initialized constexpr external global variable // Forward declarationsextern int g_y; // forward declaration for non-constant global variableextern const int g_y; // forward declaration for const global variableextern constexpr int g_y; // not allowed: constexpr variables can't be forward declared6.8 全局常量&amp;内联变量Global constants and inline variables一些符号常量需(如，阿伏伽德罗常数，重力系数…)要在整个程序中使用。比较好的方法是在一个地方对他们进行声明，而不是在每个需要它们的文件中重新定义这些常量。全局常量作为内部变量在c++中有多种方法可以促进这一点。在c++ 17之前，以下可能是最简单和最常见的方法:首先，创建一个头文件来存放这些常量；在这个头文件中，定义一个命名空间（在 6.2 – User-defined namespaces讲解过命名空间）；然后，将常量加入这个命名空间中（请确保它们的类型是constexpr）；在你要用这些变量的文件中，加上这个头文件#include &quot;xxx&quot;eg:constants.h12345678910111213#ifndef CONSTANTS_H#define CONSTANTS_H//定义你自己的命名空间(用来存储常量)namespace constants&#123; //默认情况下，常量有 内部连接 constexpr double pi &#123;3.14159&#125;; constexpr double my_gravity &#123;9.2&#125;; //....常量&#125;#endifmain.cpp1234567891011#include \"constants.h\" //：在这个文件中包含每个常量的副本int main()&#123; std::cout &lt;&lt; \"enter a radius: \"; int radius&#123;&#125;; //radius：半径 std::cin &gt;&gt;radius; std::cout &lt;&lt; \"the circumference is: \" &lt;&lt;2* radius* constants::pi; return 0;&#125;注意：在main.cpp文件中，要想访问constants中的常量，我们需要使用 范围解析符(::)。a::b 范围解析操作符的 左操作数a,表示命名空间名称；右操作符b表示命名空间a中的变量或者函数名字。::b 这种形式表示 其命名空间是全局命名空间。全局常量作为外部变量当作为内部变量时，可能会出现以下问题：虽然这很简单(对于较小的程序也很好)，但是每当constants.h被包含到不同的代码文件中时，每个变量都会被复制到包含代码文件中。因此，如果将constants.h包含到20个不同的代码文件中，那么每个变量都会重复20次。头文件保护不会阻止这种情况的发生，因为它们只会阻止头文件不止一次被包含到一个包含文件中，而不会阻止头文件一次被包含到多个不同的代码文件中。这带来了两个挑战:头文件保护符(header guards)只能确保在单个文件中包含的头文件只包含一次；当修改一个常量值时，就可能需要重新编译那些包含这个常量的文件，这可能导致大型项目的重建时间很长。如果常量的size很大，并且不能进行优化。这将花费很多内存。一个解决上面的办法就是，将这些常量设为“外部变量(external variables)”。因此，我们可以将变量只初始化一次就可以在整个程序中使用。constants.cpp123456namespace constants&#123; //actual global variables extern const double pi &#123;3.14159&#125;; extern const my_gravity &#123;9.2&#125;;&#125;在constants.cpp文件中定义这些常量，来确保它们只被定义一次；constants.h123456789101112#ifndef CONSTANTS_H#define CONSTANTS_H namespace constants&#123; // since the actual variables are inside a namespace, the forward declarations need to be inside a namespace as well extern const double pi; extern const double avogadro; extern const double my_gravity;&#125; #endif需要在头文件constants.h中对这些常量进行 提前声明main.cpp使用的方法不变12345678910#include \"constants.h\" // include all the forward declarations int main()&#123; std::cout &lt;&lt; \"Enter a radius: \"; int radius&#123;&#125;; std::cin &gt;&gt; radius; std::cout &lt;&lt; \"The circumference is: \" &lt;&lt; 2 * radius * constants::pi;&#125;因为全局符号常量在命名空间中(为了避免与全局命名空间中的标识符发生 命名冲突)，所以，就不需要在它名字中使用g_前缀现在，这些符号常量只用在constants.cpp中实例化一次(而不是每次constants.h被#include中都被实例化一次)，所以，对constants.cpp所做的任何修改都只需要重新编译constants.cpp即可。然而，这种方法也有几个缺点。首先，这些常量现在只在实际定义它们的文件(constants.cpp)中被认为是 编译时常量，而不是在其他地方使用它们。这意味着在constants.cpp之外的地方，它们不能在任何需要编译时常量的地方使用。其次，编译器可能无法对它们进行尽可能多的优化。全局常量作为内联变量在C++17中，有一个新概念叫做：inline variable(内联变量)inline意为：允许多个定义。所以，一个内联变量就可以在多个文件中被多次定义。(这并不违背 单定义规则)内联全局变量 默认是 外部连接内联变量有两个重要的限制，必须遵守：内联变量的所有定义必须相同（否则，将产生未定义的行为）；内敛变量的定义(不是提前声明)必须出现在每一个使用这些变量的文件中。编译器将会把内联变量的所有定义合并为一个变量的定义。这就允许我们在头文件中定义变量，并将它们当作a.cpp文件中只有一个定义。这些变量在它们被包含的文件中，依然保持这 constexpr 的性质这样，我们就可以在头文件中定义全局变量，而不用担心重复变量:constants.h123456789101112#ifndef CONSTANTS_H#define CONSTANTS_H // define your own namespace to hold constantsnamespace constants&#123; inline constexpr double pi &#123; 3.14159 &#125;; // note: now inline constexpr inline constexpr double avogadro &#123; 6.0221413e23 &#125;; inline constexpr double my_gravity &#123; 9.2 &#125;; // m/s^2 -- gravity is light on this planet // ... other related constants&#125;#endifmain.cpp12345678910#include \"constants.h\" int main()&#123; std::cout &lt;&lt; \"Enter a radius: \"; int radius&#123;&#125;; std::cin &gt;&gt; radius; std::cout &lt;&lt; \"The circumference is: \" &lt;&lt; 2 * radius * constants::pi;&#125;我们可以在尽可能多的代码文件中包含constants.h，但是这些变量只会被实例化一次，并在所有代码文件中共享。如果你需要全局常量，并且你的编译器支持C++17，那建议最好使用 内联变量6.9 非常量的全局变量evil最大的问题就是：当你使用全局变量(not-const)时，它可能在任何地方就被修改，但是你却不能轻松的直到在哪被改的。1234567891011121314151617181920int g_mode; //声明全局变量(将默认被初始化为0)void dosomething()&#123; g_mode = 2; //这里修改全局变量g_mode为2&#125;int main()&#123; g_mode =1; //note:这将全局g_mode变量设置为1。而不是声明一个本地g_mode变量! dosomething(); //程序猿希望这里输出的g_mode的值是1，但是实际上它的值是2 if(g_mode == 1) std::cout &lt;&lt;\"no threat detected.\\n\"; else std::cout &lt;&lt; \"lanunching nuclear missiles...\\n\"; return 0;&#125;局部变量要安全得多，因为其他函数不能直接影响它们。保护你的全局变量如果你非要使用全局变量：那我们可以对变量名使用前缀”g_”或“g”，来帮助我们识别它是全局变量。最好也将其放在你自己创建的命名空间，从而避免一些命名冲突。6.10 静态局部变量术语static是c++语言中最容易混淆的术语之一，这在很大程度上是因为静态在不同的上下文中有不同的含义。在之前的课程中，我们讨论了全局变量具有静态持续时间，这意味着它们在程序启动时创建，在程序结束时销毁。我们还讨论了static关键字如何提供全局标识符内部链接，这意味着标识符只能在定义它的文件中使用。我们将探讨应用于局部变量时静态关键字的用法。在 2.4 – Introduction to local scope, 您了解到，默认情况下 局部变量具有 自动持续时间，这意味着它们是在定义时创建的，并在块退出时销毁。但关键字static，可以将自动持续时间(attomatic duration)转变成 静态持续时间(static duration) 。从而，静态变量即使已经超出它所在的范围时，他依然没有被销毁。这意味着变量现在在程序开始时创建，并在程序结束时销毁(就像全局变量一样)。例如：默认是 automatic duration12345678910111213141516171819202122#include &lt;iostream&gt; void incrementAndPrint()&#123; int value&#123; 1 &#125;; // 默认是 automatic duration ++value; std::cout &lt;&lt; value &lt;&lt; '\\n';&#125; // value is destroyed here int main()&#123; incrementAndPrint(); incrementAndPrint(); incrementAndPrint(); return 0;&#125;/********结果**********/222每次调用函数incrementAndPrint()时，都将穿件一个叫value的变量，它被初始化为1现在使用static关键字，将默认的 atuomatic duration 转变为 static duration12345678910111213141516171819202122#include &lt;iostream&gt; void incrementAndPrint()&#123; static int s_value&#123; 1 &#125;; // 由于使用关键字 static,所以现在是 static duration。 所以这个变量将只会被初始化一次（不会像上面那个例子，每次调用都会被除初始化） ++s_value; std::cout &lt;&lt; s_value &lt;&lt; '\\n';&#125; // s_value is not destroyed here, but becomes inaccessible because it goes out of scope int main()&#123; incrementAndPrint(); incrementAndPrint(); incrementAndPrint(); return 0;&#125;/****结果****/234在这个程序中，因为s_value被声明为静态的，所以s_value只创建一次(在程序启动时)(并且初始化为零)。然后在第一次遇到变量定义时使用我们提供的初始化值(1)初始化变量(但在后续调用时不会重新初始化)。就像我们使用“g_” 作为全局变量的前缀一样，使用 “ s_”作为静态(静态持续时间)局部变量的前缀也是很常见的。静态变量提供了全局变量的一些好处(它们直到程序结束时才被销毁)，同时，限制为它们只在它自己的块中才能被看见，这使得即使您经常更改它们的值，这也使它们可以安全使用。全局、局部变量使用static全局变量使用关键字static：这会使得全局变量变为 internal linkage(内部连接)，即，使得该变量不能再其他文件中使用。局部变量使用关键字statci：这使得局部变量变为 static duration(静态持续时间),即，使得该变量将 只被创建一次，而且直到程序结束才会被销毁。6.11 总结scope/duration/linkage总结scope标识符的范围决定了它能够被访问的区间：具有 block scope(块范围) / local scope(局部范围) 的变量 只能在它们被声明的块中(包括嵌套块)被访问，这些有：局部变量；函数的形参；在块中声明的用户定义类型定义（如，枚举(enum)、类(class)）;具有 global scope(全局范围) / file scope(文件范围)的变量 可以再文件中的任何地方被访问，这些有：全局变量；函数；在命 名空间内 或 全局范围 内声明的用户定义类型定义(如枚举(enum)、类(class))总结duration变量的持续时间决定了它们何时被创建与销毁：具有 automatic duration(自动持续时间)的变量 在定义时被创建，在离开它所在的块时被销毁，这些有：局部变量；函数的形参；具有 static duration(静态持续时间)的变量 在程序开始时被创建， 在程序结束时被销毁。这些有：全局变量；静态局部变量；具有 dynamic duration(动态持续时间)的变量 由程序员请求创建和销毁。这些有：动态分配的变量；总结linkage标识符的 linkage(连接) 决定了 一个标识符的多个实例是否引用同一个标识符。标识符 没有 连接 时，意味着这个标识符仅指其自身。这些有：局部变量；在块中声明的用户定义类型定义(如枚举和类)；具有 intrnal linkage(内部连接) 的标识符 只能在它所声明的文件中 被访问。这些有：静态全局变量(static global variables) [初始化 或 未初始化 ]；静态函数（static functions）;在未命名的命名空间中声明的函数；在未命名的命名空间中声明的用户定义类型定义(如枚举和类)；具有 external linkage(外部连接) 的标识符 可以在 在声明的文件内的任何地方访问，也可以其他文件(通过提前声明)进行访问。这包括:函数；非常量的全局变量(初始化 或 未初始化)；外部常量全局变量；内联常量全局变量；在 命名空间内 或 全局范围内声明的用户定义类型定义(如枚举和类)；NOTE:默认情况下， 函数是 外部连接；它可通过使用关键字static变成 内部连接。变量的 scope/duratio /linkageTypeExampleScopeDurationLinkageNotesLocal variableint x;BlockAutomaticNoneStatic local variablestatic int s_x;BlockStaticNoneDynamic variableint *x { new int };BlockDynamicNoneFunction parametervoid foo(int x)BlockAutomaticNoneExternal non-constant global variableint g_x;FileStaticExternalInitialized or uninitializedInternal non-constant global variablestatic int g_x;FileStaticInternalInitialized or uninitializedInternal constant global variableconstexpr int g_x { 1 };FileStaticInternalConst or constexpr, Must be initializedExternal constant global variableextern constexpr int g_x { 1 };FileStaticExternalConst or constexpr, Must be initializedInline constant global variableinline constexpr int g_x { 1 };FileStaticExternalConst or constexpr, Must be initialized总结提前声明你可以在其他文件中对一个 函数/变量 进行提前声明：TypeExampleNotesFunction forward declarationvoid foo(int x);Prototype only, no function bodyNon-constant global variable forward declarationextern int g_x;Must be uninitializedConst global variable forward declarationextern const int g_x;Must be uninitializedConstexpr global variable forward declarationextern constexpr int g_x;Not allowed, constexpr cannot be forward declared什么是存储类说明符?当关键字static 、extern用作标识符声明的一部分时,它们就被称为：storage class specifier（存储类说明符）。它们设置标识符的存储的 duration 和 linkageC++支持4中存储类说明符：SpecifierMeaningNoteexternstatic (or thread_local) storage duration and external linkagestaticstatic (or thread_local) storage duration and internal linkagethread_localthread storage durationIntroduced in C++11mutableobject allowed to be modified even if containing class is constautoautomatic storage durationDeprecated in C++11registerautomatic storage duration and hint to the compiler to place in a registerDeprecated in C++17术语 storage class specifier 通常只在正式文档中使用。6.12 using 语句如果你经常使用标准库，那么在使用标准库中的所有内容之前输入std::会变得重复。C++提供了一种可选择的办法，叫做：using statementsusing的声明一种简化的方法是使用using声明语句：123456789#include &lt;iostream&gt; int main()&#123; using std::cout; // this using declaration tells the compiler that cout should resolve to std::cout cout &lt;&lt; \"Hello world!\"; // so no std:: prefix is needed here! return 0;&#125; // the using declaration expires hereusing 的声明：using std::cout告诉编译器我们将要使用 命名空间std 中的cout。所以当编译器看到cout时，它会假设我们指的是std::cout。如果std::cout与cout的其他一些使用之间存在命名冲突，则首选std::cout。上面的例子，看起来似乎没有简化多少。但如果我们要多次使用cout时，使用 using statements就可以简化很多。注意，如果你多次使用std::cout和std::cin的话，你需要对他们两个分别使用using statementsusing 指令另一种方法就是使用：using directive语句。如：12345678#include &lt;iostream&gt;int main()&#123; using namespace std; //这个using指令 告诉编译器我们可以使用 命名空间std 中的任何东西 cout &lt;&lt; \"hello world!\"; // 所以，前缀 std:: 就可以省略 return 0;&#125;这个using 指令 ：using namespace std告诉编译器我们想使用 命名空间std 中的任何东西。所以当编译器发现了一个名字它不认识时，它就会检查 命名空间std。结果就是，当编译器遇到cout(编译器不认识cout)，编译器就会查看 命名空间std 然后找到cout。如果std::cout与cout的其他一些使用之间存在命名冲突，编译器将把它标记为错误(而不是选择其中之一)。下面来看一下 using 指令 造成的歧义：eg1：123456789101112131415161718192021#include &lt;iostream&gt; namespace a&#123; int x&#123; 10 &#125;;&#125; namespace b&#123; int x&#123; 20 &#125;;&#125; int main()&#123; using namespace a; using namespace b; std::cout &lt;&lt; x &lt;&lt; '\\n'; return 0;&#125;上面例子中，编译器无法在mian函数中决定使用a::x还是b::x。然后就会出现“不明确的符号”错误。要想解决这个冲突，我们可以加上前缀使用。即显示标明使用的是哪一个命名空间中的x。eg2：1234567891011121314#include &lt;iostream&gt; // imports the declaration of std::cout int cout() // declares our own \"cout\" function&#123; return 5;&#125; int main()&#123; using namespace std; // makes std::cout accessible as \"cout\" cout &lt;&lt; \"Hello, world!\"; // uh oh! Which cout do we want here? The one in the std namespace or the one we defined above? return 0;&#125;eg2中，编译器无法判断我们使用的cout是引用的 std::cout还是 cout函数。并出现“不明确的符号”错误。解决方法：使用using declaration 来替代 using directive：12using std::cout; //告诉编译器， cout 指的是 std::coutcout &lt;&lt; \"Hello, world!\"; //所以cout表示的是 std::cout显示的使用前缀：1std::cout &lt;&lt; \"Hello, world!\"; //告诉编译器使用的是std::cout取消or替换 using语句一旦，using语句被声明，那就没有办法在声明它的范围内使用另一个using语句替换或取消它。1234567int main()&#123; using namespace Foo; //此时无法使用一个其他的 using语句来 取消或替换 “using namespace Foo;” return 0;&#125;//using namespace Foo ends here对应它的最好办法就是，显示的限制 using语句 的范围：12345678int main()&#123; &#123; using namespace Foo; //在这里调用Foo::中的东西 &#125; //using namespace Foo 过期 return 0;&#125;当然，可以显式地使用范围解析操作符(::)来避免所有这些麻烦。6.13 typedef与类型别名**优先使用类型别名，而不是typedefs，并大量使用它们来记录类型的含义**typedef允许程序猿去创建一个数据类型的别名。然后可以使用别名来替换这个类型真正的名字。Typedef的字面意思是“类型定义”我们可以使用关键字typedef，来进行 类型定义：typedef a b ：其中a表示类型的名字，b表示类型被替换成的别名.12345typedef double distance_t; //定义distance_t 作为 double类型 的别名//下面两个语句是等价的:double howFar;distance_t howFar;按照惯例，typedef名称是使用“_t”后缀声明的。这有助于指示标识符代表的是类型，而不是变量或函数，还有助于防止与其他标识符的命名冲突。类型别名为了帮助解决这些问题，我们引入了一种改进的typedefs语法，它模仿了变量的声明方式。这种语法称为 type alias(类型别名)。123typedef double distance_t; //定义distance_t 作为 double类型的 别名using distance_t = double; //定义distance_t 作为 double类型的 别名【推荐】上面两个语句在功能上等价。【NOTE】虽然使用了关键字using（在这里是重载的意义），但这和 与命名空间相关的 using语句 没有关系。为易读性使用类型别名1int GradeTest();我们可以看到返回值是一个整数，但是这个整数是什么意思呢?一个字母等级?遗漏了多少问题?学生的身份证号码?一个错误代码?谁知道!Int不能告诉我们任何东西。写成下面形式，便于理解：12using testScore_t = int;testScore_t GradeTest();使用类型别名编写与平台无关的代码比如，在一些平台中，int类型占2个字节；但在其他平台中，可能占4个字节。所以，在4字节平台中写的代码在2字节平台中可能会出错。所以，使用类型别名可以帮助我们避免出错，也更清楚地说明了对变量大小的假设。123456789#ifdef INT_2_BYTESusing int8_t = char;using int16_t = int;using int32_t = long;#elseusing int8_t = char;using int16_t = short;using int32_t = int;#endif如果，在一个机器中，整数是2个字节。那么INT_2_BYTES将被定义。此时，就使用的是上部定义的这几个。如果，在一个机器中，整数是4个字节。那么INT_2_BYTES将不被定义。此时，就使用的是下部定义的这几个。这种情况下：通过使用char、short、int和long的组合，这对于正在编译程序的机器是合适的int_8将处理 1字节的整数；int16_t将处理 2字节的整数；int32_t将处理 4字节的整数。6.14 关键字auto看一个例子：1double d &#123;5.0&#125;;如果C++早就知道5.0是double类型的数字，那为什么我们还要显示的指定d是double类型的呢？如果我们可以让一个变量根据我们初始化它的值来设想它的类型，这不是很好吗?初始化变量的类型推断当初始化一个变量，关键字auto可以用来代替类型，以告诉编译器从初始化器的类型推断变量的类型。这种就叫作：type inference(类型推断), 英文中也可以叫作：type deduction例如：12auto d &#123;5.0&#125;; //因为5.0是一个double类型的数字，所以它的类型将被推断为doubleauto i &#123;1+2&#125;; //因为1+2的结果是int类型，所以，i 将被推断为int类型也可以用在函数返回值：123456789int add(int x, int y)&#123; return x+y;&#125;int main()&#123; auto sum&#123;add(5,6)&#125;; //add() 返回一个int, 所以sum的类型将被推断为int&#125;在C++14中函数的类型推断在C++14中，关键字auto被扩展到可以从函数体中的返回语句推断出函数的返回类型。1234auto add(int x, int y)&#123; return x+y;&#125;因为x+y的值是int类型，编译器将会推断这个函数应该返回一个int类型。当使用auto返回类型时，所有的返回语句就必须返回相同的类型，否则将会出错。但是不推荐对函数的返回类型使用关键字auto。因为没有上下文来帮助指示函数返回的类型。用户实际上必须深入函数体本身来确定函数返回的类型。它不那么直观，因此更容易出错。后置返回类型语法关键字auto也可以被用来后置返回类型(trailing return syntax)。即，在函数原型之后指定返回的类型。这是C++11新增的一种函数声明的方法。下面的两个对函数声明的语句是等价的：12int add(int x, int y);auto add(int x, int y) -&gt; int;//在这种情况下，auto不执行类型推断——使用后置返回类型只是语法的一部分。那为什么要用后置类型返回语句呢？其中的好处之一就是：可以让函数的声明时的名字对齐😊，如：1234auto add(int x, int y) -&gt; int;auto divide(double x, double y) -&gt; double;auto printSomething() -&gt; void;auto generateSubstring(const std::string &amp;s, int start, int len) -&gt; std::string;函数形参的类型推断在C++20时引入的123456789101112#include &lt;iostream&gt;void add(auto x, auto y) //only valid in C++20&#123; std::cout &lt;&lt;x+y;&#125;int main()&#123; add(2, 3); //int add(1.1, 2.2); //double&#125;在C++20之前，这种形式是无效的。因为编译器在 编译时(complie time) 不能推断函数形参的类型。在C++20之前，如果你想要创建一个使用各种不同类型的泛型函数，你需要使用function templates，而不是现在用的type inference6.15 强制类型转换(隐式)类型转换有两种形式：implicit type conversion（隐式类型转换）：编译器会自动将一种数据类型转换为另一种数据类型explicit type conversion（显示类型转换）：开发人员使用转换操作符来指导转换。将值从一种数据类型转换为另一种数据类型的过程称为type conversion(类型转换)。类型转换可以在许多不同的情况下发生:当用不同数据类型的值 分配 或 初始 化一个变量时:12double d&#123;3&#125;; // initialize double variable with integer value 3d = 6; // assign double variable the integer value 6当传递一个值给一个函数时，但函数参数是不同的数据类型：12345void doSomething(long l)&#123;&#125; doSomething(3); // pass integer value 3 to a function expecting a long parameter当从一个函数返回一个值时，该函数的返回类型是不同的数据类型：1234float doSomething()&#123; return 3.0; // Return double value 3.0 back to caller through float return type&#125;使用不同类型的操作数的 二元操作符：1double division&#123; 4.0 / 3 &#125;; // division with a double and an integer隐式类型转换隐式类型转换(也称为自动类型转换或强制转换)在希望是这种数据类型，但提供了另一种数据类型。乳沟编译器能够辨认出类型转换中的两种类型，挠他就转换。否则，报错。隐式类型转换有两种基本类型：提升和转换。Numeric promotion数值提升每当将一个基本数据类型的值转换为来自同一族的更大的基本数据类型的值时，这称为数值提升(或加宽，尽管这个术语通常用于整数)。123//an int can be widened into a long, or a float promoted into a double:long l&#123; 64 &#125;; // widen the integer 64 into a longdouble d&#123; 0.12f &#125;; // promote the float 0.12 into a double虽然术语数值推广涵盖了任何类型的提升，但在c++中还有两个具有特定含义的术语:Integral promotion(整型提升)：可以将[ bool , char, unsigned char, signed char, unsigned short, and signed short ]这些类型转换为 int或者是unsigned intFloating point promotion(浮点型提升)：可以将float类型转换为double整型提升 和 浮点型提升 通常是将 较小的数据类型转换为int/unsigned int或double。Numeric conversions(数值转换)当我们将一个值从较大的类型转换为类似的较小类型时，或者在不同类型之间转换时，这称为数值转换。例如:12double d&#123; 3 &#125;; // convert integer 3 to a double (between different types)short s&#123; 2 &#125;; // convert integer 2 to a short (from larger to smaller type within same type family)数值提升是安全的；但是数值转换可能会丢失数据。因此，导致执行隐式转换的代码通常会导致编译器发出警告。eg,将一个值转换为的类型没有足够大的范围来支持这个值，就会出现意想不到的结果：123456789101112int main()&#123; int i&#123; 30000 &#125;; char c = i; // chars have range -128 to 127 std::cout &lt;&lt; static_cast&lt;int&gt;(c); return 0;&#125;/********结果**********/48在本例中，我们将一个大整数分配给一个char(其范围为-128到127)。这会导致char溢出，并产生一个意外的结果: 48但是，只要值符合较小类型的范围，从较大的整数或浮点类型转换为较小的类似类型通常就可以工作。例如:1234567891011 int i&#123; 2 &#125;; short s = i; // convert from int to short std::cout &lt;&lt; s &lt;&lt; '\\n'; double d&#123; 0.1234 &#125;; float f = d; std::cout &lt;&lt; f &lt;&lt; '\\n';/***********结果**************/20.1234对于浮点值，由于较小类型的精度损失，可能会出现一些舍入。例如:12345float f = 0.123456789; // double value 0.123456789 has 9 significant digits, but float can only support about 7 std::cout &lt;&lt; std::setprecision(9) &lt;&lt; f &lt;&lt; '\\n'; // std::setprecision defined in 头文件“iomanip”中/************结果************/0.123456791只要值符合浮点类型的范围，就可以将整数转换为浮点数。例如:123456 int i&#123; 10 &#125;; float f = i; std::cout &lt;&lt; f;/**************结果**************/10只要值符合整数的范围，就可以将浮点数转换为整数，但是任何小数值都会丢失。例如:12345 int i = 3.5; std::cout &lt;&lt; i &lt;&lt; '\\n';/***在本例中，丢失了分数值(.5)，结果如下:****/3计算算术表达式当计算表达式时，编译器将每个表达式分解成单独的子表达式。算术运算符要求它们的操作数必须是相同的类型。为了确保这一点，编译器使用以下规则:如果一个操作数是一个比int更窄的整数，它将经历整数提升(如上所述)到int或usigned int。如果操作数仍然不匹配，那么编译器会找到优先级最高的操作数，并隐式地将另一个操作数转换为匹配的操作数。操作数的优先级如下:long double (highest)doublefloatunsigned long longlong longunsigned longlongunsigned intint (lowest)我们可以通过使用typeid操作符(包含在头中)看到通常的算术转换，该操作符可用于显示表达式的结果类型。eg1:1234567891011121314#include &lt;iostream&gt;#include &lt;typeinfo&gt; // for typeid() int main()&#123; short a&#123; 4 &#125;; short b&#123; 5 &#125;; std::cout &lt;&lt; typeid(a + b).name() &lt;&lt; \" \" &lt;&lt; a + b &lt;&lt; '\\n'; // show us the type of a + b return 0;&#125;/*因为short是整数，所以它们在被添加之前要经过整数提升到int。添加两个int的结果是一个int，正如您所期望的:*/int 9注意:编译器可能会显示一些稍微不同的内容，因为typeid.name()的格式由编译器决定。eg2:12345678910111213#include &lt;iostream&gt;#include &lt;typeinfo&gt; // for typeid() int main()&#123; double d&#123; 4.0 &#125;; short s&#123; 2 &#125;; std::cout &lt;&lt; typeid(d + s).name() &lt;&lt; ' ' &lt;&lt; d + s &lt;&lt; '\\n'; // show us the type of d + s return 0;&#125;/*****结果*************/double 6.0在这种情况下，short将被 数值提升 为int。但是，int与double还是不匹配。又因为double在类型的层次结构中更高。所以，整型的2将被转换为double 类型的 2.0 。然后就相当于是两个double类型的相加，结果还是double类型.强制类型转换(显式) &amp; static_cast显式的类型转换是使用 type casting operator(类型转换操作符)。（通常是程序员来做的一个显式的的类型转换）在C++中，类型转换大致分为5种： C-style casts, static casts, const casts, dynamic casts, and reinterpret casts. 后四个有时被称为命名类型转换(named casts)。在本节课中，我们将介绍c风格的类型转换和静态类型转换。我们将在以后的课程中讨论指针和继承时再保存动态类型转换。通常应该避免使用Const casts和reinterpret casts，因为它们只在极少数情况下有用，如果使用不当可能会有害。C-style casts在标准的C语言中，类型转换是通过 操作符()来完成的。括号内是将要转换的目标类型：123int i1 &#123; 10 &#125;;int i2 &#123; 4 &#125;;float f &#123; (float)i1 / i2 &#125;;在上面的程序中，我们使用浮点c风格的强制转换来告诉编译器将i1转换为浮点值。因为运算符/的左操作数现在变为浮点值，右操作符也将被转换为浮点值。并且除法将使用浮点除法而不是整数除法!使用强制类型转换来清除隐式类型转换1234int i &#123; 48 &#125;; // explicit conversion from int to char, so that a char is assigned to variable chchar ch = static_cast&lt;char&gt;(i);当我们这样做时，我们显式地告诉编译器这个转换是有意的，并且我们接受对结果的责任。因为这个static_cast的输出类型是char，所以对变量ch的赋值不会产生任何类型不匹配，因此没有警告。下面的程序，编译器将会抱怨将double转换成int可能会导致数据丢失:12int i &#123; 100 &#125;;i = i / 2.5;告诉编译器，我们明确的意思是这样做:12int i &#123; 100 &#125;;i = static_cast&lt;int&gt;(i / 2.5);6.17 未命名/内联 命名空间未命名(匿名) 命名空间12345678910111213141516171819#include &lt;iostream&gt; namespace // unnamed namespace&#123; void doSomething() // can only be accessed in this file &#123; std::cout &lt;&lt; \"v1\\n\"; &#125;&#125; int main()&#123; doSomething(); // we can call doSomething() without a namespace prefix return 0;&#125;/********结果**********/v1在未命名的命名空间中声明的所有内容都被视为父命名空间的一部分。因此，尽管doSomething函数是在未命名的命名空间中定义的，但函数本身可以从父命名空间(在本例中是global namespace)访问，这就是为什么我们可以从main调用doSomething而不需要任何限定符。这可能使未命名的命名空间看起来毫无用处。但未命名名称空间的另一个影响是：未命名命名空间内的所有标识符都被视为具有内部链接，这意味着未命名命名空间的内容就不能在其他文件中看到。对于函数，这实际上等同于将未命名的命名空间中的所有函数定义为静态函数。下面的程序与上面的程序实际上是相同的：12345678910111213#include &lt;iostream&gt; static void doSomething() // can only be accessed in this file&#123; std::cout &lt;&lt; \"v1\\n\";&#125; int main()&#123; doSomething(); // we can call doSomething() without a namespace prefix return 0;&#125;unnamed namespace通常用于 当你有很多内容想要确保在给定文件中保持局部时，使用unnamed namespace要比单独将所有声明标记为static更容易。内联 命名空间Inline namespaces12345678910111213#include &lt;iostream&gt; void doSomething()&#123; std::cout &lt;&lt; \"v1\\n\";&#125; int main()&#123; doSomething(); return 0;&#125;但是假设你对doSomething不满意，你想通过改变它的行为方式来改进它。但如果这样做，就有可能破坏使用旧版本的现有程序。你是怎么处理的?一种方法是用不同的名称创建函数的新版本。但是经过许多更改之后，您可能会得到一组名称几乎相同的函数(doSomething、doSomething_v2、doSomething_v3等)。【推荐】另一种方法是使用内联命名空间。内联命名空间是通常用于版本化内容的名称空间。与未命名的命名空间非常相似，在内联命名空间中声明的任何内容都被认为是父名称空间的一部分。然而，内联命名空间并不是 内部链接。使用关键字inline1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt; inline namespace v1 // declare an inline namespace named v1&#123; void doSomething() &#123; std::cout &lt;&lt; \"v1\\n\"; &#125;&#125; namespace v2 // declare a normal namespace named v2&#123; void doSomething() &#123; std::cout &lt;&lt; \"v2\\n\"; &#125;&#125; int main()&#123; v1::doSomething(); // calls the v1 version of doSomething() v2::doSomething(); // calls the v2 version of doSomething() doSomething(); // calls the inline version of doSomething() (which is v1) return 0;&#125;/*********结果********/v1v2v1可以看出，当有 内联函数存在时，如果不加前缀，则默认调用的是 内联函数版本在上面的例子中，调用doSomething将得到doSomething的v1(内联版本)。希望使用新版本的调用者可以显式地调用v2::dosomething()。这保留了现有程序的功能，同时允许更新的程序利用更新的/更好的变体。6.x Chapter 6 summary and quizhttps://www.learncpp.com/cpp-tutorial/chapter-6-summary-and-quiz/","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://longlongqin.github.io/tags/C-C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"GIT 学习","slug":"学习笔记/GIT 学习","date":"2020-04-05T06:08:23.000Z","updated":"2020-09-06T03:34:02.000Z","comments":true,"path":"archives/18085cf9.html","link":"","permalink":"https://longlongqin.github.io/archives/18085cf9.html","excerpt":"Git学习笔记","text":"Git学习笔记Git的三种状态：committed（已提交）：数据已经安全的保存在本地数据库（仓库）；modified（已修改）：修改了文件，但还没有保存到数据库；staged（已暂存）：对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。Git项目的三个工作区域概念：Git仓库（Git directory 或 repository）：是Git用来保存项目的元数据和对象数据库的地方。是Git最重要部分，从其他计算机克隆仓库时，拷贝的就是这里的数据。工作目录（working directory）：对项目的某个版本独立提取出来的内容。这些从Git仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。暂存区域（staging area）：是一个文件，保存了下一次将提交的文件列表信息，一般在Git仓库目录中，有时也被称作“索引”。基本的 Git 工作流程如下：1.在工作目录中修改文件；2.暂存文件，将文件的快照放入暂存区域；3.提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目。初始设置：设置姓名和邮箱：12git config --global user.name &quot;Firstname Lastname&quot; &#x2F;&#x2F; 名字使用英文输入git config --global user.email &quot;your_email@example.com&quot;注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。这个命令，会在“~/.gitconfig”中以如下形式输出设置文件。我的电脑上，这个文件夹的位置在C:\\Users\\ACER设置SSH key:创建公开密钥：1ssh-keygen -t rsa -C &quot;your_email@example.com&quot;如果一切顺利的话，可以在用户主目录里找到.ssh目录，我的在：C:\\Users\\ACER\\.ssh里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。初始化Git仓库：在该仓库中，打开Git bash，然后：1git init关联远程仓库：在远程仓库（如：github、gitee）中有一个新仓库什么都没有，我们可以：克隆一份到本地；也可以把一个已有的本地仓库与之关联。123456git remote add &lt;远程仓库名字&gt; &lt;远程仓库的SSH或HTTPS&gt;如：git remote add origin git@github.com:michaelliao&#x2F;learngit.git其中： 远程仓库名字：origin（是git的默认叫法，也可以写成其他的） 远程仓库的SSH：git@github.com:longlongqin&#x2F;learngit.git 当需要将一个仓库同时在github 和 gitee上关联时：假如在gitee上关联之前，已经在GitHub上关联过了。比如事先在GitHub上：git remote add origin git@github.com:longlongqin/LearnGit.git，关联了一个叫origin的远程仓库。然后，我现在要在gitee上关联一个仓库：git remote add origin git@gitee.com:longlongqin/LearnGit.git出现报错：fatal: remote origin already exists.说明，本地库已经关联了一个叫做origin的远程仓库了，所以才会报错。所以，我们知道，不能将github和gitee上的仓库名字都叫一样的名字。他们之间的名字要区分。先，删除关联的已有的GitHub远程库：1git remote rm origin再开始重新关联github和gitee的仓库，这次要将他们的仓库名字区分开：/*gitee中的LearnGit仓库起名：gitee；/*github中的LearnGit仓库起名：github；12git remote gitee origin git@gitee.com:longlongqin&#x2F;LearnGit.gitgit remote github origin git@github.com:longlongqin&#x2F;LearnGit.git检查一下，是否成功：​ 我们用git remote -v查看远程库信息，可以看到两个远程库：12345$ git remote -vgitee git@gitee.com:longlongqin&#x2F;LearnGit.git (fetch)gitee git@gitee.com:longlongqin&#x2F;LearnGit.git (push)github git@github.com:longlongqin&#x2F;LearnGit.git (fetch)github git@github.com:longlongqin&#x2F;LearnGit.git (push)成功。取消关联远程仓库：在关联远程仓库一节中，关联远程仓库，我们也可以取消以经关联的远程仓库，让他们取消关联：1git remote rm &lt;要取消关联的远程仓库的名字&gt;时光穿梭机撤销修改1、没有git add时（即，对文件做了修改，但是没添加到暂存区）：==用git checkout -- &lt;file&gt; (==file前面有一个空格)2、已经git add时（即，对文件做了修改，并且添加到暂存区）：先git reset HEAD &lt;file&gt;把暂存区的修改撤销掉，即：回退到没有git add时的状态然后，再git checkout -- &lt;file&gt;。3、已经git commit时（即，对文件做了修改，不仅添加到暂存区，而且还提交到本地仓库中了）：进行==版本回退==版本回退版本之间的切换，版本指的是git commit之后带有哈希值的状态。版本回退：git reset --hard commit_id 可以回退到版本号为commit_id的那个版本。git reset --hard head^ 回退到当前版本的上一个版本。转回到新版本：因为git log显示的是从此刻head指针所在的状态到之前的状态的提交日志。而git reflog用来记录你的每一次命令。所以转回到比当前所在的状态要新的状态需要：git reflog,找到你想要回去的那个较新的状态的commit 的idgit reset --hard &lt;commit_id&gt; 回到想要回器的那个版本。删除文件rm &lt;file&gt;从工作区中删除文件（和手动删除文件效果一样。）git rm &lt;file&gt;将文件从工作区删除，并且还添加到了暂存区（即，把删除的这个状态同步到暂存区了）。git rm -r &lt;文件夹&gt; 删除一个文件夹[^小提示]: 先手动删除文件，然后使用git rm和git add效果是一样的。远程仓库添加远程仓库：关联一个远程仓库：git remote add origin git@github.com:path/repo-name.git关联后，第一次推送master分支的所有内容：git push origin master远程仓库克隆：1git clone &lt;你想要克隆内容的公开密钥的密码&gt;公开的密钥密码，如下图所示：分支管理创建与合并分支：查看分支：git branch新建分支：git branch &lt;name&gt;创建并切换分支：git checkout -b &lt;name&gt; or git switch -c &lt;name&gt;切换分支：git checkout &lt;name&gt; or git switch &lt;name&gt;删除分支：git branch -d &lt;name&gt;不能删除当前所在的分支合并分支：git merge &lt;name&gt; 用于合并分支到当前分支git merge --no-ff &lt;name&gt; 其中参数–no-ff：表示在历史记录中明确记录下本次分支合并。注意：输入此命令之后，会启动编辑器，用于录入合并提交的信息。解决冲突：当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。用git log --graph命令可以看到分支合并图。分支管理策略：在实际开发中，我们应该按照几个基本原则进行分支管理：首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。所以，团队合作的分支看起来就像这样：小结：Git分支十分强大，在团队开发中应该充分应用。合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。合并分支的两种方式：git 的 merge 与 merge no-ff 的不同之处： no-ff merge可以看到合并历史。新建分支dev1，修改readme.txt，然后在dev1分支下git add readme.txt git commit -m &quot;dev1 branch commit&quot;回到master分支，执行merge即git merge dev1删除分支查看日志即git log --graph --pretty=oneline --abbrev-commit新建分支dev2，修改readme.txt，然后在dev2分支下git add readme.txt git commit -m &quot;dev2 branch commit&quot;回到master分支，执行merge即git merge --no-ff -m &quot;dev2 merged with mo-ff&quot; dev2删除分支查看日志即git log --graph --pretty=oneline --abbrev-commit比较两次合并，可以看出不同之处，no-ff的模式会记录分支历史、12//检查 Git 的某一项配置：git config &lt;key&gt; 12//列出所有 Git 当时能找到的配置： git config --list 1234//获取帮助：3种方法$ git help &lt;verb&gt;$ git &lt;verb&gt; --help$ man git-&lt;verb&gt;###############################################Git 其他指令：查看工作区状态status：git status查看的是工作区的状态。git diff 查看工作区与暂存区的区别。git diff head查看工作区与本地仓库的区别。查看文件内容：1cat &lt;name&gt;提交：工作区提交到暂存区：1git add &quot;filename&quot;暂存区提交到本地仓库：1git commit -m &quot;message&quot; &#x2F;&#x2F;message是对此次提交的一个说明语句12git commit&#x2F;&#x2F;此命令可以更加详细的记述提交信息（运行此命令后，会自动打开Git设置好的编辑器）执行此命令后，编辑器就会启动，显示如下：1234567# Please enter the commit message for your changes. Lines starting# with &#39;#&#39; will be ignored, and an empty message aborts the commit.## On branch dev# Changes to be committed:# modified: readme.txt#在编辑器中记述提交信息的格式如下：● 第一行：用一行文字简述提交的更改内容● 第二行：空行● 第三行以后：记述更改的原因和详细内容1git commit --amend :修改上一条提交时写的信息本地仓库提交(推送)到远程仓库：git push情况一：注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以git pull是&lt;远程分支&gt;:&lt;本地分支&gt;，而git push是&lt;本地分支&gt;:&lt;远程分支&gt;。1git push &lt;远程仓库名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;情况二：（推荐）如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。1234git push &lt;远程仓库名字&gt; &lt;将本地的分支推送到远程仓库的分支（本地分支和远程分支的名字一样）&gt;如：git push origin master上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。情况三：下面命令将本地的master分支推送到origin远程仓库，同时指定origin为默认仓库，后面就可以不加任何参数使用git push了。1git push -u &lt;远程仓库名字&gt; &lt;将本地的分支推送到远程仓库的分支（本地分支和远程分支的名字一样）&gt;情况四：如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。123git push origin :&lt;远程分支&gt;# 等同于:git push origin --delete master获取最新的远程仓库的分支：加入在远程仓库中的一个分支中的内容更新了，而本地的这个分支（和远程的这个分支名字相同）不是最新的，可以用git pull来同步。1git pull &lt;远程仓库名&gt; &lt;需要更新的分支（这个分支名：本地的和远程的名字一样）&gt;如：git pull origin feature-D，表示：从远程仓库origin中的“feature-D”分支进行对本地的分支“feature-D”更新。查看提交历史：git log 查看提交（commit）历史（以便确定要回退到哪个版本）。​ 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数，即：git log --pretty=onelinegit log &lt;filename&gt; ：显示特定文件(filename)的提交历史git log -p ：文件的前后差别就会显示在提交信息之后git log -p &lt;filename&gt; ：只查看 “filename”文件的提交日 志以及提交前后的差别。git log --graph：以图表形式查看分支，例如下图：git reflog 查看历史的每一次的命令（以便确定要回到未来的哪个版本）。自定义Git:修改GIT默认编辑器：GIT默认编辑器为Vi，假如我想用Notepad++：1git config --global core.editor &quot;Notepad++&quot; &#x2F;&#x2F;设置Editor使用Notepad++Git显示颜色：1git config --global color.ui true##################################################学习廖雪峰教学中的问题：1、与教学步骤中的命令区别于：“–”（1）git diff head --readme.txt：问题：在我自己电脑上面运行没反应？解决：运行：git diff head readme.txt,即去掉那个“–”。（2）git checkout --readme.txt问题：在于我的电脑上多了“–”会运行失败。解决：去掉“–”：GitHub使用技巧搜索：1）、在不同地方搜索1、按照name搜索1in:name &lt;something&gt; &#x2F;&#x2F;假设想搜索的东西叫：something2、按照readme搜索也可以按照readme.md中包含的查找项目：1in:readme &lt;something&gt; &#x2F;&#x2F;假设想搜索的东西叫：something3、按照descriptin搜索假设我们现在要学习的项目，我们搜索项目描述(description)里面包含的项目:1in:description &lt;something&gt; &#x2F;&#x2F;假设想搜索的东西叫：something4、直接搜索直接在搜索栏中搜索：加入想搜索与CJSON有关的内容：2）、添加约束条件star数量12stars: &gt; 500 &#x2F;&#x2F; star 数量大于500的项目stars: 10..20 &#x2F;&#x2F; star 数量在10-20之间的仓库fork数量同理，我们也可以按照fork的数量来进行搜索:1in:name React forks:&gt;3000language编程语言1language:python &#x2F;&#x2F;比如，把语言限制为Python仓库push的时间假如在这些项目里面，我们想要找到最近才更新的项目，意思是更新时间就在最近，我们可以这样：1pushed:&gt;2020-01-01 &#x2F;&#x2F;项目的最近一次更新时间限制到2020-01-01之后仓库持有者1user：&lt;username&gt;仓库大小1size:&gt;&#x3D;5000 &#x2F;&#x2F; 仓库大于5000KB的仓库仓库create时间1created:&gt;2019-01-01 &#x2F;&#x2F; 2019年以后创建的仓库license协议1license:apache-2.0 &#x2F;&#x2F; 使用 apache-2.0 协议的仓库组织机构代码1org:spring-cloud &#x2F;&#x2F; 列出org 的 spring-cloud 仓库3）、组合搜索将1）和2）中可以随机组合进行精确搜索,比如：1in:description &lt;something&gt; language:python &#x2F;&#x2F;将编程语言限制为python1in:readme &lt;something&gt; stars:&gt;3000 forks:&gt;300012in:description 微服务 language:python pushed:&gt;2020-01-01&#x2F;*pushed:&gt;2020-01-01的意思是我们把项目的最后更新时间限制到2020-01-01*&#x2F;1in:name React forks:&gt;3000等等奇特搜索：awesome搜索1、awesome-awesome搜索直接使用awesome-awesome可以搜索出很多优质项目。1awesome-awesome2、awesome name搜索1awesome &lt;name&gt;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Git","slug":"学习笔记/Git","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://longlongqin.github.io/tags/Git/"}]},{"title":"LearnCpp chapterO","slug":"C&C++/LearnCpp-chapterO","date":"2020-04-04T02:21:31.000Z","updated":"2020-04-19T14:38:29.546Z","comments":true,"path":"archives/67343d3.html","link":"","permalink":"https://longlongqin.github.io/archives/67343d3.html","excerpt":"LearnCpp chapterOhttps://www.learncpp.com未完待续~~","text":"LearnCpp chapterOhttps://www.learncpp.com未完待续~~O.1 Bit flags and bit manipulation via std::bitset在现代计算机体系结构中，最小的可寻址内存单元是字节。由于所有对象都需要有唯一的内存地址，这意味着对象的大小必须至少为一个字节。对于大多数变量类型，这是可以的。然而，对于布尔值，这有点浪费。布尔类型只有两种状态:真(1)，或假(0)。这一组状态只需要存储一位。然而，如果一个变量必须至少是一个字节，而一个字节是8位，这意味着一个布尔值使用1位，而其他7位不使用。位操作：bit manipulation在对象内部，修改单个bit的过程，叫位操作。位操作在加密和压缩算法中也很有用。但是，我们可以将对象视为单个位的集合，而不是将其视为持有单个值的对象。当对象的个别位用作布尔值时，这些位称为位标志：bit flag。在计算中，标志是作为某个函数或进程的信号的值。类似地，在现实生活中，邮箱标志用于指示邮箱中有内容，因此不必打开邮箱进行检查。为了定义一组位标志，我们通常使用适当大小的无符号整数(8位、16位、32位等等，这取决于我们有多少个标志)，或者std::bitset。123#include &lt;bitset&gt; //for std::bitsetstd::bitset&lt;8&gt; mybitset &#123;&#125;; //8 bits in size means room for 8 flags位操作是少数几种应该明确使用无符号整数(或std::bitset)的操作之一。位编号和位的位置：Bit numbering and bit positions给定一个bits 序列，通常从右到左开始进行编号(编号的开头是0，不是1)。每一个数字表示一个bit positon：位的位置。eg：1276543210 Bit position00000101 Bit sequence通过std::bitset操作位在 4.12 – Literals，我们介绍了如何使用std::bitset来输出二进制形式的结果。现在我们来介绍std::bitset的其他功能：std::bitset提供了4个关键的功能，对做位操作很有用:text()：允许我们查询一个位是0还是1；set()：允许我们将一个 位(bit)设置成 on，即将其设置为1；reset()：允许我们将一个 位(bit)设置成 off，即将其设置为 0；flip()：允许我们将一个 位(bit) 由0设置为1，或者由1设置为0；这些函数中的每一个都带有一个位位置参数，该参数指示我们将要操作的位 的位置。123456789101112131415161718192021#include &lt;bitset&gt;#include &lt;iostream&gt;int main()&#123; std::bitset&lt;8&gt; bits&#123;0b0000'0101&#125;; //we need 8 bits, start with bit pattern 0000 0101 bit.set(3); //set bit position 3 to 1 (now we have 0000 1101) bit.flip(4); //flip bit 4(now we have 0001 1101) bit.reset(4); //set bit 4 back to 0 (now we have 0000 1101) std::cout &lt;&lt;\"All the bits: \"&lt;&lt;bits&lt;&lt;'\\n'; std::cout &lt;&lt;\"bit 3 has valude: \" &lt;&lt;bit.test(3) &lt;&lt;'\\n'; std:;cout &lt;&lt;\"bit 4 has valud: \"&lt;&lt;bit.test(4) &lt;&lt;'\\n'; return 0;&#125;/********输出结果********/All the bits: 00001101bit 3 has valude: 1bit 4 has valude: 0O.2 位操作符C++提供了“位操作符(bitwise operator)”：OperatorSymbolFormOperationleft shift&lt;&lt;x &lt;&lt; yall bits in x shifted left y bitsright shift&gt;&gt;x &gt;&gt; yall bits in x shifted right y bitsbitwise NOT~~xall bits in x flippedbitwise AND&amp;x &amp; yeach bit in x AND each bit in ybitwise OR|x | yeach bit in x OR each bit in ybitwise XOR^x ^ yeach bit in x XOR each bit in y在下面的例子中，我们将主要使用4位二进制值。这是为了方便和保持例子简单。在实际的程序中，使用的位的数量是基于对象的大小(例如，一个2字节的对象将存储16位)。为了可读性，我们还将在代码示例之外省略0b前缀(例如，我们将使用0101而不是0b0101)。位操作符：&lt;&lt;左移、&gt;&gt;右移按位左移(&lt;&lt;)操作符将位移到左边。左操作数是要移位的位的表达式，而右操作数是要左移的位的整数。如：x&lt;&lt;1表示，将变量x左移一个位置。从右边移进来的新位接受一个 值0。eg，0011&lt;&lt;1 是 01100011&lt;&lt;2 是 11000011&lt;&lt;3 是 1000同理，按位右移(&gt;&gt;)操作符原理也一样：1100&gt;&gt;1 是 01101100&gt;&gt;2 是 00111100&gt;&gt;3 是 0001下面是一个示例程序：123456789101112131415161718#include &lt;iostream&gt;#include &lt;bitset&gt;int main()&#123; std::bitset&lt;4&gt; x&#123;0b1100&#125;; std::cout &lt;&lt;x&lt;&lt;'\\n'; std::cout &lt;&lt; (x&gt;&gt;1) &lt;&lt; '\\n'; //右移一个位置，结果是0110 std::cout &lt;&lt; (x&lt;&lt;1) &lt;&lt; '\\n'; //左移一个位置，结果是1000 return 0；&#125;/*******结果******/110001101000位操作：NOT ~这个操作符功能就是将每个位的数由0变为1，或由1变为0：如：~0100 是 1011；~0000 0100 是 1111 1011上面例子中，虽然：0100 和000 0100是一样的，就像十进制的7和07一样；但是经过~操作符之后，它们位数不一样，就会产生不一样的结果。位操作：OR |它的形式是对两个表达式进行每个位上的或运算，如：0b0101 | 0b0110。更加直观的形式为：12340 1 0 1 OR0 1 1 0--------- &#x2F;&#x2F;结果为0 1 1 1示例：1234567891011#include &lt;iostream&gt;#include &lt;bitset&gt;int main()&#123; std::cout &lt;&lt; (std::bitset&lt;4&gt;&#123;0b0101&#125; | std::bitset&lt;4&gt;&#123;0b0110&#125;); return 0;&#125;/**********结果********/0111也可进行多个表达式的运算，如：12345670 1 1 1 OR0 0 1 1 OR0 0 0 1--------0 1 1 1&#x2F;&#x2F;只要对应的列有1，它的结果中对应的那一列就是1它写成程序：123456789101112#include &lt;iostream&gt;#include &lt;bitset&gt; int main()&#123; std::cout &lt;&lt; (std::bitset&lt;4&gt;&#123; 0b0111 &#125; | std::bitset&lt;4&gt;&#123; 0b0011 &#125; | std::bitset&lt;4&gt;&#123; 0b0001 &#125;); return 0;&#125;/*********结果*********/0111位操作：AND &amp;它的形式为：0b0101 &amp; 0b0110,更加直观的形式（也可以有多个表达式一起运算）：12340 1 0 1 AND0 1 1 0--------0 1 0 0每一列中只有全部为1时，结果中对应的列才是1.示例：12345678910111213141516#include &lt;iostream&gt;#include &lt;bitset&gt; int main()&#123; std::cout &lt;&lt; (std::bitset&lt;4&gt;&#123; 0b0001 &#125; &amp; std::bitset&lt;4&gt;&#123; 0b0011 &#125; &amp; std::bitset&lt;4&gt;&#123; 0b0111 &#125;); return 0;&#125;//直观的表示为：0 0 0 1 AND0 0 1 1 AND0 1 1 1-------- //结果为0 0 0 1位操作：XOR ^它的形式为：0b0001 ^ 0b0011 ^ 0b0111更加直观的看：123450 0 0 1 XOR0 0 1 1 XOR0 1 1 1--------0 1 0 1每一列如果有奇数个1，则结果中对应的列就是1；否则就是0.位的赋值操作符与算术赋值运算符相似，C++提供位的赋值操作符，为了方便修改变量：OperatorSymbolFormOperationLeft shift assignment&lt;&lt;=x &lt;&lt;= yShift x left by y bitsRight shift assignment&gt;&gt;=x &gt;&gt;= yShift x right by y bitsBitwise OR assignment|=x |= yAssign x | y to xBitwise AND assignment&amp;=x &amp;= yAssign x &amp; y to xBitwise XOR assignment^=x ^= yAssign x ^ y to x比如，x= x&gt;&gt;1，可以写成：x&gt;&gt;=1:1234567891011121314#include &lt;bitset&gt;#include &lt;iostream&gt;int main()&#123; std::bitset&lt;4&gt; bits&#123;0b0100&#125;; bits &gt;&gt;= 1; std::cout &lt;&lt; bits; return 0;&#125;/********结果*********/0010总结：","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://longlongqin.github.io/tags/C-C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"LearnCpp chapter5","slug":"C&C++/LearnCpp-chapter5","date":"2020-04-03T02:21:47.000Z","updated":"2020-04-19T14:38:29.545Z","comments":true,"path":"archives/b6a3dbf1.html","link":"","permalink":"https://longlongqin.github.io/archives/b6a3dbf1.html","excerpt":"LearnCpp chapter5https://www.learncpp.com","text":"LearnCpp chapter5https://www.learncpp.com5.1 操作符优先级 &amp; 结合律Operator precedence and associativity下面是操作符的优先级 及 结合律【note】下面表格的操作符优先级：level 1是最高优先级；level 17 优先级最低结合律：L-&gt;R：即，从左向右结合R-&gt;L ：即。从右向左结合注意一个连等号到表达式：x=y=z;由上表可知，该表达式其实是这样的：x=(y=z);5.2 算数运算符Arithmetic operators一元操作符(Unary arithmetic operators)：+、-：unary minus：返回 操作数乘以-1 之后的值。unary plus：返回 操作数本身。这两个操作符都应该放在操作数的前面(e.g. -x , 而不是 - x)eg: x=5 - -3;.第一个减号表示二元操作符，减法；第二个减号表示一元操作符。二元运算符：Binary arithmetic operators二元操作符有左、右 两个操作数(operand)：整数与浮点数 的除法左右两个操作数至少有一个是 浮点型值，它们的运算结果依然是一个浮点型的值。For example, 7.0 / 4 = 1.75, 7 / 4.0 = 1.75、7.0 / 4.0 = 1.75做有两个操作数均为 整型值，它的运算结果依然是 整型值。For example, 7 / 4 = 1用static_cast&lt;&gt;对整数进行浮点除法1234567891011121314151617181920#include &lt;iostream&gt;int main()&#123; int x&#123;7&#125;; int y&#123;4&#125;; std::cout &lt;&lt;\"int/int=\"&lt;&lt;x/y&lt;&lt;\"\\n\"; std::cout &lt;&lt;\"double / int = \"&lt;&lt;static_cast&lt;double&gt;(x)/y&lt;&lt;'\\n'; std::cout &lt;&lt; \"int / double = \"&lt;&lt;x/ static_cast&lt;double&gt;(y)&lt;&lt;'\\n'; std::cout &lt;&lt;\"double / double = \" &lt;&lt; static_cast&lt;double&gt;(x) / static_cast&lt;double&gt;(y)&lt;&lt;'\\n'; return 0;&#125;/*****结果*****/int / int = 1double / int = 1.75int / double = 1.75double / double = 1.75除以0如果除以0(或者 0.0)将会使程序崩溃。因为这个结果在数学中是没有定义的。赋值操作符5.3 取模 &amp; 幂运算取模操作符：The modulus operator取模操作符*，又称 *取余操作符。【note】：取余运算结果的符号，只和第一个操作数相一致。12345678910111213141516#include &lt;iostream&gt;int main()&#123; int x&#123; 6 &#125;, y&#123; -4 &#125;; //第一个操作数符号为 正 std::cout &lt;&lt; x%y &lt;&lt; '\\n'; int z&#123; -6 &#125;, w&#123; 4 &#125;; //第一个操作数符号为 负 std::cout &lt;&lt; z%w ; std::cin.clear(); std::cin.ignore(std::numeric_limits &lt;std::streamsize&gt;::max(), '\\n' ); std::cin.get(); return 0;&#125;结果：幂运算符^您将注意到^运算符(在数学中通常用于表示求幂)是c++中的位XOR操作。在C++中不包含“幂运算操作符”。如果要用，就需要加上头文件cmath：12#include &lt;cmath&gt;double x&#123; std::pow(3.0, 4.0)&#125;; //3 to the 4th power(3的4次方)【Note】注意，pow()函数的参数(和返回值)是double类型的。所以，就算传入的是整数类型的，它的计算还是会有误差的(因为浮点数计算本身就会有误差)所以，如果你想对整数进行幂运算，可以自己设计函数，使其结果比较精确：12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;cstdint&gt; //for std::int_fast64_t//note: exp(幂数) 不能是负数[因为用的是while循环]std::int_fast64_t powint (int base, int exp)&#123; std::int_fast64_t result &#123;1&#125;; while (exp) &#123; if(exp &amp; 1) result *= base; exp &gt;&gt;= 1; base *= base; &#125; return result;&#125;int main()&#123; std::cout &lt;&lt;powint(7,12); //7的12次幂 return 0;&#125;5.4 递增/递减操作符OperatorSymbolFormOperationPrefix increment (pre-increment)++++xIncrement x, then return xPrefix decrement (pre-decrement)––––xDecrement x, then return xPostfix increment (post-increment)++x++Copy x, then increment x, then return the copyPostfix decrement (post-decrement)––x––Copy x, then decrement x, then return the copy副作用：side effectsc++不定义函数参数或操作符操作数的求值顺序。12345678910111213141516#include &lt;iostream&gt; int add(int x, int y) &#123; return x+y; &#125;int main()&#123; int x&#123;5&#125;; int valude = add(x, ++x); //结果是5+6,还是6+6? //这取决于编译器计算函数参数的顺序 std::cout &lt;&lt;value; // value could be 11 or 12, depending on how the above line evaluates! return 0;&#125;【副作用】：c++没有定义函数参数求值的顺序。这种就会产生不确定性，因为还要取决于编译器对函数的参数计算的顺序。所以，不同的编译器可能会产生不同的结果。所以，结果可能为：11 或者 125.5 逗号“,” &amp; 条件 运算符逗号操作符逗号操作符适用于for循环，其他情况不推荐用OperatorSymbolFormOperationComma,x, yEvaluate x then y, returns value of ycomma operator (,)：允许您在允许单个表达式的情况下计算多个表达式的值。逗号运算符对左操作数求值，然后对右操作数求值，然后返回右操作数的结果。1234567891011121314#include &lt;iostream&gt;int main()&#123; int x&#123;1&#125;; int y&#123;2&#125;; std::cout&lt;&lt; (++x, ++y); //先计算左操作符，在计算右操作符，但是返回右操作符的结果 return 0;&#125;/*******结果**********/3逗号操作符是所有操作符中最低的12z = (a,b); //计算(a,b)，然后将返回的结果赋值给zz = a , b; //由于“=”操作符优先于“,”操作符，所以，先计算“z=a”;然后在计算b，计算完之后，b没用就被抛弃了逗号用作分隔符时，它此时代表的不是操作符12345void foo(int x, int y) // Comma used to separate parameters in function definition&#123; add(x, y); // Comma used to separate arguments in function call int z(3), w(5); // Comma used to separate multiple variables being defined on the same line (don't do this)&#125;条件操作符条件操作符是一个 三元操作符OperatorSymbolFormOperationConditional? :c ? x : yIf c is nonzero (true) then evaluate x, otherwise evaluate y形式：(condition) ? expression1 : expression2;当condition的结果是正确的(或者非零数字)，就执行expression1，否则，执行expression2由于条件操作符优先级较低，有时需要括号如：12345std::cout &lt;&lt; (x&gt;y) ? x : y;//由于“&lt;&lt;”的优先级高于“条件操作符”,所以，等同于以下形式：(std::cout &lt;&lt; (x&gt;y)) ? x : y;//想要按照我们设计的正确执行，则需要适当加上括号std::cout &lt;&lt;((x&gt;y) ? x : y);【注意】与在函数内部定义的变量在函数结束时死亡非常相似，在if或else语句中定义的变量在if或else语句结束时死亡。因此，在我们试图打印它时，类大小已经被破坏了。1234567891011121314#include &lt;iostream&gt; int main()&#123; bool inBigClassroom &#123; false &#125;; if (inBigClassroom) const int classSize &#123; 30 &#125;; else const int classSize &#123; 20 &#125;; //此时，if/else已经执行结束，所以，其内部定义的变量classSize也已经被销毁 std::cout &lt;&lt; \"The class size is: \" &lt;&lt; classSize; //因为classSize被销毁，所以会编译出错 return 0;&#125;条件编译的两个表达式的类型条件编译的两个表达式，要么具有相同的类型；要么第二个表达式的类型可以转化为第一个表达式的类型。1234567891011#include &lt;iostream&gt; int main()&#123; int x = 5; std::cout &lt;&lt; (x != 5 ? x : \"x is 5\"); // won't compile return 0;&#125;//因为，表达式1：x 是integer 类型；表达式2：\"x is 5\"是string类型。所以表达式2要转换为表达式1的类型，但是转换失败。所以编译就不成功5.6 关系运算符 &amp; 浮点数的比较关系运算符OperatorSymbolFormOperationGreater than&gt;x &gt; ytrue if x is greater than y, false otherwiseLess than&lt;x &lt; ytrue if x is less than y, false otherwiseGreater than or equals&gt;=x &gt;= ytrue if x is greater than or equal to y, false otherwiseLess than or equals&lt;=x &lt;= ytrue if x is less than or equal to y, false otherwiseEquality==x == ytrue if x equals y, false otherwiseInequality!=x != ytrue if x does not equal y, false otherwise这些操作符的值分别为布尔值true(1)和false(0)。浮点数的比较12345678910111213141516171819#include &lt;iostream&gt; int main()&#123; double d1&#123; 100.0 - 99.99 &#125;; // should equal 0.01 ? double d2&#123; 10.0 - 9.99 &#125;; // should equal 0.01 ? if (d1 == d2) std::cout &lt;&lt; \"d1 == d2\" &lt;&lt; '\\n'; else if (d1 &gt; d2) std::cout &lt;&lt; \"d1 &gt; d2\" &lt;&lt; '\\n'; else if (d1 &lt; d2) std::cout &lt;&lt; \"d1 &lt; d2\" &lt;&lt; '\\n'; return 0;&#125;/****结果*****/d1 &gt; d2我们可以看到，在我们的调试模式下，d1 = 0.0100000000000005116 而 d2 = 0.0099999999999997868.【Note】：在两个浮点数非常接近时，如果使用==和!=对浮点数之间比较，结果会不太准确。使用epsilon准确比较浮点数我们可以使用epsilon来相对准确的比较两个 足够接近的 浮点型数值。epsilon：通常被定义为一个小的正数(如，0.00000001，即1e-8)现在，我们来比较两个”close enough”的浮点数：12345678#include &lt;cmath&gt; //for std::abs()//epsilon is an absolute valuebool isAlmostEqual(double a, double b, double epsilon)&#123; //if the distance between a and b is less than epsilon, then a and b are \"close enough\" return std::abs(a-b) &lt;= epsilon;&#125;虽然这个函数可以工作，但它不是很好。0.00001的epsilon值对于1.0左右的输入是合适的，对于0.0000001左右的输入是太大了，对于10,000这样的输入是太小了。这意味着每次我们调用这个函数时，我们必须选择一个适合我们输入的。如果我们知道我们要根据输入的比例来缩放，我们也可以修改函数来做到这一点。改进1：12345678#include &lt;cmath&gt; //std::abs#include &lt;algorithm&gt; //std::max//return true if the difference between a and b is within epsilonbool approximatelyEqual(double a,double b, double epsilon)&#123; return (std::abs(a-b) &lt;= ( std::max( std::abs(a),std::abs(b) ) * epsilon ));&#125;在这种情况下，epsilon不再是一个绝对值，现在是相对于a或b大小的量级。再改进2【推荐】：当浮点数足够接近于0时，上面的方法还是不太行的。改进方法就是：同时使用相对值和绝对值：1234567891011// return true if the difference between a and b is less than absEpsilon, or within relEpsilon percent of the larger of a and bbool approximatelyEqualAbsRel(double a, double b, double absEpsilon, double relEpsilon)&#123; // Check if the numbers are really close -- needed when comparing numbers near zero. double diff&#123; std::abs(a - b) &#125;; if (diff &lt;= absEpsilon) return true; // Otherwise fall back to Knuth's algorithm(相对值方法，即“改进1”的方法) return (diff &lt;= (std::max(std::abs(a), std::abs(b)) * relEpsilon));&#125;在这个算法中，我们首先检查a和b在绝对值上是否接近，这处理了a和b都接近于零的情况。absEpsilon参数应该设置为非常小的值(例如1e-12)。如果失败了，我们就回到Knuth的算法，即，使用相对的epsilon。完整的示例：1234567891011121314151617181920212223242526272829303132333435363738#include &lt;algorithm&gt; //std::max#include &lt;cmath&gt; //std::abs#include &lt;iostream&gt;//如果a和b之间的差值在a和b之间较大值的百分之几内，则返回truebool approximatelyEqual(double a,double b,double epsilon)&#123; return (std::abs(a-b) &lt;= (std::max(std::abs(a), std::abs(b)) * epsilon ));&#125;//针对于接近于0 的浮点数的比较bool approximatelyEqualAbsRel(double a, double b,double absEpsilon, double relEspilon)&#123; //check if the numbers are really close -- need when comparing numbers near zero. double diff &#123;std::abs(a-b)&#125;; if (diff &lt;= absEpsilon) return ture; //otherwise fall back to 相对值法 return (diff &lt;= (std::max(std::abs(a), std::abs(b)) * relEspilon));&#125;int main()&#123; //a is really close to 1.0, but has rounding errors double a&#123;0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1&#125;; std::cout &lt;&lt; approximatelyEqual(a, 1.0, 1e-8);//compare \"almost 1.0\" to 1.0 std::cout &lt;&lt; approximatelyEqual(a-1.0, 0.0, 1e-8); //compare \"almost 0.0\" to 0.0 std::cout &lt;&lt; approximatelyEqualAbsRel(a-1.0, 0.0, 1e-12, 1e-8) &lt;&lt; '\\n'; // compare \"almost 0.0\" to 0.0&#125;/**********结果*********/101可以看出，在对于接近于0的浮点数，与 0.0比较时。approximatelyEqualAbsRel要更加准确。使用approximatelyEqualAbsRel方法，就可以解决大多数情况。它也涵盖了approximatelyEqual函数的功能。5.7 逻辑操作符OperatorSymbolFormOperationLogical NOT!!xtrue if x is false, or false if x is trueLogical AND&amp;&amp;x &amp;&amp; ytrue if both x and y are true, false otherwiseLogical OR||x || ytrue if either x or y are true, false otherwiseNOT：！需要注意的是，NOT 操作符的优先级很高，在level 3。所以，你很有可能会犯这种错误：1234567891011121314151617#include &lt;iostream&gt;int main()&#123; int x&#123;5&#125;; int y&#123;7&#125;; if(!x&gt;y) //正确写法：if (!(x&gt;y)) std::cout &lt;&lt; \"x is not greater than y\\n\"; else std::cout &lt;&lt; \"x is equal to or greater than y\\n\"; return 0; &#125;/********结果************/x is equal to or greater than y可以看出，结果不正确。在这里就是因为，if(!x&gt;y)中，由于!优先级高于&gt;。所以，先计算“!x”，其实，就相当于：if ( (!x) &gt; y )AND： &amp;&amp;如果逻辑操作符&amp;&amp;要返回“true”，那么所有的操作数都必须是‘true’；但如果&amp;&amp;返回是“false”，只要有一个操作数是‘false’即可。特殊的，如果第一个操作数是‘false’的话，就不会再继续看后面操作符是‘false’还是‘true’，即图签终止了。这种情况叫做：“short circuit evaluation”相似的，逻辑操作符 或||，如果要返回“true”的话，也是只要有一个操作数是‘true’即可。逻辑操作符&amp;&amp;的优先级高于||，所以，在使用如：value1 || value2 &amp;&amp; value3时，要更加小心，使用括号才会更加安全。德摩根定律：De Morgan’s law德摩根定律告诉我们，可以这样使用逻辑操作符!：!(x &amp;&amp; y) 等同于 !x || !y!(x || y)等同于 !x &amp;&amp; !y换句话说，当您分发逻辑NOT时，您还需要转换为逻辑AND逻辑OR，反之亦然!逻辑操作符，异或XORLeft operandRight operandResultfalsefalsefalsefalsetruetruetruefalsetruetruetruefalse即，真假 为 真，其他结果都是 假C++没有提供专门提供 异或操作符，但是我们可以使用：当操作数是布尔型的，即true，false，而不是integer，可以使用!=来实现异或：123456if (a != b) //a XOR b ,假定a、b是booleans ... //多个操作数if (a != b != c != d) // a XOR b XOR c XOR d, assuming a, b, c, and d are Booleans ...当操作数不是布尔型时，使用static_cast转化为bool：12if (static_cast&lt;bool&gt;(a) != static_cast&lt;bool&gt;(b) != static_cast&lt;bool&gt;(c)) // a XOR b XOR c XOR d, for any type that can be converted to bool ...","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://longlongqin.github.io/tags/C-C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"计算机科学速成课(总)","slug":"学习笔记/《计算机科学速成课》笔记/计算机科学速成课","date":"2020-04-01T02:29:42.000Z","updated":"2020-04-01T02:49:13.858Z","comments":true,"path":"archives/3ae1bc73.html","link":"","permalink":"https://longlongqin.github.io/archives/3ae1bc73.html","excerpt":"计算机科学速成课","text":"计算机科学速成课###参考文章###：*计算机科学速成课 *：笔记：https://www.cnblogs.com/livil/p/10155073.html 和https://zhuanlan.zhihu.com/p/103505933 或 https://www.imooc.com/article/271502字幕：https://github.com/1c7/Crash-Course-Computer-Science-Chinese/blob/master/(字幕)全40集中英字幕文本2、电子计算机3、布尔逻辑和逻辑门计算机最早是机电设备，一般用十进制计数。也有一些是三进制、五进制的。【也就是x进制表示有x种状态。】二进制中的 1或0 叫做：位（bit）；1字节（byte）=8位(bits)5、算数逻辑单元（ALU）：是计算机的数学大脑，是计算机里负责运算的组件。ALU有2个单元：1个算数单元和1个逻辑单元。算数单元：负责计算机里的所有数字操作。如加减法。1）算数单元(半加器)A half adder:半加器如下所示：将其抽象化，把“把假期”封装成一个单独组件：全加器（Full Adder）:如果想要处理多位二进制数加法时，就需要全加器（Full Adder），因为半加器计算完当前位的结果后，会输出进位，意味着计算下一位的结果时，要将两个输入以及前一位的进位相加。我们可以得到全加器的真值表：全加器真值表![image-20200211205005097](https://longlongqin.gitee.io/image_save/images/assets/image-20200211205005097.png)我们这里可以使用半加器来实现全加器。我们可以将一个半加器结果当做是INPUT A 和INPUT B相加后的结果，然后将SUM当做是新的INPUT A，而PRE CARRY当做是新的INPUT B输入到新的半加器中，可以发现其SUM结果和全加器SUM结果相同。而全加器的CARRY只要对这两个半加器的CARRY进行OR运算就可以了。（注意：这两个半加器不会同时出现进位）同样我们也可以对全加器进行抽象，得到一个包含三个输入和两个输出的独立部件。由此我们可以进行两个8位数字相加，表示为A和B:对A和B的第一位进行相加时，由于不存在进位，所以值使用一个半加器就能实现，这个半加器的SUM就为该位的结果，CARRY就为进位。后续的7位二进制相加，由于每一个都涉及了上一位的进位，所以后续需要7个全加器，并且每个全加器的CARRY要连接到下一个全加器的输入，而每个全加器的SUM就为该位的结果。最后一个全加器有CARRY的输出，如果该CARRY为1，就表示相加结果太大了，超出了8位，所以出现了溢出（overflow）【溢出：一般来说 “溢出” 的意思是, 两个数字的和太大了，超过了用来表示的位数，这会导致错误和不可预期的结果。】。由此，我们就构建出了一个8位加法器（8-bit adder）通过连接1个半加器和n-1个全加器，就能构建n位加法器。通过叠加更多的加法器，能够避免溢出的出现，但是会出现更多的逻辑门，而且每次进位都要一些时间，而计算是串行的，所以消耗的时间也越长，到如今的每秒几十亿次运算时就会造成影响，所以现代计算机用的加法电路有所不同，称为超前进位加法器（Carry-Look-Ahead Adder）。ALU通常支持以下操作：加法、带进位的加法、减法、带借位的减法、取反、增1、减1、数字无改变通过。这些操作也是由逻辑门构成的。注意：简单的ALU并==不==支持乘法，而是把乘法用多次加法来实现，而更好的处理器有专门做乘法的算数单元。2）逻辑单元逻辑单元：执行逻辑操作，比如AND、OR和NOT操作，也能做简单的数值测试，比如数字是不是负数。对整个8位ALU进行抽象，用一个特殊的V形符号进行表示。其中有两个8位输入，并且有一个4位操作码（Operation Code）来告诉ALU对输入执行什么操作，比如1000表示加法命令，1100表示减法命令，然后有一个8位输出。同时ALU会输出一系列1位标志（FLAG），来表示特定状态，比如我们可以计算A-B，然后通过ZERO来判断结果是否为零来判断A与B是否相等，通过NEGATIVE来判断A是否小于B；然后OVERFLOW连接到加法器的进位，来判断是否出现溢出。6、寄存器&amp;内存上节中介绍的ALU进行计算后得到的结果需要对其进行存储，可能还要进行多个连续操作，这就需要用到计算机内存了。计算机使用的是随机存取存储器（Random Access Memory, RAM），其只能在有电的情况下存储东西。另一种存储称为持久存储（Persistent Memory），电源关闭时数据也不会丢失，它用来存其他东西。随机存取存储器(RAM)：只能在有电的时候存储东西。【 内存的一个重要特性：可以随时访问任何位置。所以叫“随机存取存储器(RAM)”】))放入数据的动作叫“写入”，拿出数据的动作叫“读取”。这一节中首先构建能够存储1位的存储器，然后对其扩展来得到内存模块。之前构建的都是单向电路，我们同样可以构建回向电路，把输出连回输入。1、当将OR门构建成回向电路时，可以分析其电路特性：A和B初始为0时，输出结果为0存储0的电路- 将A修改为1时，输出结果为1，此时B的输入就变为了1。随后输出始终保持为1，不论A如何变化。所以这个电路能够永久记录1，并且无法将1变回0。2、同理可以分析下AND门构建成回向电路时的特点A和B初始化为1，则输出结果为1将A修改为0时，输出结果为0，此时B的输入就变成了0。随后输入始终保持为0，无论A如何变化。所以这个电路能够永久记录0，并且无法将0变回1。所以我们就得到了能够存储1和0的电路，为了得到有用的Memory，需要将两个电路结合起来，可以得到AND-OR锁存器（AND-OR Latch），上方的是SET输入，下方的是RESET输入，当SET=1、RESET=0，就能将输出设置为1，当RESET=1，就能将输出设置为0，当SET=0、RESET=0，则输出最后放入的内容。由此能够存储1位的信息（该信息存储在OR门上方的输入电极中）！这叫”锁存”, 因为它”锁定”了一个值，放入数据的动作叫 “写入” ，拿出数据的动作叫 “读取”。对其进行SET和RESET进行合并，并添加其他门控单元，可以得到一个门锁（GATE LATCH）门锁其中DATE INPUT表示数据输入，WRITE ENABLE表示允许写入线，用来控制是否保存当前输入的数据。对这个电路进行分析。可以将门锁进行抽象，得到一个能够存储一个bit的部件。当允许写入线为0时，输出保持不变，当允许写入线为1时，输出就是数据输入，并且能够将数据输入进行存储。门锁的抽象如果我们并排8个锁存器，就能存储8位信息。一组这样的锁存器称为**寄存器（Register）**，寄存器能够存一个数字，这个数字的位数称为寄存器的**位宽（Width）**。写入寄存器之前，要先启动里面所有的锁存器，可以将所有锁存器的允许写入线都连接在一起，把它设为1，然后用8条数据线发送数据，然后将允许写入线设回0，就能将8位数据存储在寄存器中。)寄存器：上面是只能存储1bit的“锁存器”，如果我们并排放8个锁存器，就可以存8位(bits)信息。一组这样的锁存器叫做“寄存器”。1、位宽寄存器能存一个数字，这个数字有多少位，叫做“位宽”。$早期电脑用8位寄存器，然后是16位、32位。如今都有64位宽的寄存器。$)))所以，如64位的寄存器只需要129条线就可以了。【64条是“数据输入线”、“64条数据输出线”、“一条启用写入线”】。如果要存256位，就需要513条线。减少线数的方法就是：矩阵。)所以，对于一个256位的存储：只需要35条。)如果想要访问特定的锁存器（即寻找其地址），（由于行数和列数均只有16，所以均可以用4个二进制位来表示。）就有行号和列号来对应。)))多路复用器：有不同大小。通常包含一定数目的数据输入，有一个单独的输出。把256位内存当成一个整体，抽象化一下：))一个256位内存也不能做什么大事，所以继续扩大：))))再次，看成一个整体：下图中：我们有256个地址，每个地址能读或写一个8位(bit)的值。)))))这一节用锁存器做了一块静态随机存取存储器（Static Random-Access Memory，SRAM），还有很多其他类型的RAM，比如DRAM、闪存和NVRAM，它们的功能和SRAM相似，但是使用不同的电路存放单个位。但是根本上，这些技术都是矩阵层层嵌套来存储大量信息。7、中央处理器(CPU)CPU负责执行程序，程序由一个个操作组成，这些操作叫“指令(instruction)”。如果是数学指令，比如加减，CPU会让ALU进行数学运算。如果是内存指令，CPU会和内存通信，然后读写值。9、高级CPU设计RAM是CPU之外的独立组件，意味着数据要用线来传递，这个线叫做“总线（BUS）”。$总线可能只有几厘米，虽然电信号传输速度接近光速，但是CPU每秒可以处理上亿条指令，很小的延迟也会造成问题。$)提升性能方法一：缓存一条“从内存读数据”的指令可能需要多个时钟周期，而此时CPU空等数据。解决延迟的方法之一是给CPU加一点RAM,叫：“缓存(Cache)”。因为处理器的空间不大，所以缓存一般只有KB或MB，而RAM都是GB起步。缓存提高了速度：当CPU从RAM拿数据时，RAM不用传一个，可以传一批。虽然花的时间多一点，但数据可以存在缓存。这很实用，因为数据常常是一个个按顺序处理。比如：算餐厅的当日收入时，先取RAM地址为100 的交易额，RAM与其只给一个值，不如直接给一批值，把地址为100~200的数据都复制到缓存中。当处理器要下一个交易额（地址为101的）时，缓存就会告诉处理器：“我已经有这个数据了，现在就给你”。就不用再去RAM取数据了。)当想要的数据已经在缓存中时，这种状态叫“缓存命中（Cache Hit）”；如果不在，则叫“缓存未命中（Cache Miss）”。缓存也可以当临时空间，存一些中间值，适合长的或者复杂的运算。继续餐馆的例子：假设CPU算完了一天的销售额，想把结果存到地址为150的地方。就像之前，数据不是直接存到RAM中，而是存在缓存中。这样不但存起来快一些、如果还要接着计算，取值也会快一些。但是这会导致：缓存和RAM中的数据不一致。因此缓存里每块空间有一个特殊标记，叫：“脏位（Dirty Bit）”。同步一般发生在：当缓存满了而CPU又需要缓存的时候。在清理缓存腾出空间之前，会先检查“脏位”，如果是“脏”的话，在加载新内容之前，会把数据写回RAM。![演示 (3)](https://longlongqin.gitee.io/image_save/images/assets/演示 (3).gif)提升性能方法二：“指令流水线”指令流水线：instruction pipelining例如：如果你想要洗一整个的床单，但只有一个洗衣机和一个烘干机。选择一：按顺序，先放洗衣机洗30分钟，然后在烘干机30分钟。共计1小时。选择二：像一中一样，先放一批床单到洗衣机30分钟，然后把它放到烘干机中。但是这时候要等30分钟才能烘干。此时，可以放另一批床单到 洗衣机（此时，洗衣机，烘干机在同时工作），依次，直到洗完所有床单。效率是一的2倍。处理器也可以这样设计，CPU是按顺序处理的：(读)取指(令)——&gt;解码——&gt;执行。不断重复：但是每个阶段都是用的CPU的不同部分，意味着可以并行处理：“执行”一个指令时，同时“解码”下一个指令，同时，“读取”下下条指令。这样的流水线，每一个时钟周期执行1个指令，吞吐量乘3.但是，和缓存一样，这也会带来一些问题：问题1：指令之间的依赖关系。)因此流水线处理器，要先弄清楚数据依赖性。必要时停止流水线，避免出问题。高端的CPU，会最小化流水线的停工时间，这叫“乱序执行”。问题二：“条件跳转”，比如之前的JUMP NEGATIVE（类似循环跳转）。这些指令会改变程序的执行流。)空等会造成延迟。​ 技巧：“推测执行”)))))为了尽可能减少清空流水线的次数，CPU厂商开发复杂的方法：“分支预测”。现在这种猜测的正确率超过90%。在理想情况下，CPU在一个时钟周期完成一个指令。但是“超标量处理器”的出现，一个时钟周期可以完成多个指令。用“多核处理器”【双核、四核处理器：意思是一个CPU芯片里，有多个独立的处理单元，”看起来就像有多个独立的CPU”。但因为他们整合紧密，可以共享一些资源如，缓存，使得多核可以合作运算。】。当多核不够时，可以用多个CPU。10、早期的计算机编程​ 之前的程序是用插线板编程，到后来（1940年代晚期到1950年代初）内存的价格下降，容量上升，使得程序存入内存变得可行。程序存入内存中易于修改、方便CPU快速读取，这类机器叫做：“存储程序计算机（Stored-program Computers）”。内存足够时，还可以存储程序需要的数据（包括运行时产生的数据）。这种将程序和数据存储在一起的存储结构，叫“冯诺依曼结构”。​ 冯诺依曼计算机的标志是，一个处理器（有算数逻辑单元）+数据寄存器+指令寄存器+指令地址寄存器+内存（负责存数据和指令）。11、编程语言发展史​ 计算机只能处理二进制，其实，“机器语言（Machine Language）”或“机器码（Machine Code）”。在计算机早起，还必须要用机器码 些好吃呢供需，一般会先对程序进行高层次的功能描述，称为“伪代码（Pseudo-code）”，只是助于程序员理解无法让计算机运行，然后根据指令表将伪代码转换成二进制机器码，然后将机器码送入计算机中运行。​ 在1940-1950年，程序员开发出一种新语言，更可读、更高层次，每个操作码分配一个简单名字，称为助记符（Mnemonics），助记符后跟数据，形成完整的指令。如下图所示：所以与其写0和1的机器码，程序员可以直接写“LOAD_A 14”，这个语言称为汇编语言（Assembly Language）。当然计算机无法理解“LOAD_A 14”，所以程序员们写了一个程序来将文字指令自动转换成二进制指令，这个程序称为汇编器（Assembler），$汇编器读取汇编语言写的程序，然后转换成机器码$。随着发展，汇编器有越来越多的功能使得编程更加容易，其中一个功能就是自动分析JUMP地址。如下图，JUMP后面跟的是内存中的真实地址，如果我们在上方对程序进行修改，则后面的所有地址都会改变。所以汇编器不用固定跳转地址，而是让你插入可跳转的标签，当程序传入汇编器，汇编器就会自己推算出跳转地址，这样就程序员就无序过分关注细节。​ $汇编代码例子$汇编只是修饰了一下机器码，一般来说，一条汇编指令对应一条机器指令，所以汇编码和底层硬件连接很密切，程序员仍需要思考使用什么寄存器和内存地址。为了释放电脑的潜力，霍普设计了一个高级编程语言，叫做Arithmetic Language Version 0，简称A0。一行高级编程语言，可能会转换成几十条二进制指令。为此做到这种复杂转换，霍普在1952年创造了第一个编译器（Compiler），编译器专门把高级语言转换成低级语言（比如汇编 或 机器码）。由此，高级编程语言就不用管寄存器或内存位置，编译器会解决这些细节。在1950年，大多数编程语言和编译器只能运行在一种计算机中，如果更换计算机，就要重写所有代码，因此1959年开发一种通用编程语言，可以在不同机器上通用，最后诞生了一门高级、易于使用的语言普通面向商业语言（Common Business-Oriented Language，COBOL）。为了兼容不同底层硬件，每个计算机架构需要一个COBOL编译器，由此无论运行的计算机是什么，这些编译器可以接收相同的COBOL代码。如今大多数编程语言都是如此，不必接触CPU特有的汇编码和机器码。12、编程原理-语句和函数a=5;是一个编程语言的语句。程序由一个个指令组成。13、算法入门算法：解决问题的具体步骤。14、数据结构数据是以什么形式存在内存里呢？我们希望数据是结构化的，方便读取，由此发明了数据结构。14.1 数组Array一个变量只能存储一个值，而一个数组变量能够保存多个同类型值，并且数组的值是一个个连续存在内存中的。为了取出数组中的某个值，我们需要指定一个下标（Index）。大多数编程语言中，数组的下标都从0开始。下图是数组保存在内存中的形式，为了简单，假设编译器从内存地址1000开始保存数组，数组中的内容就像图中那样顺序保存在内存中。定义该数组变量为j，则j[0]会取内存地址1000的数据来获得第一个元素的值， j[5] 则会去内存地址1000加5个偏移量得到内存地址1005中保存的数据。缺点：创建数组时就要固定大小，不能动态增加大小，并且数组在内存中是按顺序存储的，在中间插入一个值很困难。14.2 字符串String类似于数组，其实就是字母、数字、标点符号等构成的数组。我们在第4节中有讨论了计算机怎么存储字符的，通过ASCII或者Unicode编码，将字符转换为对应的二进制数。写代码时，可以直接用引号括起来构建字符串j=&quot;Hello World&quot;， 其在内存中的存储形式如下图。注意：字符串在内存中以二进制0结尾，表示字符串结尾，用来给别的函数指示什么时候字符串结束了。14.3 矩阵Matrix之前保存的都是一维数组，但是像电子表格或屏幕像素，都需要保存二维信息，所以这里就需要用到矩阵。可以将矩阵看成是数组的数组，比如一个3x3矩阵， 相当于就是一个长度为3的数组，而这个数组中的每个元素又是一个长度为3的数组。矩阵保存在内存中的形式如下图所示，这里使用的是行优先存储，即优先将矩阵的每一行保存在内存的相邻位置，当一行保存完后，再保存下一行。矩阵例子![img](https://longlongqin.gitee.io/image_save/images/assets/v2-f4e8c5b992abea5477f71fcf39702a68_hd.jpg)内存中的矩阵为了获取一个值，需要两个小标，比如`j[2][1]`表示从内存地址1000偏移`2*3+1=7`位置，得到元素12。这里偏移量的计算方法是`行索引*列元素个数+列索引`。我们不仅能构建二维矩阵，我们可以构建任意维度的矩阵。14.4 结构体Struct目前我们只将单个数字或字符存在数组或矩阵中，在数组中保存的都是相同类型的元素。如果我们想把几个有关系的变量存储在一起，并且这些变量都是不同类型的，我们就需要用到结构体。…..16、软件工程为了写大型程序，程序员用各种工具和方法，所有这些形成了软件工程学科。将大项目分解成小函数可以让很多人同时工作，由此他们无需关心整个项目，只要关心自己的函数就好了。但是这种抽象程度还是不够，大型项目中可能还是会存在大量的函数，因此需要将函数打包成层级，将相关代码放在一起，打包成对象（Object）。比如汽车软件中，可能有几个和定速巡航有关的函数，因此我们可以包装一个“定速巡航对象”来打包这些函数，我们还可以更进一步，“定速巡航”只是引擎软件的一部分，可能还有“火花塞点火”、“燃油泵”和“散热器”等等，因此我们可以做一个“引擎对象”来打包所有子对象，并且除了子对象，引擎对象还会包含自己的函数，比如“开关引擎”，也会有自己的变量，比如汽车行驶里程数。总的来说，对象可以包含其他对象、函数和变量。然后当你想调用一个比较底层对象的函数时，只需要层层向下调用就行，比如Car.Engine.CruiseControl.setCruiseSpeed(55)。这种将函数打包成对象的思想称为面向对象编程（Object Oriented Programming）。相同的想法都是通过封装组件来隐藏复杂度。把大型软件拆成一个个更小单元，会更适合团队合作。但是各个团队之间的代码是相互交织的，比如团队A实现的某个函数需要团队B的代码支持，因此团队需要文档（Documentation）来帮助理解代码都做什么，以及定义好的程序编程接口（Application Programming Interface，API）。这样，即使程序员不知道具体的实现细节，也能直接使用API调用相应的函数。并且API能控制哪些函数和数据是对外开放的，哪些是仅供对象内部使用的，面向对象的编程语言可以指定函数时public或private来设置权限，避免用户调用错了函数造成bug。如果标志为private，表示只有同一个对象内的其他函数能调用它， 所以在这个例子中，只有内部函数比如setRPM能够调用 fireSparkPlug函数，并且由于setRPM函数是public的，所以其他对象可以调用它。面向对象编程的核心：隐藏复杂度，选择性的公布功能。现代软件开发者会使用专门的工具来写代码，工具里集成了很多功能帮助写代码、整理、编译和测试，这些软件称为集成开发环境（Integrated Development Environments，IDE）。程序员一个重要的工作部分是给代码写文档，一般放在一个叫README的文件中， 文档也能直接写成注释放在源代码中。除了IDE，还有一个重要软件帮助团队协作，称为源代码管理（Source Control）。比较大型的公司会将代码放在一个中心服务器上，称为代码仓库（Code Repository）。当程序员想改一段代码时，可以check out获得代码，然后开发者在自己电脑上编辑代码，当代码没有问题，所有测试都通过时，就能将代码放回代码仓库了，称为提交（Commit）。当代码被check out，并且可能被改过了，其他开发者就不会动这段代码，避免代码冲突和重复劳动。代码的主版本（master）应该总是编译正常，尽可能少bug。并且源代码管理可以跟踪所有变化，当出现bug时，全部或部分代码可以回滚（Rolled Back）到之前的稳定版本，并且也能记录下代码修改者。测试代码一般由个人或小团队完成，测试可统称为质量保证测试（Quality Assurance Testing，QA）。“alpha version”软件一般很粗糙，错误很多，经常只在公司内部操作，而“beta version”软件指的是软件接近完成，但不是完全测试通过，公司有时会向公众发布beta版，以帮助发现问题，用户就像免费的QA团队。17、集成电路&amp;摩尔定律过去计算机的飞速发展，强烈依赖于硬件的发展。大约1940年代-1960年代中期，计算机都由独立部件组成，称为分立元件（Discrete Components），然后不同组件再用线连在一起。比如ENIAC有1万7千多个真空管，7万个电阻，1万个电容，7千个二极管，5百万个手工焊点。如果想要提升性能，就要加更多部件，这就导致了更多更复杂的电线，这个称为数字暴政（Tyranny of Numbers）问题。到1950年代中期，晶体管开始商业化，开始用于计算机中，晶体管比电子管更小更快更可靠，但晶体管依然是分立元件。1959年，IBM把709计算机从原本的电子管全部换成晶体管，诞生了IBM 7090，速度快6倍，价格只有一半。晶体管标志着计算机2.0时代的到来，但是晶体管的出现还是没有解决数字暴政的问题，有十几万个独立元件的计算机不但难设计，而且难生产。集成电路（Integrated Circuits，IC）：到1960年代，这个问题的严重性达到顶点，解决方法就是引入一层新抽象，封装复杂性。突破性进展在1958年，与其把多个独立部件用电线连起来，拼装出计算机，我们把多个组件包在一起，变成一个新的独立组件，这个称为集成电路（Integrated Circuits，IC）。几个月后，仙童半导体就让集成电路变成现实，之前使用锗来做集成电路，但是锗很稀少且不稳定，仙童半导体使用硅，因为硅的蕴藏量丰富，也更稳定可靠。起初，一个IC只有几个晶体管，但是也足以将逻辑门封装成独立组件，可以组合出无数种设计，但是最终还是要连起来，创造出更大更复杂的电路，比如计算机。所以创造出了印刷电路板（Printed Circuit Boards，PCB），可以大规模生产，无需焊接或用一堆线，它通过蚀刻金属线的方式将零件连接到一起。把PCB和IC结合使用，可以大幅减少独立组件和电线，但做到相同的功能，而且更小更便宜更可靠。不过即使组件再小，塞5个以上的晶体管还是很困难，为了实现更复杂设计，出现了全新的制作工艺——光刻（Photolithography）。简单来说，就是用光把复杂图案印到材料上，比如半导体。它只有几个基础操作，但是可以制作出复杂电路。首先，我们从一片硅开始，称为晶圆（Wafer），长得和薄饼干一样。并且硅是半导体，有时导电有时不导电，我们就可以控制导电时机，所以硅是做晶体管的绝佳材料。我们可以用晶圆做基础，把复杂金属电路放上去，来集成所有东西。在硅片顶部加一层薄薄的氧化层（Oxide Layer）作为保护层，然后加一层特殊化学品称为光刻胶（Photoresist），光刻胶被光照射后，就变得可溶，可以用一种特殊化学药剂洗掉。然后我们会在光刻胶上加一层光掩膜（Photomask），当用强光照射时，挡住光的部分光刻胶就不会变化，而光照射到的地方，光刻胶就会发生化学变化，洗掉变化的光刻胶后，就会暴露出部分氧化层。然后通常用酸能洗掉氧化层暴露出的部分，就能蚀刻到硅层。然后再用另一种化学试剂清洗掉剩余的光刻胶，这样只剩下氧化层和晶圆了。我们想修改硅暴露出来的区域，让它们导电性更好，所以我们使用掺杂（Doping），通过将磷渗透进暴露的硅，来改变电学性质。我们还需要几轮光刻法来做晶体管。还是叠加上氧化层、光刻胶和新的光掩膜，这样就能在掺杂区域上方开缺口，然后进行清洗蚀刻，再用另一种元素进行掺杂，把硅转换成另一种形式。为了控制深度，时机很重要，不要超过之前掺杂的区域，这样所有需要的组件都有了。最后，在氧化层上做通道，这样可以用细小金属导线连接不同晶体管。首先用光刻胶和光掩膜，在氧化层上蚀刻出小通道。然后用新的处理方法称为金属化（Metalization），在氧化层上放一层薄薄的金属，比如铝或铜，再加上光刻胶和光掩膜，然后融掉暴露的光刻胶，暴露出金属。最终清洗，只保留晶圆、氧化层和金属化，这样就做出了一个晶体管。它有三根线分别连接着硅的三个不同区域，每个区域的掺杂方式不同，这个叫双极型晶体管（Bipolar Junction Transistor）。晶体管相同方法，光刻可以在一片硅上制作其他电子元件，比如电阻电容，而且相互连接的电路也做好了。并且通过调节光掩膜和光源之间的距离，光可以投射成任意角度，我们可以把光掩膜聚焦到极小的区域，制作出非常精细的细节，这样一片晶圆就能做出很多IC，整块都做完后，就可以切割然后包进微型芯片中，芯片的核心都是一小片IC。随着光刻技术发展，晶体管变小，密度变高。1960年初，IC很少能超过5个晶体管，但到了1960年中期，市场上已经开始出现超过100个晶体管的IC。摩尔定律（Moore’s Law）:1965年，戈登·摩尔看到了发展趋势，提出摩尔定律（Moore’s Law）：每两年左右，得益于材料和制造技术的发展，同样大小的空间，能塞进两倍量的晶体管。晶体管更小密度更高，要移动的电荷量就越少，能快速切换状态，耗电更少。并且电路更紧凑，意味着信号延迟更低，导致时钟速度更快。集成电路的出现，尤其是用来做微处理器，开启了计算机3.0时代。到了2010年，一个IC中有10亿个晶体管。为了达到这种密度，光刻的分辨率从大约一万纳米，发展到如今的14纳米。现代工程师设计电路时，不是手工一个个设计晶体管的，从1970年代开始，超大规模集成（Very-large-scale Integration，VLSI）软件用来自动生成芯片设计。用比如逻辑综合（Logic Synthesis）可以放一整个高级组件，比如内存缓存，软件会自动生成电路，做到尽可能高效，许多人认为这是计算机4.0时代的开始。但是摩尔定律现在迎来了终结，进一步做小，会迎来两个问题：用光掩膜把图案弄到晶圆上，因为光的波长，精度已经到达极限。所以科学家在研制波长更短的光源，投射更小的形状。当晶体管非常小，电极之间可能只距离几个原子，电子就会跳过间隙，称为量子隧道贯穿（Quantum Tunneling），由此晶体管就不能正常工作了。18、操作系统40 50年代的电脑，每次只能运行一个程序，程序员在打孔纸上写程序，然后再放入计算机中进行计算，一开始计算机速度比较慢，通常一个程序需要运行几天时间，所以放程序的时间还能忍受。但是随着计算机运算速度的告诉发展后，放程序的时间比程序运行时间还要长，我们就需要一种方式，让计算机自动运行，于是诞生了操作系统（Operation Systems，OS）。操作系统其实也是程序，但它有操作硬件的特殊权限，可以运行和管理其他程序。操作系统一般是开机第一个启动的程序，然后其他所有程序都由操作系统启动。从1950年代开始有操作系统，那时计算机开始变得更加强大， 第一个操作系统主要加强了程序加载方式，取代了手工加载程序的过程。之前只能一次给一个程序，现在可以一次多个程序，当计算机运行完一个程序后，就会自动运行下一个程序，这样就不用浪费时间找下一个程序的纸卡，这称为批处理（Batch Processing）。随着计算机的发展，计算机出现在大学和政府办公室，人们开始分享软件，但是有个问题。在哈佛1号和ENIAC那个时代，计算都是一次性的，程序员只需要给特定一台机器写代码，其中处理器、读卡器和打印机都是已知并且不会改变的。但是随着计算机越来越普遍，计算机配置并不总是相同的，比如计算机可能有相同的CPU但是不同的打印机等等，这样程序员不仅要担心程序，还要担心程序怎么和不同型号的打印机进行交互，以及计算机连着的其他设备，统称为外部设备（Peripherals）。和早期的外部设备交互是非常底层的，程序员需要了解设备的硬件细节，但是程序员又很少能拿到所有型号的设备来测试代码。所以一般是阅读手册然后尽可能编写代码。所以为了能够更好地写软件，操作系统就充当软件和硬件之间的媒介。更具体的，操作系统提供API来抽象硬件，叫设备驱动程序（Device Drivers）。这样程序员可以通过标准化机制和输入输出硬件（Input &amp; Output，I/O）进行交互，而无需关注硬件型号以及具体硬件细节。到1950年代末尾，电脑已经运行非常快了，处理器经常需要等待较慢的机械设备（比如打印机和读卡器），程序就阻塞在I/O上，而处理器什么都没有进行处理。英国曼彻斯特大学开始研发世界上第一台超级计算机Atlas，由于机器运算非常快，所以需要一种方式来尽可能利用更多的算力。他们于1962年年设计了一个程序叫Atlas Supervisor，使得操作系统不仅能进行批处理，并且通过调度（Scheduling）还能在单个CPU上同时运行几个程序。比如我们需要调用print函数让Atlas打印一个变量值，由于打印机比CPU慢很多，所以print函数需要运行比较长的时间。与其等待打印机完成打印，Atlas会将该程序进行休眠，然后运行其他等待的并且可运行的程序。最终当打印机打印完后，会报告给Atlas，则Atlas会将之前的程序标记为“可运行”状态，然后在某个时刻会安排给CPU继续运行print函数下一行代码。由此，Atlas能够在CPU上运行一个程序，同时另一个程序在打印数据（这里是让打印机自己在打印，所以无需CPU进行参与），同时另一个程序读数据（这里只需要使用读卡器，不需要CPU）。Atlas配有4台读取器、4台打印机和8个磁带驱动器。使多个程序可以同时运行，在单个CPU上共享时间。操作系统的这种能力称为多任务处理（Multitasking）。但是同时运行多个程序存在一个问题，每个程序都会占用一些内存，当切换到另一个程序后，我们不能丢失这些内存中的数据。所以我们给每个程序分配专属内存块，比如我们计算机一共有10000个内存地址，然后程序A分配到了0-999的内存地址，程序B分配到1000到1999，以此类推。如果一个程序请求更多内存，操作系统就会决定是否同意，如果同意，就要决定分配哪些内存块，这就使得程序A可能会分配到非连续的内存块，使得程序员能难进行跟踪。内存中程序分配**处理分配的内存不连续的情况--动态内存分配**$如果同意，就要决定分配哪些内存块，这就使得程序A可能会分配到非连续的内存块，使得程序员能难进行跟踪。$为了隐藏这种复杂性，操作系统会把内存地址进行虚拟化，称为虚拟内存（Virtual Memory）。程序可以假定内存总是从地址0开始，而实际的物理位置，被操作系统隐藏和抽象了。以程序B为例，它分配了内存地址1000到1999，但是对于程序B而言，它能看到的地址是0到999，操作系统会自动处理虚拟内存和物理内存之间的映射，所以程序B要地址42，实际需要物理地址1042。对于程序A，它被分配了分散的物理内存块，但是程序A并不知道，它所能看到的是连续的从0到1999的地址，当程序A读内存地址999时，会被映射到物理地址999，而当程序A读内存地址1000，则会被映射到物理地址2000。虚拟内存例子这种机制使得程序的内存大小可以灵活增减，称为**动态内存分配（Dynamic Memory Allocation）**。对程序而言，内存看起来是连续的，为操作系统同时运行多个程序提供了极大的灵活性，程序员只需要根据连续的虚拟内存地址进行编程，无需考虑程序在实际物理内存中不连续的物理内存块。同时给每个程序分配一个专用的内存块，可以使得隔离起来更方便。如果一个程序出错了，在内存中胡乱写数据，它只能在自己分配的内存块中进行操作，不会影响到其他程序的数据，这个称为内存保护（Memory Protection）。这对于防止恶意软件是否有效。Atlas是第一台提供虚拟内存和内存保护功能的操作系统。到1970年代，大学会购买电脑给学生使用，此时计算机不仅能同时运行多个程序，还能让多个用户同时访问。多个用户使用终端（Terminal）来访问计算机（这里的终端只有键盘和屏幕，然后连接到计算机），终端本身并不具有处理能力。这样计算机不仅要能处理多个程序，还要处理多个用户，为了确保其中一人不会占满计算机资源，开发了分时操作系统（Time-Sharing），指的是每个用户只能用一小部分处理器、内存等，因为计算机很快，所以即使只有一小部分资源，也足以完成很多任务。早期分时操作系统中，最有影响力的是1969年发布的Multics，它是第一个从设计时就考虑到安全性的操作系统。开发人员不希望恶意用户访问不该访问的数据，这使得操作系统的复杂度远超当时的平均水平，通常内存的一半都要用来运行操作系统，这种过度设计使得Multics未能获得商业成功。所以研究员们重新打造了一个操作系统Unix，他们想把操作系统分成两部分：操作系统的核心功能，比如内存管理，多任务和输入输出处理，这个称为内核（Kernel）。一些有用的工具，但是他们不是内核的一部分，比如程序和运行库。紧凑的内核意味着功能没有之前那么全面。当内核出现崩溃时，Multics有很多操作来进行恢复，但是Unix是没有办法恢复的，会直接调用一个panic函数，最初只能无限循环打印panic。这种简单性意味着Unix可以再更便宜的硬件上运行。1971年发布之后，就有人写了不同编程语言的编译器，甚至文字处理器，使得Unix迅速成为1970-80年代最流行的操作系统之一。到1980年代早期，个人电脑逐渐出现，这些电脑比大型主机简单很多，主机一般在大学、公司和政府，因此操作系统也要变得简单。于1981年微软发布的磁盘操作系统MS-DOS只有160kb，虽然缺少多任务和保护内存这样的功能，意味着程序经常使系统崩溃，用户可以直接重启。即使在1985年发布的早期windos，也一样缺少内存保护功能，当程序错误时，就会出现蓝屏。现代的操作系统包含了多任务、虚拟内存和内存保护机制，因此可以同时运行多个程序。19、内存&amp;存储介质一般来说，电脑内存是非永久性的（Non-Permanent），如果电脑关机，则内存中的所有数据都会丢弃，所以内存叫易失性存储器（Volatile Memory），还存在另一种存储器（Storage），存储器（storage）和内存（memory）存在一定的不同。任何写入storage的数据，就会一直保存，直到被覆盖或删除，断点也不会丢失，称为非易失性（Non-volatile）。过去是易失性的速度快，非易失性的速度慢，但随着技术发展，两者的差异越来越小。最早的存储介质是打孔纸卡以及打孔纸带，到1940年代，纸卡标准是80列x12行，能够存储960位数据。纸卡用了十几年，因为不用电而且便宜耐用，但是读取速度较慢，只能写入一次，对于存临时值，纸卡不好用，我们需要更大更灵活的存储方式。延迟线存储器：1944年时，出现了延迟线存储器（Delay Line Memory）。原理：假设你有一个装满液体（如水银）的管子，管子一端放着扬声器，另一端放着麦克风，当扬声器发出脉冲时，就会在管子内产生压力波，经过一段时间后压力波会传递到麦克风，然后麦克风将压力波转换为电信号，通过在麦克风后面接一个放大器（AMPLIFIER），然后连回扬声器，我们就能用压力波的传播延迟来存储数据。假设有压力波代表1，没有代表0，扬声器发出一系列压力波，因为传播延时的原因，这些压力波会存在管子内，当撞击到麦克风后，又会通过扬声器重新回到管子，所以就能将数据保存在管子内。在1949年的EDVAC计算机中使用了延迟线存储器，总共有128条延迟线，每条能存352位，一共能保存45000位。这使得EDVAC成为最早的存储程序计算机之一。缺点：但延迟线存储器的缺点是，每个时刻只能读一位数据，如果想访问一个特定的位，就要等待它从循环中出现，所以又被称为顺序存储器Sequential Memory）或者循环存储器（Cyclic-Access Memory）。而我们想要随机存取存储器（Random Access Memory），可以随时访问任何位置。并且增加内存密度也是一个挑战，如果要将压力波变得更紧密，就会使其混在一起，所以出现了其他类型的延迟线存储器，比如磁致伸缩延迟存储器（Magnetostrictive Delay Lines），它通过金属线的振动来代表数据。磁芯存储器：但是延迟线存储器在1950年代中期就过时了。因为出现了新技术，于是出现了，磁芯存储器（Magnetic Core Memory），它用了环状磁圈，如果给磁芯绕上电线并施加电流，就能将其磁化在一个方向，如果关掉电流，磁芯还会保持磁化，如果施加了相反方向的电流，则磁化方向会翻转。这样我们就能通过磁化方向来存储0和1，就能用来存储1位。通过将磁芯排列成网格状，有线路负责选择行和列，也有电线贯穿每个磁芯，用于读写1位。磁芯存储器如果要存的数据超过1bit，就需要把磁芯存储器排列成网格：1953年麻省理工的Whirlwind1计算机第一次大规模使用磁芯内存，磁芯排列使用32x32，用了16块板子，大约能存储16000位。不像延迟线存储器，磁芯存储器能随时访问任何一位，因此从1950年代中期成为主流，流行了20多年，将存储成本从1美元1位降低到了1美分左右。磁带：到1951年，UNIVAC电脑推出了一种新存储——磁带（Magnetic Tape）。磁带是纤薄柔软的一长条卷在轴上的磁性带子，磁带可以在磁带驱动器内前后移动，里面有一个缠绕了电线的写头（Write Head），通过电流来产生磁场，导致磁带的一小部分被磁化，电流方向决定了极性，代表1和0。同样还有一个读头（Read Head），可以非破坏地检测极性来确定数据。缺点：磁带的主要缺点是访问速度，磁带是连续的，必须倒带或快进到特定位置。50 60年代出现了类似的技术磁鼓存储器（Magnetic Drum Memory）,有一个金属圆管，盖满了磁性材料来记录数据，圆管会持续旋转，周围有数十个读写头，等圆管转到了正确的位置，读写头就会读或写数据。但到了1970年代磁鼓存储器就不再生产了，但是磁鼓导致了硬盘（Hard Disk Drives）的发展，磁盘的好处是薄，可以叠在一起来提供更多表面积来存储数据。要访问某个特定位，一个读写磁头会上下移动，找到正确的磁盘，然后磁头会滑进去，就和磁鼓存储器一样，磁盘也会高速旋转，所以读写头要等到正确的部分旋转过来，这个称为寻道时间（Seek Time）。以下是内存层次结构（Memory Hierarchy），有一小部分高速且昂贵的内存，一部分稍慢且相对便宜的内存，还有更慢且更便宜的内存，这种混合可以在成本和速度之间取得平衡。其次还有软盘（Floppy Disk），除了磁盘是软的，其他都一样。后面出现的光盘（Compact Disk，CD）以及DVD，它们不使用磁性来保存数据，而是使用表面的小坑来造成光的不同反射，通过光学传感器捕获并解码为1和0。光盘表面如今成本下降了更多的存储技术在朝**固态（Solid State）**前进，**机械硬盘（hard disk drive，HDD）**被**固态硬盘（Solid State Drive，SSD）**逐渐代替。由于SSD没有机械活动部件，里面都是集成电路。因为不存在机械活动，所以磁头不用等磁盘旋转，所以固态速度快很多，但是仍然比RAM慢很多，所以现代计算机仍然使用存储层次结构。20、文件系统上一节中介绍的数据存储。存储器可以在断电状态下长时间存上万亿位，所以非常适合用来存一整块有关系的数据（或者称为文件（Files）），比如文本文件、音乐文件、照片和视频。这一节将讨论文件是什么以及计算机是怎么管理文件的。随意排列文件的数据是没有问题的，但按格式排列会更好，这个称为文件格式（File Format）。首先看一个最简单的文件格式——文本文件（Txt File，txt）。就像其他文件一样，文本文件只是一长串二进制数，可以通过ASCII编码将其解码成对应文本。波形文件：波形文件（WAV）**波形文件（Wave File，WAV）**用于存音频数据。在正确读取数据之前，我们需要知道一些信息比如码率，以及是单声道还是立体声，这种描述数据的数据称为**元数据（Meta Data）**。元数据保存在文件开头，在实际数据之前，因此也叫**文件头（Header）**。以下是WAV文件的前44个字节，有些部分会根据数据进行变化。[^元数据]: 元数据（Metadata），又称中介数据、中继数据，为描述数据的数据（data about data），主要是描述数据属性（property）的信息，用来支持如指示存储位置、历史数据、资源查找、文件记录等功能。WAV格式的数据的元数据而音频数据就紧跟在元数据之后，也是一长串二进制数，这些数字代表每秒捕获多次的声音幅度。麦克风首先会对声音进行每秒上千次采样，每次采样可以用一个数字表示，声压越高数字越大，称为**振幅(Amplitude)**，这就是WAV文件中存储的数据。播放声音时，扬声器就会产生相同的波形。位图(Bitmap)再来谈谈位图，其后缀为bmp，用于保存图片。。计算机中，图片由多个像素(Pixel)方块组成，每个像素由三种颜色组成：红、绿、蓝，叫“加色三原色”，混合在一起能产生其他颜色。类似于WAV文件，BMP文件开头也是元数据，有图片宽度、图片高度和颜色深度等等。现在假设图片宽高均为4个像素，颜色深度为24，也就是8位(bit)红色、8位绿色和9位蓝色，则每个颜色有0-255程度，然后依次保存每个位置的三原色数值。位图的元数据![image-20200223203327886](https://longlongqin.gitee.io/image_save/images/assets/image-20200223203327886.png)位图的数据通过以上例子，可以知道，文件底层都是二进制数，为了知道文件是什么，文件格式就十分重要。计算机如何存储文件：最简单存储多个文件的方法是将文件连续存储，但是这样怎么知道文件开头和结尾在哪呢？存储器并没有文件的概念，它只是用来存储大量二进制数。所以我们需要特殊文件来记录其他文件的位置，这里称为目录文件（Directory File），它通常保存在存储器最开头，方便寻找。storage在目录文件中，存有其它所有文件的名字，格式为`文件名+点+扩展名`， 扩展名有助于得知文件类型。目录文件还保存了文件的元数据，比如创建时间、最后修改时间、文件所有者、是否能读写，最重要的是记录了文件起始位置和长度。目录文件如果要添加、删除文件或者更改文件名，必须更新整个目录文件。目录文件以及对目录文件的管理，是最基本的文件系统（File System）的例子，文件系统专门负责管理文件。刚刚的例子叫平面文件系统（Flat File System），因为所有文件都在同一层次。存在一个缺点：当我们想要对中间文件增加数据时，就会覆盖后续文件的数据。所以现代文件系统会做两个处理：将空间划分成一块块，会出现一些预留空间（Slack Space），可以方便改动。同时文件数据都对齐到了相同大小，可以方便管理。使用这种方案，目录文件就要记录文件在哪些块中。拆分文件保存在多个块中。假设todo.txt文件中加了一些数据，使得文件太大无法存在一个块中，则文件系统会分配一个没使用的块来容纳额外的数据，则目录文件对每个文件就会记录不止一个块，而是多个块。通过分配块，文件就可以轻松增加减小。如果想要删除carrie.bmp，只要在目录文件中删除对应记录就行，让这一块空间变成可用的，这样就不需要进行擦除，只需要直接删除记录就行。在那一块被新数据覆盖之前，数据还是保存在原处的。所以恢复删除数据是有可能的。当文件过大，保存在若干个块中，这个称为碎片（Fragmentation），碎片是增删改文件导致的，无法避免，但是会造成性能下降。解决方法是通过碎片整理（Defragmentation），计算机会将数据来回一定，排列成正确的顺序，就能很方便地进行读写。碎片整理前![image-20200223204733889](https://longlongqin.gitee.io/image_save/images/assets/image-20200223204733889.png)碎片整理后随着容量爆炸式增长，文件数量飞速增加，平面文件系统逐渐应付不来，所以出现了**分层文件系统（Hirerarchical File System）**，这里最大的变化就是每个文件夹中都有一个目录文件，并且目录文件不仅要指向文件，还要指向目录，还需要增加额外的元数据来区分文件和目录。优点：这种文件系统不仅可以做出无限深的文件夹，也可以让我们很轻松地移动文件，我们不需要移动任何数据块，只需要在两个目录文件中删增记录就行。分层文件文件系统使我们不必关心文件在磁盘中的具体位置。21、压缩之前介绍了文件格式，如何编码文字、声音和图片，但是它们的效率并不高，我们希望文件能小一点，这样就能保存大量文件，同时传输也会快一些，解决方法就是压缩（Compression），把数据占用的空间压得更小，为此我们需要用更少的bit来表示数据。以压缩图片为例，图片一般存成一长串像素值，为了知道一行在哪里结束，图像要有元数据，写明尺寸等属性。每个像素的颜色是三原色的组合，每个颜色用一个字节保存，数字范围是0~255（一个字节=8 bits，2^8^=256），由此一张4*4（16个像素）大小的图像，其中每个像素3个字节。则这个图片需要4*4*3=48字节。—》存成一长串像素值：图片一般存成一长串像素值![img](https://longlongqin.gitee.io/image_save/images/assets/v2-202fff7eae740ec4451258a92c96eda0_720w.jpg)前五个像素的表示## 无损压缩：一种压缩方法是减少重复信息，最简单的方法叫游程编码（Run-Length Encoding），适合经常出现相同值的文件。比如上图中有7个连续相同的黄色像素块，我们可以插入一个额外字节来表示7个连续黄色像素，然后删掉后面重复的数据。为了让计算机分辨哪些字节时长度，那些字节是颜色，格式需要保持一致，所以我们需要给所有像素前面都标上长度。在这个例子中现在只需要24个字节，并且不损失任何信息。这个方法称为无损压缩（Lossless Compression），没有丢失任何数据。游程编码另一种无损压缩方法叫做**DFTBA**，它用更紧凑的方式来表示数据块。首先我们需要一个字典，来保存代码和数据之间的对应关系。我们可以将图像看成一块一块，而不是一个个像素，为了简单，我们将2个像素当成一个块，由此我们可以得到下图的4个像素对，我们会对些像素对生成**紧凑代码（Compact Codes）**。这些块出现频率不同，我们通过霍夫曼树的方法对每一种情况进行编码，使得频率最高的块代码最短。然后我们就能通过code代替块来对图像进行压缩。这个例子中将48字节的数据压缩成了14位，但是同样也要把字典保存下来，所以还需要将字典加到数据前面，所以总共有30字节。使用霍夫曼树生成的块的编码![img](https://longlongqin.gitee.io/image_save/images/assets/v2-557e83d3f9b5d120457fb8fe3fc9df87_720w.png)压缩结果![img](https://longlongqin.gitee.io/image_save/images/assets/v2-e688a0f2a014255ed2e3c9ba38855ed5_720w.png)加上字典后的压缩结果## 有损压缩：“消除冗余”和“使用更紧凑表示方法”通常会组合起来一起使用，几乎所有无损压缩格式都用到它们。无损压缩对于文本数据十分重要，但是有其他一些数据即使丢失了一部分也不会造成很大影响，通常会丢失人们无法注意到的信息，大部分有损压缩技术（Lossy Compression）都用到了这点。以声音为例，人类听力并不是完美的，有些频率我们可以捕获，但是类似于超声波这类的频率我们根本听不见，所以录制音乐时，超声波数据是可以丢弃的，其次人类对人声十分敏感，所以应该尽可能保持原样。有损音频压缩（Lossy Audio Compressors）通过不同精度编码不同频段，这样人类听不出什么区别，也不会明显影响体验。比如电话中也用到了这个技术，这就使得在电话中的声音和现实中有所差别，用过这个技术才使得更多人同时打电话。如果网速变慢，压缩算法就会删掉更多的数据。压缩音频文件MP3和没压缩音频文件WAV或FLAC大小可以相差10倍。这种删除人类无法感知的数据的方法称为感知编码（Perceptual Coding）。这也是各种有损压缩图像格式的基础，比如JPEG，人类的视觉系统也不是完美的，我们比较善于看到尖锐的对比，比如物体的边缘，但我们无法看出颜色的细微变化。JPEG由此将图像分解成8x8大小的像素块，然后删掉大量高频空间数据。比如以下这张图片，其中一个8x8像素，由于每个像素都有细微差异，所以无损压缩技术很难对其压缩，但是人眼很难看出这些细微差别，所以我们可以删除很多像素值，这样只占10%的原始数据，并且图像看起来没有什么区别。原图；8x8原始像素块；8x8压缩像素块；压缩图像视频只是一长串连续图片，所以图片的很多方面也适用于视频，但视频也可以做一些小技巧，因为帧与帧之间有很多相同的像素，称为**时间冗余（Temporal Redundancy）**。我们不需每一帧都保存这些像素，可以只保存变化了的部分。更高级的视频压缩格式会更进一步，他们找出帧和帧之间相似的补丁，然后对他们应用简单变换，比如移动、旋转、变亮和变暗，这样就不用重复保存这些相似的补丁，直接对其进行变换就行。MPEG-4视频是常见的标准，可以比原文件小20倍到200倍。但是当压缩太严重时，没有足够空间更新补丁内的像素，就会出现以下问题。过度压缩造成的错误# 23、屏幕&2D图像显示早期的文本任务通过打印机显示，因为屏幕分辨率较低，无法显示清晰的文字，而将计算结果的文字打印在纸上，有更高的对比度和分辨率，屏幕一般只用于跟踪程序的运行情况，比如寄存器的值，可以节约纸，并且屏幕更新很快，对临时值很匹配。最早最有影响力的是阴极射线管（Cathode Ray Tube，CRT），原理是将电子发射到有磷光体涂层的屏幕上，当电子撞击涂层时，会发光几分之一秒。并且因为电子是带电粒子，所以路径可以通过磁场进行控制。CRT这样就有两种方法来绘制图形：引导电子束描绘出形状，称为矢量扫描（Vector Scanning）。因为发光只持续一小会儿，如果重复速度足够快，就能得到清晰的图像。第二种方法是按照固定路径，一行行从上到下、从左到右不断重复，只在特定的点打开电子束来绘制图形。这种方法称为光栅扫描（Raster Scanning）。用这种方法可以用很多小线段绘制图形，甚至文字。矢量扫描和光栅扫描随着屏幕的发展，我们终于可以在屏幕上显示清晰的点，称为**像素（Pixel）**。**液晶显示器（Liquid Crystal Display，LCD）**也使用光栅扫描，每秒更新多次像素里红绿蓝的颜色。LCD但是早期计算机不使用像素，因为内存中需要保存像素对应的值，使其占用太多内存，所以需要一些特殊技巧来渲染图形，知道内存发展到足够用的地步。所以早期计算机不保存大量像素值，而是直接保存符号，其中80x25个符号是最经典的，若干每个字符用8个字节表示，一共也才16000位。为此，需要特殊的硬件来从内存读取字符，转换成光栅图形，这样才能显示到屏幕上，这个称为字符生成器（Character Generator），基本算是第一代显卡。显卡内部有一小块只读存储器（Read Only Memory，ROM）存着每个字符的图形，称为点阵图案（Dot Matrix Patter）。如果显卡看到某个字符对应的二进制代码，它就会把该字符的点阵图案通过光栅扫描的方式显示在屏幕的适当位置。为了显示，字符生成器会访问内存中一块特殊区域，这块区域专为图形保留，称为屏幕缓冲区（Screen Buffer），程序想显示文字时，就直接修改保存在这个区域的值就行。字符生成器这种方案用的内存很少，但只能画字符到屏幕上，无法绘制任意形状。传统的ASCII编码的字符集太小，做不了很复杂的事情，因此对ASCII进行扩展增加更多的新字符，比如用于DOS的IBM CP437字符集，有些系统还会用额外的bit来定义字体颜色和背景颜色。IBM CP437字符集为了绘制任意形状，同时不会占用太多内存，就要使用CRT上的**矢量模式**。所有东西都是由一系列线条组成的，完全不需要有文本的概念，如果要显示文字，直接用画线的形式进行显示。我们使用一个早期适量显示系统Vectrex的命令为例首先使用RESET命令来清空屏幕， 同时将电子枪的绘图点移动到坐标(0,0)，也就是屏幕左上角，并将线的亮度设为0。调用MOVE_TO 50 50，就会将绘图点移动到坐标(50,50)。然后使用INTENSITY 100将强度设为100， 然后反复调用以上命令就会绘制出对应图形。这些命令也就占160位，比直接保存一个像素矩阵好很多。类似于之前的字符生成器把内存里的字符转换成图形一样，这些矢量指令也保存在内存中，通过矢量图形卡（Vector Graphics Card）画在屏幕上。然后通过数百个命令按序保存在屏幕缓冲区中，就能绘制出十分复杂的图形。并且因为这些矢量都在内存中，程序就可以更新这些值，让图形随时间进行变化，就出现了动画。1962年诞生的Sketchpad是一个巨大的里程碑，它是一个交互式图形界面，用于计算机辅助设计（CAD），它被认为是第一个完整的图形程序。为了与图形界面进行交互，Sketchpad使用了输入设备——光笔，就是一个有线连着电脑的触控笔，笔尖用光线传感器，可以检测到显示器的刷新，并且通过判断刷新时间，电脑也可以知道笔所在的位置。使用光笔和各种按钮，用户可以画线和其他各种简单图案。最早真正使用像素的计算机和显示器出现于1960年代末。内存中的位对应屏幕上的像素，称为位图显示（Bitmapped Display），通过对像素的控制，我们能够完全绘制任意的图形。可以将图形想象成是一个巨大像素值矩阵，之前计算机将像素数据保存在内存中一个特殊区域，称为帧缓冲区（Frame Buffer），但是后来保存在特殊的高速视频内存（Video RAM，VRAM）中，这个VRAM是在显卡上，这样访问速度更快。在一个分辨率是60x35的8位灰度屏幕上，我们可用的颜色范围是0到255。如果我们想把(10,10)处的像素设为白色，可以使用frambuffer [10] [10]=255， 如果我们想要从(30,0)到(30,35)画一条直线，可以使用123FOR y&#x3D;0 TO 35 framebuffer[30][y]&#x3D;255NEXT使用相同方法，通过修改像素值就可以绘制任意图像。并且程序可以操纵帧缓冲区内的像素数据，来实现交互式图形。28、计算机网络第一个计算机网络出现在1950-1960年代，通常在公司或研究室内部使用，方便信息交换，称为球鞋网络（Sneakernet），第二个好处在于共享物理资源，比如，与其每台电脑配一台打印机，不如大家共享一台联网的打印机。并且早期网络也会共享存储空间，因为为每台计算机都配存储器太过昂贵。计算机近距离构成的小型网络称为局域网（Local Area Network，LAN），局域网能小到是同一间房间内的两台计算机，或者大到校园内的上千台电脑。尽管开发和部署了很多不同的LAN技术，其中最著名的是“以太网（Ethernet）”，以太网的最简单形式是：一条以太网电线连接数台计算机，当一台计算机要传数据给另一台计算机时它以电信号形式，将数据传入电缆中，由于电缆是共享的，所以连接在同一个网络里的其他计算机都能看到数据，但是所有计算机都不知道这些数据是给自己的还是给别人的。为了解决这个问题，以太网需要每台计算机有唯一的媒体访问控制地址（Media Access Control Address，MAC Address），然后将MAC地址作为数据的前缀发送到网络中，所以计算机只需要监听以太网电缆，只要看到自己的MAC地址，才去接收处理数据。现在制造的每台计算机都自带唯一的MAC地址，用于以太网和无线网络。以太网但是共享载体有个很大的**弊端**：当网络流量比较小时，计算机可以等待载体清空，然后再传输他们的数据。但随着网络流量上升，两台计算机想同时写入数据的概率也会上升，这称为**冲突（Collision）**，就会使得传输的数据混乱。幸好计算机能够监听电线里的信号来检测冲突，最简单的解决方案就是看到冲突就停止传输，等待网络空闲后再试一次，问题是其他计算机也是这样打算的，其他等待的计算机可能在任何停顿间隙就闯入开始传输数据，这就导致了越来越多的冲突。以太网的解决方法是：当计算机检测到冲突后，就会在重传之前等待一小段时间（因为要举例，假设是 1 秒好了），当然 如果所有计算机用同样的等待时间 是不行的，它们会在一秒后再次冲突。所以加入一个随机时间 一台计算机可能等1.3秒，另一台计算机等待1.5秒 。要是运气好 等1.3秒的计算机会醒来发现载体是空闲的 然后开始传输 ，当1.5秒的计算机醒来后 会发现载体被占用会等待其他计算机完成 ，来相互避开。当然这个并不能完全解决问题，还需要用到另一个技巧。如果一台计算机在传输数据期间检测到冲突，就等待“1秒+随机时间”，但是如果再次发生冲突，就表明有网络拥塞，这次不等1秒，而是等2秒 ，如果再次发生冲突 等4秒 然后8秒 16秒等等，直到成功传输。因为计算机的退避，冲突次数会大幅减少，使得数据能够再次流动起来，网络就变得顺畅了。这种指数级增加等待时间的方法称为指数退避（Exponential Backoff），很多以太网和WiFi都用到这个技术。但是即使有了以上的技术，想用一根网线连接整个大学的计算机还是不可能的，为了减少冲突同时提高效率，我们需要减少同一载体中设备的数量，载体和其中的设备总称为冲突域（Collision Domain）。以之前以太网为例，一根电缆连接了6台计算机，这个称为一个冲突域。为了减少冲突，我们可以用交换机（Switch）将它拆成两个冲突域。交换机位于两个更小的网络之间，在必要时才在两个网络之间传输数据，并且交换机会记录一个列表，写着哪个MAC地址位于哪边网络，所以当MAC A想要传数据给MAC C，交换机就不会将数据传到另一边的网络，同理如果MAC E传输数据给MAC F，交换机也不会将数据传到上面的网络，这使得两边的传输能同时进行。但是如果MAC F想传数据给A，数据就会通过交换机，使得两个网络都会被短暂占用。一个以太网中加入一个交换机即使最大型的网络——**互联网（Internet）**也是这样构建起来的，本质还是多个连在一起的稍小一点的网络，使得不同网络间可以传递数据。而大型网络有一个特点，从一台主机到另一台主机通常有多条线路（**解决的主要问题**），这就引出了另一个话题——**路由（Routing）（用来选择合适路线的方法）**。大型网络，两台主机之间存在多条线路连接两台相隔遥远的计算机或网络，最简单的方法是分配一条专门的通信线路，早期的电话系统就是这样运作的，这种方法称为**电路交换（Circuit Switching）**，因为是对整个电路进行修改，来连接到正确目的地，所以这种方法不灵活且价格昂贵，并且总有闲置的路线。但是好处是你可以最大限度随意使用，无需共享。因此军队、银行和其他一些机构依然会购买专门线路来连接数据中心。电路交换传输数据的另一种方法是**报文交换（Message Switching）**，就像邮政系统一样。不像之前A和B之间有一条专有线路，这里消息会经过好几个站点，就类似于邮寄信封，信封会通过一个个中转站最终到达收件人手中，每个站点都知道下一站要发往哪里，因为站点都有自己一个**表格**，用来记录到达各个目的地，信件要如何传递。报文交换的**好处**是你可以用不同的路由，使得通信更可靠。比如如果其中一个城市由于降雪无法接收邮件时，就能换到另一个城市继续传递数据。这里，城市就相当于网络中的路由器一样。报文交换> 交换机是连接若干个主机的机器，用来解决冲突域问题。 > > 路由器是连接主机、路由器、交换机的机器，用来构建数据传输的线路。信息沿着路由跳转的次数称为跳数（Hop Count），通过记录跳数，可以分辨出路由问题。比如当路由A认为到达目的地最快的下一个路由是B，就将信息传递给路由B，而路由B则认为到达目的地最快的下一个路由是A，又将信息传递回给了路由A，这就使得信息在路由A和B之间踢皮球，但是这种错误可以通过在信息中实时记录的跳数来解决，如果某条信息的跳数很大，就说明路由有出问题，这个称为跳数限制（Hop Limit）。而报文交换的缺点之一就是当报文较大时，会堵塞网络，因为这里要求将整个报文从一个路由传到下一个路由后，才能继续传递其他报文，当传输大报文时，其他报文要么等待它传递完，要么选择另一条效率较低的路线。解决方法就是将大报文分成很多小块，称为数据包（Packet）。和报文交换一样，每个数据包都有网络中的目的地址，因此路由器知道要发送到哪里，这个地址的具体格式由互联网协议（Internet Protocol，IP）定义。每个联网的计算机都需要一个IP地址（IP Address），例如172.217.7.238。MAC地址用来标识每条计算机，而IP地址是对数据包而言的。路由器会平衡与其他路由器之间的负载，来确保传输可以快速可靠，称为拥塞控制 （Congestion Control）。有时候一个报文的多个数据包会经过不同线路，使得到达顺序也可能不相同，这对一些软件来说是存在问题的。幸运的是，在IP之上还有其他协议，比如TCP/IP可以解决乱序问题。将数据拆分成多个小数据包，然后通过灵活的路由传递，非常高效且容错率高，这种方法称为分组交换（Packet Switching）。它的好处是可以去中心化，就没有单点失败问题。如今全球的路由器协同工作，找出最高效的线路，用各种标准协议传输数据，比如因特网控制信息协议（Internet Control Message Protocol，ICMP）和边界网关协议（Border Gateway Protocol，BGP）。网络是一堆管子组成的吗？ 额 算是吧。29、互联网任意计算机都和一个巨大的分布式网络连接在一起，称为互联网（Internet）。当你在家中通过计算机观看网上视频时，你的计算机首先需要连接到局域网LAN，这个局域网是由家里WiFi路由器连接的所有设备组成的。然后家里的局域网再通过路由器连接到广域网（Wide Area Network，WAN），广域网的路由器一般属于你的互联网服务提供商（Internet Service Provider，ISP）。在广域网里，首先会有一个区域性路由器，比如覆盖你所在街区的一个路由器，然后该路由器会连接到一个更大的广域网中，比如覆盖你所在的城市，可能再跳跃几次，最终会到达互联网主干，一般由一群超大型、带宽超高的路由器组成。即首先会连接到你家里的WiFi路由器构建的局域网，然后该路由器再连接到ISP提供的广域网中，该广域网是由很多层层递进的路由器构成的。比如要从YouTube中获得视频，数据包首先会到达互联网主干，沿着主干到达对应保存该视频文件的YouTube服务器，可能这里会跳4次到达互联网主干，然后跳两次穿过互联网主干，最终再跳4次到达YouTube服务器，所以总共会跳跃10次。我们可以通过traceroute来看跳跃了几次：1234567891011121314Windows上的Traceroute1.按开始按钮2.输入“ CMD”，然后按“ Enter”3.在命令提示符下，键入“ tracert dftba.com”在Mac上的Traceroute1.点击“转到”下拉菜单2.点击“实用程序”3.打开终端4.键入“ traceroute dftba.com”Linux上的Traceroute1.通过键入CTRL + Alt + T打开终端2.输入：“ traceroute dftba.com”通过traceroute查看到dftba.com中转的次数经历了11次中转。但是数据包到底是怎么传递过去的呢？如果传输时数据包丢失了，会发生什么？当我们在浏览器中输入网址时，浏览器怎么知道服务器的地址是什么呢？就像上节介绍的，互联网是一个巨大分布式网络，如果要发送的数据较大，分组传输就会将数据拆成一个个较小的数据包进行传输。其中数据包要想在互联网上进行传输，就要符合互联网协议（Internet Protocol，IP）。类似于邮寄手写信一般，每封信都需要一个地址，并且地址必须是唯一的，并且信的大小和重量也是有限制的，否则信件就无法送达。IP数据包也是如此，因为IP是一个非常底层的协议，数据包的头部只包含目标地址（IP地址），意味着当数据包到达对方电脑时，计算机不知道要把数据包交给哪个程序（比如QQ或微信），因此需要在IP之上，开发更高级的协议。数据包的结构最简单常见的协议称为用户数据报协议（User Datagram Protocol，UDP）。UDP也有头部，位于data payload里面，在data之前。UDP头部里面包含了很多有用的信息，其中之一就是**端口号（Port Number）**，每个想访问网络的程序都要向操作系统申请一个端口号。所以当数据包到达时，接收方的操作系统会读取UDP头部里的端口号，来确定该数据包是要交给哪个软件的。UDP比如 Skype 会申请端口 3478，当一个数据包到达时接收方的操作系统会读 UDP 头部，读里面的端口号如果看到端口号是 3478，就把数据包交给 Skype。端口号![image-20200229170954885](assets/image-20200229170954885.png)IP协议通过IP地址把数据包送到正确的计算机内；UDP通过数据包里的端口号送到正确的程序。同时UDP的头部中还有校验和（Checksum），通过对数据求和来检查数据是否正确。假设UDP数据包里原始数据是89 111 33 32 58 41， 最简单的计算校验和的方式就是，在发送数据包之前，计算机会把所有数据加在一起，计算出校验和364。在UDP中，校验和是以16位形式存储的，如果计算出来的和超过16位能表示的最大值，则高位数会被丢弃，只保留低位。当接收方计算机接收到这个数据包时，也会重复以上过程，如果计算出来的校验和和UDP中保存的校验和相同，代表数据是正常的，否则数据是出错的。但是，UDP不提供数据修复或数据重发机制，当接收方知道数据损坏后，一般只是丢弃这个数据包。并且当发送方使用UDP协议发送数据包时，是无法得知数据包是否到达目的地的。有些程序并不在意以上问题，因为UDP十分简单且快速。比如视频通常使用UDP协议，当数据包丢失时，也就造成视频卡顿。但是有些数据不能接受数据包丢失的问题，比如发送电子邮件时，所有数据必须到达，所以就需要传输控制协议（Transmission Control Protocol，TCP）。和UDP一样，它的头部也保存在数据之前，人们通常将IP协议和TCP协议统称为TCP/IP协议。TCP的头部中也包含端口号和校验和，并且TCP协议还提供更高级的功能：TCP1. TCP的数据包是有序号的，使得接收方可以通过这个序号将数据包排成正确顺序，即使到达时间不同。 2. TCP要求接收方的电脑收到数据包并校验和检查无误后，需要给发送方发送一个**确认码（Acknowledgement，ACK）**，代表数据包已经正确接收。当发送方接收到确认码后，就知道上一个数据包成功抵达了，发送方就会发送下一个数据包，如果这次发送方过了一段时间没有接收到确认码，则会重新发送一次。即使这里只是由于确认码延迟了，使得接收方那里有重复的数据包，但是通过序列号，可以直接删除重复的数据包。并且数据包并不会一个个数据包进行传输，而是同时发送多个数据包，同时接收多个确认码(ACK)，这将大大提高效率，不用浪费时间等待确认码。并且通过确认码的成功率和来回时间，我们可以推测网络的拥塞程度，TCP通过这个信息，来调整同时发包数量来解决拥塞问题。简而言之，TCP可以处理乱序和丢包问题，并且可以根据拥塞情况自动调整传输率。但是由于确认码数据包的存在，使得TCP需要传输的数据包数量翻了一倍，并且并没有传输更多信息，这对时间要求很高的程序代价太高，所以这类程序就会使用UDP协议（比如射击类游戏）。当计算机访问一个网站时，需要两个东西：IP地址（目标网站的地址）和 端口号（对应于你使用的计算机浏览器）（例如：例如 172.217.7.238 的 80 端口 这是谷歌的 IP 地址和端口号）。但是通过IP地址访问网站十分不方便，所以互联网提供一个特殊服务，来将域名（Domain Name）和IP地址一一对应，称为域名系统（Dimain Name System，DNS），一般DNS服务器都是由ISP提供的。当你在浏览器中输入网站域名时，浏览器就会去访问DNS服务器，DNS就会去查表，如果域名存在，则会返回浏览器对应IP地址，然后浏览器就会给这个IP地址发送TCP请求。因为当前域名特别多，所以DNS不会将其保存成列表形式，而是将其保存成树状结构。最顶层是顶级域名（Top Level Domain，TLD），比如.com和.gov；下一层是二级域名（Second Level Domain）， 比如google.com和dftba.com；再下一层是子域名（Sub-domain），比如images.google.com等等。由于这个树结构特别大，因此这些数据分布在很多DNS服务器上，不同服务器负责树的不同部分。域结构总结上两节（28、29）的内容，其实计算机网络分成很多层次，接下来从最底层到最高层：物理层（Physical Layer），比如线路中的电信号，以及无线网络中的无线信号。数据链路层（Data Link Layer）负责操控物理层，其中包含MAC地址、冲突检测、指数回退以及其他一些底层协议。网络层（Network Layer）负责各种报文交换和路由技术。传输层（Transport Layer）负责在计算机之间进行点到点的传输，还会检测和修复错误，比如UDP和TCP协议。会话层（Session Layer）会使用TCP和UDP来创建连接，传递信息，然后关掉连接。以上是开放式系统互联通信参考模型（Open System Interconnection model，OSI）下的5层，这个框架将网络通信划分成了很多层，每一层处理各自的问题。这种抽象可以使得分工改进多个层，而无需考虑整体复杂性。并且OSI还有额外两层：表示层（Presentation Layer）和应用层（Application Layer），在下一节中进行介绍。30、万维网前两节介绍的东西共同组成了互联网，这一节将向上抽象一层，来讨论万维网（World Wide Web）。万维网和互联网的概念完全不同，万维网是运行于互联网之上的，还有其他比如Skype、Instagram等也是运行在互联网之上的。互联网是用来传输数据的管道，各种程序都会使用到，其中传输最多数据的程序就是万维网，我们可以使用特殊的程序——浏览器（Web Browser）来访问万维网。万维网的最基本单位是单个页面，里面包含内容，也有访问其他页面的链接，这些链接称为超链接（Hyperlink）。这些超链接形成巨大的互联网络，这也是万维网名字的由来。并且由于文字超链接的强大，它有一个特殊的名字——超文本（Hypertext）。如今超文本最常指向的是另一个页面，这些页面会被获取并由浏览器进行渲染。为了使网页能够互相连接，每个网页需要一个唯一的地址，这个地址称为统一资源定位器（Uniform Resource Locator，URL），比如thecrashcourse.com/courses就是一个页面URL。当你访问thecrashcourse.com网址时，计算机首先会进行DNS查询，这里输入一个域名，然后DNS就会返回给浏览器对应的计算机IP地址。然后浏览器就会打开一个TCP连接到这个IP地址对应的计算机上，而这个计算机运行着一个特殊的软件——网络服务器（Web Server），网络服务器的标准端口是80。此时，你的计算机就连接到了thecrashcourse.com对应的服务器了，下一步是向服务器请求courses 页面，这里就会用到超文本传输协议（Hypertext Transfer Protocol，HTTP）。HTTP的第一个标准是1991年创建的HTTP 0.9，只有一个指令GET 。因为这里我们想要获取courses页面， 我们可以直接向服务器发送指令GET/courses， 该指令以ASCII编码发送到服务器，服务器会返回该网址对应的页面，然后浏览器就会将其渲染到屏幕上。如果用户点击了另一个链接，计算机就会重新发送一个GET请求。在之后的版本中，HTTP添加了新的状态码，会将其放在请求页面的前面，比如状态码200表示网页被正确找到了，状态码400-499代表客户端出错。因为超文本的存储和发送都是以普通文本形式进行的，编码可能是ASCII或者UTF-8，这样就无法表明什么是链接，什么只是普通的文本了，所以必须开发一种标记方法，因此出现了超文本标记语言（Hypertext Markup Language，HTML），第一代HTML创建于1990年的0.8版本，有18种指令。制作一个简单的网页综上，网络浏览器可以和网络服务器沟通，不仅获取网页和媒体，并且还负责显示。随着后期万维网日益繁荣，人们越来越需要搜索。起初人们会维护一个目录，来链接到其他网站，但是随着网络越来越大，人工编辑目录变得很不方便，所以开发了搜索引擎。最早的搜索引擎是JumpStation，它有3个部分：通过爬虫来将新链接添加进自己的列表中。不断扩张的索引，用来记录访问过的网页上出现了哪些词。查询索引的搜索算法，比如输入了某个关键字，则包含这个关键字的网页就会显示出来。早期的搜索引擎的排名方式直接取决于搜索词在页面上的出现次数，但是有的网页会通过在页面中重复该关键字来提高排名。Google成名的很大原因就是提出了一种算法来解决这个问题，与其信任页面上的内容，搜索引擎会看其他网页有没有连接到这个网页。最后提一个概念——网络中立性（Network Neutrality），它指的是要对所有数据包都平等对待，速度和优先级都应该一样。31、计算机安全计算机安全的范围和计算能力的发展速度一样快，我们可以把计算机安全，看成是保护系统和数据的保密性、完整性和可用性。保密性（Secrecy）：只有有权限的人才能读取计算机系统和数据，比如黑客泄露别人的信用卡信息，就是攻击保密性。完整性（Integrity）：只有有权限的人才能使用和修改系统和数据，比如黑客假冒你发送邮件，就是攻击完整性。可用性（Availability）：有权限的人应该随时可以访问系统和数据，拒绝服务攻击（DDOS）就是黑客发送大量的假请求到服务器上，使得网站很慢或者直接挂掉，这就是攻击可用性。为了实现这三个目标，安全专家会从抽象层面想想敌人可能是谁，这个称为威胁模型分析（Threat Model）。模型会对攻击者有个大致的描述：能力如何、目标是什么、可能使用什么手段。攻击手段又称为攻击矢量（Attack Vector）。威胁模型分析能够让你为特定情境做好准备，不被可能的攻击手段所淹没。换句话说，要怎么保护，具体看要对抗谁。通常威胁模型分析中，会以能力水平进行区分。在给定的威胁模型下，安全架构师要提供解决方案，来保持系统安全。有很多保护计算机系统、网络和数据的方法。很多安全问题可以总结成两个问题：你是谁？你能访问什么？权限应该给适合的人而拒绝错误的人，所以为了区分谁是谁，我们使用身份认证（Authentication）来让计算机得知使用者是谁。通常身份认证有三种，各有利弊：你知道什么：这个是基于某种只有用户和计算机知道的秘密，比如用户名和密码。这是如今使用最广最容易实现的方法。但是如果黑客知道了你的密码就惨了，或者可以通过暴力攻击试了密码的所有可能来获取你的密码，有些系统会在你尝试若干次错误后阻止你继续尝试。即使增长密码也很容易破解，所以现在很多网站都要求大小写字母加特殊字符，来增加可能的密码。你有什么：这是基于用户特定的物体，比如钥匙和锁。这种方法可以避免被人猜中密码的问题，而且通常需要人在现场，所以远程攻击就更加困难了。你是什么：这是基于你，通过你自己的特征展示给计算机来进行验证，比如指纹识别器和红膜扫描仪，这些方法特别的安全，但是最好的识别技术十分昂贵。“你知道什么”和“你有什么”是确定性的，但是来自传感器的数据每次都不相同，所以“你是什么”是概率性的，系统可能认不出你，或者将其他人认成了你。并且这种方法另一个问题就是无法重设，你无法修改自己的指纹或者虹膜。每种方法都有优缺点，一般建议使用两种或两种以上的认证方式。当系统知道了你是谁，接下来就需要知道你能访问什么，这个称为访问控制（Access Control），因此需要一个规范，来说明谁能访问什么、修改什么和使用什么。这个可以通过权限（Permission）或访问控制列表（Access Control List，ACL）来实现，其中描述了用户对每个文件、文件夹和程序的访问权限。读权限：允许用户查看文件内容。写权限：允许用户修改文件内容。执行权限：运行用户运行文件。有些阻止需要不同层次的权限，则ACL的正确配置就十分重要。假设我们有三个访问级别：公开、机密和顶级机密。有个经典模型称为Bell-LaPadula模型，其中包含两条规则：用户不能read up，即不能读等级更高的信息。用户不能write down，即用户不能写更低权限的信息，这样能避免高级别的信息不会泄漏到低级别的文件中。通过身份认证和权限控制，可以让计算机知道你是谁和你能访问什么，但是必须先保证做这些事的软硬件必须是可信的。但是仍然无法保证程序或计算机系统的安全，因为安全软件在理论上可能是安全的，但是实现时可能会不小心留下漏洞。但是我们有办法减少漏洞出现的可能性，比如一发现漏洞就马上修补。大部分漏洞都是具体实现时出错了，所以为了减少执行错误，就要减少执行。系统级安全的圣杯之一是安全内核或可信计算机基础：一组尽可能少的操作系统软件，这个安全性是接近可验证的。构建安全内核的挑战在于，要决定内核应该有什么（代码越少越好）。当最小化代码数量后，要是能保证代码是安全的，那就很好了。现在最好的验证代码安全性的手段是独立安全监察和质量验证（Independent Verification and Validation），让一群安全行业内的软件开发者来审计代码，这也是为什么安全型代码几乎都是开源的。但是即使这样，还是有可能被黑客攻破，因此程序开发者需要控制损失的最大程度，这个称为隔离（Ioslation）。要实现隔离，可以“沙盒”（sandbox）程序，操作系统通过给每个程序独立的内存块，使得别的程序是无法触及的，这样就能把程序放到沙盒中，即使沙盒被破坏了，也不会影响别的程序执行。并且一台计算机可以运行多个虚拟机（Virtual Machine），使得每个虚拟机都在自己的沙盒中。32、黑客&amp;攻击黑客入侵最常见的方式不是通过技术，而是欺骗别人，这个称为社会工程学（Social Engineering），通过欺骗别人来让人泄露秘密，或让人配置电脑系统来变得易于攻击。最常见的攻击是网络钓鱼（Phishing），其次还有假托（Pretexting），攻击者给某个公司打电话，假装是IT部门的人，攻击者的第一通电话一般会叫人转接，这样另一个接的时候，电话看起来就像内部的，然后让别人把电脑配置得易于入侵，或者让他们泄露机密信息，比如密码或网络配置。邮件里带木马（trojan horse）也是常见手段，木马通常会伪装成无害的东西，比如照片或发票，但实际上是恶意软件，有的会偷数据，有的会加密文件。如果攻击者无法用木马或电话欺骗，攻击者只能被迫使用其他手段，方法之一就是暴力破解，尝试所有可能的密码，直到进入系统，大多数现代系统会加长等待时间来抵御这种攻击，每次失败就加长等待时间，甚至超过一定次数后，完全封锁。现在出现了一种攻破方法称为NAND镜像，如果能物理接触到电脑，可以往内存上接几根线，复制整个内存，然后暴力尝试密码，直到设备让你等待。这时只要把复制的内容覆盖掉内存，本质上重置了内存，就不用等待，可以继续尝试密码。如果无法物理接触到设备，就需要远程攻击，比如通过互联网，这一般需要攻击者利用系统漏洞，来获得某些能力或访问权限，称为漏洞利用（Exploit）。一种常见的漏洞利用叫缓冲区溢出（Buffer Overflow），这里的缓冲区是指预留的一块内存空间，比如我们在系统登录界面输入用户名和密码，而系统是用缓冲区来存储输入值的，假设缓冲区大小为10，并且缓冲区前后肯定还有其他数据，当用户输入用户名和密码时，这些值就会被复制到缓冲区中来进行验证，而该方法会溢出缓冲区，比如输入超过10个字符的密码，会覆盖掉相邻的数据，有时会让程序或系统崩溃，因为重要值被垃圾数据覆盖掉了。这里只是让系统崩溃，但是攻击者可以输入有意义的新值到程序的内存中，比如把is_admin标志位的值改为true，有了任意修改内存的能力，黑客就可以绕过登录这类东西，甚至使用那个程序劫持整个系统。有许多方法阻止缓冲区溢出，最简单的方法就是复制到内存之前先检查长度，称为边界检查（Bounds checking），许多现代编程语言都自带边界检查，程序也会随机存放变量在内存中的位置，这样黑客就不知道应该覆盖内存的哪部分，使得更容易让程序崩溃，而不是获得访问权限。程序也可以在缓冲区后，预留一些不用的空间，然后跟踪里面的值，看是否发生变化，来判断是否有攻击，这些不用的内存空间称为金丝雀（Canaries）。另一种经典手段是代码注入（Code Injection），最常用于攻击用数据库的网站。假设网页上有登录提示，当用户点击“登录”，输入文本就会发送服务器，服务器就会运行代码，检查用户名是否存在，如果存在就看密码是否匹配。为此服务器会执行一段sql查询代码，比如1SELECT password FROM users WHERE username='___';这里语句就是要从users表中查找username为___的密码password。 这里的___就是用户输入的用户名。由此攻击者就能把sql命令输入到用户名中，比如whatever&#39;;DROP TABLE users;&#39;，这时上面的查询语句就会变成1SELECT password FROM users WHERE username='whatever';DROP TABLE users;';如果服务器存在用户名wharever，数据库就会返回密码， 当然我们无法得知密码是什么，所以服务器会拒绝我们；如果不存在用户名wharever，服务器会返回空密码或者直接错误，服务器也会拒绝我们。 但是我们关心的是后面的代码DROP TABLE users;这个是我们注入的命令，这个命令是删掉users这张表。如今几乎所有服务器都会防御这种手段。程序员需要认识到从外界输入的信息都是危险的，必须要好好检查，很多用户名和密码表单，不会让你直接输入特殊符号，比如分号或括号，来作为第一道防御。好的服务器也会清理输入，比如修改或删除特殊字符，然后才放到数据库查询语句中。当软件制造者不知道的新漏洞被发现时，称为0day漏洞（Zero Day Vulnerability），黑客就会抢在白帽程序员做出补丁之前尽可能利用漏洞。如果有足够多的电脑有漏洞，让恶意程序可以自动地在电脑之间互相传播，称为蠕虫（Worm）。如果黑客拿下大量电脑，这些电脑可以组成僵尸网络（Botnet），可以用于很多目的，比如发大量垃圾邮件等，用别人电脑的计算能力来挖比特币，或发起DDOS来攻击服务器。DDOS就是僵尸网络里的所有电脑发一大堆垃圾信息到服务器上，造成服务器的阻塞。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"《计算机科学速成课》","slug":"《计算机科学速成课》","permalink":"https://longlongqin.github.io/tags/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE%E3%80%8B/"}]},{"title":"LearnCpp chapter4","slug":"C&C++/LearnCpp-chapter4","date":"2020-03-31T05:59:58.000Z","updated":"2020-04-19T14:38:29.546Z","comments":true,"path":"archives/c1a4eb67.html","link":"","permalink":"https://longlongqin.github.io/archives/c1a4eb67.html","excerpt":"LearnCpp chapter4https://www.learncpp.com","text":"LearnCpp chapter4https://www.learncpp.com4.1 基本的数据类型内存最小的单位是一个二进制数(binary digit)，即位(bit)。它可以存储一个0或者1。就像传统的电灯开关一样——灯开着(1)，灯关着(0)由连续的单元组成的内存，叫内存地址(memory addresses)，简称地址(addresses)现代计算机中，“位”是没有它自己的内存地址的。而是用一个“字节(byte)”来表示一个内存地址。因为内存地址是比较有限的，而且需要逐“位”访问数据的情况很少。字节是作为一个单位来操作的一组”位(bit)”。现代标准规定：一个字节由8个连续的位组成。下面的图片显示了一些连续的内存地址，以及相应的数据字节:数据类型(Data types)，简称“类型(type)”我们使用数据类型来告诉编译器如何以某种有意义的方式解释内存的内容。如：当我们声明一个变量的类型为 整型(integer)时，就相当于告诉内存“这个变量使用的内存段将被解释为一个整数值”给对象(object)一个值(value)时，编译器和CPU就负责将您的值 编码(encode)为该数据类型的适当的位序列，并存储在内存中。【记住：内存只存储位(bits)】如：给一个整型对象赋一个值,65。这个值就被转换为bits：0100 0001，并被存储在分配给对象的内存中。当这个对象被求值，产生一个值时，这个 位序列(sequence of bits) 被重新构造成原来的值。意思就是：0100 0001被转换回 值65.幸运的是，这些转换工作都是由 编译器 和 CPU 来完成的。基本数据类型(fundamental data types)，但通常被非正式地称为基本类型(basic types)、基本类型(primitive types)或内置类型(built-in types)。下面是一些基本数据类型：1、注意：integer vs integral：integral即比integer范围更广integer：表示整数，即正整数、负整数、0；integral：包含了 integer、boolean(布尔型)、字符类型。他们两个名字比较相近，是因为：integral类型在内存中存储形式是和integer一样。2、 _t后缀这个后缀，表示“类型”的意思。4.2 Voidvoid是最简单的类型，void，即“没有类型”变量不能定义为void类型：1void value; // won't work, variables can't be defined with a void typevoid用途：Functions that do not return a value（函数不返回值）：12345void writeValue(int x) // void here means no return value&#123; std::cout &lt;&lt; \"The value of x is: \" &lt;&lt; x &lt;&lt; '\\n'; // no return statement, because this function doesn't return a value&#125;Functions that do not take parameters(函数中不带参数)1234567891011121314int getValue(void) // void here means no parameters&#123; int x; std::cin &gt;&gt; x; return x;&#125;//或者这种形式【在C++中，推荐写这种形式】int getValue() // empty function parameters is an implicit void&#123; int x; std::cin &gt;&gt; x; return x;&#125;4.3 对象大小&amp;sizeof操作符对象的大小：对象的大小取决于它的数据类型通常通过变量名访问内存，而不是直接通过内存地址。1个bit(位)可以容纳2个可能的值，0或1；…….即，具有n位(bits)的对象，可以容纳2^n 个可能的值。因此，对象的大小限制了它可以存储的唯一值的个数。每次定义一个对象时，只要该对象存在，就会使用一小部分空闲内存。基本数据类型的大小：给定数据类型的大小取决于编译器 和/或 计算机体系结构!C++只保证每个基本数据类型的大小都是最小的：然而，这些类型的大小在不同的计算机上可能会不一样。比如，有些机器上的int大小为4 bytes操作符“sizeof”为了能够在计算机上直到类型的大小，C++提供了“sizeof”操作符来确认类型的大小。sizeof：是一个一元操作符，它接受 类型 或 变量，然后返回它的大小(bytes)123456789101112131415161718192021222324#include &lt;iostream&gt;int main()&#123; std::cout &lt;&lt; \"bool:\\t\\t\" &lt;&lt; sizeof(bool) &lt;&lt; \"bytes\\n\"; std::cout &lt;&lt; \"char:\\t\\t\" &lt;&lt; sizeof(char) &lt;&lt; \"bytes\\n\"; std::cout &lt;&lt; \"wchar_t:\\t\" &lt;&lt; sizeof(wchar_t) &lt;&lt; \"bytes\\n\"; std::cout &lt;&lt; \"char16_t:\\t\" &lt;&lt; sizeof(char16_t) &lt;&lt; \" bytes\\n\"; // C++11 only std::cout &lt;&lt; \"char32_t:\\t\" &lt;&lt; sizeof(char32_t) &lt;&lt; \" bytes\\n\"; // C++11 only std::cout &lt;&lt; \"short:\\t\\t\" &lt;&lt; sizeof(short) &lt;&lt; \" bytes\\n\"; std::cout &lt;&lt; \"int:\\t\\t\" &lt;&lt; sizeof(int) &lt;&lt; \" bytes\\n\"; std::cout &lt;&lt; \"long:\\t\\t\" &lt;&lt; sizeof(long) &lt;&lt; \" bytes\\n\"; std::cout &lt;&lt; \"long long:\\t\" &lt;&lt; sizeof(long long) &lt;&lt; \" bytes\\n\"; // C++11 only std::cout &lt;&lt; \"float:\\t\\t\" &lt;&lt; sizeof(float) &lt;&lt; \" bytes\\n\"; std::cout &lt;&lt; \"double:\\t\\t\" &lt;&lt; sizeof(double) &lt;&lt; \" bytes\\n\"; std::cout &lt;&lt; \"long double:\\t\" &lt;&lt; sizeof(long double) &lt;&lt; \" bytes\\n\"; //避免在visual studio 中运行时 闪过 std::cin.clear(); std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n'); std::cin.get(); return 0;&#125;运行结果：运行结果会因为不同类型的机器or编译器，而出现差异。4.4 有符号整型C++中有四种整型的类型：Signed integers(有符号整型)如：+1、-1、0这种都属于 有符号整型。定义有符号整型：123456789101112131415161718//【推荐】short s;int i;long i;long long i;//除了int，其它类型也可以这样写：short int s;long int i;long liong i;//这种【不推荐】，使用“int”后缀不利于观看//也可以使用 signed前缀signed shrt s;signed int i;signed long i;signed long long i;//【不推荐】，因为signed冗余，不利于辨认有符号整型的范围数据类型可以容纳的一组特定值，叫做：range(范围)整型变量的“范围”的决定因素：该类型本身的大小；该类型是否是 有符号 的。比如，大小为1字节的有符号整型，它的范围是：-128~127(包含范围的两端)，即它可以存储2^8=256 个可能的整数。这是一个包含不同大小有符号整数范围的表:小结，一个有 n-bits的 有符号变量，它可存储值的范围是：-(2^n-1^) ~ (2^n-1^ -1)整数溢出，简称：溢出如果我们把值280,存储在 1个字节的有符号整型 中，他就会发生 溢出现象。此时，数据丢失是因为对象没有足够的内存来存储所有东西。4.5 无符号整型不推荐使用无符号整型：unsigned integer。不能存储“负数”，可以存储：0 和 正整数定义无符号整型变量要定义无符号整数，我们使用unsigned关键字。按照惯例，这是放在前面的类型:1234unsigned short us;unsigned int ui;unsigned long ul;unsigned long long ull;无符号整型范围一个有 n-bits 的无符号整型变量，它可存储的范围是：0 ~ (2^n^)-1当不需要负数时，无符号整数非常适合于网络和内存很少的系统，因为无符号整数可以存储更多的正数而不占用额外的内存。无符号整数的溢出：Unsigned integer overflow无符号整数不会溢出。如果一个值超过范围，那么它会除以一个比这个范围大的数，然后将余数存起来。正数溢出如，在 1byte的范围中，存储数据。280在 范围为 1个字节 的整型中存储，因280&gt;255。所以，它会除以256(比 1个字节的范围的最大值大1，即比255大1的数，256)。280/256=24，所以存储的是24.存储256。256&gt;255。则进行 256/256 = 0，即相当于存储 0存储257。257&gt;255。则进行 257/256 = 1，即相当于存储 1看一个程序：123456789101112131415#include &lt;iostream&gt; int main()&#123; unsigned short x&#123; 65535 &#125;; // 最大的16位无符号值 std::cout &lt;&lt; \"x was: \" &lt;&lt; x &lt;&lt; '\\n'; x = 65536; // 65536 is out of our range, so we get wrap-around std::cout &lt;&lt; \"x is now: \" &lt;&lt; x &lt;&lt; '\\n'; x = 65537; // 65537 is out of our range, so we get wrap-around std::cout &lt;&lt; \"x is now: \" &lt;&lt; x &lt;&lt; '\\n'; return 0;&#125;输出：负数溢出虽然，无符号整数的范围是0~255(假如在 1byte的范围).但是我们不小心在无符号整型中输入了 负数，应该怎么办呢？比如，当输入 -1 时。-1不在 0~255这个范围中。此时就循环到这个范围的顶部（最大值处），即 255。所以，在 1 byte 的范围的无符号整数中，输入 -1 ，存储的是 255。输入-2，存储的是254。（从最顶部往回循环）4.6 固定宽度的整数和size_t之前讲了整型变量的最低size，其实他们可以按照不同的系统变得更大。为什么不固定整型变量的大小？因为在C语言中，为了提高性能，C故意保持整数的大小是开放的，这样编译器实现者就可以为 int 选择一个在目标计算机架构上表现最好的大小。固定宽度的整型为了实现跨平台，C99定义了一系列的固定宽度的整型(在头文件stdint.h中)，使得在任何平台中的大小都一致。在C++11中的头文件cstdint中，也包含了上述的固定宽度整型。他们在命名空间std中定义的。如;123456789#include &lt;iostream&gt;#include &lt;cstdint&gt;int main()&#123; std::int16_t i(5); std::cout &lt;&lt; i; return 0;&#125;应该避免上述固定宽度的整数，因为它们可能不是在所有目标体系结构上定义的。fast &amp; least 整型：快类型 &amp; 小类型为了帮助解决上述缺点，c++ 11还定义了两个可选的整数集。*fast type *无符号格式为： std::int_fast#_t ；有符号格式：std::uint_fast#_t它提供一个整型，它提供一个在你的机器上表现得性能最好的宽度，但是它的宽度最小是“# bits”（# = 8，16，32，or 64 bit）如：std::int_fast32_t将会给你一个最小为 32bits 的无符号整型least type无符号格式为： std::int_least#_t ；有符号格式：std::uint_least#_t它提供一个整型类型，它提供一个最接近于“# bits”的宽度，但是它的宽度最小是“# bits”（# = 8，16，32，or 64 bit）小结：比较：int#\\_t、int_fast#_t、int_least#_t的差异：int#_t的bits(位数)是固定的，即有“# bits”；int_fast#_t 和 int_least#_t的bits(位数)最少有““# bits”；example：int16_t：是固定的16位的整型；int_fast16_t：可能转变成了64位的整型。（因为在你的机器上，64位整型最快了）int_least16_t：可能转变成了32位的整型。（假设因为你的系统中没有16位的整型，而32位此时是最接近16位 的整型了）注意：std::int8_t和std::uint8_t是char类型，而不是integer在C++中，很多编译器对std::int8_t和std::uint8_t（以及相应的fast 和 least 整型）的定义和对待方式 是与 signed char(有符号字符类型) 的方式相同。但是，在某些系统中，它确实是整型的，而不是char类型。12345678910111213#include &lt;cstdint&gt;#include &lt;iostream&gt; int main()&#123; std::int8_t myint = 65; std::cout &lt;&lt; myint; return 0;&#125;/******************************/运行结果是： A所以，我们要避免使用这几个整型类型。最佳使用整型当整型的大小不做要求时，使用int；如果需要一个保证为特定大小的变量，并且希望提高性能，使用int_fast#_t；如果您需要一个保证为特定大小的变量，并且希望优先考虑内存保护而不是性能，使用 int_least#_t尽量不要使用这些：无符号整型，Unsigned types；8 bits 的固定宽度的整型类型；任何特定于编译器的固定宽度整数（例如，visual studio 定义了 __int8 ，__int16 等等）std::size_t是什么？是一个无符号整数类型，通常用于表示对象的大小或长度。sizeof返回一个std::size_t类型的值。如：1234567891011#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; sizeof(int) &lt;&lt; '\\n'; return 0;&#125;/***********************/结果是： 4 【这个4，就是 std::size_t类型的】size_t本身大小也是不固定的，它确保是无符号的，并且至少是16位。但是在大多数系统中，它的大小将等于应用程序的地址宽度。比如，在32位应用程序中，size_t是一个 32 bits 的无符号整型；在64位应用程序中，size_t是一个 64 bits 的无符号整型。4.7 科学计数法scientific notation科学计数法的形式：a×10^exponent^。其中, a：只能是0~9的数（不包括0，但包括9）如：1.2×10^4^ 、 5.9736 x 10^24^在C++中，我们用字母e（大写E也可以）来代表 10；1.2×10^4^ -&gt; 1.2e4 ； 5.9736 x 10^24^ -&gt; 5.9736e24小于1的分数0.05表示为： 5e-2有效数字：significant digits有效数字的数量定义了数字的精度。(有效数字越多，数字越精确。)e前面的数就是有效数字，如5.9736e24的有效数字是：5.9736，即，5个有效数字4.8 浮点数float永远不要假设浮点数是精确的。三种浮点型数据：float、double、long double与整数一样，c++没有定义这些类型的实际大小(但它确实保证了最小大小)。在现代体系结构中，浮点表示几乎总是遵循IEEE 754二进制格式。在这种格式中：float：4字节；double：8字节，long double：可以等于一个double(8字节)、80 bits(通常填充为12字节)或者 16字节。浮点型数据通常是 有符号的(sign)：123456int x&#123;5&#125;; //整型double y&#123;5.0&#125;; //5.0是一个浮点型(没有后缀，默认情况下是double类型)float z&#123;5.0f&#125;; //5.0是一个浮点型，f后缀表示浮点类型/**********/【注】浮点型数据默认是：double类型的，加上后缀“f”表示是 float类型浮点型数据的输出1234567891011121314#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; 5.0 &lt;&lt; '\\n'; std::cout &lt;&lt; 6.7f &lt;&lt; '\\n'; std::cout &lt;&lt; 9876543.21 &lt;&lt; '\\n';&#125;/*************/输出结果：56.79.87654e+06第一个，即使我们输入的是5.0，但它输出的依然是 5。【默认情况下，如果小数部分为0,std::cout将不会打印数字的小数部分。】第二个输出正常；第三个输出是科学记数的形式。浮点型的范围根据 IEEE 754的表示：浮点型的精度浮点型的默认精度是6：123456789101112131415161718#include &lt;iostream&gt;int main()&#123; std::cout &lt;&lt; 9.87654321f &lt;&lt; '\\n'; std::cout &lt;&lt; 987.654321f &lt;&lt; '\\n'; std::cout &lt;&lt; 987654.321f &lt;&lt; '\\n'; std::cout &lt;&lt; 9876543.21f &lt;&lt; '\\n'; std::cout &lt;&lt; 0.0000987654321f &lt;&lt; '\\n'; return 0;&#125;/*******输出**********/9.87654987.6549876549.87654e+0069.87654e-005注意：根据编译器的不同，指数的位数会被填充。比如：“9.87654e+006”的指数位置就被填充为3位。显示的最小指数位数是特定于编译器的，在Visual Studio 中填充为 3 位浮点变量的精度位数取决于大小(浮点数的精度小于双精度)和存储的特定值(某些值的精度高于其他值)。用 iomanip头文件中的函数 std::setprecison来覆盖std::cout显示的默认精度。12345678910111213#include &lt;iostream&gt;#include &lt;iomanip&gt; // for std::setprecision()int main()&#123; std::cout &lt;&lt; std::setprecision(16); // show 16 digits of precision std::cout &lt;&lt; 3.33333333333333333333333333333333333333f &lt;&lt;'\\n'; // f suffix means float std::cout &lt;&lt; 3.33333333333333333333333333333333333333 &lt;&lt; '\\n'; // no suffix means double return 0;&#125;/*******输出*********/3.3333332538604743.333333333333334可以看出，double类型的比float类型的精度更高。精度不仅影响小数部分，他还影响比较大的数的精度。12345678910111213#include &lt;iostream&gt;#include &lt;iomanip&gt; // for std::setprecision() int main()&#123; float f &#123; 123456789.0f &#125;; // f has 10 significant digits std::cout &lt;&lt; std::setprecision(9); // to show 9 digits in f std::cout &lt;&lt; f &lt;&lt; '\\n'; return 0;&#125;/*********结果**********/123456792123456789.0 的有效数字是10个，但是浮点型通常有7位精度(123456792的结果只能精确到7位有效数字)。我们失去了一些精度!当由于无法精确地存储数字而丢失精度时，这称为rounding error(舍入误差)。小结：通常情况推荐使用double无限循环 &amp; 非数字 ：NaN and Inf123456789101112131415161718192021#include &lt;iostream&gt; int main()&#123; double zero &#123;0.0&#125;; double posinf &#123; 5.0 / zero &#125;; // positive infinity std::cout &lt;&lt; posinf &lt;&lt; std::endl; double neginf &#123; -5.0 / zero &#125;; // negative infinity std::cout &lt;&lt; neginf &lt;&lt; std::endl; double nan &#123; zero / zero &#125;; // not a number (mathematically invalid) std::cout &lt;&lt; nan &lt;&lt; std::endl; return 0;&#125;/*******结果************/1.#INF-1.#INF1.#INDINF代表无穷，IND代表不确定。请注意，输出Inf和NaN的结果是特定于平台的，因此您的结果可能会有所不同。总结：浮点数用于存储非常大或非常小的数字，包括那些具有小数部分的数字。浮点数通常有较小的舍入误差，即使该数的有效位数比精度小。很多时候，这些数据的舍入误差没有被注意到，因为它们非常小，而且由于输出而被截断。但是，对浮点数的比较可能不会得到预期的结果。对这些值执行数学运算将导致舍入误差增大。4.9 布尔型bool实际上，Boolean values(布尔值)存储的布尔变量，不是以true、false的形式。而是以整型类型存储的，即true对应整型1；false对应整型0。即，布尔值被认为是一个整型类型。输出布尔值123456789101112131415161718#include &lt;iostream&gt; int main() &#123; std::cout &lt;&lt;true&lt;&lt;'\\n'; std::cout &lt;&lt;false&lt;&lt;'\\n'; bool b&#123;false&#125;; std::cout &lt;&lt;b&lt;&lt;'\\n'; std::cout &lt;&lt;!b&lt;&lt;'\\n'; return 0; &#125;/***************结果***********/1001如果你想输出“true、false”。你可以用std::boolalpah：std::noboolalpha是关闭作用1234567891011121314151617#include &lt;iostream&gt;int main()&#123; std::cout &lt;&lt; true &lt;&lt; '\\n'; std::cout &lt;&lt; false &lt;&lt; '\\n'; std::cout &lt;&lt; std::boolalpha; //print bools as ture or false std::cout &lt;&lt;true&lt;&lt;'\\n'; std::cout &lt;&lt;false&lt;&lt;'\\n'; return 0;&#125;/********结果**********/10truefalse整型与布尔型的转换：Integer to Boolean conversion*不能用整型数字来初始化bool变量*bool b{4}; //error: 不允许这样转换但是，整型变量可以转换为布尔型：整型 0 可以被转换为false；其他的非0 的整型可以被转换为true12345678910111213141516171819#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; std::boolalpha; // print bools as true or false bool b1 = 4 ; // copy initialization allows implicit conversion from int to bool std::cout &lt;&lt; b1 &lt;&lt; '\\n'; bool b2 = 0 ; // copy initialization allows implicit conversion from int to bool std::cout &lt;&lt; b2 &lt;&lt; '\\n'; return 0;&#125;/********结果**********/truefalse输入布尔型值123456789int main()&#123; bool b &#123;&#125;; // default initialize to false (0) std::cout &lt;&lt; \"Enter a boolean value: \"; std::cin &gt;&gt; b; std::cout &lt;&lt; \"You entered: \" &lt;&lt; b; return 0;&#125;12Enter a Boolean value: trueYou entered: 0发现，布尔型值的输入，只接受：0 和1 (不是 true 或者 false)。所以，如果输入的值是0 和1之外的其他值，都是失败的，即false，所以是0。因为在C++11或者更新的标准中，一个失败的输入也会使变量变为0，所以b也会被赋值为0。4.11 char类型char数据类型是整数类型，这意味着底层值存储为整数，并且保证大小为1字节。但是，与将布尔值解释为true或false类似，将char值解释为ASCII字符。ASCII是美国信息交换标准代码的缩写，它定义了一种特殊的方式来将英文字符(加上一些其他符号)表示为0到127之间的数字(称为ASCII码或代码点)。字符文字总是放在单引号之间。例如，ASCII码97被解释为字符“a”。下面是完整的ASCII字符表:CodeSymbolCodeSymbolCodeSymbolCodeSymbol0NUL (null)32(space)64@96`1SOH (start of header)33!65A97a2STX (start of text)34”66B98b3ETX (end of text)35#67C99c4EOT (end of transmission)36$68D100d5ENQ (enquiry)37%69E101e6ACK (acknowledge)38&amp;70F102f7BEL (bell)39’71G103g8BS (backspace)40(72H104h9HT (horizontal tab)41)73I105i10LF (line feed/new line)42*74J106j11VT (vertical tab)43+75K107k12FF (form feed / new page)44,76L108l13CR (carriage return)45-77M109m14SO (shift out)46.78N110n15SI (shift in)47/79O111o16DLE (data link escape)48080P112p17DC1 (data control 1)49181Q113q18DC2 (data control 2)50282R114r19DC3 (data control 3)51383S115s20DC4 (data control 4)52484T116t21NAK (negative acknowledge)53585U117u22SYN (synchronous idle)54686V118v23ETB (end of transmission block)55787W119w24CAN (cancel)56888X120x25EM (end of medium)57989Y121y26SUB (substitute)58:90Z122z27ESC (escape)59;91[123{28FS (file separator)60&lt;92\\124|29GS (group separator)61=93]125}30RS (record separator)62&gt;94^126~31US (unit separator)63?95_127DEL (delete)初始化字符使用字符 初始化：char cha2{&#39;a&#39;}; // initialize with code point for ‘a’ (stored as integer 97) (preferred)使用整型数值 初始化：char cha1{97}; // initialize with integer 97 (‘a’) (not preferred)输出字符型12345678910111213141516#include &lt;iostream&gt; int main()&#123; char ch1&#123; 'a' &#125;; // (preferred) std::cout &lt;&lt; ch1; // cout prints a character char ch2&#123; 98 &#125;; // code point for 'b' (not preferred) std::cout &lt;&lt; ch2; // cout prints a character std::cout&lt;&lt;'c'; return 0;&#125;/*******结果********/abc【注意】固定宽度我的整型：int8_t类型，是被当做有符号的char类型对待的。12345678910#include &lt;iostream&gt;#include &lt;cstdint&gt;int main()&#123; int8_t a&#123; 97 &#125;; std::cout &lt;&lt; a; return 0;&#125;输出：通过类型转换将字符打印为整数一种(糟糕的)方法是将char赋值给一个整数，然后输出这个整数:1234567891011121314#include &lt;iostream&gt;int main()&#123; char ch&#123;97&#125;; int a&#123;ch&#125;; std::cout&lt;&lt;i; return 0;&#125;/********结果*********/97另一种较好的方法就是：type case：强制类型转换，其格式为：static_cast&lt;new_type&gt;(expression)12345678910111213141516#include &lt;iostream&gt;int main()&#123; char ch1&#123;97&#125;; char ch2&#123;'a'&#125;; std::cout&lt;&lt; static_cast&lt;int&gt; (ch1) &lt;&lt;'\\n'; //强制类型转换 std::cout&lt;&lt; static_cast&lt;int&gt; (ch2) ; //强制类型转换 return 0;&#125;/*********结果********/9797在上面的例子中，变量ch仍然是一个char，并且仍然保持相同的值。知识在本次输出时，输出的是整型类型的值。知识点：当您看到c++语法(不包括预处理器)使用尖括号&lt;&gt;时，尖括号之间的内容很可能是类型。这就是c++处理需要参数化类型的概念的典型方式。【注意】：std::cin将允许您输入多个字符。然而，变量ch只能包含一个字符。因此，只有第一个输入字符被提取到变量ch中，其余的用户输入留在std::cin使用的输入缓冲区中，可以通过后续调用std::cin来提取。12345678910111213141516#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; \"Input a keyboard character: \"; // assume the user enters \"abcd\" (without quotes) char ch&#123;&#125;; std::cin &gt;&gt; ch; // ch = 'a', \"bcd\" is left queued. std::cout &lt;&lt; ch &lt;&lt; \" has ASCII code \" &lt;&lt; static_cast&lt;int&gt;(ch) &lt;&lt; '\\n'; // Note: The following cin doesn't ask the user for input, it grabs queued input! std::cin &gt;&gt; ch; // ch = 'b', \"cd\" is left queued. std::cout &lt;&lt; ch &lt;&lt; \" has ASCII code \" &lt;&lt; static_cast&lt;int&gt;(ch) &lt;&lt; '\\n'; return 0;&#125;输出：)char的大小、范围以及默认的sign(符号)size：C++中char类型通常为：1 byte；sign：默认情况下，char类型是 signed 或者 unsigned；如果使用字符来保存ASCII字符，则不需要指定符号(因为有符号和无符号字符都可以保存0到127之间的值)。一个有符号的字符可以容纳-128到127之间的数字；无符号字符可以容纳0到255之间的数字。转义符：escape sequences转义符以 “\\” 开头,后面跟着一个 字母 或 数字；NameSymbolMeaningAlert\\aMakes an alert, such as a beepBackspace\\bMoves the cursor back one spaceFormfeed\\fMoves the cursor to next logical pageNewline\\nMoves cursor to next lineCarriage return\\rMoves cursor to beginning of lineHorizontal tab\\tPrints a horizontal tabVertical tab\\vPrints a vertical tabSingle quote\\’Prints a single quoteDouble quote\\”Prints a double quoteBackslash\\Prints a backslash.Question mark?Prints a question mark. No longer relevant. You can use question marks unescaped.Octal number(number)Translates into char represented by octal (octal：8进制)Hex number\\x(number)Translates into char represented by hex number(hex：16进制)单引号 VS 双引号 的区别单个字符总是放在 单引号 中。(e.g. ‘a’, ‘+’, ‘5’)。char类型的只能接收一个符号(e.g. 字母 a, + , 数字 5)char ch(&#39;56&#39;); // a char can only hold one symbol放在双引号(例如“Hello, world!”)之间的文本称为字符串string。一个 string是连续字符的集合(因此，一个字符串可以包含多个符号)。std::cout &lt;&lt; &quot;hello world&quot; ; // “Hello, world!” is a string literal知识点：string类型在C++中，不是基本数据类型char的其他类型：wchar_t、char16_t、char32_twchar_t：应避免使用(除非是在windows API接口时使用)。它的大小是在实现时才确定的，它并不可靠。char16_t、char32_t在C++11中添加，以提供对16位和32位Unicode字符的显式支持。在c++ 20中添加了char8_t。4.12 字面常量constant：是固定的值，不可被改变。C++中有两种constant：字面常量、符号常量。literal constant：字面常量，简称：literal。是直接将值插入代码中的。123return 5; //5是一个整型literalbool mynameisqin&#123;true&#125;; //true 是一个布尔型literalstd::cout &lt;&lt;3.4; //3.4 是一个双精度浮点型的literal上面这些都是常数，因为他们不能动态的被改变。就像对象分类型一样，常量也是有类型的：literal 的后缀example：12unsigned int value1 &#123;5u&#125;; //5的类型是 unsigned intlong value2 &#123;6L&#125;; // 6的类型是 long123/*默认情况，浮点类型是 double ；如果想定义其为float类型，可以添加后缀类实现*/float f1 &#123;5.0f&#125;; //5.0 的类型是 floatfloat f2 &#123;4.1&#125;; //4.1的类型是 doublestring literals123std::cout &lt;&lt; \"hello world\"; //这种是 C分割的 string literalstd::cout &lt;&lt; \"hello\" \" world\"; //C++将会把它们连接起来Scientific notation for floating point literals：浮点型literal 的科学计数12double pi &#123;3.14159&#125;; //3.14159是一种一般形式double avogadro &#123;6.02e23&#125;; //6.02e23 是双精度浮点型literal 的科学计数法形式Octal and hexadecimal literals：八进制 &amp; 十六进制 的 literal八进制：octal八进制是以8为底，它可用的数为： 0, 1, 2, 3, 4, 5, 6, 7。123456789/*八进制的前缀是，数字“0”，不是字母“o”*/#include &lt;iostream&gt;int main()&#123; int x&#123;012&#125;; //\"0\"表示这个数字是八进制数 std::cout &lt;&lt;x; return 0;&#125;十六进制：hexadecimal123456789/*十六进制数的前缀是：数字0和字母x，即 0x*/#include &lt;iostream&gt;int main()&#123; int x&#123;0xF&#125;; //0x表示这个数是十六进制数 std::cout&lt;&lt; x; return 0;&#125;十六进制通常用来表示内存地址 或 内存中的原始值。因为相对于二进制，16进制表示起来更加简洁。如：二进制的数0011 1010 0111 1111 1001 1000 0010 0110，单用16进制表示的话，就是3A7F 9826在C++14之前，无法给变量赋一个二进制的literal，但是，16进制对为我们提供了一个有用的解决方法:12345678910111213141516171819#include &lt;iostream&gt; int main()&#123; int bin&#123;&#125;; bin = 0x01; // assign binary 0000 0001 to the variable bin = 0x02; // assign binary 0000 0010 to the variable bin = 0x04; // assign binary 0000 0100 to the variable bin = 0x08; // assign binary 0000 1000 to the variable bin = 0x10; // assign binary 0001 0000 to the variable bin = 0x20; // assign binary 0010 0000 to the variable bin = 0x40; // assign binary 0100 0000 to the variable bin = 0x80; // assign binary 1000 0000 to the variable bin = 0xFF; // assign binary 1111 1111 to the variable bin = 0xB3; // assign binary 1011 0011 to the variable bin = 0xF770; // assign binary 1111 0111 0111 0000 to the variable return 0;&#125;C++14中 二进制的literal在C++14中，使用数字0和字母b，即“0b”。给变量分配二进制的literal：12345678910111213141516171819202122#include &lt;iostream&gt; int main()&#123; int bin&#123;&#125;; bin = 0b1; // assign binary 0000 0001 to the variable bin = 0b11; // assign binary 0000 0011 to the variable bin = 0b1010; // assign binary 0000 1010 to the variable bin = 0b11110000; // assign binary 1111 0000 to the variable return 0;&#125;/*但是二进制数比较长，所以用“ ' ”来当做分隔符，便于读认*/#Include &lt;iostream&gt; int main() &#123; int bin &#123;0b1011'0010&#125;; long value &#123;0'132'673'462&#125;; return 0; &#125;输出 十进制、八进制、十六进制、二进制数decimal、octal、hexadecimal、binaryC++默认输出是十进制数，但是我们可以转换输出格式：123456789101112131415161718#include &lt;iostream&gt;int main()&#123; int x &#123;12&#125;; std::cout &lt;&lt; x &lt;&lt;'\\n'; //默认十进制 std::cout &lt;&lt; std::hex&lt;&lt;x &lt;&lt;'\\n'; //16进制 std::cout &lt;&lt; x &lt;&lt;'\\n'; //x变量的值现在被转换为16进制了 std::cout &lt;&lt; std::oct&lt;&lt; x &lt;&lt;'\\n'; //8进制 std::cout &lt;&lt; std::dec&lt;&lt; x &lt;&lt;'\\n'; //十进制&#125;/*****输出*******/12cc1412输出二进制：输出二进制数比较麻烦一点。需要添加头文件：&lt;bitset&gt;。std::bitset&lt;num&gt;：表示我们存储的位数为num。它可以被初始化成一个 无符号整数值(可以使10，8，16，2进制的形式)123456789101112131415161718#include &lt;iostream&gt;#include &lt;bitset&gt; //for std::bitsetint main()&#123; // std::bitset&lt;8&gt; means we want to store 8 bits std::bitset&lt;8&gt; bin1&#123; 0b1100'0101 &#125;; // binary literal for binary 1100 0101 std::bitset&lt;8&gt; bin2&#123; 0xC5 &#125;; // hexadecimal literal for binary 1100 0101 std::cout &lt;&lt; bin1 &lt;&lt; ' ' &lt;&lt; bin2 &lt;&lt; '\\n'; std::cout &lt;&lt; std::bitset&lt;4&gt;&#123; 0b1010 &#125; &lt;&lt; '\\n'; // we can also print from std::bitset directly(输出完之后，被抛弃) return 0; &#125;/*输出*/11000101 1100010110104.13 const, constexpr, symbolic constants常量 变量：其值不能被修改，情形修改会出错使用关键字const，来表示该变量是常量：放在变量类型的前面、后面 都可以12const double gravity &#123;9.8&#125;; //放在类型的前面【推荐】int const sidesInSquare &#123;4&#125;; //放在类型后面【不推荐】常量变量(const variable)必须在定义时要初始化(即要赋值给他们)。赋值完成，它的值就不能被改变.123456/******常量变量的值被改变*************/const double a &#123;5.0&#125;;a = 1.0; //编译出错，因为常量变量的值被改变/*******常量变量不初始化********/const double a; //compiler error, must be initialized upon definitionruntime VS compile time constantsruntime：程序运行时；compile time：编译器运行时。runtime constants：初始化值只能在运行时解析的常量；compile-time constants：初始化值可以在编译时解析的；当您声明一个const变量时，编译器将隐式地跟踪它是运行时常量还是编译时常量。123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;bitset&gt;#include &lt;cstddef&gt; std::size_t getNumberOfBits()&#123; return 3;&#125; int main()&#123; const std::size_t numberOfBits&#123; 3 &#125;; // Compile-time constant std::bitset&lt;numberOfBits&gt; b&#123;&#125;; const std::size_t otherNumberOfBits&#123; getNumberOfBits() &#125;; // Run-time constant std::bitset&lt;otherNumberOfBits&gt; b2&#123;&#125;; // Error[因为此时需要的是编译时常量，而不是运行时常量] return 0;&#125;常量表达式：constexpr为了提供更多的特性，c++ 11引入了新的关键字constexpr，它确保常量必须是 “编译时常量”:1234567constexpr double gravity &#123;9.8&#125;; //正确，9.8是编译时的字面常量constexpr int sum &#123;4+5&#125;; //正确，4+5的值时编译时的字面常量std::cout &lt;&lt;\"enter your age:\";int age;std::cin &gt;&gt; age;constexpr int myage &#123;age&#125;; //错误，因为“age”是一个运行时常量【小结】：常量变量必须在定义时，对它初始化。当一个变量的值需要是 编译时常量时，推荐使用constexpr来声明它。当一个变量的值需要是 运行时常量时，推荐使用const来声明它。符号常量：symbolic constantssymbolic constant：是 字面常量(literal constant)的值 的名字。两种方法声明符号常量：使用“宏(macro)”定义：【不推荐】#define identifier substitution_text如：#define a 10;使用关键字constexpr变量：【推荐】12constexpr int maxstudentperclass &#123;30&#125;;constexpr int maxnamelength &#123;30&#125;;在多文件程序中使用符号常量在许多应用程序中，需要在整个代码中使用给定的符号常量(而不仅仅是在一个位置)。这些参数可以包括物理或数学常数(如pi或阿伏伽德罗常数)，或特定于应用程序的“调优”值(如摩擦系数或重力系数)。与其每次需要时都重新定义它们，不如在中心位置声明一次并在需要的地方使用它们。这样，如果你需要改变它们，你只需要在一个地方改变它们。有很多种方法来实现它，这里使用比较简单的一种：首先，创建一个头文件来写相关的常量；在这个头文件中，声明一个名称空间；将你要用到的常量写在这个命名空间中；在你需要这些常量的时候，#include这个头文件。example：constants.h (C++11/14):12345678910111213#ifndef CONSTANTS_H#define CONSTANTS_H//define your own namespace to hold constanstsnamespace constants&#123; constexpr double pi &#123;3.14159&#125;; constexpr double avogadro &#123;6.0221413e23&#125;; constexpr double my_gravity &#123;9.2&#125;; //.........other related constants&#125;#endifIn C++17, prefer “inline constexpr” instead:constants.h (C++17 or newer):12345678910111213#ifndef CONSTANTS_H#define CONSTANTS_H// define your own namespace to hold constantsnamespace constants&#123; inline constexpr double pi &#123;3.14159&#125;; inline constexpr double avogadro &#123; 6.0221413e23 &#125;; inline constexpr double my_gravity &#123; 9.2 &#125;; // m/s^2 -- gravity is light on this planet // ... other related constants&#125;#endif使用“作用域解析符::”,在其他文件访问你的常量：main.cpp1234567891011121314#include \"constants.h\"#include &lt;iostream&gt;int main()&#123; std::cout &lt;&lt; \"enter a radius: \"; int radius&#123;&#125;; std::cin &gt;&gt; radius; double circumference &#123;2.0*radius*constants::pi&#125;; std::cout &lt;&lt;\"the circumference is: \" &lt;&lt;circumference &lt;&lt;'\\n'; return 0;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://longlongqin.github.io/tags/C-C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"LearnCpp chapter3","slug":"C&C++/LearnCpp-chapter3","date":"2020-03-30T05:59:58.000Z","updated":"2020-04-19T14:38:29.545Z","comments":true,"path":"archives/5fc07ec4.html","link":"","permalink":"https://longlongqin.github.io/archives/5fc07ec4.html","excerpt":"LearnCpp-chapter3https://www.learncpp.com未完待续~~","text":"LearnCpp-chapter3https://www.learncpp.com未完待续~~","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://longlongqin.github.io/tags/C-C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"LearnCpp chapter2","slug":"C&C++/LearnCpp-chapter2","date":"2020-03-26T09:07:50.000Z","updated":"2020-04-19T14:38:29.702Z","comments":true,"path":"archives/28c74e52.html","link":"","permalink":"https://longlongqin.github.io/archives/28c74e52.html","excerpt":"LearnCpp chapter2https://www.learncpp.com","text":"LearnCpp chapter2https://www.learncpp.com2.1 函数当你读一本书的时候，突然有人给你打电话。然后你就用“书签”夹在当前阅读位置，去接电话。等你电话接完，再回到你放书签的那个地方继续读书。函数调用(function call)是一个表达式。它告诉CPU中断当前函数并在这里“放一个书签”，然后执行另一个函数(就是函数调用中提及的那个函数)。当调用结束后，CPU就返回到“书签”的位置，然后再继续执行。caller：发起函数调用的函数叫做caller；callee(called function)：被调用的函数叫做callee(called function)。int main()的返回值：在int main()函数最后，会有返回值，这个值是返回到操作系统的，为了让操作系统知道这个程序执行成功与否。main函数的返回值，有一个特定名字叫做：status code （状态码）一般 return 0; 表示程序执行成功。返回非零值，表示程序执行错误。【Note】：C++规定，main函数必须是int型的。即： int main()2.3 函数的形参与实参形参(parameter)：是指函数定义中参数；(形参初始化是通过调用者传来的值(即，实参)来初始化的 )实参(argument)：函数调用时的实际参数：1234567891011121314#include &lt;iostream&gt;void printValues(int x, int y) //函数定义时的参数x,y，即这里的x,y是形参&#123; std::cout &lt;&lt; x &lt;&lt; '\\n'; std::cout &lt;&lt; y &lt;&lt; '\\n';&#125; int main()&#123; printValues(6, 7); //调用函数。即，6和7是实参 return 0;&#125;实参与形参如何一起工作？当调用一个函数时，函数所有的parameters都被创建为变量，并且每个arguments的值都被复制到匹配的parameters中。这个过程称为pass by value(按值传递)。关于函数参数求值顺序的警告在C++中，没有规定实参匹配的顺序（顺序：从左→右，还是从右→左），因为匹配顺序不重要。但是，如果实参是函数调用，那就需要注意了：1someFunction(a(), b()); // a() or b() may be called first是从右→左，还是从右→左：取决于a()和b()的功能。如果你想要规定谁先的话，你可以显示的规定匹配顺序，如：1234int avar&#123; a() &#125;; // a() will always be called firstint bvar&#123; b() &#125;; // b() will always be called second someFunction(avar, bvar); // it doesn't matter whether avar or bvar are copied first because they are just values2.4 局部范围局部变量Local variables：函数的形参，和它内部定义的变量 属于“局部变量”。如：123456int add(int x, int y) // function parameters x and y are local variables&#123; int z&#123; x + y &#125;; // z is a local variable too return z;&#125;局部变量生命周期：123456789101112131415161718#include &lt;iostream&gt; int add(int x, int y) // x and y are created and enter scope here&#123; // x and y are visible/usable within this function only return x + y;&#125; // y and x go out of scope and are destroyed here int main()&#123; int a&#123; 5 &#125;; // a is created, initialized, and enters scope here int b&#123; 6 &#125;; // b is created, initialized, and enters scope here // a and b are usable within this function only std::cout &lt;&lt; add(a, b) &lt;&lt; '\\n'; // calls function add() with x=5 and y=6 return 0;&#125; // b and a go out of scope and are destroyed here执行过程：程序开始执行于main()函数；main()函数的变量a被创建并赋值为5；（初始化）★main()函数的变量b被创建并赋值为6；（初始化）★函数add()被调用，并传入实参5，6；add()函数的变量x被创建，并初值为5;（初始化）★add()函数的变量y被创建，并初值为6;（初始化）★操作符“+”计算表达式”x+y”，产生值11；add函数将值11复制回调用者main()函数；add函数的x、y被摧毁；★main()函数在控制台上打印出11；main()函数返回0到操作系统；main()函数的a、b被摧毁。★由此可知，局部变量的生命周期：是从他开始被创建（如上述的第2步，变量a被创建）一直到执行完这个它所在的函数（如上述的第9步）被摧毁。【Note】：变量的创建和摧毁发生在程序的运行期间（runtime）。所以生命周期是一个runtime属性。局部范围标识符的范围决定了在源代码中标识符可以被访问的位置。范围是一个编译期间(compile-time)的属性。（当使用的标识符不在范围内时，编译器会报错）局部变量的范围：开始于它的定义，结束于定义它们的花括号集合的末尾。如下：123456789101112131415161718#include &lt;iostream&gt; // x is not in scope anywhere in this functionvoid doSomething()&#123; std::cout &lt;&lt; \"Hello!\\n\";&#125; int main()&#123; // x can not be used here because it's not in scope yet int x&#123; 0 &#125;; // x enters scope here and can now be used doSomething(); return 0;&#125; // x goes out of scope here and can no longer be used2.5 为什么要用函数使用函数的优势：有组织性Organization：随着程序越来越复杂，若将全部的代码都写在main()函数中，势必会增加复杂性。一个函数就像一个小型程序。将它与main函数分开写，我们就不必去考其余代码。可重用性Reusability：一个函数可以被调用无数次。就可以避免这种情况：如果写在main函数中，要调用n次这个功能，就要重新写这个功能n次。便于测试Testing：因为函数减少了代码冗余，所以首先要测试的代码就更少了。另外，因为函数是自包含的，所以一旦我们测试了一个函数以确保它可以工作，我们就不需要再次测试它，除非我们修改它。这减少了我们必须一次测试的代码量，使得查找bug(或者在第一时间避免bug)变得更加容易。可扩展性Extensibility：抽象化Abstraction：在每次用这个函数时，我们只需要知道它的名字。输入和输出。不必知道它是如何工作的。如何高效的使用函数？在一个程序中出现多次的语句通常应该构成一个函数。例如，如果我们以相同的方式多次读取来自用户的输入，那么这就是一个很好的函数候选。如果我们以相同的方式输出多次，这也是一个很好的候选函数。一个函数通常应该执行一个(且仅一个)任务。当一个函数变得太长、太复杂或难以理解时，可以将其分解为多个子函数。这就是所谓的重构refactoring。2.6 空白与基本格式空白空白Whitespace：是一个术语，指的是用于格式化目的的字符。在c++中，这主要指空格、制表符(tab)和换行。c++编译器通常会忽略空白，只有少数例外(在处理文本时)。因此，我们说c++是一种与空白无关的语言。123456789/*下面这三个都是一样的作用*/std::cout &lt;&lt; \"Hello world!\"; std::cout &lt;&lt; \"Hello world!\"; std::cout &lt;&lt; \"Hello world!\"; std::cout &lt;&lt; \"Hello world!\";【注意】在文本中，不允许换行：123//这种是不被允许的std::cout &lt;&lt; \"hello world!\" ;但是这种情况是可以的：文本只是被空白(空格、制表符(tab)、换行)分离，他将会被连接：123//这里的hello与world都是被双引号包含起来的std::cout &lt;&lt; \"Hello \" \"world!\"; // prints \"Hello world!\"基本格式缩进(indentation)可以用：空格spaces或者tabs（制符表）。如果用制符表，建议将其调整为4个空格的缩进，3个也可以。大花括号（brace）：Google中的C++风格：12int main() &#123;&#125;另一种风格：这一种不容易出错，更容易找出花括号123int main()&#123;&#125;在大花括号中的每条语句，应该从其所在花括号算起隔开一个tab的距离，开始写：12345int main()&#123; std::cout &lt;&lt; \"Hello world!\\n\"; // tabbed in one tab (4 spaces) std::cout &lt;&lt; \"Nice to meet you.\\n\"; // tabbed in one tab (4 spaces)&#125;每一行的字符不要过长，一般不超过80个字符如果一行别操作符(如，&lt;&lt; 、+)分割(split)。这个操作符应该被卸载下一行的开头：123std::cout &lt;&lt; 3 + 4 + 5 + 6 * 7 * 8;通过对齐值或注释或在代码块之间添加间距，使用空白使代码更易于阅读。1234567891011//不易读cost = 57;pricePerItem = 24;value = 5;numberOfItems = 17;//易读cost = 57;pricePerItem = 24;value = 5;numberOfItems = 17;123456789//不易读std::cout &lt;&lt; \"Hello world!\\n\"; // cout lives in the iostream librarystd::cout &lt;&lt; \"It is very nice to meet you!\\n\"; // these comments make the code hard to readstd::cout &lt;&lt; \"Yeah!\\n\"; // especially when lines are different lengths//易读std::cout &lt;&lt; \"Hello world!\\n\"; // cout lives in the iostream librarystd::cout &lt;&lt; \"It is very nice to meet you!\\n\"; // these comments are easier to readstd::cout &lt;&lt; \"Yeah!\\n\"; // especially when all lined up1234567891011121314151617//不易读// cout lives in the iostream librarystd::cout &lt;&lt; \"Hello world!\\n\";// these comments make the code hard to readstd::cout &lt;&lt; \"It is very nice to meet you!\\n\";// especially when all bunched togetherstd::cout &lt;&lt; \"Yeah!\\n\";//易读// cout lives in the iostream librarystd::cout &lt;&lt; \"Hello world!\\n\"; // these comments are easier to readstd::cout &lt;&lt; \"It is very nice to meet you!\\n\"; // when separated by whitespacestd::cout &lt;&lt; \"Yeah!\\n\";2.7 提前声明与定义一个例子：123456789101112#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; \"The sum of 3 and 4 is: \" &lt;&lt; add(3, 4) &lt;&lt; '\\n'; return 0;&#125; int add(int x, int y)&#123; return x + y;&#125;在vs 2013中运行，会出现：add.cpp(5) : error C3861: &#39;add&#39;: identifier not found原因：因为编译器是按照顺序进行编译的。当编译器在main函数的第5行中调用add函数，他不知道add是什么。因为目前为止还没有定义add函数（因为add函数的定义在第9行）如何解决呢？法一：调整代码顺序：让被调用的函数在调用者之前【在复杂程序中，不实用】123456789101112#include &lt;iostream&gt; int add(int x, int y)&#123; return x + y;&#125; int main()&#123; std::cout &lt;&lt; \"The sum of 3 and 4 is: \" &lt;&lt; add(3, 4) &lt;&lt; '\\n'; return 0;&#125;如果在一个复杂的程序中，会调用很多函数，还有嵌套型的调用。如果去一个个个去找出调用顺序，然后去调整代码。这样是很乏味低效的。法二[推荐]：提前声明forward declaration：在使用函数之前，先声明它。（然后就不用关注代码实现的顺序了）提前向声明允许我们在实际定义标识符之前告诉编译器标识符的存在。为了编写一个函数的提前向声明，我们使用一个称为函数原型(function prototype)的声明语句。函数原型包括：函数的 返回类型、名字、形参，以分号(semicolon)结束。但是不包含函数主体(function body)1234567891011121314#include &lt;iostream&gt; int add(int x, int y); // forward declaration of add() (using a function prototype) int main()&#123; std::cout &lt;&lt; \"The sum of 3 and 4 is: \" &lt;&lt; add(3, 4) &lt;&lt; '\\n'; // this works because we forward declared add() above return 0;&#125; int add(int x, int y) // even though the body of add() isn't defined until here&#123; return x + y;&#125;忘记定义函数主题如果声明了函数，但没定义函数，而且这个函数没有被调用，那么这个程序可以被编译&amp;运行；如果声明了函数，但没定义函数，而且而且这个函数有被调用，那么这个程序可以被编译，但链接会出错。1234567891011#include &lt;iostream&gt; int add(int x, int y); // forward declaration of add() using function prototype int main()&#123; std::cout &lt;&lt; \"The sum of 3 and 4 is: \" &lt;&lt; add(3, 4) &lt;&lt; '\\n'; return 0;&#125; // note: No definition for function add上面程序在visual studio 中，会出现：编译成功，链接失败12345Compiling...add.cppLinking...add.obj : error LNK2001: unresolved external symbol &quot;int __cdecl add(int,int)&quot; (?add@@YAHHH@Z)add.exe : fatal error LNK1120: 1 unresolved externals声明 VS. 定义定义(define)：实现(函数或类型）或者是 实例化(对于变量）标识符。123456int add(int x, int y) // implements function add()&#123; int z&#123; x + y &#125;; // instantiates variable z return z;&#125;对于链接器(linker)来说定义（define）是必要的的。单定义规则单定义规则（one definition rule）简称：ODR：在C++中非常有名的规则，主要分三部分：在给定的文件中（这里翻译不准确），每个函数、对象、类型、模板只能有一次定义。在整个程序中，一个对象或者函数只能被定义一次；类型、模板、内置函数、变量 被允许在不同的文件中有相同的定义。违背第1条，将会使编译器发出重新定义错误；123456789101112131415int add(int x, int y)&#123; return x + y;&#125; int add(int x, int y) // violation part1 of ODR, we've already defined function add&#123; return x + y;&#125; int main()&#123; int x; int x; // violation of ODR, we've already defined x&#125;在visual studio中，会出现：1234project3.cpp(9): error C2084: function &#39;int add(int,int)&#39; already has a bodyproject3.cpp(3): note: see previous definition of &#39;add&#39;project3.cpp(16): error C2086: &#39;int x&#39;: redefinitionproject3.cpp(15): note: see declaration of &#39;x&#39;违背第2条，将会使连接器发出重新定义的错误；违背第3条，将会产生未定义的行为。声明声明(declaration)：是一个语句。它告诉编译器这里存在一个标识符和它的类型。12int add(int x, int y); // tells the compiler about a function named \"add\" that takes two int parameters and returns an int. No body!int x; // tells the compiler about an integer variable named x对编译器(complier)而言声明(declaeation)是必要的。在C++中，所有的定义也用作声明。上述例子中的int x是 定义，也是声明。多数情况下，定义符合我们的目的，因为定义能同时满足“编译器”和“链接器”的要求。【所有的定义都是声明，但所有的声明并不一定是定义。这些不是定义的声明有一个名字：纯声明(pure declarations)】一个典型的例子就是：函数原型(function prototype)，它满足编译器的要求，但不满足链接器的要求。其他类型的纯声明包含：提前声明变量 和 类型声明。单定义规则不适用于纯声明。所以，你可以对一些标识符声明n多次都可以（虽然声明n次，会有很多次是冗余的）小结：在很多编程语言中，“声明”就是指“纯声明”；“定义”就是指“定义也可以用于声明”。所以，int x;是一个定义（虽然他既是定义，也是声明）2.9 命名冲突&amp;命名空间命名冲突命名冲突：naming collision (or naming conflict).将两个同名的标识符放在同一个程序中，编译器或者链接器无法区分它们时，就会报错。这种情况就是：命名冲突例如：a.cpp123456#include &lt;iostream&gt; void myFcn(int x)&#123; std::cout &lt;&lt; x;&#125;main.cpp1234567891011#include &lt;iostream&gt; void myFcn(int x)&#123; std::cout &lt;&lt; 2 * x;&#125; int main()&#123; return 0;&#125;当编译器编译这个程序时，它将会单独的编译a.cpp和main.cpp，每个cpp文件都编译成功。但是，当链接时，链接器将会链接a.cpp和main.cpp中所有的定义到一起，此时就发现函数myFun命名冲突了。【注意，虽然函数myFun没有被调用，但在链接时还是会出错】命名冲突一般出现在以下两种情况：一个函数(或全局变量)的两个(或多个)定义被引入到不同的文件中，这些文件被编译到同一个程序中。这将导致一个链接器错误，如上所示。一个函数(或全局变量)的两个(或多个)定义被引入到同一个文件中(通常通过#include)。这将导致编译器错误。对于局部变量，C++提供一种局部范围的机制，它使定义在函数内部的局部变量不会冲突。但这种机制对于函数的名字无效。命名空间命名空间：namespace命名空间：之所以出来这样一个东西，是因为人类可用的单词数太少，并且不同的人写的程序不可能所有的变量都没有重名现象，对于库来说，这个问题尤其严重，如果两个人写的库文件中出现同名的变量或函数(不可避免)，使用起来就有问题了。为了解决这个问题，引入了名字空间这个概念，通过使用 namespace xxx；你所使用的库函数或变量就是在该名字空间中定义的，这样一来就不会引起不必要的冲突了。注意，在同一命名空间中，所有的名字必须是独一无二的。全局命名空间在C++中，任何没有定义在 类、函数、或 命名空间 的名字，都被默认的归为“全局命名空间(global namespace)”，有时也叫“全局范围(global scope)”std 命名空间在最初设计c++时，c++标准库中的所有标识符(包括std::cin和std::cout)都可以在没有std::前缀的情况下使用(它们是全局命名空间的一部分)。但是，这意味着标准库中的任何标识符都可能与你自己定义的标识符的名字(也在全局名称空间中定义)发生冲突。为了避免这种冲突，C++将所有标准库中的所有函数都移入一个叫做“std(是standard的简称)”的命名空间，即：std namespace所以，你看到的std::cout，这并不是它的名字，它实际上只是cout，std只是命名空间的名字，而cout是std namespace中的一部分。【注】：如果你使用一个命名空间中的标识符，你必须告诉编译器，这个标识符是在这个命名空间内。显示的命名空间限定符 std::最直接的方法是：告诉编译器我们使用cout是来自 std这个namespace(命名空间)的。可以使用前缀 “std::” 来完成：1234567#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; \"Hello world!\"; // when we say cout, we mean the cout defined in the std namespace return 0;&#125;‘::’ 是一个操作符，叫做“作用域解析符(scope resolution operator)”。在它左边的标识符表示：所在命名空间的名称；在它右边的标识符表示：这个命名空间的一个 标识符。【注】如果“::”的左边没有东西，则默认为它在全局命名空间( global namespace )中。std::cout就表示cout是在 std namsoace 中。using namespace std另一种方法是：用使用指令(using directive)**using namespace std。123456789#include &lt;iostream&gt; using namespace std; // this is a using directive telling the compiler to check the std namespace when resolving identifiers with no prefix int main()&#123; cout &lt;&lt; \"Hello world!\"; // cout has no prefix, so the compiler will check to see if cout is defined locally or in namespace std return 0;&#125;using directive：告诉编译器 当试图解析一个没有使用命名空间前缀(namespace prefix)的标识符时，检查一个指定的命名空间。【不推荐此方法】：123456789101112131415#include &lt;iostream&gt; // imports the declaration of std::cout using namespace std; // makes std::cout accessible as \"cout\" int cout() // declares our own \"cout\" function&#123; return 5;&#125; int main()&#123; cout &lt;&lt; \"Hello, world!\"; // Compile error! Which cout do we want here? The one in the std namespace or the one we defined above? return 0;&#125;这种情况，将不会被编译。因为编译器不知道我们到底想用我们自己定义的cout函数，还是想用 std命名空间 中的cout函数。并且，虽然标识符名称现在可能不冲突，但在将来的语言修订中，它可能与添加到std名称空间的新标识符发生冲突。2.10 预处理器在编译之前，代码要经过一个阶段，叫做“翻译(translation)”。在翻译阶段会发生许多事情，以使您的代码准备好被编译(如果您感兴趣，可以在这里找到翻译阶段的列表)。应用翻译的代码文件称为翻译单元(translation unit)。最值得注意的是：翻译阶段包含预处理器(preprocessor)。最好将预处理器看作是一个单独的程序，它处理每个代码文件中的文本部分。当预处理器运行时，它从头到尾的扫描源码文件，寻找预处理程序指令。预处理指令(preprocessor directives)，也称作directives：是以“#”符号开始，以换行符结束的指令(不是分号，即不要加分号)。“使用指令(using directives)”不是预处理指令，所以不会被预处理器处理。所以当提起“directive”，通常指的是“preprocessor directive”include当你#include*一个文件，预处理器将会把#include*指令 替换为 include file的内容。（include file 的内容将会被预处理，然后被编译）1234567#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; \"Hello, world!\"; return 0;&#125;当预处理器运行时，预处理器将会把#include &lt;iostream&gt;替换为 名为“iostream”的文件。宏定义宏定义：Macro defines#include 指令可以用来创建宏。在C++中，宏是定义如何将 ‘输入文本’ 转换为 ‘替换输出文本’。宏有两种基本类型：1️⃣对象式宏(object-like macros)。2️⃣函数式宏( function-like macros)函数式宏函数式宏的作用类似于函数，并具有类似的用途。对象式宏可以被定义成以下两种形式：#define identifier#define identifier substitution_text此处，identifier：宏名【一般是大写字母，用下划线表示空格】；substitution_text：替换文本(替换输出文本)1.带有输出文本(substitution_text)：当预处理器处理此条指令时，宏名 将会被替换为‘输出文本’。123456789101112131415161718#include &lt;iostream&gt; #define MY_NAME \"Alex\" int main()&#123; std::cout &lt;&lt; \"My name is: \" &lt;&lt; MY_NAME; return 0;&#125;//预处理程序将上述转换为以下内容:int main()&#123; std::cout &lt;&lt; \"My name is: \" &lt;&lt; \"Alex\"; return 0;&#125;2.不带输出文本：1#define USE_YEN如你所想，这条宏指令工作方式：标识符的任何进一步出现都将被删除，并将被nothing替换!条件编译条件编译：conditional compilation使用条件编译的预处理指令可以设置在什么条件下编译，什么条件下不编译。比较常见的条件编译指令有以下三个：#ifdef*、#ifndef、#endif*#ifdef 预处理指令允许预处理器检查这个标识符(identifier)是否已经被 #define(定义了)。如果被定义，那么在#ifdef*和#endif*之间的代码将会被编译；如果没被定义，这些代码将会被忽略。12345678910111213141516#include &lt;iostream&gt; #define PRINT_JOE int main()&#123;#ifdef PRINT_JOE std::cout &lt;&lt; \"Joe\\n\"; // if PRINT_JOE is defined, compile this code#endif #ifdef PRINT_BOB std::cout &lt;&lt; \"Bob\\n\"; // if PRINT_BOB is defined, compile this code#endif return 0;&#125;ifndef指令和ifdef*指令的作用是相反的。即，如果这个标识符没有被 #define，那么在#ifndef和#endif*之间的代码才会被编译12345678910#include &lt;iostream&gt; int main()&#123;#ifndef PRINT_BOB std::cout &lt;&lt; \"Bob\\n\";#endif return 0;&#125;输出结果是“Bob”,因为PRINT_BOB没有被 #define，所有才会执行。#if 0 ：条件编译的另一个常见用法是使用#if 0来排除正在编译的代码块(就像它在一个注释块中一样):12345678910111213#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; \"Joe\\n\"; #if 0 // Don't compile anything starting here std::cout &lt;&lt; \"Bob\\n\"; std::cout &lt;&lt; \"Steve\\n\";#endif // until this point return 0;&#125;【注】对象式宏不会影响预处理器的其他指令如：12345#define FOO 9 // Here's a macro substitution #ifdef FOO // This FOO does not get replaced because it’s part of another preprocessor directive std::cout &lt;&lt; FOO; // This FOO gets replaced with 9 because it's part of the normal code#endif宏定义的范围指令在编译之前，从上到下逐个文件地解析。同一文件中12345678910111213#include &lt;iostream&gt; void foo()&#123;#define MY_NAME \"Alex\"&#125; int main()&#123; std::cout &lt;&lt; \"My name is: \" &lt;&lt; MY_NAME; return 0;&#125;虽然，上面的代码表面上看起来：#define MY_NAME “Alex”是定义在函数foo内部的。但是预处理器将不会注意，因为它不懂C++中的概念，例如函数。所以，这个程序的执行流程与#define MY_NAME “Alex”在函数foo之前或之后定义的行为相同。但是，一般情况下，我们习惯于将 #define identifiers这种宏定义放在函数的外面。同一项目的不同文件中预处理程序完成后，将丢弃该文件中定义的所有标识符。这意味着指令仅从定义点到定义它们的文件末尾有效。在一个代码文件中定义的指令不会影响同一项目中的其他代码文件。example：function.cpp:1234567891011#include &lt;iostream&gt; void doSomething()&#123;#ifdef PRINT std::cout &lt;&lt; \"Printing!\";#endif#ifndef PRINT std::cout &lt;&lt; \"Not printing!\";#endif&#125;main.cpp12345678910void doSomething(); // forward declaration for function doSomething() #define PRINT int main()&#123; doSomething(); return 0;&#125;运行的结果是：Not printing!因为文件之间的宏定义互不影响。2.11 头文件头文件：Header files当程序变得越来越大了，对每个函数都进行提前声明是很乏味无趣的。如果能够将所有的 提前声明 放在一个地方，然后在需要时导入它们，这不是很好吗?code files：源文件(后缀 .cpp)；header files：头文件(后缀 .h 或 .hpp)头文件的主要用途就是：将 声明 引入 源文件 中。使用标准库头文件1234567#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; \"Hello, world!\"; return 0;&#125;这个程序使用std::cout。但是这个程序没有提供关于std::cout的声明或者定义，那编译器是如何知道std::cout是什么呢？答：因为std::cout在头文件“iostream” 中 已经提前声明过了。当我们#include &lt;iostream&gt;时，我们就请求预处理器将头文件“iostream”中的所有内容(当然也包含std::cout)都复制过来。注意：当#include xxx时，xxx头文件的所有内容都被引入到当前文件中。头文件通常只包含：函数和对象的声明，不包含它们的定义。如 std::cout在头文件“iostream”中声明， 但 定义为c++标准库的一部分，在链接器阶段自动链接到程序中。创建自己的头文件步骤：头文件保护符(header guaed)然后添加头文件(后缀 .h)进行声明；相应的也要添加源文件(后缀 .cpp)进行定义。【注意头文件、源文件的名字要一样】创建完之后：add.h：1234// 1) We really should have a header guard here, but will omit it for simplicity (we'll cover header guards in the next lesson) // 2) This is the content of the .h file, which is where the declarations goint add(int x, int y); // function prototype for add.h -- don't forget the semicolon!add.cpp：1234int add(int x, int y)&#123; return x + y;&#125;main.cpp：12345678#include &lt;iostream&gt;#include \"add.h\" // Insert contents of add.h at this point. Note use of double quotes here.【不是标准库的头文件，一般用双引号\"\"】 int main()&#123; std::cout &lt;&lt; \"The sum of 3 and 4 is \" &lt;&lt; add(3, 4) &lt;&lt; '\\n'; return 0;&#125;上面的程序的编译、链接过程：头文件的&lt;&gt;&amp;””尖括号：Angled brackets ，即&lt;&gt;。尖括号用来告诉预处理程序我们包含了编译器包含的头文件，所以它应该在系统目录中查找那个头文件。双引号：double-quotes，即“”。双引号告诉预处理器这是一个用户定义的头文件，所以它应该在当前目录中寻找这个头文件。如果没找到，它会检查其他的包含路径(已指定为compiler/IDE设置的一部分的路径)。如果还是失败的话，它将去系统目录中寻找这个头文件。“iostream”没 .h 后缀？好奇，为什么“iostream”(或者其他标准库头文件)没有后缀 .h？答：因为iostream.h是另一个头文件iostream.h与iostream：在C++最开始创建的时候，所有标准库都是有 .h 后缀的。但是，后来ANSI委员会修改C++，将所有的标准库放在 std 命名空间 中，进而避免与用户自定义的标识符 冲突。但是为题来了，将这些标准库移入std 命名空间 后，以前的程序将无法运行。为了解决这个问题，一个新的头文件：iostream出现，这个新头文件包含了 iostream.h的所有内容。然后，旧的程序依然可以用#include &lt;iostream.h&gt;，新程序就用#include &lt;iostream&gt;头文件路径建议12#include \"headers/myHeader.h\"#include \"../moreHeaders/myOtherHeader.h\"这种设置成路径形式的头文件，假设现在路径没问题。但是很有可能在某一天，你的文件位置就不小心的被移动了，这时候就用不了了。【建议】将你平常会用到的很多不同的文件放在比较固定的地方，然后在你的 compiler/IDE 这个固定地方的位置。这样当它在当前目录中找不到它们时，它就会去你设置的固定位置找。这通常可以通过在IDE项目设置中设置包含路径或搜索目录来实现。visual studio设置方法：在“解决方案”中，点击project的“属性”，然后看到“VC++目录”中的“包含目录(include directories)”，在这里面添加你要使用的头文件的目录。这种方法的优点是，如果要更改目录结构，只需更改单个编译器或IDE设置，而不必更改每个代码文件。2.12 头文件保护符头文件保护符：header guards重复定义duplicate definition：重复定义123456789101112131415161718192021222324252627//变量重定义int main()&#123; int x; // this is a definition for variable x int x; // compile error: duplicate definition return 0;&#125;//函数重定义#include &lt;iostream&gt; int foo() // this is a definition for function foo&#123; return 5;&#125; int foo() // compile error: duplicate definition&#123; return 5;&#125; int main()&#123; std::cout &lt;&lt; foo(); return 0;&#125;这种比较容易修复。但是在头文件中，很容易出现一个头文件中的定义被include不止一次。这通常发生在 一个头文件 又#include 其他头文件：square.h:12345//在头文件中，不建议出现 定义；但是这里为了方便举例int getSquareSides()&#123; return 4;&#125;geometry.h:1#include \"square.h\"main.cpp:1234567#include \"square.h\"#include \"geometry.h\"int main()&#123; return 0;&#125;上面这个程序。首先，在main.cpp中#include square.h ，它(square.h)将getSquareSides函数的定义复制到main.cpp中。然后，main.cpp又#include geometry.h ，它(geometry.h)又包含了square.h，所以也会将square.h中的内容(包括getSquareSides函数)复制到geometry.h，进而也就被复制到main.cpp中。所以，当解析完所有的#include之后，main.cpp就变成这样：1234567891011121314int getSquareSides() // from square.h&#123; return 4;&#125; int getSquareSides() // from geometry.h (via square.h)&#123; return 4;&#125; int main()&#123; return 0;&#125;所以，就会出现重复定义，编译也会出错。每个单独的文件没问题，但是因为main.cpp最终#include了两次square.h的内容，所以我们遇到了问题。如何解决呢？？？答：使用header guard头文件保护符头文件保护符(header guard)是条件编译(conditional compilation)的指令，它的形式如下：123456#ifndef SOME_UNIQUE_NAME_HERE //SOME_UNIQUE_NAME_HERE：你可以用任何名字代替它#define SOME_UNIQUE_NAME_HERE//这里是写关于 声明 的代码#endif当这个头文件被#included时，预处理器检查SOME_UNIQUE_NAME_HERE是否被定义过。如果这是我们第一次包含这个头文件，SOME_UNIQUE_NAME_HERE还没有被创建。然后就会定义SOME_UNIQUE_NAME_HERE，而且会包含文件的内容。如果这个头文件之前已经被包含到这个文件中，那么SOME_UNIQUE_NAME_HERE是已经被定义过的，而且其内容也以经被包含在这个文件中。所以这个头文件的内容将会被忽略（由于#ifndef）。每一个头文件都应该要有头文件保护符。好的头文件保护符命名规则：&lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H或者&lt;FILE&gt;_&lt;LARGE RANDOM NUMBER&gt;_H或者&lt;FILE&gt;_&lt;CREATION DATE&gt;_H请注意，头文件保护的目标是防止源文件多次接收到被保护的头文件。根据设计，头文件保护不会阻止将给定的头文件(一次)包含到单独的源码文件中。这也会导致意想不到的问题：square.h1234567891011#ifndef SQUARE_H#define SQUARE_H int getSquareSides()&#123; return 4;&#125; int getSquarePerimeter(int sideLength); // forward declaration for getSquarePerimeter #endifsquare.cpp123456#include \"square.h\" // square.h is included once here int getSquarePerimeter(int sideLength)&#123; return sideLength * getSquareSides();&#125;main.cpp12345678910#include &lt;iostream&gt;#include \"square.h\" // square.h is also included once here int main()&#123; std::cout &lt;&lt; \"a square has \" &lt;&lt; getSquareSides() &lt;&lt; \" sides\\n\"; std::cout &lt;&lt; \"a square of length 5 has perimeter length \" &lt;&lt; getSquarePerimeter(5) &lt;&lt; '\\n'; return 0;&#125;注意，square.h包含在main.cpp和square.cpp中。这意味着square.h的内容将被包含一次到square.cpp中，一次到main.cpp中。细节：当square.h被包含在square.cpp中时，在square.cpp结束之前，SQUARE_H都一直被定义。（这阻止了square.h被多次包含于square.cpp。也真是头文件保护符起作用的）。然而，一旦square.cpp结束后，SQUARE_H将不再被定义。这就意味着当预处理器运行main.cpp时，SQUARE_H在main.cpp中最初是没有定义的。结果就是，square.cpp和main.cpp都复制了getSquareSides的定义。这个程序将可以被编译，但是会链接出错（链接器会抱怨为什么会有不止一个的getSquareSides的定义）最好的解决办法就是：将函数的定义放在源文件中(即 .cpp文件中)，头文件中只含有声明。#pragma once#program once的作用和头文件标识符相同，但是它更加短。但是，#program once不是C++官方原生的一部分，所以不是所有的编译器都支持它。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://longlongqin.github.io/tags/C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"Let’s Build A Simple Interpreter-10","slug":"学习笔记/Let's Build A Simple Interpreter/LSBASI-10","date":"2020-03-25T05:21:04.000Z","updated":"2020-04-19T14:38:29.546Z","comments":true,"path":"archives/2f66ae56.html","link":"","permalink":"https://longlongqin.github.io/archives/2f66ae56.html","excerpt":"今天的改进内容：如何进行语法Fenix和解释Pascal的程序头部；如何进行语法分析Pascal的变量声明；将更新解释器，用DIV关键字来表示整数的出发、用品”/“来表示浮点数的除法；添加Pascal语言的注释功能","text":"今天的改进内容：如何进行语法Fenix和解释Pascal的程序头部；如何进行语法分析Pascal的变量声明；将更新解释器，用DIV关键字来表示整数的出发、用品”/“来表示浮点数的除法；添加Pascal语言的注释功能源码下载在进行细致的讲解之前，我们先下载本节的解释器的源码：spy.py和一个简单的Pascal语言的程序：part10.pas。然后再在命令提示符(Windows10系统 可直接在左下角搜索框中搜索“cmd”)中进行输入：python spi.py part10.pas：好了。现在来看看今天要改进的内容，我们将学习：如何进行语法Fenix和解释Pascal的程序头部；如何进行语法分析Pascal的变量声明；将更新解释器，用DIV关键字来表示整数的出发、用品”/“来表示浮点数的除法；添加Pascal语言的注释功能更新后的语法规则更新后的语法规则，如下图所示：这里给出一个简单地Pascal语言的程序，便于理解其语法：12345678910111213141516171819202122PROGRAM Part10;VAR number : INTEGER; a, b, c, x : INTEGER; y : REAL;BEGIN &#123;Part10&#125; BEGIN number := 2; a := number; b := 10 * a + 10 * number DIV 4; c := a - - b END; x := 11; y := 20 / 7 + 3.14; &#123; writeln('a = ', a); &#125; &#123; writeln('b = ', b); &#125; &#123; writeln('c = ', c); &#125; &#123; writeln('number = ', number); &#125; &#123; writeln('x = ', x); &#125; &#123; writeln('y = ', y); &#125;END. &#123;Part10&#125;1. program程序定义的语法规则，包括：保留字“PROGRAM”、程序的名字、一个以点“.”结尾的block。如：123PROGRAM Part10;BEGINEND.上面是一个完整的Pascal程序2. blockblock包含：一个声明规则、复合语句，如：12345678910//示例1VAR number : INTEGER;BEGINEND//示例2BEGINEND3. declarationsPascal的声明有几个部分，每个部分都是可选的。本节中，我们只讨论变量声明的部分。变量声明规则：要么有一个变量声明的子规则，要么是空的。4. VARPascal是静态类语言，也就是说在使用每一个变量之前，都需要明确的声明它的类型。变量的声明在程序中用VAR保留字，如：1234VAR number : INTEGER; a, b, c, x : INTEGER; y : REAL;5. type_spec在本节中，数据类型是两种：INTEGER 和 REAL(float)，常出现在变量声明部分：123VAR a : INTEGER; b : REAL;本节中没有进行设计类型检查，这将会在后续文章中添加6. termterm规则更新之后，将整数、浮点数的出发分开表示：DIV、/1220 / 7 = 2.85714285714 //浮点数出发20 DIV 7 = 2 //整数除法7. factor更新之后可以处理整数、浮点数的常量。以下是今天的完整语法：123456789101112131415161718192021222324252627282930313233343536program : PROGRAM variable SEMI block DOTblock : declarations compound_statementdeclarations : VAR (variable_declaration SEMI)+ | emptyvariable_declaration : ID (COMMA ID)* COLON type_spectype_spec : INTEGER | REALcompound_statement : BEGIN statement_list ENDstatement_list : statement | statement SEMI statement_liststatement : compound_statement | assignment_statement | emptyassignment_statement : variable ASSIGN exprempty :expr : term ((PLUS | MINUS) term)*term : factor ((MUL | INTEGER_DIV | FLOAT_DIV) factor)*factor : PLUS factor | MINUS factor | INTEGER_CONST | REAL_CONST | LPAREN expr RPAREN | variablevariable: ID更新Lexer总结一下，lexer的改变：新的tokens新的保留字添加处理Pascal语言的注释，用skip_comment更新integer更新get_next_token ，使其能够返回新添加的tokens让我们深入研究一下上面提到的变化:为了处理程序头、变量的声明、整数与浮点数常量以及它们的除法。我们需要添加新的tokens，我们还需要更新“INTEGER”的含义：表示一个整数类型，而不是一个整数常量。下面是更新后全部的tokens:PROGRAM (reserved keyword)VAR (reserved keyword)COLON (:)COMMA (,)INTEGER (we change it to mean integer type and not integer constant like 3 or 5)REAL (for Pascal REAL type)INTEGER_CONST (for example, 3 or 5)REAL_CONST (for example, 3.14 and so on)INTEGER_DIV for integer division (the DIV reserved keyword)FLOAT_DIV for float division ( forward slash / )全部的保留字token：123456789RESERVED_KEYWORDS = &#123; 'PROGRAM': Token('PROGRAM', 'PROGRAM'), 'VAR': Token('VAR', 'VAR'), 'DIV': Token('INTEGER_DIV', 'DIV'), 'INTEGER': Token('INTEGER', 'INTEGER'), 'REAL': Token('REAL', 'REAL'), 'BEGIN': Token('BEGIN', 'BEGIN'), 'END': Token('END', 'END'),&#125;处理注释，添加一个skip_comment 函数来处理注释，它的原理就是在找到右花括号“｛”之前，丢弃所有字符：1234def skip_comment(self): while self.current_char != '&#125;': self.advance() self.advance() # the closing curly brace重新命名integer函数为number函数，，使其能够处理整型常量和浮点型常量，如3和3.14：1234567891011121314151617181920212223def number(self): \"\"\"Return a (multidigit) integer or float consumed from the input.\"\"\" result = '' while self.current_char is not None and self.current_char.isdigit(): result += self.current_char self.advance() if self.current_char == '.': result += self.current_char self.advance() while ( self.current_char is not None and self.current_char.isdigit() ): result += self.current_char self.advance() token = Token('REAL_CONST', float(result)) else: token = Token('INTEGER_CONST', int(result)) return token更新get_next_token函数，使其能够返回新增的tokens：1234567891011121314151617181920212223def get_next_token(self): while self.current_char is not None: ... if self.current_char == '&#123;': self.advance() self.skip_comment() continue ... if self.current_char.isdigit(): return self.number() if self.current_char == ':': self.advance() return Token(COLON, ':') if self.current_char == ',': self.advance() return Token(COMMA, ',') ... if self.current_char == '/': self.advance() return Token(FLOAT_DIV, '/') ...更新Parser总结Parser的变化：新的抽象语法树结点（AST nodes）：Program, Block, VarDecl, Type对应新的语法规则的函数：block, declarations, variable_declaration, 和 type_spec.更新已经存在的paeser中的方法：program, term, and factor让我们深入研究一下上面提到的变化:新的AST nodes：Program AST node：表示一个程序，也是我们的根节点：1234class Program(AST): def __init__(self, name, block): self.name = name self.block = blockBlock AST node：包含声明与复合语句：1234class Block(AST): def __init__(self, declarations, compound_statement): self.declarations = declarations self.compound_statement = compound_statementVarDecl AST node：表示一个变量声明，它包含一个边梁节点和变量的类型结点：1234class VarDecl(AST): def __init__(self, var_node, type_node): self.var_node = var_node self.type_node = type_nodeType AST node：表示一个变量类型（INTEGER or REAL）：1234class Type(AST): def __init__(self, token): self.token = token self.value = token.value对应新增的语法规则的函数(方法)：block, declarations, variable_declaration, 和 type_spec.【这些方法负责解析新的语言结构和构造新的AST nodes】：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051def block(self): \"\"\"block : declarations compound_statement\"\"\" declaration_nodes = self.declarations() compound_statement_node = self.compound_statement() node = Block(declaration_nodes, compound_statement_node) return nodedef declarations(self): \"\"\"declarations : VAR (variable_declaration SEMI)+ | empty \"\"\" declarations = [] if self.current_token.type == VAR: self.eat(VAR) while self.current_token.type == ID: var_decl = self.variable_declaration() declarations.extend(var_decl) self.eat(SEMI) return declarationsdef variable_declaration(self): \"\"\"variable_declaration : ID (COMMA ID)* COLON type_spec\"\"\" var_nodes = [Var(self.current_token)] # first ID self.eat(ID) while self.current_token.type == COMMA: self.eat(COMMA) var_nodes.append(Var(self.current_token)) self.eat(ID) self.eat(COLON) type_node = self.type_spec() var_declarations = [ VarDecl(var_node, type_node) for var_node in var_nodes ] return var_declarationsdef type_spec(self): \"\"\"type_spec : INTEGER | REAL \"\"\" token = self.current_token if self.current_token.type == INTEGER: self.eat(INTEGER) else: self.eat(REAL) node = Type(token) return node更新已有的program, term, 和, factor 方法来适应语法的改变：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859def program(self): \"\"\"program : PROGRAM variable SEMI block DOT\"\"\" self.eat(PROGRAM) var_node = self.variable() prog_name = var_node.value self.eat(SEMI) block_node = self.block() program_node = Program(prog_name, block_node) self.eat(DOT) return program_nodedef term(self): \"\"\"term : factor ((MUL | INTEGER_DIV | FLOAT_DIV) factor)*\"\"\" node = self.factor() while self.current_token.type in (MUL, INTEGER_DIV, FLOAT_DIV): token = self.current_token if token.type == MUL: self.eat(MUL) elif token.type == INTEGER_DIV: self.eat(INTEGER_DIV) elif token.type == FLOAT_DIV: self.eat(FLOAT_DIV) node = BinOp(left=node, op=token, right=self.factor()) return nodedef factor(self): \"\"\"factor : PLUS factor | MINUS factor | INTEGER_CONST | REAL_CONST | LPAREN expr RPAREN | variable \"\"\" token = self.current_token if token.type == PLUS: self.eat(PLUS) node = UnaryOp(token, self.factor()) return node elif token.type == MINUS: self.eat(MINUS) node = UnaryOp(token, self.factor()) return node elif token.type == INTEGER_CONST: self.eat(INTEGER_CONST) return Num(token) elif token.type == REAL_CONST: self.eat(REAL_CONST) return Num(token) elif token.type == LPAREN: self.eat(LPAREN) node = self.expr() self.eat(RPAREN) return node else: node = self.variable() return node现在来看看我们的抽象语法树Abstract Syntax Tree，下面是一个Pascal程序：12345678910PROGRAM Part10AST;VAR a, b : INTEGER; y : REAL;BEGIN &#123;Part10AST&#125; a := 2; b := 10 * a + 10 * a DIV 4; y := 20 / 7 + 3.14;END. &#123;Part10AST&#125;它的解析树为：在图中可以看到我们添加的新节点。更新Interpreter现在，剩下的就是向解释器类添加新的访问者方法。下面是将要新增的四个访问方法（对应新增的四种结点）：visit_Programvisit_Blockvisit_VarDeclvisit_Type其中对于VarDecl和Type，解释器对他们什么都不做：123456789101112131415def visit_Program(self, node): self.visit(node.block)def visit_Block(self, node): for declaration in node.declarations: self.visit(declaration) self.visit(node.compound_statement)def visit_VarDecl(self, node): # Do nothing passdef visit_Type(self, node): # Do nothing pass更新visit_BinOp 方法，使其能够准确的解释整数和浮点数的除法：1234567891011def visit_BinOp(self, node): if node.op.type == PLUS: return self.visit(node.left) + self.visit(node.right) elif node.op.type == MINUS: return self.visit(node.left) - self.visit(node.right) elif node.op.type == MUL: return self.visit(node.left) * self.visit(node.right) elif node.op.type == INTEGER_DIV: return self.visit(node.left) // self.visit(node.right) elif node.op.type == FLOAT_DIV: return float(self.visit(node.left)) / float(self.visit(node.right))总结总结一下，在本文中，扩展了Pascal解释器的哪些部分：添加新的语法规则和更新现有的规则；添加新token，并相应地添加新方法去处理这些tokens，更新了现有的方法；parser中：为新的语法结构添加新的AST nodes；向我们的递归下降解析器添加与新语法规则相对应的新方法，并更新一些现有的方法；interpreter中添加新的访问方法，更新了一个现存的访问方法我们也出去了一些“HACKS”(part9 中提到的)：本文的解释器可以处理程序头部(PROGRAM header)变量可以用VAR关键字来声明将整数与浮点数的除法分开来","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let’s Build A Simple Interpreter","slug":"Let’s-Build-A-Simple-Interpreter","permalink":"https://longlongqin.github.io/tags/Let%E2%80%99s-Build-A-Simple-Interpreter/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"LSBASI整理","slug":"学习笔记/Let's Build A Simple Interpreter/1-8整理","date":"2020-03-24T05:34:22.000Z","updated":"2020-04-19T14:38:29.546Z","comments":true,"path":"archives/6fc94bb0.html","link":"","permalink":"https://longlongqin.github.io/archives/6fc94bb0.html","excerpt":"持续更新","text":"持续更新part 3实现了加减混合运算，并引入语法图概念part 4实现了整数的乘除混合运算，引入上下文无关语法(context-free-grammars)，即BNFpart 5实现了加减乘除混合运算，引入结合律(associativity)和优先级(precedence)part 6新增括号运算part 7从本小节开始，将interpreter和parser分开来实现。并引入抽象语法树(AST)和解析树(parse tree)概念part 8新增一元操作符(unary operators)：“+”，“-”part 9整体分析整体分析，不管是part x，都一起分析，看看他的整体结构：Lexertoken类型：12345678910111213141516171819202122INTEGER = 'INTEGER' #用于表示整数类型REAL = 'REAL' #表示浮点型INTEGER_CONST = 'INTEGER_CONST' #整型常量REAL_CONST = 'REAL_CONST' #浮点型常量PLUS = 'PLUS'MINUS = 'MINUS'MUL = 'MUL'INTEGER_DIV = 'INTEGER_DIV' #整型数的除法FLOAT_DIV = 'FLOAT_DIV' #浮点数的除法LPAREN = 'LPAREN' #左小括号RPAREN = 'RPAREN' #右小括号ID = 'ID' #表示有效的标识符ASSIGN = 'ASSIGN' #这种token表示两个字符，“:=”,用于赋值语句BEGIN = 'BEGIN' END = 'END'SEMI = 'SEMI' # 表示分号，用于标记复合语句中的一个句子的结尾DOT = 'DOT' #点，用于Pascal语言中program的定义PROGRAM = 'PROGRAM' VAR = 'VAR'COLON = 'COLON' #冒号COMMA = 'COMMA' #逗号EOF = 'EOF'保留字123456789RESERVED_KEYWORDS = &#123; 'PROGRAM': Token('PROGRAM', 'PROGRAM'), 'VAR': Token('VAR', 'VAR'), 'DIV': Token('INTEGER_DIV', 'DIV'), 'INTEGER': Token('INTEGER', 'INTEGER'), 'REAL': Token('REAL', 'REAL'), 'BEGIN': Token('BEGIN', 'BEGIN'), 'END': Token('END', 'END'),&#125;词法分析器的结构：有一个___init__的函数，在创建实例的时候，就会自动调用这个方法；一个提示错误的函数error；然后开始处理“词”，这里有一个函数advance用于向前进一步(pos会➕1）：peek：为了在以相同的字符开头时，区分是“保留字”还是“标识符”。在这里，我们可以在不消耗下一个字符的情况下去查看缓冲区：就是利用peek_pos移动查看下一个字符，而真正的pos不动。skip_comment：处理注释；skip_whitespace：处理空格；number：在part10之前，叫做integer，因为现在不仅有整型数据，还有浮点型的。所以改名为number。_id：处理“标识符”和“保留字”get_next_token：词法分析器的核心部分，前面的都是设计，现在才开始识别出一个个的token，下面就是列出识别token的种类：其实这里叫做：get_token_and_go_next比较直观，这个函数是，先识别出一个token，然后再继续寻找下一个token左括号token：“{”保留字token、标识符token。（用函数_id()来完成）整型变量token赋值符号“:=”token冒号“:”token分号“;”token逗号“,”token加、减、乘 token除法token整数除法：“DIV” token浮点数除法：“/” token左小括号“(” token ； &amp; 右小括号“)” token点“.” tokenParser​ 语法分析，主要是分析词法分析器传过来的一个个token，分析它们之间的运算关系，即语法：它们之间的关系，即语法，用抽象语法树来表示：一个基类：AST。（后面的继承于它）一个二元操作符类：BinOp(AST)（表示加减乘除运算）","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let's Build A Simple Interpreter","slug":"Let-s-Build-A-Simple-Interpreter","permalink":"https://longlongqin.github.io/tags/Let-s-Build-A-Simple-Interpreter/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"我的云书签","slug":"资源整合","date":"2020-03-22T16:05:49.000Z","updated":"2020-04-19T14:38:29.545Z","comments":true,"path":"archives/eaabd222.html","link":"","permalink":"https://longlongqin.github.io/archives/eaabd222.html","excerpt":"搜集学习资料&好用的工具","text":"搜集学习资料&好用的工具Ⅰ CS 学习00全科资料1. 面试笔记集合资源描述CS-Notes、网页版、【备用链接】📚 技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计、Java、Python、C++准备秋招，欢迎来树上取果实这里将以最短的篇幅，最清晰的层级结构去总结那些对C++后台开发最为核心的内容。《互联网面试笔记》收集和分析互联网常见面试题，并将这些面试知识整理成文方便大家查阅。主要是面向java程序员，但基础知识部分不同语言程序员(c,c++,python等）都可以参考C/C++笔记C/C++ 技术面试基础知识总结，包括语言、程序库、数据结构、算法、系统、网络、链接装载库等知识及面试经验、招聘、内推等信息。 https://interview.huihut.com2. 教程集合学习C &amp; C++学习C &amp; C++ &amp; python&amp;汇编语言 LLVM编译器 数据结构 算法 操作系统 单片机 linux 面试01实用网站geeksforgeeks是印度的一家致力于计算机科学的百科全书，根据不同的用户计算机水平而发布不同的难度等级，从基础到专家级，内容涵盖了编程、算法、面试问题等。​02项目练习基于项目学习（project-based-learning)03编程相关书籍英文版中文版04科目1. 数据结构适合回顾知识点：https://oi-wiki.org/学习教程描述状态数据结构与算法系列博客园中的一个博主写的再看👁️算法学习笔记这里的内容是学习算法过程的一些记录，希望能一直坚持下去。备用可视化工具描述Visualgo可视化的观察数据结构的操作David Galles可视化演示(JS)旧金山大学David Galles可视化演示(JS)可以从代码中可视化算法算法可视化工具是一个交互式的在线平台，可以从代码中可视化算法。更多可视化工具2. learn OpenGL中文教学网址：https://learnopengl-cn.github.io/intro/3. C/C++C语言相关：笨办法学C官方文档cppreference相关网站网站描述Cplusplus这也是一个学习 C++ 的优秀网站，除了提供相应的教程之外，还有一个很棒的论坛。和其它网站相比，它的价值更多体现在参考上，因为里面解释了许多编程概念，如果对某个特定的东西感到困惑，那么这些概念将会很有帮助。TutorialsPointTutorialspoint 是一个顶级网站，之所以这么说，是因为你想学的任何技术（包括 C++），它几乎都提供了详细的教程。保存好就对了，超级有用。Awesome C++GitHub 上的 Awesome-XXX 系列的资源整理，awesome-cpp 就是 fffaraz 发起维护的 C++ 资源列表，内容包括：标准库、Web 应用框架、人工智能、数据库、图片处理、机器学习、日志、代码分析等学习路线C++学习进阶(陈皓)学习教程资料描述LearnCpp一个很好地C++学习网站你好，C++辅助学习文章阅读（有时间可以看）Ⅱ 关注的博客Linux鳥哥的 Linux 私房菜Ⅲ Github中的资源[github仓库排名](https://gitstar-ranking.com/repositories)web开发人员的路线图自学计算机课程的参考计算机技术与科学自学之旅(中文)开源社区大学计算机科学课程中文项目（OSSU CS CN)旨在为英语能力有待提高的中文学习者提供全中文的在线本科计算机科学学习课程。消除学习者在自学计算机课程中遇到的语言障碍。请注意本课程并不是英文课程的对照翻译，而是在其基础上结合地区实际情况提供全中文的在线教育。值得注意的是，我们仍然推荐学有余力者在学习完本课程后系统学习和掌握英语技能。computer-science通往免费自学计算机科学教育的道路!Ⅱ 工具01写作相关编辑器公众号排版(支持Markdown)：推荐【分为：Google插件 &amp; 在线版】在线版135编辑器：一款强大的微信公众号文章排版插件壹伴：壹伴运营神器_新媒体小编最喜欢的微信排版工具短链生成图片压缩RGB及其它类型颜色查询无版权图片Pixabay：Pixabay是一个支持中文搜索的免费可商用图库。Gratisography：Gratisography是一个免费高分辨率摄影图片库，所有的图片都可以用于个人或者商业用途，每周更新图片你只需要点击即可下载。Unsplash：每天更新一张高质量的图片素材，全是生活中的景象作品，清新的生活气息图片。Pexels：根据英文关键词搜索图片，还能根据不同颜色分类查找，匹配的图片复古自带滤镜，风格简约，图片质量很高，素材丰富。VisualHunt：可以通过颜色来查找图片。Photock：天空、水、河、海、草坪、火、山、动物、建筑、夜景、日本景点、日本历史文化图片等等。pngimg：全部都是无背景图片，非常适合那些需要png透明底配图的。而且它分类也很细，找起来方便。Foodiesfeed：专注于美食的图片网站，高清无水印，根据分类选择匹配关键词。Everypixel：Everypixel 是一款帮助用户寻找免费图片素材的搜索引擎，选择免费或付费，利用AI和图片分析技术筛选图片，并查看图片来源网站。https://www.howtostartanllc.org/free-stock-photos/这是一个汇总了很多个免费图片网站的导航。02 云同步备份功能坚果云可以实现本地与云端实时同步，还带有历史版本回退功能。缺点：每月上传只有1G容量，只能同步体积较小的文件。亿方云：可以实现本地与云端实时同步，还带有历史版本回退功能。功能和坚果云类似。其他Markdown 简历排版","categories":[],"tags":[{"name":"forme","slug":"forme","permalink":"https://longlongqin.github.io/tags/forme/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"凸包总结","slug":"学习笔记/计算几何/Convex-Hull/凸包总结","date":"2020-03-22T08:08:18.000Z","updated":"2020-04-19T14:38:29.547Z","comments":true,"path":"archives/bf113a1c.html","link":"","permalink":"https://longlongqin.github.io/archives/bf113a1c.html","excerpt":"","text":"凸包的相关“test”测试一些定义：凸包[Convex Hull]：简单理解为将很多钉子围住的“皮筋”。极点(Extreme Point)：有一个点集S。如果存在通过点P的直线L，使得点集S中除了点P之外的其他的点都在这个直线的同一侧，则这个点P就是极点(Extreme Points)。极边(Extreme Edge)：两个极点连成的边，剩余的所有点均会在该边的一侧。To-Left TestTo-Left测试是相对于另外这两个点所确定的那条有向直线而言的，任何一条有向直线不仅会把平面分成两部分，我们还可以知道哪一边是左边，哪一边是右边。To-Left，其实就是说这个点相对于刚才的那条有向线而言到底是位于它的左侧(就是true)，还是右侧(就是false)。这里用到了行列式来求三角形面积（请看下面手写证明）。下图中的这个行列式实际上算的是它的”面积(指：有向面积）”的两倍。12345678910bool ToLeft (Point p, Point q, Point s) //判断点s对于线段pq的位置&#123; return Area2(p,q,s);&#125;int Area2(Point p, Point q, Point s)&#123; return p.x*q.y - p.y*q.x + q.x*s.y - q.y*s.x +s.x * p.y - s.y *p.x;&#125;行列式来求三角形面积的证明：图片来源于：https://zhuanlan.zhihu.com/p/35543479In-Trangle Test其实这个算法就是判断点是否在三角形内部。这个测试最直接的理解为：使用了三次To-Left Test，三角形有三条边，所以每一条边都测试一次：三次To-Left Test结果相同的（均为true或者是false），则证明在三角形内部。三次结果中有一次不相同，则证明在三角形外部。判断极边123456789101112 //判断极边的核心void checkEdge(Point S[], int n, int p, int q)&#123; bool lEmpty =TRUE, REmpty = TRUE; for( int k=0; k&lt;n&amp;&amp;(LEmpty||REmpty); k++) &#123; if (k!=p &amp;&amp; k!=q) ToLeft(S[p], S[q], S[k]) ? LEmpty=FALSE: REmpty=FALSE; &#125; if(LEmpty || REmpty) S[p].extreme =S[q].extreme= TRUE;&#125;in-convex-polygon test判定待定点是否位于某多边形内部（in-convex-polygon test）实现的方法就是：按一定方向（约定为逆时针）凸包的每条边和待定点做ToLeft test，一旦有一次test为false就说明改点在凸包外面。构造凸包的方法1 利用极点法123456789101112131415void extremePoint (point S[], int n)&#123; for(int s=0; s&lt;n; s++) S[s].extreme = TRUE; for(int p=0; p&lt;n; p++) for(int q=p+1; q&lt;n; q++) for(int r=q+1; r&lt;n; r++) for(int s=0; s&lt;n; s++) &#123; if(s==p || s==q || s==r ||!S[s].extreme) continue; if(Intriangle(S[p],S[q],S[r],S[s])) S[s].extreme = FALSE; &#125;&#125;时间复杂度：O(n^4)2 利用极边法1234567891011121314151617181920void markEE（point S[], int n）&#123; for (int k=0;k&lt;n;k++) //将所有点的初始状态都设置成：非极点 S[K].extreme = FALSE; for (int p=0; p&lt;n; p++) //遍历每条边，看他是否是极边 for(q=p+1; q&lt;n; q++) checkEdge(S,n,p,q) //判断极边的核心&#125; //判断极边的核心void checkEdge(Point S[], int n, int p, int q)&#123; bool lEmpty =TRUE, REmpty = TRUE; for( int k=0; k&lt;n&amp;&amp;(LEmpty||REmpty); k++) &#123; if (k!=p &amp;&amp; k!=q) ToLeft(S[p], S[q], S[k]) ? LEmpty=FALSE: REmpty=FALSE; &#125; if(LEmpty || REmpty) S[p].extreme =S[q].extreme= TRUE;&#125;时间复杂度：O(n^3)3 incremental construction（增量构造）详细讲解：https://www.longlongqin.github.io/archives/7c53.html该算法的核心步骤就是：复杂度 O(n^2)判定新加入点与凸包的位置关系：用in-convex-polygon testin-convex-polygon test在上面有讲向凸包插入新点：support-line如上面的点x，如何插入现有凸包当中呢？插入过程：插入过程其实就是寻找两个连接点s和t，然后将新点x与t、s分别连接得到新的凸包。t、s两个点将原凸包的边界分成两部分：st和ts两个邮箱线段。构造新凸包就要保留远端st，舍弃近端ts。取代ts的是x和s、t的连接线xt和xs。其中xt、xs被称为切线（tangent）或者support line（支撑线）。（配合下图理解）现在就是如何找到t、s这两个点？在凸包上任取一点v，按逆时针方向v点会有一个直接前驱点和直接后继点。考察有向直线xv与点v直接前驱和直接后继的位置关系（两次to left test），记为一个pattern表。【结果无非是四种情况：v的直接前驱和直接后继相对于有向直线xv的位置是RL，LR，LL，RR。例如上图黄色点v，是R和L；蓝色点v分别是L和R。实际上凸包边界st上所有点的pattern都为RL，ts上所有点的pattern都为LR。关键点在于：点S的pattern是LL，点t的pattern为RR。】说了这么多，其实我们可以将上面的两步合为一步：对于每个待定点x，不必特意去考虑它与凸包的位置关系，而是遍历凸包上每一个点。对于凸包边界上的每一个点，我们都能通过两次to left test迅速判断出pattern。对于x位于凸包外部的情况，经过遍历凸包的点，我们很容易就能得到s和t的位置，得到两条support line，从而构造出新的凸包；而对于x位于凸包内部的情况，凸包边界每个点都不可能出现RR或LL的情况，直接舍弃x即可。4 Jarvis March详细讲解：https://longlongqin.github.io/archives/9c7f.html又称：Gift Wrapping算法步骤：初始化所有点，设置点集的初态为 非极点找到开始的第一个极点：用LTL方法寻找下一个极点：用ToLeft test寻找下一个极点循环步骤3，直到找到所有极点也就是：首先从任何一个极点（用LTL确定）开始，然后找到一条以这个极点为端点的极边。然后沿着这个极边的另一个端点（endpoint）出发，再找出下一条极边。如此反复操作，最终会找到一条以最初极点为endpoint的极边，得到一个封闭的环，凸包也构造完成。123456789101112131415161718192021222324252627282930313233int LTL(Point S[], int n) //寻找最下and最左的点作为第一个极点&#123; int ltl = 0; for (int k=1; k&lt;n; k++) &#123; if(S[k].y &lt; S[ltl].y || (S[k].y==S[ltl].y &amp;&amp; S[k].x&lt;S[ltl].x) ) ltl = k; &#125; return ltl;&#125;void Javis (Point S[], int n)&#123; for (int k=0; k&lt;n; k++) S[k].extreme=FALSE; //1.将所有点标记为非极点 int ltl = LTL(S, n); //2.找到ltl int k = ltl; do &#123; S[k].extreme = true; int s = -1; //要找的下一个极点用s表示 for (int t=0; t&lt;n; t++) &#123; if (t!=k &amp;&amp; t!=s &amp;&amp; ( s==-1 || !ToLeft(S[K],S[s],S[t]) ) ) s = t; &#125; S[k].succ = s; //新的极边确定 k = s； //更新k的值，变为下一次查找的边的起点 &#125; while(k != ltl) //如果循环回到了原来的点，则结束&#125;复杂度：Jarvis March算法算法的复杂度更准确的表示为O(nh)。h（凸包边界的点的个数）又由最终输出结果，即凸包本身来决定，输出结果决定了构造过程的复杂度，这就是所谓的“输出敏感性”。这种类型的算法又被称为output sensitive algorithm。这种特性在其它凸包算法中也会体现。5 Graham Scan详细讲解；https://longlongqin.github.io/archives/3478.html算法流程：预排序(presorting)：即找到某个基准点，然后将其余所有的点按照相对于基准点的极坐标排序。它主要做了三个事情：1、找出基准点：用lowest-then-leftmost point（LTL），然后对其他点按照极坐标排序：根据极角排序的方法，在：（https://longlongqin.github.io/archives/510d.html#补：根据极角排序）2、找出起始边：从排好序的点集，选取前两个点，就是起始边。3、将起始边 与 剩下的n-2条边分别存储在不同的栈(stack)中：如下图Scan扫描这一步是算法的核心。scan的过程主要关注三个点：栈S的栈顶（S[0]）、次栈顶（S[1]）和栈T的栈顶（T[0]）。也就下图红色标注的三个点：可以观察到，每次待处理的S[0]和S[1]构成的边一定是一条极边（如上图点1和点2），算法关键步骤就是对边这条极边和T[0]做to left test，判断T[0]位于边S[0]S[1]的左边还是右边。若在左边则继续拓展，若在右边则否定掉此前认定的极边。无论结果如何，每次判定都会将问题规模缩小一个单元，算法结束时T最终肯定为空。T空后，S中存留下的点正是凸包的极点，这些点自底而上正是凸包边界点的逆时针遍历，也得到了整个凸包构造问题的解。复杂度：Graham Scan算法复杂度由三部分决定：persorting，采用一般排序算法，复杂度是O(nlogn)逐步迭代，O(n)：算法一步步纳入新点，会迭代n步。scan，O(?)所以算法的总体复杂度：O(nlogn + n * ?) ，可见scan的复杂度决定了算法总体的复杂度。算法一步步纳入新点，会迭代n步。但是在每个点上都有可能做回溯操作，所以scan的复杂度是不确定的。我们来以上图最坏情况为例，到第8个点时判定为false，舍弃点7，回溯。下一步判断也为false，舍弃点6，回溯。如此回溯直到算法开始的点2。这次scan倒退了高达O(n)个点，如果每次scan都是如此那么算法整体复杂度就为：O(nlogn + n * n) = O(n^2)了，那这种算法的意义也就不大了。其实上述分析并非错误，只是不够精确。O(n^2)确实是Graham Scan算法的一个上界，但是这个上界并不是紧的。问题就出在分析假定了每次都会出现回退高达O(n)个点。代码部分：https://longlongqin.github.io/archives/d4fa.html6 [Divide And Conquer]详细讲解：https://longlongqin.github.io/archives/f32f.html","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"凸包","slug":"凸包","permalink":"https://longlongqin.github.io/tags/%E5%87%B8%E5%8C%85/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"读书笔记","slug":"程序员练级攻略2018","date":"2020-03-21T17:42:57.000Z","updated":"2020-04-19T14:35:43.395Z","comments":true,"path":"archives/7b67faab.html","link":"","permalink":"https://longlongqin.github.io/archives/7b67faab.html","excerpt":"","text":"陈皓——程序员练级攻略提及的书籍&amp;手册等书籍列表：https://github.com/git-zjx/programmer_training_strategy","categories":[],"tags":[],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://longlongqin.github.io"}},{"title":"hexo中插入pdf","slug":"Hexo博客搭建/hexo中插入pdf","date":"2020-03-20T19:10:35.000Z","updated":"2020-04-19T14:38:29.545Z","comments":true,"path":"archives/448ac7f1.html","link":"","permalink":"https://longlongqin.github.io/archives/448ac7f1.html","excerpt":"法1：安装hexo-pdf插件法2：利用html语法：可以轻松设定尺寸","text":"法1：安装hexo-pdf插件法2：利用html语法：可以轻松设定尺寸安装hexo-pdf插件hexo-pdfHexo tag for embeded pdfInstall1$ npm install --save hexo-pdfNormal PDFpdf链接1&#123;% pdf http:&#x2F;&#x2F;7xov2f.com1.z0.glb.clouddn.com&#x2F;bash_freshman.pdf %&#125;本地（我的失败了，还没找到原因）1&#123;% pdf .&#x2F;bash_freshman.pdf %&#125;Google drive1&#123;% pdf https:&#x2F;&#x2F;drive.google.com&#x2F;file&#x2F;d&#x2F;0B6qSwdwPxPRdTEliX0dhQ2JfUEU&#x2F;preview %&#125;Slideshare1&#123;% pdf http:&#x2F;&#x2F;www.slideshare.net&#x2F;slideshow&#x2F;embed_code&#x2F;key&#x2F;8Jl0hUt2OKUOOE %&#125;示例：图片来源于网络利用html语法首先修改_config.yml文件将_config.yml中的post_asset_folder选项置为true1post_asset_folder: true关于这个选项的功能说明如下:当您设置post_asset_folder为true参数后，在建立文件时，Hexo会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。然后新建一篇文章1$ hexo new由于上一步已经将post_asset_folder选项设为了true所以这一步新建文章时会创建一个md文件和一个同名的文件夹为了方便叙述，我用test作为文件和文件夹名编辑test.md用vim或者别的编辑器打开test.mdtest.md文件中加入如下代码&lt;object data=&quot;./test/test.pdf&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;关于这句代码简单的解释data表示你要上传的pdf的路径,使用相对路径，将你要上传的pdf放入第二步生成的test文 件夹type和width就不说了，这里注意height不能设成100%，不然太矮了，显示效果不好可以用浏览器预览，通过F12预估一下高度。我最后代码如下，供参考&lt;object data=&quot;https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/PDF/Google_Cpp_Style_guide_CN.pdf &quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;877px&quot;&gt;这里不一定非用object标签，embed、iframe标签也一样具体参考:网页链接注意：用html方法，在我的主题中，如果它后面有文字，会显示不出来，原因不详。所以实例我放在文章底部展示了参考文章hexo-pdf官方教程hexo中插入pdf解决方法相关文章theme-hexo-pdf使用技巧—-解决hexo-pdf文件显示不全的问题","categories":[{"name":"hexo博客搭建","slug":"hexo博客搭建","permalink":"https://longlongqin.github.io/categories/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"hexo显示pdf","slug":"hexo显示pdf","permalink":"https://longlongqin.github.io/tags/hexo%E6%98%BE%E7%A4%BApdf/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"LearnCpp chapter1","slug":"C&C++/LearnCpp-chapter1","date":"2020-03-18T15:35:37.000Z","updated":"2020-04-19T14:38:29.545Z","comments":true,"path":"archives/a0a78e77.html","link":"","permalink":"https://longlongqin.github.io/archives/a0a78e77.html","excerpt":"LearnCpp-chapter1https://www.learncpp.com","text":"LearnCpp-chapter1https://www.learncpp.com0.5 介绍compiler, linker, and librariesStep 4: Compiling your source code为了编译C++程序，我们需要一个编译器。编译器主要是对每一个.cpp文件做两件事情：它检查你的代码是否符合C++的规则。如果不符合，就会报错（同时返回相应的行号）来帮助你确定什么需要修改，同时停止编译它将C++源代码翻译成机器代码文件（叫做：object file）。object file的名字通常是这种形式：name*.o* 或者 *name.obj***（其中name与.cpp文件的name是对应的）。例如：下面的三个.cpp的源文件，编译之后形成：Step 5: Linking object files and libraries编译器compiler **编译完成后，生成若干的 object files。接下来就需要链接器Linker**出马了。linker的工作主要有三方面：将所有的object files（编译之后生成的）合并成为一个可执行程序executable program此外，linker还可以链接库文件library files（library files是一个已经预编译好的代码经过“打包”，在其他程序中重用）C++有有一个扩充的库，叫做：标准库C++ Standard Library。它提供额外的功能性库，比如我们常用的iostream library你可以有选择性的去链接其他库，比如当你想写一个播放声音的程序。你肯定不想从头到尾的去写如何去读取文件、检查文件是否有效….. 这时候，我们只需要下载相关的库进行利用就方便很多了。连接器会确保所有的跨文件依赖项都正确的解析了。例如：如果你在一个.cpp文件中定义了”A”，然后在另一个.cpp文件中去使用”A”。linker就会将这两个文件联系起来。如果链接不成功，就会报错并且连接终止只要linker成功的完成所有的“object files 和 libraries ”的链接工作，你就会得到一个可执行文件，然后你就可以运行它。Makefile【注】有些开发环境使用Makefile，它是一个描述如何构建一个程序的文件（哪一个文件要编译&amp;链接，或者以不同方式处理）它是一个强大的工具。但是在本系列课程我们不回去讲解它。Steps 6 &amp; 7: Testing and Debugging如果你的可执行程序没有按照预期的工作，那么你就需要调试。Integrated development environments (IDEs)【note】step3、4、5、7（editor, compiler, linker, debugger）都是需要软件的。当然，你可以每一部分都是用独立的软件，但是有这样的一个软件包：integrated development environment (IDE)集成开发环境 将上面四步一体化。0.6 compling your first programConsole projects控制台项目没有graphical user interface (GUI)图形用户界面，它在控制台中打印text，从输入设备键盘读取信息。并且被编译成独立的可执行文件。Workspaces / solutions当创建一个项目时，许多IDE会自动给这个项目创建一个 “workspace” 或 “solution” 。workspace or solution：是一个可以容纳多个相关的项目的container。（例如，你正在写一个游戏，你想有一个单人 与 多人分开的可执行文件，那就需要创建两个项目。但是将这两个项目分开始没有意义的，因为它们属于同一个游戏的。所以，最好的就是每一个都被配置为单个工作空间/解决方案中的 一个单独项目。）0.8 C++中常见问题General run-time issues当执行程序时，控制台窗口闪烁，然后立即关闭？1、首先确保下面的这几行在你的源程序的最上部（visio studio 用户，请确认如果有 #include “pch.h” or #include “stdafx.h” ，那么让它在最顶顶顶部的）12#include &lt;iostream&gt;#include &lt;limits&gt;2、在main()函数中的结束部分（但要在return 语句之前）添加如下：12345std::cin.clear(); // reset any error flagsstd::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n'); // ignore any characters in the input buffer until we find an enter characterstd::cin.get(); // get one more char from the user避免使用：system(&quot;pause&quot;) 因为它只能在特定的操作系统中使用运行程序，得到窗口，但没有输出？有可能是你的xx安全管家等拦截的。试着关闭它们，然后重新运行程序编译成功，但是没有正确工作？去debug它General compile-time issues当编译程序时，得到一个未解析的外部符号：_main or _WinMain@16 ？说明你的编译器找不到main()函数。Visual Studio issues使用Microsoft Visual c++进行编译时，得到C1010 fatal error，并且伴随着提示信息，如：”c:\\vcprojects\\test.cpp(263) :fatal error C1010: unexpected end of file while looking for precompiled header directive”答：这种问题出现在：当microsoft visual c++编译器被设置为使用预编译头文件，但您的c++代码文件中有一个(或多个)没有将#include “stdafx.h” or #include “pch.h”作为代码文件的第一行。建议：在创建项目时，将预编译头 precompiled headers选项关闭。如果您希望保持打开预编译头文件，要修复这个问题，只需找到产生错误的文件(在上面的错误中，test.cpp是罪魁祸首)，并在文件的最顶部添加以下行:#include “pch.h”或者#include “stdafx.h”【老版本的VS使用“stdafx.h” ，当其中一个不起作用，可以换成另外一个】注意，每一个C++文件都是从这一行开始的。如果不想从这一行开始，那就在创建项目的时候关闭“预编译头文件”选项出现错误：“1MSVCRTD.lib(exe_winmain.obj) : error LNK2019: unresolved external symbol _WinMain@16 referenced in function “int __cdecl invoke_main(void)” (?invoke_main@@YAHXZ)”答：您可能已经创建了一个Windows图形化应用程序，而不是控制台应用程序。重新创建项目，并确保将其创建为Windows(或Win32)控制台项目。0.9 配置编译器:“生成（build）”配置debug configuration ：可以帮助你调试你的程序，而且也是IDE默认的。但是它会关掉所有的优化，包含调试信息（这会让你的项目变得很大、很慢）。release configuration：当你将你的程序发布给公众的时候使用release模式。这个模式会优化项目的大小和它的性能，而且不会包含额外的调试信息。所以这种模式适用于：测试你的代码的性能.0.10 配置编译器:编译器扩展c++标准定义了关于程序在特定环境下应该如何表现的规则。在大多数情况下，编译器将遵循这些规则。然而，许多编译器实现自己对语言的更改，通常是为了增强与该语言的其他版本(例如C99)的兼容性，或者是出于历史原因。这些特定于编译器的行为称为编译器扩展（Compiler extensions）。编写使用编译器扩展的程序允许你编写与c++标准不兼容的程序。使用非标准扩展的程序通常无法在其他编译器上编译(这些编译器不支持相同的扩展)，或者即使它们支持，也可能无法正确运行。注意，编译器扩展通常是默认启用的，这对初学者是不友好的，因为它会让初学者觉得某些行为是符合官方C++的标准，但是实际上是因为编译器只是过于宽松。因为，编译器扩展从来都不是必须的，如果开启可能让你误以为你写的代码是符合C++标准的。所以，建议，建议关闭编译器扩展。0.11 配置编译器:warning和error出现error提示：说明你写的代码可能不符合C++语言的标准。出现warning提示：说明编译器认为你的代码的某些地方可能有些错误，但是编译器不能百分百确定。好习惯：不要让warning提示堆积，要尽你所能的去解决warning提示。在大多数情况下出现的warning是需要我们尽量去解决的。但在极少数情况的warning提示，我们需要明确告诉编译器不要产生这个警告。C++官方不支持这样，但是有很多单独的编译器（如：visio studio xx 和GCC）会提供解决方案：利用不可移植 # pragma 指令 来暂时的关闭这个警告。好习惯：将你的经高级别调到最大，特别是在你学习的时候，他会帮你识别潜在的问题。将warnings视为errors如果在你学习的时候，最好告诉编译器让它把warning当做error对待，然后你就不得不去解决出现的warning了。0.12 配置编译器: 选择一个C++标准C++的标准有很多，如：C++98, C++03, C++11, C++14, C++17, 等. 通常情况，编译器的标准都是默认的，而不是最新的C++标准。如果你想使用指定的标准版本，需要手动设置。正在制定中的标准的名字有一些语言标准是按照他最终定案时候的年份（如，C++17是在2017年完成的）。但是，当一个新的语言标准正在制定ing的时候，我们不能确定它最终完成的时间。这个时候这个语言标准的名字 将会被最终完成时候的名字替代，（如，C++11在制作ing时，名字为C++1x，当最终完成的时候“C++1x”就会被替换），比如下面的一些：c++1x = C++11c++1y = C++14c++1z = C++17c++2a = C++20所以，如果你看见C++1Z，这就代表C++17【注意】：在VS xxxx系列的IDE中，是不能设置全局的语言标准的，你只能一个一个项目的去设置1.1 语句与程序结构Statements and the structure of a program语句语句(Statements)是一种指令类型，它使程序执行某些操作。它是最小的独立计算单元。在C++中，一个单独的语句就可能会被编译成很多机器语言指令。下面列出了很多种语句：Declaration statements(声明语句)Jump statements（循环语句）Expression statements（表达式语句）Compound statements（复合语句）Selection statements (conditionals) (条件语句)Iteration statements (loops) （循环语句）Try blocks函数与main函数函数是按照顺序执行的语句集合。每一个C++程序都必须要有一个main函数。一个程序开始执行的时候，开始于main函数中的第一条语句，然后按照顺序执行余下语句。说到函数，你可能会看到main() 或者 doSomething()，后面的括号其实起了一个说明作用。这个括号就说明他前面的那个字符是一个函数的名字。分析“hello world”1234567#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; \"Hello world!\" return 0;&#125;第一行：一个预处理指令。这个预处理器指令指示，我们希望使用iostream库的内容，它是c++标准库的一部分，允许我们从控制台上读写文本。我们需要这一行以便在第5行上使用std::cout。排除这一行将导致第5行出现编译错误，因为编译器不知道std::cout是什么。第2行是空的，编译器会忽略它。这一行的存在只是为了帮助使程序对人类更具可读性(通过分隔#include预处理指令和程序的后续部分)。第3行告诉编译器我们要编写(定义)一个名为main的函数。每个c++程序必须有一个主函数，否则它将无法编译。第4行和第7行告诉编译器哪些行是主函数的一部分。第4行上的左大括号和第7行上的右大括号之间的所有内容都被认为是主函数的一部分。这叫做函数体第5行是main函数中的第一个语句，也是运行程序时执行的第一个语句。cout(代表“字符输出”)和&lt;&lt;操作符允许我们将字母或数字发送到要输出的控制台。在本例中，我们向它发送文本“Hello world!”，将输出到控制台。此语句创建程序的可见输出。第6行是一个返回语句。当可执行程序完成运行时，程序将一个值发送回操作系统，以指示它是否成功运行。按照惯例，这个特殊的return语句将0的值返回给操作系统，这意味着“一切正常!”这是执行的程序中的最后一条语句。结尾，什么是C++ 标准库？答：一个标准库文件是一个 预编译代码的集合，它被“打包”起来，以供其他程序重用。1.2 注释正确的注释：At the library, program, or function level, use comments to describe what.Inside the library, program, or function, use comments to describe how.At the statement level, use comments to describe why.1.3 — Introduction to variablesdata：数据data就是可以被电脑移动、存储、处理的任何信息。计算机上的数据通常以一种便于存储或处理的格式存储(因此人类无法读懂)，这种格式就是：二进制（binary）Objects and variables：对象和数据RAM(random access memory)：随机存取存储器。在程序中，你可以把RAM看作一列邮箱，它可以在程序运行时存储数据。存储在内存中的单个数据，称为value在C++中，不允许直接访问内存。但可以通过object来访问内存。一旦创建object，编译器就自动的决定这个object存放在内存中的位置。object：是具有value和其他相关属性的存储区域。这样，我们就可以说，获取这个object的value，编译器直到这个value存储在内存的具体位置。也就是说，我们可以只关注使用object(对象)来存储和检索value，而且不用担心它在内存中的存储位置。object(对象)可以命名也可以不命名。有名字的object叫做：variable(变量)。这个object的名字，叫做：标识符(identifier)。在一般编程中，对象通常指内存中的变量、数据结构或函数。在c++中，“对象”的定义较窄，将函数排除在外。Variable instantiation：变量实例化为了创建一个变量，需要用一种特殊的声明：定义1int x; // define a variable named x, of type int在编译时，当编译器看到这个语句，它会告诉自己我们需要定义一个变量，变量名字叫x，类型为int。从此之后，只要编译器看到标识符x，它就知道我们在引用这个变量。程序运行时(称为：runtime)，该变量将会被实例化。变量在用来存储values之前，必须要先实例化。实例化：对象(object)将会被创建，并且会分配一个内存地址。为了便于举例，假设变量x是在内存位置140处实例化的。当程序使用变量x时，它将访问内存位置140中的值。实例化的对象有时也称为实例。Data types：数据类型Data types(更通用的称呼：type)：它告诉编译器变量将会存储什么类型的value在c++中，变量的类型必须在编译时(当程序被编译时)已知，如果不重新编译程序，就不能更改该类型。这意味着一个整型变量只能包含整型值。如果希望存储其他类型的值，则需要使用不同的变量。SummaryData is any sequence of symbols (numbers, letters, etc…) that can be interpreted to mean something.A value is a single piece of data stored in memory.【值是存储在内存中的单个数据块。】A variable is a named region of memory.【变量是一个命名的内存区域。】An identifier is the name that a variable is accessed by.【标识符是变量被访问的名称】A type tells the program how to interpret a value in memory.【类型是告诉程序如何解释内存中的值】1.4 变量赋值与初始化定义变量：12int x; // define an integer variable named xint y, z; // define two integer variables, named y and z变量赋值：12int width; // define an integer variable named widthwidth = 5; // copy assignment of value 5 into variable width初始化变量：(定义&amp;赋值同时进行)1int a = 1; //初始化变量a为1C++初始化变量的形式有三种：使用“=” copy initialization1int width = 5; // copy initialization of value 5 into variable width使用括号“()” direct initialization 【这种在一些高级数据类型上，性能较好】1int width(5); // direct brace initialization of value 5 into variable width (preferred)使用大括号“{}” Brace initialization(uniform initialization)[推荐这种]这种可以用于对象初始化一系列的数据123/*推荐第一种形式*/int width&#123; 5 &#125;; // direct brace initialization of value 5 into variable width (preferred)int height = &#123; 6 &#125;; // copy brace initialization of value 6 into variable height另外，空初始化：用空的花括号对数据进行Zero initialization。它表示对该变量初始化为0，或者为空。1int width&#123;&#125;; //zero initialization to value 0对于上述三种初始化方法，看一下下面的例子：1234567891011121314#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 1.2; int b(2.8); int c&#123; 3.1 &#125;; cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; endl; cin.clear(); cin.ignore(numeric_limits&lt;streamsize&gt;::max(), '\\n'); cin.get();&#125;运行结果：从运行结果可以看出，第1和2种方法只会基于“警告”，它们运行结果就是只把整数部分初始化给响应变量；而第三种就直接提示“出错”。变量初始化是很有必要的。如果不初始化，编译器可能报错的ヾ(≧O≦)〃嗷~1.5介绍输入输出流：cout cin endlstd::endl 与 ‘\\n’使用’\\n’的效率比std::endl高。因为：std::endl做两件事：1、将光标一刀下一行；2、它“刷新”输出(确保它立即显示在屏幕上)‘\\n’只做一件事：1、将光标一刀下一行；&lt;&lt; 、&gt;&gt;&lt;&lt;： insertion operator (&lt;&lt;)&gt;&gt;： extraction operator (&gt;&gt;)1.6 未初始化&amp;未定义初始化、赋值、未初始化：不像其他语言，C/C++在定义的时候，不会自动的给变量赋值(比如说 0)。所以说，如果一个变量被编译器分配到一个内存地址，如果他没有被人为的赋值，它默认的值就是这个内存地址原来存储的值（也叫“垃圾值”）。Initialization = 在对象被定义的同时给它赋值；Assignment = 在对象被定义之后，再赋值给它；Uninitialized = 对象只是被定义，但是还没有被赋值。所以，我们应该记住要初始化对象（因为现在，初始化对象的成本与带来的好处相比，成本不值一提）。不初始化对象，可能会出现无法预料的错误。未初始化行为，可能带来以下症状：程序每次运行都会有不同的结果；程序每次运行都会出现一个相同的错误结果；程序结果不稳定：有时结果正确，有时结果是错误的；程序似乎工作，但是稍后的结果不正确；程序崩溃；程序可以在一些编译器上运行，但在其他编译器中不能运行；1.7 关键字&amp;标识符关键字：C++17中的关键字（keywords 或者 reserved words）有84个关键字。标识符：变量、函数、类、模块、或任何其他用户自定义项目的 的名字 叫做：标识符。命名规则：标识符名字不能和保留字重名；标识符只能由字母、下划线、数字；标识符必须以 字母 或 数字 开头（“以下划线开头”的一般都是操作系统的保留字；库，或者是编译器使用的）；C++对大小写敏感，所以wa和WA和Wa和wA互不相同。1.8 常量&amp;操作符常量(literal，literal constant)：是一个已直接插入源代码的固定值。常量与变量都有一个value（和一个type）。但是，常量的值不可更改。操作符(Operators)：在数学中，操作是一种数学计算，包括0个或多个输入值(称为操作数operands)，它们产生一个新值(称为输出值)。要执行的特定操作由一个称为操作符的结构(通常是一个符号或一对符号)表示。操作符分为三类：一元操作符(Unary operators)：只有一个操作数；二元操作符(Binary operators)：有两个操作数（左边、右边各一个）；三元操作符(Ternary operators)：有三个操作数。在C++中只有一个三元操作符。1.9 表达式表达式与语句的区别？当我们需要程序执行某个操作时，使用语句；当我们需要程序计算有一个值的时候，使用表达式。表达式、语句、表达式语句？123int x; //语句不含表达式int x=5; //语句包含表达式x=5; //表达式语句总结chapter 1语句(statement)：是一种指令，它通常使程序执行某些操作，语句以分号（semicolon）结尾。预处理指令(Preprocessor directives)：告诉编译器执行一种特殊任务。在本章中，用到的是”#include &lt;iostream&gt;“","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://longlongqin.github.io/tags/C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"Let’s Build A Simple Interpreter-9","slug":"学习笔记/Let's Build A Simple Interpreter/LSBASI-9","date":"2020-03-18T06:44:30.000Z","updated":"2020-04-19T14:38:29.702Z","comments":true,"path":"archives/8632918.html","link":"","permalink":"https://longlongqin.github.io/archives/8632918.html","excerpt":"今天要学习的内容：如何parse and interpret 一个Pascal程序的定义 definition如何parse and interpret 复合语句compound statements如何parse and interpret 赋值语句(包括变量)assignment statements, including variables.介绍符号表，以及如何存储和查找变量。","text":"今天要学习的内容：如何parse and interpret 一个Pascal程序的定义 definition如何parse and interpret 复合语句compound statements如何parse and interpret 赋值语句(包括变量)assignment statements, including variables.介绍符号表，以及如何存储和查找变量。原文链接：https://ruslanspivak.com/lsbasi-part9/本节源代码：https://github.com/rspivak/lsbasi/tree/master/part9/python下面是一个简单的 Pascal程序，来介绍新概念：123456789BEGIN BEGIN number := 2; a := number; b := 10 * a + 10 * number / 4; c := a - - b END; x := 11;END.今天所学内容与前面的part1~8相比有了很大的飞跃，现在不再是像以前一样只是一个计算器了。我们要提升一下档次了😊新的语法树及规则现在，来看看新语言结构的语法树syntax diagrams 以及其对应的语法规则grammar rules)pascal语法一个Pascal语法由一下组成&lt;这不是完整的定义，会在后面文章慢慢扩展&gt;：BEGIN开头中间是复合语句compound statement一个点(dot) “.”结束compound statementcompound statement是一个block(区块)：它标有BEGIN 和 END ，中间可能(也可能没有)包含有一段语句或其他的复合语句compound statement所有嵌入在复合语句中的句子，除了最后一个，其他的都要以分号“;”结尾在block中的最后一个句子(last statement)可能或可能没有 中断分号“;”如下面所示：1234“BEGIN END”“BEGIN a := 5; x := 11 END”“BEGIN a := 5; x := 11; END”“BEGIN BEGIN a := 5 END; x := 11 END”statement list一个statement list 含有0个或多个语句，其位于compound statement内。如上面的例子statement一个statement可以是一个 *compound statement， 一个赋值语句assignment statement，或者是一个空语句*empty statement。assignment statement一个赋值语句的组成：一个变量 后面跟着 一个指定的token（two characters, ‘:’ and ‘=’） 后面跟着 一个表达式。如下所示：12“a := 11”“b := a + 9 - 5 * 2”varible一个 变量variable是一个标识符identifier。我们将用ID token来表示variables，这个token的value是变量的名字(如，‘a’、‘number’、‘x’…..)。在下面的一个block的代码中的‘a’、‘b’就是变量：1“BEGIN a := 11; b := a + 9 - 5 * 2 END”empty statement一个空语句表示一个语法规则，这个语法规则没有更深层的产生式productions。我们使用empty_statement语法规则来描述语法分析中末尾的statement_list ；同时也允许一个空的复合语句compound statements表示为：‘BEGIN END’factorfactor的规则更新为处理变量。完整的语法1234567891011121314151617181920212223242526program : compound_statement DOTcompound_statement : BEGIN statement_list ENDstatement_list : statement | statement SEMI statement_liststatement : compound_statement | assignment_statement | emptyassignment_statement : variable ASSIGN exprempty :expr: term ((PLUS | MINUS) term)*term: factor ((MUL | DIV) factor)*factor : PLUS factor | MINUS factor | INTEGER | LPAREN expr RPAREN | variablevariable: ID上面的语法中，在compound_statement rule 中没有用“*”来表示重复（0或多次），而是明确的制定了 statement_list rule。这是另一种方法来表示“0或多次”的操作。这在后面的语法分析器（如PLY）会派上用场。我还将规则：“(PLUS | MINUS) factor”也细分成两个规则。修改lexer,parser,interpreter为了支持更新后的语法，我们需要修改我们的此番分析器、语法分析器和解释器。lexer的改变下面是我们此番分析器有改动的地方：为了支持Pascal程序的定义、复合语句、赋值语句、变量。我们需要新的token类型：（Pascal program’s definition, compound statements, assignment statements, and variables）BEGIN (标记复合语句的开始)END (标记复合语句的结束)DOT (一个token表示 点，用于Pascal程序的定义)ASSIGN (一个token表示两个字符， ‘:=’)在Pascal中，赋值操作符不同于其他语言（如C语言用 “=”）SEMI (一个token表示分号‘ ; ’ 。用来标记在复合语句中的一个句子的结尾)ID（一个token表示 有效的标识符。）有时候，为了区分不同token（它们都以相同的字符为开头，如：‘:’ vs ‘:=’ or ‘==’ vs ‘=&gt;’），我们需要在不消耗下一个字符的情况下去查看输入缓冲区。为了这个特殊的目的，我介绍一种查看方法peek method，这种方法将帮助我们标记赋值语句。这个方法不是必要的，但是还是想早一点介绍一下，并且它也使得get_next_token函数简洁一些。它所做的目的就是：从文本缓冲区返回下一个字符，但不增加self.pos的值。下面是这个方法的代码：123456def peek(self): peek_pos = self.pos + 1 if peek_pos &gt; len(self.text) - 1: return None else: return self.text[peek_pos]因为pascal中的 变量 和 保留字 都是 标识符。所以我们需要用一个方法来区分它们，方法为：_id。它工作的原理：词法分析器对这个字母、数字序列进行检查，看这个序列是否是保留字reserved keyword，如果是，就返回一个预先构造的token来表示这个保留字；如果不是，就返回一个新的ID token（它的值就是这个字符串）（lexeme）.下面是它的代码：1234567891011121314RESERVED_KEYWORDS = &#123; 'BEGIN': Token('BEGIN', 'BEGIN'), 'END': Token('END', 'END'),&#125;def _id(self): \"\"\"Handle identifiers and reserved keywords\"\"\" result = '' while self.current_char is not None and self.current_char.isalnum(): result += self.current_char self.advance() token = RESERVED_KEYWORDS.get(result, Token(ID, result)) return token词法分析器的函数get_next_token的改变:12345678910111213141516171819def get_next_token(self): while self.current_char is not None: ... if self.current_char.isalpha(): return self._id() if self.current_char == ':' and self.peek() == '=': self.advance() self.advance() return Token(ASSIGN, ':=') if self.current_char == ';': self.advance() return Token(SEMI, ';') if self.current_char == '.': self.advance() return Token(DOT, '.') ...parser的改变下面是它的总的变化：新的AST结点：Compound AST node：表示一个复合语句，在它的孩子的变量中包含着语句节点的列表；1234class Compound(AST): \"\"\"Represents a 'BEGIN ... END' block\"\"\" def __init__(self): self.children = []Assign AST node：表示赋值语句。它的左孩子的值是Var node，右孩子结点存储着由expr解析器返回的结点。12345class Assign(AST): def __init__(self, left, op, right): self.left = left self.token = self.op = op self.right = rightVar AST node：表示一个变量，它的value就是着这个变量的名字12345class Var(AST): \"\"\"The Var node is constructed out of ID token.\"\"\" def __init__(self, token): self.token = token self.value = token.valueNoOp node：用来表示一个空语句。如‘BEGIN END’ 是一个有效的复合语句但没有句子。12class NoOp(AST): pass我们之前讲过，在我们的递归的语法分析器中每一个语法的规则都有相应的函数(method)。这次将增加7个新的函数。这些函数都是用于语法分析中新的语法和新的AST结点。下面就是：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374def program(self): \"\"\"program : compound_statement DOT\"\"\" node = self.compound_statement() self.eat(DOT) return nodedef compound_statement(self): \"\"\" compound_statement: BEGIN statement_list END \"\"\" self.eat(BEGIN) nodes = self.statement_list() self.eat(END) root = Compound() for node in nodes: root.children.append(node) return rootdef statement_list(self): \"\"\" statement_list : statement | statement SEMI statement_list \"\"\" node = self.statement() results = [node] while self.current_token.type == SEMI: self.eat(SEMI) results.append(self.statement()) if self.current_token.type == ID: self.error() return resultsdef statement(self): \"\"\" statement : compound_statement | assignment_statement | empty \"\"\" if self.current_token.type == BEGIN: node = self.compound_statement() elif self.current_token.type == ID: node = self.assignment_statement() else: node = self.empty() return nodedef assignment_statement(self): \"\"\" assignment_statement : variable ASSIGN expr \"\"\" left = self.variable() token = self.current_token self.eat(ASSIGN) right = self.expr() node = Assign(left, token, right) return nodedef variable(self): \"\"\" variable : ID \"\"\" node = Var(self.current_token) self.eat(ID) return nodedef empty(self): \"\"\"An empty production\"\"\" return NoOp()factor 函数的修改：12345678910111213141516def factor(self): \"\"\"factor : PLUS factor | MINUS factor | INTEGER | LPAREN expr RPAREN | variable \"\"\" token = self.current_token if token.type == PLUS: self.eat(PLUS) node = UnaryOp(token, self.factor()) return node ... else: node = self.variable() return nodeparse ：更新之后，它从程序的定义开始语法的分析：123456def parse(self): node = self.program() if self.current_token.type != EOF: self.error() return node下面是一个简单的程序：123456789BEGIN BEGIN number := 2; a := number; b := 10 * a + 10 * number / 4; c := a - - b END; x := 11;END.它的解析树为（为了简洁，下面的树中变量的名字所在结点就是Var node， Assign node赋值结点表示为 ‘:=’ ）：interpreter的改变为了解释新的AST结点，我们需要在interpreter中添加相应的visitor 函数：visit_Compoundvisit_Assignvisit_Varvisit_NoOp其中，visit_Compound：遍历它的孩子节点，visit_NoOp：什么都不做。123456def visit_Compound(self, node): for child in node.children: self.visit(child)def visit_NoOp(self, node): passvisit_Assign：当我们给变量赋值时，需要将该变量的值存到某个地方，待用。这也就是此函数的功能：123def visit_Assign(self, node): var_name = node.left.value self.GLOBAL_SCOPE[var_name] = self.visit(node.right)这个函数存储了一个键-值对key-value pair（一个变量名、一个变量的值），存储在symbol table GLOBAL_SCOPE。what is symbol table?symbol table是一个抽象数据类型（abstract data type (ADT)），用于跟踪源码中各种符号。目前的符号类型还只有变量，我们用Python字典趋势线符号表的ADT。（在这里用符号字表 实现的笨拙：因为它不是一个带有特殊方法的独立类，而是一个简单的Python字典，而且它的另外职责是 内存空间。在后面的文章中，原作者将会带我们了解symbol tables的细节）让我们来看一下“a := 3;” 的AST，和它的 symbol table （visit_Assign 函数处理前和处理后的）：现在让我们看看句子：“b := a + 7;”的AST：visit_Var：可以看出，赋值语句得到右半部分：“a + 7” 提及变量a，所以我们要先知道变量a的value，这就是visit_Var函数要干的事情：1234567def visit_Var(self, node): var_name = node.value val = self.GLOBAL_SCOPE.get(var_name) if val is None: raise NameError(repr(var_name)) else: return valvisit 一个 Var 结点：它首先得到变量的名字；然后这个变量名字作为进入GLOBAL_SCOPE dictionary的key🔑去寻找变量的value，如果找到了 就返回变量地值，如果找不到就NameError函数伺候。下面是“b := a + 7;”的AST和符号表（赋值前和复制后）上面就是今天所有需要进行的update了。At the end of the main program, we simply print the contents of the symbol table GLOBAL_SCOPE to standard output.Let’s take our updated interpreter for a drive both from a Python interactive shell and from the command line. Make sure that you downloaded both the source code for the interpreter and the assignments.txt file before testing:Launch your Python shell:123456789101112131415161718192021$ python&gt;&gt;&gt; from spi import Lexer, Parser, Interpreter&gt;&gt;&gt; text &#x3D; &quot;&quot;&quot;\\... BEGIN...... BEGIN... number :&#x3D; 2;... a :&#x3D; number;... b :&#x3D; 10 * a + 10 * number &#x2F; 4;... c :&#x3D; a - - b... END;...... x :&#x3D; 11;... END.... &quot;&quot;&quot;&gt;&gt;&gt; lexer &#x3D; Lexer(text)&gt;&gt;&gt; parser &#x3D; Parser(lexer)&gt;&gt;&gt; interpreter &#x3D; Interpreter(parser)&gt;&gt;&gt; interpreter.interpret()&gt;&gt;&gt; print(interpreter.GLOBAL_SCOPE)&#123;&#39;a&#39;: 2, &#39;x&#39;: 11, &#39;c&#39;: 27, &#39;b&#39;: 25, &#39;number&#39;: 2&#125;And from the command line, using a source file as input to our interpreter:12$ python spi.py assignments.txt&#123;&#39;a&#39;: 2, &#39;x&#39;: 11, &#39;c&#39;: 27, &#39;b&#39;: 25, &#39;number&#39;: 2&#125;If you haven’t tried it yet, try it now and see for yourself that the interpreter is doing its job properly.summary让我们来总结一下，你今天扩展了Pascal解释器的哪些部分：添加新的语法规则添加新的token，和它对应词法分析器中的方法（也更新了get_next_token）在 parser 中为新的语法结构添加新的AST结点在（递归下降的）语法分析中 添加相应对应新语法规则的新函数，在interpreter中增添了新的visitor函数新增 用于存储和查找变量的字典HACKS现在要介绍一下“hacks”（不完善的地方），并且随着系列文章的深入，我们还将一步步解决这些内容：上图中的不完善的地方，也就是这些：program 语法规则目前不完善，在后续文章会扩展；Pascal语言是一个静态类型语言，在使用变量之前必须要先声明；没有类型检测，目前还不是什么大问题。但当有更多类型的时候，就需要类型检测；符号表目前为止，都是用“/”来表示除法。但在Pascal语言中，必须要用关键字“div”来表示整数除法；在Pascal语言中，标识符 和 保留字 是不区分大小写的(case insensitive)。但是在目前的文章中，我们把它设计成了区分大小写。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let's Build A Simple Interpreter","slug":"Let-s-Build-A-Simple-Interpreter","permalink":"https://longlongqin.github.io/tags/Let-s-Build-A-Simple-Interpreter/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"Front-matter的规则","slug":"Hexo博客搭建/Front-matter的规则","date":"2020-03-16T14:08:32.497Z","updated":"2020-03-17T08:15:54.491Z","comments":true,"path":"archives/138a.html","link":"","permalink":"https://longlongqin.github.io/archives/138a.html","excerpt":"文章写作时，的front matter 的参数","text":"文章写作时，的front matter 的参数参数描述layout布局title标题date建立日期updated更新日期comments开启文章的评论功能tags标签（不适用于分页）categories分类（不适用于分页）permalink覆盖文章网址其中，分类和标签需要区别一下，分类具有顺序性和层次性，也就是说Foo，Bar不等于Bar，Foo；而标签没有顺序和层次。注意：每个冒号后面是有一个空格的。1234567891011121314151617title: 文章的front-matter规则 // 你的博客名字 date: 2019-08-10 21:44:44 //文章创建的日期author: longlongqin //作者名字img: /medias/banner/6.jpg //文章的显示的时候的背景coverImg: /medias/banner/6.jpg top: truecover: truetoc: truepassword: mathjax: truesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要tags:- Hexo- Github- 博客categories:- 软件安装与配置配置选项默认值描述titleMarkdown 的文件标题文章标题，强烈建议填写此选项date文件创建时的日期时间发布时间，强烈建议填写此选项，且最好保证全局唯一author根 _config.yml中的 author文章作者imgfeatureImages中的某个值文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: http://xxx.com/xxx.jpgtoptrue推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章coverfalsev1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中coverImg无v1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片password无文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项toctrue是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项mathjaxfalse是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行summary无文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories无文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类tags无文章标签，一篇文章可以多个标签reprintPolicycc_by文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个注意:如果 img 属性不填写的话，文章特色图会根据文章标题的 hashcode 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。date 的值尽量保证每篇文章是唯一的，因为本主题中 Gitalk 和 Gitment 识别 id 是通过 date 的值来作为唯一标识的。如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 _config.yml 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：开源中国在线工具、chahuo、站长工具。","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://longlongqin.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"front-matter配置","slug":"front-matter配置","permalink":"https://longlongqin.github.io/tags/front-matter%E9%85%8D%E7%BD%AE/"}]},{"title":"Let’s Build A Simple Interpreter-8","slug":"学习笔记/Let's Build A Simple Interpreter/LSBASI-8","date":"2020-03-15T10:04:49.000Z","updated":"2020-03-18T06:21:29.606Z","comments":true,"path":"archives/ae12.html","link":"","permalink":"https://longlongqin.github.io/archives/ae12.html","excerpt":"今天，将要在前面的基础上，添加一元操作符unary operators：unary plus (+) and unary minus (-) operators。","text":"今天，将要在前面的基础上，添加一元操作符unary operators：unary plus (+) and unary minus (-) operators。今天将要完成的任务：扩展语法，能够处理“+”、“-”一元操作符；添加一个新的结点类：UnaryOp AST node class；扩展语法分析器parser，生成含有UnaryOp nodes结点的抽象语法树；扩展解释器interpreter。并且增添一个新的visit_UnaryOp method函数，它可以解析一元操作符现在，开始吧。一元操作符一元操作符是什么？二元操作符：之前，我们的计算器都是围绕着这些二元操作符 (+, -, *, /)在工作，这些操作符操作两个操作数（the operators that operate on two operands.）。一元操作符unary operator ：那么，我们就能知道一元操作符是：一个操作符只操作一个操作数。（A unary operator is an operator that operates on one operand only.）一元操作符的规则下面是一元操作符“+、-”的规则：一元操作符-：它会使它的操作数取反（negation）一元操作符+：他对于它的操作数没影响，即，它的操作数不改变什么一元操作符比二元操作符（+, -, *, and /）有着更高的优先级（precedence）例子：“+ - 3”其中，这第一个位置的“+”表示一元操作符加号操作；第二个位置的“-”表示一元操作符减号操作。所以，“+ - 3”就相当于“+ (- (3))”，即，等于-3。【注】：这里的-3平常情况说它是一个负整数（negative integer），但是在这里我们称它是：一个一元操作符“-”，它的操作数是3。“5 - - 2”在这个表达式中，第一个“-”表示一个二元操作符：减法。第二个“-”表示一个一元操作符：取反。比如下面的一些例子，也是这个样子：开始修改将一元操作符添加入语法修改factor因为，一元操作符的优先级高于二元操作符。所以，函数factor需要需改。它之前的规则为：更新后的，规则为：从更新后的factor函数的规则，可知：它扩展之后能够引用它本身。这样我们就能够写出类似于：- - - + - 3”这样的式子，这是合法的带有很多一元操作符的表达式。其实，这里修改语法，只用修改factor函数的产生式，其他的expr、term产生式不变：扩展抽象语法树的结点类下一步就是要添加一个AST node class，来表示一元操作符：1234class UnaryOp(AST): def __init__(self, op, expr): self.token = self.op = op self.expr = expr这个函数有两个参数：op、expr：op：代表一元操作符的token（+或-）expr：表示一个AST的结点（要与expr函数区分，这两个知识名字一样，但是代表的东西不一样）扩展语法分析器parser之前我们修改了语法规则，当中的factor函数的产生式也发生了变化，所以现在我们将要修改代码，使其能够处理产生式中的 “(PLUS | MINUS) factor” 子规则：1234567891011121314151617181920def factor(self): \"\"\"factor : (PLUS | MINUS) factor | INTEGER | LPAREN expr RPAREN\"\"\" token = self.current_token if token.type == PLUS: self.eat(PLUS) node = unaryop(token, self.factor()) return node elif token.type == MINUS: self.eat(MINUS) node = unaryop(token, self.facot()) return node elif token.type == INTEGER: self.eat(INTEGER) node = NUM(token) return node elif token.type == LPAREN: self.eat(LPAREN) node = self.expr() self.eat(RPAREN) return node扩展解释器Interpreter现在我们还需要扩展解释器类Interpreter class ，向其中添加visit_UnaryOp 函数，来解释一元操作符结点：123456def visit_UnaryOp(self, node) op = node.op.type #token的类型 if op == PLUS: return +self.visit(node.expr) elif op == MINUS: return -self.visit(node.expr)例子让我们看一个例子，表达式 “5 - - - 2” ，通过我们的解析器来证实这个新的visit_UnaryOp函数确实起作用了。下面是如何从Python shell中实现:12345678910111213&gt;&gt;&gt; from spi import BinOp, UnaryOp, Num, MINUS, INTEGER, Token&gt;&gt;&gt; five_tok = Token(INTEGER, 5)&gt;&gt;&gt; two_tok = Token(INTEGER, 2)&gt;&gt;&gt; minus_tok = Token(MINUS, '-')&gt;&gt;&gt; expr_node = BinOp(... Num(five_tok),... minus_tok,... UnaryOp(minus_token, UnaryOp(minus_token, Num(two_tok)))... )&gt;&gt;&gt; from spi import Interpreter&gt;&gt;&gt; inter = Interpreter(None)&gt;&gt;&gt; inter.visit(expr_node)3上面的AST树看起来是这样的:","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let's Build A Simple Interpreter","slug":"Let-s-Build-A-Simple-Interpreter","permalink":"https://longlongqin.github.io/tags/Let-s-Build-A-Simple-Interpreter/"}]},{"title":"构造凸包——Divide And Conquer","slug":"学习笔记/计算几何/Convex-Hull/Divide-And-Conquererer","date":"2020-03-15T08:12:57.000Z","updated":"2020-03-22T06:58:07.022Z","comments":true,"path":"archives/f32f.html","link":"","permalink":"https://longlongqin.github.io/archives/f32f.html","excerpt":"Graham Scan算法说明了凸包构造问题的下界O(nlogn)是可以达到的。其实O(nlogn)的算法远不止这一种，分治法就是一种能达到O(nlogn)复杂度的思想。在此引入运用分治思想的两种算法来构造凸包。","text":"Graham Scan算法说明了凸包构造问题的下界O(nlogn)是可以达到的。其实O(nlogn)的算法远不止这一种，分治法就是一种能达到O(nlogn)复杂度的思想。在此引入运用分治思想的两种算法来构造凸包。归并排序与分治思想引入新算法之前依旧先来回顾一个经典排序算法：归并排序（merge sort）。归并排序的基本流程如下：算法分为两个阶段：分（divide）和归并（merge）。分的阶段将待排序列均分到一个个子序列（如图中划分到单个元素）。归并阶段将分好的子序列两两合并成有序序列，重复合并的过程直到整体归为一个序列。归并过程共logn步，每步耗费n的时间，总体复杂度为O(nlogn)。归并排序的过程就是一个典型的分治（divide-and-conquer）策略。凸包构造问题也可以套用这种策略来分而治之，逐步求解。我们可以将待处理点集S分为同等规模的两个子点集，并分别对其求凸包。有了两个子解后，问题就变成了如何适当加一些边，将两个子凸包merge成整体解。分治法核心的任务就是如何merge。Divide And Conquer（1）预处理为star-shaped polygon分治法解决问题的过程可以概括为：大事化小，小事化了。就是首先将问题划分为易求解的子问题，子问题套用已知方法解答即可。例如子凸包的构造就能用Graham Scan来解决。Graham Scan解决问题的前提是：参照基准点，其他点按极角有序排列，也就是构成了一个有序的星形多边形（star-shaped polygon）。首先要做的就是将两个子凸包预处理成两个star-shaped polygon。star-shaped polygon星形多边形是什么呢？其实就是在多边形内部存在一个点A，这个点与多边形内任意一点的连线都在多边形内部，就叫做星形多边形，这一个点A就叫做多边形的内核。由于任何一个凸多边形都是star-shaped polygon，它必然有一个核，其他点按极角有序排列。问题在于如何找到一个公共核，使得两个子凸包同时关于这个核是极角有序排列的。也就是公共核处于两个凸包的交部分，这样是最好处理的情况（如下左图）。不过还有可能有其他情况，不能找到公共核（如下中图），甚至两个凸包根本不相交（如下右图）：这就要将分治策略分不同情况来实现：两个子凸包有公共核：先找其中一个子凸包的核：我们可以任取该子凸包上的三点构成三角形，求三角形重心作为核。然后判断这个核是否也在另一个子凸包内部，若判定为真，就是有公共核的最简单情况。判定方法也就是之前提过的in convex polygon test，对凸包每条边做to left test即可，在线性时间内可以判定。找到公共核之后，进行凸包形成：—-用二路归并相对于公共核，两个子凸包的各自有序排列，相互交错。要做的就是将二者点序列合并，方法正是经典的二路归并，线性时间可以完成。最后进行Graham Scan即可得到大凸包。一个子凸包的核落在另一个子凸包外部：存在公共核的情况处理是很简单的，再看第一个子凸包的核落在第二个子凸包外部的情况。如下图所示：这中情况与增量构造法的情况很相似，P1的核x相对于P2就是一个新加入的点。做出两条support line：x→t和x→s，舍弃P2上t→s路径的点即可。这样P2中剩余点与x构成了一个星形多边形，x也成为了P2的核。这就转化成了第一种有公共核的情况。Divide And Conquer（2）上述分治策略的算法过于复杂，所以引入一种更加简明的分治策略。这种分治策略也会为三角剖分等问题提供思路。首先规定一种点集划分的策略。假设待合并的两个子凸包是沿着某方向是分离的，二者不相交（Divide And Conquer（1）中是有相交的）。例如下图凸包P1和P2就是相互分离的：这样划分会使得合并更加简明，不必区分多种复杂情况。预处理为了满足这种划分策略，需要引入一种预处理，也就是一个x方向的排序过程（X-sorting）。排序后就可取点x坐标的中值，将点集划分为规模相当的左右两个子集。每个凸包都有其最左点l和最右点r，如上图。merge操作现在merge操作就是将两个左右相离的两个子凸包合并为一个大凸包的过程了。运算的关注的正是两对l和r点。先直观感受一下merge操作要添加的新极边：上下两条紫色边正是要求的新边，又称支撑边（support line），并且每次merge只会增加两条新边。两条边类似两个圆的公切线（common tangent），将二者连接起来。注意，注意，注意：眼睛可能会欺骗你直观上感觉，两条support line正是两个子凸包的最高点t和最低点b相互连接得到的，这些点只需线性时间就能找到。当真如此的话凸包构造的下界就成了O(n)，显然直觉是错误的。例如下面的两种情况，support line就和b、t两点没有直接关系了：)构造support line的过程需要缜密的分析，并非凭直觉能得到的。缝合（stitch）—构造support line将两个子凸包连接的过程更像古代妇女用针将两块布缝合在一起（但是这里的两个凸包的间距是不能变的，仅仅是用线将其连接在一起。而且这里连接只需要最后找出来的那两条线，其余剩下的中间“工具线”都要舍去）。构造过程首先从左凸包的r点和右凸包的l点连线开始，以这条线为基础逐步得到support line。注意一个细节问题：如何得到各子凸包的l点和r点。每次合并都会产生新的凸包，所以凸包是一个动态的结构。当然可以每次计算出最左点和最右点，只需要线性时间。但是这并不是最优的方式。考虑分治的思想，就整个merge流程来讲，是自底向上将子凸包两两合并的过程。因此只要在最底层上最小的子凸包中记录最左点和最右点，每次merge更新一下这两个变量即可，只需要O(1)的常数时间！这种优化对整体的复杂度上线nlogn虽然没有影响，也能为程序节省一部分的开销。缝合上半部分再看如何将最初的r-l线变成support line，在此以寻找upper support line为例（上切线，相应的还需要计算下切线）。算法的核心依然是to left test。首先看l点，从r-l线出发，可以发现相对于对于r→l时，l的前驱、后继是LR型的。而我们想要的是RR型的。所以必须要找l的前驱。直到在某一个时刻，我们找到了l的一个前驱点满足RR型：再看r点，同样的，从此时的状态，来观察r的类型：是RL型的。要想成为LL型，r必须要找它的后驱。在某一时刻，r找到r的后继（就是该凸包点t）使其满足LL型：反过来继续看l，此时，具体的说应该是检测l的前驱点l&#39;，经检测，l&#39;已经不再满足RR型了，编程了LR型，所以还要继续寻找它的前驱点，使其再次满足RR型。某一时刻，找到它的前驱（就是该凸包的点t），使其成为RR型。反过来继续看r，此时，更准确的应该说是在看r&#39;，经检测，该店符合LL型。至此，所谓的r和l都已经符合RR或LL型了。从而已经找到upper support line了。结束上半部分。回顾由r-l线逐步推进得到support line的过程，每次操作一个端点，得到是一种“Z”字形（zig-zag）的推进轨迹。操作点的切换由另一点满足要求决定，而算法停止的依据是两个端点同时满足了要求。这种方式类似快速排序构造轴点的过程，左右两轴点交替操作，直到二者都满足要求时算法停止。缝合下半部分缝合下半部分的流程与，上半部分流程一样。时间复杂度分析一下算法时间复杂度。算法首先要按照x坐标排序，排序复杂度为O(nlogn)。再看merge过程，无论是左侧子凸包还是右侧子凸包，对于其每个点的操作至多只有以此，也就是每次归并是线性时间。归并共logn次，算法的总体复杂度就是O(nlogn)了。更多的考虑在这些算法讲解中，通常都是不考虑退化的情况，如，三点共线……最后总结一下第二种分治法的特点。此前Jarvis March算法虽然以平方复杂度为上界，但其”输出敏感性“使得实际复杂度为O(hn)，最好情况下仅甚至为线性。例如如下情况：Jarvis March算法的复杂度变为了O(4n)，而此时分治法依旧会经历按部就班的X-sorting，一上来就注定了O(nlogn)的复杂度，然后经历同样O(nlogn)的merge过程。也就是说这种分治法在各种情况下的表现都是很均匀的。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"计算几何","slug":"计算几何","permalink":"https://longlongqin.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"}]},{"title":"构造凸包-Graham Scan法","slug":"学习笔记/计算几何/Convex-Hull/Graham-Scan","date":"2020-03-14T09:40:32.000Z","updated":"2020-03-22T15:09:59.625Z","comments":true,"path":"archives/3478.html","link":"","permalink":"https://longlongqin.github.io/archives/3478.html","excerpt":"","text":"Graham Scan算法的流程假设待处理点集S共有n个点。1、预处理预排序(presorting）Graham Scan首先要做的是一个预处理排序操作（presorting）。即找到某个基准点，然后将其余所有的点按照相对于基准点的极坐标排序。如下图：点的排序可以套用任意排序算法的框架，只是将排序对象由数值变为了平面上的点，而比较器改为to left test实现。如何找出第一个点：点1？以点1为基准点，其余点按照相当于点1的极角依次排序为2、3、4……理论上讲任何一个点都能当第一个基准点，为了简化算法通常选择lowest-then-leftmost point（LTL）作为基准点。找出起始边对于与基准点1极角最小的点，也就是图中点2（假设没有三点共线的情况）。将点1和点2作为算法的起始点。将起始边 与 剩下的n-2条边分别存储在不同的栈(stack)中：算法开始前先将起始点1和2入栈S，其他的n-2个点入栈T，如下图。注意S和T中元素的入栈顺序。至此预处理已经完成。Graham Scan用到的数据结构。整个算法非常简明，核心数据结构只有两个栈，分别记作栈S和栈T。便于理解我们将S和T画成开口相对的形式，如上图。2、scan操作(此处为逆时针扫描)完成预处理之后，就能开始算法的核心：scan操作。scan的过程主要关注三个点：栈S的栈顶（S[0]）、次栈顶（S[1]）和栈T的栈顶（T[0]）。也就下图红色标注的三个点：对这三个关注的点，进行检测，检测的框架为：可以观察到，每次待处理的S[0]和S[1]构成的边一定是一条极边（如上图点1和点2），算法关键步骤就是对边这条极边和T[0]做to left test，判断T[0]位于边S[0]S[1]的左边还是右边。若在左边则继续拓展，若在右边则否定掉此前认定的极边。无论结果如何，每次判定都会将问题规模缩小一个单元，算法结束时T最终肯定为空。T空后，S中存留下的点正是凸包的极点，这些点自底而上正是凸包边界点的逆时针遍历，也得到了整个凸包构造问题的解。举例1、先来看一个最简单的例子，即点集S中所有的点都在凸包边界上。如下图：先找到LTL，也就是图中点1。然后基于点1对其余点按极角排序为点2、3、4……（实际上以一个点为中心的有序的点集，构成了所谓的星形多边形（star-shaped polygon），中心点正是星形多边形核（kernel）的一部分。凸多边形必然是星形多边形，反之则不然。）然后找到点1的后继2，点1和点2构成第一条极边。初始化栈S和栈T。现在要关心S[1], S[0]和T[0]，就是点1，2和3。点3位于边12左侧，to left关系为true，S.push ( T.pop() )，向前拓展了一条暂定极边。接下来重复上述过程。考虑点2，3和4。to left关系为true，S.push( T.pop() )……最终栈T空，算法结束，凸包由栈S自底向上得到。S和T的变化过程如下图：2、上面列举了最简单的情况下Graham Scan的过程，接下来列举一个更有代表性的实例深入算法的细节。输入的点集S，并进行预处理排序，并初始化栈S、T，如下图：接下来对点1，2和3进行to left测试，本质上就是判断边2→3（图中黄色边）能否被暂时采纳。测试结果为true，暂时采纳边2→3，S.push( T.pop() )。如下图所示：注意图中蓝色边表示已经被暂时接纳的边，也就是算法暂时认定的极边。上一次操作将蓝色边推进一个单元接下来关注点2，3和4，来判断下一条黄色边3→4能否被接纳。to left测试为true，S.push( T.pop() )，接纳边3→4。如下图右侧所示：然后判断点3，4和5。点5在边3→4的右侧，即to left测试为false。S.pop()，也就是判断出点4不可能为极点，丢弃4。因此算法回溯到点3，判断点2，3和5的关系。5在2→3的左侧，暂时接纳边3→5，S.push( T.pop() )。如下图：算法经历了无效操作，进行了回溯，得到了目前来说最优的“极边”。虽然这些”极边“不一定能最终保留，但问题的规模得到了削减。下一次scan考察的就是3，5和6了。3，5和6的to left测试为false，S.pop()，舍弃点5。然后考察点2，3和6，to left测试为false，S.pop()舍弃点3。如下图：……..………直遍历完剩下其他点，凸包就构造完成。验证算法的正确性思路上的正确性了解了算法的整体流程之后，我们再来论证一下算法的正确性。证明一个算法正确性的方法有很多，在此选用数学归纳法。数学归纳法的思想可用多米诺骨牌类比，要做的无非是两件事：证明第1张骨牌会倒；证明如果第n张骨牌会倒则第n+1张骨牌也会倒下。Graham Scan过程就是一个个引入点的过程。每当我们得到第k个点的时候，算法所得到的就是前k个点对应的“最好的凸包”。因此当k = n时得到的是整体的凸包。归纳的第一步就是证明k = 3时得到的是当前点集S‘ = {1，2，3}中的极边——也就是证明第1张骨牌会倒。显然边1→2是S’的一条极边。而根据预处理的方式，3相较于1的极角一定大于2，因此点3一定在边1→2的左侧，因此边2→3会得到保留。对于这三个点来说，任意两条边一定都是极边，2→3也是一条极边。然后证明：假设已经处理到第k个点，得到的是前点集S’ = {1，2，3，…，k}中所谓“最好的凸包”。根据算法处理方式，接下来从S’’ = {1，2，3，…，k，k+1}得到的结果是否也是正确的——也就是证明第n张骨牌会倒，则第n+1张骨牌也会倒下。预处理的方式是对2~n所有点相较于点1按极角排序，因此下一个要处理点k+1一定出现在线1→k的左侧，也就是下图蓝色区域和绿色区域（假设k = 9）：而根据目前接纳的最后一条极边( k-1)→k （例如图中8→9）来划分，点k+1可能出现的区域又分为两块，即该极边的左侧（绿色区域）和右侧（蓝色区域）。这也正对应于算法判定的两个分支。左侧：左侧的情况很简单，点k+1显然会是一个新的极点。Graham Scan要做的正是暂时接纳边k→k+1，拓展了一个新的单位。右侧：再看k+1落在右侧的情况。如下图点10：Graham Scan要做的是丢弃点k（图中点9），也就是判定出点k不可能是极点。这样做的原因：是引入点k+1后，点k一定会被包含在三角形(1, k-1, k+1)内部。如图中点9一定包含于三角形(1, 8, 10)内部。正如极点法中排除非极点的做法，点k被排除是正确的做法。接下来点k-1，k-2等（如图中点8，点7等）也可能是非极点，按照算法的流程，它们总会被判定在某个三角形的内部（例如点7在三角形(1, 5, 10)内部）而被排除，直到left test为true，回溯停止。换个角度考虑，回溯停止时得到的新边正是增量构造法中每步得到的support line，即切线。例如图中线5→10正是算法当前保留的”凸包“的切线。这也能论证Graham Scan处理方式的正确性。至此，算法思路上的正确性已经证明完毕。表述方式的正确性接下来还要考虑算法的表述方式是否有漏洞：代码中每次to left test之前并没有判断S栈中是否有≥2个元素。这也可以由预处理的方式来论证。点1选取的是LTL，而点2是相对于点1极角最小的点，这样的做法保证了除了点1和点2之外所有的点一定是在边1→2左侧的。因此算法回溯最多到点2，永远不可能把点2丢弃，S中元素任何时候至少有两个。Graham Scan算法的正确性论证完毕。预处理操作的必要性最后来思考一下预处理操作：presorting。仔细回顾上述论证过程会发现，每一步的正确性都是建立在最初的排序上的。那么这个预处理排序真的是必要的吗？可以来举极端的反例，每次选取下一个点都是随机的，例如下图的路径：上图中从点1开始出发进行to left测试，可以发现，每次判定结果都为true，最终所有的点都被保留了下了，而显然这并不是一个凸包。因此presorting是整个算法成立的基础。分析复杂度上面证明了Graham Scan算法的正确性，接下来分析其复杂度是否满足O(nlogn)，实现所谓的最优算法。直观上无法断定Graham Scan是一个最优的算法，尤其是以下极端情况令人质疑其效率：Graham Scan算法复杂度由三部分决定：persorting，采用一般排序算法，复杂度是O(nlogn)逐步迭代，O(n)：算法一步步纳入新点，会迭代n步。scan，O(?)所以算法的总体复杂度：O(nlogn + n * ?) ，可见scan的复杂度决定了算法总体的复杂度。算法一步步纳入新点，会迭代n步。但是在每个点上都有可能做回溯操作，所以scan的复杂度是不确定的。我们来以上图最坏情况为例，到第8个点时判定为false，舍弃点7，回溯。下一步判断也为false，舍弃点6，回溯。如此回溯直到算法开始的点2。这次scan倒退了高达O(n)个点，如果每次scan都是如此那么算法整体复杂度就为：O(nlogn + n * n) = O(n^2)了，那这种算法的意义也就不大了。其实上述分析并非错误，只是不够精确。O(n^2)确实是Graham Scan算法的一个上界，但是这个上界并不是紧的。问题就出在分析假定了每次都会出现回退高达O(n)个点。下图展示了整个Graham Scan的流程：图中黄色边是没有采纳的，就是to left测试判定为false后直接舍去的。紫色边则是曾经被认为是极边而接纳的，后来经过回溯又舍去了。无论是黄边还是紫边，在其上耗费的都是常数时间，关键就在于黄色边和紫色边的数目了。通过观察可以发现，从图论的角度看，所有的黄色边和紫色边连在一起构成了一张平面图，也就是它们互相是不可能内部相交的。平面图的一个重要性质：平面图中所有边的数目和顶点数目保持同阶这个性质来自欧拉公式：有n个点的平面图，边的数目上限是3n，也就是O(3n)。回溯（backtrack）可能会倒退的边数：在0~n之间。【但是注意，不是每次回溯都能回退到n，因为由上面可知，点集边数最多为3n，而这里面的每一个边，会被回退0次（极边），或者1次（非极边）。所以，某条边一旦被回退过，之后就不可能再被回退了】根据这个性质，在persorting之后的整个流程中，Graham Scan所能走过的所有边不仅不会到达n^2，而顶多到达和n同阶的一个线性数目。因此整个算法的复杂度也就取决于persorting的O(nlogn)了。算法推广Graham Scan算法不仅可以用于凸包构造问题，在其他许多场景下中也十分有效。为了推广Graham Scan算法，首先可以对其做简化，以方便利用在其他问题。首先再来回顾一下预处理排序，这是算法成立必不可少的一步。排序算法套用成熟的方法即可，利用数学方法计算偏角不仅复杂而且引入了误差，所以要采用to left test。要做的就是两点：套用成熟的排序算法，将待排序元素由数值变为点将排序算法的比较器改为to left test实现按照这样的流程就能间接地实现persorting。1、原始点集已经有某种次序有时候我们并不是从零开始构造凸包，例如得到的待处理点集已经是有某种次序的（比如已经按x坐标大小排序，如下图）。这种情况也不一定非得进行persorting构造新的次序，通常改变观察的角度，换一种理解方式就能免去预处理而直接进行后面的线性的scan操作了。上半部分凸包：考虑y轴负方向无穷远一个点，所有的点相对于这个点的极角排序恰好就是各点的x坐标序！也就是将无穷远的点看作起始点①，最右侧点（图中点8）看作点②，进行scan过程直到最左边的点（图中点1）结束，就得到了凸包的上半部分（upper hull），也就是下图的8→7→2→1：注：对 “考虑y轴负方向无穷远一个点，所有的点相对于这个点的极角排序恰好就是各点的x坐标序！” 这句话的理解：就像太阳光照在地球上的道理是一样的，太阳离地球足够的远，那么它的光到达地球上的时候，就近似的是平行的。下半部分凸包（lower hull）的构造也是如此。考虑一个在y轴正方向无穷远的一个点，以此为起点进行scan，最终得到lower hull：1→4→7。最后将两个凸包合二为一即可。代码实现","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"凸包","slug":"凸包","permalink":"https://longlongqin.github.io/tags/%E5%87%B8%E5%8C%85/"}]},{"title":"Lower Bound","slug":"学习笔记/计算几何/Convex-Hull/Lower-Bound","date":"2020-03-14T09:29:23.000Z","updated":"2020-03-22T14:50:08.237Z","comments":true,"path":"archives/ba04.html","link":"","permalink":"https://longlongqin.github.io/archives/ba04.html","excerpt":"","text":"Lower Bound从极点法的O(n^4^)复杂度，到极边法的O(n^3^)，再到增量构造法和Jarvis March的O(n^2^)，我们经历了将特定问题算法不断优化、降低复杂度的过程。那么还有比O(n^2^)更高效的算法吗？凸包构造算法的下界是什么？推广到一般情况，在计算模型固定的情况下特定问题的复杂度下界又是如何确定的？在计算模型固定的情况下特定问题的复杂度下界（lower bound）是确定的。严谨考虑，在设计算法前应该先确定下界是多少。对于某个问题的特定算法，我们可以用时间复杂度来评价算法的好坏。算法能达到的下界也就是所谓问题的难度。当然这种评价通常是比较麻烦的，有时候甚至是不可行的。这就要引入新的的方式来衡量一个算法的好坏。规约（reduction）我们引入规约（reduction）的方法来间接衡量一个算法。规约简单来讲就是用一个“参照物”对比待评算法，得到算法的复杂度。规约的一般方法如图：左侧是已知的问题A，已经明确它的难度，右侧是待分析问题B，复杂度未知。我们在二者之间建立起一种基本reduction关系：linear-time reduction。linear-time reduction具体表述为：任何一个A的输入（input of A），都可以在O(n)复杂度转化为一个B的输入（input of B），然后通过B的某种算法（any algorithm）计算出结果（output of B）;而对于output of B又都可以在在O(n)复杂度转化为A问题的结果（output of A）。两次转换的复杂度不能超过线性，也就是linear-time（线性时间）。能够进行上述操作，就称为：A问题可以规约到B问题（problem A is linear-time reducible to problem B）。注意表述方式防止搞混A和B的位置。曹冲称象可以通过曹冲称象的故事来帮助理解规约的思想。要解决的问题是：没有秤能直接称量大象重量（问题B的难度无法直接衡量），解决方案是：利用船和石块间接称量。石头块的重量是可以直接称量的（问题A的难度是已知的），利用船和水来转换石头和大象的重量是可操作的（规约的方法是可操作的）。【这里的规约关系(Reduction relationship)是指曹冲成像时的船和水】规约记号引入规约记号，problem A is linear-time reducible to problem B表示为：$$A≤_NB$$将问题A、B的难度分别表示为|A|，|B|。规约记号的意思相当于|A|≤|B|，A的下界必然就是B的下界。规约的过程：将A的输入转化为B的输入经过B的某种算法获得解后又转化为A的解，也就是这个算法也是解决A问题的算法。已知A问题的下界，那么这个算法必然不会低于A的这个下界。构造凸包的下界按照“曹冲称象”的规约思想，分析问题的难度，最重要的在于找到“石头”，而船就是规约这种方法。以二维凸包（2d-CH）来分析，首先将待解决的问题放到规约记号右边，而左边的“石头”就是排序算法。$$Sorting≤_N2D-CH$$排序是纯粹的数值计算问题，而凸包是典型的几何问题，二者是如何联系在一起的呢？前面增量构造法和Jarvis March算法正是分别由两种排序算法来类比引入的，可见排序和凸包之间有深刻的内在联系。二者之间的联系可以通过下图表示：首先清点要做的任务：可以在线性时间内，将排序问题的输入转化为凸包问题的输入排序问题的输入可以表示为x轴上的一系列的点（图中蓝色点）。然后将这些点转化为凸包问题的输入，就是将这些待排序的数转化为平面上的点。引入辅助线——一条抛物线，例如图中蓝色虚线。接下来要对蓝色点做到抛物线上的映射（O(n)），映射在抛物线上的点用绿色标出。这样就完成了将待排序数字转化为平面上点的操作。接下来就可以用某种算法将绿色点构造为凸包，即图中CH(P)。可以在线性时间内，将凸包问题的结果转化为排序问题的结果凸包CH(P)就是问题B的解，如何将B的解转化为A的解？注意最左和最右边两点的连线，即图中1和4的连线4→1。除去这条连线之外，其他首尾相接的连线：1→2，2→3和3→4都是“沿着x方向单调的”，遍历这些首尾相连的边（O(n)）就能得到一系列的数值，并且已经是有序的了。这样就将凸包问题的解——凸包CH(P) 转化为了排序问题的解——有序数值序列。两次转化说明规约是可行的，因此2d-CH问题的下界可由sorting的下界确定。一般而言，排序问题的难度是确定的：O(nlogn)。2d-CH问题的下界也就是：$$O(nlogn)$$更高维的凸包问题下界也是如此。增量构造法和Jarvis March的O(n^2^)到O(nlogn)之间的鸿沟能否跨越呢？是否存在O(nlogn)复杂度的凸包构造算法？后续文章会有回答。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"凸包","slug":"凸包","permalink":"https://longlongqin.github.io/tags/%E5%87%B8%E5%8C%85/"}]},{"title":"构造凸包-Jarvis March(Gift Wrapping)算法","slug":"学习笔记/计算几何/Convex-Hull/Jarvis-March","date":"2020-03-14T09:23:45.000Z","updated":"2020-03-22T13:53:01.986Z","comments":true,"path":"archives/9c7f.html","link":"","permalink":"https://longlongqin.github.io/archives/9c7f.html","excerpt":"回顾凸包构造算法：极点法、极边法和增量构造法，其复杂度分别为O(n^4^)、O(n^3^)和O(n^2^)，效率经过优化已经大大提高了。接下来引入一种新的算法——Jarvis March，其复杂度也是O(n^2^)，但是相较于增量构造在最好情况下效率是较高的。","text":"回顾凸包构造算法：极点法、极边法和增量构造法，其复杂度分别为O(n^4^)、O(n^3^)和O(n^2^)，效率经过优化已经大大提高了。接下来引入一种新的算法——Jarvis March，其复杂度也是O(n^2^)，但是相较于增量构造在最好情况下效率是较高的。实现策略先想一下为何极边法复杂度高达O(n^3^)。实际上我们要对点集中所有边进行遍历，这需要n^2^复杂度，然后对每个边进行鉴别，又需要n复杂度，因此总体复杂度高达O(n^3^)。那么该如何改进呢？这就可以运用选择排序的思想：将下一个要查找的边缩小到一个小范围，而非遍历所有边。选择排序每次选取出的unsorted最大元素放在sorted 部分的首部，也就意味着整个unsorted部分必然不会超过sorted部分。从算法整体框架考虑，每次我们都是维护一个局部解（也就是sorted部分），然后从尚未处理的部分（也就是unsorted部分）找到一个与当前局部解“紧密相关的元素”（相当于选取的最大元素）。这个思想为解决凸包问题带来了新思路。对算法的大致过程进行描述(标识为：已找到极边数/所有极边数)：首先从任何一个极点（后面说明如何找到这个点）开始（图中0/5），然后找到一条以这个极点为端点的极边（1/5）。接着沿着极边另一个端点（endpoint）出发，再找出下一条极边（2/5）。如此反复操作，最终会找到一条以最初极点为endpoint的极边，得到一个封闭的环，凸包也构造完成。凸包构造过程类似于选择排序中sorted不断向前扩展一样，不断扩展局部解，最后得到问题最终解。凸包构造的问题由此分解为一个个子问题：如何从endpoint出发找到下一条极边。用to left test找到下一条极边现分析如何从endpoint找到下一条极边。考虑一下的一般情况：我们从极点o开始寻找极边，假设当前找到的极边是ik，接下来要做的工作是找到从k出发的另一条极边ks，即找到极点s。显然，s来自于其他那些尚未处理的点中，那么s与其他点相比有什么特征？观察发现，ik作为一条极边，它的右侧肯定都是空的，所有其他点都在ik左侧。画出k与其他候选点的有向直线，例如下图中的ks，kt：注意图中红色标出的角度，可以看出ks与ik的夹角比kt小，也就是ks比kt相较于ik偏左的角度更小。实际上ks偏左的角度比其他任何从k出发的边都小，这就是s点的判定依据。这样就找到了从其余点中选择s点的思路：任选两个点，从k出发过这两点做有向边，看哪个偏左的角度更小就留下，另一点丢弃。然后再拿一点与留下的点比较，反复这个过程，最终留下的就是要找的s点。问题至此转化为：如何比较两条有向边（例如ks和kt）相较于另一有向直线（例如ik）谁偏左的角度更小。当然可以通过计算三角函数的方法来比较，这是最直观的数学思维。但是这样计算十分复杂，更重要的是引入了误差。这时候又要使用to left test这个基础方法来解决问题了具体做法就是以在ks和kt中以任意个为基准（如以ks为基准），对另一点（如t）做to left test。上图点t和有向边ks的to left test结果为true，t在ks左边，因此ks偏左的角度更小，舍弃点t。类比选择排序来理解:已得到的极边（从极点o开始到ik的首尾相连的极边）——相当于 sorted部分其余点——相当于 unsorted部分找到点s（能构成最小偏角的点）——相当于 从unsorted部分取出极大值选择排序中的选择过程需要比较元素大小，就要由一种比较器完成，而上述比较偏角的过程也可以抽象为一种比较器的操作。构造凸包的算法框架与选择排序相同，只是比较器替换为to left test而已。此处只是考虑一般情况，一些特殊细节未进行处理。例如在st上有s和s’两点，这两点的取舍问题未考虑。当然为了理解算法整体框架忽略特殊情况是很必要的。确定第一个极点一个细节：上文一开始提到的算法的最开始的第一个极点如何确定？任何一个极点都可以使用，我们没必要去计算出哪个点是极点。可以选取y坐标最小的点，也就是最低点，在没有退化的情况下，这个点一定是一个极点。如果情况退化，有多个最低点（如例图中所示），我们就去选x坐标最小的那个点，也就是最左边的点即可。这种方法选出的点称为lowest-then-leftmost point（LTL）。注意选取的规则的先后顺序，先选lowest，若点不唯一再选leftmost。Jarvis March类比选择排序的过程，我们得到的凸包构造算法就是Jarvis March算法，又称gift wrapping算法（算法过程如包装礼物一样）。接下来看算法具体实现方法。12345678910111213141516171819202122232425262728293031323334353637383940bool ToLeft(Point P, Point q, Point s)&#123; int area2 = p.x*q.y - p.y*q.x + q.x*s.y -q.y*s.x + s.x*p.y - s.y*p.x; return area2 &gt;0 ; //左侧为真&#125;int LTL (Point S[], int n)&#123; int ltl = 0; //the lowest-then-leftmost point for(int k=1; k&lt;n;k++)&#123; if(S[k].y &lt; S[ltl].y || (S[k].y==S[ltl].y &amp;&amp; S[k].x&lt;S[ltl].x)) ltl =k; &#125; return ltl;&#125;void Javis(Point S[], int n)&#123; for (int k=0; k&lt;n; k++) S[k].extreme =FALSE; //首先将所有点标记为非极点 int ltl=LTL(S, n); //找到LTL int k=ltl; //将LTL作为第一个极点 do &#123; S[k].extrem = true; int s =-1; //s是要找的下一个极点，用t去循环找 for (int t=0; t&lt;n; t++) &#123; if(t != k &amp;&amp;t != s &amp;&amp; ( s == -1 || !ToLeft(S[K],S[s],S[t]) ) ) s = t; //如果t在pq的右侧，则更新s &#125; S[k].succ = s; k = s; //新的极边pq确定 k = s; //更新k的值，变为下一次查找的起点 &#125;while(ltl != k) //如果循环回到了原来的点，则结束&#125;梳理首先，初始化将所有点都设为：非极点然后，开始找到第一个极点（用LTL方法），找到之后赋值给k接下来，开始找下一个极点s：主要用ToLeft Test来找出下一个极点循环第3步骤，直到找到所有极点小结最后分析Jarvis March算法相较于增量构造法的优势。二者都是O(n^2^)的复杂度，Jarvis March算法的优势在于其的“输出敏感性（output sensitive）”。考虑点集S，共有n个点，来构造S上的凸包。何为“输出敏感性”？Jarvis March算法每次新加入一条边都会耗费n的复杂度，但是构造过程一共会加入的边数往往比n少。如下图（设n = 7）：在非退化为共线的前提下，最好情况为只加入3条边（复杂度为O(3n)），最坏情况为所有点都是极点，加入n-1条边（复杂度为O(n^2^)）。实际情况中最坏情况出现的几率很小，我们引入一个指标h来衡量凸包的极边数（the size of convex hull）：$$h = |CH(S)|$$Jarvis March算法算法的复杂度更准确的表示为O(nh)。h又由最终输出结果，即凸包本身来决定，输出结果决定了构造过程的复杂度，这就是所谓的“输出敏感性”。这种类型的算法又被称为output sensitive algorithm。这种特性在其它凸包算法中也会体现。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"凸包","slug":"凸包","permalink":"https://longlongqin.github.io/tags/%E5%87%B8%E5%8C%85/"}]},{"title":"Convex Hull(凸包)","slug":"学习笔记/计算几何/Convex-Hull/Convex-Hull-凸包","date":"2020-03-14T09:15:07.000Z","updated":"2020-03-22T14:23:34.120Z","comments":true,"path":"archives/510d.html","link":"","permalink":"https://longlongqin.github.io/archives/510d.html","excerpt":"这山之高，就叫凸碧；山之低洼近水处，就叫作凹晶。这凸、凹二字，历来用的人最少，如今直用做轩馆之名，更觉新鲜，不落窠臼。","text":"这山之高，就叫凸碧；山之低洼近水处，就叫作凹晶。这凸、凹二字，历来用的人最少，如今直用做轩馆之名，更觉新鲜，不落窠臼。欧拉公式简单介绍一下欧拉公式：虚数中：i^2^=-1 ; i=√(-1)其中θ为实数，i表示虚数中的虚数单位 i；欧拉恒等式：当θ=π时；几何学中的欧拉公式：V-E+F=2 【v：几何体的顶点数；E：边数；F：面数】凸包凸包：比如，我们有很多很多钉子钉在木板上面，然后用一个皮筋将这些钉子包围起来，当我们松手后，皮筋就把这些定在全都包围起来。此时，这个皮筋所形成的凸多边形就叫凸包。如下图的蓝色的多边形就是凸包。凸性(Convexity)下图中，假设x,y,z是三种颜色，如果仅以x,y就能调出来的颜色，那么如u所示它一定会落在x,y中；若需要x,y,z三种 一起，那么如v所示会落在以x,y,z三点连成的三角形内部。极点(Extreme Point)有一个点集S。如果存在通过点P的直线L，使得点集S中除了点P之外的其他的点都在这个直线的同一侧，则这个点P就是极点(Extreme Points)。判断一个点是否为极点：该点P是否会被包含在其他点中任意三个点形成的三角形中，如果点P不在任何三角形内部，则说明点P是极点。反之，则不是极点。如下图：下图中，S就不是极点，因为他在三角形内部。判断极点的算法In-Trangle Test算法描述伪代码：其实这个算法就是判断点是否在三角形内部。代码实现：123456789101112131415void extremePoint (point S[], int n)&#123; for(int s=0; s&lt;n; s++) S[s].extreme = TRUE; for(int p=0; p&lt;n; p++) for(int q=p+1; q&lt;n; q++) for(int r=q+1; r&lt;n; r++) for(int s=0; s&lt;n; s++) &#123; if(s==p || s==q || s==r ||!S[s].extreme) continue; if(Intriangle(S[p],S[q],S[r],S[s])) S[s].extreme = FALSE; &#125;&#125;可知，该算法的时间复杂度为O(n^4^)，其实挺大的，在后面我们会进一步改善。这样基于极点的凸包算法虽然效率不高，但是它会引出一个非常重要的操作我们称之为To-Left Test在后面我们可以看到这个测试几乎是贯穿于我们计算几何这个课程的始终的。如果说我们刚才所给出的那个算法还有什么需要补充的话其实最重要的也就是那样的一个细节也就是所谓的In-Triangle test。To-Left Test我们将刚才这个In-Triangle Test转化为三次To-Left测试也就是说一个点如果确实落在某一个三角形的内部的话那么相对于这个三角形的三条边所做的这个To-Left测试都会统一的返回true或者统一地返回false。1234567bool InTriangle(Point p, Point q, Point r, Point s)&#123; bool pqLeft = ToLeft(p, q, s); bool qrLeft = ToLeft(q, r, s); bool rpLeft = ToLeft(r, p, s); return (pdLeft == qrLeft) &amp;&amp; (qrLeft == rqLeft);&#125;To-Left测试是相对于另外这两个点所确定的那条有向直线而言的，任何一条有向直线不仅会把平面分成两部分，我们还可以知道哪一边是左边，哪一边是右边。To-Left，其实就是说这个点相对于刚才的那条有向线而言到底是位于它的左侧，还是右侧。如果是前者就是true，否则的话就是false。因为三角形有三条边，所以我们要用三次To-Left Test。To-Left Test具体实现：这里用到了行列式来求三角形面积（至于原理，这里就不多说了）。下图中的这个行列式实际上算的首先是它的面积的两倍。123456789101112bool ToLeft(Point p, Point q, Point s)&#123; return Area2(p, q, s) &gt; 0; &#125;int Area2(Point p, Point q, Point s)&#123; return p.x * q.y - p.y * q.x +q.x * s.y - q.y * s.x +s.x * p.y - s.y *p.x;&#125;注意：这里的面积其实是“有向面积”，也就是说这里的面积分正负（相对于这样一个逆时针的一个编号pqs的这样的一个面积 与 s在右侧也就是按照顺时针的pqs所构成的面积虽然有可能大小是一样完全对称但是它们的符号是相反的）。整个这个To-Left的测试的判断的依据也就在于这个符号。这个行列式取正条件为：当且仅当s位于pq所确定的这条有向直线的左侧。其中转换成代码也是非常简明的，代码如上图所示。至此，To-Left Test实现完成。极边(Extreme Edge)极边：两个极点连成的边，剩余的所有点均会在该边的一侧。判断是否为极边：代码实现：12345678void markEE(point S[], int n)&#123; for (int k=0; k&lt;n; k++) S[k].extreme = FALSE; for (int p=0; p&lt;n; p++) //test for(int q=p+1; q&lt;n; q++) //检验每一条边 checkEdge(S,n,p,q) //有向边pq&#125;1234567891011void checkEdge(Point S[], int n, int p, int q)&#123; bool LEmpty =TRUE, REmpty =TRUE; for (int k=0; k&lt;n &amp;&amp; (LEmpty || REmpty); k++) &#123; if (k != p &amp;&amp; k != q) ToLeft(S[p], S[q], S[k]) ? LEmpty=FALSE : REmpty=FALSE; &#125; if(LEmpty || REmpty) S[p].extreme=S[q].extreme=TRUE;&#125;实现的步骤：初始时，先假设所有的点都不是极点。开始遍点集S中的点，它们两两组合成一个线段，然后进行checkEdge(检查这些线段是否是极边)。检查的方法checkEdge：利用ToLeft测试，每次都将当前的线段与其他点（即，除了这两个点之外的点）进行ToLeft测试，如果测试结果中：LEmpty、REmpty 其中之一为true，就表明这两个点构成的线段为*极边*，而且同时也检测出这两个点是*极点*。（其实两个点组成的线段进行checkEdge的结果中的LEmpty、REmpty最多只有一个是true,因为这里不存在一条边的两侧都没有其他点的情况）12345678910111213141516171819202122void markEE(Point S[], int n) //n&gt;2&#123; for(int k = 0; k &lt;n; k ++) S[k].extreme = False; //先假设所有的点都不是极点 for(int p = 0; p &lt; n; p ++) for(int q = p + 1; q &lt; n; q ++) checkEdge(S, n, p, q);&#125;void checkEdge(Point S[], int n, int p, int q)&#123; //LEmpty、REmpty表示改边的左侧、右侧，等于True时表示该侧是没有点的。 bool LEmpty = True, REmpty = True; for(int k = 0; k &lt; n &amp;&amp; (LEmpty || REmpty); k ++) &#123; if(k != p &amp;&amp; k != q) &#123; ToLeft(S[p], S[q], S[k]) ? LEmpty = False : REmpty = False; &#125; &#125; if(LEmpty || REmpty) S[p].extreme = S[q].extreme = True;&#125;同样可利用此来判断是否是极点（复杂度为O(n^3)）。补：根据极角排序定义：我们平常所使用的坐标系都是直角坐标系，而极角排序是在极坐标系下进行的。这里首先要选取一个点，然后其它点根据与参考点的连线与x轴所成的夹角的大小进行排序的。这里我们可以简单理解为绕着一个点逆时针转圈访问。代码：在讲具体实现方法之前，先给出用到的函数和结构体：1234567891011121314struct point//存储点&#123; double x,y;&#125;;double cross(double x1,double y1,double x2,double y2) //计算叉积&#123; return (x1*y2-x2*y1);&#125;double compare(point a,point b,point c)//计算极角&#123; return cross((b.x-a.x),(b.y-a.y),(c.x-a.x),(c.y-a.y));&#125;利用叉积的正负来排序 关于叉积：叉积=0是指两向量平行（重合）；叉积&gt;0，则向量a在向量b的顺时针方向（粗略的理解为在a在b的下方）；叉积&lt;0，则向量a在向量b的逆时针方向（粗略的理解为在a在b的上方）123456789bool cmp(point a,point b) &#123; point c;//原点 c.x = 0; c.y = 0; if(compare(c,a,b)==0)//计算叉积，函数在上面有介绍，如果叉积相等，按照X从小到大排序 return a.x&lt;b.x; else return compare(c,a,b)&gt;0;&#125;用 complex 的内建函数，算出极角大小。12345678910#include &lt;complex&gt;#define x real()#define y imag()#include &lt;algorithm&gt;using namespace std;bool cmp(const Point&amp; p1, const Point&amp; p2)&#123; return arg(p1) &lt; arg(p2);&#125;用 arctan 计算极角大小。注意角的大小范围是(-180°, +180°]。弧度表示。这里用 arctan2 函数应该是为了提高精度。关于atan2()函数：在C语言的math.h或C++中的cmath中有两个求反正切的函数atan(double x)与atan2(double y,double x) 他们返回的值是弧度要转化为角度再自己处理下。前者接受的是一个正切值（直线的斜率）得到夹角，但是由于正切的规律性本可以有两个角度的但它却只返回一个，因为atan的值域是从-90°~90° 也就是它只处理一四象限，所以一般不用它。推荐这个：第二个atan2(double y,double x) 其中y代表已知点的Y坐标，同理x ,返回值是此点与远点连线与x轴正方向的夹角，这样它就可以处理四个象限的任意情况了，它的值域相应的也就是-180~180了1234bool cmp1(const Point&amp; p1, const Point&amp; p2)&#123; return atan2(p1.y, p1.x) &lt; atan2(p2.y, p2.x);&#125;先判断象限，再用外积判断顺序，最后根据长度排序。123456789101112131415int Quadrant(point a) //象限排序，注意包含四个坐标轴&#123; if(a.x&gt;0&amp;&amp;a.y&gt;=0) return 1; if(a.x&lt;=0&amp;&amp;a.y&gt;0) return 2; if(a.x&lt;0&amp;&amp;a.y&lt;=0) return 3; if(a.x&gt;=0&amp;&amp;a.y&lt;0) return 4;&#125;bool cmp3(point a,point b) //先按象限从小到大排序 再按极角从小到大排序&#123; if(Quadrant(a)==Quadrant(b))//返回值就是象限 return cmp1(a,b); else Quadrant(a)&lt;Quadrant(b);&#125;向量的点乘与叉乘的几何意义向量的点乘（内积）：$$\\vec{a} \\cdot \\vec{b}=|\\vec{a}| \\cdot |\\vec{b}|\\cdot cos\\theta$$点乘的几何意义是可以用来表征或计算两个向量之间的夹角，以及在b向量在a向量方向上的投影向量的叉乘（外积）：$$\\vec{a} \\times \\vec{b}=|\\vec{a}| \\cdot |\\vec{b}|\\cdot sin\\theta$$向量积被定义为：模长：（在这里θ表示两向量之间的夹角(共起点的前提下)（0° ≤ θ ≤ 180°），它位于这两个矢量所定义的平面上。）方向：a向量与b向量的向量积的方向与这两个向量所在平面垂直，且遵守右手定则。（一个简单的确定满足“右手定则”的结果向量的方向的方法是这样的：若坐标系是满足右手定则的，当右手的四指从a以不超过180度的转角转向b时，竖起的大拇指指向是c的方向。c = a ∧ b）特别的，在二维中，两个向量的向量积的模的绝对值等于由这两天向量组成的平行四边形的面积。向量的叉乘，即求同时垂直两个向量的向量，即c垂直于a，同时c垂直于b（a与c的夹角为90°，b与c的夹角为90°）参考文献极角排序：https://sumygg.com/2013/07/30/Sorting-Points-by-Polar-Angle/关于极角排序：https://www.cnblogs.com/aiguona/p/7248311.html","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"凸包","slug":"凸包","permalink":"https://longlongqin.github.io/tags/%E5%87%B8%E5%8C%85/"}]},{"title":"构造凸包-增量构造法","slug":"学习笔记/计算几何/Convex-Hull/增量构造","date":"2020-03-14T09:15:07.000Z","updated":"2020-03-22T15:43:30.666Z","comments":true,"path":"archives/7c53.html","link":"","permalink":"https://longlongqin.github.io/archives/7c53.html","excerpt":"","text":"在引入新算法之前首先来回顾一下经典的算法思想：减治（decrease and conquer），注意不是分治（divided and conquer），二者稍有区别。简单来讲就是将问题划分为一个个简单的小问题，减而治之，逐个求解，最终就能得到整个问题的解。减治法的经典例子就是插入排序（insertion sort）。插入排序的过程可以归结成下图：排序的过程中将序列分为两部分：已排序部分（sorted）和未排序部分（unsorted）。每次排序都是从unsorted中拿出一个元素，通过一次顺序查找过程在sorted部分中找到位置并插入其中。整个插入排序的过程就是逐个元素的去“蚕食”unsorted部分的过程，连续的进行这个操作就会将整个问题解决。这种将大问题分解成小问题的减治过程，又被看成一种递增的、增量式的策略（incremental strategy）。这种思想为解决凸包问题提供了新的思路：从逐个插入新点的角度构造凸包。典型流程如下图（标识为：极点/整体规模）：插入新的点可能的情况有：新点对凸包有“贡献”，例如5/5→6/6，6/6→7/7；新点也有可能没有“贡献”，例如7/7→7/8；还有可能使原先有“贡献”的点失效，极点数量减少，例如7/8→6/9。那么如何对不同情况进行处理呢？确定新点与现有凸包的关系~in-convex-polygon test构造过程的核心算法应该是：判定待定点是否位于某多边形内部（in-convex-polygon test）。再看上图流程，实际上每步的核心就是判断点位于多边形内部还是外部，若落在外部，则新插入的点就是下一个极点，否则舍弃。考虑基本情况，给定一个点和一个多边形，如何高效判断该点与多边形的位置关系呢？一种思路是：我们可以先对多边形进行一个“预处理”，给每个点按序编号，类比有序向量二分查找的思想，来逐步缩小规模。如下图：首先任选一点为基准点（蓝色点），然后用二分法选取其余点的“中点“（预处理已经为所有点排了序），然后判断基准点到终点的有向直线与待定点的位置关系（to-left test）。然后可将搜索范围减半，反复上述过程，直到最后退化为平凡情况：三角形与点的位置关系（in-triangle test）。分析一下算法的整体复杂度：整个算法共log(n)步，每步的to-left test或in-triangle test都为常数成本，则整体复杂度为log(n)。至此，我们似乎得到了一个log(n)的“高效”算法，但是这种方法真的可行吗？注意，每步都会将原凸包规模减半，也就是说凸包是动态的，随时可能变化。这种方法和极点法或极边法中静态查找的情况是完全不同的。类比插入排序的过程来解释这个问题。为何插入排序的复杂度是n^2^而非nlog(n)？每次插入时，既然sorted部分已经有序，为何不使用二分查找来取代顺序查找（复杂度由n变为log(n)）？这不得不考虑sorted部分的动态性，每次插入后它的结构都会改变，而二分查找必须在静态结构中实现。当然可以使用std::vector这类支持按秩访问（call by rank）的数据结构，但是插入时维护vector的成本依旧是线性复杂度。因此插入排序的总体复杂度是n^2^。要处理的凸包与插入排序中sorted部分本质是一样的，它们都不是静态不变的结构，而要随着算法执行而不断变化。若要每次在log(n)成本下完成待定点的in-convex-polygon test，必须将凸包存储为类似vector的数据结构，但是每次向这种数据结构插入新点的成本依旧是线性的。因此对凸包进行的所谓“预处理”是没有意义的，这种减治策略算法复杂度最低应该为O(n^2^)。到现在问题依旧没有解决，究竟如何用这种增量式的策略来构造凸包？其实复杂问题中最朴素、最基本的方法反而是最有效的。in-convex-polygon test最基本的方法是什么？就是按一定方向（约定为逆时针）凸包的每条边和待定点做to-left test，一旦有一次test为false就能断定点在凸包外面。这实际上就是将in-triangle test推广多边形的情况。因此每次in-convex-polygon test的成本就会变成当前凸包的规模，也就是n。对于每个新点做一次in-convex-polygon test，构造算法的整体复杂度就是O(n^2^)。算法的复杂度从极边法的O(n^3^)又下降了一个数量级。其实增量算法的整个思路可以分成两块：1、如何判断凸包与新点的位置关系（in-convex-polygon test）2、如何向凸包插入新点上面的方法已经解决了第一个问题。第二个问题看下面部分：如何向凸包插入新点~support-line现在来讨论如何向凸包插入新点：比如下面这个点，应该如何插入凸包之中呢？插入过程：将新点x插入原凸包的过程，本质上就是寻找两个连接点s和t，将x和t、s分别连接得到新的凸包。注意t和s两点将整个原凸包边界分为两部分：st和ts两个有向段。构造新凸包就要保留远端st、舍弃近端ts。取代近端ts的两条线就是x和t的连线xt和xs，被称为切线（tangent）或者support line（支撑线）。那如何查找t、s这两个点呢？我们在凸包上任取一点v，按逆时针方向v点会有一个直接前驱点和直接后继点。考察有向直线xv与点v直接前驱和直接后继的位置关系（两次to left test），记录为一个pattern表。结果无非是四种情况：v的直接前驱和直接后继相对于有向直线xv的位置是RL，LR，LL，RR。例如上图黄色点v，是R和L；蓝色点v分别是L和R。实际上凸包边界st上所有点的pattern都为RL，ts上所有点的pattern都为LR。关键点在于：点S的pattern是LL，点t的pattern为RR。因此对凸包边界每个点做两次to left test，判断其pattern就可找出s和t，花费时间成本为常数。incremental construction再来回顾整个凸包构造算法的两大问题：in-convex-polygon test和插入新点。分开考虑只是为了将思路简化，实际上这两个问题可以套用一个算法，同时来解决。具体做法就是：对于每个待定点x，不必特意去考虑它与凸包的位置关系，而是遍历凸包上每一个点。对于凸包边界上的每一个点，我们都能通过两次to left test迅速判断出pattern。对于x位于凸包外部的情况，经过遍历凸包的点，我们很容易就能得到s和t的位置，得到两条support line，从而构造出新的凸包；而对于x位于凸包内部的情况，凸包边界每个点都不可能出现RR或LL的情况，直接舍弃x即可。每次遍历凸包边界点的复杂度为O(n)，整个构造过程要增量式的逐点考察，自然得到了一个O(n^2^)的incremental construction算法。这就是所谓增量构造法来构造凸包的过程。构造过程巧妙的避开了特殊处理诸如5/5→6/6、7/7→7/8、7/8→6/9等复杂情况，采用一致的思路逐个考察“新点”，最终完成凸包的构造。代码部分待写……..小结：其实增量算法的整个思路可以分成两块：1、如何判断凸包与新点的位置关系（in-convex-polygon test）2、如何向凸包插入新点","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"凸包","slug":"凸包","permalink":"https://longlongqin.github.io/tags/%E5%87%B8%E5%8C%85/"}]},{"title":"Let’s Build A Simple Interpreter 7","slug":"学习笔记/Let's Build A Simple Interpreter/LSBASI-7","date":"2020-03-13T13:55:47.000Z","updated":"2020-03-25T14:12:11.797Z","comments":true,"path":"archives/5a757a52.html","link":"","permalink":"https://longlongqin.github.io/archives/5a757a52.html","excerpt":"","text":"前言原文链接：https://ruslanspivak.com/lsbasi-part7/之前的那几小结，我们都是把interpreter的代码和parser的代码混在一起，而且interpreter在parser识别出一个如加减乘除之类 的特定的语言结构(language construct)后，就会立刻对它进行求值。这种 interpreter 被称为 语法导向解释器(syntax-directed interpreter)。他们通常在输 入上做一个 pass 且只适合基础的语言应用。为了分析更复杂的编程语言 Pascal 的结构， 我们需要建立一个 中间表示 (intermediate representation, IR)。parser 会 负责构建 IRinterpreter 会用来解释由 IR 所代表的输入。事实证明树是一个表示 IR 非常合适的数据结构。关于数的一些术语terminology：树是一个包含一个或多个结点组成的层次数据结构。树有一个根结点，就是顶部结点。除根结点外的所有结点有唯一 一个父结点。下图中结点为*的是一个父结点。结点为 2 和 7 的是它的子结点；子结点从左到右排序。没有子结点的结点称为叶子结点。有一个或多个子结点的非根结点被称为中间结点。子结点也可以是完全子树。下图中结点＋的左子树（结点为*）就是一个有自己子结点的 完全子树。在计算机科学中我们把树倒过来画，根结点在最上边，分枝向下生长。下面是表达式 2 * 7 + 3 的带有解释的树形表示：本系列中我们会用到的 IR 被称为 抽象语法树 (abstract-syntax tree, AST)。但在深 入了解 AST 之前让我们简单聊聊 解析树 (parse tree)。尽管我们不会在解释器和编译 器中用到解析树，但它会通过可视化 parser 执行轨迹的方法，加深你对 parser 如何解释 输入的理解。我们也会将它和 AST 做比较，来表明为什么 AST 比解析树更适合用来做 IR。那么，什么是解析树呢？解析树（有时叫做 具体语法树concrete syntax tree ）是一个根据我们的语法定义来 表示一门语言的句法结构的树形结构。它基本上展示了你的 parser 如何识别语言结构或者， 换句话说，它展示了你语法的开始符号怎么派生出该编程语言中一个特定的字符串的。parser 的调用栈隐式地代表了一个解析树，且当parser 在试图识别一个特定的语言结构时，解析树 就会自动地在内存中构建出来。下面是表达式 2 * 7 + 3 的解析树：在上面的图片中可以看到：解析树记录了 parser 用来识别输入的一系列规则。解析树的根结点的标签是语法的开始符号(start symbol)。每个中间结点表示一个非终结符(non-terminal)，代表应用了一条语法规则，像我们的情况里的 expr, term和 factor.每个叶子结点代表了一个 token.我们不会手动构建解析树且在我们的解释器中用到它，但解析树可以通过可视化 调用过程帮助我们理解 parser 怎么解释输入。你可以使用一个名为 genptdot.py 的小应用（我很快写完用来帮助你的），来查看不同的 算术表达式看起来什么样。要使用这个应用你首先需要安装 Graphviz包，然后运行下面的 命令，你可以打开生成的图片文件 parsetree.png 查看你从命令行传入的表达式的解析树：12$ python genptdot.py \"14 + 2 * 3 - 6 / 2\" &gt; \\ parsetree.dot &amp;&amp; dot -Tpng -o parsetree.png parsetree.dot下面是由表达式 14 + 2 * 3 - 6 / 2 生成的图片 parsetree.png:parser抽象语法树(AST)现在我们来聊聊抽象语法树(AST)。它是在余下的文章中会大量用到的中间表示(IR)。它是我们的解释器和未来编译器项目的核心数据结构。让我们以把表达式 2 * 7 + 3 的 AST 和解析树放在一起看来开始我们的讨论：从上面的图片中可以看出，AST抓住了输入的精髓且更小。AST 和解析树最主要的区别有：AST 使用操作符/操作(operators/operations )作为根结点，操作数(operands)作为它们的子结点。不像解析树，AST 不使用中间结点来表示语法规则。AST 并不把真实句法中的所有结节都表示出来（这就是为什么它是抽象的）──例如，没有 规则结点和括号。对于相同的语言结构来说，AST 相比于解析树更紧凑。抽象语法树是什么？抽象语法树(AST)是表示一个语言结构的抽象句法结构的树形表示，它的中间结点和根结点代表了一个操作符，子结点代表了该操作符的操作数。看一下AST与解析树对比，显现他的紧凑性：如何将操作符的优先级(precedence)编码进 AST 呢？为了把操作符优先级编码进 AST，即，为了表示“X 在 Y 之前发生”你只需要在树中把 X 放在低于 Y 的位置。你在前面 的图片中已经见过到了。【例子】：在下面的图片中，左边是表达式 2 * 7 + 3 的 AST。让我们用括号把 7 + 3 围起来以改变 它的优先级。在右边是修改后的表达式 2 * (7 + 3) 的 AST：代码实现AST好了，让我们写些代码来实现不同的 AST 结点类 并修改我们的 parser 来生成包含这些结点的 AST 树：首先，新建一个基本结点类叫做 AST，其他类会从它继承：12class AST(): pass #pass 不做任何事情，一般用做占位语句。因为如果定义一个空函数程序会报错，当你没有想好函数的内容是可以用 pass 填充，使程序可以正常运行。回忆一下 AST 表示了操作符-操作数模型。到现在为止，我们有4个操作符和整型操作数。操作符有加、减、乘、除。我们原本可以新建单独的类来表示每个操作符如 AddNode, SubNode, MulNode 和 DivNode，相反我们只会新建一个 BinOp 类来表示所有 4 个二元操作符*binary operator* （二元操作符就是作用在两个操作数的操作符）：12345class BinOp(AST): def __init__(self, left, op, right): self.left = left self.token = self.op = op self.right = right构造函数的参数是 left, op, 和 right, 其中 left 和 right 分别指向了表示 左操作数和右操作数的结点。 op 保存了指向操作符本身的 token: Token(PLUS, &#39;+&#39;) 表示加操作符， Token(MINUS, &#39;-&#39;) 表示减操作符，等等。为了在 AST 中表示整数，我们定义一个 Num 类，它将保存一个 INTEGER token 和该 token 的值：1234class Num(AST): def __init__(self, token): self.token = token self.value = token.value和你注意到的一样，所有的note保存 token 从而则创建note(all nodes store the token used to create the node)。这主要是为了方便，将来会派上用场。回忆一下表达式 2 * 7 + 3 的 AST。我们会在代码中手工创建该表达式：1234567891011121314&gt;&gt;&gt; from spi import Token, MUL, PLUS, INTEGER, Num, BinOp&gt;&gt;&gt;&gt;&gt;&gt; mul_token = Token(MUL, '*')&gt;&gt;&gt; plus_token = Token(PLUS, '+')&gt;&gt;&gt; mul_node = BinOp(... left=Num(Token(INTEGER, 2)),... op=mul_token,... right=Num(Token(INTEGER, 7))... )&gt;&gt;&gt; add_node = BinOp(... left=mul_node,... op=plus_token,... right=Num(Token(INTEGER, 3))... )以下是在新定义的结点类下 AST 的样子。下面的图片也遵循了上面手工创建的过程：parser 代码下面是我们修改过的 parser 代码，在识别输入（算术表达式）时建立和返回一个 AST:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class AST(): passclass BinOp(AST): def __init__(self, left, op, right): self.left = left self.token = self.op = op self.right = rightclass Num(AST): def __init__(self, token): self.token = token self.value = token.valueclass Parser(): def __init__(self, lexer): self.lexer = lexer # set current token to the first token from the input self.current_token = self.lexer.get_next_token() def error(self): raise Exception('Invalid syntax') def eat(self, token_type): # compare the current token type with the passed token # type and if they match then \"eat\" the current token # and assign the next token to the self.current_token, # otherwise raise an exception. if self.current_token.type == token_type: self.current_token = self.lexer.get_next_token() else: self.error() def factor(self): \"\"\"factor : INTEGER | LPAREN expr RPAREN\"\"\" token = self.current_token if token.type == INTEGER: return Num(token) elif token.type == LPAREN: self.eat(LPAREN) node = self.expr() self.eat(RPAREN) return node def term(self): \"\"\"term : factor ((MUL | DIV) factor)*\"\"\" node = self.factor() while self.current_token.type in (MUL, DIV): token = self.current_token if token.type == MUL: self.eat(MUL) elif token.type == DIV: self.eat(DIV) node = BinOp(left=node, op=token, right=self.factor()) return node def expr(self): \"\"\" expr : term ((PLUS | MINUS) term)* term : factor ((MUL | DIV) factor)* factor : INTEGER | LPAREN expr RPAREN \"\"\" node = self.term() while self.current_token.type in (PLUS, MINUS): token = self.current_token if token.type == PLUS: self.eat(PLUS) elif token.type == MINUS: self.eat(MINUS) node = BinOp(left=node, op=token, right=self.term()) return node def parse(self): return self.expr()让我们看一些算术表达式的 AST 的构建过程。如果你看了上面的 parser 代码，可以看到它建立一个 AST 中的结点的时，把变量 node 的当前值做为 BinOp 结点的左子结点，把对 term 或 factor 调用的返回结果做为它 的右子结点，这实际上就是把结点推向左边，下面表达式 1 +2 + 3 + 4 + 5 的树结构就是 这种情况的一个好例子。下面是 parser 如何一步步地构建表达式 1 + 2 + 3 + 4 + 5 的 AST 的图形表示：遍历好了，下面是表达式 2 * 7 + 3 的 AST：你怎么遍历这个树并恰当地对它所代表的表达式进行求值呢？你可以使用后序遍历*postorder traversal* (深度优先遍历depth-first traversal 的一个特例) 。这种方式由根结点开始，递归由左至右访问每个结点的子结点。后序遍历从根结点开始尽可能快地访问离根结点远的结点(The postorder traversal visits nodes as far away from the root as fast as it can)。下面是后序遍历的伪代码，其中 &lt;&lt; postorder actions &gt;&gt;是一些操作的占位符，如 BinOp 结点的加减乘除操作或 Num 结点返回整数的简单操作：为什么要使用后续遍历呢？第一，我们需要对在树中更低的中间结点进行求值， 因为它们代表了优先级更高的操作符，第二，我们在对操作数 参与 对应操作符 的运算 之前需要对操作数进行求值。在下面的图片中，可以看到使用后序遍历时我们会首先对表达式 2*7 进行 求值，而只有在对 14 + 3 求值之后，我们才会得到正确答案 17:三种深度优先遍历：为了完整起见，三种深度优先遍历的方式：先序遍历，中序遍历和后序遍历。这 些遍历方式名字的来自于遍历代码中操作的位置：有时你可能需要在所有地方（先序，中序和后序）都执行一些操作。你会在本文的源代码仓 库中找到一些例子。先序遍历preorder traversal,在先序遍历中，我们先访问根节点，然后递归使用先序遍历访问左子树，再递归使用先序遍历访问右子树，即：根节点-&gt;左子树-&gt;右子树中序遍历inorder traversal,在中序遍历中，我们递归使用中序遍历访问左子树，然后访问根节点，最后再递归使用中序遍历访问右子树，即：左子树-&gt;根节点-&gt;右子树后序遍历 postorder traversal.在后序遍历中，我们先递归使用后序遍历访问左子树和右子树，最后访问根节点。 即：左子树-&gt;右子树-&gt;根节点Interpreter用代码来遍历和解释由 parser 建立的抽象语法树：好了，让我们写一些代码来遍历和解释由 parser 建立的抽象语法树，好吗？下面是实现了访问者模式的源代码：12345678class NodeVisitor(): def visit(self, node): method_name = 'visit_' + type(node).__name__ visitor = getattr(self, method_name, self.generic_visit) return visitor(node)#generic_visit 是一个备用函数，它会抛出一个异常来表示它遇到了一个实现类中没有相 应 #visit_NodeType 方法的结点。 def generic_visit(self, node): raise Exception('No visit_&#123;&#125; method'.format(type(node).__name__))NodeVisitor一个结点访问器的基类：它遍历抽象语法树并为找到的每个节点调用一个访问器函数。（这个函数可能会返回一个由visit()方法转发 的值）。This class is meant to be subclassed, with the subclass adding visitor methods.成员函数：1️⃣ visit(node)：访问一个结点。它默认调用self.visit_classname（其中的classname是结点类的名字，或者如果这个方法不存在时，classname就是 generic_visit() ）的方法。2️⃣ generic_visit(node)：这个访问器(visitor)对结点的所有子节点调用visit()。【注意：只有这个访问器调用generic_visit() 或者访问它本身，否则自定义访问器的结点的子节点将不会被访问】1getattr(object, name[, default])官方文档中说这个函数作用是返回对象的一个属性，第一个参数是对象实例obj,name是个字符串，是对象的成员函数名字或者成员变量，default当对象没有这个属相的时候就返回默认值，如果没有提供默认值就返回异常。如：提供不默认写法：1234567891011121314&gt;&gt;&gt; class Test(object):... def func(self):... print 'I am a test'...&gt;&gt;&gt; test = Test() # 实例化一个对象&gt;&gt;&gt; func = getattr(test, 'func') # 使用getattr函数获取func的值&gt;&gt;&gt; func()I am a test&gt;&gt;&gt; func = getattr(test, 'f') # 使用对象没有的属性，则会出现异常Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;AttributeError: 'Test' object has no attribute 'f'&gt;&gt;&gt;提供默认写法如果对象没有该属性可以提供一个默认值。1234&gt;&gt;&gt; func = getattr(test, 'f', None)&gt;&gt;&gt; print funcNone&gt;&gt;&gt;Interpreter 类的源代码下面是 Interpreter 类的源代码，它继承自 NodeVisitor 类且实现了形式为 visit_NodeType 的不同方法，其中 NodeType 会被如 BinOp, Num 等类名替换：12345678910111213141516class Interpreter(NodeVisitor): def __init__(self, parser): self.parser = parser def visit_BinOp(self, node): if node.op.type == PLUS: return self.visit(node.left) + self.visit(node.right) elif node.op.type == MINUS: return self.visit(node.left) - self.visit(node.right) elif node.op.type == MUL: return self.visit(node.left) * self.visit(node.right) elif node.op.type == DIV: return self.visit(node.left) / self.visit(node.right) def visit_Num(self, node): return node.value关于以上代码有两点值得在这里提一下：第一，操作 AST 结点的访问器(也就是对AST数据的操作)的代码 和 AST 结点(即，AST的数据结构)本身 分离（解耦了）。可以看到 AST 结点类(BinOp 和 Num)没有提供任何代码来操作存储在这些结点中的数据，该逻辑被封装在了实现 NodeVisitor 的 Interpreter 类中。（也就是对数据的操作在NodeVisitor 的 Interpreter 类中）。第二，在NodeVisitor的访问函数中，不像这样使用一个巨大的if语句:123456789101112131415def visit(node): node_type = type(node).__name__ if node_type == 'BinOp': return self.visit_BinOp(node) elif node_type == 'Num': return self.visit_Num(node) elif ... # ...#####或者##########def visit(node): if isinstance(node, BinOp): return self.visit_BinOp(node) elif isinstance(node, Num): return self.visit_Num(node) elif ...NodeVisitor 的 visit 方法非常通用，能根据传入的结点类型来调度适当的方法。正如前面提到的，为了利用这一点，我们的解释器继承了 NodeVisitor 类并实现了必要的方法。 因此：如果传递给 visit 函数的结点是 BinOp，那么visit 函数就会调用 visit_BinOp 方法。如果传递给 visit函数的结点是 Num,那么 visit 函数就会调用visit_Num 方 法，等等。花此时间研究一下这个方法（Python 的标准模块 ast 也使用了相同的机制来遍历结点）， 因为我们将来会用很多新的 visit_NodeType 方法来扩展我们的解释器。现在，让我们手工为表达式 2 * 7 + 3 建立一个 AST 并把它传递给解释器，通过对该表达式求值看看运行中的 visit 方法。下面是你从 Python shell 中尝试的方法：123456789101112131415161718&gt;&gt;&gt; from spi import Token, MUL, PLUS, INTEGER, Num, BinOp&gt;&gt;&gt;&gt;&gt;&gt; mul_token = Token(MUL, '*')&gt;&gt;&gt; plus_token = Token(PLUS, '+')&gt;&gt;&gt; mul_node = BinOp(... left=Num(Token(INTEGER, 2)),... op=mul_token,... right=Num(Token(INTEGER, 7))... )&gt;&gt;&gt; add_node = BinOp(... left=mul_node,... op=plus_token,... right=Num(Token(INTEGER, 3))... )&gt;&gt;&gt; from spi import Interpreter&gt;&gt;&gt; inter = Interpreter(None)&gt;&gt;&gt; inter.visit(add_node)17如你所见，我把表达式树的根结点传递给了 visit 方法，这一行为触发了树的遍历，遍历调用了 Interpreter 类正确的方法(visit_BinOp 和 visit_Num)并生成了结果。完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264\"\"\" SPI - Simple Pascal Interpreter \"\"\"# Token types## EOF (end-of-file) token is used to indicate that# there is no more input left for lexical analysisINTEGER, PLUS, MINUS, MUL, DIV, LPAREN, RPAREN, EOF = ( 'INTEGER', 'PLUS', 'MINUS', 'MUL', 'DIV', '(', ')', 'EOF')class Token(object): def __init__(self, type, value): self.type = type self.value = value def __str__(self): \"\"\"String representation of the class instance. Examples: Token(INTEGER, 3) Token(PLUS, '+') Token(MUL, '*') \"\"\" return 'Token(&#123;type&#125;, &#123;value&#125;)'.format( type=self.type, value=repr(self.value) ) def __repr__(self): return self.__str__()################################################################################ ## LEXER ## ################################################################################class Lexer(object): def __init__(self, text): # client string input, e.g. \"4 + 2 * 3 - 6 / 2\" self.text = text # self.pos is an index into self.text self.pos = 0 self.current_char = self.text[self.pos] def error(self): raise Exception('Invalid character') def advance(self): \"\"\"Advance the `pos` pointer and set the `current_char` variable.\"\"\" self.pos += 1 if self.pos &gt; len(self.text) - 1: self.current_char = None # Indicates end of input else: self.current_char = self.text[self.pos] def skip_whitespace(self): while self.current_char is not None and self.current_char.isspace(): self.advance() def integer(self): \"\"\"Return a (multidigit) integer consumed from the input.\"\"\" result = '' while self.current_char is not None and self.current_char.isdigit(): result += self.current_char self.advance() return int(result) def get_next_token(self): \"\"\"Lexical analyzer (also known as scanner or tokenizer) This method is responsible for breaking a sentence apart into tokens. One token at a time. \"\"\" while self.current_char is not None: if self.current_char.isspace(): self.skip_whitespace() continue if self.current_char.isdigit(): return Token(INTEGER, self.integer()) if self.current_char == '+': self.advance() return Token(PLUS, '+') if self.current_char == '-': self.advance() return Token(MINUS, '-') if self.current_char == '*': self.advance() return Token(MUL, '*') if self.current_char == '/': self.advance() return Token(DIV, '/') if self.current_char == '(': self.advance() return Token(LPAREN, '(') if self.current_char == ')': self.advance() return Token(RPAREN, ')') self.error() return Token(EOF, None)################################################################################ ## PARSER ## ################################################################################class AST(object): pass # 表示定义留空class BinOp(AST): def __init__(self, left, op, right): self.left = left self.token = self.op = op self.right = rightclass Num(AST): def __init__(self, token): self.token = token self.value = token.valueclass Parser(object): def __init__(self, lexer): self.lexer = lexer # set current token to the first token taken from the input self.current_token = self.lexer.get_next_token() def error(self): raise Exception('Invalid syntax') def eat(self, token_type): # compare the current token type with the passed token # type and if they match then \"eat\" the current token # and assign the next token to the self.current_token, # otherwise raise an exception. if self.current_token.type == token_type: self.current_token = self.lexer.get_next_token() else: self.error() def factor(self): \"\"\"factor : INTEGER | LPAREN expr RPAREN\"\"\" token = self.current_token if token.type == INTEGER: self.eat(INTEGER) return Num(token) elif token.type == LPAREN: self.eat(LPAREN) node = self.expr() self.eat(RPAREN) return node def term(self): \"\"\"term : factor ((MUL | DIV) factor)*\"\"\" node = self.factor() while self.current_token.type in (MUL, DIV): token = self.current_token if token.type == MUL: self.eat(MUL) elif token.type == DIV: self.eat(DIV) node = BinOp(left=node, op=token, right=self.factor()) return node def expr(self): \"\"\" expr : term ((PLUS | MINUS) term)* term : factor ((MUL | DIV) factor)* factor : INTEGER | LPAREN expr RPAREN \"\"\" node = self.term() while self.current_token.type in (PLUS, MINUS): token = self.current_token if token.type == PLUS: self.eat(PLUS) elif token.type == MINUS: self.eat(MINUS) node = BinOp(left=node, op=token, right=self.term()) return node def parse(self): return self.expr()################################################################################ ## INTERPRETER ## ################################################################################class NodeVisitor(object): def visit(self, node): method_name = 'visit_' + type(node).__name__ visitor = getattr(self, method_name, self.generic_visit) return visitor(node) def generic_visit(self, node): raise Exception('No visit_&#123;&#125; method'.format(type(node).__name__))class Interpreter(NodeVisitor): def __init__(self, parser): self.parser = parser def visit_BinOp(self, node): if node.op.type == PLUS: return self.visit(node.left) + self.visit(node.right) elif node.op.type == MINUS: return self.visit(node.left) - self.visit(node.right) elif node.op.type == MUL: return self.visit(node.left) * self.visit(node.right) elif node.op.type == DIV: return self.visit(node.left) / self.visit(node.right) def visit_Num(self, node): return node.value def interpret(self): tree = self.parser.parse() return self.visit(tree)def main(): while True: try: try: text = raw_input('spi&gt; ') except NameError: # Python3 text = input('spi&gt; ') except EOFError: break if not text: continue lexer = Lexer(text) parser = Parser(lexer) interpreter = Interpreter(parser) result = interpreter.interpret() print(result)if __name__ == '__main__': main()将以上代码保存到名为 spi.py 的文件中，或者直接从 GitHub 下载。自己试一试，确认 你的新的基于树的解释器可以正确地对算术表达式进行求值。下面是某次运行过程：1234567$ python spi.pyspi&gt; 7 + 3 * (10 / (12 / (3 + 1) - 1))22spi&gt; 7 + 3 * (10 / (12 / (3 + 1) - 1)) / (2 + 3) - 5 - 3 + (8)10spi&gt; 7 + (((3 + 2)))12小结今天你学习了关于解析树和 AST，如何构建 AST 以及遍历表示输入的 AST 并解释执行。你还修改了 parser 和 interpreter 并将这两部分解开了。现在 lexer, parser 和 interpreter 之间的接口看起来像这样：你可以把它读作“parser 从 lexer 中 得到 token 然后返回生成的 AST 给 Interpreter 进行遍历并解释执行所给输入”。递归这就是今天的所有内容，但在总结之前我还想简单地聊一聊递归下降 (recursive-descent) parser，即是仅仅给出它的定义。定义就是：一个 递归下降parser 就 是一个自顶向下的 parser，它使用一组递归过程来处理输入。自顶向下反映了 parser 从 构建解析树的顶部结点开始逐渐构建更低的结点这一事实。梳理本节与part6相比主要添加了AST：Lexer与part6中的是一样的，还是将输入的text分析转换为token。(这也是词法分析器的功能)Parser相比part6，它添加了构造AST的内容：添加了三个类：AST()：是一个基类BinOp(AST)：继承于AST()，主要功能是实现二元操作符binary operator 。（这里只有四种：加、减、乘、除法）Num(AST)：继承于AST()，它主要是表示AST中的整数integer token（它将保存一个 INTEGER token 和该 token 的值）第二个变化就是实现语法解析的这三个函数term、factor、expr中的返回的不在是result变量了，而是返回一个结点node。Interpreter：通过词法分析、语法分析之后，开始解释语法分析之后的算式，计算出它的结果，用Interpreter来解释：增添了访问者模式：将 对数据的操作(对数据的操作在interpreter中完成：访问、解释) 和 数据结构(数据结构 在parser中的三个类中构建) 进行分离（解耦合）。使得操作集合可相对自由地演化。这里通过创建 NodeVisitor()类 实现访问者模式。实现了通过什么方式去访问生成的AST又通过Interpreter（继承于 NodeVisitor()类）来实现解释生成的AST最后，再次提醒一下：之前的那几小结，我们都是把interpreter的代码和parser的代码混在一起，但这一小节我们把interpreter的代码和parser的代码分开了。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let's Build A Simple Interpreter","slug":"Let-s-Build-A-Simple-Interpreter","permalink":"https://longlongqin.github.io/tags/Let-s-Build-A-Simple-Interpreter/"}]},{"title":"Let’s Build A Simple Interpreter 6","slug":"学习笔记/Let's Build A Simple Interpreter/LSBASI-6","date":"2020-03-12T04:55:57.000Z","updated":"2020-03-17T09:40:01.085Z","comments":true,"path":"archives/167c.html","link":"","permalink":"https://longlongqin.github.io/archives/167c.html","excerpt":"新增了括号运算(parenthesized expressions)","text":"新增了括号运算(parenthesized expressions)原文链接：https://ruslanspivak.com/lsbasi-part6/本文在前面的基础上，新增了括号运算(parenthesized expressions)，如： 7 + 3 * (10 / (12 / (3 + 1) - 1))所以需要在part5中的语法基础上，进行修改，修改后的语法如下图：从上面的图可以看出来,在part6中，expr和term和part5中一样，唯一变的是factor的产生式 (production)。它新添加了两个 terminal ：LPAREN：表示一个左括号 left parenthesis ‘( ‘RPAREN：表示一个右括号 right parenthesis ‘)’还新添加了一个非终端符：exprexpr添加在两个括号之间下面是factor的语法图：（这里用到了递归）然后，再放一下没有改变的（与part5相同）expr、term的语法图：现在看一下算式：2 * (7 + 3) 的分解过程吧：现在把语法转换成代码。下面这两条是代码中主要改变的部分：Lexer被修改，使其在原来的基础上可以返回另外两个token：左括号LPAREN 、右括号RPARENInterpreter类的factor被修改，修改之后不仅可以解析整数integer，还可以解析括号表达式(parenthesized expressions)下面就是本小节的代码部分：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194# Token types## EOF (end-of-file) token is used to indicate that# there is no more input left for lexical analysisINTEGER, PLUS, MINUS, MUL, DIV, LPAREN, RPAREN, EOF = ( 'INTEGER', 'PLUS', 'MINUS', 'MUL', 'DIV', '(', ')', 'EOF')class Token(object): def __init__(self, type, value): self.type = type self.value = value def __str__(self): \"\"\"String representation of the class instance. Examples: Token(INTEGER, 3) Token(PLUS, '+') Token(MUL, '*') \"\"\" return 'Token(&#123;type&#125;, &#123;value&#125;)'.format( type=self.type, value=repr(self.value) ) def __repr__(self): return self.__str__()class Lexer(object): def __init__(self, text): # client string input, e.g. \"4 + 2 * 3 - 6 / 2\" self.text = text # self.pos is an index into self.text self.pos = 0 self.current_char = self.text[self.pos] def error(self): raise Exception('Invalid character') def advance(self): \"\"\"Advance the `pos` pointer and set the `current_char` variable.\"\"\" self.pos += 1 if self.pos &gt; len(self.text) - 1: self.current_char = None # Indicates end of input else: self.current_char = self.text[self.pos] def skip_whitespace(self): while self.current_char is not None and self.current_char.isspace(): self.advance() def integer(self): \"\"\"Return a (multidigit) integer consumed from the input.\"\"\" result = '' while self.current_char is not None and self.current_char.isdigit(): result += self.current_char self.advance() return int(result) def get_next_token(self): \"\"\"Lexical analyzer (also known as scanner or tokenizer) This method is responsible for breaking a sentence apart into tokens. One token at a time. \"\"\" while self.current_char is not None: if self.current_char.isspace(): self.skip_whitespace() continue if self.current_char.isdigit(): return Token(INTEGER, self.integer()) if self.current_char == '+': self.advance() return Token(PLUS, '+') if self.current_char == '-': self.advance() return Token(MINUS, '-') if self.current_char == '*': self.advance() return Token(MUL, '*') if self.current_char == '/': self.advance() return Token(DIV, '/') if self.current_char == '(': self.advance() return Token(LPAREN, '(') if self.current_char == ')': self.advance() return Token(RPAREN, ')') self.error() return Token(EOF, None)class Interpreter(object): def __init__(self, lexer): self.lexer = lexer # set current token to the first token taken from the input self.current_token = self.lexer.get_next_token() def error(self): raise Exception('Invalid syntax') def eat(self, token_type): # compare the current token type with the passed token # type and if they match then \"eat\" the current token # and assign the next token to the self.current_token, # otherwise raise an exception. if self.current_token.type == token_type: self.current_token = self.lexer.get_next_token() else: self.error() def factor(self): \"\"\"factor : INTEGER | LPAREN expr RPAREN\"\"\" token = self.current_token if token.type == INTEGER: self.eat(INTEGER) return token.value elif token.type == LPAREN: self.eat(LPAREN) result = self.expr() self.eat(RPAREN) return result def term(self): \"\"\"term : factor ((MUL | DIV) factor)*\"\"\" result = self.factor() while self.current_token.type in (MUL, DIV): token = self.current_token if token.type == MUL: self.eat(MUL) result = result * self.factor() elif token.type == DIV: self.eat(DIV) result = result / self.factor() return result def expr(self): \"\"\"Arithmetic expression parser / interpreter. calc&gt; 7 + 3 * (10 / (12 / (3 + 1) - 1)) 22 expr : term ((PLUS | MINUS) term)* term : factor ((MUL | DIV) factor)* factor : INTEGER | LPAREN expr RPAREN \"\"\" result = self.term() while self.current_token.type in (PLUS, MINUS): token = self.current_token if token.type == PLUS: self.eat(PLUS) result = result + self.term() elif token.type == MINUS: self.eat(MINUS) result = result - self.term() return resultdef main(): while True: try: # To run under Python3 replace 'raw_input' call # with 'input' text = raw_input('calc&gt; ') except EOFError: break if not text: continue lexer = Lexer(text) interpreter = Interpreter(lexer) result = interpreter.expr() print(result)if __name__ == '__main__': main()","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let's Build A Simple Interpreter","slug":"Let-s-Build-A-Simple-Interpreter","permalink":"https://longlongqin.github.io/tags/Let-s-Build-A-Simple-Interpreter/"}]},{"title":"Let’s Build A Simple Interpreter 5","slug":"学习笔记/Let's Build A Simple Interpreter/LSBASI-5","date":"2020-03-11T09:45:49.000Z","updated":"2020-04-03T14:51:52.352Z","comments":true,"path":"archives/173c.html","link":"","permalink":"https://longlongqin.github.io/archives/173c.html","excerpt":"本文为这一系列的part5，第五小节。这次将写一个可移植性加减乘除混合运算的解释器。","text":"本文为这一系列的part5，第五小节。这次将写一个可移植性加减乘除混合运算的解释器。原文链接：https://ruslanspivak.com/lsbasi-part5/本文为这一系列的part5，第五小节。这次将写一个可移植性加减乘除混合运算的解释器。在开始写代码之前，我们需要知道一些，比如：结合律、操作符(operator)的优先级(precedence)结合律(associativity)比如，7+3+1等同于(7+3)+1 ，7 - 3 - 1 等同于 (7 - 3) - 1。这没有什么奇怪的。但是再比如： 7 - 3 - 1 与 7 - (3 - 1) 的结果就不一样了。其实：加、减、乘、除 这些操作符(operator)是左结合(left-associative)。比如， 7 + 3 + 1 中的 操作数(operand) 3，它的左右都是 加号 ，但是这个操作数3是与它左边的加号“+”结合的， 所以加法是左结合。那加减乘除混合时，如 7 + 5 * 2 是否还是遵循左结合律呢？很显然，不遵循，因为 (7 + 5) * 2 不等于 7 + 5 * 2 。由此可知：​ 加法和减法是一类，所以它们在一起组成的运算是左结合；乘法和除法是一类，所以他们在一起组成的运算是左结合。（即，左结合律只适用于同一类的操作符(operator)）优先级(precedence)那我们如何规定这种加减乘除（这两类操作符(operator)）同时出现时的运算规则呢？（实际上我们都知道，但是这里是为实现代码来做出一种运算规则）在 7 + 5 * 2中，如果操作符“”能先比操作符“+”到他的操作数5，就说，操作符“”有更高的优先级(higher precedence)。在实际中我们也在用，也知道。乘除的优先级要高于加减法。好了，现在我们开始用表格来表示操作符的结合律与优先级：由上表可知：+ and - 是优先级相同，都是左结合；* and / 优先级相同，也都是左结合；我们还可以根据上面的优先级表格来制定一个语法规则：优先级相同的每一级都定义一个非终端符(non-terminal)。其中每个产生式(production)的body中应该包含:算数运算符(arithmetic operators) &amp; 非终端符(这里的非终端又参与构成下一较高的优先级的规则(产生式)的一部分)创建一个表示 基本表达式的非终端符factor，本文中指integer。一般的规则是：如果你有N个优先级，那么你就需要N+1个非终端符（一类是每一层优先级的一个非终端符，一类是表示基本表达式单元）构建语法(grammars)现在根据上面的规则来构建语法：由规则1，我们将定义两个非终结符(non-terminal)，一个是leve1的non-terminal叫做expr，另一个是level2的non-terminal叫做term。然后根据规则2，我们需要定义一个叫做factor的non-terminal来作为一个基本的表达式单元，integers。这个语法的开始符号（start symbol ）叫做expr。它的产生式(production)的body含有：1️⃣表示level2的操作符(在这指的是+ and - )，2️⃣和一个非终端符term(这个term是下一层优先级（更高的）level1 的一个产生式)开始符号（S）：最大的语法单位 或 最重要的语法单位。（如上面的那个英文句子中的，最大的语法单位是：句子。）非终端符term的production(产生式)的body包含:1️⃣表示level1的操作符(在这指的是 * and /)。2️⃣还有一个非终端符factor来表示基本的表达式单元，integers非终端符factor包含：1️⃣一个integer上面的三幅图是语法、语法图的一部分，这在之前的文章中也出现过。但现在需要将上面的三幅图结合在一起来考虑结合律和优先级（ associativity and precedence ）下面是本文的语法对应的语法图：上面语法图的每一个小方框都是其他语法图的：函数调用（“method call”）。如果你以表达式 7 + 5 * 2 为例并从顶 层图 expr 开始逐步分解到最底层的图 factor, 你应该可以看到位于中间的图的高优 先级操作符*和/会比上面的图的操作符+和-先执行。为了解释清楚运算符的优先级，让我们看看使用上面语法和句法图来分解相同算术表达式 7 + 5 * 2 的过程。这只是另一种展示高优先级运算符 先于 低优先级运算符执行这个事实的 方式。语法转换成代码让我们使用part 4中的准则把该语法转化成代码，看看它怎么工作，先看一张上面放过的语法图：下面是能处理可以包含任意数量加减乘除操作符的算术表达式的计算器的完整代码。相比于part 4代码的主要变化有：Lexer 类现在可以把+,-,*和/都 token 化了（没什么新方法，我们只是把前面文章中 的代码合并到一个类中来支持所有这些 token）回想语法中的每条规则（产生式）R都要变成一个同名的方法，且对该规则的引用都要变 成一个方法调用 R() 这一点。现在 Interpreter 类有了三个方法来对应语法中的非 终结符： expr, term, factor.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182# Token types## EOF (end-of-file) token is used to indicate that# there is no more input left for lexical analysisINTEGER, PLUS, MINUS, MUL, DIV, EOF = ( 'INTEGER', 'PLUS', 'MINUS', 'MUL', 'DIV', 'EOF')class Token(object): def __init__(self, type, value): # token type: INTEGER, PLUS, MINUS, MUL, DIV, or EOF self.type = type # token value: non-negative integer value, '+', '-', '*', '/', or None self.value = value def __str__(self): \"\"\"String representation of the class instance. Examples: Token(INTEGER, 3) Token(PLUS, '+') Token(MUL, '*') \"\"\" return 'Token(&#123;type&#125;, &#123;value&#125;)'.format( type=self.type, value=repr(self.value) ) def __repr__(self): return self.__str__()class Lexer(object): def __init__(self, text): # client string input, e.g. \"3 * 5\", \"12 / 3 * 4\", etc self.text = text # self.pos is an index into self.text self.pos = 0 self.current_char = self.text[self.pos] def error(self): raise Exception('Invalid character') def advance(self): \"\"\"Advance the `pos` pointer and set the `current_char` variable.\"\"\" self.pos += 1 if self.pos &gt; len(self.text) - 1: self.current_char = None # Indicates end of input else: self.current_char = self.text[self.pos] def skip_whitespace(self): while self.current_char is not None and self.current_char.isspace(): self.advance() def integer(self): \"\"\"Return a (multidigit) integer consumed from the input.\"\"\" result = '' while self.current_char is not None and self.current_char.isdigit(): result += self.current_char self.advance() return int(result) def get_next_token(self): \"\"\"Lexical analyzer (also known as scanner or tokenizer) This method is responsible for breaking a sentence apart into tokens. One token at a time. \"\"\" while self.current_char is not None: if self.current_char.isspace(): self.skip_whitespace() continue if self.current_char.isdigit(): return Token(INTEGER, self.integer()) if self.current_char == '+': self.advance() return Token(PLUS, '+') if self.current_char == '-': self.advance() return Token(MINUS, '-') if self.current_char == '*': self.advance() return Token(MUL, '*') if self.current_char == '/': self.advance() return Token(DIV, '/') self.error() return Token(EOF, None)class Interpreter(object): def __init__(self, lexer): self.lexer = lexer # set current token to the first token taken from the input self.current_token = self.lexer.get_next_token() def error(self): raise Exception('Invalid syntax') def eat(self, token_type): # compare the current token type with the passed token # type and if they match then \"eat\" the current token # and assign the next token to the self.current_token, # otherwise raise an exception. if self.current_token.type == token_type: self.current_token = self.lexer.get_next_token() else: self.error() def factor(self): \"\"\"factor : INTEGER\"\"\" token = self.current_token self.eat(INTEGER) return token.value def term(self): \"\"\"term : factor ((MUL | DIV) factor)*\"\"\" result = self.factor() while self.current_token.type in (MUL, DIV): token = self.current_token if token.type == MUL: self.eat(MUL) result = result * self.factor() elif token.type == DIV: self.eat(DIV) result = result / self.factor() return result def expr(self): \"\"\"Arithmetic expression parser / interpreter. calc&gt; 14 + 2 * 3 - 6 / 2 17 expr : term ((PLUS | MINUS) term)* term : factor ((MUL | DIV) factor)* factor : INTEGER \"\"\" result = self.term() while self.current_token.type in (PLUS, MINUS): token = self.current_token if token.type == PLUS: self.eat(PLUS) result = result + self.term() elif token.type == MINUS: self.eat(MINUS) result = result - self.term() return resultdef main(): while True: try: # To run under Python3 replace 'raw_input' call # with 'input' text = raw_input('calc&gt; ') except EOFError: break if not text: continue lexer = Lexer(text) interpreter = Interpreter(lexer) result = interpreter.expr() print(result)if __name__ == '__main__': main()将以上代码保存到名为 calc5.py 中，或者直接从 GitHub 上下载。和以往一样，自己尝 试一下，确认解释器可以对包含不同优先级操作符的算术表达式进行求值。梳理代码中有三个类(class)，他们中的函数及作用：Token：__init__：初始化实例__str__：字符串形式__repr__：字符串形式在Python中，所有以“_”双下划线包起来的方法，都统称为“Magic Method”（魔术方法）,例如类的初始化方法 __init_repr(self)定义当被 repr() 调用时的行为str(self)定义当被 str() 调用时的行为Lexer用于词法分析：__init__：初始化实例error：错误提示advance：使pos前进一个位置skip_whitespace：略过空格integer：识别整数（可以识别多位数）get_next_token：获得一个token（其实我觉得叫做：get_token_and_to_next更合适）Interpreter用于语法分析：__init__：初始化实例error：错误提示eat：负责检测当前的token.type与传入的token_type是否相同。若相同，则将当前的token“吃了”，然后把当前token的下一个token分配给current_token。下面就是语法分析的核心了，由上面的分析直到，它由：expr、term、factor构成。梳理完毕。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let's Build A Simple Interpreter","slug":"Let-s-Build-A-Simple-Interpreter","permalink":"https://longlongqin.github.io/tags/Let-s-Build-A-Simple-Interpreter/"}]},{"title":"Let’s Build A Simple Interpreter 4","slug":"学习笔记/Let's Build A Simple Interpreter/LSBASI-4","date":"2020-03-10T09:27:30.000Z","updated":"2020-03-24T07:56:38.973Z","comments":true,"path":"archives/3b16.html","link":"","permalink":"https://longlongqin.github.io/archives/3b16.html","excerpt":"","text":"原文链接：https://ruslanspivak.com/lsbasi-part4/在前面的文章中你学会了怎样识别和解释包含任意数量的加减操作的算术表达式，例如“7 - 3 + 2 - 1”。还学会了句法图以及它们如何被用来表示一门编程语言的语法。今天你将会学习解析(parse)和解释(interpret)包含任意乘除操作的算术表达式，例如“7 * 4 / 2 * 3”。在这篇文章中使用的是整数除法，所以对于表达式“9 / 4”来说，结果是一个 整数：2。我今天会讲很多另一个表示编程语言句法的广泛使用的表示法，叫 上下文无关语法 (context-free grammars, 简记为 grammars)或 BNF (Backus-Naur Form)。为了这篇文章的目的，我不会使用纯 BNF 记法，而更像是一个修改过的 EBNF 记法。文法(语法)：描述语言的语法结构的形式规则。上下文无关语法就是说这个文法中所有的产生式左边只有一个非终结符，比如：S -&gt; aSbS -&gt; ab这个文法有两个产生式，每个产生式左边只有一个非终结符S，这就是上下文无关文法，因为你只要找到符合产生式右边的串，就可以把它归约为对应的非终结符。比如：aSb -&gt; aaSbbS -&gt; ab这就是上下文相关文法，因为它的第一个产生式左边有不止一个符号，所以你在匹配这个产生式中的S的时候必需确保这个S有正确的“上下文”，也就是左边的a和右边的b，所以叫上下文相关文法。作者：徐辰链接：https://www.zhihu.com/question/21833944/answer/40689967来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。以下是一些使用语法的原因：语法使用了一种简明的方式来描述一门编程语言的句法。不像语法图，语法非常紧凑。 在以后的文章中，你会看到我越来越多地使用语法。语法可以做为文档保存。即使对从头开始写解析器(parser)来说，语法也是一个好的入手点。很多时候通过遵循 一套简单的规则你就可以把语法转化成代码。有一套工具，叫解析器生成器(parser generator)，可以把语法做为输入并自动根据它为你生成一个解析器。我会以后在这个系列中谈到这些工具。语法机制现在，我们来聊聊语法的机制方面：下面的语法描述了算术表达式，像“7 * 4 / 2 * 3”这样的（这只是该语法可以生成的许多表达式之一）：语法是由一系列规则组成的，也被称为产生式(production)。我们的语法中有两条规则(产生式)：1、一条规则由：一个非终结符(叫做 head或生成式的左边) + 一个分号（:）+ 一系列终结符 和/或 非终结符(叫做 body 或 右边)：2、在上面展示的语法中，像 MUL, DIV, 或 INTEGER 这样的 token 被称为 终结符(terminals), expr factor 这样的变量被称为 非终结符(not-terminals).第一条规则左边的非终结符被叫做 开始符号(start symbol). 在我们的语法中，开始符号是 expr:你可以这么理解 expr 这条规则：“expr 是一个 factor 后面可选地跟一个乘或除运算符再跟 另一个 factor，后面也相应可选地跟一个乘或除运算符再跟另一个 factor，如此重复”。factor 是什么？对于本文来说 factor 就是一个整数。语法中的符号让我们快速地过一遍语法中的符号及它们的意义。|多选一。竖线表示“或”。所以 (MUL | DIV) 表示 MUL 或 DIV(...)被括号包围表示把终结符 和/或 非终结符组成一组，就像 (MUL | DIV)(...)*分组中的内容被匹配 0 或 多次。语法通过解释可以组成什么样的句子来定义一门语言。通过语法派生出算术表达式的方式为：首先从开始符号 expr 开始，然后反复地使用所包含的非终结符的规则替换该非终结符， 直到生成一个只包含终结符的句子。语法能组成的句子构成了一门语言。下面举例说明：例1，下面是语法如何派生出表达式 3:例2，下面是语法如何派生出表达式 3 * 7:例3，下面是语法如何派生出表达式 3 * 7 / 2:将语法变成代码下面是一些我们在把语法转化成源代码时会用到的==四个准则==。按照这些准则，你真的就可以把语法翻译成一个可工作的 parser:对于语法中定义的每个规则 R，将它做成一个有相同名字的方法，对该规则的引用就变成了一个方法调用：R()。该方法的方法体遵循该规则的步骤，过程中使用相同的准则。多选一 (a1|a2|aN) 变成 if-elif-else 语句可选组 (...)* 变成一个可以执行 0 或多次的 while 循环（can loop over zero or more times）每个 Token 记为 T 变成一个 eat 方法调用: eat(T). eat 方法的工作是 当它匹配到当前的向前看 (lookahead) token 就消耗掉它，然后从 lexer 中得到一个新 token 并将它赋值给内部变量 current_token.这些准则看上去像这样：让我们继续并遵循上述准则把我们的语法转化为代码。我们的语法中有两条规则： expr 和 factor. 我们从 factor 规则（生成式）开始。 根据准则，需要新建一个名为 factor 的方法（准则1)，它调用了一次 eat 方法来消耗INTEGER token （准则4)：12def factor(self): #factor就是指的integer型数值 self.eat(INTEGER)expr 规则变成了 expr 方法（还是准则1）。规则体(body)开始的 factor 引用 变成了对 factor() 方法的调用。可行组 (...)* 变成了一个 while 循环，多选一 (MUL|DIV) 变成了一个 if-elif-else 语句。把这些片段合并在一起就得到了下面的expr 方法：1234567891011def expr(self): self.factor() #语法准则中的第一个factor while self.current_token.type in (MUL, DIV): token = self.current_token if token.type == MUL: self.eat(MUL) self.factor() elif token.type == DIV: self.eat(DIV) self.factor()原作者将本文的代码放在了文件 parser.py 中，它包含了 lexer 和 parser 但没有interpreter。你可以直接从 GitHub下载并尝试一下。它包含有一个 interpreter 提示符，你可以输入表达式来查看它是否合法，即查看根据语法建立的 parser 是否可以识别出表达式。下面是在我笔记本上的一次尝试：123456789101112131415161718192021$ python parser.pycalc&gt; 3calc&gt; 3 * 7calc&gt; 3 * 7 / 2calc&gt; 3 *Traceback (most recent call last): File \"parser.py\", line 155, in &lt;module&gt; main() File \"parser.py\", line 151, in main parser.parse() File \"parser.py\", line 136, in parse self.expr() File \"parser.py\", line 130, in expr self.factor() File \"parser.py\", line 114, in factor self.eat(INTEGER) File \"parser.py\", line 107, in eat self.error() File \"parser.py\", line 97, in error raise Exception('Invalid syntax')Exception: Invalid syntax这里再次提起语法图。这是相同的 expr 规则（也叫，产生式(production)）对应的句法图：下面是原作者的关于本文的源码。下面是可以处理包含任意数量整数 乘除（整数除法）操作的合法的算术表达式的计算器代码。这里把词法分析器重构 到了一个单独的类 Lexer 中，并让 Interpreter 类使用 Lexer 实例做为参数：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156# Token types## EOF (end-of-file) token is used to indicate that# there is no more input left for lexical analysisINTEGER, MUL, DIV, EOF = 'INTEGER', 'MUL', 'DIV', 'EOF'class Token(object): def __init__(self, type, value): # token type: INTEGER, MUL, DIV, or EOF self.type = type # token value: non-negative integer value, '*', '/', or None self.value = value def __str__(self): \"\"\"String representation of the class instance. Examples: Token(INTEGER, 3) Token(MUL, '*') \"\"\" return 'Token(&#123;type&#125;, &#123;value&#125;)'.format( type=self.type, value=repr(self.value) ) def __repr__(self): return self.__str__()#词法分析class Lexer(object): def __init__(self, text): # client string input, e.g. \"3 * 5\", \"12 / 3 * 4\", etc self.text = text # self.pos is an index into self.text self.pos = 0 self.current_char = self.text[self.pos] def error(self): raise Exception('Invalid character') def advance(self): \"\"\"Advance the `pos` pointer and set the `current_char` variable.\"\"\" self.pos += 1 if self.pos &gt; len(self.text) - 1: self.current_char = None # Indicates end of input else: self.current_char = self.text[self.pos] def skip_whitespace(self): while self.current_char is not None and self.current_char.isspace(): self.advance() def integer(self): \"\"\"Return a (multidigit) integer consumed from the input.\"\"\" result = '' while self.current_char is not None and self.current_char.isdigit(): result += self.current_char self.advance() return int(result) #不如叫做：get_token_and_next def get_next_token(self): \"\"\"Lexical analyzer (also known as scanner or tokenizer) This method is responsible for breaking a sentence apart into tokens. One token at a time. \"\"\" while self.current_char is not None: if self.current_char.isspace(): self.skip_whitespace() continue if self.current_char.isdigit(): return Token(INTEGER, self.integer()) if self.current_char == '*': self.advance() return Token(MUL, '*') if self.current_char == '/': self.advance() return Token(DIV, '/') self.error() return Token(EOF, None)class Interpreter(object): def __init__(self, lexer): self.lexer = lexer # set current token to the first token taken from the input self.current_token = self.lexer.get_next_token() def error(self): raise Exception('Invalid syntax') def eat(self, token_type): # compare the current token type with the passed token # type and if they match then \"eat\" the current token # and assign the next token to the self.current_token, # otherwise raise an exception. if self.current_token.type == token_type: self.current_token = self.lexer.get_next_token() else: self.error() def factor(self): \"\"\"Return an INTEGER token value. factor : INTEGER \"\"\" token = self.current_token self.eat(INTEGER) return token.value def expr(self): \"\"\"Arithmetic expression parser / interpreter. expr : factor ((MUL | DIV) factor)* factor : INTEGER \"\"\" result = self.factor() while self.current_token.type in (MUL, DIV): token = self.current_token if token.type == MUL: self.eat(MUL) result = result * self.factor() elif token.type == DIV: self.eat(DIV) result = result / self.factor() return resultdef main(): while True: try: # To run under Python3 replace 'raw_input' call # with 'input' text = raw_input('calc&gt; ') except EOFError: break if not text: continue lexer = Lexer(text) interpreter = Interpreter(lexer) result = interpreter.expr() print(result)if __name__ == '__main__': main()将以上代码保存到名为 calc4.py 中，或者直接从 GitHub 上下载。和以往一样，自己尝 试一下，确认它能工作。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let's Build A Simple Interpreter","slug":"Let-s-Build-A-Simple-Interpreter","permalink":"https://longlongqin.github.io/tags/Let-s-Build-A-Simple-Interpreter/"}]},{"title":"Let’s Build A Simple Interpreter 3","slug":"学习笔记/Let's Build A Simple Interpreter/LSBASI-3","date":"2020-03-10T06:28:09.000Z","updated":"2020-03-24T05:48:57.917Z","comments":true,"path":"archives/f957.html","link":"","permalink":"https://longlongqin.github.io/archives/f957.html","excerpt":"","text":"原文链接：https://ruslanspivak.com/lsbasi-part3/目前为止，你已经学习了如何解释整数相加或相减的算术表达式如“7+3”或“12-9”。今天我 会聊一聊怎样解析（识别）并解释包含多位整数的加减法的算术表达式，如“7 - 3 + 2 - 1”。语法图本文中的算术表达式可以用如下的语法图(syntax diagram)表示：语法图(syntax diagram)：就是程序语言句法规则的图形表示。基本上，语法图从视觉上向你展示了在你的程序语言中哪些语句是允许的哪些是不允许的。句法图很容易阅读：只需跟随箭头所指示的路径即可。一些路径表示选择，一些路径表示循环。你可以这样阅读上面的句法图：一个 term 后面可以跟一个加号或减号，后面又跟另一个 term， 相应地它后面又可以跟一个加号或减号，后面又跟另一个 term，如此循环。你已经读懂了 这幅图片，真的。你可能会疑惑什么是“term”。在这篇文章中“term”就是一个整数。语法图的用途本文中的语法图主要有两个用途：从图形上表示一个编程语言的标准（语法）。用来帮助你编写parser(语法分析器)，你可以通过下面简单的规则将图映射到代码。语法分析器你已经学过了从 token 流中识别组合的过程叫 parsing. 且解释器或编译器中执行这部分任务的叫 parser. parsing也被称为 语法分析 (syntax analysis)，parser也相应地被称为语法分析器(syntax analyzer)，你应该也猜到这点了。根据上面的句法图，下面所有的算术表达式都是合法的：33 + 47 - 3 + 2 - 1因为在不同的程序语言中算术表达式的句法规则都相似，我们可以使用 Python shell 来 “测试”我们的句法图。启动 Python shell 自己试一下：123456&gt;&gt;&gt; 33&gt;&gt;&gt; 3 + 47&gt;&gt;&gt; 7 - 3 + 2 - 15一切正常。但表达式“3+”就不是合法的算术表达式，因为根据句法图加号后面必须跟一个 term（整数）， 否则就是句法错误。两次启动 Python shell 自己查看结果：12345&gt;&gt;&gt; 3 + File \"&lt;stdin&gt;\", line 1 3 + ^SyntaxError: invalid syntax使用 Python shell 来做测试是挺不错的，不过我们还是把上面的句法图映射到代码，用我 们自己的解释器来测试，是吧？从前面的文章（第一部分和第二部分）你知道了 parser 和 interpreter 都在 expr 方 法中。再重复一下，parser只是识别出结构并保证它符合某些规范，interpreter在parser成功识别后对表达式进行求值。下面的代码片段展示了与句语法图相对应的 parser 的代码。语法图中的矩形盒子变成了解析一个整数的 term 方法， expr 方法则只是跟随了语法图的指示：123456789101112131415def term(self): self.eat(INTEGER)def expr(self): # set current token to the first token taken from the input self.current_token = self.get_next_token() self.term() while self.current_token.type in (PLUS, MINUS): token = self.current_token if token.type == PLUS: self.eat(PLUS) self.term() elif token.type == MINUS: self.eat(MINUS) self.term()可以看到 expr 方法首先调用了 term 方法。然后是一个可能执行 0 或多次的循环。 在循环中，parser 根据 token （是加号还是减号）来做选择。Parser 本身并不解释任何事：如果识别到一个表达式它就沉默，否则就抛出一个句法错误。 让我们修改 expr 方法来添加 interpreter 代码：12345678910111213141516171819202122def term(self): \"\"\"Return an INTEGER token value\"\"\" token = self.current_token self.eat(INTEGER) return token.valuedef expr(self): \"\"\"Parser / Interpreter\"\"\" # set current token to the first token taken from the input self.current_token = self.get_next_token() result = self.term() while self.current_token.type in (PLUS, MINUS): token = self.current_token if token.type == PLUS: self.eat(PLUS) result = result += self.term() elif token.type == MINUS: self.eat(MINUS) result = result - self.term() return result因为 interpreter 需要对表达式进行求值，所以 term 方法被修改为返回一个整数值， expr 方法被修改为在适当的地方执行加减法并返回解释的结果。让我们继续前进，来看一下现在解释器的完整代码怎么样？下面是你新版计算器的源代码，它可以处理包含任意多个整数的加减操作的合法算术表达式：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128# Token的类型：'INTEGER', 'PLUS', 'MINUS', 'EOF'# Token的值(value)：整数，'+', '-', or NoneINTEGER, PLUS, MINUS, EOF = 'INTEGER', 'PLUS', 'MINUS', 'EOF'#定义Token类class Token(object): def __init__(self, type, value): self.type = type self.value = value def __str__(self): return 'Token( &#123;type&#125;, &#123;value&#125; ) ' .format( type = self.type , value = repr(self.value) #repr与下面的__repr__不一样，下面的是重构的。 ) def __repr__(self): return self.__str__()class Interpreter(object): def __init__(self, text): self.text = text self.pos = 0 self.currrent_token = None #此时还没有token实例所以是None self.current_char =self.text[self.pos] ########################################################## # Lexer code # ########################################################## def error(self): raise Exception('Invalid syntax') def advance(self): self.pos += 1 if self.pos &gt; len(self.text) -1 : self.current_char =None else: self.current_char = self.text[self.pos] def skip_whitespace(self): while self.current_char is not None and self.current_char.isspace(): self.advance() def integer(self): result = '' while self.current_char is not None and self.current_char.isdigit(): result += self.current_char self.advance() return int(result) #词法分析(分析之后形成一个个的token) def get_next_token(self): while self.current_char is not None: if self.current_char.isspace(): self.skip_whitespace() continue #识别整数 if self.current_char.isdigit(): return Token(INTEGER, self.integer() ) # 识别是否为+ - 运算符号 if self.current_char == '+': self.advance() return Token(PLUS, '+') if self.current_char == '-': self.advance() return Token(MINUS, '-') self.error() return Token(EOF, None) ########################################################## # Parser / Interpreter code # ########################################################## #比较当前的token的类型与传来的类型是否相同 def eat(self, token_type): if self.currrent_token.type == token_type: self.currrent_token = self.get_next_token() else: self.error() #返回一个整型的token的value def term(self): token = self.currrent_token self.eat(INTEGER) return token.value def expr(self): self.currrent_token = self.get_next_token() result = self.term() while self.currrent_token.type in (PLUS , MINUS): #循环是为了算不止一次的加or减法，从而达到混合运算的目的 token = self.currrent_token if token.type == PLUS: self.eat(PLUS) result = result + self.term() elif token.type == MINUS: self.eat(MINUS) result = result - self.term() return result def main(): while True: try: # To run under Python3 replace 'raw_input' call # with 'input' text = input('calc&gt; ') except EOFError: break if not text: continue interpreter = Interpreter(text) result = interpreter.expr() print(result)if __name__ == '__main__': main()将以上代码保存到名为 calc3.py 中，或者直接从 GitHub 上下载。试一试。亲眼看一下 它可以处理之前展示给你的句法图中包含的算术表达式规则。梳理输入字符串表达式（如“2+8-6+1”)，存入变量text中将text进行词法分析，执行此功能的是get_next_token()函数，词法分析会生成一个个的token然后对词法分析之后的token按照规定的语法，进行语法分析，相应函数为expr()最后输出结果","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let's Build A Simple Interpreter","slug":"Let-s-Build-A-Simple-Interpreter","permalink":"https://longlongqin.github.io/tags/Let-s-Build-A-Simple-Interpreter/"}]},{"title":"3、布尔逻辑和逻辑门","slug":"学习笔记/《计算机科学速成课》笔记/3、布尔逻辑和逻辑门","date":"2020-03-09T17:01:26.000Z","updated":"2020-03-17T08:46:49.337Z","comments":true,"path":"archives/87ef.html","link":"","permalink":"https://longlongqin.github.io/archives/87ef.html","excerpt":"计算机最早的是机电设备，一般使用十进制计数，比如用齿轮数来代表十进制。但是其实只用开/关两种状态已经足够表示信息了，将其称为二进制（Binary）。","text":"计算机最早的是机电设备，一般使用十进制计数，比如用齿轮数来代表十进制。但是其实只用开/关两种状态已经足够表示信息了，将其称为二进制（Binary）。在计算机中，当电流流过时，为闭合状态，表示true（1），当没有电流流过时，为断开状态，表示false（0）。但是其实晶体管可以不只是开/关状态，还可以让不同大小的电流通过，一些早期电子计算机，通过对不同电流大小进行划分，可以使用三进制、五进制等等。但问题是，状态越多就越难区分信号，如果存在电噪音，可能就会使状态十分混乱。所以为了让信号更加清晰，可以只使用“开”和“关”两种状态。另一个使用二进制的原因是，有一整个数学分支专门处理“真”和“假”，它已解决了所有法则和运算，即布尔代数（Boolean Algebra）。布尔代数（Boolean Algebra）与逻辑门在布尔代数中，变量的值是true和false，能够对其进行逻辑操作。布尔代数中有三个基本操作：NOT、AND和OR。NOT GATENOT：把输出端（就像水龙头左边部分送水，它送电）接在上面的电极，如果打开输出，电流就可以流过，然后“接地”，输出就没有电流，所以输出是off。当输入关闭时，电流没法接地，就流过了输出，所以输出是on。就像是水龙头一样：​​ NOT操作：把布尔值进行翻转，所以NOT操作的真值表为AND GATEAND：为了实现“AND 门”，我们需要2个晶体管连接在一起，这样有2个输入和1个输出。如果只打开A，不打开B，电流无法留到output，所以输出是false；如果只打开B，不打开A，也一样，电流无法留到output；只有当A、B都打开了，output才有电流。OR GATEOR：实现OR 门除了晶体管还需要额外的线将两个晶体管(transistor)并联起来，即得到OR GATE左侧电极为电源，下方两个电极分别表示两个输入，右侧电极为输出。只要任意一个输入开启，就能使得电源和输出电极接通，使得输出开启；当两个输入都关闭时，就使得电源和输出电极保持断开状态，使得输出保持关闭。由此通过上方的三个组件（NOT门、AND门和OR门）可以构建出更加复杂的组件。另一个常见的布尔操作叫做异或操作。XOR(异或)我们有两个输入，A和B，还有一个输出。先放一个OR门。因为OR和XOR的逻辑表很像，只有一个不同点就是：当两个输入都为true时，XOR输出false，而OR输出true。通过对AND操作真值表取反，再和OR操作真值表进行对比，可以发现，第二三行都为true，而第一四行结果不同，因此只要在这两个结果后面加个AND就能得到XOR的真值表。小结操作真值表：对应的罗基本表示：","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"计算机科学速成课","slug":"计算机科学速成课","permalink":"https://longlongqin.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE/"},{"name":"布尔逻辑和逻辑门","slug":"布尔逻辑和逻辑门","permalink":"https://longlongqin.github.io/tags/%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91%E5%92%8C%E9%80%BB%E8%BE%91%E9%97%A8/"}]},{"title":"Let’s Build A Simple Interpreter 2","slug":"学习笔记/Let's Build A Simple Interpreter/LSBASI-2","date":"2020-03-09T13:55:47.000Z","updated":"2020-03-23T09:50:36.594Z","comments":true,"path":"archives/d57d.html","link":"","permalink":"https://longlongqin.github.io/archives/d57d.html","excerpt":"If you learn only methods, you’ll be tied to your methods. But if you learnprinciples, you can devise your own methods.","text":"If you learn only methods, you’ll be tied to your methods. But if you learnprinciples, you can devise your own methods.原文地址：https://ruslanspivak.com/lsbasi-part2/这是第二个版本V2.0，第二个版本较第一个版V1.0，它可以做到：处理输入字符串中任何位置的空白符处理输入中的多位数两个整数相减（版本V1.0中只有加法）下面先给出V2.0的新版计算器的源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152# Token types# EOF (end-of-file) token is used to indicate that# there is no more input left for lexical analysisINTEGER, PLUS, MINUS, EOF = 'INTEGER', 'PLUS', 'MINUS', 'EOF'class Token(): def __init__(self, type, value): # token type: 'INTEGER', 'PLUS', 'MINUS', or 'EOF' self.type = type # token value: non-negative integer value, '+', '-', or None self.value = value def __str__(self): \"\"\"String representation of class instance Examples: Token(INTEGER, 3) Token(PLUS, '+') \"\"\" return f'Token(&#123;self.type&#125;, &#123;self.value&#125;)' def __repr__(self): return self.__str__()##__repr__() 与 __str__() 的主要区别在于，前者在交互式步骤中显示结果，后者在 print 函数中显示结果。 class Interpreter(): def __init__(self, text): # client string input, e.g. \"3 + 5\", \"12 - 5\", etc self.text = text # self.pos is an index into self.text self.pos = 0 # current token instance self.current_token = None self.current_char = self.text[self.pos] def error(self): raise Exception('Error parsing input') ########新增####### def advance(self): \"\"\"Advance the 'pos' pointer and set the 'current_char' variable.\"\"\" self.pos += 1 if self.pos &gt;= len(self.text): self.current_char = None # Indicates end of input else: self.current_char = self.text[self.pos] def skip_whitespace(self): while self.current_char is not None and self.current_char.isspace(): self.advance() def integer(self): \"\"\"Return a (multidigit) integer consumed from the input.\"\"\" result = '' while self.current_char is not None and self.current_char.isdigit(): result += self.current_char self.advance() return int(result) ##新增 完毕##### def get_next_token(self): \"\"\"Lexical analyzer (also known as scanner or tokenizer) This method is responsible for breaking a sentence apart into tokens. \"\"\" while self.current_char is not None: if self.current_char.isspace(): self.skip_whitespace() continue if self.current_char.isdigit(): return Token(INTEGER, self.integer()) if self.current_char == '+': self.advance() return Token(PLUS, '+') if self.current_char == '-': self.advance() return Token(MINUS, '-') self.error() return Token(EOF, None) def eat(self, token_type): # compare the current token type with the passed token # type and if they match then \"eat\" the current token # and assign the next token to the self.current_token, # otherwise raise an exception. if self.current_token.type == token_type: self.current_token = self.get_next_token() else: self.error() def expr(self): \"\"\"Parser / Interpreter expr -&gt; INTEGER PLUS INTEGER expr -&gt; INTEGER MINUS INTEGER \"\"\" # set current token to the first token from the input self.current_token = self.get_next_token() # we expect the current token to be an integer left = self.current_token self.eat(INTEGER) # we expect the current token to be either a '+' or '-' op = self.current_token if op.type == PLUS: self.eat(PLUS) elif op.type == MINUS: self.eat(MINUS) else: self.error() # we expect the current token to be an integer right = self.current_token self.eat(INTEGER) # after the above call the self.current_token is set to # EOF token # at this point either the INTEGER PLUS INTEGER or # the INTEGER MINUS INTEGER sequence of tokens # has been successfully found and the method can just # return the result of adding or subtracting two integers, # thus effectively interpreting client input if op.type == PLUS: result = left.value + right.value elif op.type == MINUS: result = left.value - right.value else: self.error() return resultdef main(): while True: try: # To run under Python3 replace 'raw_input' call with 'input' text = input('calc&gt; ') except EOFError: break if not text: continue interpreter = Interpreter(text) result = interpreter.expr() print(result)if __name__ == '__main__': main()把以上代码保存到名为 calc2.py 中，或者直接从 GitHub 上下载。试一试。亲眼看一下 它可以按预期运行：它可以处理输入中的任何位置的空白符；它接受多位整数，除了整数相 加还可以处理整数相减。下面可以再笔记本上次尝试：123456$ python calc2.pycalc&gt; 27 + 330calc&gt; 27 - 720calc&gt;与第一部分相比代码的主要变化有：get_next_token 方法做了一点重构。增加指针 pos 的逻辑被重构到了方法 advance 中。增加了两个方法： skip_whitespace 用来忽略空白符， integer 用来处理输入中的多位整数。expr 方法在修改后，除了可以识别 INTEGER -&gt; PLUS -&gt; INTEGER 这个组合(phrase) 之外，还可以识别INTEGER -&gt; MINUS -&gt; INTEGER。而且在成功识别相应的组合后，也可以进行相应的加减操作。在第一部分你尝到了两个重要的概念，即 token 和 词法分析器 。今天我想聊一聊 lexeme 、 parsing 和 parser 。你已经知道 token 了。但为了叙述方便，需要介绍一下 lexeme。什么是 lexeme？ lexeme 是组成 token 的一个字符序列。在下面的图片中是一些 token 和 lexeme 的例子， 希望它能把两者之间的关系表达清楚：现在还记得 expr 方法吗？我以前说过这是真正解释算术表达式的地方。但在解释一个表达式之前，你需要知道它是哪种组合，比如相加或相减。这是 expr 方法本质上做的事： 它从 get_next_token 方法得到的 token 流中找到结构，然后解释它识别出的组合，产 生算术表达式的结果。又到了做练习的时间了。扩展计算器以处理两个整数相乘扩展计算器以处理两个整数相除修改代码以使它可以解释包含任意个数字的加减操作，如“9 - 5 + 3 + 11”本节检测：什么是 lexeme？在 token 流中找到结构的过程叫什么？或者这么问，在 token 流中识别出特定组合的过程叫什么？解释器（编译器）做 parsing 工作的部分叫什么？梳理：首先输入一个表达式，如“3+9”，送给解释器Interpreter开始对这个表达式拆分成一个个的token，这一步叫做词法分析，由词法分析器(lexical analyzer)来完成。在本文中，函数get_next_token就相当于词法分析器。词法分析器get_next_token处理完之后的是一个个的token(type , value)然后开始进行语法分析（由于本文中只实现了加法、减法），所以这里的语法分析就是分析：加、减法的表达式。执行这个步骤的是expr函数，其中expr 方法使用了辅助方法eat来验证传给token的类型与当前类型是否相匹配。与现有语法规则（即，加法规则和减法规则）不匹配，eat就会抛出异常。语法分析完成之后，就直接得出算式的结果。（这也很符合解释器的特性嘛：边解释边执行，不会生成目标代码）其他的函数：Interpretererror(self)：当有错误的时候，就调用它advance(self)：增加指针pos的作用，即，将指向下一个tokenskip_whitespace(self)：跳过空格，V2.0新增加的功能integer(self)：为了可以算多位数的加减法。这里要注意：如3和233是两个整数类型的token，但是值得注意的是这篇文章中的token是按照输入的一串字符串（如“3+155”）每一个都当成一个token。也就是说本来155是一个token，但是从细节上看，在代码实现中155是被当成了三次“token”然后经过integer函数才形成了最终形体155这个token。在本系列的下一篇文章中你会扩展你的计算器来处理更复杂的算术表达式。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let’s Build A Simple Interpreter","slug":"Let’s-Build-A-Simple-Interpreter","permalink":"https://longlongqin.github.io/tags/Let%E2%80%99s-Build-A-Simple-Interpreter/"}]},{"title":"Let’s Build A Simple Interpreter 1","slug":"学习笔记/Let's Build A Simple Interpreter/LSBASI-1","date":"2020-03-08T09:26:27.000Z","updated":"2020-04-19T14:38:29.546Z","comments":true,"path":"archives/427485bf.html","link":"","permalink":"https://longlongqin.github.io/archives/427485bf.html","excerpt":"为什么要你学解释器和编译器？这里有三条理由。","text":"为什么要你学解释器和编译器？这里有三条理由。要写一个解释器或编译器，你必须同时用到很多技术。编写一个解释器或编译器会帮助 你提高这些技能并且成为一个更好的软件开发者。而且，你将学到的这些技能在开发任 何软件时都有可能用到，而不仅仅是解释器或编译器。你确实想要知道计算机如何工作。一般解释器和编译器看上去都像魔法一样。但你不应 该对这些魔法感到舒服。你想要揭开解释器和编译器的神秘面纱，理解它们如何工作并 控制所有一切。你想要创造自己的编程语言或者领域特定语言。如果是这样，你就需要为这个语言创建 一个解释器或编译器。最近，创建新语言再度兴起。你几乎每天都可以看到一门新语言 的诞生：Elixir, Go, Rust 等。原文链接：https://ruslanspivak.com/lsbasi-part1/好了，但什么是解释器和编译器呢？解释器与编译器解释器与编译器都是“高级语言与机器之间的翻译官”。都是将代码翻译成机器可以执行的二进制机器码，只不过在运行原理和翻译过程不同。那它们的区别在于：编译器：先整体编译完，然后一次性执行。比如：C语言代码被编译成二进制代码（exe程序），在windows平台上执行。解释器：解释一句后就提交计算机执行一句，即边解释边执行。比如php，postscritp，javascript就是典型的解释性语言。用一个通俗的例子来讲：我们去饭馆吃饭，点了八菜一汤。编译器的方式就是厨师把所有的菜给你全做好了，一起给你端上来，至于你在哪吃，怎么吃，随便。解释器的方式就是厨师做好一个菜给你上一个菜，你就吃这个菜，而且必须在饭店里吃。编译器与解释器的工作流程的差别：编译器与解释器的各自的特点：构造解释器V1.0该系列文章的作者使用 Python 编写Pascal语言的解释器。第一版V1.0，构造的计算器有诸多限制。如：只输入一位的数字现阶段仅支持加法操作输入中不允许有空白符这些约束使得构建一个计算器很简单，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125# Token types：# EOF (end-of-file) token is used to indicate that# there is no more input left for lexical analysisINTEGER, PLUS, EOF = 'INTEGER', 'PLUS', 'EOF'class Token(object): def __init__(self, type, value): # token type: INTEGER, PLUS, or EOF self.type = type # token value: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, '+', or None self.value = value def __str__(self): \"\"\"String representation of the class instance. Examples: Token(INTEGER, 3) Token(PLUS, '+') \"\"\" return 'Token(&#123;type&#125;, &#123;value&#125;)'.format( type=self.type, value=repr(self.value) ) def __repr__(self): return self.__str__()class Interpreter(object): def __init__(self, text): # client string input, e.g. \"3+5\" self.text = text # self.pos is an index into self.text self.pos = 0 # current token instance self.current_token = None def error(self): raise Exception('Error parsing input') def get_next_token(self): \"\"\"Lexical analyzer (also known as scanner or tokenizer) This method is responsible for breaking a sentence apart into tokens. One token at a time. \"\"\" text = self.text # is self.pos index past the end of the self.text ? # if so, then return EOF token because there no more # input left to convert into tokens if self.pos &gt; len(text) - 1: return Token(EOF, None) # get a character at the position self.pos and decide # what token to create based on the single character current_char = text[self.pos] # if the character is a digit then convert it to # integer, create an INTEGER token, increment self.pos # index to point to the next character after the digit, # and return the INTEGER token if current_char.isdigit(): token = Token(INTEGER, int(current_char)) self.pos += 1 return token if current_char == '+': token = Token(PLUS, current_char) self.pos += 1 return token self.error() def eat(self, token_type): # compare the current token type with the passed token # type and if they match then \"eat\" the current token # and assign the next token to the self.current_token, # otherwise raise an exception. if self.current_token.type == token_type: self.current_token = self.get_next_token() else: self.error() def expr(self): \"\"\"expr -&gt; INTEGER PLUS INTEGER\"\"\" # set current token to the first token taken from the input self.current_token = self.get_next_token() # we expect the current token to be a single-digit integer left = self.current_token self.eat(INTEGER) # we expect the current token to be a '+' token op = self.current_token self.eat(PLUS) # we expect the current token to be a single-digit integer right = self.current_token self.eat(INTEGER) # after the above call the self.current_token is set to # EOF token # at this point INTEGER PLUS INTEGER sequence of tokens # has been successfully found and the method can just # return the result of adding two integers, thus # effectively interpreting client input result = left.value + right.value return resultdef main(): while True: try: # To run under Python3 replace 'raw_input' call with 'input' text = input('calc&gt; ') except EOFError: break if not text: continue interpreter = Interpreter(text) result = interpreter.expr() print(result)if __name__ == '__main__': main()把以上代码保存到名为 calc1.py 中，或者直接从 GitHub 上下载。在你开始仔细研究代 码之前，在命令行上运行这个计算器并看它实现运行。把玩一下！下面是在我笔记本上的一 次尝试（如果你想在 Python3 下运行，就需要把 raw_input 替换为 input）：12345678$ python calc1.pycalc&gt; 3+47calc&gt; 3+58calc&gt; 3+912calc&gt;代码分析假设我们在命令行输入一个表达式“3+5”。你的解释器得到一个字符串 “3+5”。为了使解释器真正理解如何处理这个字符串，需要先把输入的 “3+5” 拆分成被叫做 token 的部件。词法分析：（lexical analysis，简称lexer，亦称scanner 或 tokenizer）​ 词法分析也称为 分词 ，此阶段编译器从左向右扫描源文件，将其字符流分割成一个个的 词 （ token 、 记号 ，后文中将称为 token ）。Token：​ 所谓 token ，就是源文件中不可再进一步分割的一串字符，类似于英语中单词，或汉语中的词。这里的 token 就是一个有类型的值的对象（即，token还存着值的类型）。例如对于字符串“3”来说，token 类型为 INTEGER ， 相应的值是整数 3 。解释器Interpreter要做的第一步就是读取输入的字符串并把他转化成 token 流。解释器中做这个工作的部分被称为 词法分析器(lexical analyzer)，简称 lexer 。也可以称它为： scanner 或 tokenizer 。他们的含义是一样的：表示解释器或编译器中将输入的字符串转化为 token 流的部分。那是如何转化为token流呢？解释器 Interpreter中的 get_next_token 方法就是你的词法分析器。你每次调用它，就会从输入到解释器的字符流中得到下一个 token。让我们仔细看一下这个方法，看看它是怎么把字符转化 为 token 的。输入被存放在变量 text 中，它保存了输入的字符串， pos 是指向该字符串的一个索引（把字符串看作是一个字符数组）。 pos 的初值被设为 0, 指向字符‘3’。 该方法首先检查该字符是不是数字，若是数字，就递增 pos 并返回一个类型为 INTEGER 值 为整数 3 的 token：现在 pos 指向了 text 中的字符‘+’，下次你调用这个方法时，它会先测试 pos 位 置的字符是否是数字，然后再测试它是否是加号，此时它是加号。这样该方法就递增 pos 并返回一个类型为 PLUS 值为‘+’的 token：现在 pos 指向了字符‘5’。当你再次调用 get_next_token 时，它会检查 pos 位置 是否是一个数字，此时是的，因此它递增 pos 并返回一个类型为 INTEGER 值为‘5’的 token：现在索引 pos 越过了字符串“3+5”的末尾，接下来每次调用 get_next_token 方法都会 返回 EOF token：自己动手试试看看你的计算器的 lexer 组件怎么工作的：123456789101112131415&gt;&gt;&gt; from calc1 import Interpreter&gt;&gt;&gt;&gt;&gt;&gt; interpreter = Interpreter('3+5')&gt;&gt;&gt; interpreter.get_next_token()Token(INTEGER, 3)&gt;&gt;&gt;&gt;&gt;&gt; interpreter.get_next_token()Token(PLUS, '+')&gt;&gt;&gt;&gt;&gt;&gt; interpreter.get_next_token()Token(INTEGER, 5)&gt;&gt;&gt;&gt;&gt;&gt; interpreter.get_next_token()Token(EOF, None)&gt;&gt;&gt;此时你的解释器已经可以从输入的字符流中获得 token 流了，解释器需要对它做点什么： 它需要从使用 lexer get_next_token 得到的字符流中找到结构。你的解释器期望从 流中找到如下的结构： INTEGER -&gt; PLUS -&gt; INTEGER. 即，它试着找到这样一个 token 序 列：整数后跟一个加号再跟一个整数。负责查找和解释这个结构的方法是 expr. 这个方法验证一个 token 序列是否遵从期望的 token 序列，即 INTEGER -&gt; PLUS -&gt; INTEGER. 当确定遵从这个结构后，它就把 PLUS 左 边和右边 token 的值相加来生成结果，从而成功地解释了你传给解释器的算术表达式。expr 方法使用了辅助方法 eat 来验证传给 eat 的 token 类型与当前的 token 类 型相匹配。在匹配到传入的 token 类型后， eat 方法会取得下一个 token 并把它赋值 给变量 current_token, 这样实际上是“吃掉”了当前匹配的 token 并把想象中的 token 流中的指针向前移动了。如果 token 流中的结构不遵从期望的 INTEGER PLUS INTEGER 序 列， eat 方法就会抛出一个异常。小结回顾一下你的解释器为了对一个算术表达式求值都做了什么：解释器接Interpreter收一个输入字符串，假设为“3+5”解释器调用了 expr 方法来从词法解析器 get_next_token 返回的 token 流中寻找一个结构。这个结构就是一个 INTEGER PLUS INTEGER 的形式。当确认了这个结构以后，它就使用把两个 INTEGER token 相加的方式来解释这个输入，因为此时解释器已经清楚 地知道它要做的就是把 3 和 5 两个整数相加。祝贺你。你刚刚学会了怎么构造你的第一个解释器！现在是时候做此练习了。你不会觉得你刚刚读了这篇文章就足够了，是吧？好了，自己动手做下面的练习：修改代码使得允许输入多位整数，例如“12+3”增加一个跳过空白符的方法，使你的计算器可以处理包含空白符的输入如 “ 12 + 3”修改代码使得它可以处理‘-’而非‘+’的情况检查你的理解。什么是解释器？什么是编译器？解释器和编译器的区别是什么？什么是 token？将输入拆分成 token 的过程叫什么？解释器中做词法分析的部分叫什么？解释器或编译器的这个部分还有什么其他常见的名字？相关文章链接：编译器与解释器：https://www.liujiangblog.com/course/python/9Let’s Build A Simple Interpreter. Part 1：https://feng-qi.github.io/2018/01/23/lets-build-a-simple-interpreter-part-01/","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let’s Build A Simple Interpreter","slug":"Let’s-Build-A-Simple-Interpreter","permalink":"https://longlongqin.github.io/tags/Let%E2%80%99s-Build-A-Simple-Interpreter/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"2、电子计算机","slug":"学习笔记/《计算机科学速成课》笔记/2、电子计算机","date":"2020-03-07T19:02:53.000Z","updated":"2020-03-17T09:03:42.618Z","comments":true,"path":"archives/d84f.html","link":"","permalink":"https://longlongqin.github.io/archives/d84f.html","excerpt":"这个系列的课程还是值得大家去看一看的。这个系列的视频叫《计算机科学速成课》。虽然叫速成课，我们也要做到心中有数，它肯定不是让你看了这些内容你就什么都知道了。这是科普性的视频。这个视频都是被翻译好的，再次感谢这些翻译者。","text":"这个系列的课程还是值得大家去看一看的。这个系列的视频叫《计算机科学速成课》。虽然叫速成课，我们也要做到心中有数，它肯定不是让你看了这些内容你就什么都知道了。这是科普性的视频。这个视频都是被翻译好的，再次感谢这些翻译者。前言视频在B站上都有全集的，传送门：https://www.bilibili.com/video/av21376839在GitHub上的地址：https://github.com/1c7/crash-course-computer-science-chinese这门课总共有40节，每节课的标题为：计算机早期历史电子计算布尔逻辑与逻辑电路二进制算术逻辑单元寄存器 &amp; 内存中央处理器指令和程序高级 CPU 设计编程史话编程语言编程原理：语句和函数算法初步数据结构阿兰·图灵软件工程集成电路、摩尔定律操作系统内存 &amp; 储存介质文件系统压缩命令行界面屏幕 &amp; 2D 图形显示冷战和消费主义个人计算机革命图形用户界面3D 图形计算机网络互联网万维网网络安全黑客与攻击加密机器学习与人工智能计算机视觉自然语言处理机器人计算机中的心理学教育型科技奇点，天网，计算机的未来计算机早期历史这一张图大致说明了计算机早期发展的历史。图片来源：请查看图片本身链接。后面的课会较详细的讲解。电子计算机继电器在1937年最大的机电计算机之一是哈佛的马克一号(Harvard Mark Ⅰ)，是IBM在1944年给二战的同盟国建造的。该机器的大脑(CPU的基础器件)是“继电器”。继电器：是用电控制的机械开关，继电器里有根“控制线路”控制着电路的开关，“控制线路”连着一个线圈，当线圈通电时，会产生感应磁场，由此由此能够吸引上方的金属臂，从而闭合电路，得到高电平。它的性能：1940年一个好的继电器1秒能翻转50次。哈佛马克一号1秒能做3次加减法运算，一次乘法需要6秒，除法需要15秒，三角函数需要一分钟以上。它的缺点：控制开关的金属臂是“有质量的”，因此无法快速开关。并且金属臂的反复移动就会存在磨损（任何会动的机械都会随时间磨损），哈佛马克一号平均每天需要更换一个故障继电器。真空管在1904年，英国物理学家John Ambrose Fleming开发了新的电子组件——热电子管（Thermionic valve）。热电子管：把两个电极装在一个气密的真空玻璃灯泡中。其中一个点击A可以加热，从而发射电子，称为热电子发射（Thermionic emission）；另一个电极B会吸引电子，来形成电流。但只有当电极B带正电时才能吸引电子，否则当电极B带负电荷或者中性电荷时，电子就无法跨越真空区。美国发明家Lee de Forest在此基础上加入了第三个控制电极。通过向控制电极施加正电荷，就能吸引电子，从而闭合电路；而通过施加负电荷，就能闭合电路。特点：每秒可开闭数千次。和继电器相同的是，可以通过一个控制线路来控制断开或闭合电路，并且真空管内没有会动的组件，因此存在更少的磨损。比较脆弱，会像灯泡一样烧坏，并且体积比较大。真空管的出现，标志着计算机从机电转向电子，电子数值积分计算机ENIAC，在1946年于宾夕法尼亚大学设计制造，这是世上第一个真正的通用可编程电子计算机，每秒可执行5000次十位加减法。但是由于存在大量的真空管，因此ENIAC运行半天左右就会出现一次故障。晶体管晶体管：类似于继电器和真空管，晶体管也是一个用于控制电路闭合断开的开关。晶体管有两个电极，这两个电极之间通过半导体材料隔开。控制线连接到一个“门”电极，通过改“门”的电荷，我们可以控制半导体的导电性，由此来控制电流是否流动。当控制线路通电时，两个电极接通，否则两个电极断开。特点：每秒可开关10000次。相比玻璃制成的真空管，晶体管是固体的，并且体积远小于继电器和真空管。第一个消费者可购买的，完全由晶体管构成的计算机是1957年发布的IBM 608，它有3000个晶体管，每秒执行4500次加减法，或80次左右的乘除法。如今，计算机里的晶体管小于50nm，并且每秒可切换上百万次，工作几十年。很多晶体管和半导体开发在圣克拉拉谷，位于旧金山和圣河西之间，由于制造半导体最常见的材料是硅，由此这个地方被称为“硅谷”。并且William Shockley搬过去创建了肖克利半导体，里面的员工后来成立了仙童半导体，而这里面的员工后来创立了英特尔。所以，计算机的大脑基础单元的发展路径，可概括为：继电器-&gt;电子管-&gt;晶体管","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"《计算机科学速成课》","slug":"《计算机科学速成课》","permalink":"https://longlongqin.github.io/tags/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE%E3%80%8B/"}]},{"title":"Hexo之 Yilia主题配置","slug":"Hexo博客搭建/hexo之Ylia主题配置","date":"2020-03-06T14:50:08.000Z","updated":"2020-03-18T08:51:47.606Z","comments":true,"path":"archives/460671de.html","link":"","permalink":"https://longlongqin.github.io/archives/460671de.html","excerpt":"Yilia主题配置","text":"Yilia主题配置在左侧显示总文章数将themes\\yilia\\layout_partial\\left-col.ejs文件的1234567&lt;nav class=\"header-menu\"&gt; &lt;ul&gt; &lt;% for (var i in theme.menu)&#123; %&gt; &lt;li&gt;&lt;a href=\"&lt;%- url_for(theme.menu[i]) %&gt;\"&gt;&lt;%= i %&gt;&lt;/a&gt;&lt;/li&gt; &lt;%&#125;%&gt; &lt;/ul&gt;&lt;/nav&gt;后面加上123&lt;nav&gt; 总文章数 &lt;%=site.posts.length%&gt;&lt;/nav&gt;字数、阅读时长添加首先安装 hexo-wordcount使用如下命令安装：1npm i --save hexo-wordcount #如果安装了cnpm，可换为cnpm安装Node 版本7.6.0之前,请安装 2.x 版本 (Node.js v7.6.0 and previous)1Copynpm install hexo-wordcount@2 --save然后在 themes\\yilia\\layout\\_partial\\left-col.ejs中添加：123Copy&lt;nav&gt; 总字数 &lt;span class&#x3D;&quot;post-count&quot;&gt;&lt;%&#x3D; totalcount(site, &#39;0,0.0a&#39;) %&gt;&lt;&#x2F;span&gt;&lt;&#x2F;nav&gt;添加位置在如下代码的下面：123Copy&lt;nav&gt; 总文章数 &lt;%&#x3D;site.posts.length%&gt;&lt;&#x2F;nav&gt;编辑 themes\\yilia\\layout\\_partial\\article.ejs在header下面加入：123&lt;div align&#x3D;&quot;left&quot; class&#x3D;&quot;post-count&quot;&gt; &lt;!--其中align可以在：right、center、left--&gt; 字数：&lt;%&#x3D; wordcount(post.content) %&gt;字 | 预计阅读时长：&lt;%&#x3D; min2read(post.content) %&gt;分钟&lt;&#x2F;div&gt;即可显示单篇字数和预计阅读时长。置顶文章安装插件12npm uninstall hexo-generator-index --savenpm install hexo-generator-index-pin-top --save配置置顶标准打开：/themes/*/layout（/_macro）/post.ejs 直接在最前面加入以下代码即可12345&lt;% if (page.top) &#123; %&gt; &lt;i class=\"fa fa-thumb-tack\"&gt;&lt;/i&gt; &lt;font color=7D26CD&gt;置顶&lt;/font&gt; &lt;span class=\"post-meta-divider\"&gt;|&lt;/span&gt;&lt;% &#125; %&gt;配置文章然后在需要置顶的文章的Front-matter中加上top选项即可 top后面的数字越大，优先级越高12345---title: 2019date: 2019-02-14 16:10:03top: 5---增加不蒜子统计利用这个统计，可以知道你博客的访问量。安装不蒜子脚本：在themes\\yilia\\layout\\ _partial\\after-footer.ejs最后添加：1&lt;script async src=\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt;单篇文章点击量：在themes/yilia/layout/_partial/article.ejs中 在1&lt;%- partial(&#39;post&#x2F;title&#39;, &#123;class_name: &#39;article-title&#39;&#125;) %&gt;后面插入如下代码1234567891011&lt;!--显示阅读次数--&gt;&lt;% if (!index &amp;&amp; post.comments)&#123; %&gt; &lt;br/&gt; &lt;a class=\"cloud-tie-join-count\" href=\"javascript:void(0);\" style=\"color:gray;font-size:14px;\"&gt; &lt;span class=\"icon-sort\"&gt;&lt;/span&gt; &lt;span id=\"busuanzi_container_page_pv\" style=\"color:#ef7522;font-size:14px;\"&gt; 阅读数: &lt;span id=\"busuanzi_value_page_pv\"&gt;&lt;/span&gt;次 &amp;nbsp;&amp;nbsp; &lt;/span&gt; &lt;/a&gt;&lt;% &#125; %&gt;&lt;!--显示阅读次数完毕--&gt;增加版权声明配置yilia：在themes/yilia/layout/_partial/article.ejs中，标注的位置添加代码：1234567891011121314&lt;div class=\"article-entry\" itemprop=\"articleBody\"&gt; &lt;% if (post.excerpt &amp;&amp; index)&#123; %&gt; &lt;%- post.excerpt %&gt; &lt;% if (theme.excerpt_link) &#123; %&gt; &lt;a class=\"article-more-a\" href=\"&lt;%- url_for(post.path) %&gt;#more\"&gt;&lt;%= theme.excerpt_link %&gt; &gt;&gt;&lt;/a&gt; &lt;% &#125; %&gt; &lt;% &#125; else &#123; %&gt; &lt;%- post.content %&gt; &lt;% &#125; %&gt; &lt;-- 在此处添加代码--&gt; &lt;-- 在此处添加代码--&gt; &lt;-- 在此处添加代码--&gt; &lt;-- 在此处添加代码--&gt; &lt;% if ((theme.reward_type === 2 || (theme.reward_type === 1 &amp;&amp; post.reward)) &amp;&amp; !index)&#123; %&gt; &lt;div class=\"page-reward\"&gt; &lt;a href=\"javascript:;\" class=\"page-reward-btn tooltip-top\"&gt; &lt;div class=\"tooltip tooltip-east\"&gt;在目录：themes/yilia/source-src/css中创建新文件：declare.scss，并添加如下CSS代码：123456.declare &#123; background-color: #eaeaea; margin-top: 2em; border-left: 3px solid #ff1700; padding: .5em 1em;&#125;然后，为themes/yilia/source-src/css/main.scss，添加如下代码：1@import \"./declare\";配置显示：现在该让其显示出来，在themes/yilia/_config.yml，中加入：123456789#版权基础设定：0-关闭声明； 1-文章对应的md文件里有declare: true属性，才有版权声明； 2-所有文章均有版权声明#当前应用的版权协议地址。#版权协议的名称#版权协议的Logodeclare_type: 1licensee_url: https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by-nc-sa&#x2F;4.0&#x2F;licensee_name: &#39;知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议&#39;licensee_img: https:&#x2F;&#x2F;i.creativecommons.org&#x2F;l&#x2F;by-nc-sa&#x2F;4.0&#x2F;88x31.png然后在需要进行版权声明的文章的md文件头部，设置属性1declare:true即可。在主页时文章显示摘要在你 MD 格式文章正文插入 &lt;!-- more --&gt; 即可，只会显示它之前的，此后的就不显示，点击文章标题，，或者点击下面的按钮，即可进入全文。如：文章显示目录增加文章目录 TOC ( table of content )，方便阅读文章，在 themes/yilia/_config.yml 中进行配置 toc: 2 即可，它会将你 Markdown 语法的标题，生成目录，目录查看在右下角。头像设置设置存放位置：头像/图标图片的存放位置是/themes/yilia/source/下任意位置，可以自己新建一个文件夹存放，我存放在assets文件夹下。（我之前放在img中，但是不知道为什么，它就显示不出来）配置修改：配置文件为/themes/yilia/_config.yml。设置头像为配置文件中avatar一项，设置图标为配置文件中favicon一项，设置路径的根目录为/themes/yilia/source/。例如，我的头像存放的地址是/themes/yilia/source/assets/me.png，设置则为avatar: /assets/me.png。（图标同理）提交网页sitemap方式提交网页在 Hexo 根目录打开命令行工具，执行以下命令：123npm install hexo-generator-sitemap --savehexo cleanhexo g查看1&#123;your_hexo_path&#125;&#x2F;public文件夹，可以看到文件：1sitemap.xmlsitemap 的初衷是给搜索引擎看的，为了提高搜索引擎对自己站点的收录效果，我们最好手动到 google 和百度等搜索引擎提交 sitemap.xml。baidu提交网址：https://ziyuan.baidu.com/?castk=LTE%3D百度自动推送方式提交网页在本机1&lt;博客根目录&gt;&#x2F;themes&#x2F;yilia&#x2F;layout&#x2F;_partial目录下打开article.ejs文件，定位到如下这段代码：1234&lt;% var sUrl &#x3D; url.replace(&#x2F;index\\.html$&#x2F;, &#39;&#39;); sUrl &#x3D; &#x2F;^(http:|https:)\\&#x2F;\\&#x2F;&#x2F;.test(sUrl) ? sUrl : &#39;https:&#39; + sUrl; %&gt;在它前面加上：123456789101112131415161718&lt;!- 百度自动推送方式提交 --&gt;&lt;% if (1)&#123; %&gt; &lt;script&gt; (function()&#123; var bp &#x3D; document.createElement(&#39;script&#39;); var curProtocol &#x3D; window.location.protocol.split(&#39;:&#39;)[0]; if (curProtocol &#x3D;&#x3D;&#x3D; &#39;https&#39;) &#123; bp.src &#x3D; &#39;https:&#x2F;&#x2F;zz.bdstatic.com&#x2F;linksubmit&#x2F;push.js&#39;; &#125; else &#123; bp.src &#x3D; &#39;http:&#x2F;&#x2F;push.zhanzhang.baidu.com&#x2F;push.js&#39;; &#125; var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(bp, s); &#125;)(); &lt;&#x2F;script&gt;&lt;% &#125; %&gt;&lt;!- 百度自动推送方式提交结束 --&gt;即完成了新增博客文章页面（不包括其他页面）的自动推送方式提交。链接提交百度站长平台的链接提交方式分为自动提交和手动提交两种，此处只讲自动提交，手动提交按照要求操作即可。主动推送设置主动推送最为快速的提交方式，是被百度收录最快的推送方式。主动推送可以通过安装插件实现：首先安装插件：1npm install hexo-baidu-url-submit --save修改站点根目录下的配置文件_config.yml，添加以下内容：12345baidu_url_submit: count: 20 ## 提交最新的20个链接 host: www.dongshuyan.com ## 百度站长平台中注册的域名 token: ## 16位准入秘钥 path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里准入秘钥获取:在如下图的网址中：下拉，找到这里：点击进去就是准入秘钥。检查:其次，记得查看根目录下的_config.yml文件中url的值， 必须包含是百度站长平台注册的域名， 比如:123456# URL## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;url: http:&#x2F;&#x2F;dongshuyan.comroot: &#x2F;permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;permalink_defaults:最后，加入新的deployer最后，加入新的deployer:12345deploy:- type: git ## 这是我原来的deployer repo: branch:- type: baidu_url_submitter ## 添加这里内容即可这里的”-“,必不可少！ 否则报错。使用其主动推送的实现原理如下：新链接的产生， hexo generate 会产生一个文本文件，里面包含最新的链接新链接的提交， hexo deploy 会从上述文件中读取链接，提交至百度搜索引擎自动推送装自动推送JS代码的网页，在页面被访问时，页面URL将立即被推送给百度。修改主题目录下的layout/post.ejs文件，末尾添加自动推送代码，代码如下：1234567891011121314&lt;script&gt;(function()&#123; var bp &#x3D; document.createElement(&#39;script&#39;); var curProtocol &#x3D; window.location.protocol.split(&#39;:&#39;)[0]; if (curProtocol &#x3D;&#x3D;&#x3D; &#39;https&#39;) &#123; bp.src &#x3D; &#39;https:&#x2F;&#x2F;zz.bdstatic.com&#x2F;linksubmit&#x2F;push.js&#39;; &#125; else &#123; bp.src &#x3D; &#39;http:&#x2F;&#x2F;push.zhanzhang.baidu.com&#x2F;push.js&#39;; &#125; var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(bp, s);&#125;)();&lt;&#x2F;script&gt;出处：(http://dongshuyan.com/2019/05/24/hexo博客注意事项/#14-Hexo添加百度统计)添加百度统计和谷歌统计代码百度统计首先打开百度站长平台，注册账户。然后登陆 百度统计》管理》新增站点。然后复制生成的代码：123456789&lt;script&gt;var _hmt = _hmt || [];(function() &#123; var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?这里是你的专属字符串\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s);&#125;)();&lt;/script&gt;这一段代码，最重要的就是你那段专属的字符串。开始配置：首先，打开1themes&#x2F;yilia&#x2F;_config.yml里面1baidu_analytics: ''改为1baidu_analytics: true然后，打开：1themes/yilia/layout/_partial/baidu-analytics.ejs你会看到：1234567891011&lt;% if (theme.baidu_analytics)&#123; %&gt;&lt;script&gt;var _hmt &#x3D; _hmt || [];(function() &#123; var hm &#x3D; document.createElement(&quot;script&quot;); hm.src &#x3D; &quot;https:&#x2F;&#x2F;hm.baidu.com&#x2F;hm.js?&lt;%&#x3D; theme.baidu_analytics %&gt;&quot;; var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(hm, s);&#125;)();&lt;&#x2F;script&gt;&lt;% &#125; %&gt;这里，我们直接用你的专属字符串去替换&lt;%= theme.baidu_analytics %&gt;就行了。替换后为：1234567891011&lt;% if (theme.baidu_analytics)&#123; %&gt;&lt;script&gt;var _hmt &#x3D; _hmt || [];(function() &#123; var hm &#x3D; document.createElement(&quot;script&quot;); hm.src &#x3D; &quot;https:&#x2F;&#x2F;hm.baidu.com&#x2F;hm.js?你的专属字符串&quot;; var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(hm, s);&#125;)();&lt;&#x2F;script&gt;&lt;% &#125; %&gt;谷歌统计参考：http://yansheng836.coding.me/article/eda67a25.html","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://longlongqin.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Yilia主题配置","slug":"Yilia主题配置","permalink":"https://longlongqin.github.io/tags/Yilia%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"}]},{"title":"Hexo之Matery主题配置","slug":"Hexo博客搭建/Hexo之Matery主题配置","date":"2020-03-05T09:29:38.000Z","updated":"2020-03-17T08:27:59.163Z","comments":true,"path":"archives/514b.html","link":"","permalink":"https://longlongqin.github.io/archives/514b.html","excerpt":"最近的三天一直在折腾hexo框架的博客，先是使用yilia主题，但是用来一天觉得我不适合这个主题，随即看到了matery主题。","text":"最近的三天一直在折腾hexo框架的博客，先是使用yilia主题，但是用来一天觉得我不适合这个主题，随即看到了matery主题。前言今天又折腾了白天一天时间，我这个是直接克隆的hongweiの博客，这是一个大佬呀，还要多多向他学习。然后，只把一些简单的配置弄好了。现在梳理一下：已完成的配置：404页面简历建站时间设置个人域名（已购买域名，单还需要审核，明天再去弄。）不蒜子设置 添加评论插件 网站SEO优化 百度收录站点 1.验证网站所有权 谷歌收录站点 优化你的URL 添加代码块复制功能 添加文章更新时间功能非必要配置（已经取消）：添加网易云音乐BGM添加鼠标点击烟花爆炸效果添加页面樱花飘落效果添加鼠标点击文字特效添加页面雪花飘落动效优化网站加载速度数学公式渲染和代码高亮其他搜索引擎收录你的站点添加动漫人物增加emoji支持添加博客动态标签添加博客天气插件GitHub&amp;coding pages双部署修复Valine评论的头像不显示问题配置代码高亮由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 hexo-prism-plugin 的 Hexo 插件来做代码高亮，安装命令如下：1npm i -S hexo-prism-plugin然后，修改 Hexo 根目录下 _config.yml 文件中 highlight.enable 的值为 false，并新增 prism 插件相关的配置，主要配置如下：12345678highlight: enable: falseprism_plugin: mode: 'preprocess' # realtime/preprocess theme: 'tomorrow' line_number: false # default false custom_css:遇到的问题1、Cannot set property &#39;lastIndex&#39; of undefined运行hexo g出现Cannot set property ‘lastIndex’ of undefined解决方法：修改配置文件的 _config.yml，注意不是主题里面的配置文件，把 auto_detect 设置为false 即可。2、代码显示异常解决方法：首先，修改 Hexo 根目录下 _config.yml 文件中 highlight.enable 的值为 false。然后hexo clean&amp; hexo g&amp; hexo s好了。注：作者给的解决方案比我这个要多一步，我在这里贴出来，供大家参考。3、目录定位内容有偏差我反复的去测试，后来发现，可能有两个原因会导致这个问题的出现：网页没有刷新完全的时候，点击目录他有可能不会跳转。解决方法：法一：等待网页刷新完全。法二：手动的去停止网页的刷新（这个来的比较快一点，哈哈）你的文章的标题格式有问题，比如，我用Typora软件来写文章，这个软件就是所写即所得。但是这样你就不容易发现格式细节处的错误。错误示范：我先写了一个一级标题，然后，我又点击引用，就变成这样了：这种写法在Typora中，是不会认为它是一级标题的。我们打开源码查看他的格式：&gt; # 配置。他的格式是这样的。就是这里出错了，在matery主题中这样写它仍然会识别成标题，然后就导致从这个标题开始后面的标题，在你点击这些标题的时候，它会定位错误。解决方法：我们一定要遵循Markdown格式的语法，一定要，一定要。","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://longlongqin.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"matery主题配置","slug":"matery主题配置","permalink":"https://longlongqin.github.io/tags/matery%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"}]},{"title":"Tsinghua_Online_Judge_练习","slug":"Tsinghua-Online-Judge-练习","date":"2020-03-04T09:23:29.000Z","updated":"2020-04-13T10:24:02.448Z","comments":true,"path":"archives/d4fa.html","link":"","permalink":"https://longlongqin.github.io/archives/d4fa.html","excerpt":"","text":"CG2017 PA1-1 Convex Hull (凸包)题目Description (描述)After learning Chapter 1, you must have mastered the convex hull very well. Yes, convex hull is at the kernel of computational geometry and serves as a fundamental geometric structure. That’s why you are asked to implement such an algorithm as your first programming assignments.Specifically, given a set of points in the plane, please construct the convex hull and output an encoded description of all the extreme points.经过了第一章的学习，想必你对于凸包的认识已经非常深刻。是的，凸包是计算几何的核心问题，也是一种基础性的几何结构。因此你的第一项编程任务，就是来实现这样的一个算法。具体地，对于平面上的任意一组点，请构造出对应的凸包，并在经过编码转换之后输出所有极点的信息。Input (输入)The first line is an integer n &gt; 0, i.e., the total number of input points.The k-th of the following n lines gives the k-th point:pk = (xk, yk), k = 1, 2, …, nBoth xk and yk here are integers and they are delimited by a space.第一行是一个正整数首行为一个正整数n &gt; 0，即输入点的总数。随后n行中的第k行给出第k个点：pk = (xk, yk), k = 1, 2, …, n这里，xk与yk均为整数，且二者之间以空格分隔。Output (输出)Let { s1, s2, …, sh } be the indices of all the extreme points, h ≤ n. Output the following integer as your solution:( s1 * s2 * s3 * … * sh * h ) mod (n + 1)若 { s1, s2, …, sh } 为所有极点的编号, h ≤ n，则作为你的解答，请输出以下整数：( s1 * s2 * s3 * … * sh * h ) mod (n + 1)Sample Input (输入样例)12345678910111213141516171819202122231234567891011107 9-8 -1-3 -11 4-3 96 -47 56 6-6 100 8Sample Output (输出样例)12317 &#x2F;&#x2F; ( 9 x 2 x 6 x 7 x 1 x 5 ) % (10 + 1)Limitation (限制)3 ≤ n ≤ 10^5Each coordinate of the points is an integer from (-10^5, 10^5). There are no duplicated points. Each point is selected uniformly randomly in (-10^5, 10^5) x (-10^5, 10^5).All points on extreme edges are regarded as extreme points and hence should be included in your solution.Time Limit: 2 secSpace Limit: 512 MB3 ≤ n ≤ 10^5所有点的坐标均为范围(-10^5, 10^5)内的整数，且没有重合点。每个点在(-10^5, 10^5) x (-10^5, 10^5)范围内均匀随机选取极边上的所有点均被视作极点，故在输出时亦不得遗漏时间限制：2 sec空间限制：512 MBHint (提示)Use the CH algorithms presented in the lectures.课程中讲解过的凸包算法解答：Graham Scan算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;struct point &#123; long long x, y, id; point() :x(0), y(0) &#123;&#125; point(long long x, long long y) :x(x), y(y) &#123;&#125; bool operator ==(const point&amp; p) const &#123; return x == p.x &amp;&amp; y == p.y; &#125;&#125;PP; //PP: Polar Pointvector&lt;point&gt; points;long long area2(point p, point q, point s) &#123; /* |p.x p.y 1| |q.x q.y 1| == 2*DirectedTriangleArea(p,q,s) |s.x s.y 1| */ return p.x * q.y - s.x * q.y + q.x * s.y - q.x * p.y + s.x * p.y - p.x * s.y;&#125;bool toLeftTest(point p, point q, point s) &#123; //When return value large than 0, S is on the left side of ray PQ return area2(p, q, s) &gt; 0;&#125;bool toLeftTest2(point p, point q, point s) &#123; //When return value large than 0, S is on the left side of ray PQ return area2(p, q, s) &gt;= 0;&#125;bool cmp(const point&amp; p1, const point&amp; p2) &#123; // Sort according to polar angle return PP == p1 || !(PP == p2) &amp;&amp; toLeftTest(PP, p1, p2);&#125;point LTL(vector&lt;point&gt;&amp; points) &#123; //Lowest then leftmost point ltl = points[0]; for (int i = 1; i &lt; points.size(); i++) &#123; if (points[i].y &lt; ltl.y || points[i].y == ltl.y &amp;&amp; points[i].x &lt; ltl.x) ltl = points[i]; &#125; return ltl;&#125;vector&lt;point&gt; grahamScan() &#123; PP = LTL(points); sort(points.begin(), points.end(), cmp); vector&lt;point&gt; S, T; S.push_back(points[0]); S.push_back(points[1]); for (int i = points.size() - 1; i &gt; 1; i--)T.push_back(points[i]); while (!T.empty()) &#123; if (toLeftTest2(S[S.size() - 2], S[S.size() - 1], T[T.size() - 1])) &#123; S.push_back(T[T.size() - 1]); T.pop_back(); &#125; else S.pop_back(); &#125; return S;&#125;int main() &#123; ios::sync_with_stdio(false); long long n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; point tmp; cin &gt;&gt; tmp.x &gt;&gt; tmp.y; tmp.id = i; points.push_back(tmp); &#125; vector&lt;point&gt; result; if (points.size() &gt; 2)result = grahamScan(); else result = points; long long res = 1; for (int i = 0; i &lt; result.size(); i++) &#123; //cout &lt;&lt; result[i].id &lt;&lt; endl;//debug res = ((res % (n + 1)) * (result[i].id % (n + 1))) % (n + 1); &#125; res = ((res % (n + 1)) * (result.size() % (n + 1))) % (n + 1); cout &lt;&lt; res; system(\"pause\"); return 0;&#125;分数：92.5使用Graham Scan算法。凸包板子题。","categories":[{"name":"OJ","slug":"OJ","permalink":"https://longlongqin.github.io/categories/OJ/"}],"tags":[{"name":"OJ","slug":"OJ","permalink":"https://longlongqin.github.io/tags/OJ/"}]},{"title":"32、黑客&攻击","slug":"学习笔记/《计算机科学速成课》笔记/32、黑客&攻击","date":"2020-03-04T08:59:43.000Z","updated":"2020-04-01T02:29:03.700Z","comments":true,"path":"archives/622.html","link":"","permalink":"https://longlongqin.github.io/archives/622.html","excerpt":"黑客入侵最常见的方式不是通过技术，而是欺骗别人，这个称为社会工程学（Social Engineering），通过欺骗别人来让人泄露秘密，或让人配置电脑系统来变得易于攻击。最常见的攻击是网络钓鱼（Phishing），其次还有假托（Pretexting），攻击者给某个公司打电话，假装是IT部门的人，攻击者的第一通电话一般会叫人转接，这样另一个接的时候，电话看起来就像内部的，然后让别人把电脑配置得易于入侵，或者让他们泄露机密信息，比如密码或网络配置。","text":"黑客入侵最常见的方式不是通过技术，而是欺骗别人，这个称为社会工程学（Social Engineering），通过欺骗别人来让人泄露秘密，或让人配置电脑系统来变得易于攻击。最常见的攻击是网络钓鱼（Phishing），其次还有假托（Pretexting），攻击者给某个公司打电话，假装是IT部门的人，攻击者的第一通电话一般会叫人转接，这样另一个接的时候，电话看起来就像内部的，然后让别人把电脑配置得易于入侵，或者让他们泄露机密信息，比如密码或网络配置。邮件里带木马（trojan horse）也是常见手段，木马通常会伪装成无害的东西，比如照片或发票，但实际上是恶意软件，有的会偷数据，有的会加密文件。如果攻击者无法用木马或电话欺骗，攻击者只能被迫使用其他手段，方法之一就是暴力破解，尝试所有可能的密码，直到进入系统，大多数现代系统会加长等待时间来抵御这种攻击，每次失败就加长等待时间，甚至超过一定次数后，完全封锁。现在出现了一种攻破方法称为NAND镜像，如果能物理接触到电脑，可以往内存上接几根线，复制整个内存，然后暴力尝试密码，直到设备让你等待。这时只要把复制的内容覆盖掉内存，本质上重置了内存，就不用等待，可以继续尝试密码。如果无法物理接触到设备，就需要远程攻击，比如通过互联网，这一般需要攻击者利用系统漏洞，来获得某些能力或访问权限，称为漏洞利用（Exploit）。一种常见的漏洞利用叫缓冲区溢出（Buffer Overflow），这里的缓冲区是指预留的一块内存空间，比如我们在系统登录界面输入用户名和密码，而系统是用缓冲区来存储输入值的，假设缓冲区大小为10，并且缓冲区前后肯定还有其他数据，当用户输入用户名和密码时，这些值就会被复制到缓冲区中来进行验证，而该方法会溢出缓冲区，比如输入超过10个字符的密码，会覆盖掉相邻的数据，有时会让程序或系统崩溃，因为重要值被垃圾数据覆盖掉了。这里只是让系统崩溃，但是攻击者可以输入有意义的新值到程序的内存中，比如把is_admin标志位的值改为true，有了任意修改内存的能力，黑客就可以绕过登录这类东西，甚至使用那个程序劫持整个系统。有许多方法阻止缓冲区溢出，最简单的方法就是复制到内存之前先检查长度，称为边界检查（Bounds checking），许多现代编程语言都自带边界检查，程序也会随机存放变量在内存中的位置，这样黑客就不知道应该覆盖内存的哪部分，使得更容易让程序崩溃，而不是获得访问权限。程序也可以在缓冲区后，预留一些不用的空间，然后跟踪里面的值，看是否发生变化，来判断是否有攻击，这些不用的内存空间称为金丝雀（Canaries）。另一种经典手段是代码注入（Code Injection），最常用于攻击用数据库的网站。假设网页上有登录提示，当用户点击“登录”，输入文本就会发送服务器，服务器就会运行代码，检查用户名是否存在，如果存在就看密码是否匹配。为此服务器会执行一段sql查询代码，比如1SELECT password FROM users WHERE username='___';这里语句就是要从users表中查找username为___的密码password。 这里的___就是用户输入的用户名。由此攻击者就能把sql命令输入到用户名中，比如whatever&#39;;DROP TABLE users;&#39;，这时上面的查询语句就会变成1SELECT password FROM users WHERE username='whatever';DROP TABLE users;';如果服务器存在用户名wharever，数据库就会返回密码， 当然我们无法得知密码是什么，所以服务器会拒绝我们；如果不存在用户名wharever，服务器会返回空密码或者直接错误，服务器也会拒绝我们。 但是我们关心的是后面的代码DROP TABLE users;这个是我们注入的命令，这个命令是删掉users这张表。如今几乎所有服务器都会防御这种手段。程序员需要认识到从外界输入的信息都是危险的，必须要好好检查，很多用户名和密码表单，不会让你直接输入特殊符号，比如分号或括号，来作为第一道防御。好的服务器也会清理输入，比如修改或删除特殊字符，然后才放到数据库查询语句中。当软件制造者不知道的新漏洞被发现时，称为0day漏洞（Zero Day Vulnerability），黑客就会抢在白帽程序员做出补丁之前尽可能利用漏洞。如果有足够多的电脑有漏洞，让恶意程序可以自动地在电脑之间互相传播，称为蠕虫（Worm）。如果黑客拿下大量电脑，这些电脑可以组成僵尸网络（Botnet），可以用于很多目的，比如发大量垃圾邮件等，用别人电脑的计算能力来挖比特币，或发起DDOS来攻击服务器。DDOS就是僵尸网络里的所有电脑发一大堆垃圾信息到服务器上，造成服务器的阻塞。完~~~","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"《计算机科学速成课》","slug":"《计算机科学速成课》","permalink":"https://longlongqin.github.io/tags/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE%E3%80%8B/"}]},{"title":"Hexo 博客框架搭建","slug":"Hexo博客搭建/Hexo博客框架搭建","date":"2020-03-01T13:27:52.000Z","updated":"2020-03-17T08:12:17.477Z","comments":true,"path":"archives/7f7e.html","link":"","permalink":"https://longlongqin.github.io/archives/7f7e.html","excerpt":"搭建这个博客起因是2020年的二月末的某一天晚上，无聊逛B站，然后就看到了一个博客搭建教程，随机就有了这一系列的文章了。","text":"搭建这个博客起因是2020年的二月末的某一天晚上，无聊逛B站，然后就看到了一个博客搭建教程，随机就有了这一系列的文章了。前言我的是在windows操作系统上面，在其他的系统上面大同小异。也参考了很多文章及视频教程。主要参考的是：程序羊的视频：https://www.bilibili.com/video/av44544186?from=search&amp;seid=12981624311298276946文章：https://ouwen666.gitee.io/2020/01/29/Hexo+Gitee搭建个人博客作者部署的是giteehttps://godweiyang.com/2018/04/13/hexo-blog/#toc-heading-6含有个性化配置注：文中的指令都是在cmd（Windows中的命令提示符）中完成的。如果在这之前电脑上就已经安装了Git bash，那么也可以在Git bash中运行指令。下面会用得到的命令npm install=npm i。在git clone项目的时候，项目文件中并没有 node_modules文件夹，项目的依赖文件可能很大。直接执行，npm会根据package.json配置文件中的依赖配置下载安装。-global=-g，全局安装，安装后的包位于系统预设目录下--save=-S，安装的包将写入package.json里面的dependencies，dependencies：生产环境需要依赖的库开始配置安装Node.js博客框架Hexo是基于Node.js制作的静态博客，我们待会要用到Node.js里面的npm(node package manager)包管理器来安装插件。可以点击这里进入其官网。进入之后，按照操作系统进行下载安装。如上图是Windows系统64位的版本，上面官方推荐下载的版本。安装选项就按默认的，一直点击Next。然后，检验是否安装成功：用Win+R命令打开命令提示符，输入node -v 和npm -v ，出现版本号，则说明安装成功。添加cnpm注：因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，如果npm的服务器在中国就好了，所以我们乐于分享的淘宝团队干了这事。来自官网：“这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。”所以我们可以利用npm安装cnpm，再cmd中输入：1npm install cnpm -g –registry=https://registry.npm.taobao.org再输入：cnpm -v来检验是否安装成功。此时，假设我们Node.js安装成功。安装Hexo框架我们要利用Hexo框架模型来搭建我们的博客。点击这里可以进入其官网。下载该框架也仍然是在cmd（Windows中的“命令提示符”）中输入指令完成的。在上一步我们安装了cnpm，现在我们要用它来安装hexo，用cnpm安装的速度更快一些，也可以用npm：1cnpm install -g hexo-cli检验是否安装成功，当运行之后出现版本号则安装成功：1hexo -v现在，我们的Hexo框架已经安装成功了。初始化Hexo想要看到博客运行起来，我们现在还需要对Hexo框架进行初始化。在你的电脑上找一个合适的位置，创建一个文件夹，名字可以随便取，可以用Blog等等的名字，随个人喜好取名。为了便于演示，假设你取的名字叫做：blog注意，初始化是在我们创建的这个blog文件夹中初始化的，所以，我们的命令提示符（cmd）左边的路径要在这个blog文件夹中。进入刚刚创建的文件夹中然后，在输入指令 ：1hexo init初始化完成后，我们的blog文件夹中，就会生成这些文件：node_modules: 依赖包public：存放生成的页面scaffolds：生成文章的一些模板source：用来存放你的文章themes：主题_config.yml: 博客的配置文件在安装一些必要的包：1npm install初始化完成，在打开hexo服务器：123$ hexo sINFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.我们，打开浏览器，输入：localhost:4000，就可以看到你的博客的雏形已经好了。更换主题加入你觉得这个主题你不喜欢，想要找一个其他的主题，你可以进入Hexo的官网的主题板块，来选择你喜欢的主题：假如，你想更换为3-hexo，那就点击它，会跳转到该主题的创作者的GitHub上：安装3-hexo主题，其中命令的themes/3-hexo指的是该主题的安装位置：1git clone https://github.com/yelog/hexo-theme-3-hexo.git themes/3-hexo安装完之后，我们需要运行：123$ hexo clean # 清除所有记录 $ hexo generate # 生成静态网页 简写：hexo g$ hexo server # 启动服务 简写：hexo s然后，我们就能在本地localhost:4000中，查看修改好的主题了。安装Git如果你不想只在本地上查看你的博客，也想有自己的博客网址链接，那我们可以下载Git，把博客内容部署到GitHub或者gitee上面。我们这里以GitHub为例。Git的官网点击这里。然后按照你的电脑的操作系统下载相应的版本。安装选项还是全部默认，只不过最后一步添加路径时选择Use Git from the Windows Command Prompt，这样我们就可以直接在命令提示符里打开git了。安装完成后在命令提示符中输入git --version验证是否安装成功。GitHub账号如果你没有GitHub账号，我们现在去创建一个吧。点击这里创建。创建完成之后，我们新建一个github仓库：注意你的仓库名字不要随便起，待会我们要用到。加入你GitHub名字叫“AAA”，那么仓库个名字就一定是：AAA.github.io：部署博客将博客部署在github中目前，还不能部署到GitHub上。还需要下载hexo-deployer-git插件：1cnpm install hexo-deployer-git --save #通过cpnm安装git插件如果，你是刚刚才下载的Git，则还需要设置你的姓名和邮箱：12git config --global user.name \"Firstname Lastname\" // 名字使用英文输入git config --global user.email \"your_email@example.com\"还有你的SSH Key，创建公开密钥：1ssh-keygen -t rsa -C &quot;your_email@example.com&quot;​ 把生成的密钥添加到GitHub中去：找到生成的密钥：如果一切顺利的话，可以在用户主目录里找到.ssh目录，我的在：C:\\Users\\xxxx\\.ssh（xxxx是我的一个目录）。里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便，把公钥复制进去。到这里，我们的git与远程的GitHub已经建立起关系了。我们还需要把blog文件夹中的设置文件，即：_config.yml，将最后一行进行修改,：1234deploy: type: git repository: https://github.com/longlongqin/longlongqin.github.io.git branch: master​ repository修改为你自己的github项目地址，在实际操作过程中，repository: git@github.com:longlongqin/longlongqin.github.io.git,也是可以的。修改之后，我们才能部署到GitHub上：12$ hexo deployer## 初次使用这个命令，需要输入github的用户名username和密码password​ 这里，就是利用刚下载的插件：hexo-deployer-git现在我们可以访问我们在github服务器上的博客网址，网址就是我们刚刚创建仓库的名字，比如我的仓库名是：longlongqin.github.io，我们复制粘贴它到浏览器，然后你就可以看到你的博客内容了。😊Git提交到多个仓库https://yuxiang.ren/2017/08/25/hexo%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%88%B0%E5%A4%9A%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/部署在gitee部署在gitee上的坑在gitee上面，和在GitHub上面部署差不多，但是有些地方我们还是要注意的。仓库命名问题在创建gitee仓库时，最好也是将仓库名字命名为你的账号的用户名，比如我的：​ 当然，你也可以命名为其他名字，但是换成其他名字之后，可能会带来一系列其他的问题，比如图片无法显示。其实我之前命名成其他名字，就出现了很大的问题：这种情况是因为，他找不到资源，加载错误：熬了一个晚上，终于发现了。在官方文档中有：网站在子目录的情况如果你的网站在一个子目录（例如http://example.org/blog） 设置url为http://example.org/blog并且设置root为/blog/说来也奇怪，在GitHub上面，和本地运行的时候都是好好的。就是在gitee上面出错了。o(︶︿︶)o 唉解决它的办法就是：​ 将root添加上缺少的那一级目录，即可1234567891011121314151617# URL## If your site is put in a subdirectory, set url as'http://yoursite.com/child' and root as '/child/'url: http://yoursite.com/childroot: /blog/permalink: :year/:month/:day/:post_title/permalink_defaults:pretty_urls: trailing_index: false # Set to false to remove trailing 'index.html' from permalinks trailing_html: true # Set to false to remove trailing '.html' from permalinks这一篇帖子里面也有人遇到了同样的问题，最后也是通过root的修改解决的。：https://gitee.com/oschina/git-osc/issues/IFVWV?from=project-issuegitee pages刷新除了仓库名字需要注意，我们还需要注意，gitee个人版似乎不能自动刷新，所以你每次hexo d之后，需要手动的刷新gitee pages，才能显示你新提交的内容。写文章编辑器推荐推荐使用Typora这款软件，点击这里进入官网，他可以写Markdown格式的内容，这个软件的方便之处在于直接将markdown语法呈现出其效果，并且已经集成了很多方便的功能，你无需记住插入代码的语法格式，无需记住插入图片的语法格式，这使得我可以专心写博客而无法关心学习markdown语法。有很多md编辑器，他们分成两个界面，一个界面是md源代码，另外一个界面实时更新显示其效果，而Typora是浑然一体的，真正所见即所得，就跟在使用word一样方便。不仅如此，它还可以导出PDF、Word、HTML、图片等格式。待续……图片问题http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/Hexo的操作指令我们刚开始，对于Hexo的指令不太熟悉，我们可以在他的官网上去查找相应的操作指令。文章的front-matterFront-matter 选项详解Front-matter 选项中的所有内容均为非必填的。但我仍然建议至少填写 title 和 date的值。配置选项默认值描述titleMarkdown 的文档标题文章标题，强烈建议填写此选项date文档创建时的日期时间发布时间，强烈建议填写此选项，且最好保证全局唯一author根 _config.yml中的 author文章作者imgfeatureImages中的某个值文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: http://xxx.com/xxx.jpgtoptrue（文章是否置顶），如果 top 值为 true，则会作为首页password无文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项toctrue是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项mathjaxfalse是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文档中也需要开启才行summary无文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则进程会自动截取文章的部分内容作为摘要categories无文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类tags无文章标签，一篇文章可以多个标签Front-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量，举例来说：1234---title: Hello Worlddate: 2013/7/13 20:46:25---分类和标签只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。12345categories:- Diarytags:- PS3- Games分类方法的分歧如果您有过使用 WordPress 的经验，就很容易误解 Hexo 的分类方式。WordPress 支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是 Hexo 不支持指定多个同级分类。下面的指定方法：123categories: - Diary - Life会使分类Life成为Diary的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。1234categories:- [Diary, PlayStation]- [Diary, Games]- [Life]此时这篇文章同时包括三个分类： PlayStation 和 Games 分别都是父分类 Diary 的子分类，同时 Life 是一个没有子分类的分类。JSON Front-matter除了 YAML 外，你也可以使用 JSON 来编写 Front-matter，只要将 --- 代换成 ;;; 即可。123&quot;title&quot;: &quot;Hello World&quot;,&quot;date&quot;: &quot;2013&#x2F;7&#x2F;13 20:46:25&quot;;;;配置过程遇到的问题Hexo博客中文章图片不显示的坑这个是真的坑，搞了好久，终于看到一篇博文，才解决了这个问题。放一下这篇文章的传送门。在coding中SSL证书申请失败的坑在搭建到coding中步骤其实和在github中比较相似，就是给仓库命名原则的时候需要注意，尽量让仓库名字与你的用户名相同，即和在github中命名规则相似。如果你之前都很顺利，那么在SSL证书申请时，需要注意了：你会遇到证书申请一直失败的情况。这是为什么呢？是这样的：第一次尝试，查资料说是如果之前你已经在github oages上部署了，你自己买的域名也已经解析过了。此时直接在coding pages中申请ssl的话，会失败。解决的办法就是：先把用于解析github pages的那两条暂停了，如下图所示：然后，我再试试，还是申请失败。出现类似于下面的错误：继续去查。嗯，找到了，申请失败是因为我的域名在国外无法解析，这是我的DNS设置导致的。解决办法：在解析的时候，需要将线路类型改成默认。去试一试，等待一小会哇，终于申请成功了。#Hexo博客备份有时候我们外出，自己的电脑没有带，这时候想写博客怎么办。这也是有办法的，就是我们要先备份我们的博客。这里我们可以备份到github或者gitee.拿github举例：首先，我们先要在GitHub上面建立一个仓库，仓库名字自取，仓库是public还是private，按照自己的心情来就好了。然后，我们要在本地关联远程仓库：我们进入你的本地博客所在的目录，比如我的在D:\\Blog，然后，打开你的Git bash，按顺序输入以下命令：12git init #初始化本地仓库git remote add origin &lt;你的远程仓库的SSH或HTTPS链接&gt; #关联远程仓库（ssh的链接比较快一点）关联完成，然后我们还需要，将本地的推送到远端，同样，按顺序输入一下命令：123git add . #这个‘.’表示将整个文件夹都一起添加到暂存区（不然还要一个个输入文件名）git commit -m \"输入你这次提交的说明\" git push origin master #推送到远程仓库好了，记得按时将本地的备份到远程仓库。至此，本地备份已经完成。如果你想同时备份到gitee和github上面，你可以参考这里。在另外一台电脑上写博客前提是我们把博客备份在github、gitee等上面。然后在新电脑上面：安装 Git、nodejs把你远程的博客备份，clone下来到一个指定的位置（位置自己定）在本地的博客仓库运行：npm install，来 安装依赖包好了，你可开始写博客了。优化技巧优化文章URLseo搜索引擎优化认为，网站的最佳结构是用户从首页点击三次就可以到达任何一个页面，但是我们使用hexo编译的站点打开文章的url是：sitename/year/mounth/day/title四层的结构，这样的url结构很不利于seo，爬虫就会经常爬不到我们的文章，于是，我们需要优化一下网站文章url方案一：我们可以将url直接改成sitename/title的形式，并且title最好是用英文，在根目录的配置文件下修改permalink如下：1234url: https://sunhwee.comroot: /permalink: :title.htmlpermalink_defaults:方案二：使用插件优化url插件hexo-abbrlink实现了这个功能，它将原来的URL地址重新进行了进制转换和再编码。安装hexo-abbrlink。1npm install hexo-abbrlink --save配置博客根目录下的_config.yml文件。12345# permalink: :title/permalink: archives/:abbrlink.htmlabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex运行hexo clean和hexo g命令来重新生成文件看看，可以清楚的看到，URL结构成功变为了3层。来源: 洪卫の博客作者: 洪卫文章链接: https://sunhwee.com/posts/6e8839eb.html#toc-heading-59本文章著作权归作者所有，任何形式的转载都请注明出处。其他参考文章列表：http://dongshuyan.com/2019/05/24/hexo%E5%8D%9A%E5%AE%A2%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/#14-Hexo添加百度统计网络编程系列 Hexo + Github搭建个人博客 · 花田半亩","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://longlongqin.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Hexo主题","slug":"Hexo主题","permalink":"https://longlongqin.github.io/tags/Hexo%E4%B8%BB%E9%A2%98/"}]}]}