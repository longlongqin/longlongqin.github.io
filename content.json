{"meta":{"title":"龙龙‘S BLOG","subtitle":"","description":"","author":"longlongqin","url":"https://www.longlongqin.top","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-03-16T18:44:23.649Z","updated":"2020-03-16T18:44:23.649Z","comments":true,"path":"404.html","permalink":"https://www.longlongqin.top/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-03-17T07:38:49.496Z","updated":"2020-03-17T07:38:49.496Z","comments":true,"path":"about/index.html","permalink":"https://www.longlongqin.top/about/index.html","excerpt":"","text":"路漫漫其修远兮，吾将上下而求索一个本科生化环材的跨考生，现专业软件工程。本博客主要记录自己的学习之路。现阶段学习内容：编译原理Let’s Build A Simple Interpreter计算几何邓俊辉老师的学堂在线课程C/C++基础学习：https://www.learncpp.com/"},{"title":"留言板","date":"2020-03-16T13:21:42.591Z","updated":"2020-03-15T14:08:19.000Z","comments":true,"path":"comment/index.html","permalink":"https://www.longlongqin.top/comment/index.html","excerpt":"","text":"欢迎前来灌水。。。"},{"title":"所有分类","date":"2020-03-16T13:58:21.496Z","updated":"2020-03-15T14:08:19.000Z","comments":true,"path":"categories/index.html","permalink":"https://www.longlongqin.top/categories/index.html","excerpt":"","text":""},{"title":"Friends","date":"2020-03-17T13:21:19.908Z","updated":"2020-03-17T13:21:19.908Z","comments":true,"path":"friends/index.html","permalink":"https://www.longlongqin.top/friends/index.html","excerpt":"","text":"欢迎和我交换友链~各位大佬想交换友链的话可以在下方留言，必须要提供名称、头像和链接哦~请先将本站添加到你滴友链中喔，谢谢~友链提交模板：12345- name: 龙龙‘S Blog avatar: https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg url: https://xaoxuu.com backgroundColor: '#FFA500' textColor: '#624739'背景、字体颜色按自己风格设置呀！"},{"title":"Projects","date":"2020-03-16T13:21:42.616Z","updated":"2020-03-15T14:08:19.000Z","comments":true,"path":"projects/index.html","permalink":"https://www.longlongqin.top/projects/index.html","excerpt":"","text":""},{"title":"My bookshelf","date":"2020-03-16T17:14:04.490Z","updated":"2020-03-15T14:08:19.000Z","comments":true,"path":"mybook/index.html","permalink":"https://www.longlongqin.top/mybook/index.html","excerpt":"","text":""},{"title":"","date":"2020-03-17T08:10:02.011Z","updated":"2020-03-17T08:10:02.011Z","comments":true,"path":"学习笔记/index.html","permalink":"https://www.longlongqin.top/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html","excerpt":"","text":"学习笔记编译原理Let’s Build A Simple Interpreterpart1、part2、part3、part4、part5、part6、part7、part8、part9计算几何学堂在线课程-邓俊辉老师凸包：Convex-Hull-凸包、Divide-And-Conquererer、Jarvis-March、Lower-Bound、Graham Scan计算机科学速成课2 电子计算机、3 布尔逻辑和逻辑门、32 黑客&amp;攻击"},{"title":"所有标签","date":"2020-03-16T13:21:42.616Z","updated":"2020-03-15T14:08:19.000Z","comments":true,"path":"tags/index.html","permalink":"https://www.longlongqin.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Front-matter的规则","slug":"Hexo博客搭建/Front-matter的规则","date":"2020-03-16T14:08:32.497Z","updated":"2020-03-17T08:15:54.491Z","comments":true,"path":"archives/138a.html","link":"","permalink":"https://www.longlongqin.top/archives/138a.html","excerpt":"文章写作时，的front matter 的参数","text":"文章写作时，的front matter 的参数参数描述layout布局title标题date建立日期updated更新日期comments开启文章的评论功能tags标签（不适用于分页）categories分类（不适用于分页）permalink覆盖文章网址其中，分类和标签需要区别一下，分类具有顺序性和层次性，也就是说Foo，Bar不等于Bar，Foo；而标签没有顺序和层次。注意：每个冒号后面是有一个空格的。1234567891011121314151617title: 文章的front-matter规则 // 你的博客名字 date: 2019-08-10 21:44:44 //文章创建的日期author: longlongqin //作者名字img: /medias/banner/6.jpg //文章的显示的时候的背景coverImg: /medias/banner/6.jpg top: truecover: truetoc: truepassword: mathjax: truesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要tags:- Hexo- Github- 博客categories:- 软件安装与配置配置选项默认值描述titleMarkdown 的文件标题文章标题，强烈建议填写此选项date文件创建时的日期时间发布时间，强烈建议填写此选项，且最好保证全局唯一author根 _config.yml中的 author文章作者imgfeatureImages中的某个值文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: http://xxx.com/xxx.jpgtoptrue推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章coverfalsev1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中coverImg无v1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片password无文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项toctrue是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项mathjaxfalse是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行summary无文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories无文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类tags无文章标签，一篇文章可以多个标签reprintPolicycc_by文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个注意:如果 img 属性不填写的话，文章特色图会根据文章标题的 hashcode 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。date 的值尽量保证每篇文章是唯一的，因为本主题中 Gitalk 和 Gitment 识别 id 是通过 date 的值来作为唯一标识的。如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 _config.yml 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：开源中国在线工具、chahuo、站长工具。","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.longlongqin.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"front-matter配置","slug":"front-matter配置","permalink":"https://www.longlongqin.top/tags/front-matter%E9%85%8D%E7%BD%AE/"}]},{"title":"构造凸包——Divide And Conquer","slug":"学习笔记/计算几何/Convex-Hull/Divide-And-Conquererer","date":"2020-03-15T08:12:57.000Z","updated":"2020-03-17T08:43:00.307Z","comments":true,"path":"archives/f32f.html","link":"","permalink":"https://www.longlongqin.top/archives/f32f.html","excerpt":"Graham Scan算法说明了凸包构造问题的下界O(nlogn)是可以达到的。其实O(nlogn)的算法远不止这一种，分治法就是一种能达到O(nlogn)复杂度的思想。在此引入运用分治思想的两种算法来构造凸包。","text":"Graham Scan算法说明了凸包构造问题的下界O(nlogn)是可以达到的。其实O(nlogn)的算法远不止这一种，分治法就是一种能达到O(nlogn)复杂度的思想。在此引入运用分治思想的两种算法来构造凸包。归并排序与分治思想引入新算法之前依旧先来回顾一个经典排序算法：归并排序（merge sort）。归并排序的基本流程如下：算法分为两个阶段：分（divide）和归并（merge）。分的阶段将待排序列均分到一个个子序列（如图中划分到单个元素）。归并阶段将分好的子序列两两合并成有序序列，重复合并的过程直到整体归为一个序列。归并过程共logn步，每步耗费n的时间，总体复杂度为O(nlogn)。归并排序的过程就是一个典型的分治（divide-and-conquer）策略。凸包构造问题也可以套用这种策略来分而治之，逐步求解。我们可以将待处理点集S分为同等规模的两个子点集，并分别对其求凸包。有了两个子解后，问题就变成了如何适当加一些边，将两个子凸包merge成整体解。分治法核心的任务就是如何merge。Divide And Conquer（1）预处理为star-shaped polygon分治法解决问题的过程可以概括为：大事化小，小事化了。就是首先将问题划分为易求解的子问题，子问题套用已知方法解答即可。例如子凸包的构造就能用Graham Scan来解决。Graham Scan解决问题的前提是：参照基准点，其他点按极角有序排列，也就是构成了一个有序的星形多边形（star-shaped polygon）。首先要做的就是将两个子凸包预处理成两个star-shaped polygon。star-shaped polygon星形多边形是什么呢？其实就是在多边形内部存在一个点A，这个点与多边形内任意一点的连线都在多边形内部，就叫做星形多边形，这一个点A就叫做多边形的内核。由于任何一个凸多边形都是star-shaped polygon，它必然有一个核，其他点按极角有序排列。问题在于如何找到一个公共核，使得两个子凸包同时关于这个核是极角有序排列的。也就是公共核处于两个凸包的交部分，这样是最好处理的情况（如下左图）。不过还有可能有其他情况，不能找到公共核（如下中图），甚至两个凸包根本不相交（如下右图）：这就要将分治策略分不同情况来实现：两个子凸包有公共核：先找其中一个子凸包的核：我们可以任取该子凸包上的三点构成三角形，求三角形重心作为核。然后判断这个核是否也在另一个子凸包内部，若判定为真，就是有公共核的最简单情况。判定方法也就是之前提过的in convex polygon test，对凸包每条边做to left test即可，在线性时间内可以判定。找到公共核之后，进行凸包形成：—-用二路归并相对于公共核，两个子凸包的各自有序排列，相互交错。要做的就是将二者点序列合并，方法正是经典的二路归并，线性时间可以完成。最后进行Graham Scan即可得到大凸包。一个子凸包的核落在另一个子凸包外部：存在公共核的情况处理是很简单的，再看第一个子凸包的核落在第二个子凸包外部的情况。如下图所示：这中情况与增量构造法的情况很相似，P1的核x相对于P2就是一个新加入的点。做出两条support line：x→t和x→s，舍弃P2上t→s路径的点即可。这样P2中剩余点与x构成了一个星形多边形，x也成为了P2的核。这就转化成了第一种有公共核的情况。Divide And Conquer（2）上述分治策略的算法过于复杂，所以引入一种更加简明的分治策略。这种分治策略也会为三角剖分等问题提供思路。首先规定一种点集划分的策略。假设待合并的两个子凸包是沿着某方向是分离的，二者不相交（Divide And Conquer（1）中是有相交的）。例如下图凸包P1和P2就是相互分离的：这样划分会使得合并更加简明，不必区分多种复杂情况。预处理为了满足这种划分策略，需要引入一种预处理，也就是一个x方向的排序过程（X-sorting）。排序后就可取点x坐标的中值，将点集划分为规模相当的左右两个子集。每个凸包都有其最左点l和最右点r，如上图。merge操作现在merge操作就是将两个左右相离的两个子凸包合并为一个大凸包的过程了。运算的关注的正是两对l和r点。先直观感受一下merge操作要添加的新极边：上下两条紫色边正是要求的新边，又称支撑边（support line），并且每次merge只会增加两条新边。两条边类似两个圆的公切线（common tangent），将二者连接起来。注意，注意，注意：眼睛可能会欺骗你直观上感觉，两条support line正是两个子凸包的最高点t和最低点b相互连接得到的，这些点只需线性时间就能找到。当真如此的话凸包构造的下界就成了O(n)，显然直觉是错误的。例如下面的两种情况，support line就和b、t两点没有直接关系了：)构造support line的过程需要缜密的分析，并非凭直觉能得到的。缝合（stitch）—构造support line将两个子凸包连接的过程更像古代妇女用针将两块布缝合在一起（但是这里的两个凸包的间距是不能变的，仅仅是用线将其连接在一起。而且这里连接只需要最后找出来的那两条线，其余剩下的中间“工具线”都要舍去）。构造过程首先从左凸包的r点和右凸包的l点连线开始，以这条线为基础逐步得到support line。注意一个细节问题：如何得到各子凸包的l点和r点。每次合并都会产生新的凸包，所以凸包是一个动态的结构。当然可以每次计算出最左点和最右点，只需要线性时间。但是这并不是最优的方式。考虑分治的思想，就整个merge流程来讲，是自底向上将子凸包两两合并的过程。因此只要在最底层上最小的子凸包中记录最左点和最右点，每次merge更新一下这两个变量即可，只需要O(1)的常数时间！这种优化对整体的复杂度上线nlogn虽然没有影响，也能为程序节省一部分的开销。缝合上半部分再看如何将最初的r-l线变成support line，在此以寻找upper support line为例（上切线，相应的还需要计算下切线）。算法的核心依然是to left test。首先看l点，从r-l线出发，可以发现相对于对于r→l时，l的前驱、后继是LR型的。而我们想要的是RR型的。所以必须要找l的前驱。直到在某一个时刻，我们找到了l的一个前驱点满足RR型：再看r点，同样的，从此时的状态，来观察r的类型：是RL型的。要想成为LL型，r必须要找它的后驱。在某一时刻，r找到r的后继（就是该凸包点t）使其满足LL型：反过来继续看l，此时，具体的说应该是检测l的前驱点l&#39;，经检测，l&#39;已经不再满足RR型了，编程了LR型，所以还要继续寻找它的前驱点，使其再次满足RR型。某一时刻，找到它的前驱（就是该凸包的点t），使其成为RR型。反过来继续看r，此时，更准确的应该说是在看r&#39;，经检测，该店符合LL型。至此，所谓的r和l都已经符合RR或LL型了。从而已经找到upper support line了。结束上半部分。回顾由r-l线逐步推进得到support line的过程，每次操作一个端点，得到是一种“Z”字形（zig-zag）的推进轨迹。操作点的切换由另一点满足要求决定，而算法停止的依据是两个端点同时满足了要求。这种方式类似快速排序构造轴点的过程，左右两轴点交替操作，直到二者都满足要求时算法停止。缝合下半部分缝合下半部分的流程与，上半部分流程一样。时间复杂度分析一下算法时间复杂度。算法首先要按照x坐标排序，排序复杂度为O(nlogn)。再看merge过程，无论是左侧子凸包还是右侧子凸包，对于其每个点的操作至多只有以此，也就是每次归并是线性时间。归并共logn次，算法的总体复杂度就是O(nlogn)了。更多的考虑在这些算法讲解中，通常都是不考虑退化的情况，如，三点共线……最后总结一下第二种分治法的特点。此前Jarvis March算法虽然以平方复杂度为上界，但其”输出敏感性“使得实际复杂度为O(hn)，最好情况下仅甚至为线性。例如如下情况：Jarvis March算法的复杂度变为了O(4n)，而此时分治法依旧会经历按部就班的X-sorting，一上来就注定了O(nlogn)的复杂度，然后经历同样O(nlogn)的merge过程。也就是说这种分治法在各种情况下的表现都是很均匀的。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"计算几何","slug":"计算几何","permalink":"https://www.longlongqin.top/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"}]},{"title":"构造凸包-Graham Scan法","slug":"学习笔记/计算几何/Convex-Hull/Graham-Scan","date":"2020-03-14T09:40:32.000Z","updated":"2020-03-17T08:30:42.401Z","comments":true,"path":"archives/3478.html","link":"","permalink":"https://www.longlongqin.top/archives/3478.html","excerpt":"上文简要分析出了凸包构造问题算法的下届：O(nlog n)，在此就引入一种下界意义上最优的算法：Graham Scan算法。这种算法可以保证在最坏的情况下时间复杂度也不超过 nlogn。","text":"上文简要分析出了凸包构造问题算法的下届：O(nlog n)，在此就引入一种下界意义上最优的算法：Graham Scan算法。这种算法可以保证在最坏的情况下时间复杂度也不超过 nlogn。Graham Scan算法的流程假设待处理点集S共有n个点。1、预处理预排序(presorting）Graham Scan首先要做的是一个预处理排序操作（presorting）。即找到某个基准点，然后将其余所有的点按照相对于基准点的极坐标排序。如下图：点的排序可以套用任意排序算法的框架，只是将排序对象由数值变为了平面上的点，而比较器改为to left test实现。如何找出第一个点：点1？以点1为基准点，其余点按照相当于点1的极角依次排序为2、3、4……理论上讲任何一个点都能当第一个基准点，为了简化算法通常选择lowest-then-leftmost point（LTL）作为基准点。找出起始边对于与基准点1极角最小的点，也就是图中点2（假设没有三点共线的情况）。将点1和点2作为算法的起始点。将起始边 与 剩下的n-2条边分别存储在不同的栈(stack)中：算法开始前先将起始点1和2入栈S，其他的n-2个点入栈T，如上图。注意S和T中元素的入栈顺序。至此预处理已经完成。Graham Scan用到的数据结构。整个算法非常简明，核心数据结构只有两个栈，分别记作栈S和栈T。便于理解我们将S和T画成开口相对的形式，如上图。2、scan操作(此处为逆时针扫描)完成预处理之后，就能开始算法的核心：scan操作。scan的过程中要时刻关注三个点：栈S的栈顶（S[0]）、次栈顶（S[1]）和栈T的栈顶（T[0]）。也就下图红色标注的三个点：对这三个关注的点，进行检测，检测的框架为：可以观察到，每次待处理的S[0]和S[1]构成的边一定是一条极边（如上图点1和点2），算法关键步骤就是对边这条极边和T[0]做to left test，判断T[0]位于边S[0]S[1]的左边还是右边。若在左边则继续拓展，若在右边则否定掉此前认定的极边。无论结果如何，每次判定都会将问题规模缩小一个单元，算法结束时T最终肯定为空。T空后，S中存留下的点正是凸包的极点，这些点自底而上正是凸包边界点的逆时针遍历，也得到了整个凸包构造问题的解。举例1、先来看一个最简单的例子，即点集S中所有的点都在凸包边界上。如下图：先找到LTL，也就是图中点1。然后基于点1对其余点按极角排序为点2、3、4……（实际上以一个点为中心的有序的点集，构成了所谓的星形多边形（star-shaped polygon），中心点正是星形多边形核（kernel）的一部分。凸多边形必然是星形多边形，反之则不然。）然后找到点1的后继2，点1和点2构成第一条极边。初始化栈S和栈T。现在要关心S[1], S[0]和T[0]，就是点1，2和3。点3位于边12左侧，to left关系为true，S.push ( T.pop() )，向前拓展了一条暂定极边。接下来重复上述过程。考虑点2，3和4。to left关系为true，S.push( T.pop() )……最终栈T空，算法结束，凸包由栈S自底向上得到。S和T的变化过程如下图：2、上面列举了最简单的情况下Graham Scan的过程，接下来列举一个更有代表性的实例深入算法的细节。输入的点集S，并进行预处理排序，并初始化栈S、T，如下图：接下来对点1，2和3进行to left测试，本质上就是判断边2→3（图中黄色边）能否被暂时采纳。测试结果为true，暂时采纳边2→3，S.push( T.pop() )。如下图所示：注意图中蓝色边表示已经被暂时接纳的边，也就是算法暂时认定的极边。上一次操作将蓝色边推进一个单元接下来关注点2，3和4，来判断下一条黄色边3→4能否被接纳。to left测试为true，S.push( T.pop() )，接纳边3→4。如下图右侧所示：然后判断点3，4和5。点5在边3→4的右侧，即to left测试为false。S.pop()，也就是判断出点4不可能为极点，丢弃4。因此算法回溯到点3，判断点2，3和5的关系。5在2→3的左侧，暂时接纳边3→5，S.push( T.pop() )。如下图：算法经历了无效操作，进行了回溯，得到了目前来说最优的“极边”。虽然这些”极边“不一定能最终保留，但问题的规模得到了削减。下一次scan考察的就是3，5和6了。3，5和6的to left测试为false，S.pop()，舍弃点5。然后考察点2，3和6，to left测试为false，S.pop()舍弃点3。如下图：……..………直遍历完剩下其他点，凸包就构造完成。验证算法的正确性思路上的正确性了解了算法的整体流程之后，我们再来论证一下算法的正确性。证明一个算法正确性的方法有很多，在此选用数学归纳法。数学归纳法的思想可用多米诺骨牌类比，要做的无非是两件事：证明第1张骨牌会倒；证明如果第n张骨牌会倒则第n+1张骨牌也会倒下。Graham Scan过程就是一个个引入点的过程。每当我们得到第k个点的时候，算法所得到的就是前k个点对应的“最好的凸包”。因此当k = n时得到的是整体的凸包。归纳的第一步就是证明k = 3时得到的是当前点集S‘ = {1，2，3}中的极边——也就是证明第1张骨牌会倒。显然边1→2是S’的一条极边。而根据预处理的方式，3相较于1的极角一定大于2，因此点3一定在边1→2的左侧，因此边2→3会得到保留。对于这三个点来说，任意两条边一定都是极边，2→3也是一条极边。然后证明：假设已经处理到第k个点，得到的是前点集S’ = {1，2，3，…，k}中所谓“最好的凸包”。根据算法处理方式，接下来从S’’ = {1，2，3，…，k，k+1}得到的结果是否也是正确的——也就是证明第n张骨牌会倒，则第n+1张骨牌也会倒下。预处理的方式是对2~n所有点相较于点1按极角排序，因此下一个要处理点k+1一定出现在线1→k的左侧，也就是下图蓝色区域和绿色区域（假设k = 9）：而根据目前接纳的最后一条极边( k-1)→k （例如图中8→9）来划分，点k+1可能出现的区域又分为两块，即该极边的左侧（绿色区域）和右侧（蓝色区域）。这也正对应于算法判定的两个分支。左侧：左侧的情况很简单，点k+1显然会是一个新的极点。Graham Scan要做的正是暂时接纳边k→k+1，拓展了一个新的单位。右侧：再看k+1落在右侧的情况。如下图点10：Graham Scan要做的是丢弃点k（图中点9），也就是判定出点k不可能是极点。这样做的原因：是引入点k+1后，点k一定会被包含在三角形(1, k-1, k+1)内部。如图中点9一定包含于三角形(1, 8, 10)内部。正如极点法中排除非极点的做法，点k被排除是正确的做法。接下来点k-1，k-2等（如图中点8，点7等）也可能是非极点，按照算法的流程，它们总会被判定在某个三角形的内部（例如点7在三角形(1, 5, 10)内部）而被排除，直到left test为true，回溯停止。换个角度考虑，回溯停止时得到的新边正是增量构造法中每步得到的support line，即切线。例如图中线5→10正是算法当前保留的”凸包“的切线。这也能论证Graham Scan处理方式的正确性。至此，算法思路上的正确性已经证明完毕。表述方式的正确性接下来还要考虑算法的表述方式是否有漏洞：代码中每次to left test之前并没有判断S栈中是否有≥2个元素。这也可以由预处理的方式来论证。点1选取的是LTL，而点2是相对于点1极角最小的点，这样的做法保证了除了点1和点2之外所有的点一定是在边1→2左侧的。因此算法回溯最多到点2，永远不可能把点2丢弃，S中元素任何时候至少有两个。Graham Scan算法的正确性论证完毕。预处理操作的必要性最后来思考一下预处理操作：presorting。仔细回顾上述论证过程会发现，每一步的正确性都是建立在最初的排序上的。那么这个预处理排序真的是必要的吗？可以来举极端的反例，每次选取下一个点都是随机的，例如下图的路径：上图中从点1开始出发进行to left测试，可以发现，每次判定结果都为true，最终所有的点都被保留了下了，而显然这并不是一个凸包。因此presorting是整个算法成立的基础。分析复杂度上面证明了Graham Scan算法的正确性，接下来分析其复杂度是否满足O(nlogn)，实现所谓的最优算法。直观上无法断定Graham Scan是一个最优的算法，尤其是以下极端情况令人质疑其效率：Graham Scan算法复杂度由三部分决定：persorting，采用一般排序算法，复杂度是O(nlogn)逐步迭代，O(n)：算法一步步纳入新点，会迭代n步。scan，O(?)所以算法的总体复杂度：O(nlogn + n * ?) ，可见scan的复杂度决定了算法总体的复杂度。算法一步步纳入新点，会迭代n步。但是在每个点上都有可能做回溯操作，所以scan的复杂度是不确定的。我们来以上图最坏情况为例，到第8个点时判定为false，舍弃点7，回溯。下一步判断也为false，舍弃点6，回溯。如此回溯直到算法开始的点2。这次scan倒退了高达O(n)个点，如果每次scan都是如此那么算法整体复杂度就为：O(nlogn + n * n) = O(n^2)了，那这种算法的意义也就不大了。其实上述分析并非错误，只是不够精确。O(n^2)确实是Graham Scan算法的一个上界，但是这个上界并不是紧的。问题就出在分析假定了每次都会出现回退高达O(n)个点。下图展示了整个Graham Scan的流程：图中黄色边是没有采纳的，就是to left测试判定为false后直接舍去的。紫色边则是曾经被认为是极边而接纳的，后来经过回溯又舍去了。无论是黄边还是紫边，在其上耗费的都是常数时间，关键就在于黄色边和紫色边的数目了。通过观察可以发现，从图论的角度看，所有的黄色边和紫色边连在一起构成了一张平面图，也就是它们互相是不可能内部相交的。平面图的一个重要性质：平面图中所有边的数目和顶点数目保持同阶这个性质来自欧拉公式：有n个点的平面图，边的数目上限是3n，也就是O(3n)。回溯（backtrack）可能会倒退的边数：在0~n之间。【但是注意，不是每次回溯都能回退到n，因为由上面可知，点集边数最多为3n，而这里面的每一个边，会被回退0次（极边），或者1次（非极边）。所以，某条边一旦被回退过，之后就不可能再被回退了】根据这个性质，在persorting之后的整个流程中，Graham Scan所能走过的所有边不仅不会到达n^2，而顶多到达和n同阶的一个线性数目。因此整个算法的复杂度也就取决于persorting的O(nlogn)了。算法推广Graham Scan算法不仅可以用于凸包构造问题，在其他许多场景下中也十分有效。为了推广Graham Scan算法，首先可以对其做简化，以方便利用在其他问题。首先再来回顾一下预处理排序，这是算法成立必不可少的一步。排序算法套用成熟的方法即可，利用数学方法计算偏角不仅复杂而且引入了误差，所以要采用to left test。要做的就是两点：套用成熟的排序算法，将待排序元素由数值变为点将排序算法的比较器改为to left test实现按照这样的流程就能间接地实现persorting。1、原始点集已经有某种次序有时候我们并不是从零开始构造凸包，例如得到的待处理点集已经是有某种次序的（比如已经按x坐标大小排序，如下图）。这种情况也不一定非得进行persorting构造新的次序，通常改变观察的角度，换一种理解方式就能免去预处理而直接进行后面的线性的scan操作了。上半部分凸包：考虑y轴负方向无穷远一个点，所有的点相对于这个点的极角排序恰好就是各点的x坐标序！也就是将无穷远的点看作起始点①，最右侧点（图中点8）看作点②，进行scan过程直到最左边的点（图中点1）结束，就得到了凸包的上半部分（upper hull），也就是下图的8→7→2→1：注：对 “考虑y轴负方向无穷远一个点，所有的点相对于这个点的极角排序恰好就是各点的x坐标序！” 这句话的理解：就像太阳光照在地球上的道理是一样的，太阳离地球足够的远，那么它的光到达地球上的时候，就近似的是平行的。下半部分凸包（lower hull）的构造也是如此。考虑一个在y轴正方向无穷远的一个点，以此为起点进行scan，最终得到lower hull：1→4→7。最后将两个凸包合二为一即可。代码实现","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"凸包","slug":"凸包","permalink":"https://www.longlongqin.top/tags/%E5%87%B8%E5%8C%85/"}]},{"title":"Lower Bound","slug":"学习笔记/计算几何/Convex-Hull/Lower-Bound","date":"2020-03-14T09:29:23.000Z","updated":"2020-03-17T08:32:28.928Z","comments":true,"path":"archives/ba04.html","link":"","permalink":"https://www.longlongqin.top/archives/ba04.html","excerpt":"冲曰：“置象大船之上，而刻其水深所至，称物以载之，则校可知矣。”","text":"冲曰：“置象大船之上，而刻其水深所至，称物以载之，则校可知矣。”Lower Bound冲曰：“置象大船之上，而刻其水深所至，称物以载之，则校可知矣。”从极点法的O(n^4^)复杂度，到极边法的O(n^3^)，再到增量构造法和Jarvis March的O(n^2^)，我们经历了将特定问题算法不断优化、降低复杂度的过程。那么还有比O(n^2^)更高效的算法吗？凸包构造算法的下界是什么？推广到一般情况，在计算模型固定的情况下特定问题的复杂度下界又是如何确定的？在计算模型固定的情况下特定问题的复杂度下界（lower bound）是确定的。严谨考虑，在设计算法前应该先确定下界是多少。对于某个问题的特定算法，我们可以用时间复杂度来评价算法的好坏。算法能达到的下界也就是所谓问题的难度。当然这种评价通常是比较麻烦的，有时候甚至是不可行的。这就要引入新的的方式来衡量一个算法的好坏。规约（reduction）我们引入规约（reduction）的方法来间接衡量一个算法。规约简单来讲就是用一个“参照物”对比待评算法，得到算法的复杂度。规约的一般方法如图：左侧是已知的问题A，已经明确它的难度，右侧是待分析问题B，复杂度未知。我们在二者之间建立起一种基本reduction关系：linear-time reduction。linear-time reduction具体表述为：任何一个A的输入（input of A），都可以在O(n)复杂度转化为一个B的输入（input of B），然后通过B的某种算法（any algorithm）计算出结果（output of B）;而对于output of B又都可以在在O(n)复杂度转化为A问题的结果（output of A）。两次转换的复杂度不能超过线性，也就是linear-time（线性时间）。能够进行上述操作，就称为：A问题可以规约到B问题（problem A is linear-time reducible to problem B）。注意表述方式防止搞混A和B的位置。曹冲称象可以通过曹冲称象的故事来帮助理解规约的思想。要解决的问题是：没有秤能直接称量大象重量（问题B的难度无法直接衡量），解决方案是：利用船和石块间接称量。石头块的重量是可以直接称量的（问题A的难度是已知的），利用船和水来转换石头和大象的重量是可操作的（规约的方法是可操作的）。【这里的规约关系(Reduction relationship)是指曹冲成像时的船和水】规约记号引入规约记号，problem A is linear-time reducible to problem B表示为：$$A≤_NB$$将问题A、B的难度分别表示为|A|，|B|。规约记号的意思相当于|A|≤|B|，A的下界必然就是B的下界。规约的过程：将A的输入转化为B的输入经过B的某种算法获得解后又转化为A的解，也就是这个算法也是解决A问题的算法。已知A问题的下界，那么这个算法必然不会低于A的这个下界。构造凸包的下界按照“曹冲称象”的规约思想，分析问题的难度，最重要的在于找到“石头”，而船就是规约这种方法。以二维凸包（2d-CH）来分析，首先将待解决的问题放到规约记号右边，而左边的“石头”就是排序算法。$$Sorting≤_N2D-CH$$排序是纯粹的数值计算问题，而凸包是典型的几何问题，二者是如何联系在一起的呢？前面增量构造法和Jarvis March算法正是分别由两种排序算法来类比引入的，可见排序和凸包之间有深刻的内在联系。二者之间的联系可以通过下图表示：首先清点要做的任务：可以在线性时间内，将排序问题的输入转化为凸包问题的输入排序问题的输入可以表示为x轴上的一系列的点（图中蓝色点）。然后将这些点转化为凸包问题的输入，就是将这些待排序的数转化为平面上的点。引入辅助线——一条抛物线，例如图中蓝色虚线。接下来要对蓝色点做到抛物线上的映射（O(n)），映射在抛物线上的点用绿色标出。这样就完成了将待排序数字转化为平面上点的操作。接下来就可以用某种算法将绿色点构造为凸包，即图中CH(P)。可以在线性时间内，将凸包问题的结果转化为排序问题的结果凸包CH(P)就是问题B的解，如何将B的解转化为A的解？注意最左和最右边两点的连线，即图中1和4的连线4→1。除去这条连线之外，其他首尾相接的连线：1→2，2→3和3→4都是“沿着x方向单调的”，遍历这些首尾相连的边（O(n)）就能得到一系列的数值，并且已经是有序的了。这样就将凸包问题的解——凸包CH(P) 转化为了排序问题的解——有序数值序列。两次转化说明规约是可行的，因此2d-CH问题的下界可由sorting的下界确定。一般而言，排序问题的难度是确定的：O(nlogn)。2d-CH问题的下界也就是：$$O(nlogn)$$更高维的凸包问题下界也是如此。增量构造法和Jarvis March的O(n^2^)到O(nlogn)之间的鸿沟能否跨越呢？是否存在O(nlogn)复杂度的凸包构造算法？后续文章会有回答。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"凸包","slug":"凸包","permalink":"https://www.longlongqin.top/tags/%E5%87%B8%E5%8C%85/"}]},{"title":"构造凸包-Jarvis March(Gift Wrapping)算法","slug":"学习笔记/计算几何/Convex-Hull/Jarvis-March","date":"2020-03-14T09:23:45.000Z","updated":"2020-03-17T08:42:49.577Z","comments":true,"path":"archives/9c7f.html","link":"","permalink":"https://www.longlongqin.top/archives/9c7f.html","excerpt":"回顾凸包构造算法：极点法、极边法和增量构造法，其复杂度分别为O(n^4^)、O(n^3^)和O(n^2^)，效率经过优化已经大大提高了。接下来引入一种新的算法——Jarvis March，其复杂度也是O(n^2^)，但是相较于增量构造在最好情况下效率是较高的。","text":"回顾凸包构造算法：极点法、极边法和增量构造法，其复杂度分别为O(n^4^)、O(n^3^)和O(n^2^)，效率经过优化已经大大提高了。接下来引入一种新的算法——Jarvis March，其复杂度也是O(n^2^)，但是相较于增量构造在最好情况下效率是较高的。实现策略先想一下为何极边法复杂度高达O(n^3^)。实际上我们要对点集中所有边进行遍历，这需要n^2^复杂度，然后对每个边进行鉴别，又需要n复杂度，因此总体复杂度高达O(n^3^)。那么该如何改进呢？这就可以运用选择排序的思想：将下一个要查找的边缩小到一个小范围，而非遍历所有边。选择排序每次选取出的unsorted最大元素放在sorted 部分的首部，也就意味着整个unsorted部分必然不会超过sorted部分。从算法整体框架考虑，每次我们都是维护一个局部解（也就是sorted部分），然后从尚未处理的部分（也就是unsorted部分）找到一个与当前局部解“紧密相关的元素”（相当于选取的最大元素）。这个思想为解决凸包问题带来了新思路。对算法的大致过程进行描述(标识为：已找到极边数/所有极边数)：首先从任何一个极点（后面说明如何找到这个点）开始（图中0/5），然后找到一条以这个极点为端点的极边（1/5）。接着沿着极边另一个端点（endpoint）出发，再找出下一条极边（2/5）。如此反复操作，最终会找到一条以最初极点为endpoint的极边，得到一个封闭的环，凸包也构造完成。凸包构造过程类似于选择排序中sorted不断向前扩展一样，不断扩展局部解，最后得到问题最终解。凸包构造的问题由此分解为一个个子问题：如何从endpoint出发找到下一条极边。用to left test找到下一条极边现分析如何从endpoint找到下一条极边。考虑一下的一般情况：我们从极点o开始寻找极边，假设当前找到的极边是ik，接下来要做的工作是找到从k出发的另一条极边ks，即找到极点s。显然，s来自于其他那些尚未处理的点中，那么s与其他点相比有什么特征？观察发现，ik作为一条极边，它的右侧肯定都是空的，所有其他点都在ik左侧。画出k与其他候选点的有向直线，例如下图中的ks，kt：注意图中红色标出的角度，可以看出ks与ik的夹角比kt小，也就是ks比kt相较于ik偏左的角度更小。实际上ks偏左的角度比其他任何从k出发的边都小，这就是s点的判定依据。这样就找到了从其余点中选择s点的思路：任选两个点，从k出发过这两点做有向边，看哪个偏左的角度更小就留下，另一点丢弃。然后再拿一点与留下的点比较，反复这个过程，最终留下的就是要找的s点。问题至此转化为：如何比较两条有向边（例如ks和kt）相较于另一有向直线（例如ik）谁偏左的角度更小。当然可以通过计算三角函数的方法来比较，这是最直观的数学思维。但是这样计算十分复杂，更重要的是引入了误差。这时候又要使用to left test这个基础方法来解决问题了具体做法就是以在ks和kt中以任意个为基准（如以ks为基准），对另一点（如t）做to left test。上图点t和有向边ks的to left test结果为true，t在ks左边，因此ks偏左的角度更小，舍弃点t。类比选择排序来理解:已得到的极边（从极点o开始到ik的首尾相连的极边）——相当于 sorted部分其余点——相当于 unsorted部分找到点s（能构成最小偏角的点）——相当于 从unsorted部分取出极大值选择排序中的选择过程需要比较元素大小，就要由一种比较器完成，而上述比较偏角的过程也可以抽象为一种比较器的操作。构造凸包的算法框架与选择排序相同，只是比较器替换为to left test而已。此处只是考虑一般情况，一些特殊细节未进行处理。例如在st上有s和s’两点，这两点的取舍问题未考虑。当然为了理解算法整体框架忽略特殊情况是很必要的。确定第一个极点一个细节：上文一开始提到的算法的最开始的第一个极点如何确定？任何一个极点都可以使用，我们没必要去计算出哪个点是极点。可以选取y坐标最小的点，也就是最低点，在没有退化的情况下，这个点一定是一个极点。如果情况退化，有多个最低点（如例图中所示），我们就去选x坐标最小的那个点，也就是最左边的点即可。这种方法选出的点称为lowest-then-leftmost point（LTL）。注意选取的规则的先后顺序，先选lowest，若点不唯一再选leftmost。Jarvis March类比选择排序的过程，我们得到的凸包构造算法就是Jarvis March算法，又称gift wrapping算法（算法过程如包装礼物一样）。接下来看算法具体实现方法。12345678910111213141516171819202122232425262728293031323334353637383940bool ToLeft(Point P, Point q, Point s)&#123; int area2 = p.x*q.y - p.y*q.x + q.x*s.y -q.y*s.x + s.x*p.y - s.y*p.x; return area2 &gt;0 ; //左侧为真&#125;int LTL (Point S[], int n)&#123; int ltl = 0; //the lowest-then-leftmost point for(int k=1; k&lt;n;k++)&#123; if(S[k].y &lt; S[ltl].y || (S[k].y==S[ltl].y &amp;&amp; S[k].x&lt;S[ltl].x)) ltl =k; &#125; return ltl;&#125;void Javis(Point S[], int n)&#123; for (int k=0; k&lt;n; k++) S[k].extreme =FALSE; //首先将所有点标记为非极点 int ltl=LTL(S, n); //找到LTL int k=ltl; //将LTL作为第一个极点 do &#123; S[k].extrem = true; int s =-1; //s是要找的下一个极点，用t去循环找 for (int t=0; t&lt;n; t++) &#123; if(t != k &amp;&amp;t != s &amp;&amp; ( s == -1 || !ToLeft(S[K],S[s],S[t]) ) ) s = t; //如果t在pq的右侧，则更新s &#125; S[k].succ = s; k = s; //新的极边pq确定 k = s; //更新k的值，变为下一次查找的起点 &#125;&#125; while(ltl != k) //如果循环回到了原来的点，则结束梳理首先，初始化将所有点都设为：非极点然后，开始找到第一个极点（用LTL方法），找到之后赋值给k接下来，开始找下一个极点s：主要用ToLeft Test来找出下一个极点循环第3步骤，直到找到所有极点小结最后分析Jarvis March算法相较于增量构造法的优势。二者都是O(n^2^)的复杂度，Jarvis March算法的优势在于其的“输出敏感性（output sensitive）”。考虑点集S，共有n个点，来构造S上的凸包。何为“输出敏感性”？Jarvis March算法每次新加入一条边都会耗费n的复杂度，但是构造过程一共会加入的边数往往比n少。如下图（设n = 7）：在非退化为共线的前提下，最好情况为只加入3条边（复杂度为O(3n)），最坏情况为所有点都是极点，加入n-1条边（复杂度为O(n^2^)）。实际情况中最坏情况出现的几率很小，我们引入一个指标h来衡量凸包的极边数（the size of convex hull）：$$h = |CH(S)|$$Jarvis March算法算法的复杂度更准确的表示为O(nh)。h又由最终输出结果，即凸包本身来决定，输出结果决定了构造过程的复杂度，这就是所谓的“输出敏感性”。这种类型的算法又被称为output sensitive algorithm。这种特性在其它凸包算法中也会体现。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"凸包","slug":"凸包","permalink":"https://www.longlongqin.top/tags/%E5%87%B8%E5%8C%85/"}]},{"title":"构造凸包-增量构造法","slug":"学习笔记/计算几何/Convex-Hull/增量构造","date":"2020-03-14T09:15:07.000Z","updated":"2020-03-17T08:35:10.173Z","comments":true,"path":"archives/7c53.html","link":"","permalink":"https://www.longlongqin.top/archives/7c53.html","excerpt":"在上面的极点法和极边法的复杂度分别是O(n^4^)和O(n^3^)，如果点集S的规模比较大的话，这两种方法就太慢辽。","text":"在上面的极点法和极边法的复杂度分别是O(n^4^)和O(n^3^)，如果点集S的规模比较大的话，这两种方法就太慢辽。在引入新算法之前首先来回顾一下经典的算法思想：减治（decrease and conquer），注意不是分治（divided and conquer），二者稍有区别。简单来讲就是将问题划分为一个个简单的小问题，减而治之，逐个求解，最终就能得到整个问题的解。减治法的经典例子就是插入排序（insertion sort）。插入排序的过程可以归结成下图：排序的过程中将序列分为两部分：已排序部分（sorted）和未排序部分（unsorted）。每次排序都是从unsorted中拿出一个元素，通过一次顺序查找过程在sorted部分中找到位置并插入其中。整个插入排序的过程就是逐个元素的去“蚕食”unsorted部分的过程，连续的进行这个操作就会将整个问题解决。这种将大问题分解成小问题的减治过程，又被看成一种递增的、增量式的策略（incremental strategy）。这种思想为解决凸包问题提供了新的思路：从逐个插入新点的角度构造凸包。典型流程如下图（标识为：极点/整体规模）：插入新的点可能的情况有：新点对凸包有“贡献”，例如5/5→6/6，6/6→7/7；新点也有可能没有“贡献”，例如7/7→7/8；还有可能使原先有“贡献”的点失效，极点数量减少，例如7/8→6/9。那么如何对不同情况进行处理呢？确定新点与现有凸包的关系~in-convex-polygon test构造过程的核心算法应该是：判定待定点是否位于某多边形内部（in-convex-polygon test）。再看上图流程，实际上每步的核心就是判断点位于多边形内部还是外部，若落在外部，则新插入的点就是下一个极点，否则舍弃。考虑基本情况，给定一个点和一个多边形，如何高效判断该点与多边形的位置关系呢？一种思路是：我们可以先对多边形进行一个“预处理”，给每个点按序编号，类比有序向量二分查找的思想，来逐步缩小规模。如下图：首先任选一点为基准点（蓝色点），然后用二分法选取其余点的“中点“（预处理已经为所有点排了序），然后判断基准点到终点的有向直线与待定点的位置关系（to-left test）。然后可将搜索范围减半，反复上述过程，直到最后退化为平凡情况：三角形与点的位置关系（in-triangle test）。分析一下算法的整体复杂度：整个算法共log(n)步，每步的to-left test或in-triangle test都为常数成本，则整体复杂度为log(n)。至此，我们似乎得到了一个log(n)的“高效”算法，但是这种方法真的可行吗？注意，每步都会将原凸包规模减半，也就是说凸包是动态的，随时可能变化。这种方法和极点法或极边法中静态查找的情况是完全不同的。类比插入排序的过程来解释这个问题。为何插入排序的复杂度是n^2^而非nlog(n)？每次插入时，既然sorted部分已经有序，为何不使用二分查找来取代顺序查找（复杂度由n变为log(n)）？这不得不考虑sorted部分的动态性，每次插入后它的结构都会改变，而二分查找必须在静态结构中实现。当然可以使用std::vector这类支持按秩访问（call by rank）的数据结构，但是插入时维护vector的成本依旧是线性复杂度。因此插入排序的总体复杂度是n^2^。要处理的凸包与插入排序中sorted部分本质是一样的，它们都不是静态不变的结构，而要随着算法执行而不断变化。若要每次在log(n)成本下完成待定点的in-convex-polygon test，必须将凸包存储为类似vector的数据结构，但是每次向这种数据结构插入新点的成本依旧是线性的。因此对凸包进行的所谓“预处理”是没有意义的，这种减治策略算法复杂度最低应该为O(n^2^)。到现在问题依旧没有解决，究竟如何用这种增量式的策略来构造凸包？其实复杂问题中最朴素、最基本的方法反而是最有效的。==in-convex-polygon test最基本的方法是什么？就是按一定方向（约定为逆时针）凸包的每条边和待定点做to-left test，一旦有一次test为false就能断定点在凸包外面。这实际上就是将in-triangle test推广多边形的情况。因此每次in-convex-polygon test的成本就会变成当前凸包的规模，也就是n。==对于每个新点做一次in-convex-polygon test，构造算法的整体复杂度就是O(n^2^)。算法的复杂度从极边法的O(n^3^)又下降了一个数量级。其实增量算法的整个思路可以分成两块：1、如何判断凸包与新点的位置关系（in-convex-polygon test）2、如何向凸包插入新点上面的方法已经解决（黄色部分）了第一个问题。第二个问题看下面部分：如何向凸包插入新点~support-line现在来讨论如何向凸包插入新点：比如下面这个点，应该如何插入凸包之中呢？插入过程：将新点x插入原凸包的过程，本质上就是寻找两个连接点s和t，将x和t、s分别连接得到新的凸包。注意t和s两点将整个原凸包边界分为两部分：st和ts两个有向段。构造新凸包就要保留远端st、舍弃近端ts。取代近端ts的两条线就是x和t的连线xt和xs，被称为切线（tangent）或者support line（支撑线）。那如何查找t、s这两个点呢？我们在凸包上任取一点v，按逆时针方向v点会有一个直接前驱点和直接后继点。考察有向直线xv与点v直接前驱和直接后继的位置关系（两次to left test），记录为一个pattern表。结果无非是四种情况：v的直接前驱和直接后继相对于有向直线xv的位置是RL，LR，LL，RR。例如上图黄色点v，是R和L；蓝色点v分别是L和R。实际上凸包边界st上所有点的pattern都为RL，ts上所有点的pattern都为LR。关键点在于：点S的pattern是LL，点t的pattern为RR。因此对凸包边界每个点做两次to left test，判断其pattern就可找出s和t，花费时间成本为常数。incremental construction再来回顾整个凸包构造算法的两大问题：in-convex-polygon test和插入新点。分开考虑只是为了将思路简化，实际上这两个问题可以套用一个算法，同时来解决。具体做法就是：对于每个待定点x，不必特意去考虑它与凸包的位置关系，而是遍历凸包上每一个点。对于凸包边界上的每一个点，我们都能通过两次to left test迅速判断出pattern。对于x位于凸包外部的情况，经过遍历凸包的点，我们很容易就能得到s和t的位置，得到两条support line，从而构造出新的凸包；而对于x位于凸包内部的情况，凸包边界每个点都不可能出现RR或LL的情况，直接舍弃x即可。每次遍历凸包边界点的复杂度为O(n)，整个构造过程要增量式的逐点考察，自然得到了一个O(n^2^)的incremental construction算法。这就是所谓增量构造法来构造凸包的过程。构造过程巧妙的避开了特殊处理诸如5/5→6/6、7/7→7/8、7/8→6/9等复杂情况，采用一致的思路逐个考察“新点”，最终完成凸包的构造。代码部分待写……..小结：其实增量算法的整个思路可以分成两块：1、如何判断凸包与新点的位置关系（in-convex-polygon test）2、如何向凸包插入新点","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"凸包","slug":"凸包","permalink":"https://www.longlongqin.top/tags/%E5%87%B8%E5%8C%85/"}]},{"title":"写作格式模板","slug":"volantis-markdown","date":"2020-03-13T16:00:00.000Z","updated":"2020-03-16T14:39:21.531Z","comments":true,"path":"archives/2d6f5e7f.html","link":"","permalink":"https://www.longlongqin.top/archives/2d6f5e7f.html","excerpt":"主题支持丰富多彩的标签。","text":"主题支持丰富多彩的标签。文本属性format1&lt;p 属性参数&gt;文本内容&lt;/p&gt;彩色文字在一段话中方便插入各种颜色的标签，包括：红色、黄色、绿色、青色、蓝色、灰色。1在一段话中方便插入各种颜色的标签，包括：&lt;red&gt;红色&lt;/red&gt;、&lt;yellow&gt;黄色&lt;/yellow&gt;、&lt;green&gt;绿色&lt;/green&gt;、&lt;cyan&gt;青色&lt;/cyan&gt;、&lt;blue&gt;蓝色&lt;/blue&gt;、&lt;gray&gt;灰色&lt;/gray&gt;。超大文字示例效果VolantisA Wonderful Theme for Hexo12&lt;p center large&gt;Volantis&lt;/p&gt;&lt;p center small&gt;A Wonderful Theme for Hexo&lt;/p&gt;目前支持的尺寸有：small、large、huge，布局有：left、center、right。插入简单按钮目前共支持3种尺寸的按钮。示例效果第1种按钮适合融入段落中。第2种按钮适合独立于段落之外： 示例博客第3种按钮更具有强调作用，建议搭配 center 使用： 开始使用123456789第1种 &lt;btn&gt;[按钮](/)&lt;/btn&gt; 适合融入段落中。第2种按钮适合独立于段落之外：&lt;btn regular&gt;[&lt;i class='fas fa-play-circle'&gt;&lt;/i&gt; 示例博客](https://xaoxuu.com)&lt;/btn&gt;第3种按钮更具有强调作用，建议搭配 center 使用：&lt;btn center large&gt;[&lt;i class='fas fa-download'&gt;&lt;/i&gt; 开始使用](/)&lt;/btn&gt;插入高级按钮如果需要显示类似「团队成员」之类的一组含有头像的链接：xaoxuu xaoxuu xaoxuu xaoxuu或者含有图标的按钮：下载 文档12345678910111213&#123;% raw %&#125;&lt;btns circle grid5&gt;&lt;a href='https://gyl-coder.top'&gt;&lt;img src='https://cdn.jsdelivr.net/gh/gyl-coder/blogImgs/images/touxiang.jpg'&gt;xaoxuu&lt;/a&gt;&lt;a href='https://gyl-coder.top'&gt;&lt;img src='https://cdn.jsdelivr.net/gh/gyl-coder/blogImgs/images/touxiang.jpg'&gt;xaoxuu&lt;/a&gt;&lt;a href='https://gyl-coder.top'&gt;&lt;img src='https://cdn.jsdelivr.net/gh/gyl-coder/blogImgs/images/touxiang.jpg'&gt;xaoxuu&lt;/a&gt;&lt;a href='https://gyl-coder.top'&gt;&lt;img src='https://cdn.jsdelivr.net/gh/gyl-coder/blogImgs/images/touxiang.jpg'&gt;xaoxuu&lt;/a&gt;&lt;/btns&gt;或者含有图标的按钮：&lt;btns rounded grid5&gt;&lt;a href='https://gyl-coder.top/hexo-theme-volantis/'&gt;&lt;i class='fas fa-download'&gt;&lt;/i&gt;下载源码&lt;/a&gt;&lt;a href='https://volantis.js.org/'&gt;&lt;i class='fas fa-book-open'&gt;&lt;/i&gt;查看文档&lt;/a&gt;&lt;/btns&gt;&#123;% endraw %&#125;Tips:1&#123;% raw %&#125; 和 &#123;% endraw %&#125; 之间的内容是不解析的，只能写HTML标签。自定样式123&lt;btns 样式&gt;很多按钮&lt;/btns&gt;图片样式默认为方形圆角矩形（rounded），适合app图标。圆形（circle），适合头像。布局方式默认为自动宽度，适合视野内只有一两个的情况，多了显乱。宽一点的按钮（wide）。填充布局（fill），自动铺满至少一行，多了会换行。居中（center），按钮之间是固定间距。居中分散（around）。网格布局（grid3），最多3列，屏幕变窄会适当减少列数。网格布局（grid4），最多4列，屏幕变窄会适当减少列数。网格布局（grid5），最多5列，屏幕变窄会适当减少列数。增加文字样式可以在 &lt;btns&gt;&lt;/btns&gt; 容器内增加 &lt;p&gt;标题&lt;/p&gt; 和 &lt;p&gt;描述文字&lt;/p&gt;图文并茂的例子圆形图标 + 标题 + 描述 + 图片 + 网格4列 + 居中 心率管家专业版 心率管家免费版上例写法如下12345678910111213141516&#123;% raw %&#125;&lt;btns circle center grid4&gt;&lt;a href='https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1'&gt; &lt;i class='fab fa-apple'&gt;&lt;/i&gt; &lt;b&gt;心率管家&lt;/b&gt; &lt;p red&gt;专业版&lt;/p&gt; &lt;img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/heartmate_pro.png'&gt;&lt;/a&gt;&lt;a href='https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1'&gt; &lt;i class='fab fa-apple'&gt;&lt;/i&gt; &lt;b&gt;心率管家&lt;/b&gt; &lt;p green&gt;免费版&lt;/p&gt; &lt;img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/heartmate_lite.png'&gt;&lt;/a&gt;&lt;/btns&gt;&#123;% endraw %&#125;图片放大在主题配置文件中开启插件。1234plugins: fancybox: css: '//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css' js: '//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js'将需要放大预览的图片用 &lt;fancybox&gt;&lt;/fancybox&gt; 包含起来。123456例如这个图是不能点开的：![](https://img.vim-cn.com/52/a54815c02ce232f11f54b2c547c1337828833c.png)而这个图是可以点开的：&lt;fancybox&gt;&lt;img src='https://img.vim-cn.com/52/a54815c02ce232f11f54b2c547c1337828833c.png'&gt;&lt;/fancybox&gt;示例效果例如这个图是不能点开的：而这个图是可以点开的：「注意」这样写是无效的：123&lt;fancybox&gt;![](https://img.vim-cn.com/52/a54815c02ce232f11f54b2c547c1337828833c.png)&lt;/fancybox&gt;如需一行显示多图，将多个图片同时放在一对 &lt;fancybox&gt;&lt;/fancybox&gt; 中即可：1234567&lt;fancybox&gt;&lt;img src='https://i.loli.net/2019/08/20/sgultOmRLXrwfA3.png'&gt;&amp;nbsp;&lt;img src='https://i.loli.net/2019/08/20/a2mCq871PwfbZEG.png'&gt;&amp;nbsp;&lt;img src='https://i.loli.net/2019/08/20/Zdz2cTphOlu3XKf.png'&gt;&amp;nbsp;&lt;img src='https://i.loli.net/2019/08/20/87UdSGaMuevV1iF.png'&gt;&amp;nbsp;&lt;img src='https://i.loli.net/2019/08/20/HEusSLBgG3XC1nN.png'&gt;&lt;/fancybox&gt;Tab切换这部分功能借鉴自 NexT 主题，但外观风格上有所不同。Tab的写法Tab2Tab3123456789101112131415&#123;% tabs tabname %&#125;&lt;!-- tab Tab1 --&gt;这里面写内容，支持的语法格式有限，请尽量&lt;u&gt;不要&lt;/u&gt;写太过复杂的东西。&lt;!-- endtab --&gt;&lt;!-- tab Tab2 --&gt;这里面写内容，支持的语法格式有限，请尽量&lt;u&gt;不要&lt;/u&gt;写太过复杂的东西。&lt;!-- endtab --&gt;&#123;% endtabs %&#125;这里面写内容，支持的语法格式有限，请尽量不要写太过复杂的东西。这里面写内容，支持的语法格式有限，请尽量不要写太过复杂的东西。表格滚动一般来说，表格默认会横向铺满，格子内文字过多会自动换行。但是当列数比较多时，每一列都很窄，推荐使用支持滚动的表格样式，用一对 &lt;overflow&gt;&lt;/overflow&gt; 把表格包起来。12345&lt;overflow&gt;md表格内容&lt;/overflow&gt;示例类别排序方法平均时间复杂度最优时间复杂度最差时间复杂度空间复杂度稳定性复杂性插入排序直接插入O(n2)O(n)O(n2)O(1)稳定简单插入排序希尔排序O(n1.3)O(n)O(n2)O(1)不稳定复杂选择排序直接选择O(n2)O(n2)O(n2)O(1)不稳定简单选择排序堆排序O(nlog2n)O(nlog2n)O(nlog2n)O(1)不稳定复杂交换排序冒泡排序O(n2)O(n)O(n2)O(1)稳定简单交换排序快速排序O(nlog2n)O(nlog2n)O(n2)O(nlog2n)~O(n)不稳定复杂归并排序O(nlog2n)O(nlog2n)O(nlog2n)O(n)稳定复杂基数排序O(d(r+n))O(d(r+n))O(d(r+n))O(rd+n)稳定复杂blog/source/_posts/example.md:1234567891011121314&lt;overflow&gt;| 类别 | 排序方法 | 平均时间复杂度 | 最优时间复杂度 | 最差时间复杂度 | 空间复杂度 | 稳定性 | 复杂性 || :-------- | :-------- | :-------------------- | :-------------------- | :-------------------- | :--------------------------- | :------ | :------ || 插入排序 | 直接插入 | O(n&lt;sup&gt;2&lt;/sup&gt;) | O(n) | O(n&lt;sup&gt;2&lt;/sup&gt;) | O(1) | 稳定 | 简单 || 插入排序 | 希尔排序 | O(n&lt;sup&gt;1.3&lt;/sup&gt;) | O(n) | O(n&lt;sup&gt;2&lt;/sup&gt;) | O(1) | 不稳定 | 复杂 || 选择排序 | 直接选择 | O(n&lt;sup&gt;2&lt;/sup&gt;) | O(n&lt;sup&gt;2&lt;/sup&gt;) | O(n&lt;sup&gt;2&lt;/sup&gt;) | O(1) | 不稳定 | 简单 || 选择排序 | 堆排序 | O(nlog&lt;sub&gt;2&lt;/sub&gt;n) | O(nlog&lt;sub&gt;2&lt;/sub&gt;n) | O(nlog&lt;sub&gt;2&lt;/sub&gt;n) | O(1) | 不稳定 | 复杂 || 交换排序 | 冒泡排序 | O(n&lt;sup&gt;2&lt;/sup&gt;) | O(n) | O(n&lt;sup&gt;2&lt;/sup&gt;) | O(1) | 稳定 | 简单 || 交换排序 | 快速排序 | O(nlog&lt;sub&gt;2&lt;/sub&gt;n) | O(nlog&lt;sub&gt;2&lt;/sub&gt;n) | O(n&lt;sup&gt;2&lt;/sup&gt;) | O(nlog&lt;sub&gt;2&lt;/sub&gt;n)~O(n) | 不稳定 | 复杂 || | 归并排序 | O(nlog&lt;sub&gt;2&lt;/sub&gt;n) | O(nlog&lt;sub&gt;2&lt;/sub&gt;n) | O(nlog&lt;sub&gt;2&lt;/sub&gt;n) | O(n) | 稳定 | 复杂 || | 基数排序 | O(d(r+n)) | O(d(r+n)) | O(d(r+n)) | O(rd+n) | 稳定 | 复杂 |&lt;/overflow&gt;折叠区域One More Thing 👇懒加载占位图如果喜欢请拿去：图片地址blog/source/_posts/example.md:12345678910&#123;% raw %&#125;&lt;details&gt;&lt;summary&gt;One More Thing 👇&lt;/summary&gt;&#123;% endraw %&#125;懒加载占位图如果喜欢请拿去：&lt;btn&gt;[图片地址](https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/placeholder/d570170f4f12e1ee829ca0e85a7dffeb77343a.svg)&lt;/btn&gt;&#123;% raw %&#125;&lt;/details&gt;&#123;% endraw %&#125;渲染公式（MathJax）默认是不渲染的，如果文章内有公式，需要在 front-matter 中设置开启。blog/source/_posts/example.md:12345678910111213141516171819202122232425---title: 渲染公式（MathJax）date: 2020-02-23mathjax: true # false: 不渲染, true: 渲染, internal: 只在文章内部渲染，文章列表中不渲染---$t+1=2$$$\\mbox&#123;积累因子&#125;=\\begin&#123;cases&#125;1+ni &amp; \\mbox&#123;单利&#125;\\\\\\\\(1+i)^n &amp; \\mbox&#123;复利&#125;\\end&#123;cases&#125;$$$$\\begin&#123;equation&#125;\\sum_&#123;i=0&#125;^n F_i \\cdot \\phi (H, p_i) - \\sum_&#123;i=1&#125;^n a_i \\cdot ( \\tilde&#123;x_i&#125;, \\tilde&#123;y_i&#125;) + b_i \\cdot ( \\tilde&#123;x_i&#125;^2 , \\tilde&#123;y_i&#125;^2 )\\end&#123;equation&#125;$$$$\\begin&#123;equation&#125;\\beta^*(D) = \\mathop&#123;argmin&#125; \\limits_&#123;\\beta&#125; \\lambda &#123;||\\beta||&#125;^2 + \\sum_&#123;i=1&#125;^n max(0, 1 - y_i f_&#123;\\beta&#125;(x_i))\\end&#123;equation&#125;$$示例效果$t+1=2$$$\\mbox{积累因子}=\\begin{cases}1+ni &amp; \\mbox{单利}\\\\(1+i)^n &amp; \\mbox{复利}\\end{cases}$$$$\\begin{equation}\\sum_{i=0}^n F_i \\cdot \\phi (H, p_i) - \\sum_{i=1}^n a_i \\cdot ( \\tilde{x_i}, \\tilde{y_i}) + b_i \\cdot ( \\tilde{x_i}^2 , \\tilde{y_i}^2 )\\end{equation}$$$$\\begin{equation}\\beta^*(D) = \\mathop{argmin} \\limits_{\\beta} \\lambda {||\\beta||}^2 + \\sum_{i=1}^n max(0, 1 - y_i f_{\\beta}(x_i))\\end{equation}$$如果公式仍无法正确渲染可以阅读 @MicDZ 的这篇文章：《在material-x上使用KaTeX》。Hexo原生支持的标签引用块引用书上的句子Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.David LevithanWide Awake代码块123&#123;% codeblock [title] [lang:language] [url] [link text] [additional options] %&#125;code snippet&#123;% endcodeblock %&#125;指定语言1[rectangle setX: 10 y: 10 width: 20 height: 20];123&#123;% codeblock lang:objc %&#125;[rectangle setX: 10 y: 10 width: 20 height: 20];&#123;% endcodeblock %&#125;附加说明Array.map1array.map(callback[, thisArg])blog/source/_posts/example.md:123&#123;% codeblock Array.map %&#125;array.map(callback[, thisArg])&#123;% endcodeblock %&#125;行标、高亮12345678n=eval(input())if n==0: print(\"Hello World\")elif n&gt;0: print(\"He\\nll\\no \\nWo\\nrl\\nd\")else: for c in \"Hello World\": print(c)12345678910&#123;% codeblock lang:python line_number:true mark:3,5,8 %&#125;n=eval(input())if n==0: print(\"Hello World\")elif n&gt;0: print(\"He\\nll\\no \\nWo\\nrl\\nd\")else: for c in \"Hello World\": print(c)&#123;% endcodeblock %&#125;Pull Quote在文章中插入 Pull quote。123&#123;% pullquote [class] %&#125;content&#123;% endpullquote %&#125;jsFiddle在文章中嵌入 jsFiddle。1&#123;% jsfiddle shorttag [tabs] [skin] [width] [height] %&#125;Gist在文章中嵌入 Gist，注意：在国内无法加载。1&#123;% gist gist_id [filename] %&#125;iframe在文章中插入 iframe。1&#123;% iframe url [width] [height] %&#125;Image在文章中插入指定大小的图片。1&#123;% img [class names] /path/to/image [width] [height] '\"title text\" \"alt text\"' %&#125;Link在文章中插入链接，并自动给外部链接添加 target=&quot;_blank&quot; 属性。1&#123;% link text url [external] [title] %&#125;Include Code插入 source/downloads/code 文件夹内的代码文件。source/downloads/code 不是固定的，取决于你在配置文件中 code_dir 的配置。1&#123;% include_code [title] [lang:language] [from:line] [to:line] path/to/file %&#125;示例嵌入 test.js 文件全文1&#123;% include_code lang:javascript test.js %&#125;只嵌入第 3 行1&#123;% include_code lang:javascript from:3 to:3 test.js %&#125;嵌入第 5 行至第 8 行1&#123;% include_code lang:javascript from:5 to:8 test.js %&#125;嵌入第 5 行至文件结束1&#123;% include_code lang:javascript from:5 test.js %&#125;嵌入第 1 行至第 8 行1&#123;% include_code lang:javascript to:8 test.js %&#125;引用文章引用其他文章的链接。12&#123;% post_path filename %&#125;&#123;% post_link filename [title] [escape] %&#125;示例引用这篇文章：1引用这篇文章：&#123;% post_link 2020-02-22 %&#125;文章摘要和截断在文章中使用 &lt;!-- more --&gt;，那么 &lt;!-- more --&gt; 之前的文字将会被视为摘要。首页中将只出现这部分文字，同时这部分文字也会出现在正文之中。更多请见Hexo官方文档：#标签插件布局模板取值含义page独立页面post文章页面category分类页面tag标签页面links友链页面list列表页面::: warningpost 页面几乎与 page 页面相同，但是，post 页面更适用于文章，网页向下滚动时导航栏会上翻显出文章标题。:::front-matterfront-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量。查看全部取值字段含义值类型默认值layout布局模版String-title标题String-seotitle网页标题Stringpage.titledate创建时间Date文件创建时间updated更新日期Date文件修改时间permalink覆盖文章网址String-music内部音乐控件[Object]-robotsrobotsString-keywords页面关键词String-description页面描述、摘要String-cover是否显示封面Booltruemeta文章或页面的meta信息Bool, Arraytheme.layout.*.metasidebar页面侧边栏Bool, Arraytheme.layout.*.sidebarbody页面主体元素Arraytheme.layout.on_page.bodymathjax是否渲染公式Bool, Stringfalsethumbnail缩略图Stringfalseicons图标Array[]没有 seotitle 时，以 title 作为网页标题。layout:post 时特有的字段：字段含义值类型默认值author文章作者[Object]config.authorcategories分类String, Array-tags标签String, Array-toc是否生成目录Booltruetop是否置顶Boolfalseauthor字段含义值类型默认值name作者名Stringconfig.authoravatar头像Stringconfig.avatarurl链接Stringconfig.urlmusic字段是否必须值类型server是netease, tencent, kugou, xiami, baidutype是song, playlist, album, search, artistid是song id / playlist id / album id / search keyword更多请见 Hexo 官方文档：#front-matter独立页面除了归档页面是自动生成的，其它独立页面都需要手动创建md文件。归档页面归档页面是自动生成的，并且初始化的时候已经生成，路径如下：12# Directoryarchive_dir: archives关于页面123456789101112---layout: pagetitle: 关于meta: header: [] footer: []sidebar: []valine: placeholder: 有什么想对我说的呢？---下面写关于自己的内容分类页面12345---layout: categoryindex: truetitle: 所有分类---标签页面12345---layout: tagindex: truetitle: 所有标签---列表页面12345---layout: listgroup: mylistindex: true---结果就是筛选出所有文章中 front-matter 部分含有 group: mylist 的文章。上述中的 mylist 只是示例，你可以用任何名字作为一个列表。友链页面123456789101112131415161718192021222324252627282930313233---layout: links # 必须title: 我的朋友们 # 可选，这是友链页的标题links: - group: 分组1 icon: fas fa-user-tie desc: 这个分组的描述 items: - name: # 博客名 avatar: # 头像链接 url: # 博客链接 backgroundColor: '#3E74C9' # 卡片背景颜色 textColor: '#fff' # 卡片文字颜色 tags: [标签1, 标签2] # 标签 desc: 描述文字 - group: 分组2 icon: fas fa-user-tie desc: 这个分组的描述 items: - name: # 博客名 avatar: # 头像链接 url: # 博客链接 backgroundColor: '#3E74C9' # 卡片背景颜色 textColor: '#fff' # 卡片文字颜色 tags: [标签1, 标签2] # 标签 desc: 描述文字---这里写友链上方的内容。&lt;!-- more --&gt;这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。姓名、头像、链接是必填项，其它选填。404页面123456789101112131415161718192021---layout: pagetitle: 404 Not Foundbody: [article, comments]meta: header: [] footer: []sidebar: []valine: path: /404.html placeholder: 请留言告诉我您要访问哪个页面找不到了---&lt;center&gt;&lt;p huge&gt;404&lt;/p&gt;&lt;b&gt;很抱歉，您访问的页面不存在&lt;/b&gt;可能是输入地址有误或该地址已被删除&lt;/center&gt;页面元素排列默认是文章+评论：front-matter123---body: [article, comments]---如果你想把相关文章卡片显示在评论前，可以这样写：front-matter123---body: [article, related_posts, comments]---如果想全局修改，在主题配置文件中的 layout.on_page.body 中设置。文章属性文章置顶在 front-matter 中设置以下值：front-matter1top: true如果想自定义置顶标签的文字，可以直接设置为字符串，例如：front-matter1top: 近期更新文章分类多个分类有两种关系，一种是层级（等同于文件夹），一种是并列（等同于标签）。多级分类：front-matter123---categories: [分类A, 分类B]---或者front-matter12345---categories: - 分类A - 分类B---并列分类front-matter123categories: - [分类A] - [分类B]多级+并列分类front-matter123categories: - [分类A, 分类B] - [分类C, 分类D]文章摘要在文章中插入 &lt;!-- more --&gt;，前面的部分即为摘要。某篇文章源码12345678910---title: xxxdate: 2020-02-21---这是摘要&lt;!-- more --&gt;这是正文::: warning注意： &lt;!-- more --&gt; 前后一定要有空行，不然可能导致显示错位。:::设置文章作者由于支持多作者共同维护一个博客，所以可以设置单独一篇文章的作者：front-matter123456---author: name: 作者 avatar: https://img.vim-cn.com/a1/d53c11fb5d4fd69529bc805d385fe818feb3f6.png url: https://baidu.com---显示迷你音乐播放器标题右边显示迷你音乐播放器，支持的字段有：server、type、id。front-matter123456---music: server: netease # netease, tencent, kugou, xiami, baidu type: song # song, playlist, album, search, artist id: 16846091 # song id / playlist id / album id / search keyword---实际效果见： https://volantis.js.org/contributors/APlayer配置： https://github.com/metowolf/MetingJS显示 meta 标签文章顶部和底部的日期、分类、更新日期、标签、分享等属于 meta 标签。顶部的为 header，底部的为 footer，取值见主题配置文件中的 meta 库。front-matter12345678---# 默认的meta信息，文章中没有配置则按照这里的配置来显示，设置为false则不显示# 其中，title只在header中有效，music和thumbnail无需在这里设置，文章中有则显示# 如果tags放置在meta.header中，那么在post列表中不显示（因为卡片下方已经有了）meta: header: [title, author, date, category, counter, top] footer: [updated, tags, share]---像404、关于页面就可以完全隐藏：front-matter12345---meta: header: [] footer: []---标题右边显示缩略图front-matter123---thumbnail: https://img.vim-cn.com/17/0c7b02722686d1527a1df807dae0794d995860.png---缩略图仅在文章列表和文章页面显示，不会在归档页面显示。标题右边显示图标front-matter123---icons: [fas fa-fire red, fas fa-star green]---图标仅在归档页面中显示，可以用来标注热门文章。可以通过 red / blue / green / yellow / orange / theme / accent 来设置图标的颜色theme 为主题色: @theme_mainaccent 为链接高亮颜色: @color_text_highlightmeta 区域显示外链按钮例如当前文档页面的设置：front-matter123456789---meta: footer: [btns]btns: repo: https://gyl-coder.top/hexo-theme-volantis bug: https://gyl-coder.top/hexo-theme-volantis/issues/new?assignees=&amp;labels=BUG&amp;template=bug-report.md doubt: https://gyl-coder.top/hexo-theme-volantis/issues/new?labels=疑问&amp;template=question-report.md idea: https://gyl-coder.top/hexo-theme-volantis/issues/new?assignees=&amp;labels=建议&amp;template=feature-request.md---按钮的颜色、图标、标题在主题配置文件中设置。是否要显示封面如果某个页面需要封面，可以这样写：front-matter123---cover: true---引入外部文章利用 permalink，搭配自定义的文章作者信息，你可以在文章列表中显示外部文章或者网址，例如：front-matter123456789101112131415---layout: postdate: 2017-07-05title: [转]如何搭建基于Hexo的独立博客categories: [Dev, Hexo]tags: - Hexoauthor: name: xaoxuu avatar: https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/avatar/avatar.png url: https://xaoxuu.compermalink: https://xaoxuu.com/blog/2017-07-05-hexo-blog/---![](https://img.vim-cn.com/d9/a9af7dc49fc0af8ca3e6dd2450a2f7095a87db.png)显示侧边栏通过自由设置边栏卡片来删减对应页面的冗余信息，提高有价值的信息在页面中的权重。如果某个页面不需要侧边栏，可以这样写：front-matter123---sidebar: []---某个页面想指定显示某几个侧边栏，就这样写:front-matter123---sidebar: [grid, toc, tags] # 放置任何你想要显示的侧边栏部件---关闭评论可以front-matter123---comments: false---也可以front-matter123---body: [article]---只显示留言板如果你想创建一个只有留言板的页面front-matter123---body: [comments]---","categories":[],"tags":[],"author":{"name":"yanliang","avatar":"https://cdn.jsdelivr.net/gh/gyl-coder/gyl-coder.github.com@v1.0.0/img/touxiang.jpg","url":"https://gyl-coder.github.io"}},{"title":"Let’s Build A Simple Interpreter 7","slug":"学习笔记/Let's Build A Simple Interpreter1/LSBASI-7","date":"2020-03-13T13:55:47.000Z","updated":"2020-03-17T09:40:48.807Z","comments":true,"path":"archives/d57d.html","link":"","permalink":"https://www.longlongqin.top/archives/d57d.html","excerpt":"之前的那几小结，我们都是把interpreter的代码和parser的代码混在一起，而且interpreter在parser识别出一个如加减乘除之类 的特定的语言结构(language construct)后，就会立刻对它进行求值。这种 interpreter 被称为 语法导向解释器(syntax-directed interpreter)。","text":"之前的那几小结，我们都是把interpreter的代码和parser的代码混在一起，而且interpreter在parser识别出一个如加减乘除之类 的特定的语言结构(language construct)后，就会立刻对它进行求值。这种 interpreter 被称为 语法导向解释器(syntax-directed interpreter)。前言原文链接：https://ruslanspivak.com/lsbasi-part7/之前的那几小结，我们都是把interpreter的代码和parser的代码混在一起，而且interpreter在parser识别出一个如加减乘除之类 的特定的语言结构(language construct)后，就会立刻对它进行求值。这种 interpreter 被称为 语法导向解释器(syntax-directed interpreter)。他们通常在输 入上做一个 pass 且只适合基础的语言应用。为了分析更复杂的编程语言 Pascal 的结构， 我们需要建立一个 中间表示 (intermediate representation, IR)。parser 会 负责构建 IRinterpreter 会用来解释由 IR 所代表的输入。事实证明树是一个表示 IR 非常合适的数据结构。关于数的一些术语terminology：树是一个包含一个或多个结点组成的层次数据结构。树有一个根结点，就是顶部结点。除根结点外的所有结点有唯一 一个父结点。下图中结点为*的是一个父结点。结点为 2 和 7 的是它的子结点；子结点从左到右排序。没有子结点的结点称为叶子结点。有一个或多个子结点的非根结点被称为中间结点。子结点也可以是完全子树。下图中结点＋的左子树（结点为*）就是一个有自己子结点的 完全子树。在计算机科学中我们把树倒过来画，根结点在最上边，分枝向下生长。下面是表达式 2 * 7 + 3 的带有解释的树形表示：本系列中我们会用到的 IR 被称为 抽象语法树 (abstract-syntax tree, AST)。但在深 入了解 AST 之前让我们简单聊聊 解析树 (parse tree)。尽管我们不会在解释器和编译 器中用到解析树，但它会通过可视化 parser 执行轨迹的方法，加深你对 parser 如何解释 输入的理解。我们也会将它和 AST 做比较，来表明为什么 AST 比解析树更适合用来做 IR。那么，什么是解析树呢？解析树（有时叫做 具体语法树concrete syntax tree ）是一个根据我们的语法定义来 表示一门语言的句法结构的树形结构。它基本上展示了你的 parser 如何识别语言结构或者， 换句话说，它展示了你语法的开始符号怎么派生出该编程语言中一个特定的字符串的。parser 的调用栈隐式地代表了一个解析树，且当parser 在试图识别一个特定的语言结构时，解析树 就会自动地在内存中构建出来。下面是表达式 2 * 7 + 3 的解析树：在上面的图片中可以看到：解析树记录了 parser 用来识别输入的一系列规则。解析树的根结点的标签是语法的开始符号(start symbol)。每个中间结点表示一个非终结符(non-terminal)，代表应用了一条语法规则，像我们的情况里的 expr, term和 factor.每个叶子结点代表了一个 token.我们不会手动构建解析树且在我们的解释器中用到它，但解析树可以通过可视化 调用过程帮助我们理解 parser 怎么解释输入。你可以使用一个名为 genptdot.py 的小应用（我很快写完用来帮助你的），来查看不同的 算术表达式看起来什么样。要使用这个应用你首先需要安装 Graphviz包，然后运行下面的 命令，你可以打开生成的图片文件 parsetree.png 查看你从命令行传入的表达式的解析树：12$ python genptdot.py \"14 + 2 * 3 - 6 / 2\" &gt; \\ parsetree.dot &amp;&amp; dot -Tpng -o parsetree.png parsetree.dot下面是由表达式 14 + 2 * 3 - 6 / 2 生成的图片 parsetree.png:抽象语法树(AST)现在我们来聊聊抽象语法树(AST)。它是在余下的文章中会大量用到的中间表示(IR)。它是 我们的解释器和未来编译器项目的核心数据结构。让我们以把表达式 2 * 7 + 3 的 AST 和解析树放在一起看来开始我们的讨论：从上面的图片中可以看出，AST 抓住了输入的精髓且更小。AST 和解析树最主要的区别有：AST 使用操作符/操作(operators/operations )作为根结点，操作数(operands)作为它们的子结点。不像解析树，AST 不使用中间结点来表示语法规则。AST 并不把真实句法中的所有结节都表示出来（这就是为什么它是抽象的）──例如，没有 规则结点和括号。对于相同的语言结构来说，AST 相比于解析树更紧凑。抽象语法树是什么？抽象语法树(AST)是表示一个语言结构的抽象句法结构的树形表示，它的中间结点和根结点代表了一个操作符，子结点代表了该操作符的操作数。看一下AST 与解析树对比，显现他的紧凑性：如何将操作符的优先级(precedence)编码进 AST 呢？为了把操作符优先级编码进 AST，即，为了表示“X 在 Y 之前发生”你只需要在树中把 X 放在低于 Y 的位置。你在前面 的图片中已经见过到了。【例子】：在下面的图片中，左边是表达式 2 * 7 + 3 的 AST。让我们用括号把 7 + 3 围起来以改变 它的优先级。在右边是修改后的表达式 2 * (7 + 3) 的 AST：代码实现AST好了，让我们写些代码来实现不同的 AST 结点类 并修改我们的 parser 来生成包含这些结点的 AST 树：首先，新建一个基本结点类叫做 AST，其他类会从它继承：12class AST(): pass #pass 不做任何事情，一般用做占位语句。因为如果定义一个空函数程序会报错，当你没有想好函数的内容是可以用 pass 填充，使程序可以正常运行。回忆一下 AST 表示了操作符-操作数模型。到现在为止，我们有4个操作符和整型操作数。操作符有加、减、乘、除。我们原本可以新建单独的类来表示每个操作符如 AddNode, SubNode, MulNode 和 DivNode，但相反我们只会新建一个 BinOp 类来表示所有 4 个二元操作符*binary operator* （二元操作符就是作用在两个操作数的操作符）：12345class BinOp(AST): def __init__(self, left, op, right): self.left = left self.token = self.op = op self.right = right构造函数的参数是 left, op, 和 right, 其中 left 和 right 分别指向了表示 左操作数和右操作数的结点。 op 保存了指向操作符本身的 token: Token(PLUS, &#39;+&#39;) 表示加操作符， Token(MINUS, &#39;-&#39;) 表示减操作符，等等。为了在 AST 中表示整数，我们定义一个 Num 类，它将保存一个 INTEGER token 和该 token 的值：1234class Num(AST): def __init__(self, token): self.token = token self.value = token.value和你注意到的一样，所有的note保存 token 从而则创建note(all nodes store the token used to create the node)。这主要是为了方便，将来会派上用场。回忆一下表达式 2 * 7 + 3 的 AST。我们会在代码中手工创建该表达式：1234567891011121314&gt;&gt;&gt; from spi import Token, MUL, PLUS, INTEGER, Num, BinOp&gt;&gt;&gt;&gt;&gt;&gt; mul_token = Token(MUL, '*')&gt;&gt;&gt; plus_token = Token(PLUS, '+')&gt;&gt;&gt; mul_node = BinOp(... left=Num(Token(INTEGER, 2)),... op=mul_token,... right=Num(Token(INTEGER, 7))... )&gt;&gt;&gt; add_node = BinOp(... left=mul_node,... op=plus_token,... right=Num(Token(INTEGER, 3))... )以下是在新定义的结点类下 AST 的样子。下面的图片也遵循了上面手工创建的过程：parser 代码下面是我们修改过的 parser 代码，在识别输入（算术表达式）时建立和返回一个 AST:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class AST(): passclass BinOp(AST): def __init__(self, left, op, right): self.left = left self.token = self.op = op self.right = rightclass Num(AST): def __init__(self, token): self.token = token self.value = token.valueclass Parser(): def __init__(self, lexer): self.lexer = lexer # set current token to the first token from the input self.current_token = self.lexer.get_next_token() def error(self): raise Exception('Invalid syntax') def eat(self, token_type): # compare the current token type with the passed token # type and if they match then \"eat\" the current token # and assign the next token to the self.current_token, # otherwise raise an exception. if self.current_token.type == token_type: self.current_token = self.lexer.get_next_token() else: self.error() def factor(self): \"\"\"factor : INTEGER | LPAREN expr RPAREN\"\"\" token = self.current_token if token.type == INTEGER: return Num(token) elif token.type == LPAREN: self.eat(LPAREN) node = self.expr() self.eat(RPAREN) return node def term(self): \"\"\"term : factor ((MUL | DIV) factor)*\"\"\" node = self.factor() while self.current_token.type in (MUL, DIV): token = self.current_token if token.type == MUL: self.eat(MUL) elif token.type == DIV: self.eat(DIV) node = BinOp(left=node, op=token, right=self.factor()) return node def expr(self): \"\"\" expr : term ((PLUS | MINUS) term)* term : factor ((MUL | DIV) factor)* factor : INTEGER | LPAREN expr RPAREN \"\"\" node = self.term() while self.current_token.type in (PLUS, MINUS): token = self.current_token if token.type == PLUS: self.eat(PLUS) elif token.type == MINUS: self.eat(MINUS) node = BinOp(left=node, op=token, right=self.term()) return node def parse(self): return self.expr()让我们看一些算术表达式的 AST 的构建过程。如果你看了上面的 parser 代码，可以看到它建立一个 AST 中的结点的时，把变量 node 的当前值做为 BinOp 结点的左子结点，把对 term 或 factor 调用的返回结果做为它 的右子结点，这实际上就是把结点推向左边，下面表达式 1 +2 + 3 + 4 + 5 的树结构就是 这种情况的一个好例子。下面是 parser 如何一步步地构建表达式 1 + 2 + 3 + 4 + 5 的 AST 的图形表示：遍历好了，下面是表达式 2 * 7 + 3 的 AST：你怎么遍历这个树并恰当地对它所代表的表达式进行求值呢？你可以使用后序遍历*postorder traversal* (深度优先遍历depth-first traversal 的一个特例) 。这种方式由根结点开始，递归由左至右访问每个结点的子结点。后序遍历从根结点开始尽可能快地访问离根结点远的结点(The postorder traversal visits nodes as far away from the root as fast as it can)。下面是后序遍历的伪代码，其中 &lt;&lt; postorder actions &gt;&gt;是一些操作的占位符，如 BinOp 结点的加减乘除操作或 Num 结点返回整数的简单操作：为什么要使用后续遍历呢？第一，我们需要对在树中更低的中间结点进行求值， 因为它们代表了优先级更高的操作符，第二，我们在对操作数 参与 对应操作符 的运算 之前需要对操作数进行求值。在下面的图片中，可以看到使用后序遍历时我们会首先对表达式 2*7 进行 求值，而只有在对 14 + 3 求值之后，我们才会得到正确答案 17:三种深度优先遍历：为了完整起见，三种深度优先遍历的方式：先序遍历，中序遍历和后序遍历。这 些遍历方式名字的来自于遍历代码中操作的位置：有时你可能需要在所有地方（先序，中序和后序）都执行一些操作。你会在本文的源代码仓 库中找到一些例子。先序遍历preorder traversal,在先序遍历中，我们先访问根节点，然后递归使用先序遍历访问左子树，再递归使用先序遍历访问右子树，即：根节点-&gt;左子树-&gt;右子树中序遍历inorder traversal,在中序遍历中，我们递归使用中序遍历访问左子树，然后访问根节点，最后再递归使用中序遍历访问右子树，即：左子树-&gt;根节点-&gt;右子树后序遍历 postorder traversal.在后序遍历中，我们先递归使用后序遍历访问左子树和右子树，最后访问根节点。 即：左子树-&gt;右子树-&gt;根节点Interpreter用代码来遍历和解释由 parser 建立的抽象语法树：好了，让我们写一些代码来遍历和解释由 parser 建立的抽象语法树，好吗？下面是实现了访问者模式的源代码：12345678class NodeVisitor(): def visit(self, node): method_name = 'visit_' + type(node).__name__ visitor = getattr(self, method_name, self.generic_visit) return visitor(node)#generic_visit 是一个备用函数，它会抛出一个异常来表示它遇到了一个实现类中没有相 应 #visit_NodeType 方法的结点。 def generic_visit(self, node): raise Exception('No visit_&#123;&#125; method'.format(type(node).__name__))NodeVisitor一个结点访问器的基类：它遍历抽象语法树并为找到的每个节点调用一个访问器函数。（这个函数可能会返回一个由visit()方法转发 的值）。This class is meant to be subclassed, with the subclass adding visitor methods.成员函数：1️⃣ visit(node)：访问一个结点。它默认调用self.visit_classname（其中的classname是结点类的名字，或者如果这个方法不存在时，classname就是 generic_visit() ）的方法。2️⃣ generic_visit(node)：这个访问器(visitor)对结点的所有子节点调用visit()。【注意：只有这个访问器调用generic_visit() 或者访问它本身，否则自定义访问器的结点的子节点将不会被访问】1getattr(object, name[, default])官方文档中说这个函数作用是返回对象的一个属性，第一个参数是对象实例obj,name是个字符串，是对象的成员函数名字或者成员变量，default当对象没有这个属相的时候就返回默认值，如果没有提供默认值就返回异常。如：提供不默认写法：1234567891011121314&gt;&gt;&gt; class Test(object):... def func(self):... print 'I am a test'...&gt;&gt;&gt; test = Test() # 实例化一个对象&gt;&gt;&gt; func = getattr(test, 'func') # 使用getattr函数获取func的值&gt;&gt;&gt; func()I am a test&gt;&gt;&gt; func = getattr(test, 'f') # 使用对象没有的属性，则会出现异常Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;AttributeError: 'Test' object has no attribute 'f'&gt;&gt;&gt;提供默认写法如果对象没有该属性可以提供一个默认值。1234&gt;&gt;&gt; func = getattr(test, 'f', None)&gt;&gt;&gt; print funcNone&gt;&gt;&gt;Interpreter 类的源代码下面是 Interpreter 类的源代码，它继承自 NodeVisitor 类且实现了形式为 visit_NodeType 的不同方法，其中 NodeType 会被如 BinOp, Num 等类名替换：12345678910111213141516class Interpreter(NodeVisitor): def __init__(self, parser): self.parser = parser def visit_BinOp(self, node): if node.op.type == PLUS: return self.visit(node.left) + self.visit(node.right) elif node.op.type == MINUS: return self.visit(node.left) - self.visit(node.right) elif node.op.type == MUL: return self.visit(node.left) * self.visit(node.right) elif node.op.type == DIV: return self.visit(node.left) / self.visit(node.right) def visit_Num(self, node): return node.value关于以上代码有两点值得在这里提一下：第一，操作 AST 结点的访问器(也就是对AST数据的操作)的代码 和 AST 结点(即，AST的数据结构)本身 分离（解耦了）。可以看到 AST 结点类(BinOp 和 Num)没有提供任何代码来操作存储在这些结点中的数据，该逻辑被封装在了实现 NodeVisitor 的 Interpreter 类中。（也就是对数据的操作在NodeVisitor 的 Interpreter 类中）。第二，在NodeVisitor的访问函数中，不像这样使用一个巨大的if语句:123456789101112131415def visit(node): node_type = type(node).__name__ if node_type == 'BinOp': return self.visit_BinOp(node) elif node_type == 'Num': return self.visit_Num(node) elif ... # ...#####或者##########def visit(node): if isinstance(node, BinOp): return self.visit_BinOp(node) elif isinstance(node, Num): return self.visit_Num(node) elif ...NodeVisitor 的 visit 方法非常通用，能根据传入的结点类型来调度适当的方法。正如前面提到的，为了利用这一点，我们的解释器继承了 NodeVisitor 类并实现了必要的方法。 因此：如果传递给 visit 函数的结点是 BinOp，那么visit 函数就会调用 visit_BinOp 方法。如果传递给 visit函数的结点是 Num,那么 visit 函数就会调用visit_Num 方 法，等等。花此时间研究一下这个方法（Python 的标准模块 ast 也使用了相同的机制来遍历结点）， 因为我们将来会用很多新的 visit_NodeType 方法来扩展我们的解释器。现在，让我们手工为表达式 2 * 7 + 3 建立一个 AST 并把它传递给解释器，通过对该表达式求值看看运行中的 visit 方法。下面是你从 Python shell 中尝试的方法：123456789101112131415161718&gt;&gt;&gt; from spi import Token, MUL, PLUS, INTEGER, Num, BinOp&gt;&gt;&gt;&gt;&gt;&gt; mul_token = Token(MUL, '*')&gt;&gt;&gt; plus_token = Token(PLUS, '+')&gt;&gt;&gt; mul_node = BinOp(... left=Num(Token(INTEGER, 2)),... op=mul_token,... right=Num(Token(INTEGER, 7))... )&gt;&gt;&gt; add_node = BinOp(... left=mul_node,... op=plus_token,... right=Num(Token(INTEGER, 3))... )&gt;&gt;&gt; from spi import Interpreter&gt;&gt;&gt; inter = Interpreter(None)&gt;&gt;&gt; inter.visit(add_node)17如你所见，我把表达式树的根结点传递给了 visit 方法，这一行为触发了树的遍历，遍历调用了 Interpreter 类正确的方法(visit_BinOp 和 visit_Num)并生成了结果。完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264\"\"\" SPI - Simple Pascal Interpreter \"\"\"# Token types## EOF (end-of-file) token is used to indicate that# there is no more input left for lexical analysisINTEGER, PLUS, MINUS, MUL, DIV, LPAREN, RPAREN, EOF = ( 'INTEGER', 'PLUS', 'MINUS', 'MUL', 'DIV', '(', ')', 'EOF')class Token(object): def __init__(self, type, value): self.type = type self.value = value def __str__(self): \"\"\"String representation of the class instance. Examples: Token(INTEGER, 3) Token(PLUS, '+') Token(MUL, '*') \"\"\" return 'Token(&#123;type&#125;, &#123;value&#125;)'.format( type=self.type, value=repr(self.value) ) def __repr__(self): return self.__str__()################################################################################ ## LEXER ## ################################################################################class Lexer(object): def __init__(self, text): # client string input, e.g. \"4 + 2 * 3 - 6 / 2\" self.text = text # self.pos is an index into self.text self.pos = 0 self.current_char = self.text[self.pos] def error(self): raise Exception('Invalid character') def advance(self): \"\"\"Advance the `pos` pointer and set the `current_char` variable.\"\"\" self.pos += 1 if self.pos &gt; len(self.text) - 1: self.current_char = None # Indicates end of input else: self.current_char = self.text[self.pos] def skip_whitespace(self): while self.current_char is not None and self.current_char.isspace(): self.advance() def integer(self): \"\"\"Return a (multidigit) integer consumed from the input.\"\"\" result = '' while self.current_char is not None and self.current_char.isdigit(): result += self.current_char self.advance() return int(result) def get_next_token(self): \"\"\"Lexical analyzer (also known as scanner or tokenizer) This method is responsible for breaking a sentence apart into tokens. One token at a time. \"\"\" while self.current_char is not None: if self.current_char.isspace(): self.skip_whitespace() continue if self.current_char.isdigit(): return Token(INTEGER, self.integer()) if self.current_char == '+': self.advance() return Token(PLUS, '+') if self.current_char == '-': self.advance() return Token(MINUS, '-') if self.current_char == '*': self.advance() return Token(MUL, '*') if self.current_char == '/': self.advance() return Token(DIV, '/') if self.current_char == '(': self.advance() return Token(LPAREN, '(') if self.current_char == ')': self.advance() return Token(RPAREN, ')') self.error() return Token(EOF, None)################################################################################ ## PARSER ## ################################################################################class AST(object): pass # 表示定义留空class BinOp(AST): def __init__(self, left, op, right): self.left = left self.token = self.op = op self.right = rightclass Num(AST): def __init__(self, token): self.token = token self.value = token.valueclass Parser(object): def __init__(self, lexer): self.lexer = lexer # set current token to the first token taken from the input self.current_token = self.lexer.get_next_token() def error(self): raise Exception('Invalid syntax') def eat(self, token_type): # compare the current token type with the passed token # type and if they match then \"eat\" the current token # and assign the next token to the self.current_token, # otherwise raise an exception. if self.current_token.type == token_type: self.current_token = self.lexer.get_next_token() else: self.error() def factor(self): \"\"\"factor : INTEGER | LPAREN expr RPAREN\"\"\" token = self.current_token if token.type == INTEGER: self.eat(INTEGER) return Num(token) elif token.type == LPAREN: self.eat(LPAREN) node = self.expr() self.eat(RPAREN) return node def term(self): \"\"\"term : factor ((MUL | DIV) factor)*\"\"\" node = self.factor() while self.current_token.type in (MUL, DIV): token = self.current_token if token.type == MUL: self.eat(MUL) elif token.type == DIV: self.eat(DIV) node = BinOp(left=node, op=token, right=self.factor()) return node def expr(self): \"\"\" expr : term ((PLUS | MINUS) term)* term : factor ((MUL | DIV) factor)* factor : INTEGER | LPAREN expr RPAREN \"\"\" node = self.term() while self.current_token.type in (PLUS, MINUS): token = self.current_token if token.type == PLUS: self.eat(PLUS) elif token.type == MINUS: self.eat(MINUS) node = BinOp(left=node, op=token, right=self.term()) return node def parse(self): return self.expr()################################################################################ ## INTERPRETER ## ################################################################################class NodeVisitor(object): def visit(self, node): method_name = 'visit_' + type(node).__name__ visitor = getattr(self, method_name, self.generic_visit) return visitor(node) def generic_visit(self, node): raise Exception('No visit_&#123;&#125; method'.format(type(node).__name__))class Interpreter(NodeVisitor): def __init__(self, parser): self.parser = parser def visit_BinOp(self, node): if node.op.type == PLUS: return self.visit(node.left) + self.visit(node.right) elif node.op.type == MINUS: return self.visit(node.left) - self.visit(node.right) elif node.op.type == MUL: return self.visit(node.left) * self.visit(node.right) elif node.op.type == DIV: return self.visit(node.left) / self.visit(node.right) def visit_Num(self, node): return node.value def interpret(self): tree = self.parser.parse() return self.visit(tree)def main(): while True: try: try: text = raw_input('spi&gt; ') except NameError: # Python3 text = input('spi&gt; ') except EOFError: break if not text: continue lexer = Lexer(text) parser = Parser(lexer) interpreter = Interpreter(parser) result = interpreter.interpret() print(result)if __name__ == '__main__': main()将以上代码保存到名为 spi.py 的文件中，或者直接从 GitHub 下载。自己试一试，确认 你的新的基于树的解释器可以正确地对算术表达式进行求值。下面是某次运行过程：1234567$ python spi.pyspi&gt; 7 + 3 * (10 / (12 / (3 + 1) - 1))22spi&gt; 7 + 3 * (10 / (12 / (3 + 1) - 1)) / (2 + 3) - 5 - 3 + (8)10spi&gt; 7 + (((3 + 2)))12小结今天你学习了关于解析树和 AST，如何构建 AST 以及遍历表示输入的 AST 并解释执行。你还修改了 parser 和 interpreter 并将这两部分解开了。现在 lexer, parser 和 interpreter 之间的接口看起来像这样：lsbasi_part7_pipeline你可以把它读作“parser 从 lexer 中 得到 token 然后返回生成的 AST 给 Interpreter 进行遍历并解释执行所给输入”。递归这就是今天的所有内容，但在总结之前我还想简单地聊一聊递归下降 (recursive-descent) parser，即是仅仅给出它的定义。定义就是：一个 递归下降parser 就 是一个自顶向下的 parser，它使用一组递归过程来处理输入。自顶向下反映了 parser 从 构建解析树的顶部结点开始逐渐构建更低的结点这一事实。梳理本节与part5相比主要添加了AST：Lexer与part5中的是一样的，还是将输入的text分析转换为token。(这也是词法分析器的功能)Parser相比part5，它添加了构造AST的内容：添加了三个类：AST()：是一个基类BinOp(AST)：继承于AST()，主要功能是实现二元操作符binary operator 。（这里只有四种：加、减、乘、除法）Num(AST)：继承于AST()，它主要是表示AST中的整数integer token（它将保存一个 INTEGER token 和该 token 的值）第二个变化就是实现语法解析的这三个函数term、factor、expr中的返回的不在是result变量了，而是返回一个结点node。Interpreter：通过词法分析、语法分析之后，开始解释语法分析之后的算式，计算出它的结果，用Interpreter来解释：增添了访问者模式：将 对数据的操作(对数据的操作在interpreter中完成：访问、解释) 和 数据结构(数据结构 在parser中的三个类中构建) 进行分离（解耦合）。使得操作集合可相对自由地演化。这里通过创建 NodeVisitor()类 实现访问者模式。实现了通过什么方式去访问生成的AST又通过Interpreter（继承于 NodeVisitor()类）来实现解释生成的AST最后，再次提醒一下：之前的那几小结，我们都是把interpreter的代码和parser的代码混在一起，但这一小节我们把interpreter的代码和parser的代码分开了。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let's Build A Simple Interpreter","slug":"Let-s-Build-A-Simple-Interpreter","permalink":"https://www.longlongqin.top/tags/Let-s-Build-A-Simple-Interpreter/"}]},{"title":"Let’s Build A Simple Interpreter 6","slug":"学习笔记/Let's Build A Simple Interpreter1/LSBASI-6","date":"2020-03-12T04:55:57.000Z","updated":"2020-03-17T09:40:01.085Z","comments":true,"path":"archives/167c.html","link":"","permalink":"https://www.longlongqin.top/archives/167c.html","excerpt":"新增了括号运算(parenthesized expressions)","text":"新增了括号运算(parenthesized expressions)原文链接：https://ruslanspivak.com/lsbasi-part6/本文在前面的基础上，新增了括号运算(parenthesized expressions)，如： 7 + 3 * (10 / (12 / (3 + 1) - 1))所以需要在part5中的语法基础上，进行修改，修改后的语法如下图：从上面的图可以看出来,在part6中，expr和term和part5中一样，唯一变的是factor的产生式 (production)。它新添加了两个 terminal ：LPAREN：表示一个左括号 left parenthesis ‘( ‘RPAREN：表示一个右括号 right parenthesis ‘)’还新添加了一个非终端符：exprexpr添加在两个括号之间下面是factor的语法图：（这里用到了递归）然后，再放一下没有改变的（与part5相同）expr、term的语法图：现在看一下算式：2 * (7 + 3) 的分解过程吧：现在把语法转换成代码。下面这两条是代码中主要改变的部分：Lexer被修改，使其在原来的基础上可以返回另外两个token：左括号LPAREN 、右括号RPARENInterpreter类的factor被修改，修改之后不仅可以解析整数integer，还可以解析括号表达式(parenthesized expressions)下面就是本小节的代码部分：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194# Token types## EOF (end-of-file) token is used to indicate that# there is no more input left for lexical analysisINTEGER, PLUS, MINUS, MUL, DIV, LPAREN, RPAREN, EOF = ( 'INTEGER', 'PLUS', 'MINUS', 'MUL', 'DIV', '(', ')', 'EOF')class Token(object): def __init__(self, type, value): self.type = type self.value = value def __str__(self): \"\"\"String representation of the class instance. Examples: Token(INTEGER, 3) Token(PLUS, '+') Token(MUL, '*') \"\"\" return 'Token(&#123;type&#125;, &#123;value&#125;)'.format( type=self.type, value=repr(self.value) ) def __repr__(self): return self.__str__()class Lexer(object): def __init__(self, text): # client string input, e.g. \"4 + 2 * 3 - 6 / 2\" self.text = text # self.pos is an index into self.text self.pos = 0 self.current_char = self.text[self.pos] def error(self): raise Exception('Invalid character') def advance(self): \"\"\"Advance the `pos` pointer and set the `current_char` variable.\"\"\" self.pos += 1 if self.pos &gt; len(self.text) - 1: self.current_char = None # Indicates end of input else: self.current_char = self.text[self.pos] def skip_whitespace(self): while self.current_char is not None and self.current_char.isspace(): self.advance() def integer(self): \"\"\"Return a (multidigit) integer consumed from the input.\"\"\" result = '' while self.current_char is not None and self.current_char.isdigit(): result += self.current_char self.advance() return int(result) def get_next_token(self): \"\"\"Lexical analyzer (also known as scanner or tokenizer) This method is responsible for breaking a sentence apart into tokens. One token at a time. \"\"\" while self.current_char is not None: if self.current_char.isspace(): self.skip_whitespace() continue if self.current_char.isdigit(): return Token(INTEGER, self.integer()) if self.current_char == '+': self.advance() return Token(PLUS, '+') if self.current_char == '-': self.advance() return Token(MINUS, '-') if self.current_char == '*': self.advance() return Token(MUL, '*') if self.current_char == '/': self.advance() return Token(DIV, '/') if self.current_char == '(': self.advance() return Token(LPAREN, '(') if self.current_char == ')': self.advance() return Token(RPAREN, ')') self.error() return Token(EOF, None)class Interpreter(object): def __init__(self, lexer): self.lexer = lexer # set current token to the first token taken from the input self.current_token = self.lexer.get_next_token() def error(self): raise Exception('Invalid syntax') def eat(self, token_type): # compare the current token type with the passed token # type and if they match then \"eat\" the current token # and assign the next token to the self.current_token, # otherwise raise an exception. if self.current_token.type == token_type: self.current_token = self.lexer.get_next_token() else: self.error() def factor(self): \"\"\"factor : INTEGER | LPAREN expr RPAREN\"\"\" token = self.current_token if token.type == INTEGER: self.eat(INTEGER) return token.value elif token.type == LPAREN: self.eat(LPAREN) result = self.expr() self.eat(RPAREN) return result def term(self): \"\"\"term : factor ((MUL | DIV) factor)*\"\"\" result = self.factor() while self.current_token.type in (MUL, DIV): token = self.current_token if token.type == MUL: self.eat(MUL) result = result * self.factor() elif token.type == DIV: self.eat(DIV) result = result / self.factor() return result def expr(self): \"\"\"Arithmetic expression parser / interpreter. calc&gt; 7 + 3 * (10 / (12 / (3 + 1) - 1)) 22 expr : term ((PLUS | MINUS) term)* term : factor ((MUL | DIV) factor)* factor : INTEGER | LPAREN expr RPAREN \"\"\" result = self.term() while self.current_token.type in (PLUS, MINUS): token = self.current_token if token.type == PLUS: self.eat(PLUS) result = result + self.term() elif token.type == MINUS: self.eat(MINUS) result = result - self.term() return resultdef main(): while True: try: # To run under Python3 replace 'raw_input' call # with 'input' text = raw_input('calc&gt; ') except EOFError: break if not text: continue lexer = Lexer(text) interpreter = Interpreter(lexer) result = interpreter.expr() print(result)if __name__ == '__main__': main()","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let's Build A Simple Interpreter","slug":"Let-s-Build-A-Simple-Interpreter","permalink":"https://www.longlongqin.top/tags/Let-s-Build-A-Simple-Interpreter/"}]},{"title":"Let’s Build A Simple Interpreter 5","slug":"学习笔记/Let's Build A Simple Interpreter1/LSBASI-5","date":"2020-03-11T09:45:49.000Z","updated":"2020-03-17T09:39:19.525Z","comments":true,"path":"archives/173c.html","link":"","permalink":"https://www.longlongqin.top/archives/173c.html","excerpt":"本文为这一系列的part5，第五小节。这次将写一个可移植性加减乘除混合运算的解释器。","text":"本文为这一系列的part5，第五小节。这次将写一个可移植性加减乘除混合运算的解释器。原文链接：https://ruslanspivak.com/lsbasi-part5/本文为这一系列的part5，第五小节。这次将写一个可移植性加减乘除混合运算的解释器。在开始写代码之前，我们需要知道一些，比如：结合律、操作符(operator)的优先级(precedence)结合律(associativity)比如，7+3+1等同于(7+3)+1 ，7 - 3 - 1 等同于 (7 - 3) - 1。这没有什么奇怪的。但是再比如： 7 - 3 - 1 与 7 - (3 - 1) 的结果就不一样了。其实：加、减、乘、除 这些操作符(operator)是左结合(left-associative)。比如， 7 + 3 + 1 中的 操作数(operand) 3，它的左右都是 加号 ，但是这个操作数3是与它左边的加号“+”结合的， 所以加法是左结合。那加减乘除混合时，如 7 + 5 * 2 是否还是遵循左结合律呢？很显然，不遵循，因为 (7 + 5) * 2 不等于 7 + 5 * 2 。由此可知：​ 加法和减法是一类，所以它们在一起组成的运算是左结合；乘法和除法是一类，所以他们在一起组成的运算是左结合。（即，左结合律只适用于同一类的操作符(operator)）优先级(precedence)那我们如何规定这种加减乘除（这两类操作符(operator)）同时出现时的运算规则呢？（实际上我们都知道，但是这里是为实现代码来做出一种运算规则）在 7 + 5 * 2中，如果操作符“”能先比操作符“+”到他的操作数5，就说，操作符“”有更高的优先级(higher precedence)。在实际中我们也在用，也知道。乘除的优先级要高于加减法。好了，现在我们开始用表格来表示操作符的结合律与优先级：由上表可知：+ and - 是优先级相同，都是左结合；* and / 优先级相同，也都是左结合；我们还可以根据上面的优先级表格来制定一个语法规则：优先级相同的每一级都定义一个非终端符(non-terminal)。其中每个产生式(production)的body中应该包含:算数运算符(arithmetic operators) &amp; 非终端符(这里的非终端又参与构成下一较高的优先级的规则(产生式)的一部分)创建一个表示 基本表达式的非终端符factor，本文中指integer。一般的规则是：如果你有N个优先级，那么你就需要N+1个非终端符（一类是每一层优先级的一个非终端符，一类是表示基本表达式单元）构建语法(grammars)现在根据上面的规则来构建语法：由规则1，我们将定义两个非终结符(non-terminal)，一个是leve1的non-terminal叫做expr，另一个是level2的non-terminal叫做term。然后根据规则2，我们需要定义一个叫做factor的non-terminal来作为一个基本的表达式单元，integers。这个语法的开始符号（start symbol ）叫做expr。它的产生式(production)的body含有：1️⃣表示level2的操作符(在这指的是+ and - )，2️⃣和一个非终端符term(这个term是下一层优先级（更高的）level1 的一个产生式)开始符号（S）：最大的语法单位 或 最重要的语法单位。（如上面的那个英文句子中的，最大的语法单位是：句子。）非终端符term的production(产生式)的body包含:1️⃣表示level1的操作符(在这指的是 * and /)。2️⃣还有一个非终端符factor来表示基本的表达式单元，integers非终端符factor包含：1️⃣一个integer上面的三幅图是语法、语法图的一部分，这在之前的文章中也出现过。但现在需要将上面的三幅图结合在一起来考虑结合律和优先级（ associativity and precedence ）下面是本文的语法对应的语法图：上面语法图的每一个小方框都是其他语法图的：函数调用（“method call”）。如果你以表达式 7 + 5 * 2 为例并从顶 层图 expr 开始逐步分解到最底层的图 factor, 你应该可以看到位于中间的图的高优 先级操作符*和/会比上面的图的操作符+和-先执行。为了解释清楚运算符的优先级，让我们看看使用上面语法和句法图来分解相同算术表达式 7 + 5 * 2 的过程。这只是另一种展示高优先级运算符 先于 低优先级运算符执行这个事实的 方式。语法转换成代码让我们使用part 4中的准则把该语法转化成代码，看看它怎么工作，先看一张上面放过的语法图：下面是能处理可以包含任意数量加减乘除操作符的算术表达式的计算器的完整代码。相比于part 4代码的主要变化有：Lexer 类现在可以把+,-,*和/都 token 化了（没什么新方法，我们只是把前面文章中 的代码合并到一个类中来支持所有这些 token）回想语法中的每条规则（产生式）R都要变成一个同名的方法，且对该规则的引用都要变 成一个方法调用 R() 这一点。现在 Interpreter 类有了三个方法来对应语法中的非 终结符： expr, term, factor.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182# Token types## EOF (end-of-file) token is used to indicate that# there is no more input left for lexical analysisINTEGER, PLUS, MINUS, MUL, DIV, EOF = ( 'INTEGER', 'PLUS', 'MINUS', 'MUL', 'DIV', 'EOF')class Token(object): def __init__(self, type, value): # token type: INTEGER, PLUS, MINUS, MUL, DIV, or EOF self.type = type # token value: non-negative integer value, '+', '-', '*', '/', or None self.value = value def __str__(self): \"\"\"String representation of the class instance. Examples: Token(INTEGER, 3) Token(PLUS, '+') Token(MUL, '*') \"\"\" return 'Token(&#123;type&#125;, &#123;value&#125;)'.format( type=self.type, value=repr(self.value) ) def __repr__(self): return self.__str__()class Lexer(object): def __init__(self, text): # client string input, e.g. \"3 * 5\", \"12 / 3 * 4\", etc self.text = text # self.pos is an index into self.text self.pos = 0 self.current_char = self.text[self.pos] def error(self): raise Exception('Invalid character') def advance(self): \"\"\"Advance the `pos` pointer and set the `current_char` variable.\"\"\" self.pos += 1 if self.pos &gt; len(self.text) - 1: self.current_char = None # Indicates end of input else: self.current_char = self.text[self.pos] def skip_whitespace(self): while self.current_char is not None and self.current_char.isspace(): self.advance() def integer(self): \"\"\"Return a (multidigit) integer consumed from the input.\"\"\" result = '' while self.current_char is not None and self.current_char.isdigit(): result += self.current_char self.advance() return int(result) def get_next_token(self): \"\"\"Lexical analyzer (also known as scanner or tokenizer) This method is responsible for breaking a sentence apart into tokens. One token at a time. \"\"\" while self.current_char is not None: if self.current_char.isspace(): self.skip_whitespace() continue if self.current_char.isdigit(): return Token(INTEGER, self.integer()) if self.current_char == '+': self.advance() return Token(PLUS, '+') if self.current_char == '-': self.advance() return Token(MINUS, '-') if self.current_char == '*': self.advance() return Token(MUL, '*') if self.current_char == '/': self.advance() return Token(DIV, '/') self.error() return Token(EOF, None)class Interpreter(object): def __init__(self, lexer): self.lexer = lexer # set current token to the first token taken from the input self.current_token = self.lexer.get_next_token() def error(self): raise Exception('Invalid syntax') def eat(self, token_type): # compare the current token type with the passed token # type and if they match then \"eat\" the current token # and assign the next token to the self.current_token, # otherwise raise an exception. if self.current_token.type == token_type: self.current_token = self.lexer.get_next_token() else: self.error() def factor(self): \"\"\"factor : INTEGER\"\"\" token = self.current_token self.eat(INTEGER) return token.value def term(self): \"\"\"term : factor ((MUL | DIV) factor)*\"\"\" result = self.factor() while self.current_token.type in (MUL, DIV): token = self.current_token if token.type == MUL: self.eat(MUL) result = result * self.factor() elif token.type == DIV: self.eat(DIV) result = result / self.factor() return result def expr(self): \"\"\"Arithmetic expression parser / interpreter. calc&gt; 14 + 2 * 3 - 6 / 2 17 expr : term ((PLUS | MINUS) term)* term : factor ((MUL | DIV) factor)* factor : INTEGER \"\"\" result = self.term() while self.current_token.type in (PLUS, MINUS): token = self.current_token if token.type == PLUS: self.eat(PLUS) result = result + self.term() elif token.type == MINUS: self.eat(MINUS) result = result - self.term() return resultdef main(): while True: try: # To run under Python3 replace 'raw_input' call # with 'input' text = raw_input('calc&gt; ') except EOFError: break if not text: continue lexer = Lexer(text) interpreter = Interpreter(lexer) result = interpreter.expr() print(result)if __name__ == '__main__': main()将以上代码保存到名为 calc5.py 中，或者直接从 GitHub 上下载。和以往一样，自己尝 试一下，确认解释器可以对包含不同优先级操作符的算术表达式进行求值。梳理代码中有三个类(class)，他们中的函数及作用：Token：__init__：初始化实例__str__：字符串形式__repr__：字符串形式在Python中，所有以“_”双下划线包起来的方法，都统称为“Magic Method”（魔术方法）,例如类的初始化方法 __init_repr(self)定义当被 repr() 调用时的行为str(self)定义当被 str() 调用时的行为Lexer用于词法分析：__init__：初始化实例error：错误提示advance：使pos前进一个位置skip_whitespace：略过空格integer：识别整数（可以识别多位数）get_next_token：获得一个token（其实我觉得叫做：get_token_and_to_next更合适）Interpreter用于语法分析：__init__：初始化实例error：错误提示eat：负责检测当前的token.type与传入的token_type是否相同。若相同，则将当前的token“吃了”，然后把当前token的下一个token分配给current_token。下面就是语法分析的核心了，由上面的分析直到，它由：expr、term、factor构成。梳理完毕。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let's Build A Simple Interpreter","slug":"Let-s-Build-A-Simple-Interpreter","permalink":"https://www.longlongqin.top/tags/Let-s-Build-A-Simple-Interpreter/"}]},{"title":"Let’s Build A Simple Interpreter 4","slug":"学习笔记/Let's Build A Simple Interpreter1/LSBASI-4","date":"2020-03-10T09:27:30.000Z","updated":"2020-03-17T08:39:30.795Z","comments":true,"path":"archives/3b16.html","link":"","permalink":"https://www.longlongqin.top/archives/3b16.html","excerpt":"听而易忘，见而易忘，做而易懂","text":"听而易忘，见而易忘，做而易懂原文链接：https://ruslanspivak.com/lsbasi-part4/在前面的文章中你学会了怎样识别和解释包含任意数量的加减操作的算术表达式，例如“7 - 3 + 2 - 1”。还学会了句法图以及它们如何被用来表示一门编程语言的语法。今天你将会学习解析(parse)和解释(interpret)包含任意乘除操作的算术表达式，例如“7 * 4 / 2 * 3”。在这篇文章中使用的是整数除法，所以对于表达式“9 / 4”来说，结果是一个 整数：2。我今天会讲很多另一个表示编程语言句法的广泛使用的表示法，叫 上下文无关语法 (context-free grammars, 简记为 grammars)或 BNF (Backus-Naur Form)。为了这篇文章的目的，我不会使用纯 BNF 记法，而更像是一个修改过的 EBNF 记法。以下是一些使用语法的原因：语法使用了一种简明的方式来描述一门编程语言的句法。不像语法图，语法非常紧凑。 在以后的文章中，你会看到我越来越多地使用语法。语法可以做为文档保存。即使对从头开始写解析器(parser)来说，语法也是一个好的入手点。很多时候通过遵循 一套简单的规则你就可以把语法转化成代码。有一套工具，叫解析器生成器(parser generator)，可以把语法做为输入并自动根据它为你生成一个解析器。我会以后在这个系列中谈到这些工具。语法机制现在，我们来聊聊语法的机制方面：下面的语法描述了算术表达式，像“7 * 4 / 2 * 3”这样的（这只是该语法可以生成的许多表达式之一）：语法是由一系列规则组成的，也被称为产生式(production)。我们的语法中有两条规则(产生式)：1、一条规则由一个非终结符(叫做 head或生成式的左边) + 一个分号（:）+ 一系列终结符 和/或 非终结符(叫做 body 或 右边)：2、在上面展示的语法中，像 MUL, DIV, 或 INTEGER 这样的 token 被称为 终结符(terminals), expr factor 这样的变量被称为 非终结符(not-terminals).第一条规则左边的非终结符被叫做 开始符号(start symbol). 在我们的语法中，开始符号是 expr:你可以这么理解 expr 这条规则：“expr 是一个 factor 后面可选地跟一个乘或除运算符再跟 另一个 factor，后面也相应可选地跟一个乘或除运算符再跟另一个 factor，如此重复”。factor 是什么？对于本文来说 factor 就是一个整数。语法中的符号让我们快速地过一遍语法中的符号及它们的意义。|多选一。竖线表示“或”。所以 (MUL | DIV) 表示 MUL 或 DIV(...)被括号包围表示把终结符 和/或 非终结符组成一组，就像 (MUL | DIV)(...)*分组中的内容被匹配 0 或 多次。语法通过解释可以组成什么样的句子来定义一门语言。通过语法派生出算术表达式的方式为：首先从开始符号 expr 开始，然后反复地使用所包含的非终结符的规则替换该非终结符， 直到生成一个只包含终结符的句子。语法能组成的句子构成了一门语言。下面举例说明：例1，下面是语法如何派生出表达式 3:例2，下面是语法如何派生出表达式 3 * 7:例3，下面是语法如何派生出表达式 3 * 7 / 2:将语法变成代码下面是一些我们在把语法转化成源代码时会用到的==四个准则==。按照这些准则，你真的就可以把语法翻译成一个可工作的 parser:对于语法中定义的每个规则 R，将它做成一个有相同名字的方法，对该规则的引用就变成了一个方法调用：R()。该方法的方法体遵循该规则的步骤，过程中使用相同的准则。多选一 (a1|a2|aN) 变成 if-elif-else 语句可选组 (...)* 变成一个可以执行 0 或多次的 while 循环（can loop over zero or more times）每个 Token 记为 T 变成一个 eat 方法调用: eat(T). eat 方法的工作是 当它匹配到当前的向前看 (lookahead) token 就消耗掉它，然后从 lexer 中得到一个新 token 并将它赋值给内部变量 current_token.这些准则看上去像这样：让我们继续并遵循上述准则把我们的语法转化为代码。我们的语法中有两条规则： expr 和 factor. 我们从 factor 规则（生成式）开始。 根据准则，需要新建一个名为 factor 的方法（准则1)，它调用了一次 eat 方法来消耗INTEGER token （准则4)：12def factor(self): #factor就是指的integer型数值 self.eat(INTEGER)expr 规则变成了 expr 方法（还是准则1）。规则体(body)开始的 factor 引用 变成了对 factor() 方法的调用。可行组 (...)* 变成了一个 while 循环，多选一 (MUL|DIV) 变成了一个 if-elif-else 语句。把这些片段合并在一起就得到了下面的expr 方法：1234567891011def expr(self): self.factor() #语法准则中的第一个factor while self.current_token.type in (MUL, DIV): token = self.current_token if token.type == MUL: self.eat(MUL) self.factor() elif token.type == DIV: self.eat(DIV) self.factor()原作者将本文的代码放在了文件 parser.py 中，它包含了 lexer 和 parser 但没有interpreter。你可以直接从 GitHub下载并尝试一下。它包含有一个 interpreter 提示符，你可以输入表达式来查看它是否合法，即查看根据语法建立的 parser 是否可以识别出表达式。下面是在我笔记本上的一次尝试：123456789101112131415161718192021$ python parser.pycalc&gt; 3calc&gt; 3 * 7calc&gt; 3 * 7 / 2calc&gt; 3 *Traceback (most recent call last): File \"parser.py\", line 155, in &lt;module&gt; main() File \"parser.py\", line 151, in main parser.parse() File \"parser.py\", line 136, in parse self.expr() File \"parser.py\", line 130, in expr self.factor() File \"parser.py\", line 114, in factor self.eat(INTEGER) File \"parser.py\", line 107, in eat self.error() File \"parser.py\", line 97, in error raise Exception('Invalid syntax')Exception: Invalid syntax这里再次提起语法图。这是相同的 expr 规则（也叫，产生式(production)）对应的句法图：下面是原作者的关于本文的源码。下面是可以处理包含任意数量整数 乘除（整数除法）操作的合法的算术表达式的计算器代码。这里把词法分析器重构 到了一个单独的类 Lexer 中，并让 Interpreter 类使用 Lexer 实例做为参数：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156# Token types## EOF (end-of-file) token is used to indicate that# there is no more input left for lexical analysisINTEGER, MUL, DIV, EOF = 'INTEGER', 'MUL', 'DIV', 'EOF'class Token(object): def __init__(self, type, value): # token type: INTEGER, MUL, DIV, or EOF self.type = type # token value: non-negative integer value, '*', '/', or None self.value = value def __str__(self): \"\"\"String representation of the class instance. Examples: Token(INTEGER, 3) Token(MUL, '*') \"\"\" return 'Token(&#123;type&#125;, &#123;value&#125;)'.format( type=self.type, value=repr(self.value) ) def __repr__(self): return self.__str__()#词法分析class Lexer(object): def __init__(self, text): # client string input, e.g. \"3 * 5\", \"12 / 3 * 4\", etc self.text = text # self.pos is an index into self.text self.pos = 0 self.current_char = self.text[self.pos] def error(self): raise Exception('Invalid character') def advance(self): \"\"\"Advance the `pos` pointer and set the `current_char` variable.\"\"\" self.pos += 1 if self.pos &gt; len(self.text) - 1: self.current_char = None # Indicates end of input else: self.current_char = self.text[self.pos] def skip_whitespace(self): while self.current_char is not None and self.current_char.isspace(): self.advance() def integer(self): \"\"\"Return a (multidigit) integer consumed from the input.\"\"\" result = '' while self.current_char is not None and self.current_char.isdigit(): result += self.current_char self.advance() return int(result) #不如叫做：get_token_and_next def get_next_token(self): \"\"\"Lexical analyzer (also known as scanner or tokenizer) This method is responsible for breaking a sentence apart into tokens. One token at a time. \"\"\" while self.current_char is not None: if self.current_char.isspace(): self.skip_whitespace() continue if self.current_char.isdigit(): return Token(INTEGER, self.integer()) if self.current_char == '*': self.advance() return Token(MUL, '*') if self.current_char == '/': self.advance() return Token(DIV, '/') self.error() return Token(EOF, None)class Interpreter(object): def __init__(self, lexer): self.lexer = lexer # set current token to the first token taken from the input self.current_token = self.lexer.get_next_token() def error(self): raise Exception('Invalid syntax') def eat(self, token_type): # compare the current token type with the passed token # type and if they match then \"eat\" the current token # and assign the next token to the self.current_token, # otherwise raise an exception. if self.current_token.type == token_type: self.current_token = self.lexer.get_next_token() else: self.error() def factor(self): \"\"\"Return an INTEGER token value. factor : INTEGER \"\"\" token = self.current_token self.eat(INTEGER) return token.value def expr(self): \"\"\"Arithmetic expression parser / interpreter. expr : factor ((MUL | DIV) factor)* factor : INTEGER \"\"\" result = self.factor() while self.current_token.type in (MUL, DIV): token = self.current_token if token.type == MUL: self.eat(MUL) result = result * self.factor() elif token.type == DIV: self.eat(DIV) result = result / self.factor() return resultdef main(): while True: try: # To run under Python3 replace 'raw_input' call # with 'input' text = raw_input('calc&gt; ') except EOFError: break if not text: continue lexer = Lexer(text) interpreter = Interpreter(lexer) result = interpreter.expr() print(result)if __name__ == '__main__': main()将以上代码保存到名为 calc4.py 中，或者直接从 GitHub 上下载。和以往一样，自己尝 试一下，确认它能工作。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let's Build A Simple Interpreter","slug":"Let-s-Build-A-Simple-Interpreter","permalink":"https://www.longlongqin.top/tags/Let-s-Build-A-Simple-Interpreter/"}]},{"title":"Let’s Build A Simple Interpreter 3","slug":"学习笔记/Let's Build A Simple Interpreter1/LSBASI-3","date":"2020-03-10T06:28:09.000Z","updated":"2020-03-17T08:39:55.655Z","comments":true,"path":"archives/f957.html","link":"","permalink":"https://www.longlongqin.top/archives/f957.html","excerpt":"实现加减法混合运算","text":"实现加减法混合运算原文链接：https://ruslanspivak.com/lsbasi-part3/目前为止，你已经学习了如何解释整数相加或相减的算术表达式如“7+3”或“12-9”。今天我 会聊一聊怎样解析（识别）并解释包含多位整数的加减法的算术表达式，如“7 - 3 + 2 - 1”。语法图本文中的算术表达式可以用如下的语法图(syntax diagram)表示：语法图(syntax diagram)：就是程序语言句法规则的图形表示。基本上，语法图从视觉上向你展示了在你的程序语言中哪些语句是允许的哪些是不允许的。句法图很容易阅读：只需跟随箭头所指示的路径即可。一些路径表示选择，一些路径表示循环。你可以这样阅读上面的句法图：一个 term 后面可以跟一个加号或减号，后面又跟另一个 term， 相应地它后面又可以跟一个加号或减号，后面又跟另一个 term，如此循环。你已经读懂了 这幅图片，真的。你可能会疑惑什么是“term”。在这篇文章中“term”就是一个整数。语法图的用途本文中的语法图主要有两个用途：从图形上表示一个编程语言的标准（语法）。用来帮助你编写parser(语法分析器)，你可以通过下面简单的规则将图映射到代码。语法分析器你已经学过了从 token 流中识别组合的过程叫 parsing. 且解释器或编译器中执行这部分任务的叫 parser. parsing也被称为 语法分析 (syntax analysis)，parser也相应地被称为语法分析器(syntax analyzer)，你应该也猜到这点了。根据上面的句法图，下面所有的算术表达式都是合法的：33 + 47 - 3 + 2 - 1因为在不同的程序语言中算术表达式的句法规则都相似，我们可以使用 Python shell 来 “测试”我们的句法图。启动 Python shell 自己试一下：123456&gt;&gt;&gt; 33&gt;&gt;&gt; 3 + 47&gt;&gt;&gt; 7 - 3 + 2 - 15一切正常。但表达式“3+”就不是合法的算术表达式，因为根据句法图加号后面必须跟一个 term（整数）， 否则就是句法错误。两次启动 Python shell 自己查看结果：12345&gt;&gt;&gt; 3 + File \"&lt;stdin&gt;\", line 1 3 + ^SyntaxError: invalid syntax使用 Python shell 来做测试是挺不错的，不过我们还是把上面的句法图映射到代码，用我 们自己的解释器来测试，是吧？从前面的文章（第一部分和第二部分）你知道了 parser 和 interpreter 都在 expr 方 法中。再重复一下，parser只是识别出结构并保证它符合某些规范，interpreter在parser成功识别后对表达式进行求值。下面的代码片段展示了与句法图相对应的 parser 的代码。语法图中的矩形盒子变成了解析一个整数的 term 方法， expr 方法则只是跟随了语法图的指示：123456789101112131415def term(self): self.eat(INTEGER)def expr(self): # set current token to the first token taken from the input self.current_token = self.get_next_token() self.term() while self.current_token.type in (PLUS, MINUS): token = self.current_token if token.type == PLUS: self.eat(PLUS) self.term() elif token.type == MINUS: self.eat(MINUS) self.term()可以看到 expr 方法首先调用了 term 方法。然后是一个可能执行 0 或多次的循环。 在循环中，parser 根据 token （是加号还是减号）来做选择。Parser 本身并不解释任何事：如果识别到一个表达式它就沉默，否则就抛出一个句法错误。 让我们修改 expr 方法来添加 interpreter 代码：12345678910111213141516171819202122def term(self): \"\"\"Return an INTEGER token value\"\"\" token = self.current_token self.eat(INTEGER) return token.valuedef expr(self): \"\"\"Parser / Interpreter\"\"\" # set current token to the first token taken from the input self.current_token = self.get_next_token() result = self.term() while self.current_token.type in (PLUS, MINUS): token = self.current_token if token.type == PLUS: self.eat(PLUS) result = result += self.term() elif token.type == MINUS: self.eat(MINUS) result = result - self.term() return result因为 interpreter 需要对表达式进行求值，所以 term 方法被修改为返回一个整数值， expr 方法被修改为在适当的地方执行加减法并返回解释的结果。让我们继续前进，来看一下现在解释器的完整代码怎么样？下面是你新版计算器的源代码，它可以处理包含任意多个整数的加减操作的合法算术表达式：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128# Token的类型：'INTEGER', 'PLUS', 'MINUS', 'EOF'# Token的值(value)：整数，'+', '-', or NoneINTEGER, PLUS, MINUS, EOF = 'INTEGER', 'PLUS', 'MINUS', 'EOF'#定义Token类class Token(object): def __init__(self, type, value): self.type = type self.value = value def __str__(self): return 'Token( &#123;type&#125;, &#123;value&#125; ) ' .format( type = self.type , value = repr(self.value) #repr与下面的__repr__不一样，下面的是重构的。 ) def __repr__(self): return self.__str__()class Interpreter(object): def __init__(self, text): self.text = text self.pos = 0 self.currrent_token = None #此时还没有token实例所以是None self.current_char =self.text[self.pos] ########################################################## # Lexer code # ########################################################## def error(self): raise Exception('Invalid syntax') def advance(self): self.pos += 1 if self.pos &gt; len(self.text) -1 : self.current_char =None else: self.current_char = self.text[self.pos] def skip_whitespace(self): while self.current_char is not None and self.current_char.isspace(): self.advance() def integer(self): result = '' while self.current_char is not None and self.current_char.isdigit(): result += self.current_char self.advance() return int(result) #词法分析(分析之后形成一个个的token) def get_next_token(self): while self.current_char is not None: if self.current_char.isspace(): self.skip_whitespace() continue #识别整数 if self.current_char.isdigit(): return Token(INTEGER, self.integer() ) # 识别是否为+ - 运算符号 if self.current_char == '+': self.advance() return Token(PLUS, '+') if self.current_char == '-': self.advance() return Token(MINUS, '-') self.error() return Token(EOF, None) ########################################################## # Parser / Interpreter code # ########################################################## #比较当前的token的类型与传来的类型是否相同 def eat(self, token_type): if self.currrent_token.type == token_type: self.currrent_token = self.get_next_token() else: self.error() #返回一个整型的token的value def term(self): token = self.currrent_token self.eat(INTEGER) return token.value def expr(self): self.currrent_token = self.get_next_token() result = self.term() while self.currrent_token.type in (PLUS , MINUS): #循环是为了算不止一次的加or减法，从而达到混合运算的目的 token = self.currrent_token if token.type == PLUS: self.eat(PLUS) result = result + self.term() elif token.type == MINUS: self.eat(MINUS) result = result - self.term() return result def main(): while True: try: # To run under Python3 replace 'raw_input' call # with 'input' text = input('calc&gt; ') except EOFError: break if not text: continue interpreter = Interpreter(text) result = interpreter.expr() print(result)if __name__ == '__main__': main()将以上代码保存到名为 calc3.py 中，或者直接从 GitHub 上下载。试一试。亲眼看一下 它可以处理之前展示给你的句法图中包含的算术表达式规则。梳理输入字符串表达式（如“2+8-6+1”)，存入变量text中将text进行词法分析，执行此功能的是get_next_token()函数，词法分析会生成一个个的token然后对词法分析之后的token按照规定的语法，进行语法分析，相应函数为expr()最后输出结果","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let's Build A Simple Interpreter","slug":"Let-s-Build-A-Simple-Interpreter","permalink":"https://www.longlongqin.top/tags/Let-s-Build-A-Simple-Interpreter/"}]},{"title":"3、布尔逻辑和逻辑门","slug":"学习笔记/《计算机科学速成课》笔记/3、布尔逻辑和逻辑门","date":"2020-03-09T17:01:26.000Z","updated":"2020-03-17T08:46:49.337Z","comments":true,"path":"archives/87ef.html","link":"","permalink":"https://www.longlongqin.top/archives/87ef.html","excerpt":"计算机最早的是机电设备，一般使用十进制计数，比如用齿轮数来代表十进制。但是其实只用开/关两种状态已经足够表示信息了，将其称为二进制（Binary）。","text":"计算机最早的是机电设备，一般使用十进制计数，比如用齿轮数来代表十进制。但是其实只用开/关两种状态已经足够表示信息了，将其称为二进制（Binary）。在计算机中，当电流流过时，为闭合状态，表示true（1），当没有电流流过时，为断开状态，表示false（0）。但是其实晶体管可以不只是开/关状态，还可以让不同大小的电流通过，一些早期电子计算机，通过对不同电流大小进行划分，可以使用三进制、五进制等等。但问题是，状态越多就越难区分信号，如果存在电噪音，可能就会使状态十分混乱。所以为了让信号更加清晰，可以只使用“开”和“关”两种状态。另一个使用二进制的原因是，有一整个数学分支专门处理“真”和“假”，它已解决了所有法则和运算，即布尔代数（Boolean Algebra）。布尔代数（Boolean Algebra）与逻辑门在布尔代数中，变量的值是true和false，能够对其进行逻辑操作。布尔代数中有三个基本操作：NOT、AND和OR。NOT GATENOT：把输出端（就像水龙头左边部分送水，它送电）接在上面的电极，如果打开输出，电流就可以流过，然后“接地”，输出就没有电流，所以输出是off。当输入关闭时，电流没法接地，就流过了输出，所以输出是on。就像是水龙头一样：​​ NOT操作：把布尔值进行翻转，所以NOT操作的真值表为AND GATEAND：为了实现“AND 门”，我们需要2个晶体管连接在一起，这样有2个输入和1个输出。如果只打开A，不打开B，电流无法留到output，所以输出是false；如果只打开B，不打开A，也一样，电流无法留到output；只有当A、B都打开了，output才有电流。OR GATEOR：实现OR 门除了晶体管还需要额外的线将两个晶体管(transistor)并联起来，即得到OR GATE左侧电极为电源，下方两个电极分别表示两个输入，右侧电极为输出。只要任意一个输入开启，就能使得电源和输出电极接通，使得输出开启；当两个输入都关闭时，就使得电源和输出电极保持断开状态，使得输出保持关闭。由此通过上方的三个组件（NOT门、AND门和OR门）可以构建出更加复杂的组件。另一个常见的布尔操作叫做异或操作。XOR(异或)我们有两个输入，A和B，还有一个输出。先放一个OR门。因为OR和XOR的逻辑表很像，只有一个不同点就是：当两个输入都为true时，XOR输出false，而OR输出true。通过对AND操作真值表取反，再和OR操作真值表进行对比，可以发现，第二三行都为true，而第一四行结果不同，因此只要在这两个结果后面加个AND就能得到XOR的真值表。小结操作真值表：对应的罗基本表示：","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"计算机科学速成课","slug":"计算机科学速成课","permalink":"https://www.longlongqin.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE/"},{"name":"布尔逻辑和逻辑门","slug":"布尔逻辑和逻辑门","permalink":"https://www.longlongqin.top/tags/%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91%E5%92%8C%E9%80%BB%E8%BE%91%E9%97%A8/"}]},{"title":"Let’s Build A Simple Interpreter 2","slug":"学习笔记/Let's Build A Simple Interpreter1/LSBASI-2","date":"2020-03-09T13:55:47.000Z","updated":"2020-03-17T09:37:54.717Z","comments":true,"path":"archives/d57d.html","link":"","permalink":"https://www.longlongqin.top/archives/d57d.html","excerpt":"If you learn only methods, you’ll be tied to your methods. But if you learnprinciples, you can devise your own methods.","text":"If you learn only methods, you’ll be tied to your methods. But if you learnprinciples, you can devise your own methods.原文地址：https://ruslanspivak.com/lsbasi-part2/这是第二个版本V2.0，第二个版本较第一个版V1.0，它可以做到：处理输入字符串中任何位置的空白符处理输入中的多位数两个整数相减（版本V1.0中只有加法）下面先给出V2.0的新版计算器的源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152# Token types# EOF (end-of-file) token is used to indicate that# there is no more input left for lexical analysisINTEGER, PLUS, MINUS, EOF = 'INTEGER', 'PLUS', 'MINUS', 'EOF'class Token(): def __init__(self, type, value): # token type: 'INTEGER', 'PLUS', 'MINUS', or 'EOF' self.type = type # token value: non-negative integer value, '+', '-', or None self.value = value def __str__(self): \"\"\"String representation of class instance Examples: Token(INTEGER, 3) Token(PLUS, '+') \"\"\" return f'Token(&#123;self.type&#125;, &#123;self.value&#125;)' def __repr__(self): return self.__str__()##__repr__() 与 __str__() 的主要区别在于，前者在交互式步骤中显示结果，后者在 print 函数中显示结果。 class Interpreter(): def __init__(self, text): # client string input, e.g. \"3 + 5\", \"12 - 5\", etc self.text = text # self.pos is an index into self.text self.pos = 0 # current token instance self.current_token = None self.current_char = self.text[self.pos] def error(self): raise Exception('Error parsing input') ########新增####### def advance(self): \"\"\"Advance the 'pos' pointer and set the 'current_char' variable.\"\"\" self.pos += 1 if self.pos &gt;= len(self.text): self.current_char = None # Indicates end of input else: self.current_char = self.text[self.pos] def skip_whitespace(self): while self.current_char is not None and self.current_char.isspace(): self.advance() def integer(self): \"\"\"Return a (multidigit) integer consumed from the input.\"\"\" result = '' while self.current_char is not None and self.current_char.isdigit(): result += self.current_char self.advance() return int(result) ##新增 完毕##### def get_next_token(self): \"\"\"Lexical analyzer (also known as scanner or tokenizer) This method is responsible for breaking a sentence apart into tokens. \"\"\" while self.current_char is not None: if self.current_char.isspace(): self.skip_whitespace() continue if self.current_char.isdigit(): return Token(INTEGER, self.integer()) if self.current_char == '+': self.advance() return Token(PLUS, '+') if self.current_char == '-': self.advance() return Token(MINUS, '-') self.error() return Token(EOF, None) def eat(self, token_type): # compare the current token type with the passed token # type and if they match then \"eat\" the current token # and assign the next token to the self.current_token, # otherwise raise an exception. if self.current_token.type == token_type: self.current_token = self.get_next_token() else: self.error() def expr(self): \"\"\"Parser / Interpreter expr -&gt; INTEGER PLUS INTEGER expr -&gt; INTEGER MINUS INTEGER \"\"\" # set current token to the first token from the input self.current_token = self.get_next_token() # we expect the current token to be an integer left = self.current_token self.eat(INTEGER) # we expect the current token to be either a '+' or '-' op = self.current_token if op.type == PLUS: self.eat(PLUS) elif op.type == MINUS: self.eat(MINUS) else: self.error() # we expect the current token to be an integer right = self.current_token self.eat(INTEGER) # after the above call the self.current_token is set to # EOF token # at this point either the INTEGER PLUS INTEGER or # the INTEGER MINUS INTEGER sequence of tokens # has been successfully found and the method can just # return the result of adding or subtracting two integers, # thus effectively interpreting client input if op.type == PLUS: result = left.value + right.value elif op.type == MINUS: result = left.value - right.value else: self.error() return resultdef main(): while True: try: # To run under Python3 replace 'raw_input' call with 'input' text = input('calc&gt; ') except EOFError: break if not text: continue interpreter = Interpreter(text) result = interpreter.expr() print(result)if __name__ == '__main__': main()把以上代码保存到名为 calc2.py 中，或者直接从 GitHub 上下载。试一试。亲眼看一下 它可以按预期运行：它可以处理输入中的任何位置的空白符；它接受多位整数，除了整数相 加还可以处理整数相减。下面可以再笔记本上次尝试：123456$ python calc2.pycalc&gt; 27 + 330calc&gt; 27 - 720calc&gt;与第一部分相比代码的主要变化有：get_next_token 方法做了一点重构。增加指针 pos 的逻辑被重构到了方法 advance 中。增加了两个方法： skip_whitespace 用来忽略空白符， integer 用来处理输入中的多位整数。expr 方法在修改后，除了可以识别 INTEGER -&gt; PLUS -&gt; INTEGER 这个组合(phrase) 之外，还可以识别INTEGER -&gt; MINUS -&gt; INTEGER。而且在成功识别相应的组合后，也可以进行相应的加减操作。在第一部分你尝到了两个重要的概念，即 token 和 词法分析器 。今天我想聊一聊 lexeme 、 parsing 和 parser 。你已经知道 token 了。但为了叙述方便，需要介绍一下 lexeme。什么是 lexeme？ lexeme 是组成 token 的一个字符序列。在下面的图片中是一些 token 和 lexeme 的例子， 希望它能把两者之间的关系表达清楚：现在还记得 expr 方法吗？我以前说过这是真正解释算术表达式的地方。但在解释一个表达式之前，你需要知道它是哪种组合，比如相加或相减。这是 expr 方法本质上做的事： 它从 get_next_token 方法得到的 token 流中找到结构，然后解释它识别出的组合，产 生算术表达式的结果。又到了做练习的时间了。扩展计算器以处理两个整数相乘扩展计算器以处理两个整数相除修改代码以使它可以解释包含任意个数字的加减操作，如“9 - 5 + 3 + 11”本节检测：什么是 lexeme？在 token 流中找到结构的过程叫什么？或者这么问，在 token 流中识别出特定组合的过程叫什么？解释器（编译器）做 parsing 工作的部分叫什么？梳理：首先输入一个表达式，如“3+9”，送给解释器Interpreter开始对这个表达式拆分成一个个的token，这一步叫做词法分析，由词法分析器(lexical analyzer)来完成。在本文中，函数get_next_token就相当于词法分析器。词法分析器get_next_token处理完之后的是一个个的token(type , value)然后开始进行语法分析（由于本文中只实现了加法、减法），所以这里的语法分析就是分析：加、减法的表达式。执行这个步骤的是expr函数，其中expr 方法使用了辅助方法eat来验证传给token的类型与当前类型是否相匹配。与现有语法规则（即，加法规则和减法规则）不匹配，eat就会抛出异常。语法分析完成之后，就直接得出算式的结果。（这也很符合解释器的特性嘛：便捷式边执行，不会生成目标代码）其他的函数：Interpretererror(self)：当有错误的时候，就调用它advance(self)：增加指针pos的作用，即，将指向下一个tokenskip_whitespace(self)：跳过空格，V2.0新增加的功能integer(self)：为了可以算多位数的加减法。这里要注意：如3和233是两个整数类型的token，但是值得注意的是这篇文章中的token是按照输入的一串字符串（如“3+155”）每一个都当成一个token。也就是说本来155是一个token，但是从细节上看，在代码实现中155是被当成了三次“token”然后经过integer函数才形成了最终形体155这个token。在本系列的下一篇文章中你会扩展你的计算器来处理更复杂的算术表达式。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let’s Build A Simple Interpreter","slug":"Let’s-Build-A-Simple-Interpreter","permalink":"https://www.longlongqin.top/tags/Let%E2%80%99s-Build-A-Simple-Interpreter/"}]},{"title":"Convex Hull(凸包)","slug":"学习笔记/计算几何/Convex-Hull/Convex-Hull-凸包","date":"2020-03-08T14:12:58.000Z","updated":"2020-03-17T08:42:26.159Z","comments":true,"path":"archives/510d.html","link":"","permalink":"https://www.longlongqin.top/archives/510d.html","excerpt":"这山之高，就叫凸碧；山之低洼近水处，就叫作凹晶。这凸、凹二字，历来用的人最少，如今直用做轩馆之名，更觉新鲜，不落窠臼。","text":"这山之高，就叫凸碧；山之低洼近水处，就叫作凹晶。这凸、凹二字，历来用的人最少，如今直用做轩馆之名，更觉新鲜，不落窠臼。欧拉公式简单介绍一下欧拉公式：虚数中：i^2^=-1 ; i=√(-1) 其中θ为实数，i表示虚数中的虚数单位 i；欧拉恒等式：当θ=π时；几何学中的欧拉公式：V-E+F=2 【v：几何体的顶点数；E：边数；F：面数】凸包凸包：比如，我们有很多很多钉子钉在木板上面，然后用一个皮筋将这些钉子包围起来，当我们松手后，皮筋就把这些定在全都包围起来。此时，这个皮筋所形成的凸多边形就叫凸包。如下图的蓝色的多边形就是凸包。凸性(Convexity)以颜色为例下图中，假设x,y,z是三种颜色，如果仅以x,y就能调出来的颜色，那么如u所示它一定会落在x,y中；若需要x,y,z三种 一起，那么如v所示会落在以x,y,z三点连成的三角形内部。极点(Extreme Point)有一个点集S。如果存在通过点P的直线L，使得点集S中除了点P之外的其他的点都在这个直线的同一侧，则这个点P就是极点(Extreme Points)。判断一个点是否为极点：该点P是否会被包含在其他点中任意三个点形成的三角形中，如果点P不在任何三角形内部，则说明点P是极点。反之，则不是极点。如下图：上图中，S就不是极点，因为他在三角形内部。判断极点的算法In-Trangle Test算法描述伪代码：其实这个算法就是判断点是否在三角形内部。代码实现：123456789101112131415void extremePoint (point S[], int n)&#123; for(int s=0; s&lt;n; s++) S[s].extreme = TRUE; for(int p=0; p&lt;n; p++) for(int q=p+1; q&lt;n; q++) for(int r=q+1; r&lt;n; r++) for(int s=0; s&lt;n; s++) &#123; if(s==p || s==q || s==r ||!S[s].extreme) continue; if(Intriangle(S[p],S[q],S[r],S[s])) S[s].extreme = FALSE; &#125;&#125;可知，该算法的时间复杂度为O(n^4^)，其实挺大的，在后面我们会进一步改善。这样基于极点的凸包算法虽然效率不高，但是它会引出一个非常重要的操作我们称之为To-Left Test在后面我们可以看到这个测试几乎是贯穿于我们计算几何这个课程的始终的。如果说我们刚才所给出的那个算法还有什么需要补充的话其实最重要的也就是那样的一个细节也就是所谓的In-Triangle test。To-Left Test我们将刚才这个In-Triangle Test转化为三次To-Left测试也就是说一个点如果确实落在某一个三角形的内部的话那么相对于这个三角形的三条边所做的这个To-Left测试都会统一的返回true或者统一地返回false。1234567bool InTriangle(Point p, Point q, Point r, Point s)&#123; bool pqLeft = ToLeft(p, q, s); bool qrLeft = ToLeft(q, r, s); bool rpLeft = ToLeft(r, p, s); return (pdLeft == qrLeft) &amp;&amp; (qrLeft == rqLeft);&#125;To-Left测试是相对于另外这两个点所确定的那条有向直线而言的，任何一条有向直线不仅会把平面分成两部分，我们还可以知道哪一边是左边，哪一边是右边。To-Left，其实就是说这个点相对于刚才的那条有向线而言到底是位于它的左侧，还是右侧如果是前者就是true，否则的话就是false。因为三角形有三条边，所以我们要用三次To-Left Test。To-Left Test具体实现：这里用到了行列式来求三角形面积（至于原理，这里就多说了）。下图中的这个行列式实际上算的首先是它的面积的两倍。123456789101112bool ToLeft(Point p, Point q, Point s)&#123; return Area2(p, q, s) &gt; 0; &#125;int Area2(Point p, Point q, Point s)&#123; return p.x * q.y - p.y * q.x +q.x * s.y - q.y * s.x +s.x * p.y - s.y *p.x;&#125;注意：这里的面积其实是“有向面积”，也就是说这里的面积分正负（相对于这样一个逆时针的一个编号pqs的这样的一个面积 与 s在右侧也就是按照顺时针的pqs所构成的面积虽然有可能大小是一样完全对称但是它们的符号是相反的）。整个这个To-Left的测试的判断的依据也就在于这个符号。这个行列式取正条件为：当且仅当s位于pq所确定的这条有向直线的左侧。其中转换成代码也是非常简明的，代码如下图的底部。至此，To-Left Test实现完成。极边(Extreme Edge)极边：两个极点连成的边，剩余的所有点均会在该边的一侧。判断是否为极边：代码实现：12345678void markEE(point S[], int n)&#123; for (int k=0; k&lt;n; k++) S[k].extreme = FALSE; for (int p=0; p&lt;n; p++) //test for(int q=p+1; q&lt;n; q++) //检验每一条边 checkEdge(S,n,p,q) //有向边pq&#125;1234567891011void checkEdge(Point S[], int n, int p, int q)&#123; bool LEmpty =TRUE, REmpty =TRUE; for (int k=0; k&lt;n &amp;&amp; (LEmpty || REmpty); k++) &#123; if (k != p &amp;&amp; k != q) ToLeft(S[p], S[q], S[k]) ? LEmpty=FALSE : REmpty=FALSE; &#125; if(LEmpty || REmpty) S[p].extreme=S[q].extreme=TRUE;&#125;​ 实现的步骤：初始时，先假设所有的点都不是极点。开始遍点集S中的点，它们两两组合成一个线段，然后进行checkEdge(检查这些线段是否是极边)。检查的方法checkEdge：​ 利用ToLeft测试，每次都将当前的线段与其他点（即，除了这两个点之外的点）进行ToLeft测试，如果测试结果中：LEmpty、REmpty 其中之一为true，就表明这两个点构成的线段为极边，而且同时也检测出这两个点是极点。（其实两个点组成的线段进行checkEdge的结果中的LEmpty、REmpty最多只有一个是true,因为这里不存在一条边的两侧都没有其他点的情况）12345678910111213141516171819202122void markEE(Point S[], int n) //n&gt;2&#123; for(int k = 0; k &lt;n; k ++) S[k].extreme = False; //先假设所有的点都不是极点 for(int p = 0; p &lt; n; p ++) for(int q = p + 1; q &lt; n; q ++) checkEdge(S, n, p, q);&#125;void checkEdge(Point S[], int n, int p, int q)&#123; //LEmpty、REmpty表示改边的左侧、右侧，等于True时表示该侧是没有点的。 bool LEmpty = True, REmpty = True; for(int k = 0; k &lt; n &amp;&amp; (LEmpty || REmpty); k ++) &#123; if(k != p &amp;&amp; k != q) &#123; ToLeft(S[p], S[q], S[k]) ? LEmpty = False : REmpty = False; &#125; &#125; if(LEmpty || REmpty) S[p].extreme = S[q].extreme = True;&#125;同样可利用此来判断是否是极点（复杂度为O(n^3^)）。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"《计算几何》","slug":"《计算几何》","permalink":"https://www.longlongqin.top/tags/%E3%80%8A%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E3%80%8B/"},{"name":"凸包","slug":"凸包","permalink":"https://www.longlongqin.top/tags/%E5%87%B8%E5%8C%85/"}]},{"title":"Let’s Build A Simple Interpreter 1","slug":"学习笔记/Let's Build A Simple Interpreter1/LSBASI-1","date":"2020-03-08T09:26:27.000Z","updated":"2020-03-17T09:34:39.519Z","comments":true,"path":"archives/427485bf.html","link":"","permalink":"https://www.longlongqin.top/archives/427485bf.html","excerpt":"为什么要你学解释器和编译器？这里你三条理由。","text":"为什么要你学解释器和编译器？这里你三条理由。要写一个解释器或编译器，你必须同时用到很多技术。编写一个解释器或编译器会帮助 你提高这些技能并且成为一个更好的软件开发者。而且，你将学到的这些技能在开发任 何软件时都有可能用到，而不仅仅是解释器或编译器。你确实想要知道计算机如何工作。一般解释器和编译器看上去都像魔法一样。但你不应 该对这些魔法感到舒服。你想要揭开解释器和编译器的神秘面纱，理解它们如何工作并 控制所有一切。你想要创造自己的编程语言或者领域特定语言。如果是这样，你就需要为这个语言创建 一个解释器或编译器。最近，创建新语言再度兴起。你几乎每天都可以看到一门新语言 的诞生：Elixir, Go, Rust 等。原文链接：https://ruslanspivak.com/lsbasi-part1/好了，但什么是解释器和编译器呢？解释器与编译器解释器与编译器都是“高级语言与机器之间的翻译官”。都是讲代码翻译成机器可以执行的二进制机器码，只不过在运行原理和翻译过程不同。那它们的区别在于：编译器：先整体编译完，然后一次性执行。比如C语言代码被编译成二进制代码（exe程序），在windows平台上执行。解释器：解释一句后就提交计算机执行一句，即便捷式边执行。比如php，postscritp，javascript就是典型的解释性语言。用一个通俗的例子来讲：我们去饭馆吃饭，点了八菜一汤。编译器的方式就是厨师把所有的菜给你全做好了，一起给你端上来，至于你在哪吃，怎么吃，随便。解释器的方式就是厨师做好一个菜给你上一个菜，你就吃这个菜，而且必须在饭店里吃。编译器与解释器的工作流程的差别：编译器与解释器的各自的特点：构造解释器V1.0该系列文章的作者使用 Python 编写Pascal语言的解释器。第一版V1.0，构造的计算器有诸多限制。如：只输入一位的数字现阶段仅支持加法操作输入中不允许有空白符这些约束使得构建一个计算器很简单，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125# Token types：# EOF (end-of-file) token is used to indicate that# there is no more input left for lexical analysisINTEGER, PLUS, EOF = 'INTEGER', 'PLUS', 'EOF'class Token(object): def __init__(self, type, value): # token type: INTEGER, PLUS, or EOF self.type = type # token value: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, '+', or None self.value = value def __str__(self): \"\"\"String representation of the class instance. Examples: Token(INTEGER, 3) Token(PLUS, '+') \"\"\" return 'Token(&#123;type&#125;, &#123;value&#125;)'.format( type=self.type, value=repr(self.value) ) def __repr__(self): return self.__str__()class Interpreter(object): def __init__(self, text): # client string input, e.g. \"3+5\" self.text = text # self.pos is an index into self.text self.pos = 0 # current token instance self.current_token = None def error(self): raise Exception('Error parsing input') def get_next_token(self): \"\"\"Lexical analyzer (also known as scanner or tokenizer) This method is responsible for breaking a sentence apart into tokens. One token at a time. \"\"\" text = self.text # is self.pos index past the end of the self.text ? # if so, then return EOF token because there no more # input left to convert into tokens if self.pos &gt; len(text) - 1: return Token(EOF, None) # get a character at the position self.pos and decide # what token to create based on the single character current_char = text[self.pos] # if the character is a digit then convert it to # integer, create an INTEGER token, increment self.pos # index to point to the next character after the digit, # and return the INTEGER token if current_char.isdigit(): token = Token(INTEGER, int(current_char)) self.pos += 1 return token if current_char == '+': token = Token(PLUS, current_char) self.pos += 1 return token self.error() def eat(self, token_type): # compare the current token type with the passed token # type and if they match then \"eat\" the current token # and assign the next token to the self.current_token, # otherwise raise an exception. if self.current_token.type == token_type: self.current_token = self.get_next_token() else: self.error() def expr(self): \"\"\"expr -&gt; INTEGER PLUS INTEGER\"\"\" # set current token to the first token taken from the input self.current_token = self.get_next_token() # we expect the current token to be a single-digit integer left = self.current_token self.eat(INTEGER) # we expect the current token to be a '+' token op = self.current_token self.eat(PLUS) # we expect the current token to be a single-digit integer right = self.current_token self.eat(INTEGER) # after the above call the self.current_token is set to # EOF token # at this point INTEGER PLUS INTEGER sequence of tokens # has been successfully found and the method can just # return the result of adding two integers, thus # effectively interpreting client input result = left.value + right.value return resultdef main(): while True: try: # To run under Python3 replace 'raw_input' call with 'input' text = input('calc&gt; ') except EOFError: break if not text: continue interpreter = Interpreter(text) result = interpreter.expr() print(result)if __name__ == '__main__': main()把以上代码保存到名为 calc1.py 中，或者直接从 GitHub 上下载。在你开始仔细研究代 码之前，在命令行上运行这个计算器并看它实现运行。把玩一下！下面是在我笔记本上的一 次尝试（如果你想在 Python3 下运行，就需要把 raw_input 替换为 ==input==）：12345678$ python calc1.pycalc&gt; 3+47calc&gt; 3+58calc&gt; 3+912calc&gt;代码分析假设我们在命令行输入一个表达式“3+5”。你的解释器得到一个字符串 “3+5”。为了使解释器真正理解如何处理这个字符串，需要先把输入的 “3+5” 拆分成被叫做 token 的部件。词法分析：（lexical analysis，简称lexer，亦称scanner 或 tokenizer）​ 词法分析也称为 分词 ，此阶段编译器从左向右扫描源文件，将其字符流分割成一个个的 词 （ token 、 记号 ，后文中将称为 token ）。Token：​ 所谓 token ，就是源文件中不可再进一步分割的一串字符，类似于英语中单词，或汉语中的词。这里的 token 就是一个有类型的值的对象（即，token还存着值的类型）。例如对于字符串“3”来说，token 类型为 INTEGER ， 相应的值是整数 3 。解释器Interpreter要做的第一步就是读取输入的字符串并把他转化成 token 流。解释器中做这个工作的部分被称为 词法分析器(lexical analyzer)，简称 lexer 。也可以称它为： scanner 或 tokenizer 。他们的含义是一样的：表示解释器或编译器中将输入的字符串转化为 token 流的部分。那是如何转化为token流呢？解释器 Interpreter中的 get_next_token 方法就是你的词法分析器。你每次调用它，就会从输入到解释器的字符流中得到下一个 token。让我们仔细看一下这个方法，看看它是怎么把字符转化 为 token 的。输入被存放在变量 text 中，它保存了输入的字符串， pos 是指向该字符串的一个索引（把字符串看作是一个字符数组）。 pos 的初值被设为 0, 指向字符‘3’。 该方法首先检查该字符是不是数字，若是数字，就递增 pos 并返回一个类型为 INTEGER 值 为整数 3 的 token：现在 pos 指向了 text 中的字符‘+’，下次你调用这个方法时，它会先测试 pos 位 置的字符是否是数字，然后再测试它是否是加号，此时它是加号。这样该方法就递增 pos 并返回一个类型为 PLUS 值为‘+’的 token：现在 pos 指向了字符‘5’。当你再次调用 get_next_token 时，它会检查 pos 位置 是否是一个数字，此时是的，因此它递增 pos 并返回一个类型为 INTEGER 值为‘5’的 token：现在索引 pos 越过了字符串“3+5”的末尾，接下来每次调用 get_next_token 方法都会 返回 EOF token：自己动手试试看看你的计算器的 lexer 组件怎么工作的：123456789101112131415&gt;&gt;&gt; from calc1 import Interpreter&gt;&gt;&gt;&gt;&gt;&gt; interpreter = Interpreter('3+5')&gt;&gt;&gt; interpreter.get_next_token()Token(INTEGER, 3)&gt;&gt;&gt;&gt;&gt;&gt; interpreter.get_next_token()Token(PLUS, '+')&gt;&gt;&gt;&gt;&gt;&gt; interpreter.get_next_token()Token(INTEGER, 5)&gt;&gt;&gt;&gt;&gt;&gt; interpreter.get_next_token()Token(EOF, None)&gt;&gt;&gt;此时你的解释器已经可以从输入的字符流中获得 token 流了，解释器需要对它做点什么： 它需要从使用 lexer get_next_token 得到的字符流中找到结构。你的解释器期望从 流中找到如下的结构： INTEGER -&gt; PLUS -&gt; INTEGER. 即，它试着找到这样一个 token 序 列：整数后跟一个加号再跟一个整数。负责查找和解释这个结构的方法是 expr. 这个方法验证一个 token 序列是否遵从期望的 token 序列，即 INTEGER -&gt; PLUS -&gt; INTEGER. 当确定遵从这个结构后，它就把 PLUS 左 边和右边 token 的值相加来生成结果，从而成功地解释了你传给解释器的算术表达式。expr 方法使用了辅助方法 eat 来验证传给 eat 的 token 类型与当前的 token 类 型相匹配。在匹配到传入的 token 类型后， eat 方法会取得下一个 token 并把它赋值 给变量 current_token, 这样实际上是“吃掉”了当前匹配的 token 并把想象中的 token 流中的指针向前移动了。如果 token 流中的结构不遵从期望的 INTEGER PLUS INTEGER 序 列， eat 方法就会抛出一个异常。小结回顾一下你的解释器为了对一个算术表达式求值都做了什么：解释器接Interpreter收一个输入字符串，假设为“3+5”解释器调用了 expr 方法来从词法解析器 get_next_token 返回的 token 流中寻找一个结构。这个结构就是一个 INTEGER PLUS INTEGER 的形式。当确认了这个结构以后，它就使用把两个 INTEGER token 相加的方式来解释这个输入，因为此时解释器已经清楚 地知道它要做的就是把 3 和 5 两个整数相加。祝贺你。你刚刚学会了怎么构造你的第一个解释器！现在是时候做此练习了。你不会觉得你刚刚读了这篇文章就足够了，是吧？好了，自己动手做下面的练习：修改代码使得允许输入多位整数，例如“12+3”增加一个跳过空白符的方法，使你的计算器可以处理包含空白符的输入如 “ 12 + 3”修改代码使得它可以处理‘-’而非‘+’的情况检查你的理解。什么是解释器？什么是编译器？解释器和编译器的区别是什么？什么是 token？将输入拆分成 token 的过程叫什么？解释器中做词法分析的部分叫什么？解释器或编译器的这个部分还有什么其他常见的名字？相关文章链接：编译器与解释器：https://www.liujiangblog.com/course/python/9Let’s Build A Simple Interpreter. Part 1：https://feng-qi.github.io/2018/01/23/lets-build-a-simple-interpreter-part-01/","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let’s Build A Simple Interpreter","slug":"Let’s-Build-A-Simple-Interpreter","permalink":"https://www.longlongqin.top/tags/Let%E2%80%99s-Build-A-Simple-Interpreter/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.top"}},{"title":"2、电子计算机","slug":"学习笔记/《计算机科学速成课》笔记/2、电子计算机","date":"2020-03-07T19:02:53.000Z","updated":"2020-03-17T09:03:42.618Z","comments":true,"path":"archives/d84f.html","link":"","permalink":"https://www.longlongqin.top/archives/d84f.html","excerpt":"这个系列的课程还是值得大家去看一看的。这个系列的视频叫《计算机科学速成课》。虽然叫速成课，我们也要做到心中有数，它肯定不是让你看了这些内容你就什么都知道了。这是科普性的视频。这个视频都是被翻译好的，再次感谢这些翻译者。","text":"这个系列的课程还是值得大家去看一看的。这个系列的视频叫《计算机科学速成课》。虽然叫速成课，我们也要做到心中有数，它肯定不是让你看了这些内容你就什么都知道了。这是科普性的视频。这个视频都是被翻译好的，再次感谢这些翻译者。前言视频在B站上都有全集的，传送门：https://www.bilibili.com/video/av21376839在GitHub上的地址：https://github.com/1c7/crash-course-computer-science-chinese这门课总共有40节，每节课的标题为：计算机早期历史电子计算布尔逻辑与逻辑电路二进制算术逻辑单元寄存器 &amp; 内存中央处理器指令和程序高级 CPU 设计编程史话编程语言编程原理：语句和函数算法初步数据结构阿兰·图灵软件工程集成电路、摩尔定律操作系统内存 &amp; 储存介质文件系统压缩命令行界面屏幕 &amp; 2D 图形显示冷战和消费主义个人计算机革命图形用户界面3D 图形计算机网络互联网万维网网络安全黑客与攻击加密机器学习与人工智能计算机视觉自然语言处理机器人计算机中的心理学教育型科技奇点，天网，计算机的未来计算机早期历史这一张图大致说明了计算机早期发展的历史。图片来源：请查看图片本身链接。后面的课会较详细的讲解。电子计算机继电器在1937年最大的机电计算机之一是哈佛的马克一号(Harvard Mark Ⅰ)，是IBM在1944年给二战的同盟国建造的。该机器的大脑(CPU的基础器件)是“继电器”。继电器：是用电控制的机械开关，继电器里有根“控制线路”控制着电路的开关，“控制线路”连着一个线圈，当线圈通电时，会产生感应磁场，由此由此能够吸引上方的金属臂，从而闭合电路，得到高电平。它的性能：1940年一个好的继电器1秒能翻转50次。哈佛马克一号1秒能做3次加减法运算，一次乘法需要6秒，除法需要15秒，三角函数需要一分钟以上。它的缺点：控制开关的金属臂是“有质量的”，因此无法快速开关。并且金属臂的反复移动就会存在磨损（任何会动的机械都会随时间磨损），哈佛马克一号平均每天需要更换一个故障继电器。真空管在1904年，英国物理学家John Ambrose Fleming开发了新的电子组件——热电子管（Thermionic valve）。热电子管：把两个电极装在一个气密的真空玻璃灯泡中。其中一个点击A可以加热，从而发射电子，称为热电子发射（Thermionic emission）；另一个电极B会吸引电子，来形成电流。但只有当电极B带正电时才能吸引电子，否则当电极B带负电荷或者中性电荷时，电子就无法跨越真空区。美国发明家Lee de Forest在此基础上加入了第三个控制电极。通过向控制电极施加正电荷，就能吸引电子，从而闭合电路；而通过施加负电荷，就能闭合电路。特点：每秒可开闭数千次。和继电器相同的是，可以通过一个控制线路来控制断开或闭合电路，并且真空管内没有会动的组件，因此存在更少的磨损。比较脆弱，会像灯泡一样烧坏，并且体积比较大。真空管的出现，标志着计算机从机电转向电子，电子数值积分计算机ENIAC，在1946年于宾夕法尼亚大学设计制造，这是世上第一个真正的通用可编程电子计算机，每秒可执行5000次十位加减法。但是由于存在大量的真空管，因此ENIAC运行半天左右就会出现一次故障。晶体管晶体管：类似于继电器和真空管，晶体管也是一个用于控制电路闭合断开的开关。晶体管有两个电极，这两个电极之间通过半导体材料隔开。控制线连接到一个“门”电极，通过改“门”的电荷，我们可以控制半导体的导电性，由此来控制电流是否流动。当控制线路通电时，两个电极接通，否则两个电极断开。特点：每秒可开关10000次。相比玻璃制成的真空管，晶体管是固体的，并且体积远小于继电器和真空管。第一个消费者可购买的，完全由晶体管构成的计算机是1957年发布的IBM 608，它有3000个晶体管，每秒执行4500次加减法，或80次左右的乘除法。如今，计算机里的晶体管小于50nm，并且每秒可切换上百万次，工作几十年。很多晶体管和半导体开发在圣克拉拉谷，位于旧金山和圣河西之间，由于制造半导体最常见的材料是硅，由此这个地方被称为“硅谷”。并且William Shockley搬过去创建了肖克利半导体，里面的员工后来成立了仙童半导体，而这里面的员工后来创立了英特尔。所以，计算机的大脑基础单元的发展路径，可概括为：继电器-&gt;电子管-&gt;晶体管","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"《计算机科学速成课》","slug":"《计算机科学速成课》","permalink":"https://www.longlongqin.top/tags/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE%E3%80%8B/"}]},{"title":"Hexo之 Yilia主题配置","slug":"Hexo博客搭建/hexo之Ylia主题配置","date":"2020-03-06T14:50:08.000Z","updated":"2020-03-17T09:01:53.475Z","comments":true,"path":"archives/460671de.html","link":"","permalink":"https://www.longlongqin.top/archives/460671de.html","excerpt":"","text":"在左侧显示总文章数将themes\\yilia\\layout_partial\\left-col.ejs文件的1234567&lt;nav class=\"header-menu\"&gt; &lt;ul&gt; &lt;% for (var i in theme.menu)&#123; %&gt; &lt;li&gt;&lt;a href=\"&lt;%- url_for(theme.menu[i]) %&gt;\"&gt;&lt;%= i %&gt;&lt;/a&gt;&lt;/li&gt; &lt;%&#125;%&gt; &lt;/ul&gt;&lt;/nav&gt;后面加上123&lt;nav&gt; 总文章数 &lt;%=site.posts.length%&gt;&lt;/nav&gt;字数、阅读时长添加首先安装 hexo-wordcount使用如下命令安装：1npm i --save hexo-wordcount #如果安装了cnpm，可换为cnpm安装Node 版本7.6.0之前,请安装 2.x 版本 (Node.js v7.6.0 and previous)1Copynpm install hexo-wordcount@2 --save然后在 themes\\yilia\\layout\\_partial\\left-col.ejs中添加：123Copy&lt;nav&gt; 总字数 &lt;span class&#x3D;&quot;post-count&quot;&gt;&lt;%&#x3D; totalcount(site, &#39;0,0.0a&#39;) %&gt;&lt;&#x2F;span&gt;&lt;&#x2F;nav&gt;添加位置在如下代码的下面：123Copy&lt;nav&gt; 总文章数 &lt;%&#x3D;site.posts.length%&gt;&lt;&#x2F;nav&gt;编辑 themes\\yilia\\layout\\_partial\\article.ejs在header下面加入：123&lt;div align&#x3D;&quot;left&quot; class&#x3D;&quot;post-count&quot;&gt; &lt;!--其中align可以在：right、center、left--&gt; 字数：&lt;%&#x3D; wordcount(post.content) %&gt;字 | 预计阅读时长：&lt;%&#x3D; min2read(post.content) %&gt;分钟&lt;&#x2F;div&gt;即可显示单篇字数和预计阅读时长。置顶文章安装插件12npm uninstall hexo-generator-index --savenpm install hexo-generator-index-pin-top --save配置置顶标准打开：/themes/*/layout（/_macro）/post.ejs 直接在最前面加入以下代码即可12345&lt;% if (page.top) &#123; %&gt; &lt;i class=\"fa fa-thumb-tack\"&gt;&lt;/i&gt; &lt;font color=7D26CD&gt;置顶&lt;/font&gt; &lt;span class=\"post-meta-divider\"&gt;|&lt;/span&gt;&lt;% &#125; %&gt;配置文章然后在需要置顶的文章的Front-matter中加上top选项即可 top后面的数字越大，优先级越高12345---title: 2019date: 2019-02-14 16:10:03top: 5---增加不蒜子统计利用这个统计，可以知道你博客的访问量。安装不蒜子脚本：在themes\\yilia\\layout\\ _partial\\after-footer.ejs最后添加：1&lt;script async src=\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt;单篇文章点击量：在themes/yilia/layout/_partial/article.ejs中 在1&lt;%- partial(&#39;post&#x2F;title&#39;, &#123;class_name: &#39;article-title&#39;&#125;) %&gt;后面插入如下代码1234567891011&lt;!--显示阅读次数--&gt;&lt;% if (!index &amp;&amp; post.comments)&#123; %&gt; &lt;br/&gt; &lt;a class=\"cloud-tie-join-count\" href=\"javascript:void(0);\" style=\"color:gray;font-size:14px;\"&gt; &lt;span class=\"icon-sort\"&gt;&lt;/span&gt; &lt;span id=\"busuanzi_container_page_pv\" style=\"color:#ef7522;font-size:14px;\"&gt; 阅读数: &lt;span id=\"busuanzi_value_page_pv\"&gt;&lt;/span&gt;次 &amp;nbsp;&amp;nbsp; &lt;/span&gt; &lt;/a&gt;&lt;% &#125; %&gt;&lt;!--显示阅读次数完毕--&gt;增加版权声明配置yilia：在themes/yilia/layout/_partial/article.ejs中，标注的位置添加代码：1234567891011121314&lt;div class=\"article-entry\" itemprop=\"articleBody\"&gt; &lt;% if (post.excerpt &amp;&amp; index)&#123; %&gt; &lt;%- post.excerpt %&gt; &lt;% if (theme.excerpt_link) &#123; %&gt; &lt;a class=\"article-more-a\" href=\"&lt;%- url_for(post.path) %&gt;#more\"&gt;&lt;%= theme.excerpt_link %&gt; &gt;&gt;&lt;/a&gt; &lt;% &#125; %&gt; &lt;% &#125; else &#123; %&gt; &lt;%- post.content %&gt; &lt;% &#125; %&gt; &lt;-- 在此处添加代码--&gt; &lt;-- 在此处添加代码--&gt; &lt;-- 在此处添加代码--&gt; &lt;-- 在此处添加代码--&gt; &lt;% if ((theme.reward_type === 2 || (theme.reward_type === 1 &amp;&amp; post.reward)) &amp;&amp; !index)&#123; %&gt; &lt;div class=\"page-reward\"&gt; &lt;a href=\"javascript:;\" class=\"page-reward-btn tooltip-top\"&gt; &lt;div class=\"tooltip tooltip-east\"&gt;在目录：themes/yilia/source-src/css中创建新文件：declare.scss，并添加如下CSS代码：123456.declare &#123; background-color: #eaeaea; margin-top: 2em; border-left: 3px solid #ff1700; padding: .5em 1em;&#125;然后，为themes/yilia/source-src/css/main.scss，添加如下代码：1@import \"./declare\";配置显示：现在该让其显示出来，在themes/yilia/_config.yml，中加入：123456789#版权基础设定：0-关闭声明； 1-文章对应的md文件里有declare: true属性，才有版权声明； 2-所有文章均有版权声明#当前应用的版权协议地址。#版权协议的名称#版权协议的Logodeclare_type: 1licensee_url: https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by-nc-sa&#x2F;4.0&#x2F;licensee_name: &#39;知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议&#39;licensee_img: https:&#x2F;&#x2F;i.creativecommons.org&#x2F;l&#x2F;by-nc-sa&#x2F;4.0&#x2F;88x31.png然后在需要进行版权声明的文章的md文件头部，设置属性1declare:true即可。在主页时文章显示摘要在你 MD 格式文章正文插入 &lt;!-- more --&gt; 即可，只会显示它之前的，此后的就不显示，点击文章标题，，或者点击下面的按钮，即可进入全文。如：文章显示目录增加文章目录 TOC ( table of content )，方便阅读文章，在 themes/yilia/_config.yml 中进行配置 toc: 2 即可，它会将你 Markdown 语法的标题，生成目录，目录查看在右下角。头像设置设置存放位置：头像/图标图片的存放位置是/themes/yilia/source/下任意位置，可以自己新建一个文件夹存放，我存放在assets文件夹下。（我之前放在img中，但是不知道为什么，它就显示不出来）配置修改：配置文件为/themes/yilia/_config.yml。设置头像为配置文件中avatar一项，设置图标为配置文件中favicon一项，设置路径的根目录为/themes/yilia/source/。例如，我的头像存放的地址是/themes/yilia/source/assets/me.png，设置则为avatar: /assets/me.png。（图标同理）提交网页sitemap方式提交网页在 Hexo 根目录打开命令行工具，执行以下命令：123npm install hexo-generator-sitemap --savehexo cleanhexo g查看1&#123;your_hexo_path&#125;&#x2F;public文件夹，可以看到文件：1sitemap.xmlsitemap 的初衷是给搜索引擎看的，为了提高搜索引擎对自己站点的收录效果，我们最好手动到 google 和百度等搜索引擎提交 sitemap.xml。baidu提交网址：https://ziyuan.baidu.com/?castk=LTE%3D百度自动推送方式提交网页在本机1&lt;博客根目录&gt;&#x2F;themes&#x2F;yilia&#x2F;layout&#x2F;_partial目录下打开article.ejs文件，定位到如下这段代码：1234&lt;% var sUrl &#x3D; url.replace(&#x2F;index\\.html$&#x2F;, &#39;&#39;); sUrl &#x3D; &#x2F;^(http:|https:)\\&#x2F;\\&#x2F;&#x2F;.test(sUrl) ? sUrl : &#39;https:&#39; + sUrl; %&gt;在它前面加上：123456789101112131415161718&lt;!- 百度自动推送方式提交 --&gt;&lt;% if (1)&#123; %&gt; &lt;script&gt; (function()&#123; var bp &#x3D; document.createElement(&#39;script&#39;); var curProtocol &#x3D; window.location.protocol.split(&#39;:&#39;)[0]; if (curProtocol &#x3D;&#x3D;&#x3D; &#39;https&#39;) &#123; bp.src &#x3D; &#39;https:&#x2F;&#x2F;zz.bdstatic.com&#x2F;linksubmit&#x2F;push.js&#39;; &#125; else &#123; bp.src &#x3D; &#39;http:&#x2F;&#x2F;push.zhanzhang.baidu.com&#x2F;push.js&#39;; &#125; var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(bp, s); &#125;)(); &lt;&#x2F;script&gt;&lt;% &#125; %&gt;&lt;!- 百度自动推送方式提交结束 --&gt;即完成了新增博客文章页面（不包括其他页面）的自动推送方式提交。链接提交百度站长平台的链接提交方式分为自动提交和手动提交两种，此处只讲自动提交，手动提交按照要求操作即可。主动推送设置主动推送最为快速的提交方式，是被百度收录最快的推送方式。主动推送可以通过安装插件实现：首先安装插件：1npm install hexo-baidu-url-submit --save修改站点根目录下的配置文件_config.yml，添加以下内容：12345baidu_url_submit: count: 20 ## 提交最新的20个链接 host: www.dongshuyan.com ## 百度站长平台中注册的域名 token: ## 16位准入秘钥 path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里准入秘钥获取:在如下图的网址中：下拉，找到这里：点击进去就是准入秘钥。检查:其次，记得查看根目录下的_config.yml文件中url的值， 必须包含是百度站长平台注册的域名， 比如:123456# URL## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;url: http:&#x2F;&#x2F;dongshuyan.comroot: &#x2F;permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;permalink_defaults:最后，加入新的deployer最后，加入新的deployer:12345deploy:- type: git ## 这是我原来的deployer repo: branch:- type: baidu_url_submitter ## 添加这里内容即可这里的”-“,必不可少！ 否则报错。使用其主动推送的实现原理如下：新链接的产生， hexo generate 会产生一个文本文件，里面包含最新的链接新链接的提交， hexo deploy 会从上述文件中读取链接，提交至百度搜索引擎自动推送装自动推送JS代码的网页，在页面被访问时，页面URL将立即被推送给百度。修改主题目录下的layout/post.ejs文件，末尾添加自动推送代码，代码如下：1234567891011121314&lt;script&gt;(function()&#123; var bp &#x3D; document.createElement(&#39;script&#39;); var curProtocol &#x3D; window.location.protocol.split(&#39;:&#39;)[0]; if (curProtocol &#x3D;&#x3D;&#x3D; &#39;https&#39;) &#123; bp.src &#x3D; &#39;https:&#x2F;&#x2F;zz.bdstatic.com&#x2F;linksubmit&#x2F;push.js&#39;; &#125; else &#123; bp.src &#x3D; &#39;http:&#x2F;&#x2F;push.zhanzhang.baidu.com&#x2F;push.js&#39;; &#125; var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(bp, s);&#125;)();&lt;&#x2F;script&gt;出处：(http://dongshuyan.com/2019/05/24/hexo博客注意事项/#14-Hexo添加百度统计)添加百度统计和谷歌统计代码百度统计首先打开百度站长平台，注册账户。然后登陆 百度统计》管理》新增站点。然后复制生成的代码：123456789&lt;script&gt;var _hmt = _hmt || [];(function() &#123; var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?这里是你的专属字符串\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s);&#125;)();&lt;/script&gt;这一段代码，最重要的就是你那段专属的字符串。开始配置：首先，打开1themes&#x2F;yilia&#x2F;_config.yml里面1baidu_analytics: ''改为1baidu_analytics: true然后，打开：1themes/yilia/layout/_partial/baidu-analytics.ejs你会看到：1234567891011&lt;% if (theme.baidu_analytics)&#123; %&gt;&lt;script&gt;var _hmt &#x3D; _hmt || [];(function() &#123; var hm &#x3D; document.createElement(&quot;script&quot;); hm.src &#x3D; &quot;https:&#x2F;&#x2F;hm.baidu.com&#x2F;hm.js?&lt;%&#x3D; theme.baidu_analytics %&gt;&quot;; var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(hm, s);&#125;)();&lt;&#x2F;script&gt;&lt;% &#125; %&gt;这里，我们直接用你的专属字符串去替换&lt;%= theme.baidu_analytics %&gt;就行了。替换后为：1234567891011&lt;% if (theme.baidu_analytics)&#123; %&gt;&lt;script&gt;var _hmt &#x3D; _hmt || [];(function() &#123; var hm &#x3D; document.createElement(&quot;script&quot;); hm.src &#x3D; &quot;https:&#x2F;&#x2F;hm.baidu.com&#x2F;hm.js?你的专属字符串&quot;; var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(hm, s);&#125;)();&lt;&#x2F;script&gt;&lt;% &#125; %&gt;谷歌统计参考：http://yansheng836.coding.me/article/eda67a25.html","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.longlongqin.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Yilia主题配置","slug":"Yilia主题配置","permalink":"https://www.longlongqin.top/tags/Yilia%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"}]},{"title":"Hexo之Matery主题配置","slug":"Hexo博客搭建/Hexo之Matery主题配置","date":"2020-03-05T09:29:38.000Z","updated":"2020-03-17T08:27:59.163Z","comments":true,"path":"archives/514b.html","link":"","permalink":"https://www.longlongqin.top/archives/514b.html","excerpt":"最近的三天一直在折腾hexo框架的博客，先是使用yilia主题，但是用来一天觉得我不适合这个主题，随即看到了matery主题。","text":"最近的三天一直在折腾hexo框架的博客，先是使用yilia主题，但是用来一天觉得我不适合这个主题，随即看到了matery主题。前言今天又折腾了白天一天时间，我这个是直接克隆的hongweiの博客，这是一个大佬呀，还要多多向他学习。然后，只把一些简单的配置弄好了。现在梳理一下：已完成的配置：404页面简历建站时间设置个人域名（已购买域名，单还需要审核，明天再去弄。）不蒜子设置 添加评论插件 网站SEO优化 百度收录站点 1.验证网站所有权 谷歌收录站点 优化你的URL 添加代码块复制功能 添加文章更新时间功能非必要配置（已经取消）：添加网易云音乐BGM添加鼠标点击烟花爆炸效果添加页面樱花飘落效果添加鼠标点击文字特效添加页面雪花飘落动效优化网站加载速度数学公式渲染和代码高亮其他搜索引擎收录你的站点添加动漫人物增加emoji支持添加博客动态标签添加博客天气插件GitHub&amp;coding pages双部署修复Valine评论的头像不显示问题配置代码高亮由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 hexo-prism-plugin 的 Hexo 插件来做代码高亮，安装命令如下：1npm i -S hexo-prism-plugin然后，修改 Hexo 根目录下 _config.yml 文件中 highlight.enable 的值为 false，并新增 prism 插件相关的配置，主要配置如下：12345678highlight: enable: falseprism_plugin: mode: 'preprocess' # realtime/preprocess theme: 'tomorrow' line_number: false # default false custom_css:遇到的问题1、Cannot set property &#39;lastIndex&#39; of undefined运行hexo g出现Cannot set property ‘lastIndex’ of undefined解决方法：修改配置文件的 _config.yml，注意不是主题里面的配置文件，把 auto_detect 设置为false 即可。2、代码显示异常解决方法：首先，修改 Hexo 根目录下 _config.yml 文件中 highlight.enable 的值为 false。然后hexo clean&amp; hexo g&amp; hexo s好了。注：作者给的解决方案比我这个要多一步，我在这里贴出来，供大家参考。3、目录定位内容有偏差我反复的去测试，后来发现，可能有两个原因会导致这个问题的出现：网页没有刷新完全的时候，点击目录他有可能不会跳转。解决方法：法一：等待网页刷新完全。法二：手动的去停止网页的刷新（这个来的比较快一点，哈哈）你的文章的标题格式有问题，比如，我用Typora软件来写文章，这个软件就是所写即所得。但是这样你就不容易发现格式细节处的错误。错误示范：我先写了一个一级标题，然后，我又点击引用，就变成这样了：这种写法在Typora中，是不会认为它是一级标题的。我们打开源码查看他的格式：&gt; # 配置。他的格式是这样的。就是这里出错了，在matery主题中这样写它仍然会识别成标题，然后就导致从这个标题开始后面的标题，在你点击这些标题的时候，它会定位错误。解决方法：我们一定要遵循Markdown格式的语法，一定要，一定要。","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.longlongqin.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"matery主题配置","slug":"matery主题配置","permalink":"https://www.longlongqin.top/tags/matery%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"}]},{"title":"Tsinghua_Online_Judge_练习","slug":"Tsinghua-Online-Judge-练习","date":"2020-03-04T09:23:29.000Z","updated":"2020-03-17T08:53:56.643Z","comments":true,"path":"archives/d4fa.html","link":"","permalink":"https://www.longlongqin.top/archives/d4fa.html","excerpt":"","text":"加法12345678#include &lt;cstdio&gt;int main()&#123; long long a, b; std::scanf(\"%lld%lld\", &amp;a, &amp;b); std::printf(\"%lld\\n\",a+b); return 0;&#125;…","categories":[{"name":"OJ","slug":"OJ","permalink":"https://www.longlongqin.top/categories/OJ/"}],"tags":[{"name":"OJ","slug":"OJ","permalink":"https://www.longlongqin.top/tags/OJ/"}]},{"title":"32、黑客&攻击","slug":"学习笔记/《计算机科学速成课》笔记/32、黑客&攻击","date":"2020-03-04T08:59:43.000Z","updated":"2020-03-17T08:51:19.476Z","comments":true,"path":"archives/622.html","link":"","permalink":"https://www.longlongqin.top/archives/622.html","excerpt":"黑客入侵最常见的方式不是通过技术，而是欺骗别人，这个称为社会工程学（Social Engineering），通过欺骗别人来让人泄露秘密，或让人配置电脑系统来变得易于攻击。最常见的攻击是网络钓鱼（Phishing），其次还有假托（Pretexting），攻击者给某个公司打电话，假装是IT部门的人，攻击者的第一通电话一般会叫人转接，这样另一个接的时候，电话看起来就像内部的，然后让别人把电脑配置得易于入侵，或者让他们泄露机密信息，比如密码或网络配置。","text":"黑客入侵最常见的方式不是通过技术，而是欺骗别人，这个称为社会工程学（Social Engineering），通过欺骗别人来让人泄露秘密，或让人配置电脑系统来变得易于攻击。最常见的攻击是网络钓鱼（Phishing），其次还有假托（Pretexting），攻击者给某个公司打电话，假装是IT部门的人，攻击者的第一通电话一般会叫人转接，这样另一个接的时候，电话看起来就像内部的，然后让别人把电脑配置得易于入侵，或者让他们泄露机密信息，比如密码或网络配置。邮件里带木马（trojan horse）也是常见手段，木马通常会伪装成无害的东西，比如照片或发票，但实际上是恶意软件，有的会偷数据，有的会加密文件。如果攻击者无法用木马或电话欺骗，攻击者只能被迫使用其他手段，方法之一就是暴力破解，尝试所有可能的密码，直到进入系统，大多数现代系统会加长等待时间来抵御这种攻击，每次失败就加长等待时间，甚至超过一定次数后，完全封锁。现在出现了一种攻破方法称为NAND镜像，如果能物理接触到电脑，可以往内存上接几根线，复制整个内存，然后暴力尝试密码，直到设备让你等待。这时只要把复制的内容覆盖掉内存，本质上重置了内存，就不用等待，可以继续尝试密码。如果无法物理接触到设备，就需要远程攻击，比如通过互联网，这一般需要攻击者利用系统漏洞，来获得某些能力或访问权限，称为漏洞利用（Exploit）。一种常见的漏洞利用叫缓冲区溢出（Buffer Overflow），这里的缓冲区是指预留的一块内存空间，比如我们在系统登录界面输入用户名和密码，而系统是用缓冲区来存储输入值的，假设缓冲区大小为10，并且缓冲区前后肯定还有其他数据，当用户输入用户名和密码时，这些值就会被复制到缓冲区中来进行验证，而该方法会溢出缓冲区，比如输入超过10个字符的密码，会覆盖掉相邻的数据，有时会让程序或系统崩溃，因为重要值被垃圾数据覆盖掉了。这里只是让系统崩溃，但是攻击者可以输入有意义的新值到程序的内存中，比如把is_admin标志位的值改为true，有了任意修改内存的能力，黑客就可以绕过登录这类东西，甚至使用那个程序劫持整个系统。有许多方法阻止缓冲区溢出，最简单的方法就是复制到内存之前先检查长度，称为边界检查（Bounds checking），许多现代编程语言都自带边界检查，程序也会随机存放变量在内存中的位置，这样黑客就不知道应该覆盖内存的哪部分，使得更容易让程序崩溃，而不是获得访问权限。程序也可以在缓冲区后，预留一些不用的空间，然后跟踪里面的值，看是否发生变化，来判断是否有攻击，这些不用的内存空间称为金丝雀（Canaries）。另一种经典手段是代码注入（Code Injection），最常用于攻击用数据库的网站。假设网页上有登录提示，当用户点击“登录”，输入文本就会发送服务器，服务器就会运行代码，检查用户名是否存在，如果存在就看密码是否匹配。为此服务器会执行一段sql查询代码，比如1SELECT password FROM users WHERE username='___';这里语句就是要从users表中查找username为___的密码password。 这里的___就是用户输入的用户名。由此攻击者就能把sql命令输入到用户名中，比如whatever&#39;;DROP TABLE users;&#39;，这时上面的查询语句就会变成1SELECT password FROM users WHERE username='whatever';DROP TABLE users;';如果服务器存在用户名wharever，数据库就会返回密码， 当然我们无法得知密码是什么，所以服务器会拒绝我们；如果不存在用户名wharever，服务器会返回空密码或者直接错误，服务器也会拒绝我们。 但是我们关心的是后面的代码DROP TABLE users;这个是我们注入的命令，这个命令是删掉users这张表。如今几乎所有服务器都会防御这种手段。程序员需要认识到从外界输入的信息都是危险的，必须要好好检查，很多用户名和密码表单，不会让你直接输入特殊符号，比如分号或括号，来作为第一道防御。好的服务器也会清理输入，比如修改或删除特殊字符，然后才放到数据库查询语句中。当软件制造者不知道的新漏洞被发现时，称为0day漏洞（Zero Day Vulnerability），黑客就会抢在白帽程序员做出补丁之前尽可能利用漏洞。如果有足够多的电脑有漏洞，让恶意程序可以自动地在电脑之间互相传播，称为蠕虫（Worm）。如果黑客拿下大量电脑，这些电脑可以组成僵尸网络（Botnet），可以用于很多目的，比如发大量垃圾邮件等，用别人电脑的计算能力来挖比特币，或发起DDOS来攻击服务器。DDOS就是僵尸网络里的所有电脑发一大堆垃圾信息到服务器上，造成服务器的阻塞。完~~~","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"《计算机科学速成课》","slug":"《计算机科学速成课》","permalink":"https://www.longlongqin.top/tags/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE%E3%80%8B/"}]},{"title":"Hexo 博客框架搭建","slug":"Hexo博客搭建/Hexo博客框架搭建","date":"2020-03-01T13:27:52.000Z","updated":"2020-03-17T08:12:17.477Z","comments":true,"path":"archives/7f7e.html","link":"","permalink":"https://www.longlongqin.top/archives/7f7e.html","excerpt":"搭建这个博客起因是2020年的二月末的某一天晚上，无聊逛B站，然后就看到了一个博客搭建教程，随机就有了这一系列的文章了。","text":"搭建这个博客起因是2020年的二月末的某一天晚上，无聊逛B站，然后就看到了一个博客搭建教程，随机就有了这一系列的文章了。前言我的是在windows操作系统上面，在其他的系统上面大同小异。也参考了很多文章及视频教程。主要参考的是：程序羊的视频：https://www.bilibili.com/video/av44544186?from=search&amp;seid=12981624311298276946文章：https://ouwen666.gitee.io/2020/01/29/Hexo+Gitee搭建个人博客作者部署的是giteehttps://godweiyang.com/2018/04/13/hexo-blog/#toc-heading-6含有个性化配置注：文中的指令都是在cmd（Windows中的命令提示符）中完成的。如果在这之前电脑上就已经安装了Git bash，那么也可以在Git bash中运行指令。下面会用得到的命令npm install=npm i。在git clone项目的时候，项目文件中并没有 node_modules文件夹，项目的依赖文件可能很大。直接执行，npm会根据package.json配置文件中的依赖配置下载安装。-global=-g，全局安装，安装后的包位于系统预设目录下--save=-S，安装的包将写入package.json里面的dependencies，dependencies：生产环境需要依赖的库开始配置安装Node.js博客框架Hexo是基于Node.js制作的静态博客，我们待会要用到Node.js里面的npm(node package manager)包管理器来安装插件。可以点击这里进入其官网。进入之后，按照操作系统进行下载安装。如上图是Windows系统64位的版本，上面官方推荐下载的版本。安装选项就按默认的，一直点击Next。然后，检验是否安装成功：用Win+R命令打开命令提示符，输入node -v 和npm -v ，出现版本号，则说明安装成功。添加cnpm注：因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，如果npm的服务器在中国就好了，所以我们乐于分享的淘宝团队干了这事。来自官网：“这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。”所以我们可以利用npm安装cnpm，再cmd中输入：1npm install cnpm -g –registry=https://registry.npm.taobao.org再输入：cnpm -v来检验是否安装成功。此时，假设我们Node.js安装成功。安装Hexo框架我们要利用Hexo框架模型来搭建我们的博客。点击这里可以进入其官网。下载该框架也仍然是在cmd（Windows中的“命令提示符”）中输入指令完成的。在上一步我们安装了cnpm，现在我们要用它来安装hexo，用cnpm安装的速度更快一些，也可以用npm：1cnpm install -g hexo-cli检验是否安装成功，当运行之后出现版本号则安装成功：1hexo -v现在，我们的Hexo框架已经安装成功了。初始化Hexo想要看到博客运行起来，我们现在还需要对Hexo框架进行初始化。在你的电脑上找一个合适的位置，创建一个文件夹，名字可以随便取，可以用Blog等等的名字，随个人喜好取名。为了便于演示，假设你取的名字叫做：blog注意，初始化是在我们创建的这个blog文件夹中初始化的，所以，我们的命令提示符（cmd）左边的路径要在这个blog文件夹中。进入刚刚创建的文件夹中然后，在输入指令 ：1hexo init初始化完成后，我们的blog文件夹中，就会生成这些文件：node_modules: 依赖包public：存放生成的页面scaffolds：生成文章的一些模板source：用来存放你的文章themes：主题_config.yml: 博客的配置文件在安装一些必要的包：1npm install初始化完成，在打开hexo服务器：123$ hexo sINFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.我们，打开浏览器，输入：localhost:4000，就可以看到你的博客的雏形已经好了。更换主题加入你觉得这个主题你不喜欢，想要找一个其他的主题，你可以进入Hexo的官网的主题板块，来选择你喜欢的主题：假如，你想更换为3-hexo，那就点击它，会跳转到该主题的创作者的GitHub上：安装3-hexo主题，其中命令的themes/3-hexo指的是该主题的安装位置：1git clone https://github.com/yelog/hexo-theme-3-hexo.git themes/3-hexo安装完之后，我们需要运行：123$ hexo clean # 清除所有记录 $ hexo generate # 生成静态网页 简写：hexo g$ hexo server # 启动服务 简写：hexo s然后，我们就能在本地localhost:4000中，查看修改好的主题了。安装Git如果你不想只在本地上查看你的博客，也想有自己的博客网址链接，那我们可以下载Git，把博客内容部署到GitHub或者gitee上面。我们这里以GitHub为例。Git的官网点击这里。然后按照你的电脑的操作系统下载相应的版本。安装选项还是全部默认，只不过最后一步添加路径时选择Use Git from the Windows Command Prompt，这样我们就可以直接在命令提示符里打开git了。安装完成后在命令提示符中输入git --version验证是否安装成功。GitHub账号如果你没有GitHub账号，我们现在去创建一个吧。点击这里创建。创建完成之后，我们新建一个github仓库：注意你的仓库名字不要随便起，待会我们要用到。加入你GitHub名字叫“AAA”，那么仓库个名字就一定是：AAA.github.io：部署博客将博客部署在github中目前，还不能部署到GitHub上。还需要下载hexo-deployer-git插件：1cnpm install hexo-deployer-git --save #通过cpnm安装git插件如果，你是刚刚才下载的Git，则还需要设置你的姓名和邮箱：12git config --global user.name \"Firstname Lastname\" // 名字使用英文输入git config --global user.email \"your_email@example.com\"还有你的SSH Key，创建公开密钥：1ssh-keygen -t rsa -C &quot;your_email@example.com&quot;​ 把生成的密钥添加到GitHub中去：找到生成的密钥：如果一切顺利的话，可以在用户主目录里找到.ssh目录，我的在：C:\\Users\\xxxx\\.ssh（xxxx是我的一个目录）。里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便，把公钥复制进去。到这里，我们的git与远程的GitHub已经建立起关系了。我们还需要把blog文件夹中的设置文件，即：_config.yml，将最后一行进行修改,：1234deploy: type: git repository: https://github.com/longlongqin/longlongqin.github.io.git branch: master​ repository修改为你自己的github项目地址，在实际操作过程中，repository: git@github.com:longlongqin/longlongqin.github.io.git,也是可以的。修改之后，我们才能部署到GitHub上：12$ hexo deployer## 初次使用这个命令，需要输入github的用户名username和密码password​ 这里，就是利用刚下载的插件：hexo-deployer-git现在我们可以访问我们在github服务器上的博客网址，网址就是我们刚刚创建仓库的名字，比如我的仓库名是：longlongqin.github.io，我们复制粘贴它到浏览器，然后你就可以看到你的博客内容了。😊Git提交到多个仓库https://yuxiang.ren/2017/08/25/hexo%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%88%B0%E5%A4%9A%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/部署在gitee部署在gitee上的坑在gitee上面，和在GitHub上面部署差不多，但是有些地方我们还是要注意的。仓库命名问题在创建gitee仓库时，最好也是将仓库名字命名为你的账号的用户名，比如我的：​ 当然，你也可以命名为其他名字，但是换成其他名字之后，可能会带来一系列其他的问题，比如图片无法显示。其实我之前命名成其他名字，就出现了很大的问题：这种情况是因为，他找不到资源，加载错误：熬了一个晚上，终于发现了。在官方文档中有：网站在子目录的情况如果你的网站在一个子目录（例如http://example.org/blog） 设置url为http://example.org/blog并且设置root为/blog/说来也奇怪，在GitHub上面，和本地运行的时候都是好好的。就是在gitee上面出错了。o(︶︿︶)o 唉解决它的办法就是：​ 将root添加上缺少的那一级目录，即可1234567891011121314151617# URL## If your site is put in a subdirectory, set url as'http://yoursite.com/child' and root as '/child/'url: http://yoursite.com/childroot: /blog/permalink: :year/:month/:day/:post_title/permalink_defaults:pretty_urls: trailing_index: false # Set to false to remove trailing 'index.html' from permalinks trailing_html: true # Set to false to remove trailing '.html' from permalinks这一篇帖子里面也有人遇到了同样的问题，最后也是通过root的修改解决的。：https://gitee.com/oschina/git-osc/issues/IFVWV?from=project-issuegitee pages刷新除了仓库名字需要注意，我们还需要注意，gitee个人版似乎不能自动刷新，所以你每次hexo d之后，需要手动的刷新gitee pages，才能显示你新提交的内容。写文章编辑器推荐推荐使用Typora这款软件，点击这里进入官网，他可以写Markdown格式的内容，这个软件的方便之处在于直接将markdown语法呈现出其效果，并且已经集成了很多方便的功能，你无需记住插入代码的语法格式，无需记住插入图片的语法格式，这使得我可以专心写博客而无法关心学习markdown语法。有很多md编辑器，他们分成两个界面，一个界面是md源代码，另外一个界面实时更新显示其效果，而Typora是浑然一体的，真正所见即所得，就跟在使用word一样方便。不仅如此，它还可以导出PDF、Word、HTML、图片等格式。待续……图片问题http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/Hexo的操作指令我们刚开始，对于Hexo的指令不太熟悉，我们可以在他的官网上去查找相应的操作指令。文章的front-matterFront-matter 选项详解Front-matter 选项中的所有内容均为非必填的。但我仍然建议至少填写 title 和 date的值。配置选项默认值描述titleMarkdown 的文档标题文章标题，强烈建议填写此选项date文档创建时的日期时间发布时间，强烈建议填写此选项，且最好保证全局唯一author根 _config.yml中的 author文章作者imgfeatureImages中的某个值文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: http://xxx.com/xxx.jpgtoptrue（文章是否置顶），如果 top 值为 true，则会作为首页password无文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项toctrue是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项mathjaxfalse是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文档中也需要开启才行summary无文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则进程会自动截取文章的部分内容作为摘要categories无文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类tags无文章标签，一篇文章可以多个标签Front-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量，举例来说：1234---title: Hello Worlddate: 2013/7/13 20:46:25---分类和标签只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。12345categories:- Diarytags:- PS3- Games分类方法的分歧如果您有过使用 WordPress 的经验，就很容易误解 Hexo 的分类方式。WordPress 支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是 Hexo 不支持指定多个同级分类。下面的指定方法：123categories: - Diary - Life会使分类Life成为Diary的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。1234categories:- [Diary, PlayStation]- [Diary, Games]- [Life]此时这篇文章同时包括三个分类： PlayStation 和 Games 分别都是父分类 Diary 的子分类，同时 Life 是一个没有子分类的分类。JSON Front-matter除了 YAML 外，你也可以使用 JSON 来编写 Front-matter，只要将 --- 代换成 ;;; 即可。123&quot;title&quot;: &quot;Hello World&quot;,&quot;date&quot;: &quot;2013&#x2F;7&#x2F;13 20:46:25&quot;;;;配置过程遇到的问题Hexo博客中文章图片不显示的坑这个是真的坑，搞了好久，终于看到一篇博文，才解决了这个问题。放一下这篇文章的传送门。在coding中SSL证书申请失败的坑在搭建到coding中步骤其实和在github中比较相似，就是给仓库命名原则的时候需要注意，尽量让仓库名字与你的用户名相同，即和在github中命名规则相似。如果你之前都很顺利，那么在SSL证书申请时，需要注意了：你会遇到证书申请一直失败的情况。这是为什么呢？是这样的：第一次尝试，查资料说是如果之前你已经在github oages上部署了，你自己买的域名也已经解析过了。此时直接在coding pages中申请ssl的话，会失败。解决的办法就是：先把用于解析github pages的那两条暂停了，如下图所示：然后，我再试试，还是申请失败。出现类似于下面的错误：继续去查。嗯，找到了，申请失败是因为我的域名在国外无法解析，这是我的DNS设置导致的。解决办法：在解析的时候，需要将线路类型改成默认。去试一试，等待一小会哇，终于申请成功了。#Hexo博客备份有时候我们外出，自己的电脑没有带，这时候想写博客怎么办。这也是有办法的，就是我们要先备份我们的博客。这里我们可以备份到github或者gitee.拿github举例：首先，我们先要在GitHub上面建立一个仓库，仓库名字自取，仓库是public还是private，按照自己的心情来就好了。然后，我们要在本地关联远程仓库：我们进入你的本地博客所在的目录，比如我的在D:\\Blog，然后，打开你的Git bash，按顺序输入以下命令：12git init #初始化本地仓库git remote add origin &lt;你的远程仓库的SSH或HTTPS链接&gt; #关联远程仓库（ssh的链接比较快一点）关联完成，然后我们还需要，将本地的推送到远端，同样，按顺序输入一下命令：123git add . #这个‘.’表示将整个文件夹都一起添加到暂存区（不然还要一个个输入文件名）git commit -m \"输入你这次提交的说明\" git push origin master #推送到远程仓库好了，记得按时将本地的备份到远程仓库。至此，本地备份已经完成。如果你想同时备份到gitee和github上面，你可以参考这里。在另外一台电脑上写博客前提是我们把博客备份在github、gitee等上面。然后在新电脑上面：安装 Git、nodejs把你远程的博客备份，clone下来到一个指定的位置（位置自己定）在本地的博客仓库运行：npm install，来 安装依赖包好了，你可开始写博客了。优化技巧优化文章URLseo搜索引擎优化认为，网站的最佳结构是用户从首页点击三次就可以到达任何一个页面，但是我们使用hexo编译的站点打开文章的url是：sitename/year/mounth/day/title四层的结构，这样的url结构很不利于seo，爬虫就会经常爬不到我们的文章，于是，我们需要优化一下网站文章url方案一：我们可以将url直接改成sitename/title的形式，并且title最好是用英文，在根目录的配置文件下修改permalink如下：1234url: https://sunhwee.comroot: /permalink: :title.htmlpermalink_defaults:方案二：使用插件优化url插件hexo-abbrlink实现了这个功能，它将原来的URL地址重新进行了进制转换和再编码。安装hexo-abbrlink。1npm install hexo-abbrlink --save配置博客根目录下的_config.yml文件。12345# permalink: :title/permalink: archives/:abbrlink.htmlabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex运行hexo clean和hexo g命令来重新生成文件看看，可以清楚的看到，URL结构成功变为了3层。来源: 洪卫の博客作者: 洪卫文章链接: https://sunhwee.com/posts/6e8839eb.html#toc-heading-59本文章著作权归作者所有，任何形式的转载都请注明出处。其他参考文章列表：http://dongshuyan.com/2019/05/24/hexo%E5%8D%9A%E5%AE%A2%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/#14-Hexo添加百度统计网络编程系列 Hexo + Github搭建个人博客 · 花田半亩","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.longlongqin.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Hexo主题","slug":"Hexo主题","permalink":"https://www.longlongqin.top/tags/Hexo%E4%B8%BB%E9%A2%98/"}]}]}