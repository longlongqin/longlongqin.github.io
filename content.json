{"meta":{"title":"龙龙‘S BLOG","subtitle":"","description":"","author":"longlongqin","url":"https://longlongqin.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-04-19T14:35:12.699Z","updated":"2020-04-19T14:35:12.699Z","comments":true,"path":"404.html","permalink":"https://longlongqin.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-03-30T06:26:07.079Z","updated":"2020-03-30T06:26:07.079Z","comments":true,"path":"about/index.html","permalink":"https://longlongqin.github.io/about/index.html","excerpt":"","text":"路漫漫其修远兮，吾将上下而求索一个本科生化环材的跨考生，现专业软件工程。本博客主要记录自己的学习之路。现阶段学习内容：编译原理Let’s Build A Simple Interpreter计算几何邓俊辉老师的学堂在线课程C/C++基础学习：https://www.learncpp.com/"},{"title":"所有分类","date":"2020-03-16T13:58:21.496Z","updated":"2020-03-15T14:08:19.000Z","comments":true,"path":"categories/index.html","permalink":"https://longlongqin.github.io/categories/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-03-21T17:19:06.339Z","updated":"2020-03-15T14:08:19.000Z","comments":true,"path":"comment/index.html","permalink":"https://longlongqin.github.io/comment/index.html","excerpt":"","text":"欢迎前来灌水。。。"},{"title":"Projects","date":"2020-03-21T17:16:38.679Z","updated":"2020-03-15T14:08:19.000Z","comments":true,"path":"projects/index.html","permalink":"https://longlongqin.github.io/projects/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-03-16T13:21:42.616Z","updated":"2020-03-15T14:08:19.000Z","comments":true,"path":"tags/index.html","permalink":"https://longlongqin.github.io/tags/index.html","excerpt":"","text":""},{"title":"Friends","date":"2020-04-19T14:38:29.545Z","updated":"2020-04-19T14:38:29.545Z","comments":true,"path":"friends/index.html","permalink":"https://longlongqin.github.io/friends/index.html","excerpt":"","text":"欢迎和我交换友链各位大佬想交换友链的话可以在下方留言，必须要提供名称、头像和链接哦~请先将本站添加到你滴友链中喔，谢谢~友链提交模板：123456- name: 龙龙‘S Blog avatar: https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg url: https://www.longlongqin.github.io backgroundColor: '#FFA500' textColor: '#624739' tag: #你的简介背景、字体颜色可以按自己风格设置呀！"},{"title":"","date":"2020-04-19T14:38:29.545Z","updated":"2020-04-19T14:38:29.545Z","comments":true,"path":"学习笔记/index.html","permalink":"https://longlongqin.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html","excerpt":"","text":"学习笔记编译原理Let’s Build A Simple Interpreterpart1、part2、part3、part4、part5、part6、part7、part8、part9计算几何学堂在线课程-邓俊辉老师凸包：Convex-Hull-凸包、增量构造、Jarvis-March、Lower-Bound、Graham Scan、Divide-And-Conquererer计算机科学速成课2 电子计算机、3 布尔逻辑和逻辑门、32 黑客&amp;攻击C/C++C本办法学CC++1、www.learncpp.comLearnCpp描述chapter0~1chapter2functions and fileschapter4Fundamental Data Typeschapter3debugging C++ programschapter5OperatorschapterOBit Manipulation (optional chapter)chapter6Object Scope and Conversions2、基于项目学习(project-based-learning)Build an Interpreter(Chapter 14 on is written in C)Memory Allocators 101 - Write a simple memory allocator项目练习我的项目练习相应的github仓库：https://github.com/longlongqin/learnCode_based_project程序羊推荐项目描述进度CJSON一个超轻量的、可移植的、单文件的、简单到可以成为ANSI-C兼容的JSON解析器，在MIT许可下。【一些相关教程：1️⃣从零开始的 JSON 库教程，2️⃣cJson源码和源码分析】🔥进行中Tinyhttpd是J. David Blackstone在1999年写的一个不到 500 行的超轻量型 Http Server，用来学习非常不错，可以帮助我们真正理解服务器程序的本质。官网MyTinySTL基于 C++11 的 tinySTL，（学STL时，可以写一写）oatpp用C++实现的轻量级的Web框架redis这个几万行代码，现在干不动基于项目学习(project-based-learning)项目描述进度Build an Interpreter(Chapter 14 on is written in C)使用C语言写一个解释器暂停Linux鸟哥的私房菜 0.计算机概论 1.Linux是什么 2.主机规划与硬盘分割 3.安裝 CentOS7.x【未读，我直接用的阿里云服务器】 4.首次登陆与线上求助"},{"title":"","date":"2020-04-19T14:38:29.545Z","updated":"2020-04-19T14:38:29.545Z","comments":true,"path":"easysearch/about/index.html","permalink":"https://longlongqin.github.io/easysearch/about/index.html","excerpt":"","text":"关于本页丨龙龙'S BLOG 关于本页在自己电脑上建立了很多书签，但是不方便使用。就想建立一个在线的网址导航，这样无论在哪都可以方便快捷的使用导航了。powered by webstack.cc关于我longlongqin一个跨考软工的初学者努力学习C++ 2020 - 2020 | 丨 DESIGNED BY Viggo 丨 MODIFIED BY longlongqin!function(e){var c=Array.prototype.slice.call(document.querySelectorAll(\"img[data-original]\"));function i(){for(var r=0;r"},{"title":"","date":"2020-04-19T14:38:29.851Z","updated":"2020-04-19T14:38:29.851Z","comments":true,"path":"easysearch/index.html","permalink":"https://longlongqin.github.io/easysearch/index.html","excerpt":"","text":"easysearch丨龙龙'S BLOG 开发社区 代码托管 语言文档 技能训练在线平台高校平台游戏编程 HOT Pythoner文档资料博客收藏学习资源组织社区爬虫相关 HOT 学习教程在线视频博客论坛学习平台 常用工具站长工具 HOTIT工具箱文件处理 HOT设计素材效率软件 HOT 服务平台 云服务商 众包平台 更多导航 FORME计算几何C++关注的博客 HOT常用网址公众号&写作 关于本页 隐藏/显示侧边栏 博客首页 友情链接 评论留言 关于博主!function(e,t,n,a,o,i,c,r){r=function(){i=t.createElement(n),c=t.getElementsByTagName(n)[0],i.src=o,i.charset=\"utf-8\",i.async=1,c.parentNode.insertBefore(i,c)},e.SeniverseWeatherWidgetObject=a,e[a]||(e[a]=function(){(e[a].q=e[a].q||[]).push(arguments)}),e[a].l=+new Date,e.attachEvent?e.attachEvent(\"onload\",r):e.addEventListener(\"load\",r,!1)}(window,document,\"script\",\"SeniverseWeatherWidget\",\"//cdn.sencdn.com/widget2/static/js/bundle.js?t=\"+parseInt(((new Date).getTime()/1e8).toString(),10)),window.SeniverseWeatherWidget(\"show\",{flavor:\"slim\",location:\"WX4FBXXFKE4F\",geolocation:!0,language:\"auto\",unit:\"c\",theme:\"auto\",token:\"a39cd5a0-4024-4cb2-85c6-0250317058db\",hover:\"enabled\",container:\"tp-weather-widget\"})开发社区Stack Overflow全球最受程序员欢迎的开发社区V2EXV2EX = way to explore SegmentFault改变并提升人们获取知识的方式和效率，帮助更多的开发者获得成长与成功 开源中国国内最大的开源技术社区 ITeyeITeye软件开发交流社区 - Java编程 Spring框架 Ajax技术 agile敏捷软件开发 ruby on rails实践 51CTO技术成就梦想 ITPUB全球最大的学习分享平台 知乎国内最受欢迎的知识性问答社区 简书创作你的创作 云+社区来自腾讯的开发者技术分享社区云栖社区阿里云面向开发者的开放型技术平台 掘金一个帮助开发者成长的社区CSDN全球最大中文IT社区，为IT专业技术人员提供最全面的信息传播和服务平台博客园代码改变世界代码托管Github全球最大的面向开源及私有软件项目的托管平台Gitlab支持无限的公有项目和私有项目的代码托管平台Bitbucket同时支持 Git 和 Mercurial 这两个版本控制软件，免费的私有仓库，支持5人以内的合作开发SourceForge又称 SF.net，是开源软件开发者进行开发管理的集中式场所Coding国内首个一站式云端软件服务平台Gitee国内最大的开源社区 OSChina 的代码托管平台阿里云代码托管阿里云旗下代码托管平台百度效率云百度云旗下的 Git 代码托管平台语言文档Zeal脱机文档浏览器，包含196种语言API文档，支持Windows、Linux和macOSDash适用于Mac OS平台的软件编程文档管理工具,可以浏览API文档,以及管理代码片段工具。自带了丰富的API文档,涉及各种主流的编程语言和框架DevDocs在快速，有条理和可搜索的界面中结合了多个API文档，可以在移动设备上离线运行，并且可以安装在Chrome上C/C++C/C++ API 文档C#C# API 文档JavaJava API 文档.NET.NET API 文档PHPPHP API 文档JavaScriptJavaScript API 文档PythonPython API 文档AndroidAndroid API 文档iOSiOS API 文档SQLSQL API 文档SwiftSwift API 文档RubyRuby API 文档GOGO API 文档RR API 文档MATLABMATLAB API 文档Node.jsNode.js API 文档HTMLHTML API 文档CSSCSS API 文档RedisRedis API 文档MongoDBMongoDB API 文档DjangoDjango API 文档在线平台 LeetCode全球极客挚爱的技术成长平台Topcoder全世界规模最大的程序竞赛网站，也会有一些算法竞赛，适合一些高端的或者搞ACM的，也会举办一些比赛Codeforces俄罗斯最大的算法比赛网站Hihocoder技术团队来自原北京大学POJ (PKU Online Judge)开发团队，收集了全球范围内很多地区、高校举办的比赛试题， 提供365天*24小时的在线提交、评判程序的服务LintCode被称作中文版的leetcode，也是可以做为编程能力提升的一个中转站SPOJ波兰的算法刷题网站NEUQ OJ一个在线的判题平台洛谷创办于2013年，致力于为参加noip、noi、acm的选手提供清爽、快捷的编程体验牛客网中国最大的IT题库C语言网在这里可以参加包括ACM、NOI在内的各种C/C++/java程序比赛，也可以DIY举办各类程序比赛活动！计蒜客计蒜客OI题库致力于为参加noi、noip、信息学竞赛的选手提供优秀的Online Judge系统高校平台POJ北京大学程序在线评测系统FDU OJ复旦大学程序在线评测系统TJ OJ同济大学程序在线评测系统USTC OJ中国科学技术大学程序在线评测系统ZOJ浙江大学程序在线评测系统HDU OJ杭州电子科技大学程序在线评测系统CSU-ACM中南大学程序在线评测系统HOJX哈尔滨工业大学程序在线评测系统HRBUST OJ哈尔滨理工大学程序在线评测系统PowerOJ西南科技大学程序在线评测系统SCU OJ四川大学程序在线评测系统FZU CoidngOJ福州大学程序在线评测系统NBUT OJ宁波工程学院程序在线评测系统Lutece电子科技大学程序在线评测系统武汉大学 ACM 协会武汉大学 ACM 协会ZJUT OJ浙江工业大学程序在线评测系统游戏编程CheckiO面向初学者和高级程序员的编码游戏，使用Python和JavaScript解决棘手的挑战和有趣的任务，从而提高您的编码技能Coding Games支持包括PHP、C、JavaScript在内的20多种编程语言。用户界面功能强大，可以定制Codewars一个外国的在线练习编程的网站,做题的过程类似打怪,做题升级,而且可以看到别人的解法,里面有很多巧妙的写法可以学习CodeCombat一个面向学生的游戏和CS学习平台。这是一个社区项目，有数百玩家自愿提供支持。支持语言包括Java、JS、Python、Lua、CoffeeScriptScreeps在游戏中学习JavaScript。世界上第一款针对程序员的MMO沙盒游戏VIM Adventures玩游戏的时候学VIMCyber-Dojo一个提供给程序员们练习写程序的地方。支持语言包括JavaScript、Java、Python、PHP、Ruby和很多其他语言Elevator Saga电梯编程游戏，跟随关卡解决所有挑站，使用语言为JavaScriptRuby Quiz一个Ruby程序员提供的每周编程挑战项目hacker.org这项挑战由一系列本设计来强化你黑客技巧的解密、诡计、测试、烧脑环节组成。想要通关本系列，你必须学会解密、编码、渗透Ruby Warrior玩游戏学Ruby，通过Ruby脚本来控制一个Warrior通过每一关，每一关的代码难度都会有所增加，使玩家逐渐了解Ruby基本的函数、控制、变量、数组等语言特性的用法文档资料Python 官方文档Python 官方文档Python 标准库Python 标准库Python RequestsPython Requests 文档Python UrllibPython Urllib 文档Python SeleniumPython Selenium 中文翻译文档正则表达式Python 正则表达式官方文档Beautiful SoupBeautiful Soup 文档ScrapyScrapy 爬虫框架官方文档PySpiderPySpider 爬虫框架官方文档MatplotlibMatplotlib 2D绘图库 官方中文文档NumpyNumpy 科学计算 官方中文文档PandasPandas 结构化数据分析 官方中文文档博客收藏廖雪峰廖雪峰的官方网站 - 研究互联网产品和技术，提供原创中文精品教程崔庆才崔庆才的个人博客,专注PHP,Python,爬虫,深度学习,机器学习,数据分析莫烦Python专注Python、机器学习、深度学习唐松专注Python网络爬虫, 数据科学, 数据挖掘, 数据分析捕蛇者说编程、程序员、PythonFxxkPython学习python的正确姿势wistbeanPython 大佬PigleiPython 大佬TendCodePython 大佬追梦人物的博客Python Django 大佬the5fire《Django企业开发实战》作者，关注Python、Django、Vim、Linux、Web开发小明明S À DOMICILE《Python Web开发实战》作者，Python 大佬Python之禅Python 大佬Python 知识圈Python知识圈 - 实用的Python教程网站Python 教程网小詹学Python，专注Python学习烂笔头 j_hao104Python大佬咸鱼日常专注Python爬虫，有许多JS逆向文章AnShengPython 全栈大佬夏溪辰云栖社区特邀爬虫工程师，Python大佬高级农民工Python大佬云爬虫技术研究笔记Lateautumn4lin 爬虫开发工程师，多年反爬虫破解经验，沉迷数据分析和黑客增长，CSDN博客专家，华为云享专家云爬虫技术研究笔记(CSDN)Lateautumn4lin 爬虫开发工程师，多年反爬虫破解经验，沉迷数据分析和黑客增长，CSDN博客专家，华为云享专家Jack CuiCSDN博客专家，Python 大佬学习资源Python爬虫人工智能学习教程Python爬虫人工智能学习教程分享Python 中文学习大本营Python 中文学习大本营Python 资源大全中文版Python 资源大全中文版爱湃森各种 Python 教程组织社区PyChinaPython 中国社区PyCon China中国 Python 开发者大会蠎周刊蠎周刊 - 汇集全球蠎事儿爬虫相关镀金的天空GlidedSky 镀金的天空，在线爬虫练习题库夜幕爬虫安全论坛一个专注于爬虫与 PC/Web/ 移动端安全领域技术交流的社区，社区由夜幕团队 NightTeam 创办，旨在提升开发者对爬虫与软件安全防护的理解西刺免费代理IP每日更新免费HTTP代理，所有代理均为6675端口高匿代理，可隐藏IP爬虫IP代理池爬虫IP代理池云打码采用全球领先的秒传识别系统，50%图片零秒识别，人工平均处理时间0-3秒超级鹰专业的验证码云端识别服务,让验证码识别更快速、更准确、更强大八爪鱼采集器一款使用简单、功能强大的网络爬虫工具，完全可视化操作，无需编写代码，内置海量模板，支持任意网络数据抓取Python 逆向Python 逆向相关资源Python 爬虫集合Python 爬虫集合Python 入门网络爬虫之精华版Python 入门网络爬虫之精华版爬虫项目进阶实战Python3 爬虫项目进阶实战、JS加解密、逆向教程、css 加密、字体加密Python 模拟登陆一些大型网站Python 模拟登陆一些大型网站系统化学习 Python 爬虫系统化学习 Python 爬虫Python3 网络爬虫实战Python3 网络爬虫实战在线视频腾讯课堂腾讯推出的专业在线教育平台，聚合大量优质教育机构和名师网易云课堂网易旗下一个专注职业技能提升的在线学习平台。立足于实用性的要求，与多家教育培训机构和行业的专家、讲师建立合作中国大学 MOOC中国大学MOOC(慕课)，国家精品课程在线学习平台黑马程序员致力于培养中级程序员，是业内以口碑闻名的IT教育培训机构课工场更可靠的IT就业教育平台，针对大学生量身定制人工智能、大数据、云计算、区块链、Java大数据开发等大学生IT培训课程极客学院极客学院作为中国专业IT职业在线教育平台,拥有海量高清IT职业课程,涵盖30+个技术领域慕课网慕课网（IMOOC）是IT技能学习平台。慕课网(IMOOC)提供了丰富的移动端开发、php开发、web前端、android开发以及html5等视频教程资源公开课尚硅谷尚硅谷Java培训，谷粉与老学员为你推荐的Java培训、Web前端培训、前端培训、大数据培训、Python培训；0基础入学，学员就业起薪屡创新高！实验楼国内领先的IT在线编程及在线实训学习平台，专业导师提供精选的实践项目，创新的技术使得学习者无需配置繁琐的本地环境，随时在线流畅使用优达学城Udacity是来自硅谷的前沿技术平台，为广大学子提供WEB前端开发、Python/JAVA编程、IOS/Android开发、人工智能开发等一系列在线课程及实战项目，满足学员灵活的学习需求51CTO学院51CTO学院IT职业在线教育平台是依托12年行业品牌、1400万IT技术用户建立的专业IT技能学习培训平台，已签约1000多位技术专家发布了12万个自学式实战视频教程CSDN 学院CSDN 学院作为IT在线教育平台,涵盖人工智能、考试认证、移动开发、大数据技术领域职业课程老男孩IT教育隶属北京一天天教育科技有限公司,是一直专注于Linux培训、Linux系统及架构师培训、Python培训、网络安全培训，大数据实战的高端培训机构千锋教育千锋教育 - 坚持教育初心，坚持面授品质，IT培训良心品牌博客论坛鱼C工作室鱼C工作室-免费编程视频教学|Python教学|Web开发教学|全栈开发教学|C语言教学|汇编教学|Win32开发|加密与解密|Linux教学吾爱破解致力于软件安全与病毒分析的前沿，丰富的技术版块交相辉映，由无数热衷于软件加密解密及反病毒爱好者共同维护廖雪峰廖雪峰的官方网站 - 研究互联网产品和技术，提供原创中文精品教程崔庆才崔庆才的个人博客,专注PHP,Python,爬虫,深度学习,机器学习,数据分析莫烦Python专注Python、机器学习、深度学习唐松专注Python网络爬虫, 数据科学, 数据挖掘, 数据分析阮一峰上海财经大学世界经济博士研究生，计算机科普博主，对自由软件有着坚定不移的信念学习平台菜鸟教程提供了编程的基础技术教程, 介绍了HTML、CSS、Javascript、Python，Java，Ruby，C，PHP , MySQL等各种编程语言的基础知识 W3school领先的 Web 技术教程C语言网C语言网 - 领先实用的编程在线学习网站前端网前端网，最好的自学web前端网站 牛客网牛客网 - 互联网求职神器和备考学习平台How2JHow2J的Java教程, 内容涵盖J2SE、WEB前端、J2EE、框架技术等全面的Java内容站长工具新浪短网址多种后缀短网址生成百度短网址百度旗下专业的网址缩短服务站长工具 - 站长之家站长工具,SEO工具,权重查询,收录查询,PR查询,ICP备案查询,whois查询,友情链接查询,反向链接查询,网站测试,IP查询,Alexa查询阿里云 whois 查询whois查询,域名whois,域名注册信息,whois查询工具,whois信息,域名信息NnameBeta国际域名搜索、域名注册、国别域名注册、域名比价Domcomp域名比价，Domain Name Price and Availability.仿站工具箱在线仿站工具箱超级 SEO 外链工具网站自动化宣传机器/免费的超级外链工具可批量增加外链百度站长平台百度搜索资源平台 - 让网站更具价值搜狗站长平台搜狗站长平台 - 全面掌握在搜狗搜索中的数据表现360 站长平台360 站长平台 - 给网站带来更多流量和展现Google 站长平台Google 网站站长 - 支持、学习、互动交流和 Search Console – GoogleBing 网站管理员工具Bing 网站管理员工具百度广告联盟百度广告联盟为您的流量增值Google AdSenseGoogle 广告平台百度统计百度统计 — 最大的中文网站分析平台友盟+国内领先的第三方全域数据智能服务商ICP/IP地址/域名信息备案管理系统工业和信息化部ICP/IP地址/域名信息备案管理系统全国互联网安全管理服务平台公安备案网 - 全国互联网安全管理服务平台IT工具箱在线工具 - 程序员的工具箱站长工具、代码格式化、压缩、加密、解密、下载链接转换等在线工具 - OSCHINA.NET社区常用文档、常用对照表、代码处理、Html/Js/Css工具、加密/转码工具等记磊工具箱Dns检测、CSS格式化、超级Ping、端口扫描等孟坤工具箱css一键美化、文本差异比较、代码高亮等Syntax HighlightSyntax Highlight Code In Word Documents，在Word文档中插入漂亮的代码Text to ASCII Art GeneratorText to ASCII Art Generator，字符串转成 ASCII 码图案MDEditor开源在线 Markdown 编辑器临时邮箱匿名注册不常用的网站/论坛，保护隐私免骚扰SM.MSSM 免费图床，每个文件最大支持 5MB路过图床免费公共图床，支持最大10MB、批量上传Greasy Fork安全、实用的用户脚本大全Hello World 大全收集了大约481种 Hello World 程序，涵盖了目前已知的所有编程语言，另加上 67 人类语言动画展示各种路径搜索算法动画展示各种路径搜索算法IT eBooks可以下载IT电子书籍的网站（英文）GEEKTyper在线模拟黑客工作的虚拟桌面系统，提供多种黑客工作的场景免费计算机编程类中文书籍免费计算机编程类中文书籍EaseUS Partition Master磁盘分区管理软件，不用重装系统，就可以重新划分磁盘空间文件处理Convertio在线文件转换工具，支持超过309种不同的文档、图像、电子表格、电子书、文档、演示文稿、音频和视频格式Office-Converter免费在线转换视频，在线音频转换，在线图形转换，在线文档转换和在线压缩格式TinyPNGPNG/JPG图片在线压缩利器SquooshGoogle开源在线压缩、调整工具，支持WebPILoveIMG永远免费的在线图片处理工具，可在线编辑，压缩、裁剪、转换、水印等SmallpdfSmallpdf - A Free Solution to all your PDF Problems,PDF压缩、转换、分割、合并等PHOTOMOSH故障艺术在线生成，可以输出jpg、gif和视频稿定抠图免费在线抠图软件,图片快速换背景-抠白底图U钙网完全免费的LOGO在线设计制作工具SVGOMGSVG在线压缩平台在线图片透明圆角处理在线图片透明圆角处理草料二维码国内创建二维码在线应用Logaster在线免费创建简单logo及名片设计PreloadersLoading 懒加载动画在线制作Loading制作GIF、SVG、CSS加载动画图标waifu2x图片智能无损放大2倍，适合动漫、插画等智图腾讯ISUX前端团队开发的一个专门用于图片压缩和图片格式转换的平台音乐免费下载全网音乐免费下载工具OK资源采集OK资源采集-最新影视资源大全网易见外工作台针对视频、图片、文档、音频都可以进行翻译转写操作，每天两小时免费使用HiPDF一站式解决所有PDF相关的问题视频鱼在线下载各大网站视频的网站ScreenToGif开源、轻量级却非常强大的录屏软件，快速将屏幕录制成高清GIF设计素材Iconfont阿里巴巴矢量图标库，提供矢量图标下载、在线存储、格式转换等功能Font Awesome一个基于CSS 和 LESS 的字体和图标工具包Flaticon海量扁平化免费的图标库icons8独特系统平台风格和web图标库，下载免费图标，音乐千图网海量原创设计模板免费下载昵图网国内海量平面免费素材下载千库网免费 png 图片背景素材下载Pexels才华横溢的摄影作者在这里免费分享最精彩的素材照片和视频必应壁纸必应每日高清壁纸Piqsels精美的免版税图库私藏字体优质字体免费下载站第一 PPT 网免费 PPT 模板下载吾道幻灯片全新的office生产力工具，支持演示文稿、PPT模板、协同办公，可以帮助用户轻松创建具有视觉吸引力的幻灯片Mixkit免费、高质量、可商用的视频素材分享网站The Stocks对各大图片网站进行整合，免费优质图片下载极简壁纸高质量精品壁纸网站NASA Image and Video Library美国国家航天局的官方库，从此太空类的素材再也不是问题Unsplash质量超高的免费图片素材库，无需注册，直接下载WordArt文字云工具效率软件分流抢票全程自动抢票,自动抢候补,自动识别验证码,多线程秒单、稳定捡漏,支持多天、多车次、多席别、多乘客等功能PanDownload百度网盘下载神器Quicker为常用操作建立捷径，PC 快捷动作面板，让效率触手可及!万彩办公大师免费、轻松处理文档/音视频/图片的工具LICEcap简洁易用的动画屏幕录制软件，它可将屏幕录像的内容直接保存为高质量（每帧颜色数量可超过256）GIF动态图片格式Snipaste简单但强大的截图工具，支持截图 + 贴图FSCapture一个强大的，轻量级的，功能齐全的屏幕捕获工具Everything速度最快的的文件搜索工具DeskPins顶置任意窗口TrafficMonitor一个用于显示当前网速、CPU及内存利用率的桌面悬浮窗软件PicGo由 electronic-vue 构建的简单而精美的图片上传工具PowerToys微软为 Windows 系统推出的一系列免费实用小工具合集Dism++一款根据微软底层的架构结构设计的一个系统维护工具，全球第一款基于 CBS 的 Dism GUI 实现ColorPix屏幕取色小工具CCleaner一款免费的系统优化和隐私保护工具GifCam集录制与剪辑为一体的屏幕 GIF 动画制作工具，录制后的动画可以逐帧编辑EV录屏一款免费并且不添加水印的录屏工具Fliqlo一款极简主义的时钟屏保软件Fences栅栏管理桌面，使桌面更加整洁有条理Q-dir多窗口文件整理工具WGestures鼠标手势工具XMind一个全功能的思维导图和头脑风暴软件速盘免登录，自动查询提取码，极速的度盘下载工具f.lux国外开源的护眼软件，通过根据时间调节屏幕颜色，减少蓝光对视力的影响云服务商 阿里云阿里云 - 为了无法计算的价值腾讯云腾讯云 - 产业智变 云启未来百度云百度云 - 计算无限可能华为云华为云 - +智能，见未来京东云京东云 - 遇见无限可能西部数码西部数码 - 云服务器、虚拟主机、域名注册17年知名云计算服务提供商！景安云景安云 - 专业的数据中心服务商七牛云七牛云 - 国内领先的企业级云服务商又拍云又拍云 - 加速在线业务-CDN-云存储美橙互联美橙互联 - 域名注册、企业建站、云服务器、企业网络推广整体解决方案服务商！UCloudUCloud - 中立 安全 可信赖的云计算服务商AWSAWS 云服务 - 专业的大数据和云计算服务以及云解决方案提供商Microsoft AzureAzure. Invent with purpose.GoDaddyGoDaddy - 提供域名注册和互联网主机服务的美国公司CloudflareCloudflare - 网络性能和安全公司jsDelivrjsDelivr - A free, fast, and reliable Open Source CDN for npm and GitHub众包平台 猿急送专注于 IT 众包领域，职位内容大多集中于 UI 设计、产品设计、程序开发、产品运营等需求开源众包开源中国旗下外包网站，项目大多是团队的整包项目，适合多人组团接单外包大师PMCAFF旗下的一个众包开发平台，目前以技术开发为主，以众包开发和自有开发相结合形式运营人人开发集可视化开发，应用市场，威客众包，PaaS云于一体的企业级应用服务平台快码提供智能硬件、各种智能共享项目解决方案，为互联网创业者提供APP、小程序、公众号开发。我爱方案网专注于硬件类外包，电子方案开发供应链众包平台，软件外包，方案，硬件开发方案，硬件设计开发英选提供可信赖的定制开发外包服务，包括企业品牌官网、电商系统及创新定制产品开发智筹为企业&创业者提供互联网高级人才直租服务。按次直租，解决临时、突发问题；按月直租，建立长期兼职合作；按任务直租，解决有明确预算的外包任务开发邦互联网软件定制开发与软件外包开发服务，十年互联网软件定制开发经验码市Coding 推出的互联网软件外包服务平台，意在连接需求方与广大开发者。让项目的需求方快速的找到合适的开发者，完成项目开发工作自由职客自由职客是权威的IT互联网行业灵活用工交易平台，外包，众包，兼职，招聘，erp，sap解放号解放号众包平台提供软件开发外包、人力驻场服务等软件项目外包服务。解放号的软件项目交付全流程可视化监控与全生命周期管理能力程序员客栈领先的程序员自由工作平台，38万+优秀开发者，您的专属云端开发团队，BAT级别的开发者，标准化的服务和交付码易智网易联旗下IT软件服务平台，集软件商城、企业应用、电商软件、crm软件、商务服务平台于一体的一站式软件外包开发服务平台电鸭社区电鸭社区旨在推动自由工作方式在国内渐进式发展，区别于传统方式的工作职位，倡导「只工作，不上班」的工作心态Sxsoft中国最早的外包服务平台，18年口碑服务，20万程序员、100+专业软件开发公司，专注解决各类软件开发需求实现网为企业提供BAT等名企背景的、靠谱的开发设计兼职人才和自由职业者，满足企业项目外包、驻场开发、远程兼职、技术咨询等短期人力需求智城外包网零佣金开发资源平台，认证担保，全程无忧，专业的软件外包网和项目外包、项目开发、人力外派、短期招聘、人力资源交易平台更多导航 创造狮导航创造狮，一个创意工作者的导航，专注分享正版优质设计、前端、产品、运营的书签导航，设计教程、设计规范、颜色搭配、灵感创意、前端框架、开发者工具、互联网新品推荐、运营数据分析、自媒体和工具利器好用的分类导航大全大数据导航大数据导航，以大数据产业为主，大数据工具为辅，给用户提供一个更加快速找到大数据相关的工具平台优设导航优设网站导航为设计师提供ps教程、UI设计、素材下载、高清图库、配色方案、用户体验、网页设计等全方位设计师网站导航指引牛导航实用工具导航聚BT聚BT - 聚合最优质的BT、磁力资源ShareHubShareHub - 资源和工具的集合狼牌工作网址导航工具，资源，方法，All IN ONE的办公工作网址导航计算几何xuetangx邓俊辉老师的《计算几何》Tsinghua Online Judge邓俊辉老师的《计算几何》上机练习C++LearnCppC++基础教学Project Based Learninggithub中C++项目式学习CTOLIBC/C++开发项目(中文)STLSTL入门教程(中文)cppreferenceC/C++ API 文档写作坚果云好用的文件自动同步，再也不担心typora出bugfont awesomeicon图标TEA写作软件极简又极其强大的笔记应用关注的博客知名博客随机推荐推荐一些比较知名的程序开发大神和团队博客、他们的github和他们网站等，跟随大神的脚步，学习最新的程序开发知识，时刻让自己走在前面！欢迎邮箱推荐或者自荐酷壳-陈皓一个IT技术技术性BLOG。是一个分享技术见闻，知识，趋势的网站。阮一峰大佬分享IT技术、以及其他感悟廖雪峰廖雪峰的官方网站 -git教程 & 研究互联网产品和技术，提供原创中文精品教程演算法笔记诸如图论、数论、计算几何、数值方法、资料处理、诸如自然语言处理、声音处理、影像处理、计算机图学 …… 常用网址我的云书签将本地的浏览器的收藏夹转化为云书签Stack Overflow全球最受程序员欢迎的开发社区 公众号&写作微信公众平台公众号管理135编辑器功能强大的微信公众号文章排版编辑器坚果云好用的文件自动同步，再也不担心typora出bugfont awesomeicon图标TEA写作软件极简又极其强大的笔记应用COPYRIGHT 2020 - 2020 WEBSTACK 丨 DESIGNED BY VIGGO 丨 CHANGED BY longlongqin​ ​$(document).ready(function(){return $(document).on(\"click\",\".has-sub\",function(){var e=$(this);$(this).hasClass(\"expanded\")?$(\".has-sub ul\").each(function(s,i){var t=$(this);e.find(\"ul\")[0]!=i&&setTimeout(function(){t.attr(\"style\",\"\")},300)}):setTimeout(function(){e.find(\"ul\").attr(\"style\",\"\")},300)}),$(\".user-info-menu .hidden-sm\").click(function(){$(\".sidebar-menu\").hasClass(\"collapsed\")?$(\".has-sub.expanded > ul\").attr(\"style\",\"\"):$(\".has-sub.expanded > ul\").show()}),$(\"#main-menu li ul li\").click(function(){$(this).siblings(\"li\").removeClass(\"active\"),$(this).addClass(\"active\")}),$(\"a.smooth\").click(function(s){s.preventDefault(),public_vars.$mainMenu.add(public_vars.$sidebarProfile).toggleClass(\"mobile-is-visible\"),ps_destroy(),$(\"html, body\").animate({scrollTop:$($(this).attr(\"href\")).offset().top-30},{duration:500,easing:\"swing\"})}),!1});var href=\"\",pos=0;$(\"a.smooth\").click(function(s){$(\"#main-menu li\").each(function(){$(this).removeClass(\"active\")}),$(this).parent(\"li\").addClass(\"active\"),s.preventDefault(),href=$(this).attr(\"href\"),pos=$(href).position().top-30})!function(e){var c=Array.prototype.slice.call(document.querySelectorAll(\"img[data-original]\"));function i(){for(var r=0;r"}],"posts":[{"title":"LearnCpp chapter8","slug":"C&C++/LearnCpp-chapter8","date":"2020-04-19T08:54:17.000Z","updated":"2020-04-22T07:17:55.695Z","comments":true,"path":"archives/c812a74c.html","link":"","permalink":"https://longlongqin.github.io/archives/c812a74c.html","excerpt":"LearnCpp-chapter8https://www.learncpp.com未完待续~~","text":"LearnCpp-chapter8https://www.learncpp.com未完待续~~8.1 介绍面向对象编程Object-oriented programming (OOP)在 1.3 – Introduction to variables中，我们在c++中将一个对象定义为“一段可用来存储值的内存”。具有名称的对象称为变量。在传统编程中(我们在此之前一直在做的工作)，程序基本上是计算机的指令列表，这些指令定义数据(通过对象)，然后处理数据(通过语句和函数)。数据和处理该数据的函数是独立的实体，它们组合在一起以产生所需的结果。由于这种分离，传统的编程通常不能提供对现实的非常直观的表示。由程序员以适当的方式管理和连接 属性(变量)和行为(函数)，这就致使代码变成这样：1driveTo(you, work);什么是面向对象编程？和许多事物一样，它可能最容易通过类比来理解。看看你的周围–你看到的每一个地方都是object：书籍、建筑物、食物，甚至你自己。object有两个主要的部分：（properties）相关属性的列表（e.g. weight, color, size, solidity, shape, etc…）（behavior）这些属性能表现出的一些行为（e.g. being opened, making something else hot, etc…）这些属性和行为是不可分割的。Object-oriented programming (OOP) 为我们提供了创建对象的能力，这些对象将属性和行为绑定到一个自包含的、可重用的包中。这导致代码看起来更像这样:1you.driveto(work);这不仅读起来更清晰，还使主语(您)和被调用的行为(在某处驾驶)更清晰。不是专注于编写函数，而是专注于定义具有定义良好的行为集的对象。这就是为什么这个范例被称为“面向对象”。优点这允许以更模块化的方式编写程序，这使它们更容易编写和理解，还提供了更高程度的代码可重用性。这些对象还提供了一种 通过允许我们定义如何与对象交互以及如何与其他对象交互，来更直观的方式来处理数据。请注意，OOP并没有取代传统的编程方法。相反，它在编程工具带中为您提供了额外的工具，以便在需要时管理复杂性。object请注意，术语“object”被稍微重载了一些，这导致了一些混淆。在传统编程中，对象是用来存储值的一块内存。在面向对象编程中，“对象”意味着它包含 传统编程意义上的对象，又是属性和行为的组合。从现在开始，当我们使用“对象”这个术语时，我们将在面向对象的意义上引用“对象”。8.2 类&amp;类成员虽然C++提供一些基本的数据类型（e.g. char, int, long, float, double, etc…），它们可以解决一些简单的问题。但是在解决复杂问题的时候这些基本数据类型就不够用了。C++也提供：允许用户自定义数据类型，如之前学的： enumerated types、structs在C++，中class与 struct本质上相同。如下面的两个是等价的：1234567891011121314struct DateStruct&#123; int year; int month; int day;&#125;; class DateClass&#123;public: int m_year; int m_month; int m_day;&#125;;注意，惟一显著的区别是public:关键字在类中类(和结构)定义就像一个蓝图——它们描述结果对象的样子，但是它们实际上并不创建对象。要实际创建类的对象，必须定义该类类型的变量:1DateClass today &#123; 2020, 10, 14 &#125;; // declare a variable of class DateClass成员函数除了保存数据，类(和结构)还可以包含函数!在类内部定义的函数称为成员函数 (有时也称为方法)。成员函数&amp;非成员函数eg：12345678910111213141516//非成员函数：函数不能调用定义在它下面的函数(没有前向声明):void x()&#123; // You can't call y() from here unless the compiler has already seen a forward declaration for y()&#125;void y()&#123; &#125;//成员函数：成员函数没有这个限制class foo&#123;public: void x() &#123;y()&#125; ;// okay to call y() here, even though y() isn't defined until later in this class void y() &#123;&#125;;&#125;成员类型除了成员变量和成员函数外，类还可以具有成员类型或嵌套类型(包括类型别名)。在下面的例子中，我们创建了一个计算器，如果需要，我们可以快速地更改它所使用的数字类型。1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;vertor&gt;class Calculator&#123;public: using number_t = int; //这是一个嵌套类型的别名 std::vector&lt;number_t&gt; m_result&#123;&#125;; number_t add (number_t a, number_t b) &#123; //auto的原理就是根据后面的值，来自己推测前面的类型是什么。 auto result &#123;a+b&#125;; m_result.push_back (result); return result; &#125;&#125;;int main()&#123; Calculator calculator &#123;&#125;; std::cout &lt;&lt; calculator.add(3, 4) &lt;&lt; '\\n'; //7 return 0;&#125;在这样的上下文中，类名实际上充当嵌套类型的名称空间。在类内部，我们只需要引用number_t。在类之外，我们可以通过Calculator::number_t访问类型。关于C++中的struct的说明在C语言中，结构体只能保存数据，没有成员函数。但是咋C++中，两者都可以有。经过考虑，他决定他们应该有一个统一的规则集。因此，虽然我们使用class关键字编写了上述程序，但我们可以使用struct关键字。所以，建议：对只包含数据的结构使用struct关键字。对同时具有数据和函数的对象使用class关键字。8.3 访问说明符 piblicVS privatepublic：class和struct的public member 可以在 它们的外部访问；由关键字struct构成的数据类型，默认是public。private：只能被类的其他成员访问；由class构成的数据类型，默认是private。通常，成员变量通常是private的，而成员函数通常是public的。eg：123456789101112131415161718192021222324252627282930313233struct DateStruct // members are public by default&#123; int month; // public by default, can be accessed by anyone int day; // public by default, can be accessed by anyone int year; // public by default, can be accessed by anyone&#125;;int main()&#123; DateStruct date; date.month = 10; date.day = 14; date.year= 2020; return 0;&#125;------------------------------------class DateClass // members are private by default&#123; int m_month; // private by default, can only be accessed by other members int m_day; // private by default, can only be accessed by other members int m_year; // private by default, can only be accessed by other members&#125;; int main()&#123; DateClass date; date.m_month = 10; // error date.m_day = 14; // error date.m_year = 2020; // error return 0;&#125;类的public member通常被看作 public interface（公共接口）：因为只有public mebmber才可以在类外部被访问，但是public member可以直接访问类中的private和protected的成员。所以利用public member 可以间接访问类的private和protected的成员。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://longlongqin.github.io/tags/C-C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"LearnCpp chapterL","slug":"C&C++/LearnCpp-chapterL","date":"2020-04-18T02:13:00.000Z","updated":"2020-04-23T08:14:32.228Z","comments":true,"path":"archives/9f7a1269.html","link":"","permalink":"https://longlongqin.github.io/archives/9f7a1269.html","excerpt":"LearnCpp-chapterLhttps://www.learncpp.com未完待续~~","text":"LearnCpp-chapterLhttps://www.learncpp.com未完待续~~L5.1 控制流当程序运行时，CPU开始从mian()函数执行，然后执行它里面的语句，最后结束于main()函数结尾。CPU执行语句的顺序叫做：程序执行路径(execution path)。停止(halt)但程序运行并不总是将main()函数中的语句全部执行。它可以被停止。在C++中，可以使用头文件cstdlib中的std::exit()函数，来终止程序。exit函数接受一个整数参数，该参数作为std::exit代码返回给操作系统，这与main()的返回值非常相似。eg:12345678910111213141516171819#include &lt;cstdlib&gt; //for std::exit()#include &lt;iostream&gt;void cleanup()&#123; //code here to do any kind of cleanup required&#125;int main()&#123; std::cout&lt;&lt; 1 &lt;&lt; '\\n'; cleanup(); std::exit(0); //程序在此结束，并且向操作系统返回0 //所以下面的语句将不会执行 std::cout&lt;&lt;2&lt;&lt;'\\n'; return 0;&#125;注意，std::exit()无论从哪个函数调用(甚至是main以外的函数)都可以工作。还要注意，std::exit()使用最少的清理立即终止程序。所以，在使用std::exit()之前，您应该考虑是否需要进行任何手动清理(例如将用户的游戏保存到磁盘)。通常，std::exit()用于在发生灾难性的、不可恢复的错误时立即终止程序。L5.1 if语句最基本的条件分支就是 if 语句。隐式的块我们需要注意，隐式的块中的一些陷阱，陷阱1：1234567891011121314#include &lt;iostream&gt; int main()&#123; if (true) int x = 5; else int x = 6; std::cout &lt;&lt; x; return 0;&#125;//因为上面的x是在一个块中被定义的(这个块没有显式的写出来，但它确实是一个块)上面这个程序会出错，原因：（这将无法编译，编译器将生成标识符x未定义的错误）123456789101112131415161718//上面的程序和这个程序相等。这个程序将块显式的表示出来了#include &lt;iostream&gt; int main()&#123; if (true) &#123; int x = 5; &#125; // x destroyed here else &#123; int x = 6; &#125; // x destroyed here std::cout &lt;&lt; x; // x isn't defined here return 0;&#125;陷阱2：程序1：123456789101112131415161718#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; \"Enter a number: \"; int x; std::cin &gt;&gt; x; if (x &gt;= 10) &#123; if (x &lt;= 20) std::cout &lt;&lt; x &lt;&lt; \"is between 10 and 20\\n\"; &#125; else // attached to outer if statement std::cout &lt;&lt; x &lt;&lt; \"is less than 10\\n\"; return 0;&#125;程序2：（去掉大括号）123456789101112131415161718#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; \"Enter a number: \"; int x; std::cin &gt;&gt; x; if (x &gt;= 10) //删除大括号 if (x &lt;= 20) std::cout &lt;&lt; x &lt;&lt; \"is between 10 and 20\\n\"; else // attached to outer if statement std::cout &lt;&lt; x &lt;&lt; \"is less than 10\\n\"; return 0;&#125;程序1和2是否一样呢？答：不一样。程序1中的最后的else语句是与第一个if语句匹配；程序2中的最后的else语句是与它最近的if语句匹配。if中的初始化语句如果需要在If语句中使用变量，而不是在If语句之外，那么可以在条件之前使用init语句(在C++17中添加的）。1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;int main()&#123; std::string firstname&#123;&#125;; std::string lastname&#123;&#125;; std::cout &lt;&lt; \"First name: \"; std::cin &gt;&gt; firstName; std::cout &lt;&lt; \"Last name: \"; std::cin &gt;&gt; lastName; if(std::string fullname &#123;firsstname + ' ' + lastname&#125;; fullname.length()&gt;20) &#123; std::cout &lt;&lt; '\"'&lt;&lt;fullname &lt;&lt;'\\\" is to long \\n'; &#125; else &#123; std::cout &lt;&lt;\"your name is: \" &lt;&lt;fullname; &#125; return 0; &#125;变量fullname在整个if语句中是可以访问的。L5.2 switch语句C++ 中 switch 语句的语法：123456789101112switch(expression)&#123; case constant-expression : statement(s); break; // 可选的 case constant-expression : statement(s); break; // 可选的 // 您可以有任意数量的 case 语句 default : // 可选的 statement(s);&#125;switch 语句必须遵循下面的规则：switch 语句中的 expression 必须是一个integral type(整数类型)或浮点类型，或者是一个 class 类型，其中 class 有一个单一的转换函数将其转换为整型或枚举类型。整数类型有：char, short, int, long, long long, or enum注意，在C/C++中，char是属于整数类型的。在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。case 的 constant-expression 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 break 语句为止。当遇到 break 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。不是每一个 case 都需要包含 break。如果 case 语句不包含 break，控制流将会 继续 后续的 case，直到遇到 break 为止。一个 switch 语句可以有一个可选的 default case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 break 语句不是必需的。break在case语句中有、无 break 的效果在 switch 语句中，每个 case 语句的结尾不要忘记添加 break 语句，否则将导致多个分支重叠。当然，除非有意使多个分支重叠，这样可以免去 break 语句。下面我们来看一个实际示例。1234567891011121314151617181920212223242526272829303132333435363738394041424344//有breakswitch (2)&#123; case 1: // Does not match std::cout &lt;&lt; 1 &lt;&lt; '\\n'; // skipped break; case 2: // Match! std::cout &lt;&lt; 2 &lt;&lt; '\\n'; // Execution begins here break; case 3: std::cout &lt;&lt; 3 &lt;&lt; '\\n'; // This is also executed break; case 4: std::cout &lt;&lt; 4 &lt;&lt; '\\n'; // This is also executed break; default: std::cout &lt;&lt; 5 &lt;&lt; '\\n'; // This is also executed break;&#125;/**结果******/2 //无breakswitch (2)&#123; case 1: // Does not match std::cout &lt;&lt; 1 &lt;&lt; '\\n'; // skipped case 2: // Match! std::cout &lt;&lt; 2 &lt;&lt; '\\n'; // Execution begins here case 3: std::cout &lt;&lt; 3 &lt;&lt; '\\n'; // This is also executed case 4: std::cout &lt;&lt; 4 &lt;&lt; '\\n'; // This is also executed default: std::cout &lt;&lt; 5 &lt;&lt; '\\n'; // This is also executed&#125;/******结果***********/2345case语句中变量的声明&amp;定义你可以在switch语句中声明变量(但不能够初始化)。在case之前或之后均可：12345678910111213141516171819202122switch (1)&#123; int a; // okay, declaration is allowed before the case labels int b = 5; // illegal, initialization is not allowed before the case labels case 1: int y; // okay, declaration is allowed within a case y = 4; // okay, 这个是赋值(不是初始化) break; case 2: y = 5; // okay, y was declared above, so we can use it here too break; case 3: int z = 4; // illegal, 不能再这里面对变量初始化 break; default: std::cout &lt;&lt; \"default case\" &lt;&lt; std::endl; break;&#125;因为在switch语句中，不存在隐式的块。所以，在switch语句内，所有语句的范围都一样(存在于switch的内部)。所以，在case 1：声明的变量y，可以在case 2：中被访问但是，不允许直接在case标签下面初始化变量，这会导致编译错误。这是因为初始化变量需要执行（声明语句不会执行），而包含初始化的case语句可能不会执行!但是我们可以在case块中，初始化变量：123456789101112switch (1)&#123; case 1: &#123; // note addition of block here int x = 4; // okay, variables can be initialized inside a block inside a case std::cout &lt;&lt; x; break; &#125; default: std::cout &lt;&lt; \"default case\" &lt;&lt; std::endl; break;&#125;L5.4 goto 语句goto语句是一个控制流语句，它使CPU跳到代码中的另一个位置。这个位置是通过使用statement label（语句标签）来标识的。eg:12345678910111213141516#include &lt;iostream&gt;#include &lt;cmath&gt; // for sqrt() function int main()&#123; double x;tryAgain: // this is a statement label std::cout &lt;&lt; \"Enter a non-negative number\"; std::cin &gt;&gt; x; if (x &lt; 0.0) goto tryAgain; // this is the goto statement std::cout &lt;&lt; \"The sqrt of \" &lt;&lt; x &lt;&lt; \" is \" &lt;&lt; sqrt(x) &lt;&lt; std::endl; return 0;&#125;如果用户输入的数是负数，那它会一直goto到这个语句标签，直到你输入一个合格的非负数。陷阱：12345678int main()&#123; goto skip; // invalid forward jump int x = 5;skip: x += 3; // what would this even evaluate to? return 0;&#125;我们不能这样使用 语句标签。因为我们跳转到标签语句skip中时，程序还没执行到int x = 5;这个语句。所以，会报错：如何改正：我们可以让int x=5;这个语句放在 goto skip;语句之前，就可以了。不建议使用goto语句goto的主要问题是，它允许程序员任意地在执行点上跳转。因此很难理解这种代码的逻辑。L5.7 for语句123//形式for (init-statement; condition-expression; end-expression) statement多重声明有时for循环需要多个变量。当这种情况发生时，程序员可以使用逗号操作符来分配(在init-statement中)或更改(在end-statement中)多个变量的值:12345678910 int iii&#123;&#125;; int jjj&#123;&#125;; for (iii = 0, jjj = 9; iii &lt; 10; ++iii, --jjj) std::cout &lt;&lt; iii &lt;&lt; ' ' &lt;&lt; jjj &lt;&lt; '\\n';//更常用的写法是：for(int iii&#123;0&#125;, jjj&#123;9&#125;; iii&lt;10; ++iii, --jjj)&#123; std::cout &lt;&lt;iii &lt;&lt;' ' &lt;&lt;jjj &lt;&lt; '\\n';&#125;L5.8 break 和 continuebreak与returnbreak语句是终止switch语句 或者 其他循环语句，然后继续执行该语句下面的语句。return语句终止循环所在的整个函数，并在调用函数的地方继续执行。请看下面例子：12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt; int breakOrReturn()&#123; while (true) // infinite loop &#123; std::cout &lt;&lt; \"Enter 'b' to break or 'r' to return: \"; char ch; std::cin &gt;&gt; ch; if (ch == 'b') break; // execution will continue at the first statement beyond the loop if (ch == 'r') return 1; // return will cause the function to immediately return to the caller (in this case, main()) &#125; // breaking the loop causes execution to resume here std::cout &lt;&lt; \"We broke out of the loop\\n\"; return 0;&#125; int main()&#123; int returnValue&#123; breakOrReturn() &#125;; std::cout &lt;&lt; \"Function breakOrReturn returned \" &lt;&lt; returnValue &lt;&lt; '\\n'; return 0;&#125;continuecontinue语句提供了一种方便的方法来跳转到当前迭代（当前这一层循环）的循环体的末尾。当我们想要提前终止当前的迭代时，这是很有用的。123456789101112for (int count&#123; 0 &#125;; count &lt; 20; ++count)&#123; // if the number is divisible by 4, skip this iteration if ((count % 4) == 0) continue; // jump to end of loop body // If the number is not divisible by 4, keep going std::cout &lt;&lt; count &lt;&lt; std::endl;------------------------------------------------------ // The continue statement jumps to here------------------------------------------------------&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://longlongqin.github.io/tags/C-C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"【六】Linux 档案与目录管理","slug":"Linux/Linux档案与目录管理","date":"2020-04-14T18:30:36.000Z","updated":"2020-04-19T14:38:29.546Z","comments":true,"path":"archives/426514b1.html","link":"","permalink":"https://longlongqin.github.io/archives/426514b1.html","excerpt":"鸟哥私房菜【六】http://linux.vbird.org/linux_basic/","text":"鸟哥私房菜【六】http://linux.vbird.org/linux_basic/目录相关操作变换目录：cd (Change Directory)12345. 代表此层目录.. 代表上一层目录- 代表前一个工作目录~ 代表『目前使用者身份』所在的家目录~account 代表account 这个使用者的家目录(account是个帐号名称)常见的处理目录的指令:cd：变换目录pwd：显示目前的目录mkdir：建立一个新的目录rmdir：删除一个空的目录cd (change directory, 变换目录)123456789101112131415161718#先切换身份成为root看看！[dmtsai@study ~]$ su - [root@study ~]# cd [相对路径或绝对路径] #最重要的就是目录的绝对路径与相对路径，还有一些特殊目录的符号啰！[root@study ~]# cd ~dmtsai #代表去到dmtsai这个使用者的家目录，亦即/home/dmtsai [root@study dmtsai]# cd ~ #表示回到自己的家目录，亦即是/ root这个目录 [root@study ~]# cd #没有加上任何路径，也还是代表回到自己家目录的意思喔！[root@study ~]# cd .. #表示去到目前的上层目录，亦即是/root的上层目录的意思； [root@study /]# cd - #表示回到刚刚的那个目录，也就是/root啰～ [root@study ~]# cd /var/spool/mail #这个就是绝对路径的写法！直接指定要去的完整路径名称！[root@study mail]# cd ../postfix# 这个是相对路径的写法，我们由/var/spool/mail 去到/var/spool/postfix 就这样写！pwd (显示目前所在的目录)1234pwd [-P]选项与参数：-P ：显示出真实的路径，而非使用连结(link) 路径。示例：1234567891011121314范例：单纯显示出目前的工作目录： [root@study ~]# pwd /root &lt;==显示出目录啦～范例：显示出实际的工作目录，而非连结档本身的目录名而已 [root@study ~]# cd /var/mail &lt;==注意，/var/mail是一个连结档 [root@study mail]# pwd /var/mail &lt;==列出目前的工作目录 [root@study mail]# pwd -P /var/spool/mail &lt;==怎么回事？有没有加-P差很多～ [root@study mail]# ls -ld /var/mail lrwxrwxrwx. 1 root root 10 May 4 17:51 /var/mail -&gt; spool/mail #看到这里应该知道为啥了吧？因为/var/mail是连结档，连结到/var/spool/mail# 所以，加上pwd -P 的选项后，会不以连结档的资料显示，而是显示正确的完整路径啊！mkdir (建立新目录)1mkdir [-m、p] 目录名称eg:12345678910111213141516171819202122[root@study ~]# mkdir [-mp]目录名称选项与参数：-m ：设定档案的权限喔！直接设定，不需要看预设权限(umask) 的脸色～-p ：帮助你直接将所需要的目录(包含上层目录)递回建立起来！范例：请到/tmp底下尝试建立数个新目录看看： [root@study ~]# cd /tmp [root@study tmp]# mkdir test &lt;==建立一名为test的新目录 [root@study tmp]# mkdir test1/test2/test3/test4mkdir: cannot create directory 'test1/test2/test3/test4': No such file or directory#话说，系统告诉我们，没可能建立这个目录啊！就是没有目录才要建立的！见鬼嘛？[root@study tmp]# mkdir -p test1/test2/test3/test4 #原来是要建test4上层没先建test3之故！加了这个-p的选项，可以自行帮你建立多层目录！范例：建立权限为rwx--x--x的目录 [root@study tmp]# mkdir -m 711 test2 [root@study tmp]# ls -ld test*drwxr-xr-x. 2 root root 6 Jun 4 19:03 testdrwxr-xr-x. 3 root root 18 Jun 4 19:04 test1drwx--x--x . 2 root root 6 Jun 4 19:05 test2 #仔细看上面的权限部分，如果没有加上-m来强制设定属性，系统会使用预设属性。#那么你的预设属性为何？这要透过底下介绍的umask才能了解喔！^_^rmdir (删除『空』的目录)1rmdir [-p] 目录名称1234567891011121314151617[root@study ~]# rmdir [-p]目录名称选项与参数：-p ：连同『上层』『空的』目录也一起删除范例：将于mkdir范例中建立的目录(&#x2F;tmp底下)删除掉！[root@study tmp]# ls -ld test* &lt;&#x3D;&#x3D;看看有多少目录存在？drwxr-xr-x. 2 root root 6 Jun 4 19:03 testdrwxr-xr-x. 3 root root 18 Jun 4 19:04 test1drwx--x--x. 2 root root 6 Jun 4 19:05 test2[root@study tmp]# rmdir test &lt;&#x3D;&#x3D;可直接删除掉，没问题 [root@study tmp]# rmdir test1 &lt;&#x3D;&#x3D;因为尚有内容，所以无法删除！rmdir: failed to remove &#39;test1&#39;: Directory not empty[root@study tmp]# rmdir -p test1&#x2F;test2&#x2F;test3&#x2F;test4 [root@study tmp]# ls -ld test* &lt;&#x3D;&#x3D;您看看，底下的输出中test与test1不见了！drwx--x--x. 2 root root 6 Jun 4 19:05 test2# 瞧！利用-p 这个选项，立刻就可以将test1&#x2F;test2&#x2F;test3&#x2F;test4 一次删除～# 不过要注意的是，这个rmdir 仅能『删除空的目录』喔！","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"linux","slug":"学习笔记/linux","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://longlongqin.github.io/tags/linux/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"LearnCpp chapterP","slug":"C&C++/LearnCpp-chapterS","date":"2020-04-14T08:48:27.000Z","updated":"2020-04-19T14:38:29.546Z","comments":true,"path":"archives/67343d3.html","link":"","permalink":"https://longlongqin.github.io/archives/67343d3.html","excerpt":"LearnCpp chapterPhttps://www.learncpp.com","text":"LearnCpp chapterPhttps://www.learncpp.comS.4.4b 介绍std::string字符串在程序中很常见，大部分现代编程语言都包括一个内置的字符串数据类型。C++包括一个，不是作为核心语言的一部分，而是作为标准库的一部分。std::string如果想在C++中使用string类型。需要加入头文件#include &lt;string&gt;来声明std::string。只要有这个头文件，我们就可以在程序中使用string类型。12#include &lt;string&gt;std::string myName;就像其他类型一样，你可以为字符串类型的变量进行初始化 或者 复制：12std::string myName&#123; \"Alex\" &#125;; // initialize myName with string literal \"Alex\"myName = \"John\"; // assign variable myName the string literal \"John\"字符串也可以保存数字：1std::string myID&#123; \"45\" &#125;; // \"45\" is not the same as integer 45!字符串格式的 数字，其实是文本形式，而不是 数字形式。输入输出字符串12345678910111213#include &lt;string&gt;#include &lt;iostream&gt; int main()&#123; std::string myName&#123; \"Alex\" &#125;; std::cout &lt;&lt; \"My name is: \" &lt;&lt; myName &lt;&lt; '\\n'; return 0;&#125;/************打印***********/My name is: Alex但是，使用std::cin来输入字符串，可能会产生异常：1234567891011121314151617#include &lt;string&gt;#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; \"Enter your full name: \"; std::string name; std::cin &gt;&gt; name; // this won't work as expected since std::cin breaks on whitespace std::cout &lt;&lt; \"Enter your age: \"; std::string age; std::cin &gt;&gt; age; std::cout &lt;&lt; \"Your name is \" &lt;&lt; name &lt;&lt; \" and your age is \" &lt;&lt; age &lt;&lt; '\\n'; return 0;&#125;结果：可以看到，大 魔头中间有空格。然后就会被自动截断，前一部分赋值给变量name；第二半段赋值给age。也就是说：那是不对的!发生了什么事?结果表明，当使用操作符&gt;&gt;从cin提取字符串时，操作符&gt;&gt;只返回它遇到的第一个空格之前的字符。其他字符留在cin中，等待下一次提取。用std::getline()输入文本要将整行输入读入字符串，我们最好需要使用std::getline()函数。std::getline()含有两个形参：第一个是std::cin；第二个是我们输入的字符串的变量12345678910111213141516171819202122#include &lt;string&gt;#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; \"Enter your full name: \"; std::string name&#123;&#125;; std::getline(std::cin, name); // read a full line of text into name std::cout &lt;&lt; \"Enter your age: \"; std::string age&#123;&#125;; std::getline(std::cin, age); // read a full line of text into age std::cout &lt;&lt; \"Your name is \" &lt;&lt; name &lt;&lt; \" and your age is \" &lt;&lt; age &lt;&lt; '\\n'; return 0;&#125;/********结果**************/Enter your full name: John DoeEnter your age: 23Your name is John Doe and your age is 23混合使用std::cin、std::getline()混合使用他俩，可能会产生异常：1234567891011121314151617#include &lt;string&gt;#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; \"Pick 1 or 2: \"; int choice&#123;&#125;; std::cin &gt;&gt; choice; std::cout &lt;&lt; \"Now enter your name: \"; std::string name&#123;&#125;; std::getline(std::cin, name); std::cout &lt;&lt; \"Hello, \" &lt;&lt; name &lt;&lt; \", you picked \" &lt;&lt; choice &lt;&lt; '\\n'; return 0;&#125;这个程序首先要求您输入1或2，然后等待您这样做。到目前为止一切顺利。然后它会要求你输入你的名字。然而，它实际上不会等待您输入您的名字！相反，它打印“Hello”行，然后退出。发生了什么事?结果是，当您使用cin输入一个值时，cin不仅捕获值，还捕获换行符。当我们输入2时，cin实际上会得到字符串“2\\n”。然后提取2到变量选择，使换行留在输入流中。然后，当std::getline()去读取名称时，它会看到“\\n”已经在流中，并且认为我们必须输入一个空字符串!绝对不是我们想要的。一个好方法：使用std::cin读取完值 之后，将换行 从输入流中删除：std::cin.ignore(32767, &#39;\\n&#39;); //忽略不超过32767个字符，直到删除一个\\n.关于32767请看下一节如下，在main函数中，增加一句std::cin.ignore(32767, &#39;\\n&#39;);：1234567891011121314151617int main()&#123; std::cout &lt;&lt; \"Pick 1 or 2: \"; int choice&#123;&#125;; std::cin &gt;&gt; choice; //新加 std::cin.ignore(32767, '\\n'); // ignore up to 32767 characters until a \\n is removed std::cout &lt;&lt; \"Now enter your name: \"; std::string name; std::getline(std::cin, name); std::cout &lt;&lt; \"Hello, \" &lt;&lt; name &lt;&lt; \", you picked \" &lt;&lt; choice &lt;&lt; '\\n'; return 0;&#125;规则:如果使用std::cin读取值，最好使用std:: cin .ignore()来删除多余的换行符。32767代表什么这告诉std::cin.ignore()要忽略多少字符。我们选择32767是因为它是保证在所有平台上都适合(2字节)整数的最大带符号值。从技术上讲，忽略无限量输入的正确方法如下:12345#include &lt;limits&gt; ... std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n'); // ignore unlimited characters until a \\n is removed但是，相比之下，这样的方式太复杂了。而且还需要加上头文件limits字符串的“加法”12345678910111213141516171819#include &lt;string&gt;#include &lt;iostream&gt; int main()&#123; std::string a&#123; \"45\" &#125;; std::string b&#123; \"11\" &#125;; std::cout &lt;&lt; a + b &lt;&lt; '\\n'; // a and b will be concatenated a += \"volts\"; std::cout &lt;&lt; a; return 0;&#125;/*****结果********/451145volts注意，如果你想对字符串减法，是不可以的熬字符串长度12345678910#include &lt;string&gt;#include &lt;iostream&gt; int main()&#123; std::string myName&#123; \"Alex\" &#125;; std::cout &lt;&lt; myName &lt;&lt; \" has \" &lt;&lt; myName.length() &lt;&lt; \" characters\\n\"; std::cout &lt;&lt; myName &lt;&lt; \" has \" &lt;&lt; length(myName) &lt;&lt; \" characters\\n\";//error:未定义标识符 length return 0;&#125;注意，我们不是将字符串长度作为length(myName)，而是使用myName.length()。length函数不是我们目前使用的一个普通的独立函数，它是属于std::string的一种特殊类型的函数，称为成员函数。S.4.4c 使用语言参考本节原文地址：S.4.4c — Using a language reference其中一个资源是Stack Overflow，你可以在这里提问；另一个就是语言参考文档： cppreference；S.4.5 枚举类型c++包含允许程序员创建自己的数据类型的功能。这些数据类型称为用户定义的数据类型。枚举类型(也称为enumeration或enum)是一种数据类型，其中每个可能的值都被定义为符号常量(称为enumerator(枚举器))。枚举是通过enum关键字定义的。让我们来看一个例子:注意，每个枚举数由逗号分隔，整个枚举以分号结束。1234567891011121314151617181920// Define a new enumeration named Colorenum Color&#123; // Here are the enumerators // These define all the possible values this type can hold // Each enumerator is separated by a comma, not a semicolon COLOR_BLACK, COLOR_RED, COLOR_BLUE, COLOR_GREEN, COLOR_WHITE, COLOR_CYAN, COLOR_YELLOW, COLOR_MAGENTA, // see note about trailing comma on the last enumerator below&#125;; // however the enum itself must end with a semicolon // Define a few variables of enumerated type ColorColor paint = COLOR_WHITE;Color house(COLOR_BLUE);Color apple &#123; COLOR_RED &#125;;定义一个枚举类型(也可以说，定义一个用户自定义类型)时，是不会给它分配内存的；只有当定义了枚举类型的变量(如上面示例中的变量paint)时，才会为该变量分配内存。在c++ 11之前，不允许在最后一个枚举数之后使用逗号(例如，在COLOR_MAGENTA之后)(尽管许多编译器都接受了逗号)。但是，从c++ 11开始，允许使用逗号结尾。现在c++ 11编译器更加流行了，一般认为在最后一个元素后面使用逗号是可以接受的。枚举的命名和枚举器枚举的命名是可选的，通常，没有名字的枚举有时被称为匿名枚举。枚举的名字通常以大写字母开头。枚举器(枚举常量)是必须要给出名字的。它的名字通常是大写字母(如，COLOR_WHITE)，或者以大写字母K为前缀(如， kColorWhite)枚举常量的范围因为枚举常量被放在与枚举相同的命名空间中，所以，枚举常量名字不能用于同一命名空间内的多个枚举:12345678910111213enum Color&#123;RED,BLUE, // BLUE is put into the global namespaceGREEN&#125;; enum Feeling&#123;HAPPY,TIRED,BLUE // error, BLUE was already used in enum Color in the global namespace&#125;;枚举常量的值每个枚举器根据其在枚举列表中的位置自动分配一个整数值。默认情况下，第一个枚举数被赋值为整数值0，随后的每个枚举数的值都比前一个枚举数大1:1234567891011121314151617enum Color&#123; COLOR_BLACK, // assigned 0 COLOR_RED, // assigned 1 COLOR_BLUE, // assigned 2 COLOR_GREEN, // assigned 3 COLOR_WHITE, // assigned 4 COLOR_CYAN, // assigned 5 COLOR_YELLOW, // assigned 6 COLOR_MAGENTA // assigned 7&#125;; Color paint(COLOR_WHITE);std::cout &lt;&lt; paint;/*********结果*********/4你也可以显式定义枚举数的值。这些整数值可以是正的，也可以是负的，并且可以与其他枚举数共享相同的值。任何未定义的枚举数都被赋予一个比前一个枚举数大1的值。12345678910// define a new enum named Animalenum Animal&#123; ANIMAL_CAT = -3, ANIMAL_DOG, // assigned -2 ANIMAL_PIG, // assigned -1 ANIMAL_HORSE = 5, ANIMAL_GIRAFFE = 5, // shares same value as ANIMAL_HORSE ANIMAL_CHICKEN // assigned 6&#125;;注意到：ANIMAL_HORSE和ANIMAL_GIRAFFE的值相同。这表示他们两个可以互换。即，它俩没区别。虽然，C++允许这样，但是不建议将枚举常量赋值位相同的值。枚举类型的input/output因为枚举值是整数类型的，所以它们可以被赋值给整型变量。这意味着它们可以 以integers形式被output，因为std::cout知道如何输出整数。12345int mypet = ANIMAL_PIG;std::cout &lt;&lt; ANIMAL_PIG;//evaluates to integer before being passed to std::cout/*******结果*****/5编译器不会隐式的将整型转变为枚举类型值。1234Animal animal = 5; // will cause compiler error//但是我们可以使用 static_cast 来强制转换Color color = static_cast&lt;Color&gt;(5); // ugly编译器也不会让你输入一个枚举类型：1234567891011121314151617181920enum Color&#123; COLOR_BLACK, // assigned 0 COLOR_RED, // assigned 1 COLOR_BLUE, // assigned 2 COLOR_GREEN, // assigned 3 COLOR_WHITE, // assigned 4 COLOR_CYAN, // assigned 5 COLOR_YELLOW, // assigned 6 COLOR_MAGENTA // assigned 7&#125;; Color color;std::cin &gt;&gt; color; // will cause compiler error//但是，我们可以通过读取一个整型，并使用static_cast来强制编译器将整型值放入枚举类型中：int inputColor;std::cin&gt;&gt; inpitColor;Color color&#123; static_cast&lt;Color&gt;(inputColor) &#125;;每个枚举类型都被认为是不同的类型。因此，试图将枚举数从一个枚举类型分配到另一个枚举类型将导致编译错误:1Animal animal&#123; COLOR_BLUE &#125;; // will cause compiler error如果您想为枚举器使用不同的整数类型，你可以您可以在enum声明中指定它：1234567// Use an 8 bit unsigned integer as the enum base.enum Color : std::uint_least8_t&#123; COLOR_BLACK, COLOR_RED, // ...&#125;;枚举类型的提前声明。12345678910111213enum Color; // Errorenum Color : int; // Okay // ... // Because Color was forward declared with a fixed base, we// need to specify the base again at the definition.enum Color : int&#123; COLOR_BLACK, COLOR_RED, // ...&#125;;Enum分配和提前声明Enum类型被认为是整数类型家族的一部分，它由编译器决定为Enum变量分配多少内存。c++标准要求枚举的大小必须足够大，以表示所有枚举值。通常，它会使enum变量的大小与标准int相同。因为编译器知道给枚举类型分配多少内存，所以您只能在指定固定基数时，才可以提前声明它们。枚举器有什么用?当需要表示特定的预定义状态集时，枚举类型对于代码文档和可读性非常有用。如：1234567891011int readFileContents()&#123; if (!openFile()) return -1; if (!readFile()) return -2; if (!parseFile()) return -3; return 0; // success&#125;负数用来表示不同的可能的错误代码。如上面：-1 -2 -3然而，使用像这样的神奇数字并不是很有描述性。另一种方法是使用枚举类型：这种方法可读性更强。12345678910111213141516171819enum ParseResult&#123; SUCCESS = 0, ERROR_OPENING_FILE = -1, ERROR_READING_FILE = -2, ERROR_PARSING_FILE = -3&#125;; ParseResult readFileContents()&#123; if (!openFile()) return ERROR_OPENING_FILE; if (!readFile()) return ERROR_READING_FILE; if (!parsefile()) return ERROR_PARSING_FILE; return SUCCESS;&#125;调用者可以根据适当的枚举器测试函数的返回值，这比测试特定整数值的返回结果更容易理解。如：12345678if (readFileContents() == SUCCESS) &#123; // do something &#125;else &#123; // print error message &#125;许多语言使用枚举定义布尔值。布尔值本质上就是一个有两个枚举器的枚举:false和true!然而，在c++中，true和false被定义为关键字，而不是枚举数。S.4.6 枚举类C++11定义了一个新概念，enum class(枚举类)，也称 scoped enumeration（作用域枚举）。我们在enum之后使用关键字 class来构造枚举类：1234567891011121314151617181920212223242526#include &lt;iostream&gt; int main()&#123; enum class Color // \"enum class\" defines this as a scoped enumeration instead of a standard enumeration &#123; red, // red is inside the scope of Color blue &#125;; enum class Fruit &#123; banana, // banana is inside the scope of Fruit apple &#125;; Color color&#123; Color::red &#125;; // note: red is not directly accessible any more, we have to use Color::red Fruit fruit&#123; Fruit::banana &#125;; // note: banana is not directly accessible any more, we have to use Fruit::banana if (color == fruit) // compile error here, as the compiler doesn't know how to compare different types Color and Fruit std::cout &lt;&lt; \"color and fruit are equal\\n\"; else std::cout &lt;&lt; \"color and fruit are not equal\\n\"; return 0;&#125;对于正常的枚举，枚举器被放置在与枚举本身相同的范围内。所以，我们可以直接访问枚举器(枚举常量). (e.g. red).因为枚举器是enum类的一部分，所以不需要在枚举器名称前面加上前缀(例如，可以使用red而不是COLOR_red，因为Color::COLOR_red是多余的)。但是，在枚举类中，严格的范围规则意味着所有的枚举器(枚举常量)是枚举的一部分。所以，我们必须使用必须使用范围限定符来访问枚举器(例如，Color::red)。这有助于降低名称污染和名称冲突的可能性。强类型规则意味着每个enum类都被认为是唯一的类型。这意味着编译器不会隐式地比较来自不同枚举的枚举数。如果尝试这样做，编译器将抛出一个错误，如上面的示例所示。然而，你仍然可以在同一枚举类 内部进行 枚举常量的比较(因为让门属于同一类型)：12345678910111213141516171819#include &lt;iostream&gt; int main()&#123; enum class Color &#123; red, blue &#125;; Color color&#123; Color::red &#125;; if (color == Color::red) // this is okay(这样是可以的) std::cout &lt;&lt; \"The color is red!\\n\"; else if (color == Color::blue) std::cout &lt;&lt; \"The color is blue!\\n\"; return 0;&#125;使用enum类，编译器将不再隐式地将枚举数值转换为整数。这基本上是一件好事。但是，在某些情况下，这样做是有用的。在这些情况下，可以使用static_cast将enum类枚举数显式转换为整数:1234567891011121314151617#include &lt;iostream&gt; int main()&#123; enum class Color &#123; red, blue &#125;; Color color&#123; Color::blue &#125;; std::cout &lt;&lt; color; // won't work, because there's no implicit conversion to int std::cout &lt;&lt; static_cast&lt;int&gt;(color); // will print 1 return 0;&#125;【note】万一你遇到它，“enum struct”相当于“enum class”。但这种用法不推荐，也不常用。S.4.7 structc++允许我们创建自己的用户定义的aggregate data types(聚集数据类型)。聚集数据类型：是将多个单独变量分组在一起的数据类型struct就是聚集数据类型的最简单之一。struct的定义&amp;声明因为structs是用户自定义的，所以我们首先要在使用它之前，必须要告诉编译器我们的struct是什么样的。我们使用struct关键字声明结构体。12345678//告诉编译器我们定义了一个结构体，名为Employeestruct Employee&#123; short id; int age; double wage;&#125;;//这些结构中的变量称为 **成员(或字段)**。记住，上面的Employee只是一个声明。尽管我们告诉编译器结构体将有成员变量，但此时没有分配内存。按照惯例，结构名以大写字母开头，以便与变量名区分开来。为了使用Employee结构，我们只需声明一个类型为Employee的变量:1Employee joe; // struct Employee is capitalized, variable joe is not这定义了一个名为joe的Employee类型的变量。与普通变量一样，定义结构变量为该变量分配内存。访问结构体成员当我们定义一个变量如Employee joe时，joe引用整个结构(包含成员变量)。为了访问各个成员，我们使用member selection operator(成员选择操作符)。下面是一个使用成员选择操作符初始化每个成员变量的例子:123456789Employee joe; // create an Employee struct for Joejoe.id = 14; // assign a value to member id within struct joejoe.age = 32; // assign a value to member age within struct joejoe.wage = 24.15; // assign a value to member wage within struct joe Employee frank; // create an Employee struct for Frankfrank.id = 15; // assign a value to member id within struct frankfrank.age = 28; // assign a value to member age within struct frankfrank.wage = 18.27; // assign a value to member wage within struct frank与普通变量一样，结构成员变量没有初始化，通常会包含垃圾。我们必须手动初始化它们。Struct成员变量的作用就像普通变量一样，所以可以对它们进行普通操作:1234567891011121314int totalAge&#123; joe.age + frank.age &#125;; if (joe.wage &gt; frank.wage) std::cout &lt;&lt; \"Joe makes more than Frank\\n\";else if (joe.wage &lt; frank.wage) std::cout &lt;&lt; \"Joe makes less than Frank\\n\";else std::cout &lt;&lt; \"Joe and Frank make the same amount\\n\"; // Frank got a promotionfrank.wage += 2.50; // Today is Joe's birthday++joe.age; // use pre-increment to increment Joe's age by 1初始化结构体通过逐个成员分配值来初始化结构有点麻烦，因此，c++支持使用initializer list(初始化列表)来初始化结构体的更快方法:123456789struct Employee&#123; short id; int age; double wage;&#125;; Employee joe&#123; 1, 32, 60000.0 &#125;; // joe.id = 1, joe.age = 32, joe.wage = 60000.0Employee frank&#123; 2, 28 &#125;; // frank.id = 2, frank.age = 28, frank.wage = 0.0 (default initialization)在C++11/14中: Non-static member initialization从c++ 11开始，可以给非静态(普通)结构成员一个默认值:1234567891011121314struct Rectangle&#123; double length&#123; 1.0 &#125;; double width&#123; 1.0 &#125;;&#125;; int main()&#123; Rectangle x; // length = 1.0, width = 1.0 x.length = 2.0; // you can assign other values like normal return 0;&#125;不幸的是，在c++ 11中，非静态成员初始化语法与初始化列表和统一的初始化语法不兼容。例如，在c++ 11中，以下程序无法编译:123456789101112struct Rectangle&#123; double length&#123; 1.0 &#125;; // non-static member initialization double width&#123; 1.0 &#125;;&#125;; int main()&#123; Rectangle x&#123; 2.0, 2.0 &#125;; // uniform initialization/initializer list【推荐】 return 0;&#125;因此，在c++ 11中，您必须决定是使用非静态成员初始化还是使用统一初始化。统一初始化更加灵活，因此我们建议坚持使用这种方法。然而，在c++ 14中，这个限制被取消了，两者都可以使用。如果两者都提供了，则优先使用初始化列表/统一初始化语法（即：initializer list）。在上面的例子中，矩形x的length和width将用2.0进行初始化。在c++ 14中，两者都使用应该是首选的，因为它允许您声明具有或不具有初始化参数的结构，并确保成员已初始化对结构体赋值12345678910111213141516171819202122struct Employee&#123; short id; int age; double wage;&#125;; Employee joe;joe = &#123; 1, 32, 60000.0 &#125;; // C++11 only(只在C++11中可以使用)//在C++11之前struct Employee&#123; short id; int age; double wage;&#125;; Employee joe;joe.id = 1;joe.age = 32;joe.wage = 60000.0;结构体与函数与单个变量相比，使用struct的一大好处是，我们可以将整个struct传递给一个需要与成员协同工作的函数:这避免了我们必须单独传递每个变量。12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt; struct Employee&#123; short id; int age; double wage;&#125;; void printInformation(Employee employee)&#123; std::cout &lt;&lt; \"ID: \" &lt;&lt; employee.id &lt;&lt; '\\n'; std::cout &lt;&lt; \"Age: \" &lt;&lt; employee.age &lt;&lt; '\\n'; std::cout &lt;&lt; \"Wage: \" &lt;&lt; employee.wage &lt;&lt; '\\n';&#125; int main()&#123; Employee joe &#123; 14, 32, 24.15 &#125;; Employee frank &#123; 15, 28, 18.27 &#125;; // Print Joe's information printInformation(joe); std::cout &lt;&lt; '\\n'; // Print Frank's information printInformation(frank); return 0;&#125;/******结果*********/ID: 14Age: 32Wage: 24.15ID: 15Age: 28Wage: 18.27我们将整个Employee结构传递给printInformation() (通过值传递，这意味着实参被复制到形参中)。函数的返回可以是一个结构体：一个函数也可以返回一个结构体，这是使一个函数返回多个变量的几种方法之一。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt; struct Point3d&#123; double x; double y; double z;&#125;; Point3d getZeroPoint()&#123; // We can create a variable and return the variable. Point3d temp &#123; 0.0, 0.0, 0.0 &#125;; return temp;&#125; Point3d getZeroPoint2()&#123; // We can return directly. We already specified the type // at the function declaration (Point3d), so we don't need // it again here. return &#123; 0.0, 0.0, 0.0 &#125;;&#125; Point3d getZeroPoint3()&#123; // We can use empty curly braces to zero-initialize all // members of `Point3d`. return &#123;&#125;;&#125; int main()&#123; Point3d zero&#123; getZeroPoint() &#125;; if (zero.x == 0.0 &amp;&amp; zero.y == 0.0 &amp;&amp; zero.z == 0.0) std::cout &lt;&lt; \"The point is zero\\n\"; else std::cout &lt;&lt; \"The point is not zero\\n\"; return 0;&#125;结构体嵌套结构体可以包含其他结构体。例如:12345678910111213141516struct Employee&#123; short id; int age; double wage;&#125;; struct Company&#123; Employee CEO; // Employee is a struct within the Company struct int numberOfEmployees;&#125;; Company myCompany;//我们可以使用初始化列表初始化它们：//Company myCompany&#123;&#123; 1, 42, 60000.0 &#125;, 5 &#125;;结构体的大小结构体的大小是所有成员大小的总和，但这不是一定的。12345678910111213141516struct Employee&#123; short id; int age; double wage;&#125;; int main()&#123; std::cout &lt;&lt; \"The size of Employee is \" &lt;&lt; sizeof(Employee) &lt;&lt; '\\n'; return 0;&#125;/*******结果*************/The size of Employee is 16结果是，我们只能说结构体的大小至少与它所包含的所有变量的大小一样大。但它可以更大! 出于性能原因，编译器有时会在结构中添加空白(这称为padding(填充))。事实上，上面程序中的Employee结构体中，编译器在成员id的后面添加了2个字节的填充(这是不可见的)。所以才导结构的大小为16字节，而不是14字节。本课介绍的结构有时被称为plain old data structs(普通旧数据结构)(或POD结构)，因为成员都是数据(变量)成员。将来(当我们讨论类时)，我们将讨论其他类型的成员","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://longlongqin.github.io/tags/C-C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"LearnCpp chapterP","slug":"C&C++/LearnCpp-chapterP","date":"2020-04-14T08:42:47.783Z","updated":"2020-04-19T14:38:29.545Z","comments":true,"path":"archives/67343d3.html","link":"","permalink":"https://longlongqin.github.io/archives/67343d3.html","excerpt":"LearnCpp chapterPhttps://www.learncpp.com","text":"LearnCpp chapterPhttps://www.learncpp.com","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://longlongqin.github.io/tags/C-C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"【转】Github下载提速","slug":"实用技巧/[转]Github克隆&下载提速","date":"2020-04-13T15:21:08.000Z","updated":"2020-04-19T14:38:29.546Z","comments":true,"path":"archives/260c7660.html","link":"","permalink":"https://longlongqin.github.io/archives/260c7660.html","excerpt":"Github克隆&下载提速以上内容转载于：https://mp.weixin.qq.com/s/SYR4zvjhAH1mX9fxdp8cbA原作者：codesheep","text":"Github克隆&下载提速以上内容转载于：https://mp.weixin.qq.com/s/SYR4zvjhAH1mX9fxdp8cbA原作者：codesheep一个痛点众所周知，GitHub是一个巨大的开源宝库，以及程序员和编程爱好者的聚集地，包括我之前推荐的诸多优秀的开源项目全部都是位于GitHub上。但是每当我们看到优秀的开源项目，准备去下（bai）载（piao）时，会发现 git clone的速度异常之慢！就我个人而言，在我家里200M移动宽带的环境下，我克隆开源项目就没发现速度大于过 20.00KiB/s的时候，这简直太难受了。小项目倒还好，我等几分钟无所谓；一旦项目庞大起来，或者项目文件数目一多， git clone 大概率会失败！当然网上常见的诸如修改hosts、代理等方式实际使用效果并不一定好，而且也不稳定。“码云”是个好东西接下来就介绍一种GitHub下载的加速方法：通过国内码云平台的转接，来完成GitHub上项目的下载加速。感谢公众号小伙伴ioc提供思路（1）首先确保码云上有账户，可以正常使用，没有的可以自行注册一下。（2）点击右上角新建仓库的加号 +，选择“从 GitHub/GitLab导入仓库”菜单（3）然后填写位于 GitHub上你想 clone的仓库地址并导入这一步交给码云来做速度是非常快的，一会儿功夫，码云就克隆出了一份和GitHub上一模一样的项目！（4）接下来我们通过码云上的项目地址，将项目 clone到本地，这时候的clone速度就很快了，几 MB/s的速度是没问题的，很快项目就下载下来了。按道理讲这时候我们的目的已经达到了，不过不要忘了，还有一件事没做。重新关联远端地址要知道，这时候克隆到本地的项目关联的是码云Gitee的地址，已经和原来的GitHub项目完全脱离了，是另外一个副本。在必要情况下（比如我们就是要给GitHub上的某个项目提 PR），我们还需要重新将我们本地的项目关联到原来的GitHub项目上去，做法如下：（1）首先找到位于本地仓库目录下的隐藏文件夹 .git（2）用文本编辑器打开 .git文件夹中的 config配置文件将配置文件中的 [remote&quot;origin&quot;].url字段重新关联到原来位于GitHub上的GitHub项目地址当然你也可以通过命令行来修改远端地址，效果一样的至此大功告成，本地项目就相当于是 clone自GitHub，后续提代码，提 PR到GitHub上都没有问题。以上内容转载于：https://mp.weixin.qq.com/s/SYR4zvjhAH1mX9fxdp8cbA","categories":[{"name":"实用技巧","slug":"实用技巧","permalink":"https://longlongqin.github.io/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"github","slug":"github","permalink":"https://longlongqin.github.io/tags/github/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"【转】配置方法集合","slug":"配置/【转】配置方法集合","date":"2020-04-13T15:21:08.000Z","updated":"2020-04-19T14:38:29.546Z","comments":true,"path":"archives/6de95ae.html","link":"","permalink":"https://longlongqin.github.io/archives/6de95ae.html","excerpt":"","text":"WSL 使用指南：https://zhuanlan.zhihu.com/p/36482795OpenCV安装配置： http://blog.csdn.net/poem_qianmo/article/details/19809337onedrive无法启动：https://blog.ooolg.com/index.php/20190121/568=568.html","categories":[{"name":"配置","slug":"配置","permalink":"https://longlongqin.github.io/categories/%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"配置","slug":"配置","permalink":"https://longlongqin.github.io/tags/%E9%85%8D%E7%BD%AE/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"鸟哥私房菜linux","slug":"Linux/鸟哥私房菜","date":"2020-04-08T18:01:59.000Z","updated":"2020-04-19T14:38:29.546Z","comments":true,"path":"archives/7a585be8.html","link":"","permalink":"https://longlongqin.github.io/archives/7a585be8.html","excerpt":"鸟哥私房菜http://linux.vbird.org/linux_basic/","text":"鸟哥私房菜http://linux.vbird.org/linux_basic/5️⃣Linux的档案权限与目录配置元件内容叠代物件rwx档案详细资料data文件资料夹读到文件内容修改文件内容执行文件内容目录档名可分类抽屉读到档名修改档名进入该目录的权限(key)由一般用户切换为“root”身份：su -；返回一般用户身份：exit查看文件ls;复制：cp1cp 源档案名字 目的档案(档案副本的名称)改变档案属性与权限1、必须要进入档案所在目录中；2、所修改成的群组、所属者必须存在；3、只有root才有权限改变所属群组：chgrp1chgrp [-R] dirname/filename ...123选项与参数：-R : 进行递回(recursive)的持续变更，亦即连同级目录下的所有档案、目录 都更新成为这个群组之意。常常用在变更某一目录内所有的档案之情况。改变档案拥有者：chown12chown [-R] 帐号名称 档案或目录chown [-R] 帐号名称:群组名称 档案或目录 //:可以换为. 但是推荐使用:12选项与参数：-R : 进行递回(recursive)的持续变更，亦即连同次目录下的所有档案都变更改变权限：chmod使用数字改编权限12345chmod [-R] xyz 档案或目录-----------------------选项与参数：xyz : 就是刚刚提到的数字类型的权限属性，为rwx 属性数值的相加。-R : 进行递回(recursive)的持续变更，亦即连同次目录下的所有档案都会变更Linux档案的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限，先复习一下刚刚上面提到的资料：档案的权限字元为：『-rwxrwxrwx』，这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：r:4w:2x:1每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是：owner = rwx = 4+2+1 = 7group = rwx = 4+2+1 = 7others= — = 0+0+0 = 0符号类型改变档案权限因为有三种身份：(1)user (2)group (3)others。那么我们就可以由u, g, o来代表三种身份的权限。此外，a则代表all亦即全部的身份！也就是可以使用底下的方式来看：eg：","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"linux","slug":"学习笔记/linux","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://longlongqin.github.io/tags/linux/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"C&C++/LearnCpp-chapter6","slug":"C&C++/LearnCpp-chapter6","date":"2020-04-06T05:59:00.000Z","updated":"2020-04-19T14:38:29.547Z","comments":true,"path":"archives/2faa8a4b.html","link":"","permalink":"https://longlongqin.github.io/archives/2faa8a4b.html","excerpt":"LearnCpp chapter6https://www.learncpp.com","text":"LearnCpp chapter6https://www.learncpp.com6.2 用户自定义namespace在2.9 – Naming collisions and an introduction to namespaces中讲解了命名冲突和命名空间的内容。现在再次看一下命名冲突。下面的foo.cpp和goo.cpp两个源文件，中的函数有着不同的功能，但是它们的名字却是一样的：foo.cpp12345//this dosomething() adds the value of its parametersint dosomething(intx, int y)&#123; return x+y;&#125;goo.cpp12345//this dosomething() subtracts the value of its parametersint doSomething(int x, int y)&#123; return x - y;&#125;main.cpp123456789#include &lt;iostream&gt;int dosomething(int x, int y); //forward declaration for dosomethingint main()&#123; std::cout &lt;&lt; dosometing(4, 3) &lt;&lt;'\\n'; //which dosometing will we get? return 0;&#125;此时，编译器会将foo.cpp和goo.cpp都编译在同一个程序中。因为它们俩里面中的函数的名字、参数都一样，而且又在同一个范围中(global scope)，这将会造成“命名冲突”。结果就是，链接器工作时，将会发生错误：goo.cpp:3: multiple definition of &quot;doSomething(int, int)&quot;; foo.cpp:3: first defined here一个较好的解决办法就是，将你的函数放在你自己定义的“命名空间namespace **”中。定义自己的namespaceC++允许我们使用关键字namespace来定义自己的命名空间。由用户自定义的命名空间，叫：user-defined namespaces。而 由C++提供的命名空间，如 global namespace；或者由库提供的，如namespace std；它们就不是user-defined namespaces。命名空间的标识符通常 不大写。下面是对上面命名冲突的函数的改写：foo.cpp12345678namespace foo //定义一个命名空间，名字为：foo&#123; //this dosomething() belongs to namespace foo int dosomething(int x, int y) &#123; return x+y; &#125;&#125;goo.cpp12345678namespace goo //定义一个命名空间，名字为：goo&#123; //this dosomething() belongs namespace goo int dosomething(int x, int y) &#123; return x+y; &#125;&#125;main.cpp1234567int dosomething(int x, int y) //提前对函数dosomething()进行声明 int main()&#123; std::cout &lt;&lt;dosomething(4, 3)&lt;&lt;'\\n'; //which dosomething will we get? return 0;&#125;现在这个两个dosomething()函数都分别属于不同的命名空间了。让我们来运行一下。😂，新问题又出现了：ConsoleApplication1.obj : error LNK2019: unresolved external symbol &quot;int __cdecl doSomething(int,int)&quot; (?doSomething@@YAHHH@Z) referenced in function _main在这个改版中，其实编译器是满意的(因为我们已经进行提前声明)。但是链接器找不到一个在global namespace中的dosomething的定义。这是因为我们虽然为两个dosomething分别声明在不同的命名空间，可惜的是这两个命名空间都不属于 全局命名空间 中。这里有两个解决方案：1.使用scope resolution operator；2.通过using statements*使用范围解析操作符(::)访问名称空间 *【范围解析操作符：scope resolution operator(::)】告诉编译器在特定名称空间中查找标识符的最佳方法是使用scope resolution operator(::)“::”，它告诉编译器：应该在该操作符的 左操作数表示的范围中查找 操作符右边的操作数(也就是要找的标识符)下面是一个例子：对于后面的示例，为了便于阅读，我们将把示例压缩为一个文件解决方案。12345678910111213141516171819202122232425#include &lt;iostream&gt; namespace foo // define a namespace named foo&#123; // This doSomething() belongs to namespace foo int doSomething(int x, int y) &#123; return x + y; &#125;&#125; namespace goo // define a namespace named goo&#123; // This doSomething() belongs to namespace goo int doSomething(int x, int y) &#123; return x - y; &#125;&#125; int main()&#123; std::cout &lt;&lt; foo::doSomething(4, 3) &lt;&lt; '\\n'; // use the doSomething() that exists in namespace foo return 0;&#125;可以注意到main函数中的这个语句：std::cout &lt;&lt; foo::doSomething(4, 3) &lt;&lt; &#39;\\n&#39;;，就是用了“范围解析符 :: ”。该标识符的左操作数：foo，表示命名空间的名字。右操作数表示标识符。所以，foo::dosomething(4,3)，就表示：调用的函数dosomething()是来源于命名空间foo中的。小结解决命名冲突的步骤为：为这些同名的函数，均设置自己的命名空间；在使用这个同名函数的时候，还需要加上“范围解析符 :: ”没有前缀的范围解析符格式：:: 标识符没有前缀的范围解析符，就相当于它的范围是全局命名空间。例子：12345678910111213141516171819202122#include &lt;iostream&gt;void print() //this print lives in the global namespace&#123; std::cout &lt;&lt; \"there\"&lt;&lt;'\\n';&#125;namespace foo&#123; void print() // this print lives in the foo namespace &#123; std::cout &lt;&lt; \"Hello\"; &#125;&#125;int main()&#123; foo::print(); // call foo::print() ::print(); // call print() in global namespace (same as just calling print() in this case) return 0; &#125;允许多个命名空间块：Multiple namespace blocks allowed在多个位置(跨多个文件，或同一文件中的多个位置)声明名称空间块是合法的。命名空间内的所有声明都被认为是命名空间的一部分。例子1（多文件中）：circle.h123456789#if !defined(CIRCLE_H)#define CIRCLE_H namespace basicMath&#123; inline constexpr double pi&#123; 3.14 &#125;;&#125; #endifgrowth.h12345678910#if !defined(GROWTH_H)#define GROWTH_H namespace basicMath&#123; // the constant e is also part of namespace basicMath inline constexpr double e&#123; 2.7 &#125;;&#125; #endifmain.cpp123456789101112#include \"circle.h\" // for basicMath::pi#include \"growth.h\" // for basicMath::e #include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; basicMath::pi &lt;&lt; '\\n'; std::cout &lt;&lt; basicMath::e &lt;&lt; '\\n'; return 0;&#125;结果：3.142.7标准库充就分利用了这个特性，因为每个标准库头文件都将其声明包含在该头文件中包含的 命名空间std 块中。否则，整个标准库必须在一个头文件中定义!【note】：尽管你可以利用这个功能，将你写的函数添加到std namespace中，但是std namespace有一个规则，那就是禁止用户将自己的函数扩展到它的里面。例子2如果你将你的代码分离再多个文件中，你就必须在头文件和原文件中使用命名空间。add.h12345678910#if !defined(ADD_H)#define ADD_H namespace basicMath&#123; // function add() is part of namespace basicMath int add(int x, int y);&#125; #endifadd.cpp12345678910#include \"add.h\" namespace basicMath&#123; // define the function add() int add(int x, int y) &#123; return x + y; &#125;&#125;main.cpp12345678910#include \"add.h\" // for basicMath::add() #include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; basicMath::add(4, 3) &lt;&lt; '\\n'; return 0;&#125;如果在add.cpp中省略了namespace，将会导致链接器找不到basicMath::add。因为这个源文件在缺少namespace时，对add的定义是在全局命名空间中的。如果在add.h中省略namespace，将会导致在“main.cpp”中不能使用basicMath::add因为这个头文件在缺少namespace时，对add的声明是在全局命名空间中的。嵌套命名空间如：123456789101112131415161718#include &lt;iostream&gt; namespace foo&#123; namespace goo // goo is a namespace inside the foo namespace &#123; int add(int x, int y) &#123; return x + y; &#125; &#125;&#125; int main()&#123; std::cout &lt;&lt; foo::goo::add() &lt;&lt; '\\n'; return 0;&#125;所以，当我们要调用函数add的时候，我们使用格式为：foo::goo::add在C++17中，嵌套的命名空间也可以这样声明：123456789101112131415#include &lt;iostream&gt; namespace foo::goo // goo is a namespace inside the foo namespace (C++17 style)&#123; int add(int x, int y) &#123; return x + y; &#125;&#125; int main()&#123; std::cout &lt;&lt; foo::goo::add() &lt;&lt; '\\n'; return 0;&#125;给命名空间设置别名：namespace aliases在使用嵌套的命名空间的函数或变量时，我们需要将命名空间层级都全部写完整，这样会很麻烦，如果我们给这个嵌套的命名空间起一个别名就省事多了：123456789101112131415161718192021#include &lt;iostream&gt; namespace foo&#123; namespace goo &#123; int add(int x, int y) &#123; return x + y; &#125; &#125;&#125; int main()&#123; namespace boo = foo::goo; // boo now refers to foo::goo std::cout &lt;&lt; boo::add() &lt;&lt; '\\n'; // This is really foo::goo::add() return 0;&#125; // The boo alias ends here6.3 局部变量在 2.4 – Introduction to local scope,介绍了局部变量，它是在函数中的形参。局部变量的块范围标识符的范围决定了标识符在源码中可获得的区域。范围是一个“编译时间”的属性。局部变量的 块范围(block scope)，中的范围就是：从他们定义开始，到这个块结束 的这个范围。如：1234567#include &lt;iostream&gt;&#123; int i &#123;5&#125;; //i enters scope here double d &#123;4.0&#125;; // d enters scope here return 0;&#125;// i and d go out of scope here虽然函数的形参没有被定义在函数体的内部，但是对于典型函数而言，形参可以被看成，是属于函数体块的范围内。如下：1234567int max(int x, int y) //x and y enter scope here&#123; //将x、y中较大者分配给max int max&#123;(x&gt;y) ? x : y&#125;; //max enters scope here return max;&#125;// x, y and max leave scope here同一范围内的变量名不相同下面的函数在编译时会出错，因为该范围内的变量名相同了：1234void someFunction(int x)&#123; int x&#123;&#125;; //编译时会出错，因为这里的x和形参x之间命名冲突了&#125;局部变量的自动存储期变量的存储期(storage duration),也叫持续时长(duration)决定了什么时间以及如何创造和销毁它。通常，变量的存储器直接决定了它的“生命周期(lifetime)”例如，局部变量的存储器，意味着它在被定义时就被创建，然后在他被定义的范围块的尾部被销毁：1234567int main()&#123; int i &#123;5&#125;; //i created and initialized here double d &#123;4.0&#125;; //d created and initialized here return 0;&#125; // i and d are destoryed here由于这个原因，局部变量 有时也被称为：自动变量嵌套快中的局部变量局部变量可以被定义在嵌套块中，这和在函数体块中的局部变量工作流程相同：1234567891011int main() //外部块&#123; int x&#123;5&#125;; //x enters scope and is created here &#123; //嵌套块 int y &#123;7&#125;; //y enters scope and is created here &#125; // y goes out of scope and is destroyed here //此时，y就不能再被用了，因为它不属于现在所在的范围 return 0;&#125; // x goes out of scope and is destoryed here注意：变量x的范围是整个mian函数块中，自然，在嵌套块中，变量x也是有效的，即也可以访问它。局部变量的无连接标识符的另一个属性就是：“连接(linkage)”。一个标识符的linkage决定了该标识符的其他声明是否引用的是相同的对象。局部变量没有关联性，也就是说对一个标识符的每一个声明都代表不同的对象如：12345678int main()&#123; int x &#123;2&#125;; // local variable, no linkage &#123; int x &#123;3&#125;; //这个标识符x与上面的标识符x，表示的是不同对象(尽管他们名字相同) //但是现在嵌套外部的变量x被隐藏起来了(在6.5节会讲到变量隐藏) &#125;&#125;变量定义的范围如果一个变量仅在嵌套块中使用，那它就应该旨在嵌套块中被定义：1234567891011121314#include &lt;iostream&gt;int main()&#123; //don't define y here &#123; //y只在这个块中被使用，所以在这里定义它 int y&#123;5&#125;; std::cout &lt;&lt;y&lt;&lt;'\\n'; &#125; return 0;&#125;所以，我们尽量把变量定义在，使用它的范围内部。6.4 全局变量全局变量的声明通常，全局变量声明是在：头文件的下面，在其他代码的上面。123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;//在函数外面声明的变量是全局变量int g_x &#123;&#125;; // global variable g_xvoid doSomething()&#123; // global variables can be seen and used everywhere in the file g_x = 3; std::cout &lt;&lt; g_x &lt;&lt; '\\n';&#125;int main()&#123; doSomething(); std::cout &lt;&lt; g_x &lt;&lt; '\\n'; // global variables can be seen and used everywhere in the file g_x = 5; std::cout &lt;&lt; g_x &lt;&lt; '\\n'; return 0;&#125;// g_x goes out of scope here/********结果*****/335按照惯例， 在全局变量名字加上前缀“g”或者“g_”，来便于是显示的说明它是 全局变量全局变量的file scope&amp;静态持续时间file scope也叫：全局范围(global scope)或者全局命名空间范围(global namespace scope)因为全局变量是在函数外部定义的，所以也被视为“全局命名空间(global namespace)”的一部分。所以，才有global namespace scope这个叫法。也就是说，它们从被定义开始，到所在文件的结束期间 都是有效的。全局变量在程序开始被创建，在程序结束时被销毁。这成为“静态持续时间(static duration)”有着‘static duration’的变量，也被称为：“静态变量(static variable)”局部变量默认是不被初始化的，全局变量默认是被初始化为0的全局变量的初始化123int g_x; //没有显示的初始化变量(所以默认初始化为0)int g_y&#123;&#125;; //初始化为0int g_z&#123;3&#125;; //显示的初始化为3常量局部变量与局部变量一样，全局变量也可以是常量。只要是常量，那它就必须被初始化。1234567891011121314151617181920212223242526#include &lt;iostream&gt;const int g_x; //error:常量型的变量必须要被初始化constexpr int g_w; //error:常量型的变量必须要被初始化（constexpr，表示它是 编译时常量）const int g_y &#123;1&#125;; //正确，初始化了constexpr int g_z &#123;2&#125;; //正确，初始化了void dosomething()&#123; //全局变量在这个文件中的每一个地方都是有效的(可以被看见和使用) std::cout &lt;&lt; g_y &lt;&lt; '\\n'; std::cout &lt;&lt; g_z &lt;&lt; '\\n'; &#125;int main()&#123; dosomething(); //全局变量在这个文件中的每一个地方都是有效的(可以被看见和使用) std::cout &lt;&lt; g_y &lt;&lt; '\\n'; std::cout &lt;&lt; g_z &lt;&lt; '\\n'; return 0;&#125;// g_y and g_z goes out of scope here小结123456789101112// Non-constant global variables(非常量的全局变量)int g_x; // defines non-initialized global variable (zero initialized by default)int g_x &#123;&#125;; // defines explicitly zero-initialized global variableint g_x &#123; 1 &#125;; // defines explicitly initialized global variable // Const global variablesconst int g_y; // error: const variables must be initializedconst int g_y &#123; 2 &#125;; // defines initialized global constant // Constexpr global variablesconstexpr int g_y; // error: constexpr variables must be initializedconstexpr int g_y &#123; 3 &#125;; // defines initialized global const6.5 变量被隐藏局部变量被隐藏123456789101112131415161718192021#include &lt;iostream&gt;int main()&#123;// outer block int apples &#123; 5 &#125;; // 嵌套外部的apples &#123;// nested block std::cout &lt;&lt;apples&lt;&lt;'\\n'; //这里的apples是嵌套外部的 int apples &#123;0&#125;; //在嵌套内部定义变量apples //现在的apples指的是嵌套内部 的apples.嵌套外部的apples现在被隐藏起来了 apples = 10; //现在被赋值的apples指的是嵌套内部的apples std::cout &lt;&lt; apples &lt;&lt;'\\n'' &#125; //嵌套块内部的apples被销毁 std::cout &lt;&lt;apples&lt;&lt;'\\n'; //这个apples指的是嵌套外部的apples(因为现在，嵌套内部的apples已经被销毁) return 0；&#125; //嵌套外部的apples被销毁运行结果：1235105全局变量被隐藏就像局部变量中的，嵌套块中的变量可以将嵌套外部的同名变量以藏起来 一样。局部变量可以将全局中的同名变量隐藏起来:123456789101112131415161718#include &lt;iostream&gt;int a &#123;5&#125;; //全局变量 void foo() &#123; std::cout &lt;&lt;\"global variable a：\"&lt;&lt;a&lt;&lt;'\\n';//此时，全局变量a还没有被隐藏。即，这里的变量a，指的是全局变量 &#125;int main()&#123; int a &#123;7&#125;; //此时，全局变量a就被这里的局部变量a 隐藏起来了 ++a; //局部变量a加1，而不是全局变量 std::cout &lt;&lt; \"local variable a: \" &lt;&lt; a &lt;&lt; '\\n'; foo(); return 0;&#125; // 局部变量a被销毁运行结果:12local variable a: 8global variable a: 5然而啊，全局变量是属于全局的命名空间。所以，我们可以使用 范围解析符(::)（不带前缀的，即默认是在全局命名空间）来告诉编译器我们使用的是全局变量：123456789101112131415#include &lt;iostream&gt;int a &#123;5&#125;; //全局变量int main()&#123; int a &#123;7&#125;; //此时，将全局变量a隐藏起来了 ++a； //局部变量a加1，而不是全局变量 --(::a); //此时是对于全局变量，减一 std::cout &lt;&lt; \"local variable a: \" &lt;&lt; a &lt;&lt; '\\n'; std::cout &lt;&lt; \"global variable a: \" &lt;&lt; ::a &lt;&lt; '\\n'; return 0; &#125;//local a 被销毁运行结果：12local variable a: 8global variable a: 4避免变量被隐藏通常应该避免局部变量的隐藏，因为它会在使用或修改错误的变量时导致无意的错误。一些编译器会在变量被隐藏时发出警告。6.6 内部连接在 6.3 – Local variables中，讲到：“一个标识符的连接决定了该名称的其他声明是否引用同一对象”和“局部变量的无连接”全局变量和函数标识符有：内部链接(internal linkage)和外部链接(external linkage)。本节主要讲内部链接。一个标识若是内部连接，那它就只能在这一个文件中有效(可以被看到和使用)；而不可以在其他文件中看到和使用【也就是说，它没有暴露给链接器】。也就是说，如果有两个文件，它们分别含有一个相同名字的标识符(而且这这个同名的标识符是 内部连接)，那么这个同名的标识符就被看待成相互独立的。全局变量内部连接全局变量是内部链接时，也被称为：内部变量(internal variables)。让 非常量的全局变量 成为内部变量，需要使用关键字static；（因为非常量的全局变量默认是 外部链接 的）而 常量的全局变量 默认的就是 内部变量。如：123456789static int g_x; //非常量的全局变量默认是 外部链接。但是加上关键字static后，就变成内部连接const int g_y &#123;1&#125;; //const 的全局变量默认是 内部连接constexpr int g_z &#123;2&#125;; //constexpr 的全局变量默认是 内部连接int main()&#123; return 0;&#125;const和constexpr的全局变量默认是 内部连接(所以，不需要加 关键字static)一个定义规则和内部连接还记得在 2.7 – Forward declarations and definitions,中讲到一个定义的规则：在文件或程序中，*一个*对象或者函数只能有一个定义。然而，这一个我们却在一个程序中对一个对象或函数进行了“多次定义”，这是否违背了上面的规则呢？答：不违背。因为本节中我们将它们设置为内部连接，此时虽然它们的名字相同，但是相互独立（即，它们相当于不同的对象或函数，只是名字相同。就好像两个同名的人一样）。所以不违背上面的定义规则。函数内部连接因为“连接(linkage)”是标识符的属性(标识符不仅仅只代表变量(☄⊙ω⊙)☄，因为函数的名字也是标识符)。所以，函数标识符也具有 内部连接 的属性。如：add.cpp123456//这个函数前使用关键字static，表示它现在只在这个文件中有效//如果，企图通过函数提前声明从，从另一个文件访问它，将失败static int add (int x, int y)&#123; return x+y;&#125;main.cpp123456789#include &lt;iostream&gt;int add (int x, int y); //对函数add，提前声明int main()&#123; std::cout &lt;&lt; add(3, 4) &lt;&lt;'\\n'; return 0;&#125;上面的程序，在链接器连接时，将会出错。因为函数add在main.cpp中不可访问小结123456789// Internal global variables definitions:static int g_x; // defines non-initialized internal global variable (zero initialized by default)static int g_x&#123; 1 &#125;; // defines initialized internal global variable const int g_y &#123; 2 &#125;; // defines initialized internal global const variableconstexpr int g_y &#123; 3 &#125;; // defines initialized internal global constexpr variable // Internal function definitions:static int foo() &#123;&#125;; // defines internal function6.7 外部连接一个标识符具有 外部连接(external linkage)的属性，那么它就可以在整个程序中(不仅仅只在一个文件中)被看见和访问。（在其他文件中，可以通过提前声明来访问它）所以，具有外部连接属性的表示符，才是真正的“全局”变量函数默认是外部链接在 2.8 – Programs with multiple code files中，讲到我们可以从其他文件中调用函数，这是因为这个函数默认是“外部链接”的。在从其他文件中调用函数时，我们必须要对这个函数进行 提前声明(forward declaration)因为，提前声明可以告诉编译器这个函数的存在；而链接器则是将函数调用连接到实际的函数定义如：a.cpp123456#include &lt;iostream&gt;void sayHi() //这个函数默认是 外部连接，所以他可以在整个程序(包括其他文件)中被看见&#123; std::cout &lt;&lt; \"hi\";&#125;main.cpp12345678void sayHi(); //对函数进行提前声明，使得该函数在这个文件中可以被访问int main()&#123; sayHi(); //这里是从其他文件中调用此函数，链接器将把这个调用连接到函数定义 return 0;&#125;运行结果:1hi全局变量外部连接全局变量具有外部连接属性时，也称为：外部变量(external variables)非常量的全局变量默认是 外部变量；常量的全局变量 要想成为外部变量，需要使用关键字extern如：123456789int g_x &#123;2&#125;; //非常量的全局变量默认是 外部变量；extern const int g_y &#123;3&#125;;//const 的全局变量可以被定义成 外部变量，需要加关键字externextern constexpr int g_z &#123;3&#125;; //constexpr 的全局变量可以被定义成 外部变量,需要加关键字externint main()&#123; return 0;&#125;默认情况下，非const全局变量是外部变量(如果使用，extern关键字将被忽略)。extern提前声明变量要实际使用在另一个文件中定义的外部全局变量，我们需要在使用它的文件中对全局变量进行提前声明。对于变量，在创建一个提前声明时，也是需要使用关键字extern的(没有初始化值)：如：a.cpp123//全局变量的定义int g_x &#123;2&#125;; //非常量的全局变量默认是 外部链接extern const int g_y &#123;3&#125;; //常量的全局变量是内部连接，但使用关键字extern后，变为 外部链接main.cpp12345678910#include &lt;iostream&gt;extern int g_x; //对变量g_x的提前声明。它的定义在其他文件中extern const int g_y; //对常量变量g_y的提前声明。它的定义在其他文件中int main()&#123; std&lt;&lt; g_x; //结果为2 return 0;&#125;函数提前声明不用extern函数的提前声明不需要关键字extern编译器能搞告诉你这个函数在哪定义，也可以根据是否提供函数体来进行提前声明。变量的提前声明必须要用关键字extern，来帮助区分 变量定义 和 变量提前声明(它们看起来是一样的):如：1234567//非常量int g_x; //变量的定义(如果需要，可进行初始化)extern int g_x; //变量的提前声明(提前声明 不带初始化)//常量extern const int g_y &#123;1&#125;;//定义变量(常量的定义必须要进行初始化)extern const int g_y; //提前声明(提前声明 不带初始化)file范围VS.global范围看下面的例子：global.cpp12int g_x &#123;2&#125;; //（非常量的变量）默认是外部连接//g_x goes out scope heremain.cpp12345678extern int g_x; //对变量g_x的提前声明。可以在此文件中使用g_xint main()&#123; std::cout &lt;&lt; g_x; //应该输出 2 return 0;&#125;//g_x的提前声明 goes out of scope here变量g_x的文件范围(file scope)是在global.cpp中。它在该文件中定义之后，就可以被使用。但是它不能直接在其他文件中使用。如果要在其他文件中使用g_x，我们要在其他文件中对它进行提前声明(记得要使用关键字extern)也就是说，“文件范围”通常用于具有内部连接属性的全局变量；“全局范围”更多用于具有外部连接属性的全局变量(因为，它被提前声明之后，就可以在其他地方使用)全局变量初始化顺序问题全局变量的初始化是程序启动的一部分，在执行mian函数之前，这个过程分为两部分：第一部分，称为 static initialization静态初始化。在静态初始化中，带有constexpr初始化器(包括字面值(literal))的全局变量被初始化为给定的值[因为，constexpr和字面值常量定义时自带有初始值]；eg,const a {1};那么a就被初始化为1constexpr a{1};那么a就被初始化为1定义时没有给定初始值的全局变量(也使常量的全局变量，但没有显示初始化为0)被默认初始化为0。const a {};那么a就默认被初始化为0constexpr a{};那么a就默认被初始化为0第二部分，称为 dynamic initialization动态初始化。这部分，比较复杂，它的要点是：初始化那些“不带有constexpr初始化器的全局变量”(即，就是 非常量的全局变量)。例如：123456int init()&#123; return 5;&#125;int g_something &#123;init()&#125;; //非常量的变量初始化在单位件的程序中，全局变量按照定义的顺序被初始化这个规则有几个例外。考虑到这一点，您需要小心不要让变量依赖于其他变量的初始化值，这些变量要到稍后才会初始化。例如:12345678910111213141516171819202122232425#include &lt;iostream&gt; int initx(); // forward declarationint inity(); // forward declaration int g_x&#123; initx() &#125;; // g_x is initialized firstint g_y&#123; inity() &#125;; int initx()&#123; return g_y; // g_y isn't initialized when this is called&#125; int inity()&#123; return 5;&#125; int main()&#123; std::cout &lt;&lt; g_x &lt;&lt; ' ' &lt;&lt; g_y &lt;&lt; '\\n';&#125;/******结果*******/0 5再多文件程序中，不同文件之间的初始化顺序是没有规定的。例如，有两个文件a.cpp和b.cpp，它们两个文件谁先被初始化是不确定的。所以，如果在a.cpp中有一个变量的值是依赖于b.cpp。那么就有50%的可能这些变量还没有被初始化。注意：C++中，全局变量的动态初始化会造成很多问题。所以避免使用。小结：123456789// External global variable definitions:int g_x; // defines non-initialized external global variable (zero initialized by default)extern const int g_x&#123; 1 &#125;; // defines initialized const external global variableextern constexpr int g_x&#123; 2 &#125;; // defines initialized constexpr external global variable // Forward declarationsextern int g_y; // forward declaration for non-constant global variableextern const int g_y; // forward declaration for const global variableextern constexpr int g_y; // not allowed: constexpr variables can't be forward declared6.8 全局常量&amp;内联变量Global constants and inline variables一些符号常量需(如，阿伏伽德罗常数，重力系数…)要在整个程序中使用。比较好的方法是在一个地方对他们进行声明，而不是在每个需要它们的文件中重新定义这些常量。全局常量作为内部变量在c++中有多种方法可以促进这一点。在c++ 17之前，以下可能是最简单和最常见的方法:首先，创建一个头文件来存放这些常量；在这个头文件中，定义一个命名空间（在 6.2 – User-defined namespaces讲解过命名空间）；然后，将常量加入这个命名空间中（请确保它们的类型是constexpr）；在你要用这些变量的文件中，加上这个头文件#include &quot;xxx&quot;eg:constants.h12345678910111213#ifndef CONSTANTS_H#define CONSTANTS_H//定义你自己的命名空间(用来存储常量)namespace constants&#123; //默认情况下，常量有 内部连接 constexpr double pi &#123;3.14159&#125;; constexpr double my_gravity &#123;9.2&#125;; //....常量&#125;#endifmain.cpp1234567891011#include \"constants.h\" //：在这个文件中包含每个常量的副本int main()&#123; std::cout &lt;&lt; \"enter a radius: \"; int radius&#123;&#125;; //radius：半径 std::cin &gt;&gt;radius; std::cout &lt;&lt; \"the circumference is: \" &lt;&lt;2* radius* constants::pi; return 0;&#125;注意：在main.cpp文件中，要想访问constants中的常量，我们需要使用 范围解析符(::)。a::b 范围解析操作符的 左操作数a,表示命名空间名称；右操作符b表示命名空间a中的变量或者函数名字。::b 这种形式表示 其命名空间是全局命名空间。全局常量作为外部变量当作为内部变量时，可能会出现以下问题：虽然这很简单(对于较小的程序也很好)，但是每当constants.h被包含到不同的代码文件中时，每个变量都会被复制到包含代码文件中。因此，如果将constants.h包含到20个不同的代码文件中，那么每个变量都会重复20次。头文件保护不会阻止这种情况的发生，因为它们只会阻止头文件不止一次被包含到一个包含文件中，而不会阻止头文件一次被包含到多个不同的代码文件中。这带来了两个挑战:头文件保护符(header guards)只能确保在单个文件中包含的头文件只包含一次；当修改一个常量值时，就可能需要重新编译那些包含这个常量的文件，这可能导致大型项目的重建时间很长。如果常量的size很大，并且不能进行优化。这将花费很多内存。一个解决上面的办法就是，将这些常量设为“外部变量(external variables)”。因此，我们可以将变量只初始化一次就可以在整个程序中使用。constants.cpp123456namespace constants&#123; //actual global variables extern const double pi &#123;3.14159&#125;; extern const my_gravity &#123;9.2&#125;;&#125;在constants.cpp文件中定义这些常量，来确保它们只被定义一次；constants.h123456789101112#ifndef CONSTANTS_H#define CONSTANTS_H namespace constants&#123; // since the actual variables are inside a namespace, the forward declarations need to be inside a namespace as well extern const double pi; extern const double avogadro; extern const double my_gravity;&#125; #endif需要在头文件constants.h中对这些常量进行 提前声明main.cpp使用的方法不变12345678910#include \"constants.h\" // include all the forward declarations int main()&#123; std::cout &lt;&lt; \"Enter a radius: \"; int radius&#123;&#125;; std::cin &gt;&gt; radius; std::cout &lt;&lt; \"The circumference is: \" &lt;&lt; 2 * radius * constants::pi;&#125;因为全局符号常量在命名空间中(为了避免与全局命名空间中的标识符发生 命名冲突)，所以，就不需要在它名字中使用g_前缀现在，这些符号常量只用在constants.cpp中实例化一次(而不是每次constants.h被#include中都被实例化一次)，所以，对constants.cpp所做的任何修改都只需要重新编译constants.cpp即可。然而，这种方法也有几个缺点。首先，这些常量现在只在实际定义它们的文件(constants.cpp)中被认为是 编译时常量，而不是在其他地方使用它们。这意味着在constants.cpp之外的地方，它们不能在任何需要编译时常量的地方使用。其次，编译器可能无法对它们进行尽可能多的优化。全局常量作为内联变量在C++17中，有一个新概念叫做：inline variable(内联变量)inline意为：允许多个定义。所以，一个内联变量就可以在多个文件中被多次定义。(这并不违背 单定义规则)内联全局变量 默认是 外部连接内联变量有两个重要的限制，必须遵守：内联变量的所有定义必须相同（否则，将产生未定义的行为）；内敛变量的定义(不是提前声明)必须出现在每一个使用这些变量的文件中。编译器将会把内联变量的所有定义合并为一个变量的定义。这就允许我们在头文件中定义变量，并将它们当作a.cpp文件中只有一个定义。这些变量在它们被包含的文件中，依然保持这 constexpr 的性质这样，我们就可以在头文件中定义全局变量，而不用担心重复变量:constants.h123456789101112#ifndef CONSTANTS_H#define CONSTANTS_H // define your own namespace to hold constantsnamespace constants&#123; inline constexpr double pi &#123; 3.14159 &#125;; // note: now inline constexpr inline constexpr double avogadro &#123; 6.0221413e23 &#125;; inline constexpr double my_gravity &#123; 9.2 &#125;; // m/s^2 -- gravity is light on this planet // ... other related constants&#125;#endifmain.cpp12345678910#include \"constants.h\" int main()&#123; std::cout &lt;&lt; \"Enter a radius: \"; int radius&#123;&#125;; std::cin &gt;&gt; radius; std::cout &lt;&lt; \"The circumference is: \" &lt;&lt; 2 * radius * constants::pi;&#125;我们可以在尽可能多的代码文件中包含constants.h，但是这些变量只会被实例化一次，并在所有代码文件中共享。如果你需要全局常量，并且你的编译器支持C++17，那建议最好使用 内联变量6.9 非常量的全局变量evil最大的问题就是：当你使用全局变量(not-const)时，它可能在任何地方就被修改，但是你却不能轻松的直到在哪被改的。1234567891011121314151617181920int g_mode; //声明全局变量(将默认被初始化为0)void dosomething()&#123; g_mode = 2; //这里修改全局变量g_mode为2&#125;int main()&#123; g_mode =1; //note:这将全局g_mode变量设置为1。而不是声明一个本地g_mode变量! dosomething(); //程序猿希望这里输出的g_mode的值是1，但是实际上它的值是2 if(g_mode == 1) std::cout &lt;&lt;\"no threat detected.\\n\"; else std::cout &lt;&lt; \"lanunching nuclear missiles...\\n\"; return 0;&#125;局部变量要安全得多，因为其他函数不能直接影响它们。保护你的全局变量如果你非要使用全局变量：那我们可以对变量名使用前缀”g_”或“g”，来帮助我们识别它是全局变量。最好也将其放在你自己创建的命名空间，从而避免一些命名冲突。6.10 静态局部变量术语static是c++语言中最容易混淆的术语之一，这在很大程度上是因为静态在不同的上下文中有不同的含义。在之前的课程中，我们讨论了全局变量具有静态持续时间，这意味着它们在程序启动时创建，在程序结束时销毁。我们还讨论了static关键字如何提供全局标识符内部链接，这意味着标识符只能在定义它的文件中使用。我们将探讨应用于局部变量时静态关键字的用法。在 2.4 – Introduction to local scope, 您了解到，默认情况下 局部变量具有 自动持续时间，这意味着它们是在定义时创建的，并在块退出时销毁。但关键字static，可以将自动持续时间(attomatic duration)转变成 静态持续时间(static duration) 。从而，静态变量即使已经超出它所在的范围时，他依然没有被销毁。这意味着变量现在在程序开始时创建，并在程序结束时销毁(就像全局变量一样)。例如：默认是 automatic duration12345678910111213141516171819202122#include &lt;iostream&gt; void incrementAndPrint()&#123; int value&#123; 1 &#125;; // 默认是 automatic duration ++value; std::cout &lt;&lt; value &lt;&lt; '\\n';&#125; // value is destroyed here int main()&#123; incrementAndPrint(); incrementAndPrint(); incrementAndPrint(); return 0;&#125;/********结果**********/222每次调用函数incrementAndPrint()时，都将穿件一个叫value的变量，它被初始化为1现在使用static关键字，将默认的 atuomatic duration 转变为 static duration12345678910111213141516171819202122#include &lt;iostream&gt; void incrementAndPrint()&#123; static int s_value&#123; 1 &#125;; // 由于使用关键字 static,所以现在是 static duration。 所以这个变量将只会被初始化一次（不会像上面那个例子，每次调用都会被除初始化） ++s_value; std::cout &lt;&lt; s_value &lt;&lt; '\\n';&#125; // s_value is not destroyed here, but becomes inaccessible because it goes out of scope int main()&#123; incrementAndPrint(); incrementAndPrint(); incrementAndPrint(); return 0;&#125;/****结果****/234在这个程序中，因为s_value被声明为静态的，所以s_value只创建一次(在程序启动时)(并且初始化为零)。然后在第一次遇到变量定义时使用我们提供的初始化值(1)初始化变量(但在后续调用时不会重新初始化)。就像我们使用“g_” 作为全局变量的前缀一样，使用 “ s_”作为静态(静态持续时间)局部变量的前缀也是很常见的。静态变量提供了全局变量的一些好处(它们直到程序结束时才被销毁)，同时，限制为它们只在它自己的块中才能被看见，这使得即使您经常更改它们的值，这也使它们可以安全使用。全局、局部变量使用static全局变量使用关键字static：这会使得全局变量变为 internal linkage(内部连接)，即，使得该变量不能再其他文件中使用。局部变量使用关键字statci：这使得局部变量变为 static duration(静态持续时间),即，使得该变量将 只被创建一次，而且直到程序结束才会被销毁。6.11 总结scope/duration/linkage总结scope标识符的范围决定了它能够被访问的区间：具有 block scope(块范围) / local scope(局部范围) 的变量 只能在它们被声明的块中(包括嵌套块)被访问，这些有：局部变量；函数的形参；在块中声明的用户定义类型定义（如，枚举(enum)、类(class)）;具有 global scope(全局范围) / file scope(文件范围)的变量 可以再文件中的任何地方被访问，这些有：全局变量；函数；在命 名空间内 或 全局范围 内声明的用户定义类型定义(如枚举(enum)、类(class))总结duration变量的持续时间决定了它们何时被创建与销毁：具有 automatic duration(自动持续时间)的变量 在定义时被创建，在离开它所在的块时被销毁，这些有：局部变量；函数的形参；具有 static duration(静态持续时间)的变量 在程序开始时被创建， 在程序结束时被销毁。这些有：全局变量；静态局部变量；具有 dynamic duration(动态持续时间)的变量 由程序员请求创建和销毁。这些有：动态分配的变量；总结linkage标识符的 linkage(连接) 决定了 一个标识符的多个实例是否引用同一个标识符。标识符 没有 连接 时，意味着这个标识符仅指其自身。这些有：局部变量；在块中声明的用户定义类型定义(如枚举和类)；具有 intrnal linkage(内部连接) 的标识符 只能在它所声明的文件中 被访问。这些有：静态全局变量(static global variables) [初始化 或 未初始化 ]；静态函数（static functions）;在未命名的命名空间中声明的函数；在未命名的命名空间中声明的用户定义类型定义(如枚举和类)；具有 external linkage(外部连接) 的标识符 可以在 在声明的文件内的任何地方访问，也可以其他文件(通过提前声明)进行访问。这包括:函数；非常量的全局变量(初始化 或 未初始化)；外部常量全局变量；内联常量全局变量；在 命名空间内 或 全局范围内声明的用户定义类型定义(如枚举和类)；NOTE:默认情况下， 函数是 外部连接；它可通过使用关键字static变成 内部连接。变量的 scope/duratio /linkageTypeExampleScopeDurationLinkageNotesLocal variableint x;BlockAutomaticNoneStatic local variablestatic int s_x;BlockStaticNoneDynamic variableint *x { new int };BlockDynamicNoneFunction parametervoid foo(int x)BlockAutomaticNoneExternal non-constant global variableint g_x;FileStaticExternalInitialized or uninitializedInternal non-constant global variablestatic int g_x;FileStaticInternalInitialized or uninitializedInternal constant global variableconstexpr int g_x { 1 };FileStaticInternalConst or constexpr, Must be initializedExternal constant global variableextern constexpr int g_x { 1 };FileStaticExternalConst or constexpr, Must be initializedInline constant global variableinline constexpr int g_x { 1 };FileStaticExternalConst or constexpr, Must be initialized总结提前声明你可以在其他文件中对一个 函数/变量 进行提前声明：TypeExampleNotesFunction forward declarationvoid foo(int x);Prototype only, no function bodyNon-constant global variable forward declarationextern int g_x;Must be uninitializedConst global variable forward declarationextern const int g_x;Must be uninitializedConstexpr global variable forward declarationextern constexpr int g_x;Not allowed, constexpr cannot be forward declared什么是存储类说明符?当关键字static 、extern用作标识符声明的一部分时,它们就被称为：storage class specifier（存储类说明符）。它们设置标识符的存储的 duration 和 linkageC++支持4中存储类说明符：SpecifierMeaningNoteexternstatic (or thread_local) storage duration and external linkagestaticstatic (or thread_local) storage duration and internal linkagethread_localthread storage durationIntroduced in C++11mutableobject allowed to be modified even if containing class is constautoautomatic storage durationDeprecated in C++11registerautomatic storage duration and hint to the compiler to place in a registerDeprecated in C++17术语 storage class specifier 通常只在正式文档中使用。6.12 using 语句如果你经常使用标准库，那么在使用标准库中的所有内容之前输入std::会变得重复。C++提供了一种可选择的办法，叫做：using statementsusing的声明一种简化的方法是使用using声明语句：123456789#include &lt;iostream&gt; int main()&#123; using std::cout; // this using declaration tells the compiler that cout should resolve to std::cout cout &lt;&lt; \"Hello world!\"; // so no std:: prefix is needed here! return 0;&#125; // the using declaration expires hereusing 的声明：using std::cout告诉编译器我们将要使用 命名空间std 中的cout。所以当编译器看到cout时，它会假设我们指的是std::cout。如果std::cout与cout的其他一些使用之间存在命名冲突，则首选std::cout。上面的例子，看起来似乎没有简化多少。但如果我们要多次使用cout时，使用 using statements就可以简化很多。注意，如果你多次使用std::cout和std::cin的话，你需要对他们两个分别使用using statementsusing 指令另一种方法就是使用：using directive语句。如：12345678#include &lt;iostream&gt;int main()&#123; using namespace std; //这个using指令 告诉编译器我们可以使用 命名空间std 中的任何东西 cout &lt;&lt; \"hello world!\"; // 所以，前缀 std:: 就可以省略 return 0;&#125;这个using 指令 ：using namespace std告诉编译器我们想使用 命名空间std 中的任何东西。所以当编译器发现了一个名字它不认识时，它就会检查 命名空间std。结果就是，当编译器遇到cout(编译器不认识cout)，编译器就会查看 命名空间std 然后找到cout。如果std::cout与cout的其他一些使用之间存在命名冲突，编译器将把它标记为错误(而不是选择其中之一)。下面来看一下 using 指令 造成的歧义：eg1：123456789101112131415161718192021#include &lt;iostream&gt; namespace a&#123; int x&#123; 10 &#125;;&#125; namespace b&#123; int x&#123; 20 &#125;;&#125; int main()&#123; using namespace a; using namespace b; std::cout &lt;&lt; x &lt;&lt; '\\n'; return 0;&#125;上面例子中，编译器无法在mian函数中决定使用a::x还是b::x。然后就会出现“不明确的符号”错误。要想解决这个冲突，我们可以加上前缀使用。即显示标明使用的是哪一个命名空间中的x。eg2：1234567891011121314#include &lt;iostream&gt; // imports the declaration of std::cout int cout() // declares our own \"cout\" function&#123; return 5;&#125; int main()&#123; using namespace std; // makes std::cout accessible as \"cout\" cout &lt;&lt; \"Hello, world!\"; // uh oh! Which cout do we want here? The one in the std namespace or the one we defined above? return 0;&#125;eg2中，编译器无法判断我们使用的cout是引用的 std::cout还是 cout函数。并出现“不明确的符号”错误。解决方法：使用using declaration 来替代 using directive：12using std::cout; //告诉编译器， cout 指的是 std::coutcout &lt;&lt; \"Hello, world!\"; //所以cout表示的是 std::cout显示的使用前缀：1std::cout &lt;&lt; \"Hello, world!\"; //告诉编译器使用的是std::cout取消or替换 using语句一旦，using语句被声明，那就没有办法在声明它的范围内使用另一个using语句替换或取消它。1234567int main()&#123; using namespace Foo; //此时无法使用一个其他的 using语句来 取消或替换 “using namespace Foo;” return 0;&#125;//using namespace Foo ends here对应它的最好办法就是，显示的限制 using语句 的范围：12345678int main()&#123; &#123; using namespace Foo; //在这里调用Foo::中的东西 &#125; //using namespace Foo 过期 return 0;&#125;当然，可以显式地使用范围解析操作符(::)来避免所有这些麻烦。6.13 typedef与类型别名**优先使用类型别名，而不是typedefs，并大量使用它们来记录类型的含义**typedef允许程序猿去创建一个数据类型的别名。然后可以使用别名来替换这个类型真正的名字。Typedef的字面意思是“类型定义”我们可以使用关键字typedef，来进行 类型定义：typedef a b ：其中a表示类型的名字，b表示类型被替换成的别名.12345typedef double distance_t; //定义distance_t 作为 double类型 的别名//下面两个语句是等价的:double howFar;distance_t howFar;按照惯例，typedef名称是使用“_t”后缀声明的。这有助于指示标识符代表的是类型，而不是变量或函数，还有助于防止与其他标识符的命名冲突。类型别名为了帮助解决这些问题，我们引入了一种改进的typedefs语法，它模仿了变量的声明方式。这种语法称为 type alias(类型别名)。123typedef double distance_t; //定义distance_t 作为 double类型的 别名using distance_t = double; //定义distance_t 作为 double类型的 别名【推荐】上面两个语句在功能上等价。【NOTE】虽然使用了关键字using（在这里是重载的意义），但这和 与命名空间相关的 using语句 没有关系。为易读性使用类型别名1int GradeTest();我们可以看到返回值是一个整数，但是这个整数是什么意思呢?一个字母等级?遗漏了多少问题?学生的身份证号码?一个错误代码?谁知道!Int不能告诉我们任何东西。写成下面形式，便于理解：12using testScore_t = int;testScore_t GradeTest();使用类型别名编写与平台无关的代码比如，在一些平台中，int类型占2个字节；但在其他平台中，可能占4个字节。所以，在4字节平台中写的代码在2字节平台中可能会出错。所以，使用类型别名可以帮助我们避免出错，也更清楚地说明了对变量大小的假设。123456789#ifdef INT_2_BYTESusing int8_t = char;using int16_t = int;using int32_t = long;#elseusing int8_t = char;using int16_t = short;using int32_t = int;#endif如果，在一个机器中，整数是2个字节。那么INT_2_BYTES将被定义。此时，就使用的是上部定义的这几个。如果，在一个机器中，整数是4个字节。那么INT_2_BYTES将不被定义。此时，就使用的是下部定义的这几个。这种情况下：通过使用char、short、int和long的组合，这对于正在编译程序的机器是合适的int_8将处理 1字节的整数；int16_t将处理 2字节的整数；int32_t将处理 4字节的整数。6.14 关键字auto看一个例子：1double d &#123;5.0&#125;;如果C++早就知道5.0是double类型的数字，那为什么我们还要显示的指定d是double类型的呢？如果我们可以让一个变量根据我们初始化它的值来设想它的类型，这不是很好吗?初始化变量的类型推断当初始化一个变量，关键字auto可以用来代替类型，以告诉编译器从初始化器的类型推断变量的类型。这种就叫作：type inference(类型推断), 英文中也可以叫作：type deduction例如：12auto d &#123;5.0&#125;; //因为5.0是一个double类型的数字，所以它的类型将被推断为doubleauto i &#123;1+2&#125;; //因为1+2的结果是int类型，所以，i 将被推断为int类型也可以用在函数返回值：123456789int add(int x, int y)&#123; return x+y;&#125;int main()&#123; auto sum&#123;add(5,6)&#125;; //add() 返回一个int, 所以sum的类型将被推断为int&#125;在C++14中函数的类型推断在C++14中，关键字auto被扩展到可以从函数体中的返回语句推断出函数的返回类型。1234auto add(int x, int y)&#123; return x+y;&#125;因为x+y的值是int类型，编译器将会推断这个函数应该返回一个int类型。当使用auto返回类型时，所有的返回语句就必须返回相同的类型，否则将会出错。但是不推荐对函数的返回类型使用关键字auto。因为没有上下文来帮助指示函数返回的类型。用户实际上必须深入函数体本身来确定函数返回的类型。它不那么直观，因此更容易出错。后置返回类型语法关键字auto也可以被用来后置返回类型(trailing return syntax)。即，在函数原型之后指定返回的类型。这是C++11新增的一种函数声明的方法。下面的两个对函数声明的语句是等价的：12int add(int x, int y);auto add(int x, int y) -&gt; int;//在这种情况下，auto不执行类型推断——使用后置返回类型只是语法的一部分。那为什么要用后置类型返回语句呢？其中的好处之一就是：可以让函数的声明时的名字对齐😊，如：1234auto add(int x, int y) -&gt; int;auto divide(double x, double y) -&gt; double;auto printSomething() -&gt; void;auto generateSubstring(const std::string &amp;s, int start, int len) -&gt; std::string;函数形参的类型推断在C++20时引入的123456789101112#include &lt;iostream&gt;void add(auto x, auto y) //only valid in C++20&#123; std::cout &lt;&lt;x+y;&#125;int main()&#123; add(2, 3); //int add(1.1, 2.2); //double&#125;在C++20之前，这种形式是无效的。因为编译器在 编译时(complie time) 不能推断函数形参的类型。在C++20之前，如果你想要创建一个使用各种不同类型的泛型函数，你需要使用function templates，而不是现在用的type inference6.15 强制类型转换(隐式)类型转换有两种形式：implicit type conversion（隐式类型转换）：编译器会自动将一种数据类型转换为另一种数据类型explicit type conversion（显示类型转换）：开发人员使用转换操作符来指导转换。将值从一种数据类型转换为另一种数据类型的过程称为type conversion(类型转换)。类型转换可以在许多不同的情况下发生:当用不同数据类型的值 分配 或 初始 化一个变量时:12double d&#123;3&#125;; // initialize double variable with integer value 3d = 6; // assign double variable the integer value 6当传递一个值给一个函数时，但函数参数是不同的数据类型：12345void doSomething(long l)&#123;&#125; doSomething(3); // pass integer value 3 to a function expecting a long parameter当从一个函数返回一个值时，该函数的返回类型是不同的数据类型：1234float doSomething()&#123; return 3.0; // Return double value 3.0 back to caller through float return type&#125;使用不同类型的操作数的 二元操作符：1double division&#123; 4.0 / 3 &#125;; // division with a double and an integer隐式类型转换隐式类型转换(也称为自动类型转换或强制转换)在希望是这种数据类型，但提供了另一种数据类型。乳沟编译器能够辨认出类型转换中的两种类型，挠他就转换。否则，报错。隐式类型转换有两种基本类型：提升和转换。Numeric promotion数值提升每当将一个基本数据类型的值转换为来自同一族的更大的基本数据类型的值时，这称为数值提升(或加宽，尽管这个术语通常用于整数)。123//an int can be widened into a long, or a float promoted into a double:long l&#123; 64 &#125;; // widen the integer 64 into a longdouble d&#123; 0.12f &#125;; // promote the float 0.12 into a double虽然术语数值推广涵盖了任何类型的提升，但在c++中还有两个具有特定含义的术语:Integral promotion(整型提升)：可以将[ bool , char, unsigned char, signed char, unsigned short, and signed short ]这些类型转换为 int或者是unsigned intFloating point promotion(浮点型提升)：可以将float类型转换为double整型提升 和 浮点型提升 通常是将 较小的数据类型转换为int/unsigned int或double。Numeric conversions(数值转换)当我们将一个值从较大的类型转换为类似的较小类型时，或者在不同类型之间转换时，这称为数值转换。例如:12double d&#123; 3 &#125;; // convert integer 3 to a double (between different types)short s&#123; 2 &#125;; // convert integer 2 to a short (from larger to smaller type within same type family)数值提升是安全的；但是数值转换可能会丢失数据。因此，导致执行隐式转换的代码通常会导致编译器发出警告。eg,将一个值转换为的类型没有足够大的范围来支持这个值，就会出现意想不到的结果：123456789101112int main()&#123; int i&#123; 30000 &#125;; char c = i; // chars have range -128 to 127 std::cout &lt;&lt; static_cast&lt;int&gt;(c); return 0;&#125;/********结果**********/48在本例中，我们将一个大整数分配给一个char(其范围为-128到127)。这会导致char溢出，并产生一个意外的结果: 48但是，只要值符合较小类型的范围，从较大的整数或浮点类型转换为较小的类似类型通常就可以工作。例如:1234567891011 int i&#123; 2 &#125;; short s = i; // convert from int to short std::cout &lt;&lt; s &lt;&lt; '\\n'; double d&#123; 0.1234 &#125;; float f = d; std::cout &lt;&lt; f &lt;&lt; '\\n';/***********结果**************/20.1234对于浮点值，由于较小类型的精度损失，可能会出现一些舍入。例如:12345float f = 0.123456789; // double value 0.123456789 has 9 significant digits, but float can only support about 7 std::cout &lt;&lt; std::setprecision(9) &lt;&lt; f &lt;&lt; '\\n'; // std::setprecision defined in 头文件“iomanip”中/************结果************/0.123456791只要值符合浮点类型的范围，就可以将整数转换为浮点数。例如:123456 int i&#123; 10 &#125;; float f = i; std::cout &lt;&lt; f;/**************结果**************/10只要值符合整数的范围，就可以将浮点数转换为整数，但是任何小数值都会丢失。例如:12345 int i = 3.5; std::cout &lt;&lt; i &lt;&lt; '\\n';/***在本例中，丢失了分数值(.5)，结果如下:****/3计算算术表达式当计算表达式时，编译器将每个表达式分解成单独的子表达式。算术运算符要求它们的操作数必须是相同的类型。为了确保这一点，编译器使用以下规则:如果一个操作数是一个比int更窄的整数，它将经历整数提升(如上所述)到int或usigned int。如果操作数仍然不匹配，那么编译器会找到优先级最高的操作数，并隐式地将另一个操作数转换为匹配的操作数。操作数的优先级如下:long double (highest)doublefloatunsigned long longlong longunsigned longlongunsigned intint (lowest)我们可以通过使用typeid操作符(包含在头中)看到通常的算术转换，该操作符可用于显示表达式的结果类型。eg1:1234567891011121314#include &lt;iostream&gt;#include &lt;typeinfo&gt; // for typeid() int main()&#123; short a&#123; 4 &#125;; short b&#123; 5 &#125;; std::cout &lt;&lt; typeid(a + b).name() &lt;&lt; \" \" &lt;&lt; a + b &lt;&lt; '\\n'; // show us the type of a + b return 0;&#125;/*因为short是整数，所以它们在被添加之前要经过整数提升到int。添加两个int的结果是一个int，正如您所期望的:*/int 9注意:编译器可能会显示一些稍微不同的内容，因为typeid.name()的格式由编译器决定。eg2:12345678910111213#include &lt;iostream&gt;#include &lt;typeinfo&gt; // for typeid() int main()&#123; double d&#123; 4.0 &#125;; short s&#123; 2 &#125;; std::cout &lt;&lt; typeid(d + s).name() &lt;&lt; ' ' &lt;&lt; d + s &lt;&lt; '\\n'; // show us the type of d + s return 0;&#125;/*****结果*************/double 6.0在这种情况下，short将被 数值提升 为int。但是，int与double还是不匹配。又因为double在类型的层次结构中更高。所以，整型的2将被转换为double 类型的 2.0 。然后就相当于是两个double类型的相加，结果还是double类型.强制类型转换(显式) &amp; static_cast显式的类型转换是使用 type casting operator(类型转换操作符)。（通常是程序员来做的一个显式的的类型转换）在C++中，类型转换大致分为5种： C-style casts, static casts, const casts, dynamic casts, and reinterpret casts. 后四个有时被称为命名类型转换(named casts)。在本节课中，我们将介绍c风格的类型转换和静态类型转换。我们将在以后的课程中讨论指针和继承时再保存动态类型转换。通常应该避免使用Const casts和reinterpret casts，因为它们只在极少数情况下有用，如果使用不当可能会有害。C-style casts在标准的C语言中，类型转换是通过 操作符()来完成的。括号内是将要转换的目标类型：123int i1 &#123; 10 &#125;;int i2 &#123; 4 &#125;;float f &#123; (float)i1 / i2 &#125;;在上面的程序中，我们使用浮点c风格的强制转换来告诉编译器将i1转换为浮点值。因为运算符/的左操作数现在变为浮点值，右操作符也将被转换为浮点值。并且除法将使用浮点除法而不是整数除法!使用强制类型转换来清除隐式类型转换1234int i &#123; 48 &#125;; // explicit conversion from int to char, so that a char is assigned to variable chchar ch = static_cast&lt;char&gt;(i);当我们这样做时，我们显式地告诉编译器这个转换是有意的，并且我们接受对结果的责任。因为这个static_cast的输出类型是char，所以对变量ch的赋值不会产生任何类型不匹配，因此没有警告。下面的程序，编译器将会抱怨将double转换成int可能会导致数据丢失:12int i &#123; 100 &#125;;i = i / 2.5;告诉编译器，我们明确的意思是这样做:12int i &#123; 100 &#125;;i = static_cast&lt;int&gt;(i / 2.5);6.17 未命名/内联 命名空间未命名(匿名) 命名空间12345678910111213141516171819#include &lt;iostream&gt; namespace // unnamed namespace&#123; void doSomething() // can only be accessed in this file &#123; std::cout &lt;&lt; \"v1\\n\"; &#125;&#125; int main()&#123; doSomething(); // we can call doSomething() without a namespace prefix return 0;&#125;/********结果**********/v1在未命名的命名空间中声明的所有内容都被视为父命名空间的一部分。因此，尽管doSomething函数是在未命名的命名空间中定义的，但函数本身可以从父命名空间(在本例中是global namespace)访问，这就是为什么我们可以从main调用doSomething而不需要任何限定符。这可能使未命名的命名空间看起来毫无用处。但未命名名称空间的另一个影响是：未命名命名空间内的所有标识符都被视为具有内部链接，这意味着未命名命名空间的内容就不能在其他文件中看到。对于函数，这实际上等同于将未命名的命名空间中的所有函数定义为静态函数。下面的程序与上面的程序实际上是相同的：12345678910111213#include &lt;iostream&gt; static void doSomething() // can only be accessed in this file&#123; std::cout &lt;&lt; \"v1\\n\";&#125; int main()&#123; doSomething(); // we can call doSomething() without a namespace prefix return 0;&#125;unnamed namespace通常用于 当你有很多内容想要确保在给定文件中保持局部时，使用unnamed namespace要比单独将所有声明标记为static更容易。内联 命名空间Inline namespaces12345678910111213#include &lt;iostream&gt; void doSomething()&#123; std::cout &lt;&lt; \"v1\\n\";&#125; int main()&#123; doSomething(); return 0;&#125;但是假设你对doSomething不满意，你想通过改变它的行为方式来改进它。但如果这样做，就有可能破坏使用旧版本的现有程序。你是怎么处理的?一种方法是用不同的名称创建函数的新版本。但是经过许多更改之后，您可能会得到一组名称几乎相同的函数(doSomething、doSomething_v2、doSomething_v3等)。【推荐】另一种方法是使用内联命名空间。内联命名空间是通常用于版本化内容的名称空间。与未命名的命名空间非常相似，在内联命名空间中声明的任何内容都被认为是父名称空间的一部分。然而，内联命名空间并不是 内部链接。使用关键字inline1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt; inline namespace v1 // declare an inline namespace named v1&#123; void doSomething() &#123; std::cout &lt;&lt; \"v1\\n\"; &#125;&#125; namespace v2 // declare a normal namespace named v2&#123; void doSomething() &#123; std::cout &lt;&lt; \"v2\\n\"; &#125;&#125; int main()&#123; v1::doSomething(); // calls the v1 version of doSomething() v2::doSomething(); // calls the v2 version of doSomething() doSomething(); // calls the inline version of doSomething() (which is v1) return 0;&#125;/*********结果********/v1v2v1可以看出，当有 内联函数存在时，如果不加前缀，则默认调用的是 内联函数版本在上面的例子中，调用doSomething将得到doSomething的v1(内联版本)。希望使用新版本的调用者可以显式地调用v2::dosomething()。这保留了现有程序的功能，同时允许更新的程序利用更新的/更好的变体。6.x Chapter 6 summary and quizhttps://www.learncpp.com/cpp-tutorial/chapter-6-summary-and-quiz/","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://longlongqin.github.io/tags/C-C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"GIT 学习","slug":"学习笔记/GIT 学习","date":"2020-04-05T06:08:23.000Z","updated":"2020-04-05T06:10:19.408Z","comments":true,"path":"archives/18085cf9.html","link":"","permalink":"https://longlongqin.github.io/archives/18085cf9.html","excerpt":"Git学习笔记","text":"Git学习笔记Git的三种状态：committed（已提交）：数据已经安全的保存在本地数据库（仓库）；modified（已修改）：修改了文件，但还没有保存到数据库；staged（已暂存）：对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。Git项目的三个工作区域概念：Git仓库（Git directory 或 repository）：是Git用来保存项目的元数据和对象数据库的地方。是Git最重要部分，从其他计算机克隆仓库时，拷贝的就是这里的数据。工作目录（working directory）：对项目的某个版本独立提取出来的内容。这些从Git仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。暂存区域（staging area）：是一个文件，保存了下一次将提交的文件列表信息，一般在Git仓库目录中，有时也被称作“索引”。基本的 Git 工作流程如下：1.在工作目录中修改文件；2.暂存文件，将文件的快照放入暂存区域；3.提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目。初始设置：设置姓名和邮箱：12git config --global user.name &quot;Firstname Lastname&quot; &#x2F;&#x2F; 名字使用英文输入git config --global user.email &quot;your_email@example.com&quot;注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。这个命令，会在“~/.gitconfig”中以如下形式输出设置文件。我的电脑上，这个文件夹的位置在C:\\Users\\ACER设置SSH key:创建公开密钥：1ssh-keygen -t rsa -C &quot;your_email@example.com&quot;如果一切顺利的话，可以在用户主目录里找到.ssh目录，我的在：C:\\Users\\ACER\\.ssh里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。初始化Git仓库：在该仓库中，打开Git bash，然后：1git init关联远程仓库：在远程仓库（如：github、gitee）中有一个新仓库什么都没有，我们可以：克隆一份到本地；也可以把一个已有的本地仓库与之关联。123456git remote add &lt;远程仓库名字&gt; &lt;远程仓库的SSH或HTTPS&gt;如：git remote add origin git@github.com:michaelliao&#x2F;learngit.git其中： 远程仓库名字：origin（是git的默认叫法，也可以写成其他的） 远程仓库的SSH：git@github.com:longlongqin&#x2F;learngit.git 当需要将一个仓库同时在github 和 gitee上关联时：假如在gitee上关联之前，已经在GitHub上关联过了。比如事先在GitHub上：git remote add origin git@github.com:longlongqin/LearnGit.git，关联了一个叫origin的远程仓库。然后，我现在要在gitee上关联一个仓库：git remote add origin git@gitee.com:longlongqin/LearnGit.git出现报错：fatal: remote origin already exists.说明，本地库已经关联了一个叫做origin的远程仓库了，所以才会报错。所以，我们知道，不能将github和gitee上的仓库名字都叫一样的名字。他们之间的名字要区分。先，删除关联的已有的GitHub远程库：1git remote rm origin再开始重新关联github和gitee的仓库，这次要将他们的仓库名字区分开：/*gitee中的LearnGit仓库起名：gitee；/*github中的LearnGit仓库起名：github；12git remote gitee origin git@gitee.com:longlongqin&#x2F;LearnGit.gitgit remote github origin git@github.com:longlongqin&#x2F;LearnGit.git检查一下，是否成功：​ 我们用git remote -v查看远程库信息，可以看到两个远程库：12345$ git remote -vgitee git@gitee.com:longlongqin&#x2F;LearnGit.git (fetch)gitee git@gitee.com:longlongqin&#x2F;LearnGit.git (push)github git@github.com:longlongqin&#x2F;LearnGit.git (fetch)github git@github.com:longlongqin&#x2F;LearnGit.git (push)成功。取消关联远程仓库：在关联远程仓库一节中，关联远程仓库，我们也可以取消以经关联的远程仓库，让他们取消关联：1git remote rm &lt;要取消关联的远程仓库的名字&gt;时光穿梭机撤销修改1、没有git add时（即，对文件做了修改，但是没添加到暂存区）：==用git checkout -- &lt;file&gt; (==file前面有一个空格)2、已经git add时（即，对文件做了修改，并且添加到暂存区）：先git reset HEAD &lt;file&gt;把暂存区的修改撤销掉，即：回退到没有git add时的状态然后，再git checkout -- &lt;file&gt;。3、已经git commit时（即，对文件做了修改，不仅添加到暂存区，而且还提交到本地仓库中了）：进行==版本回退==版本回退版本之间的切换，版本指的是git commit之后带有哈希值的状态。版本回退：git reset --hard commit_id 可以回退到版本号为commit_id的那个版本。git reset --hard head^ 回退到当前版本的上一个版本。转回到新版本：因为git log显示的是从此刻head指针所在的状态到之前的状态的提交日志。而git reflog用来记录你的每一次命令。所以转回到比当前所在的状态要新的状态需要：git reflog,找到你想要回去的那个较新的状态的commit 的idgit reset --hard &lt;commit_id&gt; 回到想要回器的那个版本。删除文件rm &lt;file&gt;从工作区中删除文件（和手动删除文件效果一样。）git rm &lt;file&gt;将文件从工作区删除，并且还添加到了暂存区（即，把删除的这个状态同步到暂存区了）。[^小提示]: 先手动删除文件，然后使用git rm和git add效果是一样的。远程仓库添加远程仓库：关联一个远程仓库：git remote add origin git@github.com:path/repo-name.git关联后，第一次推送master分支的所有内容：git push origin master远程仓库克隆：1git clone &lt;你想要克隆内容的公开密钥的密码&gt;公开的密钥密码，如下图所示：分支管理创建与合并分支：查看分支：git branch新建分支：git branch &lt;name&gt;创建并切换分支：git checkout -b &lt;name&gt; or git switch -c &lt;name&gt;切换分支：git checkout &lt;name&gt; or git switch &lt;name&gt;删除分支：git branch -d &lt;name&gt;不能删除当前所在的分支合并分支：git merge &lt;name&gt; 用于合并分支到当前分支git merge --no-ff &lt;name&gt; 其中参数–no-ff：表示在历史记录中明确记录下本次分支合并。注意：输入此命令之后，会启动编辑器，用于录入合并提交的信息。解决冲突：当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。用git log --graph命令可以看到分支合并图。分支管理策略：在实际开发中，我们应该按照几个基本原则进行分支管理：首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。所以，团队合作的分支看起来就像这样：小结：Git分支十分强大，在团队开发中应该充分应用。合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。合并分支的两种方式：git 的 merge 与 merge no-ff 的不同之处： no-ff merge可以看到合并历史。新建分支dev1，修改readme.txt，然后在dev1分支下git add readme.txt git commit -m &quot;dev1 branch commit&quot;回到master分支，执行merge即git merge dev1删除分支查看日志即git log --graph --pretty=oneline --abbrev-commit新建分支dev2，修改readme.txt，然后在dev2分支下git add readme.txt git commit -m &quot;dev2 branch commit&quot;回到master分支，执行merge即git merge --no-ff -m &quot;dev2 merged with mo-ff&quot; dev2删除分支查看日志即git log --graph --pretty=oneline --abbrev-commit比较两次合并，可以看出不同之处，no-ff的模式会记录分支历史、12//检查 Git 的某一项配置：git config &lt;key&gt; 12//列出所有 Git 当时能找到的配置： git config --list 1234//获取帮助：3种方法$ git help &lt;verb&gt;$ git &lt;verb&gt; --help$ man git-&lt;verb&gt;###############################################Git 其他指令：查看工作区状态status：git status查看的是工作区的状态。git diff 查看工作区与暂存区的区别。git diff head查看工作区与本地仓库的区别。查看文件内容：1cat &lt;name&gt;提交：工作区提交到暂存区：1git add &quot;filename&quot;暂存区提交到本地仓库：1git commit -m &quot;message&quot; &#x2F;&#x2F;message是对此次提交的一个说明语句12git commit&#x2F;&#x2F;此命令可以更加详细的记述提交信息（运行此命令后，会自动打开Git设置好的编辑器）执行此命令后，编辑器就会启动，显示如下：1234567# Please enter the commit message for your changes. Lines starting# with &#39;#&#39; will be ignored, and an empty message aborts the commit.## On branch dev# Changes to be committed:# modified: readme.txt#在编辑器中记述提交信息的格式如下：● 第一行：用一行文字简述提交的更改内容● 第二行：空行● 第三行以后：记述更改的原因和详细内容1git commit --amend :修改上一条提交时写的信息本地仓库提交(推送)到远程仓库：git push情况一：注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以git pull是&lt;远程分支&gt;:&lt;本地分支&gt;，而git push是&lt;本地分支&gt;:&lt;远程分支&gt;。1git push &lt;远程仓库名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;情况二：（推荐）如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。1234git push &lt;远程仓库名字&gt; &lt;将本地的分支推送到远程仓库的分支（本地分支和远程分支的名字一样）&gt;如：git push origin master上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。情况三：下面命令将本地的master分支推送到origin远程仓库，同时指定origin为默认仓库，后面就可以不加任何参数使用git push了。1git push -u &lt;远程仓库名字&gt; &lt;将本地的分支推送到远程仓库的分支（本地分支和远程分支的名字一样）&gt;情况四：如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。123git push origin :&lt;远程分支&gt;# 等同于:git push origin --delete master获取最新的远程仓库的分支：加入在远程仓库中的一个分支中的内容更新了，而本地的这个分支（和远程的这个分支名字相同）不是最新的，可以用git pull来同步。1git pull &lt;远程仓库名&gt; &lt;需要更新的分支（这个分支名：本地的和远程的名字一样）&gt;如：git pull origin feature-D，表示：从远程仓库origin中的“feature-D”分支进行对本地的分支“feature-D”更新。查看提交历史：git log 查看提交（commit）历史（以便确定要回退到哪个版本）。​ 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数，即：git log --pretty=onelinegit log &lt;filename&gt; ：显示特定文件(filename)的提交历史git log -p ：文件的前后差别就会显示在提交信息之后git log -p &lt;filename&gt; ：只查看 “filename”文件的提交日 志以及提交前后的差别。git log --graph：以图表形式查看分支，例如下图：git reflog 查看历史的每一次的命令（以便确定要回到未来的哪个版本）。自定义Git:修改GIT默认编辑器：GIT默认编辑器为Vi，假如我想用Notepad++：1git config --global core.editor &quot;Notepad++&quot; &#x2F;&#x2F;设置Editor使用Notepad++Git显示颜色：1git config --global color.ui true##################################################学习廖雪峰教学中的问题：1、与教学步骤中的命令区别于：“–”（1）git diff head --readme.txt：问题：在我自己电脑上面运行没反应？解决：运行：git diff head readme.txt,即去掉那个“–”。（2）git checkout --readme.txt问题：在于我的电脑上多了“–”会运行失败。解决：去掉“–”：GitHub使用技巧搜索：1）、在不同地方搜索1、按照name搜索1in:name &lt;something&gt; &#x2F;&#x2F;假设想搜索的东西叫：something2、按照readme搜索也可以按照readme.md中包含的查找项目：1in:readme &lt;something&gt; &#x2F;&#x2F;假设想搜索的东西叫：something3、按照descriptin搜索假设我们现在要学习的项目，我们搜索项目描述(description)里面包含的项目:1in:description &lt;something&gt; &#x2F;&#x2F;假设想搜索的东西叫：something4、直接搜索直接在搜索栏中搜索：加入想搜索与CJSON有关的内容：2）、添加约束条件star数量12stars: &gt; 500 &#x2F;&#x2F; star 数量大于500的项目stars: 10..20 &#x2F;&#x2F; star 数量在10-20之间的仓库fork数量同理，我们也可以按照fork的数量来进行搜索:1in:name React forks:&gt;3000language编程语言1language:python &#x2F;&#x2F;比如，把语言限制为Python仓库push的时间假如在这些项目里面，我们想要找到最近才更新的项目，意思是更新时间就在最近，我们可以这样：1pushed:&gt;2020-01-01 &#x2F;&#x2F;项目的最近一次更新时间限制到2020-01-01之后仓库持有者1user：&lt;username&gt;仓库大小1size:&gt;&#x3D;5000 &#x2F;&#x2F; 仓库大于5000KB的仓库仓库create时间1created:&gt;2019-01-01 &#x2F;&#x2F; 2019年以后创建的仓库license协议1license:apache-2.0 &#x2F;&#x2F; 使用 apache-2.0 协议的仓库组织机构代码1org:spring-cloud &#x2F;&#x2F; 列出org 的 spring-cloud 仓库3）、组合搜索将1）和2）中可以随机组合进行精确搜索,比如：1in:description &lt;something&gt; language:python &#x2F;&#x2F;将编程语言限制为python1in:readme &lt;something&gt; stars:&gt;3000 forks:&gt;300012in:description 微服务 language:python pushed:&gt;2020-01-01&#x2F;*pushed:&gt;2020-01-01的意思是我们把项目的最后更新时间限制到2020-01-01*&#x2F;1in:name React forks:&gt;3000等等奇特搜索：awesome搜索1、awesome-awesome搜索直接使用awesome-awesome可以搜索出很多优质项目。1awesome-awesome2、awesome name搜索1awesome &lt;name&gt;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Git","slug":"学习笔记/Git","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://longlongqin.github.io/tags/Git/"}]},{"title":"LearnCpp chapterO","slug":"C&C++/LearnCpp-chapterO","date":"2020-04-04T02:21:31.000Z","updated":"2020-04-19T14:38:29.546Z","comments":true,"path":"archives/67343d3.html","link":"","permalink":"https://longlongqin.github.io/archives/67343d3.html","excerpt":"LearnCpp chapterOhttps://www.learncpp.com未完待续~~","text":"LearnCpp chapterOhttps://www.learncpp.com未完待续~~O.1 Bit flags and bit manipulation via std::bitset在现代计算机体系结构中，最小的可寻址内存单元是字节。由于所有对象都需要有唯一的内存地址，这意味着对象的大小必须至少为一个字节。对于大多数变量类型，这是可以的。然而，对于布尔值，这有点浪费。布尔类型只有两种状态:真(1)，或假(0)。这一组状态只需要存储一位。然而，如果一个变量必须至少是一个字节，而一个字节是8位，这意味着一个布尔值使用1位，而其他7位不使用。位操作：bit manipulation在对象内部，修改单个bit的过程，叫位操作。位操作在加密和压缩算法中也很有用。但是，我们可以将对象视为单个位的集合，而不是将其视为持有单个值的对象。当对象的个别位用作布尔值时，这些位称为位标志：bit flag。在计算中，标志是作为某个函数或进程的信号的值。类似地，在现实生活中，邮箱标志用于指示邮箱中有内容，因此不必打开邮箱进行检查。为了定义一组位标志，我们通常使用适当大小的无符号整数(8位、16位、32位等等，这取决于我们有多少个标志)，或者std::bitset。123#include &lt;bitset&gt; //for std::bitsetstd::bitset&lt;8&gt; mybitset &#123;&#125;; //8 bits in size means room for 8 flags位操作是少数几种应该明确使用无符号整数(或std::bitset)的操作之一。位编号和位的位置：Bit numbering and bit positions给定一个bits 序列，通常从右到左开始进行编号(编号的开头是0，不是1)。每一个数字表示一个bit positon：位的位置。eg：1276543210 Bit position00000101 Bit sequence通过std::bitset操作位在 4.12 – Literals，我们介绍了如何使用std::bitset来输出二进制形式的结果。现在我们来介绍std::bitset的其他功能：std::bitset提供了4个关键的功能，对做位操作很有用:text()：允许我们查询一个位是0还是1；set()：允许我们将一个 位(bit)设置成 on，即将其设置为1；reset()：允许我们将一个 位(bit)设置成 off，即将其设置为 0；flip()：允许我们将一个 位(bit) 由0设置为1，或者由1设置为0；这些函数中的每一个都带有一个位位置参数，该参数指示我们将要操作的位 的位置。123456789101112131415161718192021#include &lt;bitset&gt;#include &lt;iostream&gt;int main()&#123; std::bitset&lt;8&gt; bits&#123;0b0000'0101&#125;; //we need 8 bits, start with bit pattern 0000 0101 bit.set(3); //set bit position 3 to 1 (now we have 0000 1101) bit.flip(4); //flip bit 4(now we have 0001 1101) bit.reset(4); //set bit 4 back to 0 (now we have 0000 1101) std::cout &lt;&lt;\"All the bits: \"&lt;&lt;bits&lt;&lt;'\\n'; std::cout &lt;&lt;\"bit 3 has valude: \" &lt;&lt;bit.test(3) &lt;&lt;'\\n'; std:;cout &lt;&lt;\"bit 4 has valud: \"&lt;&lt;bit.test(4) &lt;&lt;'\\n'; return 0;&#125;/********输出结果********/All the bits: 00001101bit 3 has valude: 1bit 4 has valude: 0O.2 位操作符C++提供了“位操作符(bitwise operator)”：OperatorSymbolFormOperationleft shift&lt;&lt;x &lt;&lt; yall bits in x shifted left y bitsright shift&gt;&gt;x &gt;&gt; yall bits in x shifted right y bitsbitwise NOT~~xall bits in x flippedbitwise AND&amp;x &amp; yeach bit in x AND each bit in ybitwise OR|x | yeach bit in x OR each bit in ybitwise XOR^x ^ yeach bit in x XOR each bit in y在下面的例子中，我们将主要使用4位二进制值。这是为了方便和保持例子简单。在实际的程序中，使用的位的数量是基于对象的大小(例如，一个2字节的对象将存储16位)。为了可读性，我们还将在代码示例之外省略0b前缀(例如，我们将使用0101而不是0b0101)。位操作符：&lt;&lt;左移、&gt;&gt;右移按位左移(&lt;&lt;)操作符将位移到左边。左操作数是要移位的位的表达式，而右操作数是要左移的位的整数。如：x&lt;&lt;1表示，将变量x左移一个位置。从右边移进来的新位接受一个 值0。eg，0011&lt;&lt;1 是 01100011&lt;&lt;2 是 11000011&lt;&lt;3 是 1000同理，按位右移(&gt;&gt;)操作符原理也一样：1100&gt;&gt;1 是 01101100&gt;&gt;2 是 00111100&gt;&gt;3 是 0001下面是一个示例程序：123456789101112131415161718#include &lt;iostream&gt;#include &lt;bitset&gt;int main()&#123; std::bitset&lt;4&gt; x&#123;0b1100&#125;; std::cout &lt;&lt;x&lt;&lt;'\\n'; std::cout &lt;&lt; (x&gt;&gt;1) &lt;&lt; '\\n'; //右移一个位置，结果是0110 std::cout &lt;&lt; (x&lt;&lt;1) &lt;&lt; '\\n'; //左移一个位置，结果是1000 return 0；&#125;/*******结果******/110001101000位操作：NOT ~这个操作符功能就是将每个位的数由0变为1，或由1变为0：如：~0100 是 1011；~0000 0100 是 1111 1011上面例子中，虽然：0100 和000 0100是一样的，就像十进制的7和07一样；但是经过~操作符之后，它们位数不一样，就会产生不一样的结果。位操作：OR |它的形式是对两个表达式进行每个位上的或运算，如：0b0101 | 0b0110。更加直观的形式为：12340 1 0 1 OR0 1 1 0--------- &#x2F;&#x2F;结果为0 1 1 1示例：1234567891011#include &lt;iostream&gt;#include &lt;bitset&gt;int main()&#123; std::cout &lt;&lt; (std::bitset&lt;4&gt;&#123;0b0101&#125; | std::bitset&lt;4&gt;&#123;0b0110&#125;); return 0;&#125;/**********结果********/0111也可进行多个表达式的运算，如：12345670 1 1 1 OR0 0 1 1 OR0 0 0 1--------0 1 1 1&#x2F;&#x2F;只要对应的列有1，它的结果中对应的那一列就是1它写成程序：123456789101112#include &lt;iostream&gt;#include &lt;bitset&gt; int main()&#123; std::cout &lt;&lt; (std::bitset&lt;4&gt;&#123; 0b0111 &#125; | std::bitset&lt;4&gt;&#123; 0b0011 &#125; | std::bitset&lt;4&gt;&#123; 0b0001 &#125;); return 0;&#125;/*********结果*********/0111位操作：AND &amp;它的形式为：0b0101 &amp; 0b0110,更加直观的形式（也可以有多个表达式一起运算）：12340 1 0 1 AND0 1 1 0--------0 1 0 0每一列中只有全部为1时，结果中对应的列才是1.示例：12345678910111213141516#include &lt;iostream&gt;#include &lt;bitset&gt; int main()&#123; std::cout &lt;&lt; (std::bitset&lt;4&gt;&#123; 0b0001 &#125; &amp; std::bitset&lt;4&gt;&#123; 0b0011 &#125; &amp; std::bitset&lt;4&gt;&#123; 0b0111 &#125;); return 0;&#125;//直观的表示为：0 0 0 1 AND0 0 1 1 AND0 1 1 1-------- //结果为0 0 0 1位操作：XOR ^它的形式为：0b0001 ^ 0b0011 ^ 0b0111更加直观的看：123450 0 0 1 XOR0 0 1 1 XOR0 1 1 1--------0 1 0 1每一列如果有奇数个1，则结果中对应的列就是1；否则就是0.位的赋值操作符与算术赋值运算符相似，C++提供位的赋值操作符，为了方便修改变量：OperatorSymbolFormOperationLeft shift assignment&lt;&lt;=x &lt;&lt;= yShift x left by y bitsRight shift assignment&gt;&gt;=x &gt;&gt;= yShift x right by y bitsBitwise OR assignment|=x |= yAssign x | y to xBitwise AND assignment&amp;=x &amp;= yAssign x &amp; y to xBitwise XOR assignment^=x ^= yAssign x ^ y to x比如，x= x&gt;&gt;1，可以写成：x&gt;&gt;=1:1234567891011121314#include &lt;bitset&gt;#include &lt;iostream&gt;int main()&#123; std::bitset&lt;4&gt; bits&#123;0b0100&#125;; bits &gt;&gt;= 1; std::cout &lt;&lt; bits; return 0;&#125;/********结果*********/0010总结：","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://longlongqin.github.io/tags/C-C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"LearnCpp chapter5","slug":"C&C++/LearnCpp-chapter5","date":"2020-04-03T02:21:47.000Z","updated":"2020-04-19T14:38:29.545Z","comments":true,"path":"archives/b6a3dbf1.html","link":"","permalink":"https://longlongqin.github.io/archives/b6a3dbf1.html","excerpt":"LearnCpp chapter5https://www.learncpp.com","text":"LearnCpp chapter5https://www.learncpp.com5.1 操作符优先级 &amp; 结合律Operator precedence and associativity下面是操作符的优先级 及 结合律【note】下面表格的操作符优先级：level 1是最高优先级；level 17 优先级最低结合律：L-&gt;R：即，从左向右结合R-&gt;L ：即。从右向左结合注意一个连等号到表达式：x=y=z;由上表可知，该表达式其实是这样的：x=(y=z);5.2 算数运算符Arithmetic operators一元操作符(Unary arithmetic operators)：+、-：unary minus：返回 操作数乘以-1 之后的值。unary plus：返回 操作数本身。这两个操作符都应该放在操作数的前面(e.g. -x , 而不是 - x)eg: x=5 - -3;.第一个减号表示二元操作符，减法；第二个减号表示一元操作符。二元运算符：Binary arithmetic operators二元操作符有左、右 两个操作数(operand)：整数与浮点数 的除法左右两个操作数至少有一个是 浮点型值，它们的运算结果依然是一个浮点型的值。For example, 7.0 / 4 = 1.75, 7 / 4.0 = 1.75、7.0 / 4.0 = 1.75做有两个操作数均为 整型值，它的运算结果依然是 整型值。For example, 7 / 4 = 1用static_cast&lt;&gt;对整数进行浮点除法1234567891011121314151617181920#include &lt;iostream&gt;int main()&#123; int x&#123;7&#125;; int y&#123;4&#125;; std::cout &lt;&lt;\"int/int=\"&lt;&lt;x/y&lt;&lt;\"\\n\"; std::cout &lt;&lt;\"double / int = \"&lt;&lt;static_cast&lt;double&gt;(x)/y&lt;&lt;'\\n'; std::cout &lt;&lt; \"int / double = \"&lt;&lt;x/ static_cast&lt;double&gt;(y)&lt;&lt;'\\n'; std::cout &lt;&lt;\"double / double = \" &lt;&lt; static_cast&lt;double&gt;(x) / static_cast&lt;double&gt;(y)&lt;&lt;'\\n'; return 0;&#125;/*****结果*****/int / int = 1double / int = 1.75int / double = 1.75double / double = 1.75除以0如果除以0(或者 0.0)将会使程序崩溃。因为这个结果在数学中是没有定义的。赋值操作符5.3 取模 &amp; 幂运算取模操作符：The modulus operator取模操作符*，又称 *取余操作符。【note】：取余运算结果的符号，只和第一个操作数相一致。12345678910111213141516#include &lt;iostream&gt;int main()&#123; int x&#123; 6 &#125;, y&#123; -4 &#125;; //第一个操作数符号为 正 std::cout &lt;&lt; x%y &lt;&lt; '\\n'; int z&#123; -6 &#125;, w&#123; 4 &#125;; //第一个操作数符号为 负 std::cout &lt;&lt; z%w ; std::cin.clear(); std::cin.ignore(std::numeric_limits &lt;std::streamsize&gt;::max(), '\\n' ); std::cin.get(); return 0;&#125;结果：幂运算符^您将注意到^运算符(在数学中通常用于表示求幂)是c++中的位XOR操作。在C++中不包含“幂运算操作符”。如果要用，就需要加上头文件cmath：12#include &lt;cmath&gt;double x&#123; std::pow(3.0, 4.0)&#125;; //3 to the 4th power(3的4次方)【Note】注意，pow()函数的参数(和返回值)是double类型的。所以，就算传入的是整数类型的，它的计算还是会有误差的(因为浮点数计算本身就会有误差)所以，如果你想对整数进行幂运算，可以自己设计函数，使其结果比较精确：12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;cstdint&gt; //for std::int_fast64_t//note: exp(幂数) 不能是负数[因为用的是while循环]std::int_fast64_t powint (int base, int exp)&#123; std::int_fast64_t result &#123;1&#125;; while (exp) &#123; if(exp &amp; 1) result *= base; exp &gt;&gt;= 1; base *= base; &#125; return result;&#125;int main()&#123; std::cout &lt;&lt;powint(7,12); //7的12次幂 return 0;&#125;5.4 递增/递减操作符OperatorSymbolFormOperationPrefix increment (pre-increment)++++xIncrement x, then return xPrefix decrement (pre-decrement)––––xDecrement x, then return xPostfix increment (post-increment)++x++Copy x, then increment x, then return the copyPostfix decrement (post-decrement)––x––Copy x, then decrement x, then return the copy副作用：side effectsc++不定义函数参数或操作符操作数的求值顺序。12345678910111213141516#include &lt;iostream&gt; int add(int x, int y) &#123; return x+y; &#125;int main()&#123; int x&#123;5&#125;; int valude = add(x, ++x); //结果是5+6,还是6+6? //这取决于编译器计算函数参数的顺序 std::cout &lt;&lt;value; // value could be 11 or 12, depending on how the above line evaluates! return 0;&#125;【副作用】：c++没有定义函数参数求值的顺序。这种就会产生不确定性，因为还要取决于编译器对函数的参数计算的顺序。所以，不同的编译器可能会产生不同的结果。所以，结果可能为：11 或者 125.5 逗号“,” &amp; 条件 运算符逗号操作符逗号操作符适用于for循环，其他情况不推荐用OperatorSymbolFormOperationComma,x, yEvaluate x then y, returns value of ycomma operator (,)：允许您在允许单个表达式的情况下计算多个表达式的值。逗号运算符对左操作数求值，然后对右操作数求值，然后返回右操作数的结果。1234567891011121314#include &lt;iostream&gt;int main()&#123; int x&#123;1&#125;; int y&#123;2&#125;; std::cout&lt;&lt; (++x, ++y); //先计算左操作符，在计算右操作符，但是返回右操作符的结果 return 0;&#125;/*******结果**********/3逗号操作符是所有操作符中最低的12z = (a,b); //计算(a,b)，然后将返回的结果赋值给zz = a , b; //由于“=”操作符优先于“,”操作符，所以，先计算“z=a”;然后在计算b，计算完之后，b没用就被抛弃了逗号用作分隔符时，它此时代表的不是操作符12345void foo(int x, int y) // Comma used to separate parameters in function definition&#123; add(x, y); // Comma used to separate arguments in function call int z(3), w(5); // Comma used to separate multiple variables being defined on the same line (don't do this)&#125;条件操作符条件操作符是一个 三元操作符OperatorSymbolFormOperationConditional? :c ? x : yIf c is nonzero (true) then evaluate x, otherwise evaluate y形式：(condition) ? expression1 : expression2;当condition的结果是正确的(或者非零数字)，就执行expression1，否则，执行expression2由于条件操作符优先级较低，有时需要括号如：12345std::cout &lt;&lt; (x&gt;y) ? x : y;//由于“&lt;&lt;”的优先级高于“条件操作符”,所以，等同于以下形式：(std::cout &lt;&lt; (x&gt;y)) ? x : y;//想要按照我们设计的正确执行，则需要适当加上括号std::cout &lt;&lt;((x&gt;y) ? x : y);【注意】与在函数内部定义的变量在函数结束时死亡非常相似，在if或else语句中定义的变量在if或else语句结束时死亡。因此，在我们试图打印它时，类大小已经被破坏了。1234567891011121314#include &lt;iostream&gt; int main()&#123; bool inBigClassroom &#123; false &#125;; if (inBigClassroom) const int classSize &#123; 30 &#125;; else const int classSize &#123; 20 &#125;; //此时，if/else已经执行结束，所以，其内部定义的变量classSize也已经被销毁 std::cout &lt;&lt; \"The class size is: \" &lt;&lt; classSize; //因为classSize被销毁，所以会编译出错 return 0;&#125;条件编译的两个表达式的类型条件编译的两个表达式，要么具有相同的类型；要么第二个表达式的类型可以转化为第一个表达式的类型。1234567891011#include &lt;iostream&gt; int main()&#123; int x = 5; std::cout &lt;&lt; (x != 5 ? x : \"x is 5\"); // won't compile return 0;&#125;//因为，表达式1：x 是integer 类型；表达式2：\"x is 5\"是string类型。所以表达式2要转换为表达式1的类型，但是转换失败。所以编译就不成功5.6 关系运算符 &amp; 浮点数的比较关系运算符OperatorSymbolFormOperationGreater than&gt;x &gt; ytrue if x is greater than y, false otherwiseLess than&lt;x &lt; ytrue if x is less than y, false otherwiseGreater than or equals&gt;=x &gt;= ytrue if x is greater than or equal to y, false otherwiseLess than or equals&lt;=x &lt;= ytrue if x is less than or equal to y, false otherwiseEquality==x == ytrue if x equals y, false otherwiseInequality!=x != ytrue if x does not equal y, false otherwise这些操作符的值分别为布尔值true(1)和false(0)。浮点数的比较12345678910111213141516171819#include &lt;iostream&gt; int main()&#123; double d1&#123; 100.0 - 99.99 &#125;; // should equal 0.01 ? double d2&#123; 10.0 - 9.99 &#125;; // should equal 0.01 ? if (d1 == d2) std::cout &lt;&lt; \"d1 == d2\" &lt;&lt; '\\n'; else if (d1 &gt; d2) std::cout &lt;&lt; \"d1 &gt; d2\" &lt;&lt; '\\n'; else if (d1 &lt; d2) std::cout &lt;&lt; \"d1 &lt; d2\" &lt;&lt; '\\n'; return 0;&#125;/****结果*****/d1 &gt; d2我们可以看到，在我们的调试模式下，d1 = 0.0100000000000005116 而 d2 = 0.0099999999999997868.【Note】：在两个浮点数非常接近时，如果使用==和!=对浮点数之间比较，结果会不太准确。使用epsilon准确比较浮点数我们可以使用epsilon来相对准确的比较两个 足够接近的 浮点型数值。epsilon：通常被定义为一个小的正数(如，0.00000001，即1e-8)现在，我们来比较两个”close enough”的浮点数：12345678#include &lt;cmath&gt; //for std::abs()//epsilon is an absolute valuebool isAlmostEqual(double a, double b, double epsilon)&#123; //if the distance between a and b is less than epsilon, then a and b are \"close enough\" return std::abs(a-b) &lt;= epsilon;&#125;虽然这个函数可以工作，但它不是很好。0.00001的epsilon值对于1.0左右的输入是合适的，对于0.0000001左右的输入是太大了，对于10,000这样的输入是太小了。这意味着每次我们调用这个函数时，我们必须选择一个适合我们输入的。如果我们知道我们要根据输入的比例来缩放，我们也可以修改函数来做到这一点。改进1：12345678#include &lt;cmath&gt; //std::abs#include &lt;algorithm&gt; //std::max//return true if the difference between a and b is within epsilonbool approximatelyEqual(double a,double b, double epsilon)&#123; return (std::abs(a-b) &lt;= ( std::max( std::abs(a),std::abs(b) ) * epsilon ));&#125;在这种情况下，epsilon不再是一个绝对值，现在是相对于a或b大小的量级。再改进2【推荐】：当浮点数足够接近于0时，上面的方法还是不太行的。改进方法就是：同时使用相对值和绝对值：1234567891011// return true if the difference between a and b is less than absEpsilon, or within relEpsilon percent of the larger of a and bbool approximatelyEqualAbsRel(double a, double b, double absEpsilon, double relEpsilon)&#123; // Check if the numbers are really close -- needed when comparing numbers near zero. double diff&#123; std::abs(a - b) &#125;; if (diff &lt;= absEpsilon) return true; // Otherwise fall back to Knuth's algorithm(相对值方法，即“改进1”的方法) return (diff &lt;= (std::max(std::abs(a), std::abs(b)) * relEpsilon));&#125;在这个算法中，我们首先检查a和b在绝对值上是否接近，这处理了a和b都接近于零的情况。absEpsilon参数应该设置为非常小的值(例如1e-12)。如果失败了，我们就回到Knuth的算法，即，使用相对的epsilon。完整的示例：1234567891011121314151617181920212223242526272829303132333435363738#include &lt;algorithm&gt; //std::max#include &lt;cmath&gt; //std::abs#include &lt;iostream&gt;//如果a和b之间的差值在a和b之间较大值的百分之几内，则返回truebool approximatelyEqual(double a,double b,double epsilon)&#123; return (std::abs(a-b) &lt;= (std::max(std::abs(a), std::abs(b)) * epsilon ));&#125;//针对于接近于0 的浮点数的比较bool approximatelyEqualAbsRel(double a, double b,double absEpsilon, double relEspilon)&#123; //check if the numbers are really close -- need when comparing numbers near zero. double diff &#123;std::abs(a-b)&#125;; if (diff &lt;= absEpsilon) return ture; //otherwise fall back to 相对值法 return (diff &lt;= (std::max(std::abs(a), std::abs(b)) * relEspilon));&#125;int main()&#123; //a is really close to 1.0, but has rounding errors double a&#123;0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1&#125;; std::cout &lt;&lt; approximatelyEqual(a, 1.0, 1e-8);//compare \"almost 1.0\" to 1.0 std::cout &lt;&lt; approximatelyEqual(a-1.0, 0.0, 1e-8); //compare \"almost 0.0\" to 0.0 std::cout &lt;&lt; approximatelyEqualAbsRel(a-1.0, 0.0, 1e-12, 1e-8) &lt;&lt; '\\n'; // compare \"almost 0.0\" to 0.0&#125;/**********结果*********/101可以看出，在对于接近于0的浮点数，与 0.0比较时。approximatelyEqualAbsRel要更加准确。使用approximatelyEqualAbsRel方法，就可以解决大多数情况。它也涵盖了approximatelyEqual函数的功能。5.7 逻辑操作符OperatorSymbolFormOperationLogical NOT!!xtrue if x is false, or false if x is trueLogical AND&amp;&amp;x &amp;&amp; ytrue if both x and y are true, false otherwiseLogical OR||x || ytrue if either x or y are true, false otherwiseNOT：！需要注意的是，NOT 操作符的优先级很高，在level 3。所以，你很有可能会犯这种错误：1234567891011121314151617#include &lt;iostream&gt;int main()&#123; int x&#123;5&#125;; int y&#123;7&#125;; if(!x&gt;y) //正确写法：if (!(x&gt;y)) std::cout &lt;&lt; \"x is not greater than y\\n\"; else std::cout &lt;&lt; \"x is equal to or greater than y\\n\"; return 0; &#125;/********结果************/x is equal to or greater than y可以看出，结果不正确。在这里就是因为，if(!x&gt;y)中，由于!优先级高于&gt;。所以，先计算“!x”，其实，就相当于：if ( (!x) &gt; y )AND： &amp;&amp;如果逻辑操作符&amp;&amp;要返回“true”，那么所有的操作数都必须是‘true’；但如果&amp;&amp;返回是“false”，只要有一个操作数是‘false’即可。特殊的，如果第一个操作数是‘false’的话，就不会再继续看后面操作符是‘false’还是‘true’，即图签终止了。这种情况叫做：“short circuit evaluation”相似的，逻辑操作符 或||，如果要返回“true”的话，也是只要有一个操作数是‘true’即可。逻辑操作符&amp;&amp;的优先级高于||，所以，在使用如：value1 || value2 &amp;&amp; value3时，要更加小心，使用括号才会更加安全。德摩根定律：De Morgan’s law德摩根定律告诉我们，可以这样使用逻辑操作符!：!(x &amp;&amp; y) 等同于 !x || !y!(x || y)等同于 !x &amp;&amp; !y换句话说，当您分发逻辑NOT时，您还需要转换为逻辑AND逻辑OR，反之亦然!逻辑操作符，异或XORLeft operandRight operandResultfalsefalsefalsefalsetruetruetruefalsetruetruetruefalse即，真假 为 真，其他结果都是 假C++没有提供专门提供 异或操作符，但是我们可以使用：当操作数是布尔型的，即true，false，而不是integer，可以使用!=来实现异或：123456if (a != b) //a XOR b ,假定a、b是booleans ... //多个操作数if (a != b != c != d) // a XOR b XOR c XOR d, assuming a, b, c, and d are Booleans ...当操作数不是布尔型时，使用static_cast转化为bool：12if (static_cast&lt;bool&gt;(a) != static_cast&lt;bool&gt;(b) != static_cast&lt;bool&gt;(c)) // a XOR b XOR c XOR d, for any type that can be converted to bool ...","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://longlongqin.github.io/tags/C-C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"计算机科学速成课(总)","slug":"学习笔记/《计算机科学速成课》笔记/计算机科学速成课","date":"2020-04-01T02:29:42.000Z","updated":"2020-04-01T02:49:13.858Z","comments":true,"path":"archives/3ae1bc73.html","link":"","permalink":"https://longlongqin.github.io/archives/3ae1bc73.html","excerpt":"计算机科学速成课","text":"计算机科学速成课###参考文章###：*计算机科学速成课 *：笔记：https://www.cnblogs.com/livil/p/10155073.html 和https://zhuanlan.zhihu.com/p/103505933 或 https://www.imooc.com/article/271502字幕：https://github.com/1c7/Crash-Course-Computer-Science-Chinese/blob/master/(字幕)全40集中英字幕文本2、电子计算机3、布尔逻辑和逻辑门计算机最早是机电设备，一般用十进制计数。也有一些是三进制、五进制的。【也就是x进制表示有x种状态。】二进制中的 1或0 叫做：位（bit）；1字节（byte）=8位(bits)5、算数逻辑单元（ALU）：是计算机的数学大脑，是计算机里负责运算的组件。ALU有2个单元：1个算数单元和1个逻辑单元。算数单元：负责计算机里的所有数字操作。如加减法。1）算数单元(半加器)A half adder:半加器如下所示：将其抽象化，把“把假期”封装成一个单独组件：全加器（Full Adder）:如果想要处理多位二进制数加法时，就需要全加器（Full Adder），因为半加器计算完当前位的结果后，会输出进位，意味着计算下一位的结果时，要将两个输入以及前一位的进位相加。我们可以得到全加器的真值表：全加器真值表![image-20200211205005097](https://longlongqin.gitee.io/image_save/images/assets/image-20200211205005097.png)我们这里可以使用半加器来实现全加器。我们可以将一个半加器结果当做是INPUT A 和INPUT B相加后的结果，然后将SUM当做是新的INPUT A，而PRE CARRY当做是新的INPUT B输入到新的半加器中，可以发现其SUM结果和全加器SUM结果相同。而全加器的CARRY只要对这两个半加器的CARRY进行OR运算就可以了。（注意：这两个半加器不会同时出现进位）同样我们也可以对全加器进行抽象，得到一个包含三个输入和两个输出的独立部件。由此我们可以进行两个8位数字相加，表示为A和B:对A和B的第一位进行相加时，由于不存在进位，所以值使用一个半加器就能实现，这个半加器的SUM就为该位的结果，CARRY就为进位。后续的7位二进制相加，由于每一个都涉及了上一位的进位，所以后续需要7个全加器，并且每个全加器的CARRY要连接到下一个全加器的输入，而每个全加器的SUM就为该位的结果。最后一个全加器有CARRY的输出，如果该CARRY为1，就表示相加结果太大了，超出了8位，所以出现了溢出（overflow）【溢出：一般来说 “溢出” 的意思是, 两个数字的和太大了，超过了用来表示的位数，这会导致错误和不可预期的结果。】。由此，我们就构建出了一个8位加法器（8-bit adder）通过连接1个半加器和n-1个全加器，就能构建n位加法器。通过叠加更多的加法器，能够避免溢出的出现，但是会出现更多的逻辑门，而且每次进位都要一些时间，而计算是串行的，所以消耗的时间也越长，到如今的每秒几十亿次运算时就会造成影响，所以现代计算机用的加法电路有所不同，称为超前进位加法器（Carry-Look-Ahead Adder）。ALU通常支持以下操作：加法、带进位的加法、减法、带借位的减法、取反、增1、减1、数字无改变通过。这些操作也是由逻辑门构成的。注意：简单的ALU并==不==支持乘法，而是把乘法用多次加法来实现，而更好的处理器有专门做乘法的算数单元。2）逻辑单元逻辑单元：执行逻辑操作，比如AND、OR和NOT操作，也能做简单的数值测试，比如数字是不是负数。对整个8位ALU进行抽象，用一个特殊的V形符号进行表示。其中有两个8位输入，并且有一个4位操作码（Operation Code）来告诉ALU对输入执行什么操作，比如1000表示加法命令，1100表示减法命令，然后有一个8位输出。同时ALU会输出一系列1位标志（FLAG），来表示特定状态，比如我们可以计算A-B，然后通过ZERO来判断结果是否为零来判断A与B是否相等，通过NEGATIVE来判断A是否小于B；然后OVERFLOW连接到加法器的进位，来判断是否出现溢出。6、寄存器&amp;内存上节中介绍的ALU进行计算后得到的结果需要对其进行存储，可能还要进行多个连续操作，这就需要用到计算机内存了。计算机使用的是随机存取存储器（Random Access Memory, RAM），其只能在有电的情况下存储东西。另一种存储称为持久存储（Persistent Memory），电源关闭时数据也不会丢失，它用来存其他东西。随机存取存储器(RAM)：只能在有电的时候存储东西。【 内存的一个重要特性：可以随时访问任何位置。所以叫“随机存取存储器(RAM)”】))放入数据的动作叫“写入”，拿出数据的动作叫“读取”。这一节中首先构建能够存储1位的存储器，然后对其扩展来得到内存模块。之前构建的都是单向电路，我们同样可以构建回向电路，把输出连回输入。1、当将OR门构建成回向电路时，可以分析其电路特性：A和B初始为0时，输出结果为0存储0的电路- 将A修改为1时，输出结果为1，此时B的输入就变为了1。随后输出始终保持为1，不论A如何变化。所以这个电路能够永久记录1，并且无法将1变回0。2、同理可以分析下AND门构建成回向电路时的特点A和B初始化为1，则输出结果为1将A修改为0时，输出结果为0，此时B的输入就变成了0。随后输入始终保持为0，无论A如何变化。所以这个电路能够永久记录0，并且无法将0变回1。所以我们就得到了能够存储1和0的电路，为了得到有用的Memory，需要将两个电路结合起来，可以得到AND-OR锁存器（AND-OR Latch），上方的是SET输入，下方的是RESET输入，当SET=1、RESET=0，就能将输出设置为1，当RESET=1，就能将输出设置为0，当SET=0、RESET=0，则输出最后放入的内容。由此能够存储1位的信息（该信息存储在OR门上方的输入电极中）！这叫”锁存”, 因为它”锁定”了一个值，放入数据的动作叫 “写入” ，拿出数据的动作叫 “读取”。对其进行SET和RESET进行合并，并添加其他门控单元，可以得到一个门锁（GATE LATCH）门锁其中DATE INPUT表示数据输入，WRITE ENABLE表示允许写入线，用来控制是否保存当前输入的数据。对这个电路进行分析。可以将门锁进行抽象，得到一个能够存储一个bit的部件。当允许写入线为0时，输出保持不变，当允许写入线为1时，输出就是数据输入，并且能够将数据输入进行存储。门锁的抽象如果我们并排8个锁存器，就能存储8位信息。一组这样的锁存器称为**寄存器（Register）**，寄存器能够存一个数字，这个数字的位数称为寄存器的**位宽（Width）**。写入寄存器之前，要先启动里面所有的锁存器，可以将所有锁存器的允许写入线都连接在一起，把它设为1，然后用8条数据线发送数据，然后将允许写入线设回0，就能将8位数据存储在寄存器中。)寄存器：上面是只能存储1bit的“锁存器”，如果我们并排放8个锁存器，就可以存8位(bits)信息。一组这样的锁存器叫做“寄存器”。1、位宽寄存器能存一个数字，这个数字有多少位，叫做“位宽”。$早期电脑用8位寄存器，然后是16位、32位。如今都有64位宽的寄存器。$)))所以，如64位的寄存器只需要129条线就可以了。【64条是“数据输入线”、“64条数据输出线”、“一条启用写入线”】。如果要存256位，就需要513条线。减少线数的方法就是：矩阵。)所以，对于一个256位的存储：只需要35条。)如果想要访问特定的锁存器（即寻找其地址），（由于行数和列数均只有16，所以均可以用4个二进制位来表示。）就有行号和列号来对应。)))多路复用器：有不同大小。通常包含一定数目的数据输入，有一个单独的输出。把256位内存当成一个整体，抽象化一下：))一个256位内存也不能做什么大事，所以继续扩大：))))再次，看成一个整体：下图中：我们有256个地址，每个地址能读或写一个8位(bit)的值。)))))这一节用锁存器做了一块静态随机存取存储器（Static Random-Access Memory，SRAM），还有很多其他类型的RAM，比如DRAM、闪存和NVRAM，它们的功能和SRAM相似，但是使用不同的电路存放单个位。但是根本上，这些技术都是矩阵层层嵌套来存储大量信息。7、中央处理器(CPU)CPU负责执行程序，程序由一个个操作组成，这些操作叫“指令(instruction)”。如果是数学指令，比如加减，CPU会让ALU进行数学运算。如果是内存指令，CPU会和内存通信，然后读写值。9、高级CPU设计RAM是CPU之外的独立组件，意味着数据要用线来传递，这个线叫做“总线（BUS）”。$总线可能只有几厘米，虽然电信号传输速度接近光速，但是CPU每秒可以处理上亿条指令，很小的延迟也会造成问题。$)提升性能方法一：缓存一条“从内存读数据”的指令可能需要多个时钟周期，而此时CPU空等数据。解决延迟的方法之一是给CPU加一点RAM,叫：“缓存(Cache)”。因为处理器的空间不大，所以缓存一般只有KB或MB，而RAM都是GB起步。缓存提高了速度：当CPU从RAM拿数据时，RAM不用传一个，可以传一批。虽然花的时间多一点，但数据可以存在缓存。这很实用，因为数据常常是一个个按顺序处理。比如：算餐厅的当日收入时，先取RAM地址为100 的交易额，RAM与其只给一个值，不如直接给一批值，把地址为100~200的数据都复制到缓存中。当处理器要下一个交易额（地址为101的）时，缓存就会告诉处理器：“我已经有这个数据了，现在就给你”。就不用再去RAM取数据了。)当想要的数据已经在缓存中时，这种状态叫“缓存命中（Cache Hit）”；如果不在，则叫“缓存未命中（Cache Miss）”。缓存也可以当临时空间，存一些中间值，适合长的或者复杂的运算。继续餐馆的例子：假设CPU算完了一天的销售额，想把结果存到地址为150的地方。就像之前，数据不是直接存到RAM中，而是存在缓存中。这样不但存起来快一些、如果还要接着计算，取值也会快一些。但是这会导致：缓存和RAM中的数据不一致。因此缓存里每块空间有一个特殊标记，叫：“脏位（Dirty Bit）”。同步一般发生在：当缓存满了而CPU又需要缓存的时候。在清理缓存腾出空间之前，会先检查“脏位”，如果是“脏”的话，在加载新内容之前，会把数据写回RAM。![演示 (3)](https://longlongqin.gitee.io/image_save/images/assets/演示 (3).gif)提升性能方法二：“指令流水线”指令流水线：instruction pipelining例如：如果你想要洗一整个的床单，但只有一个洗衣机和一个烘干机。选择一：按顺序，先放洗衣机洗30分钟，然后在烘干机30分钟。共计1小时。选择二：像一中一样，先放一批床单到洗衣机30分钟，然后把它放到烘干机中。但是这时候要等30分钟才能烘干。此时，可以放另一批床单到 洗衣机（此时，洗衣机，烘干机在同时工作），依次，直到洗完所有床单。效率是一的2倍。处理器也可以这样设计，CPU是按顺序处理的：(读)取指(令)——&gt;解码——&gt;执行。不断重复：但是每个阶段都是用的CPU的不同部分，意味着可以并行处理：“执行”一个指令时，同时“解码”下一个指令，同时，“读取”下下条指令。这样的流水线，每一个时钟周期执行1个指令，吞吐量乘3.但是，和缓存一样，这也会带来一些问题：问题1：指令之间的依赖关系。)因此流水线处理器，要先弄清楚数据依赖性。必要时停止流水线，避免出问题。高端的CPU，会最小化流水线的停工时间，这叫“乱序执行”。问题二：“条件跳转”，比如之前的JUMP NEGATIVE（类似循环跳转）。这些指令会改变程序的执行流。)空等会造成延迟。​ 技巧：“推测执行”)))))为了尽可能减少清空流水线的次数，CPU厂商开发复杂的方法：“分支预测”。现在这种猜测的正确率超过90%。在理想情况下，CPU在一个时钟周期完成一个指令。但是“超标量处理器”的出现，一个时钟周期可以完成多个指令。用“多核处理器”【双核、四核处理器：意思是一个CPU芯片里，有多个独立的处理单元，”看起来就像有多个独立的CPU”。但因为他们整合紧密，可以共享一些资源如，缓存，使得多核可以合作运算。】。当多核不够时，可以用多个CPU。10、早期的计算机编程​ 之前的程序是用插线板编程，到后来（1940年代晚期到1950年代初）内存的价格下降，容量上升，使得程序存入内存变得可行。程序存入内存中易于修改、方便CPU快速读取，这类机器叫做：“存储程序计算机（Stored-program Computers）”。内存足够时，还可以存储程序需要的数据（包括运行时产生的数据）。这种将程序和数据存储在一起的存储结构，叫“冯诺依曼结构”。​ 冯诺依曼计算机的标志是，一个处理器（有算数逻辑单元）+数据寄存器+指令寄存器+指令地址寄存器+内存（负责存数据和指令）。11、编程语言发展史​ 计算机只能处理二进制，其实，“机器语言（Machine Language）”或“机器码（Machine Code）”。在计算机早起，还必须要用机器码 些好吃呢供需，一般会先对程序进行高层次的功能描述，称为“伪代码（Pseudo-code）”，只是助于程序员理解无法让计算机运行，然后根据指令表将伪代码转换成二进制机器码，然后将机器码送入计算机中运行。​ 在1940-1950年，程序员开发出一种新语言，更可读、更高层次，每个操作码分配一个简单名字，称为助记符（Mnemonics），助记符后跟数据，形成完整的指令。如下图所示：所以与其写0和1的机器码，程序员可以直接写“LOAD_A 14”，这个语言称为汇编语言（Assembly Language）。当然计算机无法理解“LOAD_A 14”，所以程序员们写了一个程序来将文字指令自动转换成二进制指令，这个程序称为汇编器（Assembler），$汇编器读取汇编语言写的程序，然后转换成机器码$。随着发展，汇编器有越来越多的功能使得编程更加容易，其中一个功能就是自动分析JUMP地址。如下图，JUMP后面跟的是内存中的真实地址，如果我们在上方对程序进行修改，则后面的所有地址都会改变。所以汇编器不用固定跳转地址，而是让你插入可跳转的标签，当程序传入汇编器，汇编器就会自己推算出跳转地址，这样就程序员就无序过分关注细节。​ $汇编代码例子$汇编只是修饰了一下机器码，一般来说，一条汇编指令对应一条机器指令，所以汇编码和底层硬件连接很密切，程序员仍需要思考使用什么寄存器和内存地址。为了释放电脑的潜力，霍普设计了一个高级编程语言，叫做Arithmetic Language Version 0，简称A0。一行高级编程语言，可能会转换成几十条二进制指令。为此做到这种复杂转换，霍普在1952年创造了第一个编译器（Compiler），编译器专门把高级语言转换成低级语言（比如汇编 或 机器码）。由此，高级编程语言就不用管寄存器或内存位置，编译器会解决这些细节。在1950年，大多数编程语言和编译器只能运行在一种计算机中，如果更换计算机，就要重写所有代码，因此1959年开发一种通用编程语言，可以在不同机器上通用，最后诞生了一门高级、易于使用的语言普通面向商业语言（Common Business-Oriented Language，COBOL）。为了兼容不同底层硬件，每个计算机架构需要一个COBOL编译器，由此无论运行的计算机是什么，这些编译器可以接收相同的COBOL代码。如今大多数编程语言都是如此，不必接触CPU特有的汇编码和机器码。12、编程原理-语句和函数a=5;是一个编程语言的语句。程序由一个个指令组成。13、算法入门算法：解决问题的具体步骤。14、数据结构数据是以什么形式存在内存里呢？我们希望数据是结构化的，方便读取，由此发明了数据结构。14.1 数组Array一个变量只能存储一个值，而一个数组变量能够保存多个同类型值，并且数组的值是一个个连续存在内存中的。为了取出数组中的某个值，我们需要指定一个下标（Index）。大多数编程语言中，数组的下标都从0开始。下图是数组保存在内存中的形式，为了简单，假设编译器从内存地址1000开始保存数组，数组中的内容就像图中那样顺序保存在内存中。定义该数组变量为j，则j[0]会取内存地址1000的数据来获得第一个元素的值， j[5] 则会去内存地址1000加5个偏移量得到内存地址1005中保存的数据。缺点：创建数组时就要固定大小，不能动态增加大小，并且数组在内存中是按顺序存储的，在中间插入一个值很困难。14.2 字符串String类似于数组，其实就是字母、数字、标点符号等构成的数组。我们在第4节中有讨论了计算机怎么存储字符的，通过ASCII或者Unicode编码，将字符转换为对应的二进制数。写代码时，可以直接用引号括起来构建字符串j=&quot;Hello World&quot;， 其在内存中的存储形式如下图。注意：字符串在内存中以二进制0结尾，表示字符串结尾，用来给别的函数指示什么时候字符串结束了。14.3 矩阵Matrix之前保存的都是一维数组，但是像电子表格或屏幕像素，都需要保存二维信息，所以这里就需要用到矩阵。可以将矩阵看成是数组的数组，比如一个3x3矩阵， 相当于就是一个长度为3的数组，而这个数组中的每个元素又是一个长度为3的数组。矩阵保存在内存中的形式如下图所示，这里使用的是行优先存储，即优先将矩阵的每一行保存在内存的相邻位置，当一行保存完后，再保存下一行。矩阵例子![img](https://longlongqin.gitee.io/image_save/images/assets/v2-f4e8c5b992abea5477f71fcf39702a68_hd.jpg)内存中的矩阵为了获取一个值，需要两个小标，比如`j[2][1]`表示从内存地址1000偏移`2*3+1=7`位置，得到元素12。这里偏移量的计算方法是`行索引*列元素个数+列索引`。我们不仅能构建二维矩阵，我们可以构建任意维度的矩阵。14.4 结构体Struct目前我们只将单个数字或字符存在数组或矩阵中，在数组中保存的都是相同类型的元素。如果我们想把几个有关系的变量存储在一起，并且这些变量都是不同类型的，我们就需要用到结构体。…..16、软件工程为了写大型程序，程序员用各种工具和方法，所有这些形成了软件工程学科。将大项目分解成小函数可以让很多人同时工作，由此他们无需关心整个项目，只要关心自己的函数就好了。但是这种抽象程度还是不够，大型项目中可能还是会存在大量的函数，因此需要将函数打包成层级，将相关代码放在一起，打包成对象（Object）。比如汽车软件中，可能有几个和定速巡航有关的函数，因此我们可以包装一个“定速巡航对象”来打包这些函数，我们还可以更进一步，“定速巡航”只是引擎软件的一部分，可能还有“火花塞点火”、“燃油泵”和“散热器”等等，因此我们可以做一个“引擎对象”来打包所有子对象，并且除了子对象，引擎对象还会包含自己的函数，比如“开关引擎”，也会有自己的变量，比如汽车行驶里程数。总的来说，对象可以包含其他对象、函数和变量。然后当你想调用一个比较底层对象的函数时，只需要层层向下调用就行，比如Car.Engine.CruiseControl.setCruiseSpeed(55)。这种将函数打包成对象的思想称为面向对象编程（Object Oriented Programming）。相同的想法都是通过封装组件来隐藏复杂度。把大型软件拆成一个个更小单元，会更适合团队合作。但是各个团队之间的代码是相互交织的，比如团队A实现的某个函数需要团队B的代码支持，因此团队需要文档（Documentation）来帮助理解代码都做什么，以及定义好的程序编程接口（Application Programming Interface，API）。这样，即使程序员不知道具体的实现细节，也能直接使用API调用相应的函数。并且API能控制哪些函数和数据是对外开放的，哪些是仅供对象内部使用的，面向对象的编程语言可以指定函数时public或private来设置权限，避免用户调用错了函数造成bug。如果标志为private，表示只有同一个对象内的其他函数能调用它， 所以在这个例子中，只有内部函数比如setRPM能够调用 fireSparkPlug函数，并且由于setRPM函数是public的，所以其他对象可以调用它。面向对象编程的核心：隐藏复杂度，选择性的公布功能。现代软件开发者会使用专门的工具来写代码，工具里集成了很多功能帮助写代码、整理、编译和测试，这些软件称为集成开发环境（Integrated Development Environments，IDE）。程序员一个重要的工作部分是给代码写文档，一般放在一个叫README的文件中， 文档也能直接写成注释放在源代码中。除了IDE，还有一个重要软件帮助团队协作，称为源代码管理（Source Control）。比较大型的公司会将代码放在一个中心服务器上，称为代码仓库（Code Repository）。当程序员想改一段代码时，可以check out获得代码，然后开发者在自己电脑上编辑代码，当代码没有问题，所有测试都通过时，就能将代码放回代码仓库了，称为提交（Commit）。当代码被check out，并且可能被改过了，其他开发者就不会动这段代码，避免代码冲突和重复劳动。代码的主版本（master）应该总是编译正常，尽可能少bug。并且源代码管理可以跟踪所有变化，当出现bug时，全部或部分代码可以回滚（Rolled Back）到之前的稳定版本，并且也能记录下代码修改者。测试代码一般由个人或小团队完成，测试可统称为质量保证测试（Quality Assurance Testing，QA）。“alpha version”软件一般很粗糙，错误很多，经常只在公司内部操作，而“beta version”软件指的是软件接近完成，但不是完全测试通过，公司有时会向公众发布beta版，以帮助发现问题，用户就像免费的QA团队。17、集成电路&amp;摩尔定律过去计算机的飞速发展，强烈依赖于硬件的发展。大约1940年代-1960年代中期，计算机都由独立部件组成，称为分立元件（Discrete Components），然后不同组件再用线连在一起。比如ENIAC有1万7千多个真空管，7万个电阻，1万个电容，7千个二极管，5百万个手工焊点。如果想要提升性能，就要加更多部件，这就导致了更多更复杂的电线，这个称为数字暴政（Tyranny of Numbers）问题。到1950年代中期，晶体管开始商业化，开始用于计算机中，晶体管比电子管更小更快更可靠，但晶体管依然是分立元件。1959年，IBM把709计算机从原本的电子管全部换成晶体管，诞生了IBM 7090，速度快6倍，价格只有一半。晶体管标志着计算机2.0时代的到来，但是晶体管的出现还是没有解决数字暴政的问题，有十几万个独立元件的计算机不但难设计，而且难生产。集成电路（Integrated Circuits，IC）：到1960年代，这个问题的严重性达到顶点，解决方法就是引入一层新抽象，封装复杂性。突破性进展在1958年，与其把多个独立部件用电线连起来，拼装出计算机，我们把多个组件包在一起，变成一个新的独立组件，这个称为集成电路（Integrated Circuits，IC）。几个月后，仙童半导体就让集成电路变成现实，之前使用锗来做集成电路，但是锗很稀少且不稳定，仙童半导体使用硅，因为硅的蕴藏量丰富，也更稳定可靠。起初，一个IC只有几个晶体管，但是也足以将逻辑门封装成独立组件，可以组合出无数种设计，但是最终还是要连起来，创造出更大更复杂的电路，比如计算机。所以创造出了印刷电路板（Printed Circuit Boards，PCB），可以大规模生产，无需焊接或用一堆线，它通过蚀刻金属线的方式将零件连接到一起。把PCB和IC结合使用，可以大幅减少独立组件和电线，但做到相同的功能，而且更小更便宜更可靠。不过即使组件再小，塞5个以上的晶体管还是很困难，为了实现更复杂设计，出现了全新的制作工艺——光刻（Photolithography）。简单来说，就是用光把复杂图案印到材料上，比如半导体。它只有几个基础操作，但是可以制作出复杂电路。首先，我们从一片硅开始，称为晶圆（Wafer），长得和薄饼干一样。并且硅是半导体，有时导电有时不导电，我们就可以控制导电时机，所以硅是做晶体管的绝佳材料。我们可以用晶圆做基础，把复杂金属电路放上去，来集成所有东西。在硅片顶部加一层薄薄的氧化层（Oxide Layer）作为保护层，然后加一层特殊化学品称为光刻胶（Photoresist），光刻胶被光照射后，就变得可溶，可以用一种特殊化学药剂洗掉。然后我们会在光刻胶上加一层光掩膜（Photomask），当用强光照射时，挡住光的部分光刻胶就不会变化，而光照射到的地方，光刻胶就会发生化学变化，洗掉变化的光刻胶后，就会暴露出部分氧化层。然后通常用酸能洗掉氧化层暴露出的部分，就能蚀刻到硅层。然后再用另一种化学试剂清洗掉剩余的光刻胶，这样只剩下氧化层和晶圆了。我们想修改硅暴露出来的区域，让它们导电性更好，所以我们使用掺杂（Doping），通过将磷渗透进暴露的硅，来改变电学性质。我们还需要几轮光刻法来做晶体管。还是叠加上氧化层、光刻胶和新的光掩膜，这样就能在掺杂区域上方开缺口，然后进行清洗蚀刻，再用另一种元素进行掺杂，把硅转换成另一种形式。为了控制深度，时机很重要，不要超过之前掺杂的区域，这样所有需要的组件都有了。最后，在氧化层上做通道，这样可以用细小金属导线连接不同晶体管。首先用光刻胶和光掩膜，在氧化层上蚀刻出小通道。然后用新的处理方法称为金属化（Metalization），在氧化层上放一层薄薄的金属，比如铝或铜，再加上光刻胶和光掩膜，然后融掉暴露的光刻胶，暴露出金属。最终清洗，只保留晶圆、氧化层和金属化，这样就做出了一个晶体管。它有三根线分别连接着硅的三个不同区域，每个区域的掺杂方式不同，这个叫双极型晶体管（Bipolar Junction Transistor）。晶体管相同方法，光刻可以在一片硅上制作其他电子元件，比如电阻电容，而且相互连接的电路也做好了。并且通过调节光掩膜和光源之间的距离，光可以投射成任意角度，我们可以把光掩膜聚焦到极小的区域，制作出非常精细的细节，这样一片晶圆就能做出很多IC，整块都做完后，就可以切割然后包进微型芯片中，芯片的核心都是一小片IC。随着光刻技术发展，晶体管变小，密度变高。1960年初，IC很少能超过5个晶体管，但到了1960年中期，市场上已经开始出现超过100个晶体管的IC。摩尔定律（Moore’s Law）:1965年，戈登·摩尔看到了发展趋势，提出摩尔定律（Moore’s Law）：每两年左右，得益于材料和制造技术的发展，同样大小的空间，能塞进两倍量的晶体管。晶体管更小密度更高，要移动的电荷量就越少，能快速切换状态，耗电更少。并且电路更紧凑，意味着信号延迟更低，导致时钟速度更快。集成电路的出现，尤其是用来做微处理器，开启了计算机3.0时代。到了2010年，一个IC中有10亿个晶体管。为了达到这种密度，光刻的分辨率从大约一万纳米，发展到如今的14纳米。现代工程师设计电路时，不是手工一个个设计晶体管的，从1970年代开始，超大规模集成（Very-large-scale Integration，VLSI）软件用来自动生成芯片设计。用比如逻辑综合（Logic Synthesis）可以放一整个高级组件，比如内存缓存，软件会自动生成电路，做到尽可能高效，许多人认为这是计算机4.0时代的开始。但是摩尔定律现在迎来了终结，进一步做小，会迎来两个问题：用光掩膜把图案弄到晶圆上，因为光的波长，精度已经到达极限。所以科学家在研制波长更短的光源，投射更小的形状。当晶体管非常小，电极之间可能只距离几个原子，电子就会跳过间隙，称为量子隧道贯穿（Quantum Tunneling），由此晶体管就不能正常工作了。18、操作系统40 50年代的电脑，每次只能运行一个程序，程序员在打孔纸上写程序，然后再放入计算机中进行计算，一开始计算机速度比较慢，通常一个程序需要运行几天时间，所以放程序的时间还能忍受。但是随着计算机运算速度的告诉发展后，放程序的时间比程序运行时间还要长，我们就需要一种方式，让计算机自动运行，于是诞生了操作系统（Operation Systems，OS）。操作系统其实也是程序，但它有操作硬件的特殊权限，可以运行和管理其他程序。操作系统一般是开机第一个启动的程序，然后其他所有程序都由操作系统启动。从1950年代开始有操作系统，那时计算机开始变得更加强大， 第一个操作系统主要加强了程序加载方式，取代了手工加载程序的过程。之前只能一次给一个程序，现在可以一次多个程序，当计算机运行完一个程序后，就会自动运行下一个程序，这样就不用浪费时间找下一个程序的纸卡，这称为批处理（Batch Processing）。随着计算机的发展，计算机出现在大学和政府办公室，人们开始分享软件，但是有个问题。在哈佛1号和ENIAC那个时代，计算都是一次性的，程序员只需要给特定一台机器写代码，其中处理器、读卡器和打印机都是已知并且不会改变的。但是随着计算机越来越普遍，计算机配置并不总是相同的，比如计算机可能有相同的CPU但是不同的打印机等等，这样程序员不仅要担心程序，还要担心程序怎么和不同型号的打印机进行交互，以及计算机连着的其他设备，统称为外部设备（Peripherals）。和早期的外部设备交互是非常底层的，程序员需要了解设备的硬件细节，但是程序员又很少能拿到所有型号的设备来测试代码。所以一般是阅读手册然后尽可能编写代码。所以为了能够更好地写软件，操作系统就充当软件和硬件之间的媒介。更具体的，操作系统提供API来抽象硬件，叫设备驱动程序（Device Drivers）。这样程序员可以通过标准化机制和输入输出硬件（Input &amp; Output，I/O）进行交互，而无需关注硬件型号以及具体硬件细节。到1950年代末尾，电脑已经运行非常快了，处理器经常需要等待较慢的机械设备（比如打印机和读卡器），程序就阻塞在I/O上，而处理器什么都没有进行处理。英国曼彻斯特大学开始研发世界上第一台超级计算机Atlas，由于机器运算非常快，所以需要一种方式来尽可能利用更多的算力。他们于1962年年设计了一个程序叫Atlas Supervisor，使得操作系统不仅能进行批处理，并且通过调度（Scheduling）还能在单个CPU上同时运行几个程序。比如我们需要调用print函数让Atlas打印一个变量值，由于打印机比CPU慢很多，所以print函数需要运行比较长的时间。与其等待打印机完成打印，Atlas会将该程序进行休眠，然后运行其他等待的并且可运行的程序。最终当打印机打印完后，会报告给Atlas，则Atlas会将之前的程序标记为“可运行”状态，然后在某个时刻会安排给CPU继续运行print函数下一行代码。由此，Atlas能够在CPU上运行一个程序，同时另一个程序在打印数据（这里是让打印机自己在打印，所以无需CPU进行参与），同时另一个程序读数据（这里只需要使用读卡器，不需要CPU）。Atlas配有4台读取器、4台打印机和8个磁带驱动器。使多个程序可以同时运行，在单个CPU上共享时间。操作系统的这种能力称为多任务处理（Multitasking）。但是同时运行多个程序存在一个问题，每个程序都会占用一些内存，当切换到另一个程序后，我们不能丢失这些内存中的数据。所以我们给每个程序分配专属内存块，比如我们计算机一共有10000个内存地址，然后程序A分配到了0-999的内存地址，程序B分配到1000到1999，以此类推。如果一个程序请求更多内存，操作系统就会决定是否同意，如果同意，就要决定分配哪些内存块，这就使得程序A可能会分配到非连续的内存块，使得程序员能难进行跟踪。内存中程序分配**处理分配的内存不连续的情况--动态内存分配**$如果同意，就要决定分配哪些内存块，这就使得程序A可能会分配到非连续的内存块，使得程序员能难进行跟踪。$为了隐藏这种复杂性，操作系统会把内存地址进行虚拟化，称为虚拟内存（Virtual Memory）。程序可以假定内存总是从地址0开始，而实际的物理位置，被操作系统隐藏和抽象了。以程序B为例，它分配了内存地址1000到1999，但是对于程序B而言，它能看到的地址是0到999，操作系统会自动处理虚拟内存和物理内存之间的映射，所以程序B要地址42，实际需要物理地址1042。对于程序A，它被分配了分散的物理内存块，但是程序A并不知道，它所能看到的是连续的从0到1999的地址，当程序A读内存地址999时，会被映射到物理地址999，而当程序A读内存地址1000，则会被映射到物理地址2000。虚拟内存例子这种机制使得程序的内存大小可以灵活增减，称为**动态内存分配（Dynamic Memory Allocation）**。对程序而言，内存看起来是连续的，为操作系统同时运行多个程序提供了极大的灵活性，程序员只需要根据连续的虚拟内存地址进行编程，无需考虑程序在实际物理内存中不连续的物理内存块。同时给每个程序分配一个专用的内存块，可以使得隔离起来更方便。如果一个程序出错了，在内存中胡乱写数据，它只能在自己分配的内存块中进行操作，不会影响到其他程序的数据，这个称为内存保护（Memory Protection）。这对于防止恶意软件是否有效。Atlas是第一台提供虚拟内存和内存保护功能的操作系统。到1970年代，大学会购买电脑给学生使用，此时计算机不仅能同时运行多个程序，还能让多个用户同时访问。多个用户使用终端（Terminal）来访问计算机（这里的终端只有键盘和屏幕，然后连接到计算机），终端本身并不具有处理能力。这样计算机不仅要能处理多个程序，还要处理多个用户，为了确保其中一人不会占满计算机资源，开发了分时操作系统（Time-Sharing），指的是每个用户只能用一小部分处理器、内存等，因为计算机很快，所以即使只有一小部分资源，也足以完成很多任务。早期分时操作系统中，最有影响力的是1969年发布的Multics，它是第一个从设计时就考虑到安全性的操作系统。开发人员不希望恶意用户访问不该访问的数据，这使得操作系统的复杂度远超当时的平均水平，通常内存的一半都要用来运行操作系统，这种过度设计使得Multics未能获得商业成功。所以研究员们重新打造了一个操作系统Unix，他们想把操作系统分成两部分：操作系统的核心功能，比如内存管理，多任务和输入输出处理，这个称为内核（Kernel）。一些有用的工具，但是他们不是内核的一部分，比如程序和运行库。紧凑的内核意味着功能没有之前那么全面。当内核出现崩溃时，Multics有很多操作来进行恢复，但是Unix是没有办法恢复的，会直接调用一个panic函数，最初只能无限循环打印panic。这种简单性意味着Unix可以再更便宜的硬件上运行。1971年发布之后，就有人写了不同编程语言的编译器，甚至文字处理器，使得Unix迅速成为1970-80年代最流行的操作系统之一。到1980年代早期，个人电脑逐渐出现，这些电脑比大型主机简单很多，主机一般在大学、公司和政府，因此操作系统也要变得简单。于1981年微软发布的磁盘操作系统MS-DOS只有160kb，虽然缺少多任务和保护内存这样的功能，意味着程序经常使系统崩溃，用户可以直接重启。即使在1985年发布的早期windos，也一样缺少内存保护功能，当程序错误时，就会出现蓝屏。现代的操作系统包含了多任务、虚拟内存和内存保护机制，因此可以同时运行多个程序。19、内存&amp;存储介质一般来说，电脑内存是非永久性的（Non-Permanent），如果电脑关机，则内存中的所有数据都会丢弃，所以内存叫易失性存储器（Volatile Memory），还存在另一种存储器（Storage），存储器（storage）和内存（memory）存在一定的不同。任何写入storage的数据，就会一直保存，直到被覆盖或删除，断点也不会丢失，称为非易失性（Non-volatile）。过去是易失性的速度快，非易失性的速度慢，但随着技术发展，两者的差异越来越小。最早的存储介质是打孔纸卡以及打孔纸带，到1940年代，纸卡标准是80列x12行，能够存储960位数据。纸卡用了十几年，因为不用电而且便宜耐用，但是读取速度较慢，只能写入一次，对于存临时值，纸卡不好用，我们需要更大更灵活的存储方式。延迟线存储器：1944年时，出现了延迟线存储器（Delay Line Memory）。原理：假设你有一个装满液体（如水银）的管子，管子一端放着扬声器，另一端放着麦克风，当扬声器发出脉冲时，就会在管子内产生压力波，经过一段时间后压力波会传递到麦克风，然后麦克风将压力波转换为电信号，通过在麦克风后面接一个放大器（AMPLIFIER），然后连回扬声器，我们就能用压力波的传播延迟来存储数据。假设有压力波代表1，没有代表0，扬声器发出一系列压力波，因为传播延时的原因，这些压力波会存在管子内，当撞击到麦克风后，又会通过扬声器重新回到管子，所以就能将数据保存在管子内。在1949年的EDVAC计算机中使用了延迟线存储器，总共有128条延迟线，每条能存352位，一共能保存45000位。这使得EDVAC成为最早的存储程序计算机之一。缺点：但延迟线存储器的缺点是，每个时刻只能读一位数据，如果想访问一个特定的位，就要等待它从循环中出现，所以又被称为顺序存储器Sequential Memory）或者循环存储器（Cyclic-Access Memory）。而我们想要随机存取存储器（Random Access Memory），可以随时访问任何位置。并且增加内存密度也是一个挑战，如果要将压力波变得更紧密，就会使其混在一起，所以出现了其他类型的延迟线存储器，比如磁致伸缩延迟存储器（Magnetostrictive Delay Lines），它通过金属线的振动来代表数据。磁芯存储器：但是延迟线存储器在1950年代中期就过时了。因为出现了新技术，于是出现了，磁芯存储器（Magnetic Core Memory），它用了环状磁圈，如果给磁芯绕上电线并施加电流，就能将其磁化在一个方向，如果关掉电流，磁芯还会保持磁化，如果施加了相反方向的电流，则磁化方向会翻转。这样我们就能通过磁化方向来存储0和1，就能用来存储1位。通过将磁芯排列成网格状，有线路负责选择行和列，也有电线贯穿每个磁芯，用于读写1位。磁芯存储器如果要存的数据超过1bit，就需要把磁芯存储器排列成网格：1953年麻省理工的Whirlwind1计算机第一次大规模使用磁芯内存，磁芯排列使用32x32，用了16块板子，大约能存储16000位。不像延迟线存储器，磁芯存储器能随时访问任何一位，因此从1950年代中期成为主流，流行了20多年，将存储成本从1美元1位降低到了1美分左右。磁带：到1951年，UNIVAC电脑推出了一种新存储——磁带（Magnetic Tape）。磁带是纤薄柔软的一长条卷在轴上的磁性带子，磁带可以在磁带驱动器内前后移动，里面有一个缠绕了电线的写头（Write Head），通过电流来产生磁场，导致磁带的一小部分被磁化，电流方向决定了极性，代表1和0。同样还有一个读头（Read Head），可以非破坏地检测极性来确定数据。缺点：磁带的主要缺点是访问速度，磁带是连续的，必须倒带或快进到特定位置。50 60年代出现了类似的技术磁鼓存储器（Magnetic Drum Memory）,有一个金属圆管，盖满了磁性材料来记录数据，圆管会持续旋转，周围有数十个读写头，等圆管转到了正确的位置，读写头就会读或写数据。但到了1970年代磁鼓存储器就不再生产了，但是磁鼓导致了硬盘（Hard Disk Drives）的发展，磁盘的好处是薄，可以叠在一起来提供更多表面积来存储数据。要访问某个特定位，一个读写磁头会上下移动，找到正确的磁盘，然后磁头会滑进去，就和磁鼓存储器一样，磁盘也会高速旋转，所以读写头要等到正确的部分旋转过来，这个称为寻道时间（Seek Time）。以下是内存层次结构（Memory Hierarchy），有一小部分高速且昂贵的内存，一部分稍慢且相对便宜的内存，还有更慢且更便宜的内存，这种混合可以在成本和速度之间取得平衡。其次还有软盘（Floppy Disk），除了磁盘是软的，其他都一样。后面出现的光盘（Compact Disk，CD）以及DVD，它们不使用磁性来保存数据，而是使用表面的小坑来造成光的不同反射，通过光学传感器捕获并解码为1和0。光盘表面如今成本下降了更多的存储技术在朝**固态（Solid State）**前进，**机械硬盘（hard disk drive，HDD）**被**固态硬盘（Solid State Drive，SSD）**逐渐代替。由于SSD没有机械活动部件，里面都是集成电路。因为不存在机械活动，所以磁头不用等磁盘旋转，所以固态速度快很多，但是仍然比RAM慢很多，所以现代计算机仍然使用存储层次结构。20、文件系统上一节中介绍的数据存储。存储器可以在断电状态下长时间存上万亿位，所以非常适合用来存一整块有关系的数据（或者称为文件（Files）），比如文本文件、音乐文件、照片和视频。这一节将讨论文件是什么以及计算机是怎么管理文件的。随意排列文件的数据是没有问题的，但按格式排列会更好，这个称为文件格式（File Format）。首先看一个最简单的文件格式——文本文件（Txt File，txt）。就像其他文件一样，文本文件只是一长串二进制数，可以通过ASCII编码将其解码成对应文本。波形文件：波形文件（WAV）**波形文件（Wave File，WAV）**用于存音频数据。在正确读取数据之前，我们需要知道一些信息比如码率，以及是单声道还是立体声，这种描述数据的数据称为**元数据（Meta Data）**。元数据保存在文件开头，在实际数据之前，因此也叫**文件头（Header）**。以下是WAV文件的前44个字节，有些部分会根据数据进行变化。[^元数据]: 元数据（Metadata），又称中介数据、中继数据，为描述数据的数据（data about data），主要是描述数据属性（property）的信息，用来支持如指示存储位置、历史数据、资源查找、文件记录等功能。WAV格式的数据的元数据而音频数据就紧跟在元数据之后，也是一长串二进制数，这些数字代表每秒捕获多次的声音幅度。麦克风首先会对声音进行每秒上千次采样，每次采样可以用一个数字表示，声压越高数字越大，称为**振幅(Amplitude)**，这就是WAV文件中存储的数据。播放声音时，扬声器就会产生相同的波形。位图(Bitmap)再来谈谈位图，其后缀为bmp，用于保存图片。。计算机中，图片由多个像素(Pixel)方块组成，每个像素由三种颜色组成：红、绿、蓝，叫“加色三原色”，混合在一起能产生其他颜色。类似于WAV文件，BMP文件开头也是元数据，有图片宽度、图片高度和颜色深度等等。现在假设图片宽高均为4个像素，颜色深度为24，也就是8位(bit)红色、8位绿色和9位蓝色，则每个颜色有0-255程度，然后依次保存每个位置的三原色数值。位图的元数据![image-20200223203327886](https://longlongqin.gitee.io/image_save/images/assets/image-20200223203327886.png)位图的数据通过以上例子，可以知道，文件底层都是二进制数，为了知道文件是什么，文件格式就十分重要。计算机如何存储文件：最简单存储多个文件的方法是将文件连续存储，但是这样怎么知道文件开头和结尾在哪呢？存储器并没有文件的概念，它只是用来存储大量二进制数。所以我们需要特殊文件来记录其他文件的位置，这里称为目录文件（Directory File），它通常保存在存储器最开头，方便寻找。storage在目录文件中，存有其它所有文件的名字，格式为`文件名+点+扩展名`， 扩展名有助于得知文件类型。目录文件还保存了文件的元数据，比如创建时间、最后修改时间、文件所有者、是否能读写，最重要的是记录了文件起始位置和长度。目录文件如果要添加、删除文件或者更改文件名，必须更新整个目录文件。目录文件以及对目录文件的管理，是最基本的文件系统（File System）的例子，文件系统专门负责管理文件。刚刚的例子叫平面文件系统（Flat File System），因为所有文件都在同一层次。存在一个缺点：当我们想要对中间文件增加数据时，就会覆盖后续文件的数据。所以现代文件系统会做两个处理：将空间划分成一块块，会出现一些预留空间（Slack Space），可以方便改动。同时文件数据都对齐到了相同大小，可以方便管理。使用这种方案，目录文件就要记录文件在哪些块中。拆分文件保存在多个块中。假设todo.txt文件中加了一些数据，使得文件太大无法存在一个块中，则文件系统会分配一个没使用的块来容纳额外的数据，则目录文件对每个文件就会记录不止一个块，而是多个块。通过分配块，文件就可以轻松增加减小。如果想要删除carrie.bmp，只要在目录文件中删除对应记录就行，让这一块空间变成可用的，这样就不需要进行擦除，只需要直接删除记录就行。在那一块被新数据覆盖之前，数据还是保存在原处的。所以恢复删除数据是有可能的。当文件过大，保存在若干个块中，这个称为碎片（Fragmentation），碎片是增删改文件导致的，无法避免，但是会造成性能下降。解决方法是通过碎片整理（Defragmentation），计算机会将数据来回一定，排列成正确的顺序，就能很方便地进行读写。碎片整理前![image-20200223204733889](https://longlongqin.gitee.io/image_save/images/assets/image-20200223204733889.png)碎片整理后随着容量爆炸式增长，文件数量飞速增加，平面文件系统逐渐应付不来，所以出现了**分层文件系统（Hirerarchical File System）**，这里最大的变化就是每个文件夹中都有一个目录文件，并且目录文件不仅要指向文件，还要指向目录，还需要增加额外的元数据来区分文件和目录。优点：这种文件系统不仅可以做出无限深的文件夹，也可以让我们很轻松地移动文件，我们不需要移动任何数据块，只需要在两个目录文件中删增记录就行。分层文件文件系统使我们不必关心文件在磁盘中的具体位置。21、压缩之前介绍了文件格式，如何编码文字、声音和图片，但是它们的效率并不高，我们希望文件能小一点，这样就能保存大量文件，同时传输也会快一些，解决方法就是压缩（Compression），把数据占用的空间压得更小，为此我们需要用更少的bit来表示数据。以压缩图片为例，图片一般存成一长串像素值，为了知道一行在哪里结束，图像要有元数据，写明尺寸等属性。每个像素的颜色是三原色的组合，每个颜色用一个字节保存，数字范围是0~255（一个字节=8 bits，2^8^=256），由此一张4*4（16个像素）大小的图像，其中每个像素3个字节。则这个图片需要4*4*3=48字节。—》存成一长串像素值：图片一般存成一长串像素值![img](https://longlongqin.gitee.io/image_save/images/assets/v2-202fff7eae740ec4451258a92c96eda0_720w.jpg)前五个像素的表示## 无损压缩：一种压缩方法是减少重复信息，最简单的方法叫游程编码（Run-Length Encoding），适合经常出现相同值的文件。比如上图中有7个连续相同的黄色像素块，我们可以插入一个额外字节来表示7个连续黄色像素，然后删掉后面重复的数据。为了让计算机分辨哪些字节时长度，那些字节是颜色，格式需要保持一致，所以我们需要给所有像素前面都标上长度。在这个例子中现在只需要24个字节，并且不损失任何信息。这个方法称为无损压缩（Lossless Compression），没有丢失任何数据。游程编码另一种无损压缩方法叫做**DFTBA**，它用更紧凑的方式来表示数据块。首先我们需要一个字典，来保存代码和数据之间的对应关系。我们可以将图像看成一块一块，而不是一个个像素，为了简单，我们将2个像素当成一个块，由此我们可以得到下图的4个像素对，我们会对些像素对生成**紧凑代码（Compact Codes）**。这些块出现频率不同，我们通过霍夫曼树的方法对每一种情况进行编码，使得频率最高的块代码最短。然后我们就能通过code代替块来对图像进行压缩。这个例子中将48字节的数据压缩成了14位，但是同样也要把字典保存下来，所以还需要将字典加到数据前面，所以总共有30字节。使用霍夫曼树生成的块的编码![img](https://longlongqin.gitee.io/image_save/images/assets/v2-557e83d3f9b5d120457fb8fe3fc9df87_720w.png)压缩结果![img](https://longlongqin.gitee.io/image_save/images/assets/v2-e688a0f2a014255ed2e3c9ba38855ed5_720w.png)加上字典后的压缩结果## 有损压缩：“消除冗余”和“使用更紧凑表示方法”通常会组合起来一起使用，几乎所有无损压缩格式都用到它们。无损压缩对于文本数据十分重要，但是有其他一些数据即使丢失了一部分也不会造成很大影响，通常会丢失人们无法注意到的信息，大部分有损压缩技术（Lossy Compression）都用到了这点。以声音为例，人类听力并不是完美的，有些频率我们可以捕获，但是类似于超声波这类的频率我们根本听不见，所以录制音乐时，超声波数据是可以丢弃的，其次人类对人声十分敏感，所以应该尽可能保持原样。有损音频压缩（Lossy Audio Compressors）通过不同精度编码不同频段，这样人类听不出什么区别，也不会明显影响体验。比如电话中也用到了这个技术，这就使得在电话中的声音和现实中有所差别，用过这个技术才使得更多人同时打电话。如果网速变慢，压缩算法就会删掉更多的数据。压缩音频文件MP3和没压缩音频文件WAV或FLAC大小可以相差10倍。这种删除人类无法感知的数据的方法称为感知编码（Perceptual Coding）。这也是各种有损压缩图像格式的基础，比如JPEG，人类的视觉系统也不是完美的，我们比较善于看到尖锐的对比，比如物体的边缘，但我们无法看出颜色的细微变化。JPEG由此将图像分解成8x8大小的像素块，然后删掉大量高频空间数据。比如以下这张图片，其中一个8x8像素，由于每个像素都有细微差异，所以无损压缩技术很难对其压缩，但是人眼很难看出这些细微差别，所以我们可以删除很多像素值，这样只占10%的原始数据，并且图像看起来没有什么区别。原图；8x8原始像素块；8x8压缩像素块；压缩图像视频只是一长串连续图片，所以图片的很多方面也适用于视频，但视频也可以做一些小技巧，因为帧与帧之间有很多相同的像素，称为**时间冗余（Temporal Redundancy）**。我们不需每一帧都保存这些像素，可以只保存变化了的部分。更高级的视频压缩格式会更进一步，他们找出帧和帧之间相似的补丁，然后对他们应用简单变换，比如移动、旋转、变亮和变暗，这样就不用重复保存这些相似的补丁，直接对其进行变换就行。MPEG-4视频是常见的标准，可以比原文件小20倍到200倍。但是当压缩太严重时，没有足够空间更新补丁内的像素，就会出现以下问题。过度压缩造成的错误# 23、屏幕&2D图像显示早期的文本任务通过打印机显示，因为屏幕分辨率较低，无法显示清晰的文字，而将计算结果的文字打印在纸上，有更高的对比度和分辨率，屏幕一般只用于跟踪程序的运行情况，比如寄存器的值，可以节约纸，并且屏幕更新很快，对临时值很匹配。最早最有影响力的是阴极射线管（Cathode Ray Tube，CRT），原理是将电子发射到有磷光体涂层的屏幕上，当电子撞击涂层时，会发光几分之一秒。并且因为电子是带电粒子，所以路径可以通过磁场进行控制。CRT这样就有两种方法来绘制图形：引导电子束描绘出形状，称为矢量扫描（Vector Scanning）。因为发光只持续一小会儿，如果重复速度足够快，就能得到清晰的图像。第二种方法是按照固定路径，一行行从上到下、从左到右不断重复，只在特定的点打开电子束来绘制图形。这种方法称为光栅扫描（Raster Scanning）。用这种方法可以用很多小线段绘制图形，甚至文字。矢量扫描和光栅扫描随着屏幕的发展，我们终于可以在屏幕上显示清晰的点，称为**像素（Pixel）**。**液晶显示器（Liquid Crystal Display，LCD）**也使用光栅扫描，每秒更新多次像素里红绿蓝的颜色。LCD但是早期计算机不使用像素，因为内存中需要保存像素对应的值，使其占用太多内存，所以需要一些特殊技巧来渲染图形，知道内存发展到足够用的地步。所以早期计算机不保存大量像素值，而是直接保存符号，其中80x25个符号是最经典的，若干每个字符用8个字节表示，一共也才16000位。为此，需要特殊的硬件来从内存读取字符，转换成光栅图形，这样才能显示到屏幕上，这个称为字符生成器（Character Generator），基本算是第一代显卡。显卡内部有一小块只读存储器（Read Only Memory，ROM）存着每个字符的图形，称为点阵图案（Dot Matrix Patter）。如果显卡看到某个字符对应的二进制代码，它就会把该字符的点阵图案通过光栅扫描的方式显示在屏幕的适当位置。为了显示，字符生成器会访问内存中一块特殊区域，这块区域专为图形保留，称为屏幕缓冲区（Screen Buffer），程序想显示文字时，就直接修改保存在这个区域的值就行。字符生成器这种方案用的内存很少，但只能画字符到屏幕上，无法绘制任意形状。传统的ASCII编码的字符集太小，做不了很复杂的事情，因此对ASCII进行扩展增加更多的新字符，比如用于DOS的IBM CP437字符集，有些系统还会用额外的bit来定义字体颜色和背景颜色。IBM CP437字符集为了绘制任意形状，同时不会占用太多内存，就要使用CRT上的**矢量模式**。所有东西都是由一系列线条组成的，完全不需要有文本的概念，如果要显示文字，直接用画线的形式进行显示。我们使用一个早期适量显示系统Vectrex的命令为例首先使用RESET命令来清空屏幕， 同时将电子枪的绘图点移动到坐标(0,0)，也就是屏幕左上角，并将线的亮度设为0。调用MOVE_TO 50 50，就会将绘图点移动到坐标(50,50)。然后使用INTENSITY 100将强度设为100， 然后反复调用以上命令就会绘制出对应图形。这些命令也就占160位，比直接保存一个像素矩阵好很多。类似于之前的字符生成器把内存里的字符转换成图形一样，这些矢量指令也保存在内存中，通过矢量图形卡（Vector Graphics Card）画在屏幕上。然后通过数百个命令按序保存在屏幕缓冲区中，就能绘制出十分复杂的图形。并且因为这些矢量都在内存中，程序就可以更新这些值，让图形随时间进行变化，就出现了动画。1962年诞生的Sketchpad是一个巨大的里程碑，它是一个交互式图形界面，用于计算机辅助设计（CAD），它被认为是第一个完整的图形程序。为了与图形界面进行交互，Sketchpad使用了输入设备——光笔，就是一个有线连着电脑的触控笔，笔尖用光线传感器，可以检测到显示器的刷新，并且通过判断刷新时间，电脑也可以知道笔所在的位置。使用光笔和各种按钮，用户可以画线和其他各种简单图案。最早真正使用像素的计算机和显示器出现于1960年代末。内存中的位对应屏幕上的像素，称为位图显示（Bitmapped Display），通过对像素的控制，我们能够完全绘制任意的图形。可以将图形想象成是一个巨大像素值矩阵，之前计算机将像素数据保存在内存中一个特殊区域，称为帧缓冲区（Frame Buffer），但是后来保存在特殊的高速视频内存（Video RAM，VRAM）中，这个VRAM是在显卡上，这样访问速度更快。在一个分辨率是60x35的8位灰度屏幕上，我们可用的颜色范围是0到255。如果我们想把(10,10)处的像素设为白色，可以使用frambuffer [10] [10]=255， 如果我们想要从(30,0)到(30,35)画一条直线，可以使用123FOR y&#x3D;0 TO 35 framebuffer[30][y]&#x3D;255NEXT使用相同方法，通过修改像素值就可以绘制任意图像。并且程序可以操纵帧缓冲区内的像素数据，来实现交互式图形。28、计算机网络第一个计算机网络出现在1950-1960年代，通常在公司或研究室内部使用，方便信息交换，称为球鞋网络（Sneakernet），第二个好处在于共享物理资源，比如，与其每台电脑配一台打印机，不如大家共享一台联网的打印机。并且早期网络也会共享存储空间，因为为每台计算机都配存储器太过昂贵。计算机近距离构成的小型网络称为局域网（Local Area Network，LAN），局域网能小到是同一间房间内的两台计算机，或者大到校园内的上千台电脑。尽管开发和部署了很多不同的LAN技术，其中最著名的是“以太网（Ethernet）”，以太网的最简单形式是：一条以太网电线连接数台计算机，当一台计算机要传数据给另一台计算机时它以电信号形式，将数据传入电缆中，由于电缆是共享的，所以连接在同一个网络里的其他计算机都能看到数据，但是所有计算机都不知道这些数据是给自己的还是给别人的。为了解决这个问题，以太网需要每台计算机有唯一的媒体访问控制地址（Media Access Control Address，MAC Address），然后将MAC地址作为数据的前缀发送到网络中，所以计算机只需要监听以太网电缆，只要看到自己的MAC地址，才去接收处理数据。现在制造的每台计算机都自带唯一的MAC地址，用于以太网和无线网络。以太网但是共享载体有个很大的**弊端**：当网络流量比较小时，计算机可以等待载体清空，然后再传输他们的数据。但随着网络流量上升，两台计算机想同时写入数据的概率也会上升，这称为**冲突（Collision）**，就会使得传输的数据混乱。幸好计算机能够监听电线里的信号来检测冲突，最简单的解决方案就是看到冲突就停止传输，等待网络空闲后再试一次，问题是其他计算机也是这样打算的，其他等待的计算机可能在任何停顿间隙就闯入开始传输数据，这就导致了越来越多的冲突。以太网的解决方法是：当计算机检测到冲突后，就会在重传之前等待一小段时间（因为要举例，假设是 1 秒好了），当然 如果所有计算机用同样的等待时间 是不行的，它们会在一秒后再次冲突。所以加入一个随机时间 一台计算机可能等1.3秒，另一台计算机等待1.5秒 。要是运气好 等1.3秒的计算机会醒来发现载体是空闲的 然后开始传输 ，当1.5秒的计算机醒来后 会发现载体被占用会等待其他计算机完成 ，来相互避开。当然这个并不能完全解决问题，还需要用到另一个技巧。如果一台计算机在传输数据期间检测到冲突，就等待“1秒+随机时间”，但是如果再次发生冲突，就表明有网络拥塞，这次不等1秒，而是等2秒 ，如果再次发生冲突 等4秒 然后8秒 16秒等等，直到成功传输。因为计算机的退避，冲突次数会大幅减少，使得数据能够再次流动起来，网络就变得顺畅了。这种指数级增加等待时间的方法称为指数退避（Exponential Backoff），很多以太网和WiFi都用到这个技术。但是即使有了以上的技术，想用一根网线连接整个大学的计算机还是不可能的，为了减少冲突同时提高效率，我们需要减少同一载体中设备的数量，载体和其中的设备总称为冲突域（Collision Domain）。以之前以太网为例，一根电缆连接了6台计算机，这个称为一个冲突域。为了减少冲突，我们可以用交换机（Switch）将它拆成两个冲突域。交换机位于两个更小的网络之间，在必要时才在两个网络之间传输数据，并且交换机会记录一个列表，写着哪个MAC地址位于哪边网络，所以当MAC A想要传数据给MAC C，交换机就不会将数据传到另一边的网络，同理如果MAC E传输数据给MAC F，交换机也不会将数据传到上面的网络，这使得两边的传输能同时进行。但是如果MAC F想传数据给A，数据就会通过交换机，使得两个网络都会被短暂占用。一个以太网中加入一个交换机即使最大型的网络——**互联网（Internet）**也是这样构建起来的，本质还是多个连在一起的稍小一点的网络，使得不同网络间可以传递数据。而大型网络有一个特点，从一台主机到另一台主机通常有多条线路（**解决的主要问题**），这就引出了另一个话题——**路由（Routing）（用来选择合适路线的方法）**。大型网络，两台主机之间存在多条线路连接两台相隔遥远的计算机或网络，最简单的方法是分配一条专门的通信线路，早期的电话系统就是这样运作的，这种方法称为**电路交换（Circuit Switching）**，因为是对整个电路进行修改，来连接到正确目的地，所以这种方法不灵活且价格昂贵，并且总有闲置的路线。但是好处是你可以最大限度随意使用，无需共享。因此军队、银行和其他一些机构依然会购买专门线路来连接数据中心。电路交换传输数据的另一种方法是**报文交换（Message Switching）**，就像邮政系统一样。不像之前A和B之间有一条专有线路，这里消息会经过好几个站点，就类似于邮寄信封，信封会通过一个个中转站最终到达收件人手中，每个站点都知道下一站要发往哪里，因为站点都有自己一个**表格**，用来记录到达各个目的地，信件要如何传递。报文交换的**好处**是你可以用不同的路由，使得通信更可靠。比如如果其中一个城市由于降雪无法接收邮件时，就能换到另一个城市继续传递数据。这里，城市就相当于网络中的路由器一样。报文交换> 交换机是连接若干个主机的机器，用来解决冲突域问题。 > > 路由器是连接主机、路由器、交换机的机器，用来构建数据传输的线路。信息沿着路由跳转的次数称为跳数（Hop Count），通过记录跳数，可以分辨出路由问题。比如当路由A认为到达目的地最快的下一个路由是B，就将信息传递给路由B，而路由B则认为到达目的地最快的下一个路由是A，又将信息传递回给了路由A，这就使得信息在路由A和B之间踢皮球，但是这种错误可以通过在信息中实时记录的跳数来解决，如果某条信息的跳数很大，就说明路由有出问题，这个称为跳数限制（Hop Limit）。而报文交换的缺点之一就是当报文较大时，会堵塞网络，因为这里要求将整个报文从一个路由传到下一个路由后，才能继续传递其他报文，当传输大报文时，其他报文要么等待它传递完，要么选择另一条效率较低的路线。解决方法就是将大报文分成很多小块，称为数据包（Packet）。和报文交换一样，每个数据包都有网络中的目的地址，因此路由器知道要发送到哪里，这个地址的具体格式由互联网协议（Internet Protocol，IP）定义。每个联网的计算机都需要一个IP地址（IP Address），例如172.217.7.238。MAC地址用来标识每条计算机，而IP地址是对数据包而言的。路由器会平衡与其他路由器之间的负载，来确保传输可以快速可靠，称为拥塞控制 （Congestion Control）。有时候一个报文的多个数据包会经过不同线路，使得到达顺序也可能不相同，这对一些软件来说是存在问题的。幸运的是，在IP之上还有其他协议，比如TCP/IP可以解决乱序问题。将数据拆分成多个小数据包，然后通过灵活的路由传递，非常高效且容错率高，这种方法称为分组交换（Packet Switching）。它的好处是可以去中心化，就没有单点失败问题。如今全球的路由器协同工作，找出最高效的线路，用各种标准协议传输数据，比如因特网控制信息协议（Internet Control Message Protocol，ICMP）和边界网关协议（Border Gateway Protocol，BGP）。网络是一堆管子组成的吗？ 额 算是吧。29、互联网任意计算机都和一个巨大的分布式网络连接在一起，称为互联网（Internet）。当你在家中通过计算机观看网上视频时，你的计算机首先需要连接到局域网LAN，这个局域网是由家里WiFi路由器连接的所有设备组成的。然后家里的局域网再通过路由器连接到广域网（Wide Area Network，WAN），广域网的路由器一般属于你的互联网服务提供商（Internet Service Provider，ISP）。在广域网里，首先会有一个区域性路由器，比如覆盖你所在街区的一个路由器，然后该路由器会连接到一个更大的广域网中，比如覆盖你所在的城市，可能再跳跃几次，最终会到达互联网主干，一般由一群超大型、带宽超高的路由器组成。即首先会连接到你家里的WiFi路由器构建的局域网，然后该路由器再连接到ISP提供的广域网中，该广域网是由很多层层递进的路由器构成的。比如要从YouTube中获得视频，数据包首先会到达互联网主干，沿着主干到达对应保存该视频文件的YouTube服务器，可能这里会跳4次到达互联网主干，然后跳两次穿过互联网主干，最终再跳4次到达YouTube服务器，所以总共会跳跃10次。我们可以通过traceroute来看跳跃了几次：1234567891011121314Windows上的Traceroute1.按开始按钮2.输入“ CMD”，然后按“ Enter”3.在命令提示符下，键入“ tracert dftba.com”在Mac上的Traceroute1.点击“转到”下拉菜单2.点击“实用程序”3.打开终端4.键入“ traceroute dftba.com”Linux上的Traceroute1.通过键入CTRL + Alt + T打开终端2.输入：“ traceroute dftba.com”通过traceroute查看到dftba.com中转的次数经历了11次中转。但是数据包到底是怎么传递过去的呢？如果传输时数据包丢失了，会发生什么？当我们在浏览器中输入网址时，浏览器怎么知道服务器的地址是什么呢？就像上节介绍的，互联网是一个巨大分布式网络，如果要发送的数据较大，分组传输就会将数据拆成一个个较小的数据包进行传输。其中数据包要想在互联网上进行传输，就要符合互联网协议（Internet Protocol，IP）。类似于邮寄手写信一般，每封信都需要一个地址，并且地址必须是唯一的，并且信的大小和重量也是有限制的，否则信件就无法送达。IP数据包也是如此，因为IP是一个非常底层的协议，数据包的头部只包含目标地址（IP地址），意味着当数据包到达对方电脑时，计算机不知道要把数据包交给哪个程序（比如QQ或微信），因此需要在IP之上，开发更高级的协议。数据包的结构最简单常见的协议称为用户数据报协议（User Datagram Protocol，UDP）。UDP也有头部，位于data payload里面，在data之前。UDP头部里面包含了很多有用的信息，其中之一就是**端口号（Port Number）**，每个想访问网络的程序都要向操作系统申请一个端口号。所以当数据包到达时，接收方的操作系统会读取UDP头部里的端口号，来确定该数据包是要交给哪个软件的。UDP比如 Skype 会申请端口 3478，当一个数据包到达时接收方的操作系统会读 UDP 头部，读里面的端口号如果看到端口号是 3478，就把数据包交给 Skype。端口号![image-20200229170954885](assets/image-20200229170954885.png)IP协议通过IP地址把数据包送到正确的计算机内；UDP通过数据包里的端口号送到正确的程序。同时UDP的头部中还有校验和（Checksum），通过对数据求和来检查数据是否正确。假设UDP数据包里原始数据是89 111 33 32 58 41， 最简单的计算校验和的方式就是，在发送数据包之前，计算机会把所有数据加在一起，计算出校验和364。在UDP中，校验和是以16位形式存储的，如果计算出来的和超过16位能表示的最大值，则高位数会被丢弃，只保留低位。当接收方计算机接收到这个数据包时，也会重复以上过程，如果计算出来的校验和和UDP中保存的校验和相同，代表数据是正常的，否则数据是出错的。但是，UDP不提供数据修复或数据重发机制，当接收方知道数据损坏后，一般只是丢弃这个数据包。并且当发送方使用UDP协议发送数据包时，是无法得知数据包是否到达目的地的。有些程序并不在意以上问题，因为UDP十分简单且快速。比如视频通常使用UDP协议，当数据包丢失时，也就造成视频卡顿。但是有些数据不能接受数据包丢失的问题，比如发送电子邮件时，所有数据必须到达，所以就需要传输控制协议（Transmission Control Protocol，TCP）。和UDP一样，它的头部也保存在数据之前，人们通常将IP协议和TCP协议统称为TCP/IP协议。TCP的头部中也包含端口号和校验和，并且TCP协议还提供更高级的功能：TCP1. TCP的数据包是有序号的，使得接收方可以通过这个序号将数据包排成正确顺序，即使到达时间不同。 2. TCP要求接收方的电脑收到数据包并校验和检查无误后，需要给发送方发送一个**确认码（Acknowledgement，ACK）**，代表数据包已经正确接收。当发送方接收到确认码后，就知道上一个数据包成功抵达了，发送方就会发送下一个数据包，如果这次发送方过了一段时间没有接收到确认码，则会重新发送一次。即使这里只是由于确认码延迟了，使得接收方那里有重复的数据包，但是通过序列号，可以直接删除重复的数据包。并且数据包并不会一个个数据包进行传输，而是同时发送多个数据包，同时接收多个确认码(ACK)，这将大大提高效率，不用浪费时间等待确认码。并且通过确认码的成功率和来回时间，我们可以推测网络的拥塞程度，TCP通过这个信息，来调整同时发包数量来解决拥塞问题。简而言之，TCP可以处理乱序和丢包问题，并且可以根据拥塞情况自动调整传输率。但是由于确认码数据包的存在，使得TCP需要传输的数据包数量翻了一倍，并且并没有传输更多信息，这对时间要求很高的程序代价太高，所以这类程序就会使用UDP协议（比如射击类游戏）。当计算机访问一个网站时，需要两个东西：IP地址（目标网站的地址）和 端口号（对应于你使用的计算机浏览器）（例如：例如 172.217.7.238 的 80 端口 这是谷歌的 IP 地址和端口号）。但是通过IP地址访问网站十分不方便，所以互联网提供一个特殊服务，来将域名（Domain Name）和IP地址一一对应，称为域名系统（Dimain Name System，DNS），一般DNS服务器都是由ISP提供的。当你在浏览器中输入网站域名时，浏览器就会去访问DNS服务器，DNS就会去查表，如果域名存在，则会返回浏览器对应IP地址，然后浏览器就会给这个IP地址发送TCP请求。因为当前域名特别多，所以DNS不会将其保存成列表形式，而是将其保存成树状结构。最顶层是顶级域名（Top Level Domain，TLD），比如.com和.gov；下一层是二级域名（Second Level Domain）， 比如google.com和dftba.com；再下一层是子域名（Sub-domain），比如images.google.com等等。由于这个树结构特别大，因此这些数据分布在很多DNS服务器上，不同服务器负责树的不同部分。域结构总结上两节（28、29）的内容，其实计算机网络分成很多层次，接下来从最底层到最高层：物理层（Physical Layer），比如线路中的电信号，以及无线网络中的无线信号。数据链路层（Data Link Layer）负责操控物理层，其中包含MAC地址、冲突检测、指数回退以及其他一些底层协议。网络层（Network Layer）负责各种报文交换和路由技术。传输层（Transport Layer）负责在计算机之间进行点到点的传输，还会检测和修复错误，比如UDP和TCP协议。会话层（Session Layer）会使用TCP和UDP来创建连接，传递信息，然后关掉连接。以上是开放式系统互联通信参考模型（Open System Interconnection model，OSI）下的5层，这个框架将网络通信划分成了很多层，每一层处理各自的问题。这种抽象可以使得分工改进多个层，而无需考虑整体复杂性。并且OSI还有额外两层：表示层（Presentation Layer）和应用层（Application Layer），在下一节中进行介绍。30、万维网前两节介绍的东西共同组成了互联网，这一节将向上抽象一层，来讨论万维网（World Wide Web）。万维网和互联网的概念完全不同，万维网是运行于互联网之上的，还有其他比如Skype、Instagram等也是运行在互联网之上的。互联网是用来传输数据的管道，各种程序都会使用到，其中传输最多数据的程序就是万维网，我们可以使用特殊的程序——浏览器（Web Browser）来访问万维网。万维网的最基本单位是单个页面，里面包含内容，也有访问其他页面的链接，这些链接称为超链接（Hyperlink）。这些超链接形成巨大的互联网络，这也是万维网名字的由来。并且由于文字超链接的强大，它有一个特殊的名字——超文本（Hypertext）。如今超文本最常指向的是另一个页面，这些页面会被获取并由浏览器进行渲染。为了使网页能够互相连接，每个网页需要一个唯一的地址，这个地址称为统一资源定位器（Uniform Resource Locator，URL），比如thecrashcourse.com/courses就是一个页面URL。当你访问thecrashcourse.com网址时，计算机首先会进行DNS查询，这里输入一个域名，然后DNS就会返回给浏览器对应的计算机IP地址。然后浏览器就会打开一个TCP连接到这个IP地址对应的计算机上，而这个计算机运行着一个特殊的软件——网络服务器（Web Server），网络服务器的标准端口是80。此时，你的计算机就连接到了thecrashcourse.com对应的服务器了，下一步是向服务器请求courses 页面，这里就会用到超文本传输协议（Hypertext Transfer Protocol，HTTP）。HTTP的第一个标准是1991年创建的HTTP 0.9，只有一个指令GET 。因为这里我们想要获取courses页面， 我们可以直接向服务器发送指令GET/courses， 该指令以ASCII编码发送到服务器，服务器会返回该网址对应的页面，然后浏览器就会将其渲染到屏幕上。如果用户点击了另一个链接，计算机就会重新发送一个GET请求。在之后的版本中，HTTP添加了新的状态码，会将其放在请求页面的前面，比如状态码200表示网页被正确找到了，状态码400-499代表客户端出错。因为超文本的存储和发送都是以普通文本形式进行的，编码可能是ASCII或者UTF-8，这样就无法表明什么是链接，什么只是普通的文本了，所以必须开发一种标记方法，因此出现了超文本标记语言（Hypertext Markup Language，HTML），第一代HTML创建于1990年的0.8版本，有18种指令。制作一个简单的网页综上，网络浏览器可以和网络服务器沟通，不仅获取网页和媒体，并且还负责显示。随着后期万维网日益繁荣，人们越来越需要搜索。起初人们会维护一个目录，来链接到其他网站，但是随着网络越来越大，人工编辑目录变得很不方便，所以开发了搜索引擎。最早的搜索引擎是JumpStation，它有3个部分：通过爬虫来将新链接添加进自己的列表中。不断扩张的索引，用来记录访问过的网页上出现了哪些词。查询索引的搜索算法，比如输入了某个关键字，则包含这个关键字的网页就会显示出来。早期的搜索引擎的排名方式直接取决于搜索词在页面上的出现次数，但是有的网页会通过在页面中重复该关键字来提高排名。Google成名的很大原因就是提出了一种算法来解决这个问题，与其信任页面上的内容，搜索引擎会看其他网页有没有连接到这个网页。最后提一个概念——网络中立性（Network Neutrality），它指的是要对所有数据包都平等对待，速度和优先级都应该一样。31、计算机安全计算机安全的范围和计算能力的发展速度一样快，我们可以把计算机安全，看成是保护系统和数据的保密性、完整性和可用性。保密性（Secrecy）：只有有权限的人才能读取计算机系统和数据，比如黑客泄露别人的信用卡信息，就是攻击保密性。完整性（Integrity）：只有有权限的人才能使用和修改系统和数据，比如黑客假冒你发送邮件，就是攻击完整性。可用性（Availability）：有权限的人应该随时可以访问系统和数据，拒绝服务攻击（DDOS）就是黑客发送大量的假请求到服务器上，使得网站很慢或者直接挂掉，这就是攻击可用性。为了实现这三个目标，安全专家会从抽象层面想想敌人可能是谁，这个称为威胁模型分析（Threat Model）。模型会对攻击者有个大致的描述：能力如何、目标是什么、可能使用什么手段。攻击手段又称为攻击矢量（Attack Vector）。威胁模型分析能够让你为特定情境做好准备，不被可能的攻击手段所淹没。换句话说，要怎么保护，具体看要对抗谁。通常威胁模型分析中，会以能力水平进行区分。在给定的威胁模型下，安全架构师要提供解决方案，来保持系统安全。有很多保护计算机系统、网络和数据的方法。很多安全问题可以总结成两个问题：你是谁？你能访问什么？权限应该给适合的人而拒绝错误的人，所以为了区分谁是谁，我们使用身份认证（Authentication）来让计算机得知使用者是谁。通常身份认证有三种，各有利弊：你知道什么：这个是基于某种只有用户和计算机知道的秘密，比如用户名和密码。这是如今使用最广最容易实现的方法。但是如果黑客知道了你的密码就惨了，或者可以通过暴力攻击试了密码的所有可能来获取你的密码，有些系统会在你尝试若干次错误后阻止你继续尝试。即使增长密码也很容易破解，所以现在很多网站都要求大小写字母加特殊字符，来增加可能的密码。你有什么：这是基于用户特定的物体，比如钥匙和锁。这种方法可以避免被人猜中密码的问题，而且通常需要人在现场，所以远程攻击就更加困难了。你是什么：这是基于你，通过你自己的特征展示给计算机来进行验证，比如指纹识别器和红膜扫描仪，这些方法特别的安全，但是最好的识别技术十分昂贵。“你知道什么”和“你有什么”是确定性的，但是来自传感器的数据每次都不相同，所以“你是什么”是概率性的，系统可能认不出你，或者将其他人认成了你。并且这种方法另一个问题就是无法重设，你无法修改自己的指纹或者虹膜。每种方法都有优缺点，一般建议使用两种或两种以上的认证方式。当系统知道了你是谁，接下来就需要知道你能访问什么，这个称为访问控制（Access Control），因此需要一个规范，来说明谁能访问什么、修改什么和使用什么。这个可以通过权限（Permission）或访问控制列表（Access Control List，ACL）来实现，其中描述了用户对每个文件、文件夹和程序的访问权限。读权限：允许用户查看文件内容。写权限：允许用户修改文件内容。执行权限：运行用户运行文件。有些阻止需要不同层次的权限，则ACL的正确配置就十分重要。假设我们有三个访问级别：公开、机密和顶级机密。有个经典模型称为Bell-LaPadula模型，其中包含两条规则：用户不能read up，即不能读等级更高的信息。用户不能write down，即用户不能写更低权限的信息，这样能避免高级别的信息不会泄漏到低级别的文件中。通过身份认证和权限控制，可以让计算机知道你是谁和你能访问什么，但是必须先保证做这些事的软硬件必须是可信的。但是仍然无法保证程序或计算机系统的安全，因为安全软件在理论上可能是安全的，但是实现时可能会不小心留下漏洞。但是我们有办法减少漏洞出现的可能性，比如一发现漏洞就马上修补。大部分漏洞都是具体实现时出错了，所以为了减少执行错误，就要减少执行。系统级安全的圣杯之一是安全内核或可信计算机基础：一组尽可能少的操作系统软件，这个安全性是接近可验证的。构建安全内核的挑战在于，要决定内核应该有什么（代码越少越好）。当最小化代码数量后，要是能保证代码是安全的，那就很好了。现在最好的验证代码安全性的手段是独立安全监察和质量验证（Independent Verification and Validation），让一群安全行业内的软件开发者来审计代码，这也是为什么安全型代码几乎都是开源的。但是即使这样，还是有可能被黑客攻破，因此程序开发者需要控制损失的最大程度，这个称为隔离（Ioslation）。要实现隔离，可以“沙盒”（sandbox）程序，操作系统通过给每个程序独立的内存块，使得别的程序是无法触及的，这样就能把程序放到沙盒中，即使沙盒被破坏了，也不会影响别的程序执行。并且一台计算机可以运行多个虚拟机（Virtual Machine），使得每个虚拟机都在自己的沙盒中。32、黑客&amp;攻击黑客入侵最常见的方式不是通过技术，而是欺骗别人，这个称为社会工程学（Social Engineering），通过欺骗别人来让人泄露秘密，或让人配置电脑系统来变得易于攻击。最常见的攻击是网络钓鱼（Phishing），其次还有假托（Pretexting），攻击者给某个公司打电话，假装是IT部门的人，攻击者的第一通电话一般会叫人转接，这样另一个接的时候，电话看起来就像内部的，然后让别人把电脑配置得易于入侵，或者让他们泄露机密信息，比如密码或网络配置。邮件里带木马（trojan horse）也是常见手段，木马通常会伪装成无害的东西，比如照片或发票，但实际上是恶意软件，有的会偷数据，有的会加密文件。如果攻击者无法用木马或电话欺骗，攻击者只能被迫使用其他手段，方法之一就是暴力破解，尝试所有可能的密码，直到进入系统，大多数现代系统会加长等待时间来抵御这种攻击，每次失败就加长等待时间，甚至超过一定次数后，完全封锁。现在出现了一种攻破方法称为NAND镜像，如果能物理接触到电脑，可以往内存上接几根线，复制整个内存，然后暴力尝试密码，直到设备让你等待。这时只要把复制的内容覆盖掉内存，本质上重置了内存，就不用等待，可以继续尝试密码。如果无法物理接触到设备，就需要远程攻击，比如通过互联网，这一般需要攻击者利用系统漏洞，来获得某些能力或访问权限，称为漏洞利用（Exploit）。一种常见的漏洞利用叫缓冲区溢出（Buffer Overflow），这里的缓冲区是指预留的一块内存空间，比如我们在系统登录界面输入用户名和密码，而系统是用缓冲区来存储输入值的，假设缓冲区大小为10，并且缓冲区前后肯定还有其他数据，当用户输入用户名和密码时，这些值就会被复制到缓冲区中来进行验证，而该方法会溢出缓冲区，比如输入超过10个字符的密码，会覆盖掉相邻的数据，有时会让程序或系统崩溃，因为重要值被垃圾数据覆盖掉了。这里只是让系统崩溃，但是攻击者可以输入有意义的新值到程序的内存中，比如把is_admin标志位的值改为true，有了任意修改内存的能力，黑客就可以绕过登录这类东西，甚至使用那个程序劫持整个系统。有许多方法阻止缓冲区溢出，最简单的方法就是复制到内存之前先检查长度，称为边界检查（Bounds checking），许多现代编程语言都自带边界检查，程序也会随机存放变量在内存中的位置，这样黑客就不知道应该覆盖内存的哪部分，使得更容易让程序崩溃，而不是获得访问权限。程序也可以在缓冲区后，预留一些不用的空间，然后跟踪里面的值，看是否发生变化，来判断是否有攻击，这些不用的内存空间称为金丝雀（Canaries）。另一种经典手段是代码注入（Code Injection），最常用于攻击用数据库的网站。假设网页上有登录提示，当用户点击“登录”，输入文本就会发送服务器，服务器就会运行代码，检查用户名是否存在，如果存在就看密码是否匹配。为此服务器会执行一段sql查询代码，比如1SELECT password FROM users WHERE username='___';这里语句就是要从users表中查找username为___的密码password。 这里的___就是用户输入的用户名。由此攻击者就能把sql命令输入到用户名中，比如whatever&#39;;DROP TABLE users;&#39;，这时上面的查询语句就会变成1SELECT password FROM users WHERE username='whatever';DROP TABLE users;';如果服务器存在用户名wharever，数据库就会返回密码， 当然我们无法得知密码是什么，所以服务器会拒绝我们；如果不存在用户名wharever，服务器会返回空密码或者直接错误，服务器也会拒绝我们。 但是我们关心的是后面的代码DROP TABLE users;这个是我们注入的命令，这个命令是删掉users这张表。如今几乎所有服务器都会防御这种手段。程序员需要认识到从外界输入的信息都是危险的，必须要好好检查，很多用户名和密码表单，不会让你直接输入特殊符号，比如分号或括号，来作为第一道防御。好的服务器也会清理输入，比如修改或删除特殊字符，然后才放到数据库查询语句中。当软件制造者不知道的新漏洞被发现时，称为0day漏洞（Zero Day Vulnerability），黑客就会抢在白帽程序员做出补丁之前尽可能利用漏洞。如果有足够多的电脑有漏洞，让恶意程序可以自动地在电脑之间互相传播，称为蠕虫（Worm）。如果黑客拿下大量电脑，这些电脑可以组成僵尸网络（Botnet），可以用于很多目的，比如发大量垃圾邮件等，用别人电脑的计算能力来挖比特币，或发起DDOS来攻击服务器。DDOS就是僵尸网络里的所有电脑发一大堆垃圾信息到服务器上，造成服务器的阻塞。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"《计算机科学速成课》","slug":"《计算机科学速成课》","permalink":"https://longlongqin.github.io/tags/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE%E3%80%8B/"}]},{"title":"LearnCpp chapter4","slug":"C&C++/LearnCpp-chapter4","date":"2020-03-31T05:59:58.000Z","updated":"2020-04-19T14:38:29.546Z","comments":true,"path":"archives/c1a4eb67.html","link":"","permalink":"https://longlongqin.github.io/archives/c1a4eb67.html","excerpt":"LearnCpp chapter4https://www.learncpp.com","text":"LearnCpp chapter4https://www.learncpp.com4.1 基本的数据类型内存最小的单位是一个二进制数(binary digit)，即位(bit)。它可以存储一个0或者1。就像传统的电灯开关一样——灯开着(1)，灯关着(0)由连续的单元组成的内存，叫内存地址(memory addresses)，简称地址(addresses)现代计算机中，“位”是没有它自己的内存地址的。而是用一个“字节(byte)”来表示一个内存地址。因为内存地址是比较有限的，而且需要逐“位”访问数据的情况很少。字节是作为一个单位来操作的一组”位(bit)”。现代标准规定：一个字节由8个连续的位组成。下面的图片显示了一些连续的内存地址，以及相应的数据字节:数据类型(Data types)，简称“类型(type)”我们使用数据类型来告诉编译器如何以某种有意义的方式解释内存的内容。如：当我们声明一个变量的类型为 整型(integer)时，就相当于告诉内存“这个变量使用的内存段将被解释为一个整数值”给对象(object)一个值(value)时，编译器和CPU就负责将您的值 编码(encode)为该数据类型的适当的位序列，并存储在内存中。【记住：内存只存储位(bits)】如：给一个整型对象赋一个值,65。这个值就被转换为bits：0100 0001，并被存储在分配给对象的内存中。当这个对象被求值，产生一个值时，这个 位序列(sequence of bits) 被重新构造成原来的值。意思就是：0100 0001被转换回 值65.幸运的是，这些转换工作都是由 编译器 和 CPU 来完成的。基本数据类型(fundamental data types)，但通常被非正式地称为基本类型(basic types)、基本类型(primitive types)或内置类型(built-in types)。下面是一些基本数据类型：1、注意：integer vs integral：integral即比integer范围更广integer：表示整数，即正整数、负整数、0；integral：包含了 integer、boolean(布尔型)、字符类型。他们两个名字比较相近，是因为：integral类型在内存中存储形式是和integer一样。2、 _t后缀这个后缀，表示“类型”的意思。4.2 Voidvoid是最简单的类型，void，即“没有类型”变量不能定义为void类型：1void value; // won't work, variables can't be defined with a void typevoid用途：Functions that do not return a value（函数不返回值）：12345void writeValue(int x) // void here means no return value&#123; std::cout &lt;&lt; \"The value of x is: \" &lt;&lt; x &lt;&lt; '\\n'; // no return statement, because this function doesn't return a value&#125;Functions that do not take parameters(函数中不带参数)1234567891011121314int getValue(void) // void here means no parameters&#123; int x; std::cin &gt;&gt; x; return x;&#125;//或者这种形式【在C++中，推荐写这种形式】int getValue() // empty function parameters is an implicit void&#123; int x; std::cin &gt;&gt; x; return x;&#125;4.3 对象大小&amp;sizeof操作符对象的大小：对象的大小取决于它的数据类型通常通过变量名访问内存，而不是直接通过内存地址。1个bit(位)可以容纳2个可能的值，0或1；…….即，具有n位(bits)的对象，可以容纳2^n 个可能的值。因此，对象的大小限制了它可以存储的唯一值的个数。每次定义一个对象时，只要该对象存在，就会使用一小部分空闲内存。基本数据类型的大小：给定数据类型的大小取决于编译器 和/或 计算机体系结构!C++只保证每个基本数据类型的大小都是最小的：然而，这些类型的大小在不同的计算机上可能会不一样。比如，有些机器上的int大小为4 bytes操作符“sizeof”为了能够在计算机上直到类型的大小，C++提供了“sizeof”操作符来确认类型的大小。sizeof：是一个一元操作符，它接受 类型 或 变量，然后返回它的大小(bytes)123456789101112131415161718192021222324#include &lt;iostream&gt;int main()&#123; std::cout &lt;&lt; \"bool:\\t\\t\" &lt;&lt; sizeof(bool) &lt;&lt; \"bytes\\n\"; std::cout &lt;&lt; \"char:\\t\\t\" &lt;&lt; sizeof(char) &lt;&lt; \"bytes\\n\"; std::cout &lt;&lt; \"wchar_t:\\t\" &lt;&lt; sizeof(wchar_t) &lt;&lt; \"bytes\\n\"; std::cout &lt;&lt; \"char16_t:\\t\" &lt;&lt; sizeof(char16_t) &lt;&lt; \" bytes\\n\"; // C++11 only std::cout &lt;&lt; \"char32_t:\\t\" &lt;&lt; sizeof(char32_t) &lt;&lt; \" bytes\\n\"; // C++11 only std::cout &lt;&lt; \"short:\\t\\t\" &lt;&lt; sizeof(short) &lt;&lt; \" bytes\\n\"; std::cout &lt;&lt; \"int:\\t\\t\" &lt;&lt; sizeof(int) &lt;&lt; \" bytes\\n\"; std::cout &lt;&lt; \"long:\\t\\t\" &lt;&lt; sizeof(long) &lt;&lt; \" bytes\\n\"; std::cout &lt;&lt; \"long long:\\t\" &lt;&lt; sizeof(long long) &lt;&lt; \" bytes\\n\"; // C++11 only std::cout &lt;&lt; \"float:\\t\\t\" &lt;&lt; sizeof(float) &lt;&lt; \" bytes\\n\"; std::cout &lt;&lt; \"double:\\t\\t\" &lt;&lt; sizeof(double) &lt;&lt; \" bytes\\n\"; std::cout &lt;&lt; \"long double:\\t\" &lt;&lt; sizeof(long double) &lt;&lt; \" bytes\\n\"; //避免在visual studio 中运行时 闪过 std::cin.clear(); std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n'); std::cin.get(); return 0;&#125;运行结果：运行结果会因为不同类型的机器or编译器，而出现差异。4.4 有符号整型C++中有四种整型的类型：Signed integers(有符号整型)如：+1、-1、0这种都属于 有符号整型。定义有符号整型：123456789101112131415161718//【推荐】short s;int i;long i;long long i;//除了int，其它类型也可以这样写：short int s;long int i;long liong i;//这种【不推荐】，使用“int”后缀不利于观看//也可以使用 signed前缀signed shrt s;signed int i;signed long i;signed long long i;//【不推荐】，因为signed冗余，不利于辨认有符号整型的范围数据类型可以容纳的一组特定值，叫做：range(范围)整型变量的“范围”的决定因素：该类型本身的大小；该类型是否是 有符号 的。比如，大小为1字节的有符号整型，它的范围是：-128~127(包含范围的两端)，即它可以存储2^8=256 个可能的整数。这是一个包含不同大小有符号整数范围的表:小结，一个有 n-bits的 有符号变量，它可存储值的范围是：-(2^n-1^) ~ (2^n-1^ -1)整数溢出，简称：溢出如果我们把值280,存储在 1个字节的有符号整型 中，他就会发生 溢出现象。此时，数据丢失是因为对象没有足够的内存来存储所有东西。4.5 无符号整型不推荐使用无符号整型：unsigned integer。不能存储“负数”，可以存储：0 和 正整数定义无符号整型变量要定义无符号整数，我们使用unsigned关键字。按照惯例，这是放在前面的类型:1234unsigned short us;unsigned int ui;unsigned long ul;unsigned long long ull;无符号整型范围一个有 n-bits 的无符号整型变量，它可存储的范围是：0 ~ (2^n^)-1当不需要负数时，无符号整数非常适合于网络和内存很少的系统，因为无符号整数可以存储更多的正数而不占用额外的内存。无符号整数的溢出：Unsigned integer overflow无符号整数不会溢出。如果一个值超过范围，那么它会除以一个比这个范围大的数，然后将余数存起来。正数溢出如，在 1byte的范围中，存储数据。280在 范围为 1个字节 的整型中存储，因280&gt;255。所以，它会除以256(比 1个字节的范围的最大值大1，即比255大1的数，256)。280/256=24，所以存储的是24.存储256。256&gt;255。则进行 256/256 = 0，即相当于存储 0存储257。257&gt;255。则进行 257/256 = 1，即相当于存储 1看一个程序：123456789101112131415#include &lt;iostream&gt; int main()&#123; unsigned short x&#123; 65535 &#125;; // 最大的16位无符号值 std::cout &lt;&lt; \"x was: \" &lt;&lt; x &lt;&lt; '\\n'; x = 65536; // 65536 is out of our range, so we get wrap-around std::cout &lt;&lt; \"x is now: \" &lt;&lt; x &lt;&lt; '\\n'; x = 65537; // 65537 is out of our range, so we get wrap-around std::cout &lt;&lt; \"x is now: \" &lt;&lt; x &lt;&lt; '\\n'; return 0;&#125;输出：负数溢出虽然，无符号整数的范围是0~255(假如在 1byte的范围).但是我们不小心在无符号整型中输入了 负数，应该怎么办呢？比如，当输入 -1 时。-1不在 0~255这个范围中。此时就循环到这个范围的顶部（最大值处），即 255。所以，在 1 byte 的范围的无符号整数中，输入 -1 ，存储的是 255。输入-2，存储的是254。（从最顶部往回循环）4.6 固定宽度的整数和size_t之前讲了整型变量的最低size，其实他们可以按照不同的系统变得更大。为什么不固定整型变量的大小？因为在C语言中，为了提高性能，C故意保持整数的大小是开放的，这样编译器实现者就可以为 int 选择一个在目标计算机架构上表现最好的大小。固定宽度的整型为了实现跨平台，C99定义了一系列的固定宽度的整型(在头文件stdint.h中)，使得在任何平台中的大小都一致。在C++11中的头文件cstdint中，也包含了上述的固定宽度整型。他们在命名空间std中定义的。如;123456789#include &lt;iostream&gt;#include &lt;cstdint&gt;int main()&#123; std::int16_t i(5); std::cout &lt;&lt; i; return 0;&#125;应该避免上述固定宽度的整数，因为它们可能不是在所有目标体系结构上定义的。fast &amp; least 整型：快类型 &amp; 小类型为了帮助解决上述缺点，c++ 11还定义了两个可选的整数集。*fast type *无符号格式为： std::int_fast#_t ；有符号格式：std::uint_fast#_t它提供一个整型，它提供一个在你的机器上表现得性能最好的宽度，但是它的宽度最小是“# bits”（# = 8，16，32，or 64 bit）如：std::int_fast32_t将会给你一个最小为 32bits 的无符号整型least type无符号格式为： std::int_least#_t ；有符号格式：std::uint_least#_t它提供一个整型类型，它提供一个最接近于“# bits”的宽度，但是它的宽度最小是“# bits”（# = 8，16，32，or 64 bit）小结：比较：int#\\_t、int_fast#_t、int_least#_t的差异：int#_t的bits(位数)是固定的，即有“# bits”；int_fast#_t 和 int_least#_t的bits(位数)最少有““# bits”；example：int16_t：是固定的16位的整型；int_fast16_t：可能转变成了64位的整型。（因为在你的机器上，64位整型最快了）int_least16_t：可能转变成了32位的整型。（假设因为你的系统中没有16位的整型，而32位此时是最接近16位 的整型了）注意：std::int8_t和std::uint8_t是char类型，而不是integer在C++中，很多编译器对std::int8_t和std::uint8_t（以及相应的fast 和 least 整型）的定义和对待方式 是与 signed char(有符号字符类型) 的方式相同。但是，在某些系统中，它确实是整型的，而不是char类型。12345678910111213#include &lt;cstdint&gt;#include &lt;iostream&gt; int main()&#123; std::int8_t myint = 65; std::cout &lt;&lt; myint; return 0;&#125;/******************************/运行结果是： A所以，我们要避免使用这几个整型类型。最佳使用整型当整型的大小不做要求时，使用int；如果需要一个保证为特定大小的变量，并且希望提高性能，使用int_fast#_t；如果您需要一个保证为特定大小的变量，并且希望优先考虑内存保护而不是性能，使用 int_least#_t尽量不要使用这些：无符号整型，Unsigned types；8 bits 的固定宽度的整型类型；任何特定于编译器的固定宽度整数（例如，visual studio 定义了 __int8 ，__int16 等等）std::size_t是什么？是一个无符号整数类型，通常用于表示对象的大小或长度。sizeof返回一个std::size_t类型的值。如：1234567891011#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; sizeof(int) &lt;&lt; '\\n'; return 0;&#125;/***********************/结果是： 4 【这个4，就是 std::size_t类型的】size_t本身大小也是不固定的，它确保是无符号的，并且至少是16位。但是在大多数系统中，它的大小将等于应用程序的地址宽度。比如，在32位应用程序中，size_t是一个 32 bits 的无符号整型；在64位应用程序中，size_t是一个 64 bits 的无符号整型。4.7 科学计数法scientific notation科学计数法的形式：a×10^exponent^。其中, a：只能是0~9的数（不包括0，但包括9）如：1.2×10^4^ 、 5.9736 x 10^24^在C++中，我们用字母e（大写E也可以）来代表 10；1.2×10^4^ -&gt; 1.2e4 ； 5.9736 x 10^24^ -&gt; 5.9736e24小于1的分数0.05表示为： 5e-2有效数字：significant digits有效数字的数量定义了数字的精度。(有效数字越多，数字越精确。)e前面的数就是有效数字，如5.9736e24的有效数字是：5.9736，即，5个有效数字4.8 浮点数float永远不要假设浮点数是精确的。三种浮点型数据：float、double、long double与整数一样，c++没有定义这些类型的实际大小(但它确实保证了最小大小)。在现代体系结构中，浮点表示几乎总是遵循IEEE 754二进制格式。在这种格式中：float：4字节；double：8字节，long double：可以等于一个double(8字节)、80 bits(通常填充为12字节)或者 16字节。浮点型数据通常是 有符号的(sign)：123456int x&#123;5&#125;; //整型double y&#123;5.0&#125;; //5.0是一个浮点型(没有后缀，默认情况下是double类型)float z&#123;5.0f&#125;; //5.0是一个浮点型，f后缀表示浮点类型/**********/【注】浮点型数据默认是：double类型的，加上后缀“f”表示是 float类型浮点型数据的输出1234567891011121314#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; 5.0 &lt;&lt; '\\n'; std::cout &lt;&lt; 6.7f &lt;&lt; '\\n'; std::cout &lt;&lt; 9876543.21 &lt;&lt; '\\n';&#125;/*************/输出结果：56.79.87654e+06第一个，即使我们输入的是5.0，但它输出的依然是 5。【默认情况下，如果小数部分为0,std::cout将不会打印数字的小数部分。】第二个输出正常；第三个输出是科学记数的形式。浮点型的范围根据 IEEE 754的表示：浮点型的精度浮点型的默认精度是6：123456789101112131415161718#include &lt;iostream&gt;int main()&#123; std::cout &lt;&lt; 9.87654321f &lt;&lt; '\\n'; std::cout &lt;&lt; 987.654321f &lt;&lt; '\\n'; std::cout &lt;&lt; 987654.321f &lt;&lt; '\\n'; std::cout &lt;&lt; 9876543.21f &lt;&lt; '\\n'; std::cout &lt;&lt; 0.0000987654321f &lt;&lt; '\\n'; return 0;&#125;/*******输出**********/9.87654987.6549876549.87654e+0069.87654e-005注意：根据编译器的不同，指数的位数会被填充。比如：“9.87654e+006”的指数位置就被填充为3位。显示的最小指数位数是特定于编译器的，在Visual Studio 中填充为 3 位浮点变量的精度位数取决于大小(浮点数的精度小于双精度)和存储的特定值(某些值的精度高于其他值)。用 iomanip头文件中的函数 std::setprecison来覆盖std::cout显示的默认精度。12345678910111213#include &lt;iostream&gt;#include &lt;iomanip&gt; // for std::setprecision()int main()&#123; std::cout &lt;&lt; std::setprecision(16); // show 16 digits of precision std::cout &lt;&lt; 3.33333333333333333333333333333333333333f &lt;&lt;'\\n'; // f suffix means float std::cout &lt;&lt; 3.33333333333333333333333333333333333333 &lt;&lt; '\\n'; // no suffix means double return 0;&#125;/*******输出*********/3.3333332538604743.333333333333334可以看出，double类型的比float类型的精度更高。精度不仅影响小数部分，他还影响比较大的数的精度。12345678910111213#include &lt;iostream&gt;#include &lt;iomanip&gt; // for std::setprecision() int main()&#123; float f &#123; 123456789.0f &#125;; // f has 10 significant digits std::cout &lt;&lt; std::setprecision(9); // to show 9 digits in f std::cout &lt;&lt; f &lt;&lt; '\\n'; return 0;&#125;/*********结果**********/123456792123456789.0 的有效数字是10个，但是浮点型通常有7位精度(123456792的结果只能精确到7位有效数字)。我们失去了一些精度!当由于无法精确地存储数字而丢失精度时，这称为rounding error(舍入误差)。小结：通常情况推荐使用double无限循环 &amp; 非数字 ：NaN and Inf123456789101112131415161718192021#include &lt;iostream&gt; int main()&#123; double zero &#123;0.0&#125;; double posinf &#123; 5.0 / zero &#125;; // positive infinity std::cout &lt;&lt; posinf &lt;&lt; std::endl; double neginf &#123; -5.0 / zero &#125;; // negative infinity std::cout &lt;&lt; neginf &lt;&lt; std::endl; double nan &#123; zero / zero &#125;; // not a number (mathematically invalid) std::cout &lt;&lt; nan &lt;&lt; std::endl; return 0;&#125;/*******结果************/1.#INF-1.#INF1.#INDINF代表无穷，IND代表不确定。请注意，输出Inf和NaN的结果是特定于平台的，因此您的结果可能会有所不同。总结：浮点数用于存储非常大或非常小的数字，包括那些具有小数部分的数字。浮点数通常有较小的舍入误差，即使该数的有效位数比精度小。很多时候，这些数据的舍入误差没有被注意到，因为它们非常小，而且由于输出而被截断。但是，对浮点数的比较可能不会得到预期的结果。对这些值执行数学运算将导致舍入误差增大。4.9 布尔型bool实际上，Boolean values(布尔值)存储的布尔变量，不是以true、false的形式。而是以整型类型存储的，即true对应整型1；false对应整型0。即，布尔值被认为是一个整型类型。输出布尔值123456789101112131415161718#include &lt;iostream&gt; int main() &#123; std::cout &lt;&lt;true&lt;&lt;'\\n'; std::cout &lt;&lt;false&lt;&lt;'\\n'; bool b&#123;false&#125;; std::cout &lt;&lt;b&lt;&lt;'\\n'; std::cout &lt;&lt;!b&lt;&lt;'\\n'; return 0; &#125;/***************结果***********/1001如果你想输出“true、false”。你可以用std::boolalpah：std::noboolalpha是关闭作用1234567891011121314151617#include &lt;iostream&gt;int main()&#123; std::cout &lt;&lt; true &lt;&lt; '\\n'; std::cout &lt;&lt; false &lt;&lt; '\\n'; std::cout &lt;&lt; std::boolalpha; //print bools as ture or false std::cout &lt;&lt;true&lt;&lt;'\\n'; std::cout &lt;&lt;false&lt;&lt;'\\n'; return 0;&#125;/********结果**********/10truefalse整型与布尔型的转换：Integer to Boolean conversion*不能用整型数字来初始化bool变量*bool b{4}; //error: 不允许这样转换但是，整型变量可以转换为布尔型：整型 0 可以被转换为false；其他的非0 的整型可以被转换为true12345678910111213141516171819#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; std::boolalpha; // print bools as true or false bool b1 = 4 ; // copy initialization allows implicit conversion from int to bool std::cout &lt;&lt; b1 &lt;&lt; '\\n'; bool b2 = 0 ; // copy initialization allows implicit conversion from int to bool std::cout &lt;&lt; b2 &lt;&lt; '\\n'; return 0;&#125;/********结果**********/truefalse输入布尔型值123456789int main()&#123; bool b &#123;&#125;; // default initialize to false (0) std::cout &lt;&lt; \"Enter a boolean value: \"; std::cin &gt;&gt; b; std::cout &lt;&lt; \"You entered: \" &lt;&lt; b; return 0;&#125;12Enter a Boolean value: trueYou entered: 0发现，布尔型值的输入，只接受：0 和1 (不是 true 或者 false)。所以，如果输入的值是0 和1之外的其他值，都是失败的，即false，所以是0。因为在C++11或者更新的标准中，一个失败的输入也会使变量变为0，所以b也会被赋值为0。4.11 char类型char数据类型是整数类型，这意味着底层值存储为整数，并且保证大小为1字节。但是，与将布尔值解释为true或false类似，将char值解释为ASCII字符。ASCII是美国信息交换标准代码的缩写，它定义了一种特殊的方式来将英文字符(加上一些其他符号)表示为0到127之间的数字(称为ASCII码或代码点)。字符文字总是放在单引号之间。例如，ASCII码97被解释为字符“a”。下面是完整的ASCII字符表:CodeSymbolCodeSymbolCodeSymbolCodeSymbol0NUL (null)32(space)64@96`1SOH (start of header)33!65A97a2STX (start of text)34”66B98b3ETX (end of text)35#67C99c4EOT (end of transmission)36$68D100d5ENQ (enquiry)37%69E101e6ACK (acknowledge)38&amp;70F102f7BEL (bell)39’71G103g8BS (backspace)40(72H104h9HT (horizontal tab)41)73I105i10LF (line feed/new line)42*74J106j11VT (vertical tab)43+75K107k12FF (form feed / new page)44,76L108l13CR (carriage return)45-77M109m14SO (shift out)46.78N110n15SI (shift in)47/79O111o16DLE (data link escape)48080P112p17DC1 (data control 1)49181Q113q18DC2 (data control 2)50282R114r19DC3 (data control 3)51383S115s20DC4 (data control 4)52484T116t21NAK (negative acknowledge)53585U117u22SYN (synchronous idle)54686V118v23ETB (end of transmission block)55787W119w24CAN (cancel)56888X120x25EM (end of medium)57989Y121y26SUB (substitute)58:90Z122z27ESC (escape)59;91[123{28FS (file separator)60&lt;92\\124|29GS (group separator)61=93]125}30RS (record separator)62&gt;94^126~31US (unit separator)63?95_127DEL (delete)初始化字符使用字符 初始化：char cha2{&#39;a&#39;}; // initialize with code point for ‘a’ (stored as integer 97) (preferred)使用整型数值 初始化：char cha1{97}; // initialize with integer 97 (‘a’) (not preferred)输出字符型12345678910111213141516#include &lt;iostream&gt; int main()&#123; char ch1&#123; 'a' &#125;; // (preferred) std::cout &lt;&lt; ch1; // cout prints a character char ch2&#123; 98 &#125;; // code point for 'b' (not preferred) std::cout &lt;&lt; ch2; // cout prints a character std::cout&lt;&lt;'c'; return 0;&#125;/*******结果********/abc【注意】固定宽度我的整型：int8_t类型，是被当做有符号的char类型对待的。12345678910#include &lt;iostream&gt;#include &lt;cstdint&gt;int main()&#123; int8_t a&#123; 97 &#125;; std::cout &lt;&lt; a; return 0;&#125;输出：通过类型转换将字符打印为整数一种(糟糕的)方法是将char赋值给一个整数，然后输出这个整数:1234567891011121314#include &lt;iostream&gt;int main()&#123; char ch&#123;97&#125;; int a&#123;ch&#125;; std::cout&lt;&lt;i; return 0;&#125;/********结果*********/97另一种较好的方法就是：type case：强制类型转换，其格式为：static_cast&lt;new_type&gt;(expression)12345678910111213141516#include &lt;iostream&gt;int main()&#123; char ch1&#123;97&#125;; char ch2&#123;'a'&#125;; std::cout&lt;&lt; static_cast&lt;int&gt; (ch1) &lt;&lt;'\\n'; //强制类型转换 std::cout&lt;&lt; static_cast&lt;int&gt; (ch2) ; //强制类型转换 return 0;&#125;/*********结果********/9797在上面的例子中，变量ch仍然是一个char，并且仍然保持相同的值。知识在本次输出时，输出的是整型类型的值。知识点：当您看到c++语法(不包括预处理器)使用尖括号&lt;&gt;时，尖括号之间的内容很可能是类型。这就是c++处理需要参数化类型的概念的典型方式。【注意】：std::cin将允许您输入多个字符。然而，变量ch只能包含一个字符。因此，只有第一个输入字符被提取到变量ch中，其余的用户输入留在std::cin使用的输入缓冲区中，可以通过后续调用std::cin来提取。12345678910111213141516#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; \"Input a keyboard character: \"; // assume the user enters \"abcd\" (without quotes) char ch&#123;&#125;; std::cin &gt;&gt; ch; // ch = 'a', \"bcd\" is left queued. std::cout &lt;&lt; ch &lt;&lt; \" has ASCII code \" &lt;&lt; static_cast&lt;int&gt;(ch) &lt;&lt; '\\n'; // Note: The following cin doesn't ask the user for input, it grabs queued input! std::cin &gt;&gt; ch; // ch = 'b', \"cd\" is left queued. std::cout &lt;&lt; ch &lt;&lt; \" has ASCII code \" &lt;&lt; static_cast&lt;int&gt;(ch) &lt;&lt; '\\n'; return 0;&#125;输出：)char的大小、范围以及默认的sign(符号)size：C++中char类型通常为：1 byte；sign：默认情况下，char类型是 signed 或者 unsigned；如果使用字符来保存ASCII字符，则不需要指定符号(因为有符号和无符号字符都可以保存0到127之间的值)。一个有符号的字符可以容纳-128到127之间的数字；无符号字符可以容纳0到255之间的数字。转义符：escape sequences转义符以 “\\” 开头,后面跟着一个 字母 或 数字；NameSymbolMeaningAlert\\aMakes an alert, such as a beepBackspace\\bMoves the cursor back one spaceFormfeed\\fMoves the cursor to next logical pageNewline\\nMoves cursor to next lineCarriage return\\rMoves cursor to beginning of lineHorizontal tab\\tPrints a horizontal tabVertical tab\\vPrints a vertical tabSingle quote\\’Prints a single quoteDouble quote\\”Prints a double quoteBackslash\\Prints a backslash.Question mark?Prints a question mark. No longer relevant. You can use question marks unescaped.Octal number(number)Translates into char represented by octal (octal：8进制)Hex number\\x(number)Translates into char represented by hex number(hex：16进制)单引号 VS 双引号 的区别单个字符总是放在 单引号 中。(e.g. ‘a’, ‘+’, ‘5’)。char类型的只能接收一个符号(e.g. 字母 a, + , 数字 5)char ch(&#39;56&#39;); // a char can only hold one symbol放在双引号(例如“Hello, world!”)之间的文本称为字符串string。一个 string是连续字符的集合(因此，一个字符串可以包含多个符号)。std::cout &lt;&lt; &quot;hello world&quot; ; // “Hello, world!” is a string literal知识点：string类型在C++中，不是基本数据类型char的其他类型：wchar_t、char16_t、char32_twchar_t：应避免使用(除非是在windows API接口时使用)。它的大小是在实现时才确定的，它并不可靠。char16_t、char32_t在C++11中添加，以提供对16位和32位Unicode字符的显式支持。在c++ 20中添加了char8_t。4.12 字面常量constant：是固定的值，不可被改变。C++中有两种constant：字面常量、符号常量。literal constant：字面常量，简称：literal。是直接将值插入代码中的。123return 5; //5是一个整型literalbool mynameisqin&#123;true&#125;; //true 是一个布尔型literalstd::cout &lt;&lt;3.4; //3.4 是一个双精度浮点型的literal上面这些都是常数，因为他们不能动态的被改变。就像对象分类型一样，常量也是有类型的：literal 的后缀example：12unsigned int value1 &#123;5u&#125;; //5的类型是 unsigned intlong value2 &#123;6L&#125;; // 6的类型是 long123/*默认情况，浮点类型是 double ；如果想定义其为float类型，可以添加后缀类实现*/float f1 &#123;5.0f&#125;; //5.0 的类型是 floatfloat f2 &#123;4.1&#125;; //4.1的类型是 doublestring literals123std::cout &lt;&lt; \"hello world\"; //这种是 C分割的 string literalstd::cout &lt;&lt; \"hello\" \" world\"; //C++将会把它们连接起来Scientific notation for floating point literals：浮点型literal 的科学计数12double pi &#123;3.14159&#125;; //3.14159是一种一般形式double avogadro &#123;6.02e23&#125;; //6.02e23 是双精度浮点型literal 的科学计数法形式Octal and hexadecimal literals：八进制 &amp; 十六进制 的 literal八进制：octal八进制是以8为底，它可用的数为： 0, 1, 2, 3, 4, 5, 6, 7。123456789/*八进制的前缀是，数字“0”，不是字母“o”*/#include &lt;iostream&gt;int main()&#123; int x&#123;012&#125;; //\"0\"表示这个数字是八进制数 std::cout &lt;&lt;x; return 0;&#125;十六进制：hexadecimal123456789/*十六进制数的前缀是：数字0和字母x，即 0x*/#include &lt;iostream&gt;int main()&#123; int x&#123;0xF&#125;; //0x表示这个数是十六进制数 std::cout&lt;&lt; x; return 0;&#125;十六进制通常用来表示内存地址 或 内存中的原始值。因为相对于二进制，16进制表示起来更加简洁。如：二进制的数0011 1010 0111 1111 1001 1000 0010 0110，单用16进制表示的话，就是3A7F 9826在C++14之前，无法给变量赋一个二进制的literal，但是，16进制对为我们提供了一个有用的解决方法:12345678910111213141516171819#include &lt;iostream&gt; int main()&#123; int bin&#123;&#125;; bin = 0x01; // assign binary 0000 0001 to the variable bin = 0x02; // assign binary 0000 0010 to the variable bin = 0x04; // assign binary 0000 0100 to the variable bin = 0x08; // assign binary 0000 1000 to the variable bin = 0x10; // assign binary 0001 0000 to the variable bin = 0x20; // assign binary 0010 0000 to the variable bin = 0x40; // assign binary 0100 0000 to the variable bin = 0x80; // assign binary 1000 0000 to the variable bin = 0xFF; // assign binary 1111 1111 to the variable bin = 0xB3; // assign binary 1011 0011 to the variable bin = 0xF770; // assign binary 1111 0111 0111 0000 to the variable return 0;&#125;C++14中 二进制的literal在C++14中，使用数字0和字母b，即“0b”。给变量分配二进制的literal：12345678910111213141516171819202122#include &lt;iostream&gt; int main()&#123; int bin&#123;&#125;; bin = 0b1; // assign binary 0000 0001 to the variable bin = 0b11; // assign binary 0000 0011 to the variable bin = 0b1010; // assign binary 0000 1010 to the variable bin = 0b11110000; // assign binary 1111 0000 to the variable return 0;&#125;/*但是二进制数比较长，所以用“ ' ”来当做分隔符，便于读认*/#Include &lt;iostream&gt; int main() &#123; int bin &#123;0b1011'0010&#125;; long value &#123;0'132'673'462&#125;; return 0; &#125;输出 十进制、八进制、十六进制、二进制数decimal、octal、hexadecimal、binaryC++默认输出是十进制数，但是我们可以转换输出格式：123456789101112131415161718#include &lt;iostream&gt;int main()&#123; int x &#123;12&#125;; std::cout &lt;&lt; x &lt;&lt;'\\n'; //默认十进制 std::cout &lt;&lt; std::hex&lt;&lt;x &lt;&lt;'\\n'; //16进制 std::cout &lt;&lt; x &lt;&lt;'\\n'; //x变量的值现在被转换为16进制了 std::cout &lt;&lt; std::oct&lt;&lt; x &lt;&lt;'\\n'; //8进制 std::cout &lt;&lt; std::dec&lt;&lt; x &lt;&lt;'\\n'; //十进制&#125;/*****输出*******/12cc1412输出二进制：输出二进制数比较麻烦一点。需要添加头文件：&lt;bitset&gt;。std::bitset&lt;num&gt;：表示我们存储的位数为num。它可以被初始化成一个 无符号整数值(可以使10，8，16，2进制的形式)123456789101112131415161718#include &lt;iostream&gt;#include &lt;bitset&gt; //for std::bitsetint main()&#123; // std::bitset&lt;8&gt; means we want to store 8 bits std::bitset&lt;8&gt; bin1&#123; 0b1100'0101 &#125;; // binary literal for binary 1100 0101 std::bitset&lt;8&gt; bin2&#123; 0xC5 &#125;; // hexadecimal literal for binary 1100 0101 std::cout &lt;&lt; bin1 &lt;&lt; ' ' &lt;&lt; bin2 &lt;&lt; '\\n'; std::cout &lt;&lt; std::bitset&lt;4&gt;&#123; 0b1010 &#125; &lt;&lt; '\\n'; // we can also print from std::bitset directly(输出完之后，被抛弃) return 0; &#125;/*输出*/11000101 1100010110104.13 const, constexpr, symbolic constants常量 变量：其值不能被修改，情形修改会出错使用关键字const，来表示该变量是常量：放在变量类型的前面、后面 都可以12const double gravity &#123;9.8&#125;; //放在类型的前面【推荐】int const sidesInSquare &#123;4&#125;; //放在类型后面【不推荐】常量变量(const variable)必须在定义时要初始化(即要赋值给他们)。赋值完成，它的值就不能被改变.123456/******常量变量的值被改变*************/const double a &#123;5.0&#125;;a = 1.0; //编译出错，因为常量变量的值被改变/*******常量变量不初始化********/const double a; //compiler error, must be initialized upon definitionruntime VS compile time constantsruntime：程序运行时；compile time：编译器运行时。runtime constants：初始化值只能在运行时解析的常量；compile-time constants：初始化值可以在编译时解析的；当您声明一个const变量时，编译器将隐式地跟踪它是运行时常量还是编译时常量。123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;bitset&gt;#include &lt;cstddef&gt; std::size_t getNumberOfBits()&#123; return 3;&#125; int main()&#123; const std::size_t numberOfBits&#123; 3 &#125;; // Compile-time constant std::bitset&lt;numberOfBits&gt; b&#123;&#125;; const std::size_t otherNumberOfBits&#123; getNumberOfBits() &#125;; // Run-time constant std::bitset&lt;otherNumberOfBits&gt; b2&#123;&#125;; // Error[因为此时需要的是编译时常量，而不是运行时常量] return 0;&#125;常量表达式：constexpr为了提供更多的特性，c++ 11引入了新的关键字constexpr，它确保常量必须是 “编译时常量”:1234567constexpr double gravity &#123;9.8&#125;; //正确，9.8是编译时的字面常量constexpr int sum &#123;4+5&#125;; //正确，4+5的值时编译时的字面常量std::cout &lt;&lt;\"enter your age:\";int age;std::cin &gt;&gt; age;constexpr int myage &#123;age&#125;; //错误，因为“age”是一个运行时常量【小结】：常量变量必须在定义时，对它初始化。当一个变量的值需要是 编译时常量时，推荐使用constexpr来声明它。当一个变量的值需要是 运行时常量时，推荐使用const来声明它。符号常量：symbolic constantssymbolic constant：是 字面常量(literal constant)的值 的名字。两种方法声明符号常量：使用“宏(macro)”定义：【不推荐】#define identifier substitution_text如：#define a 10;使用关键字constexpr变量：【推荐】12constexpr int maxstudentperclass &#123;30&#125;;constexpr int maxnamelength &#123;30&#125;;在多文件程序中使用符号常量在许多应用程序中，需要在整个代码中使用给定的符号常量(而不仅仅是在一个位置)。这些参数可以包括物理或数学常数(如pi或阿伏伽德罗常数)，或特定于应用程序的“调优”值(如摩擦系数或重力系数)。与其每次需要时都重新定义它们，不如在中心位置声明一次并在需要的地方使用它们。这样，如果你需要改变它们，你只需要在一个地方改变它们。有很多种方法来实现它，这里使用比较简单的一种：首先，创建一个头文件来写相关的常量；在这个头文件中，声明一个名称空间；将你要用到的常量写在这个命名空间中；在你需要这些常量的时候，#include这个头文件。example：constants.h (C++11/14):12345678910111213#ifndef CONSTANTS_H#define CONSTANTS_H//define your own namespace to hold constanstsnamespace constants&#123; constexpr double pi &#123;3.14159&#125;; constexpr double avogadro &#123;6.0221413e23&#125;; constexpr double my_gravity &#123;9.2&#125;; //.........other related constants&#125;#endifIn C++17, prefer “inline constexpr” instead:constants.h (C++17 or newer):12345678910111213#ifndef CONSTANTS_H#define CONSTANTS_H// define your own namespace to hold constantsnamespace constants&#123; inline constexpr double pi &#123;3.14159&#125;; inline constexpr double avogadro &#123; 6.0221413e23 &#125;; inline constexpr double my_gravity &#123; 9.2 &#125;; // m/s^2 -- gravity is light on this planet // ... other related constants&#125;#endif使用“作用域解析符::”,在其他文件访问你的常量：main.cpp1234567891011121314#include \"constants.h\"#include &lt;iostream&gt;int main()&#123; std::cout &lt;&lt; \"enter a radius: \"; int radius&#123;&#125;; std::cin &gt;&gt; radius; double circumference &#123;2.0*radius*constants::pi&#125;; std::cout &lt;&lt;\"the circumference is: \" &lt;&lt;circumference &lt;&lt;'\\n'; return 0;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://longlongqin.github.io/tags/C-C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"LearnCpp chapter3","slug":"C&C++/LearnCpp-chapter3","date":"2020-03-30T05:59:58.000Z","updated":"2020-04-19T14:38:29.545Z","comments":true,"path":"archives/5fc07ec4.html","link":"","permalink":"https://longlongqin.github.io/archives/5fc07ec4.html","excerpt":"LearnCpp-chapter3https://www.learncpp.com未完待续~~","text":"LearnCpp-chapter3https://www.learncpp.com未完待续~~","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://longlongqin.github.io/tags/C-C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"LearnCpp chapter2","slug":"C&C++/LearnCpp-chapter2","date":"2020-03-26T09:07:50.000Z","updated":"2020-04-19T14:38:29.702Z","comments":true,"path":"archives/28c74e52.html","link":"","permalink":"https://longlongqin.github.io/archives/28c74e52.html","excerpt":"LearnCpp chapter2https://www.learncpp.com","text":"LearnCpp chapter2https://www.learncpp.com2.1 函数当你读一本书的时候，突然有人给你打电话。然后你就用“书签”夹在当前阅读位置，去接电话。等你电话接完，再回到你放书签的那个地方继续读书。函数调用(function call)是一个表达式。它告诉CPU中断当前函数并在这里“放一个书签”，然后执行另一个函数(就是函数调用中提及的那个函数)。当调用结束后，CPU就返回到“书签”的位置，然后再继续执行。caller：发起函数调用的函数叫做caller；callee(called function)：被调用的函数叫做callee(called function)。int main()的返回值：在int main()函数最后，会有返回值，这个值是返回到操作系统的，为了让操作系统知道这个程序执行成功与否。main函数的返回值，有一个特定名字叫做：status code （状态码）一般 return 0; 表示程序执行成功。返回非零值，表示程序执行错误。【Note】：C++规定，main函数必须是int型的。即： int main()2.3 函数的形参与实参形参(parameter)：是指函数定义中参数；(形参初始化是通过调用者传来的值(即，实参)来初始化的 )实参(argument)：函数调用时的实际参数：1234567891011121314#include &lt;iostream&gt;void printValues(int x, int y) //函数定义时的参数x,y，即这里的x,y是形参&#123; std::cout &lt;&lt; x &lt;&lt; '\\n'; std::cout &lt;&lt; y &lt;&lt; '\\n';&#125; int main()&#123; printValues(6, 7); //调用函数。即，6和7是实参 return 0;&#125;实参与形参如何一起工作？当调用一个函数时，函数所有的parameters都被创建为变量，并且每个arguments的值都被复制到匹配的parameters中。这个过程称为pass by value(按值传递)。关于函数参数求值顺序的警告在C++中，没有规定实参匹配的顺序（顺序：从左→右，还是从右→左），因为匹配顺序不重要。但是，如果实参是函数调用，那就需要注意了：1someFunction(a(), b()); // a() or b() may be called first是从右→左，还是从右→左：取决于a()和b()的功能。如果你想要规定谁先的话，你可以显示的规定匹配顺序，如：1234int avar&#123; a() &#125;; // a() will always be called firstint bvar&#123; b() &#125;; // b() will always be called second someFunction(avar, bvar); // it doesn't matter whether avar or bvar are copied first because they are just values2.4 局部范围局部变量Local variables：函数的形参，和它内部定义的变量 属于“局部变量”。如：123456int add(int x, int y) // function parameters x and y are local variables&#123; int z&#123; x + y &#125;; // z is a local variable too return z;&#125;局部变量生命周期：123456789101112131415161718#include &lt;iostream&gt; int add(int x, int y) // x and y are created and enter scope here&#123; // x and y are visible/usable within this function only return x + y;&#125; // y and x go out of scope and are destroyed here int main()&#123; int a&#123; 5 &#125;; // a is created, initialized, and enters scope here int b&#123; 6 &#125;; // b is created, initialized, and enters scope here // a and b are usable within this function only std::cout &lt;&lt; add(a, b) &lt;&lt; '\\n'; // calls function add() with x=5 and y=6 return 0;&#125; // b and a go out of scope and are destroyed here执行过程：程序开始执行于main()函数；main()函数的变量a被创建并赋值为5；（初始化）★main()函数的变量b被创建并赋值为6；（初始化）★函数add()被调用，并传入实参5，6；add()函数的变量x被创建，并初值为5;（初始化）★add()函数的变量y被创建，并初值为6;（初始化）★操作符“+”计算表达式”x+y”，产生值11；add函数将值11复制回调用者main()函数；add函数的x、y被摧毁；★main()函数在控制台上打印出11；main()函数返回0到操作系统；main()函数的a、b被摧毁。★由此可知，局部变量的生命周期：是从他开始被创建（如上述的第2步，变量a被创建）一直到执行完这个它所在的函数（如上述的第9步）被摧毁。【Note】：变量的创建和摧毁发生在程序的运行期间（runtime）。所以生命周期是一个runtime属性。局部范围标识符的范围决定了在源代码中标识符可以被访问的位置。范围是一个编译期间(compile-time)的属性。（当使用的标识符不在范围内时，编译器会报错）局部变量的范围：开始于它的定义，结束于定义它们的花括号集合的末尾。如下：123456789101112131415161718#include &lt;iostream&gt; // x is not in scope anywhere in this functionvoid doSomething()&#123; std::cout &lt;&lt; \"Hello!\\n\";&#125; int main()&#123; // x can not be used here because it's not in scope yet int x&#123; 0 &#125;; // x enters scope here and can now be used doSomething(); return 0;&#125; // x goes out of scope here and can no longer be used2.5 为什么要用函数使用函数的优势：有组织性Organization：随着程序越来越复杂，若将全部的代码都写在main()函数中，势必会增加复杂性。一个函数就像一个小型程序。将它与main函数分开写，我们就不必去考其余代码。可重用性Reusability：一个函数可以被调用无数次。就可以避免这种情况：如果写在main函数中，要调用n次这个功能，就要重新写这个功能n次。便于测试Testing：因为函数减少了代码冗余，所以首先要测试的代码就更少了。另外，因为函数是自包含的，所以一旦我们测试了一个函数以确保它可以工作，我们就不需要再次测试它，除非我们修改它。这减少了我们必须一次测试的代码量，使得查找bug(或者在第一时间避免bug)变得更加容易。可扩展性Extensibility：抽象化Abstraction：在每次用这个函数时，我们只需要知道它的名字。输入和输出。不必知道它是如何工作的。如何高效的使用函数？在一个程序中出现多次的语句通常应该构成一个函数。例如，如果我们以相同的方式多次读取来自用户的输入，那么这就是一个很好的函数候选。如果我们以相同的方式输出多次，这也是一个很好的候选函数。一个函数通常应该执行一个(且仅一个)任务。当一个函数变得太长、太复杂或难以理解时，可以将其分解为多个子函数。这就是所谓的重构refactoring。2.6 空白与基本格式空白空白Whitespace：是一个术语，指的是用于格式化目的的字符。在c++中，这主要指空格、制表符(tab)和换行。c++编译器通常会忽略空白，只有少数例外(在处理文本时)。因此，我们说c++是一种与空白无关的语言。123456789/*下面这三个都是一样的作用*/std::cout &lt;&lt; \"Hello world!\"; std::cout &lt;&lt; \"Hello world!\"; std::cout &lt;&lt; \"Hello world!\"; std::cout &lt;&lt; \"Hello world!\";【注意】在文本中，不允许换行：123//这种是不被允许的std::cout &lt;&lt; \"hello world!\" ;但是这种情况是可以的：文本只是被空白(空格、制表符(tab)、换行)分离，他将会被连接：123//这里的hello与world都是被双引号包含起来的std::cout &lt;&lt; \"Hello \" \"world!\"; // prints \"Hello world!\"基本格式缩进(indentation)可以用：空格spaces或者tabs（制符表）。如果用制符表，建议将其调整为4个空格的缩进，3个也可以。大花括号（brace）：Google中的C++风格：12int main() &#123;&#125;另一种风格：这一种不容易出错，更容易找出花括号123int main()&#123;&#125;在大花括号中的每条语句，应该从其所在花括号算起隔开一个tab的距离，开始写：12345int main()&#123; std::cout &lt;&lt; \"Hello world!\\n\"; // tabbed in one tab (4 spaces) std::cout &lt;&lt; \"Nice to meet you.\\n\"; // tabbed in one tab (4 spaces)&#125;每一行的字符不要过长，一般不超过80个字符如果一行别操作符(如，&lt;&lt; 、+)分割(split)。这个操作符应该被卸载下一行的开头：123std::cout &lt;&lt; 3 + 4 + 5 + 6 * 7 * 8;通过对齐值或注释或在代码块之间添加间距，使用空白使代码更易于阅读。1234567891011//不易读cost = 57;pricePerItem = 24;value = 5;numberOfItems = 17;//易读cost = 57;pricePerItem = 24;value = 5;numberOfItems = 17;123456789//不易读std::cout &lt;&lt; \"Hello world!\\n\"; // cout lives in the iostream librarystd::cout &lt;&lt; \"It is very nice to meet you!\\n\"; // these comments make the code hard to readstd::cout &lt;&lt; \"Yeah!\\n\"; // especially when lines are different lengths//易读std::cout &lt;&lt; \"Hello world!\\n\"; // cout lives in the iostream librarystd::cout &lt;&lt; \"It is very nice to meet you!\\n\"; // these comments are easier to readstd::cout &lt;&lt; \"Yeah!\\n\"; // especially when all lined up1234567891011121314151617//不易读// cout lives in the iostream librarystd::cout &lt;&lt; \"Hello world!\\n\";// these comments make the code hard to readstd::cout &lt;&lt; \"It is very nice to meet you!\\n\";// especially when all bunched togetherstd::cout &lt;&lt; \"Yeah!\\n\";//易读// cout lives in the iostream librarystd::cout &lt;&lt; \"Hello world!\\n\"; // these comments are easier to readstd::cout &lt;&lt; \"It is very nice to meet you!\\n\"; // when separated by whitespacestd::cout &lt;&lt; \"Yeah!\\n\";2.7 提前声明与定义一个例子：123456789101112#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; \"The sum of 3 and 4 is: \" &lt;&lt; add(3, 4) &lt;&lt; '\\n'; return 0;&#125; int add(int x, int y)&#123; return x + y;&#125;在vs 2013中运行，会出现：add.cpp(5) : error C3861: &#39;add&#39;: identifier not found原因：因为编译器是按照顺序进行编译的。当编译器在main函数的第5行中调用add函数，他不知道add是什么。因为目前为止还没有定义add函数（因为add函数的定义在第9行）如何解决呢？法一：调整代码顺序：让被调用的函数在调用者之前【在复杂程序中，不实用】123456789101112#include &lt;iostream&gt; int add(int x, int y)&#123; return x + y;&#125; int main()&#123; std::cout &lt;&lt; \"The sum of 3 and 4 is: \" &lt;&lt; add(3, 4) &lt;&lt; '\\n'; return 0;&#125;如果在一个复杂的程序中，会调用很多函数，还有嵌套型的调用。如果去一个个个去找出调用顺序，然后去调整代码。这样是很乏味低效的。法二[推荐]：提前声明forward declaration：在使用函数之前，先声明它。（然后就不用关注代码实现的顺序了）提前向声明允许我们在实际定义标识符之前告诉编译器标识符的存在。为了编写一个函数的提前向声明，我们使用一个称为函数原型(function prototype)的声明语句。函数原型包括：函数的 返回类型、名字、形参，以分号(semicolon)结束。但是不包含函数主体(function body)1234567891011121314#include &lt;iostream&gt; int add(int x, int y); // forward declaration of add() (using a function prototype) int main()&#123; std::cout &lt;&lt; \"The sum of 3 and 4 is: \" &lt;&lt; add(3, 4) &lt;&lt; '\\n'; // this works because we forward declared add() above return 0;&#125; int add(int x, int y) // even though the body of add() isn't defined until here&#123; return x + y;&#125;忘记定义函数主题如果声明了函数，但没定义函数，而且这个函数没有被调用，那么这个程序可以被编译&amp;运行；如果声明了函数，但没定义函数，而且而且这个函数有被调用，那么这个程序可以被编译，但链接会出错。1234567891011#include &lt;iostream&gt; int add(int x, int y); // forward declaration of add() using function prototype int main()&#123; std::cout &lt;&lt; \"The sum of 3 and 4 is: \" &lt;&lt; add(3, 4) &lt;&lt; '\\n'; return 0;&#125; // note: No definition for function add上面程序在visual studio 中，会出现：编译成功，链接失败12345Compiling...add.cppLinking...add.obj : error LNK2001: unresolved external symbol &quot;int __cdecl add(int,int)&quot; (?add@@YAHHH@Z)add.exe : fatal error LNK1120: 1 unresolved externals声明 VS. 定义定义(define)：实现(函数或类型）或者是 实例化(对于变量）标识符。123456int add(int x, int y) // implements function add()&#123; int z&#123; x + y &#125;; // instantiates variable z return z;&#125;对于链接器(linker)来说定义（define）是必要的的。单定义规则单定义规则（one definition rule）简称：ODR：在C++中非常有名的规则，主要分三部分：在给定的文件中（这里翻译不准确），每个函数、对象、类型、模板只能有一次定义。在整个程序中，一个对象或者函数只能被定义一次；类型、模板、内置函数、变量 被允许在不同的文件中有相同的定义。违背第1条，将会使编译器发出重新定义错误；123456789101112131415int add(int x, int y)&#123; return x + y;&#125; int add(int x, int y) // violation part1 of ODR, we've already defined function add&#123; return x + y;&#125; int main()&#123; int x; int x; // violation of ODR, we've already defined x&#125;在visual studio中，会出现：1234project3.cpp(9): error C2084: function &#39;int add(int,int)&#39; already has a bodyproject3.cpp(3): note: see previous definition of &#39;add&#39;project3.cpp(16): error C2086: &#39;int x&#39;: redefinitionproject3.cpp(15): note: see declaration of &#39;x&#39;违背第2条，将会使连接器发出重新定义的错误；违背第3条，将会产生未定义的行为。声明声明(declaration)：是一个语句。它告诉编译器这里存在一个标识符和它的类型。12int add(int x, int y); // tells the compiler about a function named \"add\" that takes two int parameters and returns an int. No body!int x; // tells the compiler about an integer variable named x对编译器(complier)而言声明(declaeation)是必要的。在C++中，所有的定义也用作声明。上述例子中的int x是 定义，也是声明。多数情况下，定义符合我们的目的，因为定义能同时满足“编译器”和“链接器”的要求。【所有的定义都是声明，但所有的声明并不一定是定义。这些不是定义的声明有一个名字：纯声明(pure declarations)】一个典型的例子就是：函数原型(function prototype)，它满足编译器的要求，但不满足链接器的要求。其他类型的纯声明包含：提前声明变量 和 类型声明。单定义规则不适用于纯声明。所以，你可以对一些标识符声明n多次都可以（虽然声明n次，会有很多次是冗余的）小结：在很多编程语言中，“声明”就是指“纯声明”；“定义”就是指“定义也可以用于声明”。所以，int x;是一个定义（虽然他既是定义，也是声明）2.9 命名冲突&amp;命名空间命名冲突命名冲突：naming collision (or naming conflict).将两个同名的标识符放在同一个程序中，编译器或者链接器无法区分它们时，就会报错。这种情况就是：命名冲突例如：a.cpp123456#include &lt;iostream&gt; void myFcn(int x)&#123; std::cout &lt;&lt; x;&#125;main.cpp1234567891011#include &lt;iostream&gt; void myFcn(int x)&#123; std::cout &lt;&lt; 2 * x;&#125; int main()&#123; return 0;&#125;当编译器编译这个程序时，它将会单独的编译a.cpp和main.cpp，每个cpp文件都编译成功。但是，当链接时，链接器将会链接a.cpp和main.cpp中所有的定义到一起，此时就发现函数myFun命名冲突了。【注意，虽然函数myFun没有被调用，但在链接时还是会出错】命名冲突一般出现在以下两种情况：一个函数(或全局变量)的两个(或多个)定义被引入到不同的文件中，这些文件被编译到同一个程序中。这将导致一个链接器错误，如上所示。一个函数(或全局变量)的两个(或多个)定义被引入到同一个文件中(通常通过#include)。这将导致编译器错误。对于局部变量，C++提供一种局部范围的机制，它使定义在函数内部的局部变量不会冲突。但这种机制对于函数的名字无效。命名空间命名空间：namespace命名空间：之所以出来这样一个东西，是因为人类可用的单词数太少，并且不同的人写的程序不可能所有的变量都没有重名现象，对于库来说，这个问题尤其严重，如果两个人写的库文件中出现同名的变量或函数(不可避免)，使用起来就有问题了。为了解决这个问题，引入了名字空间这个概念，通过使用 namespace xxx；你所使用的库函数或变量就是在该名字空间中定义的，这样一来就不会引起不必要的冲突了。注意，在同一命名空间中，所有的名字必须是独一无二的。全局命名空间在C++中，任何没有定义在 类、函数、或 命名空间 的名字，都被默认的归为“全局命名空间(global namespace)”，有时也叫“全局范围(global scope)”std 命名空间在最初设计c++时，c++标准库中的所有标识符(包括std::cin和std::cout)都可以在没有std::前缀的情况下使用(它们是全局命名空间的一部分)。但是，这意味着标准库中的任何标识符都可能与你自己定义的标识符的名字(也在全局名称空间中定义)发生冲突。为了避免这种冲突，C++将所有标准库中的所有函数都移入一个叫做“std(是standard的简称)”的命名空间，即：std namespace所以，你看到的std::cout，这并不是它的名字，它实际上只是cout，std只是命名空间的名字，而cout是std namespace中的一部分。【注】：如果你使用一个命名空间中的标识符，你必须告诉编译器，这个标识符是在这个命名空间内。显示的命名空间限定符 std::最直接的方法是：告诉编译器我们使用cout是来自 std这个namespace(命名空间)的。可以使用前缀 “std::” 来完成：1234567#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; \"Hello world!\"; // when we say cout, we mean the cout defined in the std namespace return 0;&#125;‘::’ 是一个操作符，叫做“作用域解析符(scope resolution operator)”。在它左边的标识符表示：所在命名空间的名称；在它右边的标识符表示：这个命名空间的一个 标识符。【注】如果“::”的左边没有东西，则默认为它在全局命名空间( global namespace )中。std::cout就表示cout是在 std namsoace 中。using namespace std另一种方法是：用使用指令(using directive)**using namespace std。123456789#include &lt;iostream&gt; using namespace std; // this is a using directive telling the compiler to check the std namespace when resolving identifiers with no prefix int main()&#123; cout &lt;&lt; \"Hello world!\"; // cout has no prefix, so the compiler will check to see if cout is defined locally or in namespace std return 0;&#125;using directive：告诉编译器 当试图解析一个没有使用命名空间前缀(namespace prefix)的标识符时，检查一个指定的命名空间。【不推荐此方法】：123456789101112131415#include &lt;iostream&gt; // imports the declaration of std::cout using namespace std; // makes std::cout accessible as \"cout\" int cout() // declares our own \"cout\" function&#123; return 5;&#125; int main()&#123; cout &lt;&lt; \"Hello, world!\"; // Compile error! Which cout do we want here? The one in the std namespace or the one we defined above? return 0;&#125;这种情况，将不会被编译。因为编译器不知道我们到底想用我们自己定义的cout函数，还是想用 std命名空间 中的cout函数。并且，虽然标识符名称现在可能不冲突，但在将来的语言修订中，它可能与添加到std名称空间的新标识符发生冲突。2.10 预处理器在编译之前，代码要经过一个阶段，叫做“翻译(translation)”。在翻译阶段会发生许多事情，以使您的代码准备好被编译(如果您感兴趣，可以在这里找到翻译阶段的列表)。应用翻译的代码文件称为翻译单元(translation unit)。最值得注意的是：翻译阶段包含预处理器(preprocessor)。最好将预处理器看作是一个单独的程序，它处理每个代码文件中的文本部分。当预处理器运行时，它从头到尾的扫描源码文件，寻找预处理程序指令。预处理指令(preprocessor directives)，也称作directives：是以“#”符号开始，以换行符结束的指令(不是分号，即不要加分号)。“使用指令(using directives)”不是预处理指令，所以不会被预处理器处理。所以当提起“directive”，通常指的是“preprocessor directive”include当你#include*一个文件，预处理器将会把#include*指令 替换为 include file的内容。（include file 的内容将会被预处理，然后被编译）1234567#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; \"Hello, world!\"; return 0;&#125;当预处理器运行时，预处理器将会把#include &lt;iostream&gt;替换为 名为“iostream”的文件。宏定义宏定义：Macro defines#include 指令可以用来创建宏。在C++中，宏是定义如何将 ‘输入文本’ 转换为 ‘替换输出文本’。宏有两种基本类型：1️⃣对象式宏(object-like macros)。2️⃣函数式宏( function-like macros)函数式宏函数式宏的作用类似于函数，并具有类似的用途。对象式宏可以被定义成以下两种形式：#define identifier#define identifier substitution_text此处，identifier：宏名【一般是大写字母，用下划线表示空格】；substitution_text：替换文本(替换输出文本)1.带有输出文本(substitution_text)：当预处理器处理此条指令时，宏名 将会被替换为‘输出文本’。123456789101112131415161718#include &lt;iostream&gt; #define MY_NAME \"Alex\" int main()&#123; std::cout &lt;&lt; \"My name is: \" &lt;&lt; MY_NAME; return 0;&#125;//预处理程序将上述转换为以下内容:int main()&#123; std::cout &lt;&lt; \"My name is: \" &lt;&lt; \"Alex\"; return 0;&#125;2.不带输出文本：1#define USE_YEN如你所想，这条宏指令工作方式：标识符的任何进一步出现都将被删除，并将被nothing替换!条件编译条件编译：conditional compilation使用条件编译的预处理指令可以设置在什么条件下编译，什么条件下不编译。比较常见的条件编译指令有以下三个：#ifdef*、#ifndef、#endif*#ifdef 预处理指令允许预处理器检查这个标识符(identifier)是否已经被 #define(定义了)。如果被定义，那么在#ifdef*和#endif*之间的代码将会被编译；如果没被定义，这些代码将会被忽略。12345678910111213141516#include &lt;iostream&gt; #define PRINT_JOE int main()&#123;#ifdef PRINT_JOE std::cout &lt;&lt; \"Joe\\n\"; // if PRINT_JOE is defined, compile this code#endif #ifdef PRINT_BOB std::cout &lt;&lt; \"Bob\\n\"; // if PRINT_BOB is defined, compile this code#endif return 0;&#125;ifndef指令和ifdef*指令的作用是相反的。即，如果这个标识符没有被 #define，那么在#ifndef和#endif*之间的代码才会被编译12345678910#include &lt;iostream&gt; int main()&#123;#ifndef PRINT_BOB std::cout &lt;&lt; \"Bob\\n\";#endif return 0;&#125;输出结果是“Bob”,因为PRINT_BOB没有被 #define，所有才会执行。#if 0 ：条件编译的另一个常见用法是使用#if 0来排除正在编译的代码块(就像它在一个注释块中一样):12345678910111213#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; \"Joe\\n\"; #if 0 // Don't compile anything starting here std::cout &lt;&lt; \"Bob\\n\"; std::cout &lt;&lt; \"Steve\\n\";#endif // until this point return 0;&#125;【注】对象式宏不会影响预处理器的其他指令如：12345#define FOO 9 // Here's a macro substitution #ifdef FOO // This FOO does not get replaced because it’s part of another preprocessor directive std::cout &lt;&lt; FOO; // This FOO gets replaced with 9 because it's part of the normal code#endif宏定义的范围指令在编译之前，从上到下逐个文件地解析。同一文件中12345678910111213#include &lt;iostream&gt; void foo()&#123;#define MY_NAME \"Alex\"&#125; int main()&#123; std::cout &lt;&lt; \"My name is: \" &lt;&lt; MY_NAME; return 0;&#125;虽然，上面的代码表面上看起来：#define MY_NAME “Alex”是定义在函数foo内部的。但是预处理器将不会注意，因为它不懂C++中的概念，例如函数。所以，这个程序的执行流程与#define MY_NAME “Alex”在函数foo之前或之后定义的行为相同。但是，一般情况下，我们习惯于将 #define identifiers这种宏定义放在函数的外面。同一项目的不同文件中预处理程序完成后，将丢弃该文件中定义的所有标识符。这意味着指令仅从定义点到定义它们的文件末尾有效。在一个代码文件中定义的指令不会影响同一项目中的其他代码文件。example：function.cpp:1234567891011#include &lt;iostream&gt; void doSomething()&#123;#ifdef PRINT std::cout &lt;&lt; \"Printing!\";#endif#ifndef PRINT std::cout &lt;&lt; \"Not printing!\";#endif&#125;main.cpp12345678910void doSomething(); // forward declaration for function doSomething() #define PRINT int main()&#123; doSomething(); return 0;&#125;运行的结果是：Not printing!因为文件之间的宏定义互不影响。2.11 头文件头文件：Header files当程序变得越来越大了，对每个函数都进行提前声明是很乏味无趣的。如果能够将所有的 提前声明 放在一个地方，然后在需要时导入它们，这不是很好吗?code files：源文件(后缀 .cpp)；header files：头文件(后缀 .h 或 .hpp)头文件的主要用途就是：将 声明 引入 源文件 中。使用标准库头文件1234567#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; \"Hello, world!\"; return 0;&#125;这个程序使用std::cout。但是这个程序没有提供关于std::cout的声明或者定义，那编译器是如何知道std::cout是什么呢？答：因为std::cout在头文件“iostream” 中 已经提前声明过了。当我们#include &lt;iostream&gt;时，我们就请求预处理器将头文件“iostream”中的所有内容(当然也包含std::cout)都复制过来。注意：当#include xxx时，xxx头文件的所有内容都被引入到当前文件中。头文件通常只包含：函数和对象的声明，不包含它们的定义。如 std::cout在头文件“iostream”中声明， 但 定义为c++标准库的一部分，在链接器阶段自动链接到程序中。创建自己的头文件步骤：头文件保护符(header guaed)然后添加头文件(后缀 .h)进行声明；相应的也要添加源文件(后缀 .cpp)进行定义。【注意头文件、源文件的名字要一样】创建完之后：add.h：1234// 1) We really should have a header guard here, but will omit it for simplicity (we'll cover header guards in the next lesson) // 2) This is the content of the .h file, which is where the declarations goint add(int x, int y); // function prototype for add.h -- don't forget the semicolon!add.cpp：1234int add(int x, int y)&#123; return x + y;&#125;main.cpp：12345678#include &lt;iostream&gt;#include \"add.h\" // Insert contents of add.h at this point. Note use of double quotes here.【不是标准库的头文件，一般用双引号\"\"】 int main()&#123; std::cout &lt;&lt; \"The sum of 3 and 4 is \" &lt;&lt; add(3, 4) &lt;&lt; '\\n'; return 0;&#125;上面的程序的编译、链接过程：头文件的&lt;&gt;&amp;””尖括号：Angled brackets ，即&lt;&gt;。尖括号用来告诉预处理程序我们包含了编译器包含的头文件，所以它应该在系统目录中查找那个头文件。双引号：double-quotes，即“”。双引号告诉预处理器这是一个用户定义的头文件，所以它应该在当前目录中寻找这个头文件。如果没找到，它会检查其他的包含路径(已指定为compiler/IDE设置的一部分的路径)。如果还是失败的话，它将去系统目录中寻找这个头文件。“iostream”没 .h 后缀？好奇，为什么“iostream”(或者其他标准库头文件)没有后缀 .h？答：因为iostream.h是另一个头文件iostream.h与iostream：在C++最开始创建的时候，所有标准库都是有 .h 后缀的。但是，后来ANSI委员会修改C++，将所有的标准库放在 std 命名空间 中，进而避免与用户自定义的标识符 冲突。但是为题来了，将这些标准库移入std 命名空间 后，以前的程序将无法运行。为了解决这个问题，一个新的头文件：iostream出现，这个新头文件包含了 iostream.h的所有内容。然后，旧的程序依然可以用#include &lt;iostream.h&gt;，新程序就用#include &lt;iostream&gt;头文件路径建议12#include \"headers/myHeader.h\"#include \"../moreHeaders/myOtherHeader.h\"这种设置成路径形式的头文件，假设现在路径没问题。但是很有可能在某一天，你的文件位置就不小心的被移动了，这时候就用不了了。【建议】将你平常会用到的很多不同的文件放在比较固定的地方，然后在你的 compiler/IDE 这个固定地方的位置。这样当它在当前目录中找不到它们时，它就会去你设置的固定位置找。这通常可以通过在IDE项目设置中设置包含路径或搜索目录来实现。visual studio设置方法：在“解决方案”中，点击project的“属性”，然后看到“VC++目录”中的“包含目录(include directories)”，在这里面添加你要使用的头文件的目录。这种方法的优点是，如果要更改目录结构，只需更改单个编译器或IDE设置，而不必更改每个代码文件。2.12 头文件保护符头文件保护符：header guards重复定义duplicate definition：重复定义123456789101112131415161718192021222324252627//变量重定义int main()&#123; int x; // this is a definition for variable x int x; // compile error: duplicate definition return 0;&#125;//函数重定义#include &lt;iostream&gt; int foo() // this is a definition for function foo&#123; return 5;&#125; int foo() // compile error: duplicate definition&#123; return 5;&#125; int main()&#123; std::cout &lt;&lt; foo(); return 0;&#125;这种比较容易修复。但是在头文件中，很容易出现一个头文件中的定义被include不止一次。这通常发生在 一个头文件 又#include 其他头文件：square.h:12345//在头文件中，不建议出现 定义；但是这里为了方便举例int getSquareSides()&#123; return 4;&#125;geometry.h:1#include \"square.h\"main.cpp:1234567#include \"square.h\"#include \"geometry.h\"int main()&#123; return 0;&#125;上面这个程序。首先，在main.cpp中#include square.h ，它(square.h)将getSquareSides函数的定义复制到main.cpp中。然后，main.cpp又#include geometry.h ，它(geometry.h)又包含了square.h，所以也会将square.h中的内容(包括getSquareSides函数)复制到geometry.h，进而也就被复制到main.cpp中。所以，当解析完所有的#include之后，main.cpp就变成这样：1234567891011121314int getSquareSides() // from square.h&#123; return 4;&#125; int getSquareSides() // from geometry.h (via square.h)&#123; return 4;&#125; int main()&#123; return 0;&#125;所以，就会出现重复定义，编译也会出错。每个单独的文件没问题，但是因为main.cpp最终#include了两次square.h的内容，所以我们遇到了问题。如何解决呢？？？答：使用header guard头文件保护符头文件保护符(header guard)是条件编译(conditional compilation)的指令，它的形式如下：123456#ifndef SOME_UNIQUE_NAME_HERE //SOME_UNIQUE_NAME_HERE：你可以用任何名字代替它#define SOME_UNIQUE_NAME_HERE//这里是写关于 声明 的代码#endif当这个头文件被#included时，预处理器检查SOME_UNIQUE_NAME_HERE是否被定义过。如果这是我们第一次包含这个头文件，SOME_UNIQUE_NAME_HERE还没有被创建。然后就会定义SOME_UNIQUE_NAME_HERE，而且会包含文件的内容。如果这个头文件之前已经被包含到这个文件中，那么SOME_UNIQUE_NAME_HERE是已经被定义过的，而且其内容也以经被包含在这个文件中。所以这个头文件的内容将会被忽略（由于#ifndef）。每一个头文件都应该要有头文件保护符。好的头文件保护符命名规则：&lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H或者&lt;FILE&gt;_&lt;LARGE RANDOM NUMBER&gt;_H或者&lt;FILE&gt;_&lt;CREATION DATE&gt;_H请注意，头文件保护的目标是防止源文件多次接收到被保护的头文件。根据设计，头文件保护不会阻止将给定的头文件(一次)包含到单独的源码文件中。这也会导致意想不到的问题：square.h1234567891011#ifndef SQUARE_H#define SQUARE_H int getSquareSides()&#123; return 4;&#125; int getSquarePerimeter(int sideLength); // forward declaration for getSquarePerimeter #endifsquare.cpp123456#include \"square.h\" // square.h is included once here int getSquarePerimeter(int sideLength)&#123; return sideLength * getSquareSides();&#125;main.cpp12345678910#include &lt;iostream&gt;#include \"square.h\" // square.h is also included once here int main()&#123; std::cout &lt;&lt; \"a square has \" &lt;&lt; getSquareSides() &lt;&lt; \" sides\\n\"; std::cout &lt;&lt; \"a square of length 5 has perimeter length \" &lt;&lt; getSquarePerimeter(5) &lt;&lt; '\\n'; return 0;&#125;注意，square.h包含在main.cpp和square.cpp中。这意味着square.h的内容将被包含一次到square.cpp中，一次到main.cpp中。细节：当square.h被包含在square.cpp中时，在square.cpp结束之前，SQUARE_H都一直被定义。（这阻止了square.h被多次包含于square.cpp。也真是头文件保护符起作用的）。然而，一旦square.cpp结束后，SQUARE_H将不再被定义。这就意味着当预处理器运行main.cpp时，SQUARE_H在main.cpp中最初是没有定义的。结果就是，square.cpp和main.cpp都复制了getSquareSides的定义。这个程序将可以被编译，但是会链接出错（链接器会抱怨为什么会有不止一个的getSquareSides的定义）最好的解决办法就是：将函数的定义放在源文件中(即 .cpp文件中)，头文件中只含有声明。#pragma once#program once的作用和头文件标识符相同，但是它更加短。但是，#program once不是C++官方原生的一部分，所以不是所有的编译器都支持它。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://longlongqin.github.io/tags/C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"Let’s Build A Simple Interpreter-10","slug":"学习笔记/Let's Build A Simple Interpreter/LSBASI-10","date":"2020-03-25T05:21:04.000Z","updated":"2020-04-19T14:38:29.546Z","comments":true,"path":"archives/2f66ae56.html","link":"","permalink":"https://longlongqin.github.io/archives/2f66ae56.html","excerpt":"今天的改进内容：如何进行语法Fenix和解释Pascal的程序头部；如何进行语法分析Pascal的变量声明；将更新解释器，用DIV关键字来表示整数的出发、用品”/“来表示浮点数的除法；添加Pascal语言的注释功能","text":"今天的改进内容：如何进行语法Fenix和解释Pascal的程序头部；如何进行语法分析Pascal的变量声明；将更新解释器，用DIV关键字来表示整数的出发、用品”/“来表示浮点数的除法；添加Pascal语言的注释功能源码下载在进行细致的讲解之前，我们先下载本节的解释器的源码：spy.py和一个简单的Pascal语言的程序：part10.pas。然后再在命令提示符(Windows10系统 可直接在左下角搜索框中搜索“cmd”)中进行输入：python spi.py part10.pas：好了。现在来看看今天要改进的内容，我们将学习：如何进行语法Fenix和解释Pascal的程序头部；如何进行语法分析Pascal的变量声明；将更新解释器，用DIV关键字来表示整数的出发、用品”/“来表示浮点数的除法；添加Pascal语言的注释功能更新后的语法规则更新后的语法规则，如下图所示：这里给出一个简单地Pascal语言的程序，便于理解其语法：12345678910111213141516171819202122PROGRAM Part10;VAR number : INTEGER; a, b, c, x : INTEGER; y : REAL;BEGIN &#123;Part10&#125; BEGIN number := 2; a := number; b := 10 * a + 10 * number DIV 4; c := a - - b END; x := 11; y := 20 / 7 + 3.14; &#123; writeln('a = ', a); &#125; &#123; writeln('b = ', b); &#125; &#123; writeln('c = ', c); &#125; &#123; writeln('number = ', number); &#125; &#123; writeln('x = ', x); &#125; &#123; writeln('y = ', y); &#125;END. &#123;Part10&#125;1. program程序定义的语法规则，包括：保留字“PROGRAM”、程序的名字、一个以点“.”结尾的block。如：123PROGRAM Part10;BEGINEND.上面是一个完整的Pascal程序2. blockblock包含：一个声明规则、复合语句，如：12345678910//示例1VAR number : INTEGER;BEGINEND//示例2BEGINEND3. declarationsPascal的声明有几个部分，每个部分都是可选的。本节中，我们只讨论变量声明的部分。变量声明规则：要么有一个变量声明的子规则，要么是空的。4. VARPascal是静态类语言，也就是说在使用每一个变量之前，都需要明确的声明它的类型。变量的声明在程序中用VAR保留字，如：1234VAR number : INTEGER; a, b, c, x : INTEGER; y : REAL;5. type_spec在本节中，数据类型是两种：INTEGER 和 REAL(float)，常出现在变量声明部分：123VAR a : INTEGER; b : REAL;本节中没有进行设计类型检查，这将会在后续文章中添加6. termterm规则更新之后，将整数、浮点数的出发分开表示：DIV、/1220 / 7 = 2.85714285714 //浮点数出发20 DIV 7 = 2 //整数除法7. factor更新之后可以处理整数、浮点数的常量。以下是今天的完整语法：123456789101112131415161718192021222324252627282930313233343536program : PROGRAM variable SEMI block DOTblock : declarations compound_statementdeclarations : VAR (variable_declaration SEMI)+ | emptyvariable_declaration : ID (COMMA ID)* COLON type_spectype_spec : INTEGER | REALcompound_statement : BEGIN statement_list ENDstatement_list : statement | statement SEMI statement_liststatement : compound_statement | assignment_statement | emptyassignment_statement : variable ASSIGN exprempty :expr : term ((PLUS | MINUS) term)*term : factor ((MUL | INTEGER_DIV | FLOAT_DIV) factor)*factor : PLUS factor | MINUS factor | INTEGER_CONST | REAL_CONST | LPAREN expr RPAREN | variablevariable: ID更新Lexer总结一下，lexer的改变：新的tokens新的保留字添加处理Pascal语言的注释，用skip_comment更新integer更新get_next_token ，使其能够返回新添加的tokens让我们深入研究一下上面提到的变化:为了处理程序头、变量的声明、整数与浮点数常量以及它们的除法。我们需要添加新的tokens，我们还需要更新“INTEGER”的含义：表示一个整数类型，而不是一个整数常量。下面是更新后全部的tokens:PROGRAM (reserved keyword)VAR (reserved keyword)COLON (:)COMMA (,)INTEGER (we change it to mean integer type and not integer constant like 3 or 5)REAL (for Pascal REAL type)INTEGER_CONST (for example, 3 or 5)REAL_CONST (for example, 3.14 and so on)INTEGER_DIV for integer division (the DIV reserved keyword)FLOAT_DIV for float division ( forward slash / )全部的保留字token：123456789RESERVED_KEYWORDS = &#123; 'PROGRAM': Token('PROGRAM', 'PROGRAM'), 'VAR': Token('VAR', 'VAR'), 'DIV': Token('INTEGER_DIV', 'DIV'), 'INTEGER': Token('INTEGER', 'INTEGER'), 'REAL': Token('REAL', 'REAL'), 'BEGIN': Token('BEGIN', 'BEGIN'), 'END': Token('END', 'END'),&#125;处理注释，添加一个skip_comment 函数来处理注释，它的原理就是在找到右花括号“｛”之前，丢弃所有字符：1234def skip_comment(self): while self.current_char != '&#125;': self.advance() self.advance() # the closing curly brace重新命名integer函数为number函数，，使其能够处理整型常量和浮点型常量，如3和3.14：1234567891011121314151617181920212223def number(self): \"\"\"Return a (multidigit) integer or float consumed from the input.\"\"\" result = '' while self.current_char is not None and self.current_char.isdigit(): result += self.current_char self.advance() if self.current_char == '.': result += self.current_char self.advance() while ( self.current_char is not None and self.current_char.isdigit() ): result += self.current_char self.advance() token = Token('REAL_CONST', float(result)) else: token = Token('INTEGER_CONST', int(result)) return token更新get_next_token函数，使其能够返回新增的tokens：1234567891011121314151617181920212223def get_next_token(self): while self.current_char is not None: ... if self.current_char == '&#123;': self.advance() self.skip_comment() continue ... if self.current_char.isdigit(): return self.number() if self.current_char == ':': self.advance() return Token(COLON, ':') if self.current_char == ',': self.advance() return Token(COMMA, ',') ... if self.current_char == '/': self.advance() return Token(FLOAT_DIV, '/') ...更新Parser总结Parser的变化：新的抽象语法树结点（AST nodes）：Program, Block, VarDecl, Type对应新的语法规则的函数：block, declarations, variable_declaration, 和 type_spec.更新已经存在的paeser中的方法：program, term, and factor让我们深入研究一下上面提到的变化:新的AST nodes：Program AST node：表示一个程序，也是我们的根节点：1234class Program(AST): def __init__(self, name, block): self.name = name self.block = blockBlock AST node：包含声明与复合语句：1234class Block(AST): def __init__(self, declarations, compound_statement): self.declarations = declarations self.compound_statement = compound_statementVarDecl AST node：表示一个变量声明，它包含一个边梁节点和变量的类型结点：1234class VarDecl(AST): def __init__(self, var_node, type_node): self.var_node = var_node self.type_node = type_nodeType AST node：表示一个变量类型（INTEGER or REAL）：1234class Type(AST): def __init__(self, token): self.token = token self.value = token.value对应新增的语法规则的函数(方法)：block, declarations, variable_declaration, 和 type_spec.【这些方法负责解析新的语言结构和构造新的AST nodes】：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051def block(self): \"\"\"block : declarations compound_statement\"\"\" declaration_nodes = self.declarations() compound_statement_node = self.compound_statement() node = Block(declaration_nodes, compound_statement_node) return nodedef declarations(self): \"\"\"declarations : VAR (variable_declaration SEMI)+ | empty \"\"\" declarations = [] if self.current_token.type == VAR: self.eat(VAR) while self.current_token.type == ID: var_decl = self.variable_declaration() declarations.extend(var_decl) self.eat(SEMI) return declarationsdef variable_declaration(self): \"\"\"variable_declaration : ID (COMMA ID)* COLON type_spec\"\"\" var_nodes = [Var(self.current_token)] # first ID self.eat(ID) while self.current_token.type == COMMA: self.eat(COMMA) var_nodes.append(Var(self.current_token)) self.eat(ID) self.eat(COLON) type_node = self.type_spec() var_declarations = [ VarDecl(var_node, type_node) for var_node in var_nodes ] return var_declarationsdef type_spec(self): \"\"\"type_spec : INTEGER | REAL \"\"\" token = self.current_token if self.current_token.type == INTEGER: self.eat(INTEGER) else: self.eat(REAL) node = Type(token) return node更新已有的program, term, 和, factor 方法来适应语法的改变：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859def program(self): \"\"\"program : PROGRAM variable SEMI block DOT\"\"\" self.eat(PROGRAM) var_node = self.variable() prog_name = var_node.value self.eat(SEMI) block_node = self.block() program_node = Program(prog_name, block_node) self.eat(DOT) return program_nodedef term(self): \"\"\"term : factor ((MUL | INTEGER_DIV | FLOAT_DIV) factor)*\"\"\" node = self.factor() while self.current_token.type in (MUL, INTEGER_DIV, FLOAT_DIV): token = self.current_token if token.type == MUL: self.eat(MUL) elif token.type == INTEGER_DIV: self.eat(INTEGER_DIV) elif token.type == FLOAT_DIV: self.eat(FLOAT_DIV) node = BinOp(left=node, op=token, right=self.factor()) return nodedef factor(self): \"\"\"factor : PLUS factor | MINUS factor | INTEGER_CONST | REAL_CONST | LPAREN expr RPAREN | variable \"\"\" token = self.current_token if token.type == PLUS: self.eat(PLUS) node = UnaryOp(token, self.factor()) return node elif token.type == MINUS: self.eat(MINUS) node = UnaryOp(token, self.factor()) return node elif token.type == INTEGER_CONST: self.eat(INTEGER_CONST) return Num(token) elif token.type == REAL_CONST: self.eat(REAL_CONST) return Num(token) elif token.type == LPAREN: self.eat(LPAREN) node = self.expr() self.eat(RPAREN) return node else: node = self.variable() return node现在来看看我们的抽象语法树Abstract Syntax Tree，下面是一个Pascal程序：12345678910PROGRAM Part10AST;VAR a, b : INTEGER; y : REAL;BEGIN &#123;Part10AST&#125; a := 2; b := 10 * a + 10 * a DIV 4; y := 20 / 7 + 3.14;END. &#123;Part10AST&#125;它的解析树为：在图中可以看到我们添加的新节点。更新Interpreter现在，剩下的就是向解释器类添加新的访问者方法。下面是将要新增的四个访问方法（对应新增的四种结点）：visit_Programvisit_Blockvisit_VarDeclvisit_Type其中对于VarDecl和Type，解释器对他们什么都不做：123456789101112131415def visit_Program(self, node): self.visit(node.block)def visit_Block(self, node): for declaration in node.declarations: self.visit(declaration) self.visit(node.compound_statement)def visit_VarDecl(self, node): # Do nothing passdef visit_Type(self, node): # Do nothing pass更新visit_BinOp 方法，使其能够准确的解释整数和浮点数的除法：1234567891011def visit_BinOp(self, node): if node.op.type == PLUS: return self.visit(node.left) + self.visit(node.right) elif node.op.type == MINUS: return self.visit(node.left) - self.visit(node.right) elif node.op.type == MUL: return self.visit(node.left) * self.visit(node.right) elif node.op.type == INTEGER_DIV: return self.visit(node.left) // self.visit(node.right) elif node.op.type == FLOAT_DIV: return float(self.visit(node.left)) / float(self.visit(node.right))总结总结一下，在本文中，扩展了Pascal解释器的哪些部分：添加新的语法规则和更新现有的规则；添加新token，并相应地添加新方法去处理这些tokens，更新了现有的方法；parser中：为新的语法结构添加新的AST nodes；向我们的递归下降解析器添加与新语法规则相对应的新方法，并更新一些现有的方法；interpreter中添加新的访问方法，更新了一个现存的访问方法我们也出去了一些“HACKS”(part9 中提到的)：本文的解释器可以处理程序头部(PROGRAM header)变量可以用VAR关键字来声明将整数与浮点数的除法分开来","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let’s Build A Simple Interpreter","slug":"Let’s-Build-A-Simple-Interpreter","permalink":"https://longlongqin.github.io/tags/Let%E2%80%99s-Build-A-Simple-Interpreter/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"LSBASI整理","slug":"学习笔记/Let's Build A Simple Interpreter/1-8整理","date":"2020-03-24T05:34:22.000Z","updated":"2020-04-19T14:38:29.546Z","comments":true,"path":"archives/6fc94bb0.html","link":"","permalink":"https://longlongqin.github.io/archives/6fc94bb0.html","excerpt":"持续更新","text":"持续更新part 3实现了加减混合运算，并引入语法图概念part 4实现了整数的乘除混合运算，引入上下文无关语法(context-free-grammars)，即BNFpart 5实现了加减乘除混合运算，引入结合律(associativity)和优先级(precedence)part 6新增括号运算part 7从本小节开始，将interpreter和parser分开来实现。并引入抽象语法树(AST)和解析树(parse tree)概念part 8新增一元操作符(unary operators)：“+”，“-”part 9整体分析整体分析，不管是part x，都一起分析，看看他的整体结构：Lexertoken类型：12345678910111213141516171819202122INTEGER = 'INTEGER' #用于表示整数类型REAL = 'REAL' #表示浮点型INTEGER_CONST = 'INTEGER_CONST' #整型常量REAL_CONST = 'REAL_CONST' #浮点型常量PLUS = 'PLUS'MINUS = 'MINUS'MUL = 'MUL'INTEGER_DIV = 'INTEGER_DIV' #整型数的除法FLOAT_DIV = 'FLOAT_DIV' #浮点数的除法LPAREN = 'LPAREN' #左小括号RPAREN = 'RPAREN' #右小括号ID = 'ID' #表示有效的标识符ASSIGN = 'ASSIGN' #这种token表示两个字符，“:=”,用于赋值语句BEGIN = 'BEGIN' END = 'END'SEMI = 'SEMI' # 表示分号，用于标记复合语句中的一个句子的结尾DOT = 'DOT' #点，用于Pascal语言中program的定义PROGRAM = 'PROGRAM' VAR = 'VAR'COLON = 'COLON' #冒号COMMA = 'COMMA' #逗号EOF = 'EOF'保留字123456789RESERVED_KEYWORDS = &#123; 'PROGRAM': Token('PROGRAM', 'PROGRAM'), 'VAR': Token('VAR', 'VAR'), 'DIV': Token('INTEGER_DIV', 'DIV'), 'INTEGER': Token('INTEGER', 'INTEGER'), 'REAL': Token('REAL', 'REAL'), 'BEGIN': Token('BEGIN', 'BEGIN'), 'END': Token('END', 'END'),&#125;词法分析器的结构：有一个___init__的函数，在创建实例的时候，就会自动调用这个方法；一个提示错误的函数error；然后开始处理“词”，这里有一个函数advance用于向前进一步(pos会➕1）：peek：为了在以相同的字符开头时，区分是“保留字”还是“标识符”。在这里，我们可以在不消耗下一个字符的情况下去查看缓冲区：就是利用peek_pos移动查看下一个字符，而真正的pos不动。skip_comment：处理注释；skip_whitespace：处理空格；number：在part10之前，叫做integer，因为现在不仅有整型数据，还有浮点型的。所以改名为number。_id：处理“标识符”和“保留字”get_next_token：词法分析器的核心部分，前面的都是设计，现在才开始识别出一个个的token，下面就是列出识别token的种类：其实这里叫做：get_token_and_go_next比较直观，这个函数是，先识别出一个token，然后再继续寻找下一个token左括号token：“{”保留字token、标识符token。（用函数_id()来完成）整型变量token赋值符号“:=”token冒号“:”token分号“;”token逗号“,”token加、减、乘 token除法token整数除法：“DIV” token浮点数除法：“/” token左小括号“(” token ； &amp; 右小括号“)” token点“.” tokenParser​ 语法分析，主要是分析词法分析器传过来的一个个token，分析它们之间的运算关系，即语法：它们之间的关系，即语法，用抽象语法树来表示：一个基类：AST。（后面的继承于它）一个二元操作符类：BinOp(AST)（表示加减乘除运算）","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let's Build A Simple Interpreter","slug":"Let-s-Build-A-Simple-Interpreter","permalink":"https://longlongqin.github.io/tags/Let-s-Build-A-Simple-Interpreter/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"我的云书签","slug":"资源整合","date":"2020-03-22T16:05:49.000Z","updated":"2020-04-19T14:38:29.545Z","comments":true,"path":"archives/eaabd222.html","link":"","permalink":"https://longlongqin.github.io/archives/eaabd222.html","excerpt":"搜集学习资料&好用的工具","text":"搜集学习资料&好用的工具Ⅰ CS 学习00全科资料1. 面试笔记集合资源描述CS-Notes、网页版、【备用链接】📚 技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计、Java、Python、C++准备秋招，欢迎来树上取果实这里将以最短的篇幅，最清晰的层级结构去总结那些对C++后台开发最为核心的内容。《互联网面试笔记》收集和分析互联网常见面试题，并将这些面试知识整理成文方便大家查阅。主要是面向java程序员，但基础知识部分不同语言程序员(c,c++,python等）都可以参考C/C++笔记C/C++ 技术面试基础知识总结，包括语言、程序库、数据结构、算法、系统、网络、链接装载库等知识及面试经验、招聘、内推等信息。 https://interview.huihut.com2. 教程集合学习C &amp; C++学习C &amp; C++ &amp; python&amp;汇编语言 LLVM编译器 数据结构 算法 操作系统 单片机 linux 面试01实用网站geeksforgeeks是印度的一家致力于计算机科学的百科全书，根据不同的用户计算机水平而发布不同的难度等级，从基础到专家级，内容涵盖了编程、算法、面试问题等。​02项目练习基于项目学习（project-based-learning)03编程相关书籍英文版中文版04科目1. 数据结构适合回顾知识点：https://oi-wiki.org/学习教程描述状态数据结构与算法系列博客园中的一个博主写的再看👁️算法学习笔记这里的内容是学习算法过程的一些记录，希望能一直坚持下去。备用可视化工具描述Visualgo可视化的观察数据结构的操作David Galles可视化演示(JS)旧金山大学David Galles可视化演示(JS)可以从代码中可视化算法算法可视化工具是一个交互式的在线平台，可以从代码中可视化算法。更多可视化工具2. learn OpenGL中文教学网址：https://learnopengl-cn.github.io/intro/3. C/C++C语言相关：笨办法学C官方文档cppreference相关网站网站描述Cplusplus这也是一个学习 C++ 的优秀网站，除了提供相应的教程之外，还有一个很棒的论坛。和其它网站相比，它的价值更多体现在参考上，因为里面解释了许多编程概念，如果对某个特定的东西感到困惑，那么这些概念将会很有帮助。TutorialsPointTutorialspoint 是一个顶级网站，之所以这么说，是因为你想学的任何技术（包括 C++），它几乎都提供了详细的教程。保存好就对了，超级有用。Awesome C++GitHub 上的 Awesome-XXX 系列的资源整理，awesome-cpp 就是 fffaraz 发起维护的 C++ 资源列表，内容包括：标准库、Web 应用框架、人工智能、数据库、图片处理、机器学习、日志、代码分析等学习路线C++学习进阶(陈皓)学习教程资料描述LearnCpp一个很好地C++学习网站你好，C++辅助学习文章阅读（有时间可以看）Ⅱ 关注的博客Linux鳥哥的 Linux 私房菜Ⅲ Github中的资源[github仓库排名](https://gitstar-ranking.com/repositories)web开发人员的路线图自学计算机课程的参考计算机技术与科学自学之旅(中文)开源社区大学计算机科学课程中文项目（OSSU CS CN)旨在为英语能力有待提高的中文学习者提供全中文的在线本科计算机科学学习课程。消除学习者在自学计算机课程中遇到的语言障碍。请注意本课程并不是英文课程的对照翻译，而是在其基础上结合地区实际情况提供全中文的在线教育。值得注意的是，我们仍然推荐学有余力者在学习完本课程后系统学习和掌握英语技能。computer-science通往免费自学计算机科学教育的道路!Ⅱ 工具01写作相关编辑器公众号排版(支持Markdown)：推荐【分为：Google插件 &amp; 在线版】在线版135编辑器：一款强大的微信公众号文章排版插件壹伴：壹伴运营神器_新媒体小编最喜欢的微信排版工具短链生成图片压缩RGB及其它类型颜色查询无版权图片Pixabay：Pixabay是一个支持中文搜索的免费可商用图库。Gratisography：Gratisography是一个免费高分辨率摄影图片库，所有的图片都可以用于个人或者商业用途，每周更新图片你只需要点击即可下载。Unsplash：每天更新一张高质量的图片素材，全是生活中的景象作品，清新的生活气息图片。Pexels：根据英文关键词搜索图片，还能根据不同颜色分类查找，匹配的图片复古自带滤镜，风格简约，图片质量很高，素材丰富。VisualHunt：可以通过颜色来查找图片。Photock：天空、水、河、海、草坪、火、山、动物、建筑、夜景、日本景点、日本历史文化图片等等。pngimg：全部都是无背景图片，非常适合那些需要png透明底配图的。而且它分类也很细，找起来方便。Foodiesfeed：专注于美食的图片网站，高清无水印，根据分类选择匹配关键词。Everypixel：Everypixel 是一款帮助用户寻找免费图片素材的搜索引擎，选择免费或付费，利用AI和图片分析技术筛选图片，并查看图片来源网站。https://www.howtostartanllc.org/free-stock-photos/这是一个汇总了很多个免费图片网站的导航。02 云同步备份功能坚果云可以实现本地与云端实时同步，还带有历史版本回退功能。缺点：每月上传只有1G容量，只能同步体积较小的文件。亿方云：可以实现本地与云端实时同步，还带有历史版本回退功能。功能和坚果云类似。其他Markdown 简历排版","categories":[],"tags":[{"name":"forme","slug":"forme","permalink":"https://longlongqin.github.io/tags/forme/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"凸包总结","slug":"学习笔记/计算几何/Convex-Hull/凸包总结","date":"2020-03-22T08:08:18.000Z","updated":"2020-04-19T14:38:29.547Z","comments":true,"path":"archives/bf113a1c.html","link":"","permalink":"https://longlongqin.github.io/archives/bf113a1c.html","excerpt":"","text":"凸包的相关“test”测试一些定义：凸包[Convex Hull]：简单理解为将很多钉子围住的“皮筋”。极点(Extreme Point)：有一个点集S。如果存在通过点P的直线L，使得点集S中除了点P之外的其他的点都在这个直线的同一侧，则这个点P就是极点(Extreme Points)。极边(Extreme Edge)：两个极点连成的边，剩余的所有点均会在该边的一侧。To-Left TestTo-Left测试是相对于另外这两个点所确定的那条有向直线而言的，任何一条有向直线不仅会把平面分成两部分，我们还可以知道哪一边是左边，哪一边是右边。To-Left，其实就是说这个点相对于刚才的那条有向线而言到底是位于它的左侧(就是true)，还是右侧(就是false)。这里用到了行列式来求三角形面积（请看下面手写证明）。下图中的这个行列式实际上算的是它的”面积(指：有向面积）”的两倍。12345678910bool ToLeft (Point p, Point q, Point s) //判断点s对于线段pq的位置&#123; return Area2(p,q,s);&#125;int Area2(Point p, Point q, Point s)&#123; return p.x*q.y - p.y*q.x + q.x*s.y - q.y*s.x +s.x * p.y - s.y *p.x;&#125;行列式来求三角形面积的证明：图片来源于：https://zhuanlan.zhihu.com/p/35543479In-Trangle Test其实这个算法就是判断点是否在三角形内部。这个测试最直接的理解为：使用了三次To-Left Test，三角形有三条边，所以每一条边都测试一次：三次To-Left Test结果相同的（均为true或者是false），则证明在三角形内部。三次结果中有一次不相同，则证明在三角形外部。判断极边123456789101112 //判断极边的核心void checkEdge(Point S[], int n, int p, int q)&#123; bool lEmpty =TRUE, REmpty = TRUE; for( int k=0; k&lt;n&amp;&amp;(LEmpty||REmpty); k++) &#123; if (k!=p &amp;&amp; k!=q) ToLeft(S[p], S[q], S[k]) ? LEmpty=FALSE: REmpty=FALSE; &#125; if(LEmpty || REmpty) S[p].extreme =S[q].extreme= TRUE;&#125;in-convex-polygon test判定待定点是否位于某多边形内部（in-convex-polygon test）实现的方法就是：按一定方向（约定为逆时针）凸包的每条边和待定点做ToLeft test，一旦有一次test为false就说明改点在凸包外面。构造凸包的方法1 利用极点法123456789101112131415void extremePoint (point S[], int n)&#123; for(int s=0; s&lt;n; s++) S[s].extreme = TRUE; for(int p=0; p&lt;n; p++) for(int q=p+1; q&lt;n; q++) for(int r=q+1; r&lt;n; r++) for(int s=0; s&lt;n; s++) &#123; if(s==p || s==q || s==r ||!S[s].extreme) continue; if(Intriangle(S[p],S[q],S[r],S[s])) S[s].extreme = FALSE; &#125;&#125;时间复杂度：O(n^4)2 利用极边法1234567891011121314151617181920void markEE（point S[], int n）&#123; for (int k=0;k&lt;n;k++) //将所有点的初始状态都设置成：非极点 S[K].extreme = FALSE; for (int p=0; p&lt;n; p++) //遍历每条边，看他是否是极边 for(q=p+1; q&lt;n; q++) checkEdge(S,n,p,q) //判断极边的核心&#125; //判断极边的核心void checkEdge(Point S[], int n, int p, int q)&#123; bool lEmpty =TRUE, REmpty = TRUE; for( int k=0; k&lt;n&amp;&amp;(LEmpty||REmpty); k++) &#123; if (k!=p &amp;&amp; k!=q) ToLeft(S[p], S[q], S[k]) ? LEmpty=FALSE: REmpty=FALSE; &#125; if(LEmpty || REmpty) S[p].extreme =S[q].extreme= TRUE;&#125;时间复杂度：O(n^3)3 incremental construction（增量构造）详细讲解：https://www.longlongqin.github.io/archives/7c53.html该算法的核心步骤就是：复杂度 O(n^2)判定新加入点与凸包的位置关系：用in-convex-polygon testin-convex-polygon test在上面有讲向凸包插入新点：support-line如上面的点x，如何插入现有凸包当中呢？插入过程：插入过程其实就是寻找两个连接点s和t，然后将新点x与t、s分别连接得到新的凸包。t、s两个点将原凸包的边界分成两部分：st和ts两个邮箱线段。构造新凸包就要保留远端st，舍弃近端ts。取代ts的是x和s、t的连接线xt和xs。其中xt、xs被称为切线（tangent）或者support line（支撑线）。（配合下图理解）现在就是如何找到t、s这两个点？在凸包上任取一点v，按逆时针方向v点会有一个直接前驱点和直接后继点。考察有向直线xv与点v直接前驱和直接后继的位置关系（两次to left test），记为一个pattern表。【结果无非是四种情况：v的直接前驱和直接后继相对于有向直线xv的位置是RL，LR，LL，RR。例如上图黄色点v，是R和L；蓝色点v分别是L和R。实际上凸包边界st上所有点的pattern都为RL，ts上所有点的pattern都为LR。关键点在于：点S的pattern是LL，点t的pattern为RR。】说了这么多，其实我们可以将上面的两步合为一步：对于每个待定点x，不必特意去考虑它与凸包的位置关系，而是遍历凸包上每一个点。对于凸包边界上的每一个点，我们都能通过两次to left test迅速判断出pattern。对于x位于凸包外部的情况，经过遍历凸包的点，我们很容易就能得到s和t的位置，得到两条support line，从而构造出新的凸包；而对于x位于凸包内部的情况，凸包边界每个点都不可能出现RR或LL的情况，直接舍弃x即可。4 Jarvis March详细讲解：https://longlongqin.github.io/archives/9c7f.html又称：Gift Wrapping算法步骤：初始化所有点，设置点集的初态为 非极点找到开始的第一个极点：用LTL方法寻找下一个极点：用ToLeft test寻找下一个极点循环步骤3，直到找到所有极点也就是：首先从任何一个极点（用LTL确定）开始，然后找到一条以这个极点为端点的极边。然后沿着这个极边的另一个端点（endpoint）出发，再找出下一条极边。如此反复操作，最终会找到一条以最初极点为endpoint的极边，得到一个封闭的环，凸包也构造完成。123456789101112131415161718192021222324252627282930313233int LTL(Point S[], int n) //寻找最下and最左的点作为第一个极点&#123; int ltl = 0; for (int k=1; k&lt;n; k++) &#123; if(S[k].y &lt; S[ltl].y || (S[k].y==S[ltl].y &amp;&amp; S[k].x&lt;S[ltl].x) ) ltl = k; &#125; return ltl;&#125;void Javis (Point S[], int n)&#123; for (int k=0; k&lt;n; k++) S[k].extreme=FALSE; //1.将所有点标记为非极点 int ltl = LTL(S, n); //2.找到ltl int k = ltl; do &#123; S[k].extreme = true; int s = -1; //要找的下一个极点用s表示 for (int t=0; t&lt;n; t++) &#123; if (t!=k &amp;&amp; t!=s &amp;&amp; ( s==-1 || !ToLeft(S[K],S[s],S[t]) ) ) s = t; &#125; S[k].succ = s; //新的极边确定 k = s； //更新k的值，变为下一次查找的边的起点 &#125; while(k != ltl) //如果循环回到了原来的点，则结束&#125;复杂度：Jarvis March算法算法的复杂度更准确的表示为O(nh)。h（凸包边界的点的个数）又由最终输出结果，即凸包本身来决定，输出结果决定了构造过程的复杂度，这就是所谓的“输出敏感性”。这种类型的算法又被称为output sensitive algorithm。这种特性在其它凸包算法中也会体现。5 Graham Scan详细讲解；https://longlongqin.github.io/archives/3478.html算法流程：预排序(presorting)：即找到某个基准点，然后将其余所有的点按照相对于基准点的极坐标排序。它主要做了三个事情：1、找出基准点：用lowest-then-leftmost point（LTL），然后对其他点按照极坐标排序：根据极角排序的方法，在：（https://longlongqin.github.io/archives/510d.html#补：根据极角排序）2、找出起始边：从排好序的点集，选取前两个点，就是起始边。3、将起始边 与 剩下的n-2条边分别存储在不同的栈(stack)中：如下图Scan扫描这一步是算法的核心。scan的过程主要关注三个点：栈S的栈顶（S[0]）、次栈顶（S[1]）和栈T的栈顶（T[0]）。也就下图红色标注的三个点：可以观察到，每次待处理的S[0]和S[1]构成的边一定是一条极边（如上图点1和点2），算法关键步骤就是对边这条极边和T[0]做to left test，判断T[0]位于边S[0]S[1]的左边还是右边。若在左边则继续拓展，若在右边则否定掉此前认定的极边。无论结果如何，每次判定都会将问题规模缩小一个单元，算法结束时T最终肯定为空。T空后，S中存留下的点正是凸包的极点，这些点自底而上正是凸包边界点的逆时针遍历，也得到了整个凸包构造问题的解。复杂度：Graham Scan算法复杂度由三部分决定：persorting，采用一般排序算法，复杂度是O(nlogn)逐步迭代，O(n)：算法一步步纳入新点，会迭代n步。scan，O(?)所以算法的总体复杂度：O(nlogn + n * ?) ，可见scan的复杂度决定了算法总体的复杂度。算法一步步纳入新点，会迭代n步。但是在每个点上都有可能做回溯操作，所以scan的复杂度是不确定的。我们来以上图最坏情况为例，到第8个点时判定为false，舍弃点7，回溯。下一步判断也为false，舍弃点6，回溯。如此回溯直到算法开始的点2。这次scan倒退了高达O(n)个点，如果每次scan都是如此那么算法整体复杂度就为：O(nlogn + n * n) = O(n^2)了，那这种算法的意义也就不大了。其实上述分析并非错误，只是不够精确。O(n^2)确实是Graham Scan算法的一个上界，但是这个上界并不是紧的。问题就出在分析假定了每次都会出现回退高达O(n)个点。代码部分：https://longlongqin.github.io/archives/d4fa.html6 [Divide And Conquer]详细讲解：https://longlongqin.github.io/archives/f32f.html","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"凸包","slug":"凸包","permalink":"https://longlongqin.github.io/tags/%E5%87%B8%E5%8C%85/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"读书笔记","slug":"程序员练级攻略2018","date":"2020-03-21T17:42:57.000Z","updated":"2020-04-19T14:35:43.395Z","comments":true,"path":"archives/7b67faab.html","link":"","permalink":"https://longlongqin.github.io/archives/7b67faab.html","excerpt":"","text":"陈皓——程序员练级攻略提及的书籍&amp;手册等书籍列表：https://github.com/git-zjx/programmer_training_strategy","categories":[],"tags":[],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://longlongqin.github.io"}},{"title":"hexo中插入pdf","slug":"Hexo博客搭建/hexo中插入pdf","date":"2020-03-20T19:10:35.000Z","updated":"2020-04-19T14:38:29.545Z","comments":true,"path":"archives/448ac7f1.html","link":"","permalink":"https://longlongqin.github.io/archives/448ac7f1.html","excerpt":"法1：安装hexo-pdf插件法2：利用html语法：可以轻松设定尺寸","text":"法1：安装hexo-pdf插件法2：利用html语法：可以轻松设定尺寸安装hexo-pdf插件hexo-pdfHexo tag for embeded pdfInstall1$ npm install --save hexo-pdfNormal PDFpdf链接1&#123;% pdf http:&#x2F;&#x2F;7xov2f.com1.z0.glb.clouddn.com&#x2F;bash_freshman.pdf %&#125;本地（我的失败了，还没找到原因）1&#123;% pdf .&#x2F;bash_freshman.pdf %&#125;Google drive1&#123;% pdf https:&#x2F;&#x2F;drive.google.com&#x2F;file&#x2F;d&#x2F;0B6qSwdwPxPRdTEliX0dhQ2JfUEU&#x2F;preview %&#125;Slideshare1&#123;% pdf http:&#x2F;&#x2F;www.slideshare.net&#x2F;slideshow&#x2F;embed_code&#x2F;key&#x2F;8Jl0hUt2OKUOOE %&#125;示例：图片来源于网络利用html语法首先修改_config.yml文件将_config.yml中的post_asset_folder选项置为true1post_asset_folder: true关于这个选项的功能说明如下:当您设置post_asset_folder为true参数后，在建立文件时，Hexo会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。然后新建一篇文章1$ hexo new由于上一步已经将post_asset_folder选项设为了true所以这一步新建文章时会创建一个md文件和一个同名的文件夹为了方便叙述，我用test作为文件和文件夹名编辑test.md用vim或者别的编辑器打开test.mdtest.md文件中加入如下代码&lt;object data=&quot;./test/test.pdf&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;关于这句代码简单的解释data表示你要上传的pdf的路径,使用相对路径，将你要上传的pdf放入第二步生成的test文 件夹type和width就不说了，这里注意height不能设成100%，不然太矮了，显示效果不好可以用浏览器预览，通过F12预估一下高度。我最后代码如下，供参考&lt;object data=&quot;https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/PDF/Google_Cpp_Style_guide_CN.pdf &quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;877px&quot;&gt;这里不一定非用object标签，embed、iframe标签也一样具体参考:网页链接注意：用html方法，在我的主题中，如果它后面有文字，会显示不出来，原因不详。所以实例我放在文章底部展示了参考文章hexo-pdf官方教程hexo中插入pdf解决方法相关文章theme-hexo-pdf使用技巧—-解决hexo-pdf文件显示不全的问题","categories":[{"name":"hexo博客搭建","slug":"hexo博客搭建","permalink":"https://longlongqin.github.io/categories/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"hexo显示pdf","slug":"hexo显示pdf","permalink":"https://longlongqin.github.io/tags/hexo%E6%98%BE%E7%A4%BApdf/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"LearnCpp chapter1","slug":"C&C++/LearnCpp-chapter1","date":"2020-03-18T15:35:37.000Z","updated":"2020-04-19T14:38:29.545Z","comments":true,"path":"archives/a0a78e77.html","link":"","permalink":"https://longlongqin.github.io/archives/a0a78e77.html","excerpt":"LearnCpp-chapter1https://www.learncpp.com","text":"LearnCpp-chapter1https://www.learncpp.com0.5 介绍compiler, linker, and librariesStep 4: Compiling your source code为了编译C++程序，我们需要一个编译器。编译器主要是对每一个.cpp文件做两件事情：它检查你的代码是否符合C++的规则。如果不符合，就会报错（同时返回相应的行号）来帮助你确定什么需要修改，同时停止编译它将C++源代码翻译成机器代码文件（叫做：object file）。object file的名字通常是这种形式：name*.o* 或者 *name.obj***（其中name与.cpp文件的name是对应的）。例如：下面的三个.cpp的源文件，编译之后形成：Step 5: Linking object files and libraries编译器compiler **编译完成后，生成若干的 object files。接下来就需要链接器Linker**出马了。linker的工作主要有三方面：将所有的object files（编译之后生成的）合并成为一个可执行程序executable program此外，linker还可以链接库文件library files（library files是一个已经预编译好的代码经过“打包”，在其他程序中重用）C++有有一个扩充的库，叫做：标准库C++ Standard Library。它提供额外的功能性库，比如我们常用的iostream library你可以有选择性的去链接其他库，比如当你想写一个播放声音的程序。你肯定不想从头到尾的去写如何去读取文件、检查文件是否有效….. 这时候，我们只需要下载相关的库进行利用就方便很多了。连接器会确保所有的跨文件依赖项都正确的解析了。例如：如果你在一个.cpp文件中定义了”A”，然后在另一个.cpp文件中去使用”A”。linker就会将这两个文件联系起来。如果链接不成功，就会报错并且连接终止只要linker成功的完成所有的“object files 和 libraries ”的链接工作，你就会得到一个可执行文件，然后你就可以运行它。Makefile【注】有些开发环境使用Makefile，它是一个描述如何构建一个程序的文件（哪一个文件要编译&amp;链接，或者以不同方式处理）它是一个强大的工具。但是在本系列课程我们不回去讲解它。Steps 6 &amp; 7: Testing and Debugging如果你的可执行程序没有按照预期的工作，那么你就需要调试。Integrated development environments (IDEs)【note】step3、4、5、7（editor, compiler, linker, debugger）都是需要软件的。当然，你可以每一部分都是用独立的软件，但是有这样的一个软件包：integrated development environment (IDE)集成开发环境 将上面四步一体化。0.6 compling your first programConsole projects控制台项目没有graphical user interface (GUI)图形用户界面，它在控制台中打印text，从输入设备键盘读取信息。并且被编译成独立的可执行文件。Workspaces / solutions当创建一个项目时，许多IDE会自动给这个项目创建一个 “workspace” 或 “solution” 。workspace or solution：是一个可以容纳多个相关的项目的container。（例如，你正在写一个游戏，你想有一个单人 与 多人分开的可执行文件，那就需要创建两个项目。但是将这两个项目分开始没有意义的，因为它们属于同一个游戏的。所以，最好的就是每一个都被配置为单个工作空间/解决方案中的 一个单独项目。）0.8 C++中常见问题General run-time issues当执行程序时，控制台窗口闪烁，然后立即关闭？1、首先确保下面的这几行在你的源程序的最上部（visio studio 用户，请确认如果有 #include “pch.h” or #include “stdafx.h” ，那么让它在最顶顶顶部的）12#include &lt;iostream&gt;#include &lt;limits&gt;2、在main()函数中的结束部分（但要在return 语句之前）添加如下：12345std::cin.clear(); // reset any error flagsstd::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n'); // ignore any characters in the input buffer until we find an enter characterstd::cin.get(); // get one more char from the user避免使用：system(&quot;pause&quot;) 因为它只能在特定的操作系统中使用运行程序，得到窗口，但没有输出？有可能是你的xx安全管家等拦截的。试着关闭它们，然后重新运行程序编译成功，但是没有正确工作？去debug它General compile-time issues当编译程序时，得到一个未解析的外部符号：_main or _WinMain@16 ？说明你的编译器找不到main()函数。Visual Studio issues使用Microsoft Visual c++进行编译时，得到C1010 fatal error，并且伴随着提示信息，如：”c:\\vcprojects\\test.cpp(263) :fatal error C1010: unexpected end of file while looking for precompiled header directive”答：这种问题出现在：当microsoft visual c++编译器被设置为使用预编译头文件，但您的c++代码文件中有一个(或多个)没有将#include “stdafx.h” or #include “pch.h”作为代码文件的第一行。建议：在创建项目时，将预编译头 precompiled headers选项关闭。如果您希望保持打开预编译头文件，要修复这个问题，只需找到产生错误的文件(在上面的错误中，test.cpp是罪魁祸首)，并在文件的最顶部添加以下行:#include “pch.h”或者#include “stdafx.h”【老版本的VS使用“stdafx.h” ，当其中一个不起作用，可以换成另外一个】注意，每一个C++文件都是从这一行开始的。如果不想从这一行开始，那就在创建项目的时候关闭“预编译头文件”选项出现错误：“1MSVCRTD.lib(exe_winmain.obj) : error LNK2019: unresolved external symbol _WinMain@16 referenced in function “int __cdecl invoke_main(void)” (?invoke_main@@YAHXZ)”答：您可能已经创建了一个Windows图形化应用程序，而不是控制台应用程序。重新创建项目，并确保将其创建为Windows(或Win32)控制台项目。0.9 配置编译器:“生成（build）”配置debug configuration ：可以帮助你调试你的程序，而且也是IDE默认的。但是它会关掉所有的优化，包含调试信息（这会让你的项目变得很大、很慢）。release configuration：当你将你的程序发布给公众的时候使用release模式。这个模式会优化项目的大小和它的性能，而且不会包含额外的调试信息。所以这种模式适用于：测试你的代码的性能.0.10 配置编译器:编译器扩展c++标准定义了关于程序在特定环境下应该如何表现的规则。在大多数情况下，编译器将遵循这些规则。然而，许多编译器实现自己对语言的更改，通常是为了增强与该语言的其他版本(例如C99)的兼容性，或者是出于历史原因。这些特定于编译器的行为称为编译器扩展（Compiler extensions）。编写使用编译器扩展的程序允许你编写与c++标准不兼容的程序。使用非标准扩展的程序通常无法在其他编译器上编译(这些编译器不支持相同的扩展)，或者即使它们支持，也可能无法正确运行。注意，编译器扩展通常是默认启用的，这对初学者是不友好的，因为它会让初学者觉得某些行为是符合官方C++的标准，但是实际上是因为编译器只是过于宽松。因为，编译器扩展从来都不是必须的，如果开启可能让你误以为你写的代码是符合C++标准的。所以，建议，建议关闭编译器扩展。0.11 配置编译器:warning和error出现error提示：说明你写的代码可能不符合C++语言的标准。出现warning提示：说明编译器认为你的代码的某些地方可能有些错误，但是编译器不能百分百确定。好习惯：不要让warning提示堆积，要尽你所能的去解决warning提示。在大多数情况下出现的warning是需要我们尽量去解决的。但在极少数情况的warning提示，我们需要明确告诉编译器不要产生这个警告。C++官方不支持这样，但是有很多单独的编译器（如：visio studio xx 和GCC）会提供解决方案：利用不可移植 # pragma 指令 来暂时的关闭这个警告。好习惯：将你的经高级别调到最大，特别是在你学习的时候，他会帮你识别潜在的问题。将warnings视为errors如果在你学习的时候，最好告诉编译器让它把warning当做error对待，然后你就不得不去解决出现的warning了。0.12 配置编译器: 选择一个C++标准C++的标准有很多，如：C++98, C++03, C++11, C++14, C++17, 等. 通常情况，编译器的标准都是默认的，而不是最新的C++标准。如果你想使用指定的标准版本，需要手动设置。正在制定中的标准的名字有一些语言标准是按照他最终定案时候的年份（如，C++17是在2017年完成的）。但是，当一个新的语言标准正在制定ing的时候，我们不能确定它最终完成的时间。这个时候这个语言标准的名字 将会被最终完成时候的名字替代，（如，C++11在制作ing时，名字为C++1x，当最终完成的时候“C++1x”就会被替换），比如下面的一些：c++1x = C++11c++1y = C++14c++1z = C++17c++2a = C++20所以，如果你看见C++1Z，这就代表C++17【注意】：在VS xxxx系列的IDE中，是不能设置全局的语言标准的，你只能一个一个项目的去设置1.1 语句与程序结构Statements and the structure of a program语句语句(Statements)是一种指令类型，它使程序执行某些操作。它是最小的独立计算单元。在C++中，一个单独的语句就可能会被编译成很多机器语言指令。下面列出了很多种语句：Declaration statements(声明语句)Jump statements（循环语句）Expression statements（表达式语句）Compound statements（复合语句）Selection statements (conditionals) (条件语句)Iteration statements (loops) （循环语句）Try blocks函数与main函数函数是按照顺序执行的语句集合。每一个C++程序都必须要有一个main函数。一个程序开始执行的时候，开始于main函数中的第一条语句，然后按照顺序执行余下语句。说到函数，你可能会看到main() 或者 doSomething()，后面的括号其实起了一个说明作用。这个括号就说明他前面的那个字符是一个函数的名字。分析“hello world”1234567#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; \"Hello world!\" return 0;&#125;第一行：一个预处理指令。这个预处理器指令指示，我们希望使用iostream库的内容，它是c++标准库的一部分，允许我们从控制台上读写文本。我们需要这一行以便在第5行上使用std::cout。排除这一行将导致第5行出现编译错误，因为编译器不知道std::cout是什么。第2行是空的，编译器会忽略它。这一行的存在只是为了帮助使程序对人类更具可读性(通过分隔#include预处理指令和程序的后续部分)。第3行告诉编译器我们要编写(定义)一个名为main的函数。每个c++程序必须有一个主函数，否则它将无法编译。第4行和第7行告诉编译器哪些行是主函数的一部分。第4行上的左大括号和第7行上的右大括号之间的所有内容都被认为是主函数的一部分。这叫做函数体第5行是main函数中的第一个语句，也是运行程序时执行的第一个语句。cout(代表“字符输出”)和&lt;&lt;操作符允许我们将字母或数字发送到要输出的控制台。在本例中，我们向它发送文本“Hello world!”，将输出到控制台。此语句创建程序的可见输出。第6行是一个返回语句。当可执行程序完成运行时，程序将一个值发送回操作系统，以指示它是否成功运行。按照惯例，这个特殊的return语句将0的值返回给操作系统，这意味着“一切正常!”这是执行的程序中的最后一条语句。结尾，什么是C++ 标准库？答：一个标准库文件是一个 预编译代码的集合，它被“打包”起来，以供其他程序重用。1.2 注释正确的注释：At the library, program, or function level, use comments to describe what.Inside the library, program, or function, use comments to describe how.At the statement level, use comments to describe why.1.3 — Introduction to variablesdata：数据data就是可以被电脑移动、存储、处理的任何信息。计算机上的数据通常以一种便于存储或处理的格式存储(因此人类无法读懂)，这种格式就是：二进制（binary）Objects and variables：对象和数据RAM(random access memory)：随机存取存储器。在程序中，你可以把RAM看作一列邮箱，它可以在程序运行时存储数据。存储在内存中的单个数据，称为value在C++中，不允许直接访问内存。但可以通过object来访问内存。一旦创建object，编译器就自动的决定这个object存放在内存中的位置。object：是具有value和其他相关属性的存储区域。这样，我们就可以说，获取这个object的value，编译器直到这个value存储在内存的具体位置。也就是说，我们可以只关注使用object(对象)来存储和检索value，而且不用担心它在内存中的存储位置。object(对象)可以命名也可以不命名。有名字的object叫做：variable(变量)。这个object的名字，叫做：标识符(identifier)。在一般编程中，对象通常指内存中的变量、数据结构或函数。在c++中，“对象”的定义较窄，将函数排除在外。Variable instantiation：变量实例化为了创建一个变量，需要用一种特殊的声明：定义1int x; // define a variable named x, of type int在编译时，当编译器看到这个语句，它会告诉自己我们需要定义一个变量，变量名字叫x，类型为int。从此之后，只要编译器看到标识符x，它就知道我们在引用这个变量。程序运行时(称为：runtime)，该变量将会被实例化。变量在用来存储values之前，必须要先实例化。实例化：对象(object)将会被创建，并且会分配一个内存地址。为了便于举例，假设变量x是在内存位置140处实例化的。当程序使用变量x时，它将访问内存位置140中的值。实例化的对象有时也称为实例。Data types：数据类型Data types(更通用的称呼：type)：它告诉编译器变量将会存储什么类型的value在c++中，变量的类型必须在编译时(当程序被编译时)已知，如果不重新编译程序，就不能更改该类型。这意味着一个整型变量只能包含整型值。如果希望存储其他类型的值，则需要使用不同的变量。SummaryData is any sequence of symbols (numbers, letters, etc…) that can be interpreted to mean something.A value is a single piece of data stored in memory.【值是存储在内存中的单个数据块。】A variable is a named region of memory.【变量是一个命名的内存区域。】An identifier is the name that a variable is accessed by.【标识符是变量被访问的名称】A type tells the program how to interpret a value in memory.【类型是告诉程序如何解释内存中的值】1.4 变量赋值与初始化定义变量：12int x; // define an integer variable named xint y, z; // define two integer variables, named y and z变量赋值：12int width; // define an integer variable named widthwidth = 5; // copy assignment of value 5 into variable width初始化变量：(定义&amp;赋值同时进行)1int a = 1; //初始化变量a为1C++初始化变量的形式有三种：使用“=” copy initialization1int width = 5; // copy initialization of value 5 into variable width使用括号“()” direct initialization 【这种在一些高级数据类型上，性能较好】1int width(5); // direct brace initialization of value 5 into variable width (preferred)使用大括号“{}” Brace initialization(uniform initialization)[推荐这种]这种可以用于对象初始化一系列的数据123/*推荐第一种形式*/int width&#123; 5 &#125;; // direct brace initialization of value 5 into variable width (preferred)int height = &#123; 6 &#125;; // copy brace initialization of value 6 into variable height另外，空初始化：用空的花括号对数据进行Zero initialization。它表示对该变量初始化为0，或者为空。1int width&#123;&#125;; //zero initialization to value 0对于上述三种初始化方法，看一下下面的例子：1234567891011121314#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 1.2; int b(2.8); int c&#123; 3.1 &#125;; cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; endl; cin.clear(); cin.ignore(numeric_limits&lt;streamsize&gt;::max(), '\\n'); cin.get();&#125;运行结果：从运行结果可以看出，第1和2种方法只会基于“警告”，它们运行结果就是只把整数部分初始化给响应变量；而第三种就直接提示“出错”。变量初始化是很有必要的。如果不初始化，编译器可能报错的ヾ(≧O≦)〃嗷~1.5介绍输入输出流：cout cin endlstd::endl 与 ‘\\n’使用’\\n’的效率比std::endl高。因为：std::endl做两件事：1、将光标一刀下一行；2、它“刷新”输出(确保它立即显示在屏幕上)‘\\n’只做一件事：1、将光标一刀下一行；&lt;&lt; 、&gt;&gt;&lt;&lt;： insertion operator (&lt;&lt;)&gt;&gt;： extraction operator (&gt;&gt;)1.6 未初始化&amp;未定义初始化、赋值、未初始化：不像其他语言，C/C++在定义的时候，不会自动的给变量赋值(比如说 0)。所以说，如果一个变量被编译器分配到一个内存地址，如果他没有被人为的赋值，它默认的值就是这个内存地址原来存储的值（也叫“垃圾值”）。Initialization = 在对象被定义的同时给它赋值；Assignment = 在对象被定义之后，再赋值给它；Uninitialized = 对象只是被定义，但是还没有被赋值。所以，我们应该记住要初始化对象（因为现在，初始化对象的成本与带来的好处相比，成本不值一提）。不初始化对象，可能会出现无法预料的错误。未初始化行为，可能带来以下症状：程序每次运行都会有不同的结果；程序每次运行都会出现一个相同的错误结果；程序结果不稳定：有时结果正确，有时结果是错误的；程序似乎工作，但是稍后的结果不正确；程序崩溃；程序可以在一些编译器上运行，但在其他编译器中不能运行；1.7 关键字&amp;标识符关键字：C++17中的关键字（keywords 或者 reserved words）有84个关键字。标识符：变量、函数、类、模块、或任何其他用户自定义项目的 的名字 叫做：标识符。命名规则：标识符名字不能和保留字重名；标识符只能由字母、下划线、数字；标识符必须以 字母 或 数字 开头（“以下划线开头”的一般都是操作系统的保留字；库，或者是编译器使用的）；C++对大小写敏感，所以wa和WA和Wa和wA互不相同。1.8 常量&amp;操作符常量(literal，literal constant)：是一个已直接插入源代码的固定值。常量与变量都有一个value（和一个type）。但是，常量的值不可更改。操作符(Operators)：在数学中，操作是一种数学计算，包括0个或多个输入值(称为操作数operands)，它们产生一个新值(称为输出值)。要执行的特定操作由一个称为操作符的结构(通常是一个符号或一对符号)表示。操作符分为三类：一元操作符(Unary operators)：只有一个操作数；二元操作符(Binary operators)：有两个操作数（左边、右边各一个）；三元操作符(Ternary operators)：有三个操作数。在C++中只有一个三元操作符。1.9 表达式表达式与语句的区别？当我们需要程序执行某个操作时，使用语句；当我们需要程序计算有一个值的时候，使用表达式。表达式、语句、表达式语句？123int x; //语句不含表达式int x=5; //语句包含表达式x=5; //表达式语句总结chapter 1语句(statement)：是一种指令，它通常使程序执行某些操作，语句以分号（semicolon）结尾。预处理指令(Preprocessor directives)：告诉编译器执行一种特殊任务。在本章中，用到的是”#include &lt;iostream&gt;“","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"学习笔记/C-C","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://longlongqin.github.io/tags/C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"Let’s Build A Simple Interpreter-9","slug":"学习笔记/Let's Build A Simple Interpreter/LSBASI-9","date":"2020-03-18T06:44:30.000Z","updated":"2020-04-19T14:38:29.702Z","comments":true,"path":"archives/8632918.html","link":"","permalink":"https://longlongqin.github.io/archives/8632918.html","excerpt":"今天要学习的内容：如何parse and interpret 一个Pascal程序的定义 definition如何parse and interpret 复合语句compound statements如何parse and interpret 赋值语句(包括变量)assignment statements, including variables.介绍符号表，以及如何存储和查找变量。","text":"今天要学习的内容：如何parse and interpret 一个Pascal程序的定义 definition如何parse and interpret 复合语句compound statements如何parse and interpret 赋值语句(包括变量)assignment statements, including variables.介绍符号表，以及如何存储和查找变量。原文链接：https://ruslanspivak.com/lsbasi-part9/本节源代码：https://github.com/rspivak/lsbasi/tree/master/part9/python下面是一个简单的 Pascal程序，来介绍新概念：123456789BEGIN BEGIN number := 2; a := number; b := 10 * a + 10 * number / 4; c := a - - b END; x := 11;END.今天所学内容与前面的part1~8相比有了很大的飞跃，现在不再是像以前一样只是一个计算器了。我们要提升一下档次了😊新的语法树及规则现在，来看看新语言结构的语法树syntax diagrams 以及其对应的语法规则grammar rules)pascal语法一个Pascal语法由一下组成&lt;这不是完整的定义，会在后面文章慢慢扩展&gt;：BEGIN开头中间是复合语句compound statement一个点(dot) “.”结束compound statementcompound statement是一个block(区块)：它标有BEGIN 和 END ，中间可能(也可能没有)包含有一段语句或其他的复合语句compound statement所有嵌入在复合语句中的句子，除了最后一个，其他的都要以分号“;”结尾在block中的最后一个句子(last statement)可能或可能没有 中断分号“;”如下面所示：1234“BEGIN END”“BEGIN a := 5; x := 11 END”“BEGIN a := 5; x := 11; END”“BEGIN BEGIN a := 5 END; x := 11 END”statement list一个statement list 含有0个或多个语句，其位于compound statement内。如上面的例子statement一个statement可以是一个 *compound statement， 一个赋值语句assignment statement，或者是一个空语句*empty statement。assignment statement一个赋值语句的组成：一个变量 后面跟着 一个指定的token（two characters, ‘:’ and ‘=’） 后面跟着 一个表达式。如下所示：12“a := 11”“b := a + 9 - 5 * 2”varible一个 变量variable是一个标识符identifier。我们将用ID token来表示variables，这个token的value是变量的名字(如，‘a’、‘number’、‘x’…..)。在下面的一个block的代码中的‘a’、‘b’就是变量：1“BEGIN a := 11; b := a + 9 - 5 * 2 END”empty statement一个空语句表示一个语法规则，这个语法规则没有更深层的产生式productions。我们使用empty_statement语法规则来描述语法分析中末尾的statement_list ；同时也允许一个空的复合语句compound statements表示为：‘BEGIN END’factorfactor的规则更新为处理变量。完整的语法1234567891011121314151617181920212223242526program : compound_statement DOTcompound_statement : BEGIN statement_list ENDstatement_list : statement | statement SEMI statement_liststatement : compound_statement | assignment_statement | emptyassignment_statement : variable ASSIGN exprempty :expr: term ((PLUS | MINUS) term)*term: factor ((MUL | DIV) factor)*factor : PLUS factor | MINUS factor | INTEGER | LPAREN expr RPAREN | variablevariable: ID上面的语法中，在compound_statement rule 中没有用“*”来表示重复（0或多次），而是明确的制定了 statement_list rule。这是另一种方法来表示“0或多次”的操作。这在后面的语法分析器（如PLY）会派上用场。我还将规则：“(PLUS | MINUS) factor”也细分成两个规则。修改lexer,parser,interpreter为了支持更新后的语法，我们需要修改我们的此番分析器、语法分析器和解释器。lexer的改变下面是我们此番分析器有改动的地方：为了支持Pascal程序的定义、复合语句、赋值语句、变量。我们需要新的token类型：（Pascal program’s definition, compound statements, assignment statements, and variables）BEGIN (标记复合语句的开始)END (标记复合语句的结束)DOT (一个token表示 点，用于Pascal程序的定义)ASSIGN (一个token表示两个字符， ‘:=’)在Pascal中，赋值操作符不同于其他语言（如C语言用 “=”）SEMI (一个token表示分号‘ ; ’ 。用来标记在复合语句中的一个句子的结尾)ID（一个token表示 有效的标识符。）有时候，为了区分不同token（它们都以相同的字符为开头，如：‘:’ vs ‘:=’ or ‘==’ vs ‘=&gt;’），我们需要在不消耗下一个字符的情况下去查看输入缓冲区。为了这个特殊的目的，我介绍一种查看方法peek method，这种方法将帮助我们标记赋值语句。这个方法不是必要的，但是还是想早一点介绍一下，并且它也使得get_next_token函数简洁一些。它所做的目的就是：从文本缓冲区返回下一个字符，但不增加self.pos的值。下面是这个方法的代码：123456def peek(self): peek_pos = self.pos + 1 if peek_pos &gt; len(self.text) - 1: return None else: return self.text[peek_pos]因为pascal中的 变量 和 保留字 都是 标识符。所以我们需要用一个方法来区分它们，方法为：_id。它工作的原理：词法分析器对这个字母、数字序列进行检查，看这个序列是否是保留字reserved keyword，如果是，就返回一个预先构造的token来表示这个保留字；如果不是，就返回一个新的ID token（它的值就是这个字符串）（lexeme）.下面是它的代码：1234567891011121314RESERVED_KEYWORDS = &#123; 'BEGIN': Token('BEGIN', 'BEGIN'), 'END': Token('END', 'END'),&#125;def _id(self): \"\"\"Handle identifiers and reserved keywords\"\"\" result = '' while self.current_char is not None and self.current_char.isalnum(): result += self.current_char self.advance() token = RESERVED_KEYWORDS.get(result, Token(ID, result)) return token词法分析器的函数get_next_token的改变:12345678910111213141516171819def get_next_token(self): while self.current_char is not None: ... if self.current_char.isalpha(): return self._id() if self.current_char == ':' and self.peek() == '=': self.advance() self.advance() return Token(ASSIGN, ':=') if self.current_char == ';': self.advance() return Token(SEMI, ';') if self.current_char == '.': self.advance() return Token(DOT, '.') ...parser的改变下面是它的总的变化：新的AST结点：Compound AST node：表示一个复合语句，在它的孩子的变量中包含着语句节点的列表；1234class Compound(AST): \"\"\"Represents a 'BEGIN ... END' block\"\"\" def __init__(self): self.children = []Assign AST node：表示赋值语句。它的左孩子的值是Var node，右孩子结点存储着由expr解析器返回的结点。12345class Assign(AST): def __init__(self, left, op, right): self.left = left self.token = self.op = op self.right = rightVar AST node：表示一个变量，它的value就是着这个变量的名字12345class Var(AST): \"\"\"The Var node is constructed out of ID token.\"\"\" def __init__(self, token): self.token = token self.value = token.valueNoOp node：用来表示一个空语句。如‘BEGIN END’ 是一个有效的复合语句但没有句子。12class NoOp(AST): pass我们之前讲过，在我们的递归的语法分析器中每一个语法的规则都有相应的函数(method)。这次将增加7个新的函数。这些函数都是用于语法分析中新的语法和新的AST结点。下面就是：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374def program(self): \"\"\"program : compound_statement DOT\"\"\" node = self.compound_statement() self.eat(DOT) return nodedef compound_statement(self): \"\"\" compound_statement: BEGIN statement_list END \"\"\" self.eat(BEGIN) nodes = self.statement_list() self.eat(END) root = Compound() for node in nodes: root.children.append(node) return rootdef statement_list(self): \"\"\" statement_list : statement | statement SEMI statement_list \"\"\" node = self.statement() results = [node] while self.current_token.type == SEMI: self.eat(SEMI) results.append(self.statement()) if self.current_token.type == ID: self.error() return resultsdef statement(self): \"\"\" statement : compound_statement | assignment_statement | empty \"\"\" if self.current_token.type == BEGIN: node = self.compound_statement() elif self.current_token.type == ID: node = self.assignment_statement() else: node = self.empty() return nodedef assignment_statement(self): \"\"\" assignment_statement : variable ASSIGN expr \"\"\" left = self.variable() token = self.current_token self.eat(ASSIGN) right = self.expr() node = Assign(left, token, right) return nodedef variable(self): \"\"\" variable : ID \"\"\" node = Var(self.current_token) self.eat(ID) return nodedef empty(self): \"\"\"An empty production\"\"\" return NoOp()factor 函数的修改：12345678910111213141516def factor(self): \"\"\"factor : PLUS factor | MINUS factor | INTEGER | LPAREN expr RPAREN | variable \"\"\" token = self.current_token if token.type == PLUS: self.eat(PLUS) node = UnaryOp(token, self.factor()) return node ... else: node = self.variable() return nodeparse ：更新之后，它从程序的定义开始语法的分析：123456def parse(self): node = self.program() if self.current_token.type != EOF: self.error() return node下面是一个简单的程序：123456789BEGIN BEGIN number := 2; a := number; b := 10 * a + 10 * number / 4; c := a - - b END; x := 11;END.它的解析树为（为了简洁，下面的树中变量的名字所在结点就是Var node， Assign node赋值结点表示为 ‘:=’ ）：interpreter的改变为了解释新的AST结点，我们需要在interpreter中添加相应的visitor 函数：visit_Compoundvisit_Assignvisit_Varvisit_NoOp其中，visit_Compound：遍历它的孩子节点，visit_NoOp：什么都不做。123456def visit_Compound(self, node): for child in node.children: self.visit(child)def visit_NoOp(self, node): passvisit_Assign：当我们给变量赋值时，需要将该变量的值存到某个地方，待用。这也就是此函数的功能：123def visit_Assign(self, node): var_name = node.left.value self.GLOBAL_SCOPE[var_name] = self.visit(node.right)这个函数存储了一个键-值对key-value pair（一个变量名、一个变量的值），存储在symbol table GLOBAL_SCOPE。what is symbol table?symbol table是一个抽象数据类型（abstract data type (ADT)），用于跟踪源码中各种符号。目前的符号类型还只有变量，我们用Python字典趋势线符号表的ADT。（在这里用符号字表 实现的笨拙：因为它不是一个带有特殊方法的独立类，而是一个简单的Python字典，而且它的另外职责是 内存空间。在后面的文章中，原作者将会带我们了解symbol tables的细节）让我们来看一下“a := 3;” 的AST，和它的 symbol table （visit_Assign 函数处理前和处理后的）：现在让我们看看句子：“b := a + 7;”的AST：visit_Var：可以看出，赋值语句得到右半部分：“a + 7” 提及变量a，所以我们要先知道变量a的value，这就是visit_Var函数要干的事情：1234567def visit_Var(self, node): var_name = node.value val = self.GLOBAL_SCOPE.get(var_name) if val is None: raise NameError(repr(var_name)) else: return valvisit 一个 Var 结点：它首先得到变量的名字；然后这个变量名字作为进入GLOBAL_SCOPE dictionary的key🔑去寻找变量的value，如果找到了 就返回变量地值，如果找不到就NameError函数伺候。下面是“b := a + 7;”的AST和符号表（赋值前和复制后）上面就是今天所有需要进行的update了。At the end of the main program, we simply print the contents of the symbol table GLOBAL_SCOPE to standard output.Let’s take our updated interpreter for a drive both from a Python interactive shell and from the command line. Make sure that you downloaded both the source code for the interpreter and the assignments.txt file before testing:Launch your Python shell:123456789101112131415161718192021$ python&gt;&gt;&gt; from spi import Lexer, Parser, Interpreter&gt;&gt;&gt; text &#x3D; &quot;&quot;&quot;\\... BEGIN...... BEGIN... number :&#x3D; 2;... a :&#x3D; number;... b :&#x3D; 10 * a + 10 * number &#x2F; 4;... c :&#x3D; a - - b... END;...... x :&#x3D; 11;... END.... &quot;&quot;&quot;&gt;&gt;&gt; lexer &#x3D; Lexer(text)&gt;&gt;&gt; parser &#x3D; Parser(lexer)&gt;&gt;&gt; interpreter &#x3D; Interpreter(parser)&gt;&gt;&gt; interpreter.interpret()&gt;&gt;&gt; print(interpreter.GLOBAL_SCOPE)&#123;&#39;a&#39;: 2, &#39;x&#39;: 11, &#39;c&#39;: 27, &#39;b&#39;: 25, &#39;number&#39;: 2&#125;And from the command line, using a source file as input to our interpreter:12$ python spi.py assignments.txt&#123;&#39;a&#39;: 2, &#39;x&#39;: 11, &#39;c&#39;: 27, &#39;b&#39;: 25, &#39;number&#39;: 2&#125;If you haven’t tried it yet, try it now and see for yourself that the interpreter is doing its job properly.summary让我们来总结一下，你今天扩展了Pascal解释器的哪些部分：添加新的语法规则添加新的token，和它对应词法分析器中的方法（也更新了get_next_token）在 parser 中为新的语法结构添加新的AST结点在（递归下降的）语法分析中 添加相应对应新语法规则的新函数，在interpreter中增添了新的visitor函数新增 用于存储和查找变量的字典HACKS现在要介绍一下“hacks”（不完善的地方），并且随着系列文章的深入，我们还将一步步解决这些内容：上图中的不完善的地方，也就是这些：program 语法规则目前不完善，在后续文章会扩展；Pascal语言是一个静态类型语言，在使用变量之前必须要先声明；没有类型检测，目前还不是什么大问题。但当有更多类型的时候，就需要类型检测；符号表目前为止，都是用“/”来表示除法。但在Pascal语言中，必须要用关键字“div”来表示整数除法；在Pascal语言中，标识符 和 保留字 是不区分大小写的(case insensitive)。但是在目前的文章中，我们把它设计成了区分大小写。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let's Build A Simple Interpreter","slug":"Let-s-Build-A-Simple-Interpreter","permalink":"https://longlongqin.github.io/tags/Let-s-Build-A-Simple-Interpreter/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"Front-matter的规则","slug":"Hexo博客搭建/Front-matter的规则","date":"2020-03-16T14:08:32.497Z","updated":"2020-03-17T08:15:54.491Z","comments":true,"path":"archives/138a.html","link":"","permalink":"https://longlongqin.github.io/archives/138a.html","excerpt":"文章写作时，的front matter 的参数","text":"文章写作时，的front matter 的参数参数描述layout布局title标题date建立日期updated更新日期comments开启文章的评论功能tags标签（不适用于分页）categories分类（不适用于分页）permalink覆盖文章网址其中，分类和标签需要区别一下，分类具有顺序性和层次性，也就是说Foo，Bar不等于Bar，Foo；而标签没有顺序和层次。注意：每个冒号后面是有一个空格的。1234567891011121314151617title: 文章的front-matter规则 // 你的博客名字 date: 2019-08-10 21:44:44 //文章创建的日期author: longlongqin //作者名字img: /medias/banner/6.jpg //文章的显示的时候的背景coverImg: /medias/banner/6.jpg top: truecover: truetoc: truepassword: mathjax: truesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要tags:- Hexo- Github- 博客categories:- 软件安装与配置配置选项默认值描述titleMarkdown 的文件标题文章标题，强烈建议填写此选项date文件创建时的日期时间发布时间，强烈建议填写此选项，且最好保证全局唯一author根 _config.yml中的 author文章作者imgfeatureImages中的某个值文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: http://xxx.com/xxx.jpgtoptrue推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章coverfalsev1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中coverImg无v1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片password无文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项toctrue是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项mathjaxfalse是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行summary无文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories无文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类tags无文章标签，一篇文章可以多个标签reprintPolicycc_by文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个注意:如果 img 属性不填写的话，文章特色图会根据文章标题的 hashcode 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。date 的值尽量保证每篇文章是唯一的，因为本主题中 Gitalk 和 Gitment 识别 id 是通过 date 的值来作为唯一标识的。如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 _config.yml 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：开源中国在线工具、chahuo、站长工具。","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://longlongqin.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"front-matter配置","slug":"front-matter配置","permalink":"https://longlongqin.github.io/tags/front-matter%E9%85%8D%E7%BD%AE/"}]},{"title":"Let’s Build A Simple Interpreter-8","slug":"学习笔记/Let's Build A Simple Interpreter/LSBASI-8","date":"2020-03-15T10:04:49.000Z","updated":"2020-03-18T06:21:29.606Z","comments":true,"path":"archives/ae12.html","link":"","permalink":"https://longlongqin.github.io/archives/ae12.html","excerpt":"今天，将要在前面的基础上，添加一元操作符unary operators：unary plus (+) and unary minus (-) operators。","text":"今天，将要在前面的基础上，添加一元操作符unary operators：unary plus (+) and unary minus (-) operators。今天将要完成的任务：扩展语法，能够处理“+”、“-”一元操作符；添加一个新的结点类：UnaryOp AST node class；扩展语法分析器parser，生成含有UnaryOp nodes结点的抽象语法树；扩展解释器interpreter。并且增添一个新的visit_UnaryOp method函数，它可以解析一元操作符现在，开始吧。一元操作符一元操作符是什么？二元操作符：之前，我们的计算器都是围绕着这些二元操作符 (+, -, *, /)在工作，这些操作符操作两个操作数（the operators that operate on two operands.）。一元操作符unary operator ：那么，我们就能知道一元操作符是：一个操作符只操作一个操作数。（A unary operator is an operator that operates on one operand only.）一元操作符的规则下面是一元操作符“+、-”的规则：一元操作符-：它会使它的操作数取反（negation）一元操作符+：他对于它的操作数没影响，即，它的操作数不改变什么一元操作符比二元操作符（+, -, *, and /）有着更高的优先级（precedence）例子：“+ - 3”其中，这第一个位置的“+”表示一元操作符加号操作；第二个位置的“-”表示一元操作符减号操作。所以，“+ - 3”就相当于“+ (- (3))”，即，等于-3。【注】：这里的-3平常情况说它是一个负整数（negative integer），但是在这里我们称它是：一个一元操作符“-”，它的操作数是3。“5 - - 2”在这个表达式中，第一个“-”表示一个二元操作符：减法。第二个“-”表示一个一元操作符：取反。比如下面的一些例子，也是这个样子：开始修改将一元操作符添加入语法修改factor因为，一元操作符的优先级高于二元操作符。所以，函数factor需要需改。它之前的规则为：更新后的，规则为：从更新后的factor函数的规则，可知：它扩展之后能够引用它本身。这样我们就能够写出类似于：- - - + - 3”这样的式子，这是合法的带有很多一元操作符的表达式。其实，这里修改语法，只用修改factor函数的产生式，其他的expr、term产生式不变：扩展抽象语法树的结点类下一步就是要添加一个AST node class，来表示一元操作符：1234class UnaryOp(AST): def __init__(self, op, expr): self.token = self.op = op self.expr = expr这个函数有两个参数：op、expr：op：代表一元操作符的token（+或-）expr：表示一个AST的结点（要与expr函数区分，这两个知识名字一样，但是代表的东西不一样）扩展语法分析器parser之前我们修改了语法规则，当中的factor函数的产生式也发生了变化，所以现在我们将要修改代码，使其能够处理产生式中的 “(PLUS | MINUS) factor” 子规则：1234567891011121314151617181920def factor(self): \"\"\"factor : (PLUS | MINUS) factor | INTEGER | LPAREN expr RPAREN\"\"\" token = self.current_token if token.type == PLUS: self.eat(PLUS) node = unaryop(token, self.factor()) return node elif token.type == MINUS: self.eat(MINUS) node = unaryop(token, self.facot()) return node elif token.type == INTEGER: self.eat(INTEGER) node = NUM(token) return node elif token.type == LPAREN: self.eat(LPAREN) node = self.expr() self.eat(RPAREN) return node扩展解释器Interpreter现在我们还需要扩展解释器类Interpreter class ，向其中添加visit_UnaryOp 函数，来解释一元操作符结点：123456def visit_UnaryOp(self, node) op = node.op.type #token的类型 if op == PLUS: return +self.visit(node.expr) elif op == MINUS: return -self.visit(node.expr)例子让我们看一个例子，表达式 “5 - - - 2” ，通过我们的解析器来证实这个新的visit_UnaryOp函数确实起作用了。下面是如何从Python shell中实现:12345678910111213&gt;&gt;&gt; from spi import BinOp, UnaryOp, Num, MINUS, INTEGER, Token&gt;&gt;&gt; five_tok = Token(INTEGER, 5)&gt;&gt;&gt; two_tok = Token(INTEGER, 2)&gt;&gt;&gt; minus_tok = Token(MINUS, '-')&gt;&gt;&gt; expr_node = BinOp(... Num(five_tok),... minus_tok,... UnaryOp(minus_token, UnaryOp(minus_token, Num(two_tok)))... )&gt;&gt;&gt; from spi import Interpreter&gt;&gt;&gt; inter = Interpreter(None)&gt;&gt;&gt; inter.visit(expr_node)3上面的AST树看起来是这样的:","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let's Build A Simple Interpreter","slug":"Let-s-Build-A-Simple-Interpreter","permalink":"https://longlongqin.github.io/tags/Let-s-Build-A-Simple-Interpreter/"}]},{"title":"构造凸包——Divide And Conquer","slug":"学习笔记/计算几何/Convex-Hull/Divide-And-Conquererer","date":"2020-03-15T08:12:57.000Z","updated":"2020-03-22T06:58:07.022Z","comments":true,"path":"archives/f32f.html","link":"","permalink":"https://longlongqin.github.io/archives/f32f.html","excerpt":"Graham Scan算法说明了凸包构造问题的下界O(nlogn)是可以达到的。其实O(nlogn)的算法远不止这一种，分治法就是一种能达到O(nlogn)复杂度的思想。在此引入运用分治思想的两种算法来构造凸包。","text":"Graham Scan算法说明了凸包构造问题的下界O(nlogn)是可以达到的。其实O(nlogn)的算法远不止这一种，分治法就是一种能达到O(nlogn)复杂度的思想。在此引入运用分治思想的两种算法来构造凸包。归并排序与分治思想引入新算法之前依旧先来回顾一个经典排序算法：归并排序（merge sort）。归并排序的基本流程如下：算法分为两个阶段：分（divide）和归并（merge）。分的阶段将待排序列均分到一个个子序列（如图中划分到单个元素）。归并阶段将分好的子序列两两合并成有序序列，重复合并的过程直到整体归为一个序列。归并过程共logn步，每步耗费n的时间，总体复杂度为O(nlogn)。归并排序的过程就是一个典型的分治（divide-and-conquer）策略。凸包构造问题也可以套用这种策略来分而治之，逐步求解。我们可以将待处理点集S分为同等规模的两个子点集，并分别对其求凸包。有了两个子解后，问题就变成了如何适当加一些边，将两个子凸包merge成整体解。分治法核心的任务就是如何merge。Divide And Conquer（1）预处理为star-shaped polygon分治法解决问题的过程可以概括为：大事化小，小事化了。就是首先将问题划分为易求解的子问题，子问题套用已知方法解答即可。例如子凸包的构造就能用Graham Scan来解决。Graham Scan解决问题的前提是：参照基准点，其他点按极角有序排列，也就是构成了一个有序的星形多边形（star-shaped polygon）。首先要做的就是将两个子凸包预处理成两个star-shaped polygon。star-shaped polygon星形多边形是什么呢？其实就是在多边形内部存在一个点A，这个点与多边形内任意一点的连线都在多边形内部，就叫做星形多边形，这一个点A就叫做多边形的内核。由于任何一个凸多边形都是star-shaped polygon，它必然有一个核，其他点按极角有序排列。问题在于如何找到一个公共核，使得两个子凸包同时关于这个核是极角有序排列的。也就是公共核处于两个凸包的交部分，这样是最好处理的情况（如下左图）。不过还有可能有其他情况，不能找到公共核（如下中图），甚至两个凸包根本不相交（如下右图）：这就要将分治策略分不同情况来实现：两个子凸包有公共核：先找其中一个子凸包的核：我们可以任取该子凸包上的三点构成三角形，求三角形重心作为核。然后判断这个核是否也在另一个子凸包内部，若判定为真，就是有公共核的最简单情况。判定方法也就是之前提过的in convex polygon test，对凸包每条边做to left test即可，在线性时间内可以判定。找到公共核之后，进行凸包形成：—-用二路归并相对于公共核，两个子凸包的各自有序排列，相互交错。要做的就是将二者点序列合并，方法正是经典的二路归并，线性时间可以完成。最后进行Graham Scan即可得到大凸包。一个子凸包的核落在另一个子凸包外部：存在公共核的情况处理是很简单的，再看第一个子凸包的核落在第二个子凸包外部的情况。如下图所示：这中情况与增量构造法的情况很相似，P1的核x相对于P2就是一个新加入的点。做出两条support line：x→t和x→s，舍弃P2上t→s路径的点即可。这样P2中剩余点与x构成了一个星形多边形，x也成为了P2的核。这就转化成了第一种有公共核的情况。Divide And Conquer（2）上述分治策略的算法过于复杂，所以引入一种更加简明的分治策略。这种分治策略也会为三角剖分等问题提供思路。首先规定一种点集划分的策略。假设待合并的两个子凸包是沿着某方向是分离的，二者不相交（Divide And Conquer（1）中是有相交的）。例如下图凸包P1和P2就是相互分离的：这样划分会使得合并更加简明，不必区分多种复杂情况。预处理为了满足这种划分策略，需要引入一种预处理，也就是一个x方向的排序过程（X-sorting）。排序后就可取点x坐标的中值，将点集划分为规模相当的左右两个子集。每个凸包都有其最左点l和最右点r，如上图。merge操作现在merge操作就是将两个左右相离的两个子凸包合并为一个大凸包的过程了。运算的关注的正是两对l和r点。先直观感受一下merge操作要添加的新极边：上下两条紫色边正是要求的新边，又称支撑边（support line），并且每次merge只会增加两条新边。两条边类似两个圆的公切线（common tangent），将二者连接起来。注意，注意，注意：眼睛可能会欺骗你直观上感觉，两条support line正是两个子凸包的最高点t和最低点b相互连接得到的，这些点只需线性时间就能找到。当真如此的话凸包构造的下界就成了O(n)，显然直觉是错误的。例如下面的两种情况，support line就和b、t两点没有直接关系了：)构造support line的过程需要缜密的分析，并非凭直觉能得到的。缝合（stitch）—构造support line将两个子凸包连接的过程更像古代妇女用针将两块布缝合在一起（但是这里的两个凸包的间距是不能变的，仅仅是用线将其连接在一起。而且这里连接只需要最后找出来的那两条线，其余剩下的中间“工具线”都要舍去）。构造过程首先从左凸包的r点和右凸包的l点连线开始，以这条线为基础逐步得到support line。注意一个细节问题：如何得到各子凸包的l点和r点。每次合并都会产生新的凸包，所以凸包是一个动态的结构。当然可以每次计算出最左点和最右点，只需要线性时间。但是这并不是最优的方式。考虑分治的思想，就整个merge流程来讲，是自底向上将子凸包两两合并的过程。因此只要在最底层上最小的子凸包中记录最左点和最右点，每次merge更新一下这两个变量即可，只需要O(1)的常数时间！这种优化对整体的复杂度上线nlogn虽然没有影响，也能为程序节省一部分的开销。缝合上半部分再看如何将最初的r-l线变成support line，在此以寻找upper support line为例（上切线，相应的还需要计算下切线）。算法的核心依然是to left test。首先看l点，从r-l线出发，可以发现相对于对于r→l时，l的前驱、后继是LR型的。而我们想要的是RR型的。所以必须要找l的前驱。直到在某一个时刻，我们找到了l的一个前驱点满足RR型：再看r点，同样的，从此时的状态，来观察r的类型：是RL型的。要想成为LL型，r必须要找它的后驱。在某一时刻，r找到r的后继（就是该凸包点t）使其满足LL型：反过来继续看l，此时，具体的说应该是检测l的前驱点l&#39;，经检测，l&#39;已经不再满足RR型了，编程了LR型，所以还要继续寻找它的前驱点，使其再次满足RR型。某一时刻，找到它的前驱（就是该凸包的点t），使其成为RR型。反过来继续看r，此时，更准确的应该说是在看r&#39;，经检测，该店符合LL型。至此，所谓的r和l都已经符合RR或LL型了。从而已经找到upper support line了。结束上半部分。回顾由r-l线逐步推进得到support line的过程，每次操作一个端点，得到是一种“Z”字形（zig-zag）的推进轨迹。操作点的切换由另一点满足要求决定，而算法停止的依据是两个端点同时满足了要求。这种方式类似快速排序构造轴点的过程，左右两轴点交替操作，直到二者都满足要求时算法停止。缝合下半部分缝合下半部分的流程与，上半部分流程一样。时间复杂度分析一下算法时间复杂度。算法首先要按照x坐标排序，排序复杂度为O(nlogn)。再看merge过程，无论是左侧子凸包还是右侧子凸包，对于其每个点的操作至多只有以此，也就是每次归并是线性时间。归并共logn次，算法的总体复杂度就是O(nlogn)了。更多的考虑在这些算法讲解中，通常都是不考虑退化的情况，如，三点共线……最后总结一下第二种分治法的特点。此前Jarvis March算法虽然以平方复杂度为上界，但其”输出敏感性“使得实际复杂度为O(hn)，最好情况下仅甚至为线性。例如如下情况：Jarvis March算法的复杂度变为了O(4n)，而此时分治法依旧会经历按部就班的X-sorting，一上来就注定了O(nlogn)的复杂度，然后经历同样O(nlogn)的merge过程。也就是说这种分治法在各种情况下的表现都是很均匀的。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"计算几何","slug":"计算几何","permalink":"https://longlongqin.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"}]},{"title":"构造凸包-Graham Scan法","slug":"学习笔记/计算几何/Convex-Hull/Graham-Scan","date":"2020-03-14T09:40:32.000Z","updated":"2020-03-22T15:09:59.625Z","comments":true,"path":"archives/3478.html","link":"","permalink":"https://longlongqin.github.io/archives/3478.html","excerpt":"","text":"Graham Scan算法的流程假设待处理点集S共有n个点。1、预处理预排序(presorting）Graham Scan首先要做的是一个预处理排序操作（presorting）。即找到某个基准点，然后将其余所有的点按照相对于基准点的极坐标排序。如下图：点的排序可以套用任意排序算法的框架，只是将排序对象由数值变为了平面上的点，而比较器改为to left test实现。如何找出第一个点：点1？以点1为基准点，其余点按照相当于点1的极角依次排序为2、3、4……理论上讲任何一个点都能当第一个基准点，为了简化算法通常选择lowest-then-leftmost point（LTL）作为基准点。找出起始边对于与基准点1极角最小的点，也就是图中点2（假设没有三点共线的情况）。将点1和点2作为算法的起始点。将起始边 与 剩下的n-2条边分别存储在不同的栈(stack)中：算法开始前先将起始点1和2入栈S，其他的n-2个点入栈T，如下图。注意S和T中元素的入栈顺序。至此预处理已经完成。Graham Scan用到的数据结构。整个算法非常简明，核心数据结构只有两个栈，分别记作栈S和栈T。便于理解我们将S和T画成开口相对的形式，如上图。2、scan操作(此处为逆时针扫描)完成预处理之后，就能开始算法的核心：scan操作。scan的过程主要关注三个点：栈S的栈顶（S[0]）、次栈顶（S[1]）和栈T的栈顶（T[0]）。也就下图红色标注的三个点：对这三个关注的点，进行检测，检测的框架为：可以观察到，每次待处理的S[0]和S[1]构成的边一定是一条极边（如上图点1和点2），算法关键步骤就是对边这条极边和T[0]做to left test，判断T[0]位于边S[0]S[1]的左边还是右边。若在左边则继续拓展，若在右边则否定掉此前认定的极边。无论结果如何，每次判定都会将问题规模缩小一个单元，算法结束时T最终肯定为空。T空后，S中存留下的点正是凸包的极点，这些点自底而上正是凸包边界点的逆时针遍历，也得到了整个凸包构造问题的解。举例1、先来看一个最简单的例子，即点集S中所有的点都在凸包边界上。如下图：先找到LTL，也就是图中点1。然后基于点1对其余点按极角排序为点2、3、4……（实际上以一个点为中心的有序的点集，构成了所谓的星形多边形（star-shaped polygon），中心点正是星形多边形核（kernel）的一部分。凸多边形必然是星形多边形，反之则不然。）然后找到点1的后继2，点1和点2构成第一条极边。初始化栈S和栈T。现在要关心S[1], S[0]和T[0]，就是点1，2和3。点3位于边12左侧，to left关系为true，S.push ( T.pop() )，向前拓展了一条暂定极边。接下来重复上述过程。考虑点2，3和4。to left关系为true，S.push( T.pop() )……最终栈T空，算法结束，凸包由栈S自底向上得到。S和T的变化过程如下图：2、上面列举了最简单的情况下Graham Scan的过程，接下来列举一个更有代表性的实例深入算法的细节。输入的点集S，并进行预处理排序，并初始化栈S、T，如下图：接下来对点1，2和3进行to left测试，本质上就是判断边2→3（图中黄色边）能否被暂时采纳。测试结果为true，暂时采纳边2→3，S.push( T.pop() )。如下图所示：注意图中蓝色边表示已经被暂时接纳的边，也就是算法暂时认定的极边。上一次操作将蓝色边推进一个单元接下来关注点2，3和4，来判断下一条黄色边3→4能否被接纳。to left测试为true，S.push( T.pop() )，接纳边3→4。如下图右侧所示：然后判断点3，4和5。点5在边3→4的右侧，即to left测试为false。S.pop()，也就是判断出点4不可能为极点，丢弃4。因此算法回溯到点3，判断点2，3和5的关系。5在2→3的左侧，暂时接纳边3→5，S.push( T.pop() )。如下图：算法经历了无效操作，进行了回溯，得到了目前来说最优的“极边”。虽然这些”极边“不一定能最终保留，但问题的规模得到了削减。下一次scan考察的就是3，5和6了。3，5和6的to left测试为false，S.pop()，舍弃点5。然后考察点2，3和6，to left测试为false，S.pop()舍弃点3。如下图：……..………直遍历完剩下其他点，凸包就构造完成。验证算法的正确性思路上的正确性了解了算法的整体流程之后，我们再来论证一下算法的正确性。证明一个算法正确性的方法有很多，在此选用数学归纳法。数学归纳法的思想可用多米诺骨牌类比，要做的无非是两件事：证明第1张骨牌会倒；证明如果第n张骨牌会倒则第n+1张骨牌也会倒下。Graham Scan过程就是一个个引入点的过程。每当我们得到第k个点的时候，算法所得到的就是前k个点对应的“最好的凸包”。因此当k = n时得到的是整体的凸包。归纳的第一步就是证明k = 3时得到的是当前点集S‘ = {1，2，3}中的极边——也就是证明第1张骨牌会倒。显然边1→2是S’的一条极边。而根据预处理的方式，3相较于1的极角一定大于2，因此点3一定在边1→2的左侧，因此边2→3会得到保留。对于这三个点来说，任意两条边一定都是极边，2→3也是一条极边。然后证明：假设已经处理到第k个点，得到的是前点集S’ = {1，2，3，…，k}中所谓“最好的凸包”。根据算法处理方式，接下来从S’’ = {1，2，3，…，k，k+1}得到的结果是否也是正确的——也就是证明第n张骨牌会倒，则第n+1张骨牌也会倒下。预处理的方式是对2~n所有点相较于点1按极角排序，因此下一个要处理点k+1一定出现在线1→k的左侧，也就是下图蓝色区域和绿色区域（假设k = 9）：而根据目前接纳的最后一条极边( k-1)→k （例如图中8→9）来划分，点k+1可能出现的区域又分为两块，即该极边的左侧（绿色区域）和右侧（蓝色区域）。这也正对应于算法判定的两个分支。左侧：左侧的情况很简单，点k+1显然会是一个新的极点。Graham Scan要做的正是暂时接纳边k→k+1，拓展了一个新的单位。右侧：再看k+1落在右侧的情况。如下图点10：Graham Scan要做的是丢弃点k（图中点9），也就是判定出点k不可能是极点。这样做的原因：是引入点k+1后，点k一定会被包含在三角形(1, k-1, k+1)内部。如图中点9一定包含于三角形(1, 8, 10)内部。正如极点法中排除非极点的做法，点k被排除是正确的做法。接下来点k-1，k-2等（如图中点8，点7等）也可能是非极点，按照算法的流程，它们总会被判定在某个三角形的内部（例如点7在三角形(1, 5, 10)内部）而被排除，直到left test为true，回溯停止。换个角度考虑，回溯停止时得到的新边正是增量构造法中每步得到的support line，即切线。例如图中线5→10正是算法当前保留的”凸包“的切线。这也能论证Graham Scan处理方式的正确性。至此，算法思路上的正确性已经证明完毕。表述方式的正确性接下来还要考虑算法的表述方式是否有漏洞：代码中每次to left test之前并没有判断S栈中是否有≥2个元素。这也可以由预处理的方式来论证。点1选取的是LTL，而点2是相对于点1极角最小的点，这样的做法保证了除了点1和点2之外所有的点一定是在边1→2左侧的。因此算法回溯最多到点2，永远不可能把点2丢弃，S中元素任何时候至少有两个。Graham Scan算法的正确性论证完毕。预处理操作的必要性最后来思考一下预处理操作：presorting。仔细回顾上述论证过程会发现，每一步的正确性都是建立在最初的排序上的。那么这个预处理排序真的是必要的吗？可以来举极端的反例，每次选取下一个点都是随机的，例如下图的路径：上图中从点1开始出发进行to left测试，可以发现，每次判定结果都为true，最终所有的点都被保留了下了，而显然这并不是一个凸包。因此presorting是整个算法成立的基础。分析复杂度上面证明了Graham Scan算法的正确性，接下来分析其复杂度是否满足O(nlogn)，实现所谓的最优算法。直观上无法断定Graham Scan是一个最优的算法，尤其是以下极端情况令人质疑其效率：Graham Scan算法复杂度由三部分决定：persorting，采用一般排序算法，复杂度是O(nlogn)逐步迭代，O(n)：算法一步步纳入新点，会迭代n步。scan，O(?)所以算法的总体复杂度：O(nlogn + n * ?) ，可见scan的复杂度决定了算法总体的复杂度。算法一步步纳入新点，会迭代n步。但是在每个点上都有可能做回溯操作，所以scan的复杂度是不确定的。我们来以上图最坏情况为例，到第8个点时判定为false，舍弃点7，回溯。下一步判断也为false，舍弃点6，回溯。如此回溯直到算法开始的点2。这次scan倒退了高达O(n)个点，如果每次scan都是如此那么算法整体复杂度就为：O(nlogn + n * n) = O(n^2)了，那这种算法的意义也就不大了。其实上述分析并非错误，只是不够精确。O(n^2)确实是Graham Scan算法的一个上界，但是这个上界并不是紧的。问题就出在分析假定了每次都会出现回退高达O(n)个点。下图展示了整个Graham Scan的流程：图中黄色边是没有采纳的，就是to left测试判定为false后直接舍去的。紫色边则是曾经被认为是极边而接纳的，后来经过回溯又舍去了。无论是黄边还是紫边，在其上耗费的都是常数时间，关键就在于黄色边和紫色边的数目了。通过观察可以发现，从图论的角度看，所有的黄色边和紫色边连在一起构成了一张平面图，也就是它们互相是不可能内部相交的。平面图的一个重要性质：平面图中所有边的数目和顶点数目保持同阶这个性质来自欧拉公式：有n个点的平面图，边的数目上限是3n，也就是O(3n)。回溯（backtrack）可能会倒退的边数：在0~n之间。【但是注意，不是每次回溯都能回退到n，因为由上面可知，点集边数最多为3n，而这里面的每一个边，会被回退0次（极边），或者1次（非极边）。所以，某条边一旦被回退过，之后就不可能再被回退了】根据这个性质，在persorting之后的整个流程中，Graham Scan所能走过的所有边不仅不会到达n^2，而顶多到达和n同阶的一个线性数目。因此整个算法的复杂度也就取决于persorting的O(nlogn)了。算法推广Graham Scan算法不仅可以用于凸包构造问题，在其他许多场景下中也十分有效。为了推广Graham Scan算法，首先可以对其做简化，以方便利用在其他问题。首先再来回顾一下预处理排序，这是算法成立必不可少的一步。排序算法套用成熟的方法即可，利用数学方法计算偏角不仅复杂而且引入了误差，所以要采用to left test。要做的就是两点：套用成熟的排序算法，将待排序元素由数值变为点将排序算法的比较器改为to left test实现按照这样的流程就能间接地实现persorting。1、原始点集已经有某种次序有时候我们并不是从零开始构造凸包，例如得到的待处理点集已经是有某种次序的（比如已经按x坐标大小排序，如下图）。这种情况也不一定非得进行persorting构造新的次序，通常改变观察的角度，换一种理解方式就能免去预处理而直接进行后面的线性的scan操作了。上半部分凸包：考虑y轴负方向无穷远一个点，所有的点相对于这个点的极角排序恰好就是各点的x坐标序！也就是将无穷远的点看作起始点①，最右侧点（图中点8）看作点②，进行scan过程直到最左边的点（图中点1）结束，就得到了凸包的上半部分（upper hull），也就是下图的8→7→2→1：注：对 “考虑y轴负方向无穷远一个点，所有的点相对于这个点的极角排序恰好就是各点的x坐标序！” 这句话的理解：就像太阳光照在地球上的道理是一样的，太阳离地球足够的远，那么它的光到达地球上的时候，就近似的是平行的。下半部分凸包（lower hull）的构造也是如此。考虑一个在y轴正方向无穷远的一个点，以此为起点进行scan，最终得到lower hull：1→4→7。最后将两个凸包合二为一即可。代码实现","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"凸包","slug":"凸包","permalink":"https://longlongqin.github.io/tags/%E5%87%B8%E5%8C%85/"}]},{"title":"Lower Bound","slug":"学习笔记/计算几何/Convex-Hull/Lower-Bound","date":"2020-03-14T09:29:23.000Z","updated":"2020-03-22T14:50:08.237Z","comments":true,"path":"archives/ba04.html","link":"","permalink":"https://longlongqin.github.io/archives/ba04.html","excerpt":"","text":"Lower Bound从极点法的O(n^4^)复杂度，到极边法的O(n^3^)，再到增量构造法和Jarvis March的O(n^2^)，我们经历了将特定问题算法不断优化、降低复杂度的过程。那么还有比O(n^2^)更高效的算法吗？凸包构造算法的下界是什么？推广到一般情况，在计算模型固定的情况下特定问题的复杂度下界又是如何确定的？在计算模型固定的情况下特定问题的复杂度下界（lower bound）是确定的。严谨考虑，在设计算法前应该先确定下界是多少。对于某个问题的特定算法，我们可以用时间复杂度来评价算法的好坏。算法能达到的下界也就是所谓问题的难度。当然这种评价通常是比较麻烦的，有时候甚至是不可行的。这就要引入新的的方式来衡量一个算法的好坏。规约（reduction）我们引入规约（reduction）的方法来间接衡量一个算法。规约简单来讲就是用一个“参照物”对比待评算法，得到算法的复杂度。规约的一般方法如图：左侧是已知的问题A，已经明确它的难度，右侧是待分析问题B，复杂度未知。我们在二者之间建立起一种基本reduction关系：linear-time reduction。linear-time reduction具体表述为：任何一个A的输入（input of A），都可以在O(n)复杂度转化为一个B的输入（input of B），然后通过B的某种算法（any algorithm）计算出结果（output of B）;而对于output of B又都可以在在O(n)复杂度转化为A问题的结果（output of A）。两次转换的复杂度不能超过线性，也就是linear-time（线性时间）。能够进行上述操作，就称为：A问题可以规约到B问题（problem A is linear-time reducible to problem B）。注意表述方式防止搞混A和B的位置。曹冲称象可以通过曹冲称象的故事来帮助理解规约的思想。要解决的问题是：没有秤能直接称量大象重量（问题B的难度无法直接衡量），解决方案是：利用船和石块间接称量。石头块的重量是可以直接称量的（问题A的难度是已知的），利用船和水来转换石头和大象的重量是可操作的（规约的方法是可操作的）。【这里的规约关系(Reduction relationship)是指曹冲成像时的船和水】规约记号引入规约记号，problem A is linear-time reducible to problem B表示为：$$A≤_NB$$将问题A、B的难度分别表示为|A|，|B|。规约记号的意思相当于|A|≤|B|，A的下界必然就是B的下界。规约的过程：将A的输入转化为B的输入经过B的某种算法获得解后又转化为A的解，也就是这个算法也是解决A问题的算法。已知A问题的下界，那么这个算法必然不会低于A的这个下界。构造凸包的下界按照“曹冲称象”的规约思想，分析问题的难度，最重要的在于找到“石头”，而船就是规约这种方法。以二维凸包（2d-CH）来分析，首先将待解决的问题放到规约记号右边，而左边的“石头”就是排序算法。$$Sorting≤_N2D-CH$$排序是纯粹的数值计算问题，而凸包是典型的几何问题，二者是如何联系在一起的呢？前面增量构造法和Jarvis March算法正是分别由两种排序算法来类比引入的，可见排序和凸包之间有深刻的内在联系。二者之间的联系可以通过下图表示：首先清点要做的任务：可以在线性时间内，将排序问题的输入转化为凸包问题的输入排序问题的输入可以表示为x轴上的一系列的点（图中蓝色点）。然后将这些点转化为凸包问题的输入，就是将这些待排序的数转化为平面上的点。引入辅助线——一条抛物线，例如图中蓝色虚线。接下来要对蓝色点做到抛物线上的映射（O(n)），映射在抛物线上的点用绿色标出。这样就完成了将待排序数字转化为平面上点的操作。接下来就可以用某种算法将绿色点构造为凸包，即图中CH(P)。可以在线性时间内，将凸包问题的结果转化为排序问题的结果凸包CH(P)就是问题B的解，如何将B的解转化为A的解？注意最左和最右边两点的连线，即图中1和4的连线4→1。除去这条连线之外，其他首尾相接的连线：1→2，2→3和3→4都是“沿着x方向单调的”，遍历这些首尾相连的边（O(n)）就能得到一系列的数值，并且已经是有序的了。这样就将凸包问题的解——凸包CH(P) 转化为了排序问题的解——有序数值序列。两次转化说明规约是可行的，因此2d-CH问题的下界可由sorting的下界确定。一般而言，排序问题的难度是确定的：O(nlogn)。2d-CH问题的下界也就是：$$O(nlogn)$$更高维的凸包问题下界也是如此。增量构造法和Jarvis March的O(n^2^)到O(nlogn)之间的鸿沟能否跨越呢？是否存在O(nlogn)复杂度的凸包构造算法？后续文章会有回答。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"凸包","slug":"凸包","permalink":"https://longlongqin.github.io/tags/%E5%87%B8%E5%8C%85/"}]},{"title":"构造凸包-Jarvis March(Gift Wrapping)算法","slug":"学习笔记/计算几何/Convex-Hull/Jarvis-March","date":"2020-03-14T09:23:45.000Z","updated":"2020-03-22T13:53:01.986Z","comments":true,"path":"archives/9c7f.html","link":"","permalink":"https://longlongqin.github.io/archives/9c7f.html","excerpt":"回顾凸包构造算法：极点法、极边法和增量构造法，其复杂度分别为O(n^4^)、O(n^3^)和O(n^2^)，效率经过优化已经大大提高了。接下来引入一种新的算法——Jarvis March，其复杂度也是O(n^2^)，但是相较于增量构造在最好情况下效率是较高的。","text":"回顾凸包构造算法：极点法、极边法和增量构造法，其复杂度分别为O(n^4^)、O(n^3^)和O(n^2^)，效率经过优化已经大大提高了。接下来引入一种新的算法——Jarvis March，其复杂度也是O(n^2^)，但是相较于增量构造在最好情况下效率是较高的。实现策略先想一下为何极边法复杂度高达O(n^3^)。实际上我们要对点集中所有边进行遍历，这需要n^2^复杂度，然后对每个边进行鉴别，又需要n复杂度，因此总体复杂度高达O(n^3^)。那么该如何改进呢？这就可以运用选择排序的思想：将下一个要查找的边缩小到一个小范围，而非遍历所有边。选择排序每次选取出的unsorted最大元素放在sorted 部分的首部，也就意味着整个unsorted部分必然不会超过sorted部分。从算法整体框架考虑，每次我们都是维护一个局部解（也就是sorted部分），然后从尚未处理的部分（也就是unsorted部分）找到一个与当前局部解“紧密相关的元素”（相当于选取的最大元素）。这个思想为解决凸包问题带来了新思路。对算法的大致过程进行描述(标识为：已找到极边数/所有极边数)：首先从任何一个极点（后面说明如何找到这个点）开始（图中0/5），然后找到一条以这个极点为端点的极边（1/5）。接着沿着极边另一个端点（endpoint）出发，再找出下一条极边（2/5）。如此反复操作，最终会找到一条以最初极点为endpoint的极边，得到一个封闭的环，凸包也构造完成。凸包构造过程类似于选择排序中sorted不断向前扩展一样，不断扩展局部解，最后得到问题最终解。凸包构造的问题由此分解为一个个子问题：如何从endpoint出发找到下一条极边。用to left test找到下一条极边现分析如何从endpoint找到下一条极边。考虑一下的一般情况：我们从极点o开始寻找极边，假设当前找到的极边是ik，接下来要做的工作是找到从k出发的另一条极边ks，即找到极点s。显然，s来自于其他那些尚未处理的点中，那么s与其他点相比有什么特征？观察发现，ik作为一条极边，它的右侧肯定都是空的，所有其他点都在ik左侧。画出k与其他候选点的有向直线，例如下图中的ks，kt：注意图中红色标出的角度，可以看出ks与ik的夹角比kt小，也就是ks比kt相较于ik偏左的角度更小。实际上ks偏左的角度比其他任何从k出发的边都小，这就是s点的判定依据。这样就找到了从其余点中选择s点的思路：任选两个点，从k出发过这两点做有向边，看哪个偏左的角度更小就留下，另一点丢弃。然后再拿一点与留下的点比较，反复这个过程，最终留下的就是要找的s点。问题至此转化为：如何比较两条有向边（例如ks和kt）相较于另一有向直线（例如ik）谁偏左的角度更小。当然可以通过计算三角函数的方法来比较，这是最直观的数学思维。但是这样计算十分复杂，更重要的是引入了误差。这时候又要使用to left test这个基础方法来解决问题了具体做法就是以在ks和kt中以任意个为基准（如以ks为基准），对另一点（如t）做to left test。上图点t和有向边ks的to left test结果为true，t在ks左边，因此ks偏左的角度更小，舍弃点t。类比选择排序来理解:已得到的极边（从极点o开始到ik的首尾相连的极边）——相当于 sorted部分其余点——相当于 unsorted部分找到点s（能构成最小偏角的点）——相当于 从unsorted部分取出极大值选择排序中的选择过程需要比较元素大小，就要由一种比较器完成，而上述比较偏角的过程也可以抽象为一种比较器的操作。构造凸包的算法框架与选择排序相同，只是比较器替换为to left test而已。此处只是考虑一般情况，一些特殊细节未进行处理。例如在st上有s和s’两点，这两点的取舍问题未考虑。当然为了理解算法整体框架忽略特殊情况是很必要的。确定第一个极点一个细节：上文一开始提到的算法的最开始的第一个极点如何确定？任何一个极点都可以使用，我们没必要去计算出哪个点是极点。可以选取y坐标最小的点，也就是最低点，在没有退化的情况下，这个点一定是一个极点。如果情况退化，有多个最低点（如例图中所示），我们就去选x坐标最小的那个点，也就是最左边的点即可。这种方法选出的点称为lowest-then-leftmost point（LTL）。注意选取的规则的先后顺序，先选lowest，若点不唯一再选leftmost。Jarvis March类比选择排序的过程，我们得到的凸包构造算法就是Jarvis March算法，又称gift wrapping算法（算法过程如包装礼物一样）。接下来看算法具体实现方法。12345678910111213141516171819202122232425262728293031323334353637383940bool ToLeft(Point P, Point q, Point s)&#123; int area2 = p.x*q.y - p.y*q.x + q.x*s.y -q.y*s.x + s.x*p.y - s.y*p.x; return area2 &gt;0 ; //左侧为真&#125;int LTL (Point S[], int n)&#123; int ltl = 0; //the lowest-then-leftmost point for(int k=1; k&lt;n;k++)&#123; if(S[k].y &lt; S[ltl].y || (S[k].y==S[ltl].y &amp;&amp; S[k].x&lt;S[ltl].x)) ltl =k; &#125; return ltl;&#125;void Javis(Point S[], int n)&#123; for (int k=0; k&lt;n; k++) S[k].extreme =FALSE; //首先将所有点标记为非极点 int ltl=LTL(S, n); //找到LTL int k=ltl; //将LTL作为第一个极点 do &#123; S[k].extrem = true; int s =-1; //s是要找的下一个极点，用t去循环找 for (int t=0; t&lt;n; t++) &#123; if(t != k &amp;&amp;t != s &amp;&amp; ( s == -1 || !ToLeft(S[K],S[s],S[t]) ) ) s = t; //如果t在pq的右侧，则更新s &#125; S[k].succ = s; k = s; //新的极边pq确定 k = s; //更新k的值，变为下一次查找的起点 &#125;while(ltl != k) //如果循环回到了原来的点，则结束&#125;梳理首先，初始化将所有点都设为：非极点然后，开始找到第一个极点（用LTL方法），找到之后赋值给k接下来，开始找下一个极点s：主要用ToLeft Test来找出下一个极点循环第3步骤，直到找到所有极点小结最后分析Jarvis March算法相较于增量构造法的优势。二者都是O(n^2^)的复杂度，Jarvis March算法的优势在于其的“输出敏感性（output sensitive）”。考虑点集S，共有n个点，来构造S上的凸包。何为“输出敏感性”？Jarvis March算法每次新加入一条边都会耗费n的复杂度，但是构造过程一共会加入的边数往往比n少。如下图（设n = 7）：在非退化为共线的前提下，最好情况为只加入3条边（复杂度为O(3n)），最坏情况为所有点都是极点，加入n-1条边（复杂度为O(n^2^)）。实际情况中最坏情况出现的几率很小，我们引入一个指标h来衡量凸包的极边数（the size of convex hull）：$$h = |CH(S)|$$Jarvis March算法算法的复杂度更准确的表示为O(nh)。h又由最终输出结果，即凸包本身来决定，输出结果决定了构造过程的复杂度，这就是所谓的“输出敏感性”。这种类型的算法又被称为output sensitive algorithm。这种特性在其它凸包算法中也会体现。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"凸包","slug":"凸包","permalink":"https://longlongqin.github.io/tags/%E5%87%B8%E5%8C%85/"}]},{"title":"Convex Hull(凸包)","slug":"学习笔记/计算几何/Convex-Hull/Convex-Hull-凸包","date":"2020-03-14T09:15:07.000Z","updated":"2020-03-22T14:23:34.120Z","comments":true,"path":"archives/510d.html","link":"","permalink":"https://longlongqin.github.io/archives/510d.html","excerpt":"这山之高，就叫凸碧；山之低洼近水处，就叫作凹晶。这凸、凹二字，历来用的人最少，如今直用做轩馆之名，更觉新鲜，不落窠臼。","text":"这山之高，就叫凸碧；山之低洼近水处，就叫作凹晶。这凸、凹二字，历来用的人最少，如今直用做轩馆之名，更觉新鲜，不落窠臼。欧拉公式简单介绍一下欧拉公式：虚数中：i^2^=-1 ; i=√(-1)其中θ为实数，i表示虚数中的虚数单位 i；欧拉恒等式：当θ=π时；几何学中的欧拉公式：V-E+F=2 【v：几何体的顶点数；E：边数；F：面数】凸包凸包：比如，我们有很多很多钉子钉在木板上面，然后用一个皮筋将这些钉子包围起来，当我们松手后，皮筋就把这些定在全都包围起来。此时，这个皮筋所形成的凸多边形就叫凸包。如下图的蓝色的多边形就是凸包。凸性(Convexity)下图中，假设x,y,z是三种颜色，如果仅以x,y就能调出来的颜色，那么如u所示它一定会落在x,y中；若需要x,y,z三种 一起，那么如v所示会落在以x,y,z三点连成的三角形内部。极点(Extreme Point)有一个点集S。如果存在通过点P的直线L，使得点集S中除了点P之外的其他的点都在这个直线的同一侧，则这个点P就是极点(Extreme Points)。判断一个点是否为极点：该点P是否会被包含在其他点中任意三个点形成的三角形中，如果点P不在任何三角形内部，则说明点P是极点。反之，则不是极点。如下图：下图中，S就不是极点，因为他在三角形内部。判断极点的算法In-Trangle Test算法描述伪代码：其实这个算法就是判断点是否在三角形内部。代码实现：123456789101112131415void extremePoint (point S[], int n)&#123; for(int s=0; s&lt;n; s++) S[s].extreme = TRUE; for(int p=0; p&lt;n; p++) for(int q=p+1; q&lt;n; q++) for(int r=q+1; r&lt;n; r++) for(int s=0; s&lt;n; s++) &#123; if(s==p || s==q || s==r ||!S[s].extreme) continue; if(Intriangle(S[p],S[q],S[r],S[s])) S[s].extreme = FALSE; &#125;&#125;可知，该算法的时间复杂度为O(n^4^)，其实挺大的，在后面我们会进一步改善。这样基于极点的凸包算法虽然效率不高，但是它会引出一个非常重要的操作我们称之为To-Left Test在后面我们可以看到这个测试几乎是贯穿于我们计算几何这个课程的始终的。如果说我们刚才所给出的那个算法还有什么需要补充的话其实最重要的也就是那样的一个细节也就是所谓的In-Triangle test。To-Left Test我们将刚才这个In-Triangle Test转化为三次To-Left测试也就是说一个点如果确实落在某一个三角形的内部的话那么相对于这个三角形的三条边所做的这个To-Left测试都会统一的返回true或者统一地返回false。1234567bool InTriangle(Point p, Point q, Point r, Point s)&#123; bool pqLeft = ToLeft(p, q, s); bool qrLeft = ToLeft(q, r, s); bool rpLeft = ToLeft(r, p, s); return (pdLeft == qrLeft) &amp;&amp; (qrLeft == rqLeft);&#125;To-Left测试是相对于另外这两个点所确定的那条有向直线而言的，任何一条有向直线不仅会把平面分成两部分，我们还可以知道哪一边是左边，哪一边是右边。To-Left，其实就是说这个点相对于刚才的那条有向线而言到底是位于它的左侧，还是右侧。如果是前者就是true，否则的话就是false。因为三角形有三条边，所以我们要用三次To-Left Test。To-Left Test具体实现：这里用到了行列式来求三角形面积（至于原理，这里就不多说了）。下图中的这个行列式实际上算的首先是它的面积的两倍。123456789101112bool ToLeft(Point p, Point q, Point s)&#123; return Area2(p, q, s) &gt; 0; &#125;int Area2(Point p, Point q, Point s)&#123; return p.x * q.y - p.y * q.x +q.x * s.y - q.y * s.x +s.x * p.y - s.y *p.x;&#125;注意：这里的面积其实是“有向面积”，也就是说这里的面积分正负（相对于这样一个逆时针的一个编号pqs的这样的一个面积 与 s在右侧也就是按照顺时针的pqs所构成的面积虽然有可能大小是一样完全对称但是它们的符号是相反的）。整个这个To-Left的测试的判断的依据也就在于这个符号。这个行列式取正条件为：当且仅当s位于pq所确定的这条有向直线的左侧。其中转换成代码也是非常简明的，代码如上图所示。至此，To-Left Test实现完成。极边(Extreme Edge)极边：两个极点连成的边，剩余的所有点均会在该边的一侧。判断是否为极边：代码实现：12345678void markEE(point S[], int n)&#123; for (int k=0; k&lt;n; k++) S[k].extreme = FALSE; for (int p=0; p&lt;n; p++) //test for(int q=p+1; q&lt;n; q++) //检验每一条边 checkEdge(S,n,p,q) //有向边pq&#125;1234567891011void checkEdge(Point S[], int n, int p, int q)&#123; bool LEmpty =TRUE, REmpty =TRUE; for (int k=0; k&lt;n &amp;&amp; (LEmpty || REmpty); k++) &#123; if (k != p &amp;&amp; k != q) ToLeft(S[p], S[q], S[k]) ? LEmpty=FALSE : REmpty=FALSE; &#125; if(LEmpty || REmpty) S[p].extreme=S[q].extreme=TRUE;&#125;实现的步骤：初始时，先假设所有的点都不是极点。开始遍点集S中的点，它们两两组合成一个线段，然后进行checkEdge(检查这些线段是否是极边)。检查的方法checkEdge：利用ToLeft测试，每次都将当前的线段与其他点（即，除了这两个点之外的点）进行ToLeft测试，如果测试结果中：LEmpty、REmpty 其中之一为true，就表明这两个点构成的线段为*极边*，而且同时也检测出这两个点是*极点*。（其实两个点组成的线段进行checkEdge的结果中的LEmpty、REmpty最多只有一个是true,因为这里不存在一条边的两侧都没有其他点的情况）12345678910111213141516171819202122void markEE(Point S[], int n) //n&gt;2&#123; for(int k = 0; k &lt;n; k ++) S[k].extreme = False; //先假设所有的点都不是极点 for(int p = 0; p &lt; n; p ++) for(int q = p + 1; q &lt; n; q ++) checkEdge(S, n, p, q);&#125;void checkEdge(Point S[], int n, int p, int q)&#123; //LEmpty、REmpty表示改边的左侧、右侧，等于True时表示该侧是没有点的。 bool LEmpty = True, REmpty = True; for(int k = 0; k &lt; n &amp;&amp; (LEmpty || REmpty); k ++) &#123; if(k != p &amp;&amp; k != q) &#123; ToLeft(S[p], S[q], S[k]) ? LEmpty = False : REmpty = False; &#125; &#125; if(LEmpty || REmpty) S[p].extreme = S[q].extreme = True;&#125;同样可利用此来判断是否是极点（复杂度为O(n^3)）。补：根据极角排序定义：我们平常所使用的坐标系都是直角坐标系，而极角排序是在极坐标系下进行的。这里首先要选取一个点，然后其它点根据与参考点的连线与x轴所成的夹角的大小进行排序的。这里我们可以简单理解为绕着一个点逆时针转圈访问。代码：在讲具体实现方法之前，先给出用到的函数和结构体：1234567891011121314struct point//存储点&#123; double x,y;&#125;;double cross(double x1,double y1,double x2,double y2) //计算叉积&#123; return (x1*y2-x2*y1);&#125;double compare(point a,point b,point c)//计算极角&#123; return cross((b.x-a.x),(b.y-a.y),(c.x-a.x),(c.y-a.y));&#125;利用叉积的正负来排序 关于叉积：叉积=0是指两向量平行（重合）；叉积&gt;0，则向量a在向量b的顺时针方向（粗略的理解为在a在b的下方）；叉积&lt;0，则向量a在向量b的逆时针方向（粗略的理解为在a在b的上方）123456789bool cmp(point a,point b) &#123; point c;//原点 c.x = 0; c.y = 0; if(compare(c,a,b)==0)//计算叉积，函数在上面有介绍，如果叉积相等，按照X从小到大排序 return a.x&lt;b.x; else return compare(c,a,b)&gt;0;&#125;用 complex 的内建函数，算出极角大小。12345678910#include &lt;complex&gt;#define x real()#define y imag()#include &lt;algorithm&gt;using namespace std;bool cmp(const Point&amp; p1, const Point&amp; p2)&#123; return arg(p1) &lt; arg(p2);&#125;用 arctan 计算极角大小。注意角的大小范围是(-180°, +180°]。弧度表示。这里用 arctan2 函数应该是为了提高精度。关于atan2()函数：在C语言的math.h或C++中的cmath中有两个求反正切的函数atan(double x)与atan2(double y,double x) 他们返回的值是弧度要转化为角度再自己处理下。前者接受的是一个正切值（直线的斜率）得到夹角，但是由于正切的规律性本可以有两个角度的但它却只返回一个，因为atan的值域是从-90°~90° 也就是它只处理一四象限，所以一般不用它。推荐这个：第二个atan2(double y,double x) 其中y代表已知点的Y坐标，同理x ,返回值是此点与远点连线与x轴正方向的夹角，这样它就可以处理四个象限的任意情况了，它的值域相应的也就是-180~180了1234bool cmp1(const Point&amp; p1, const Point&amp; p2)&#123; return atan2(p1.y, p1.x) &lt; atan2(p2.y, p2.x);&#125;先判断象限，再用外积判断顺序，最后根据长度排序。123456789101112131415int Quadrant(point a) //象限排序，注意包含四个坐标轴&#123; if(a.x&gt;0&amp;&amp;a.y&gt;=0) return 1; if(a.x&lt;=0&amp;&amp;a.y&gt;0) return 2; if(a.x&lt;0&amp;&amp;a.y&lt;=0) return 3; if(a.x&gt;=0&amp;&amp;a.y&lt;0) return 4;&#125;bool cmp3(point a,point b) //先按象限从小到大排序 再按极角从小到大排序&#123; if(Quadrant(a)==Quadrant(b))//返回值就是象限 return cmp1(a,b); else Quadrant(a)&lt;Quadrant(b);&#125;向量的点乘与叉乘的几何意义向量的点乘（内积）：$$\\vec{a} \\cdot \\vec{b}=|\\vec{a}| \\cdot |\\vec{b}|\\cdot cos\\theta$$点乘的几何意义是可以用来表征或计算两个向量之间的夹角，以及在b向量在a向量方向上的投影向量的叉乘（外积）：$$\\vec{a} \\times \\vec{b}=|\\vec{a}| \\cdot |\\vec{b}|\\cdot sin\\theta$$向量积被定义为：模长：（在这里θ表示两向量之间的夹角(共起点的前提下)（0° ≤ θ ≤ 180°），它位于这两个矢量所定义的平面上。）方向：a向量与b向量的向量积的方向与这两个向量所在平面垂直，且遵守右手定则。（一个简单的确定满足“右手定则”的结果向量的方向的方法是这样的：若坐标系是满足右手定则的，当右手的四指从a以不超过180度的转角转向b时，竖起的大拇指指向是c的方向。c = a ∧ b）特别的，在二维中，两个向量的向量积的模的绝对值等于由这两天向量组成的平行四边形的面积。向量的叉乘，即求同时垂直两个向量的向量，即c垂直于a，同时c垂直于b（a与c的夹角为90°，b与c的夹角为90°）参考文献极角排序：https://sumygg.com/2013/07/30/Sorting-Points-by-Polar-Angle/关于极角排序：https://www.cnblogs.com/aiguona/p/7248311.html","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"凸包","slug":"凸包","permalink":"https://longlongqin.github.io/tags/%E5%87%B8%E5%8C%85/"}]},{"title":"构造凸包-增量构造法","slug":"学习笔记/计算几何/Convex-Hull/增量构造","date":"2020-03-14T09:15:07.000Z","updated":"2020-03-22T15:43:30.666Z","comments":true,"path":"archives/7c53.html","link":"","permalink":"https://longlongqin.github.io/archives/7c53.html","excerpt":"","text":"在引入新算法之前首先来回顾一下经典的算法思想：减治（decrease and conquer），注意不是分治（divided and conquer），二者稍有区别。简单来讲就是将问题划分为一个个简单的小问题，减而治之，逐个求解，最终就能得到整个问题的解。减治法的经典例子就是插入排序（insertion sort）。插入排序的过程可以归结成下图：排序的过程中将序列分为两部分：已排序部分（sorted）和未排序部分（unsorted）。每次排序都是从unsorted中拿出一个元素，通过一次顺序查找过程在sorted部分中找到位置并插入其中。整个插入排序的过程就是逐个元素的去“蚕食”unsorted部分的过程，连续的进行这个操作就会将整个问题解决。这种将大问题分解成小问题的减治过程，又被看成一种递增的、增量式的策略（incremental strategy）。这种思想为解决凸包问题提供了新的思路：从逐个插入新点的角度构造凸包。典型流程如下图（标识为：极点/整体规模）：插入新的点可能的情况有：新点对凸包有“贡献”，例如5/5→6/6，6/6→7/7；新点也有可能没有“贡献”，例如7/7→7/8；还有可能使原先有“贡献”的点失效，极点数量减少，例如7/8→6/9。那么如何对不同情况进行处理呢？确定新点与现有凸包的关系~in-convex-polygon test构造过程的核心算法应该是：判定待定点是否位于某多边形内部（in-convex-polygon test）。再看上图流程，实际上每步的核心就是判断点位于多边形内部还是外部，若落在外部，则新插入的点就是下一个极点，否则舍弃。考虑基本情况，给定一个点和一个多边形，如何高效判断该点与多边形的位置关系呢？一种思路是：我们可以先对多边形进行一个“预处理”，给每个点按序编号，类比有序向量二分查找的思想，来逐步缩小规模。如下图：首先任选一点为基准点（蓝色点），然后用二分法选取其余点的“中点“（预处理已经为所有点排了序），然后判断基准点到终点的有向直线与待定点的位置关系（to-left test）。然后可将搜索范围减半，反复上述过程，直到最后退化为平凡情况：三角形与点的位置关系（in-triangle test）。分析一下算法的整体复杂度：整个算法共log(n)步，每步的to-left test或in-triangle test都为常数成本，则整体复杂度为log(n)。至此，我们似乎得到了一个log(n)的“高效”算法，但是这种方法真的可行吗？注意，每步都会将原凸包规模减半，也就是说凸包是动态的，随时可能变化。这种方法和极点法或极边法中静态查找的情况是完全不同的。类比插入排序的过程来解释这个问题。为何插入排序的复杂度是n^2^而非nlog(n)？每次插入时，既然sorted部分已经有序，为何不使用二分查找来取代顺序查找（复杂度由n变为log(n)）？这不得不考虑sorted部分的动态性，每次插入后它的结构都会改变，而二分查找必须在静态结构中实现。当然可以使用std::vector这类支持按秩访问（call by rank）的数据结构，但是插入时维护vector的成本依旧是线性复杂度。因此插入排序的总体复杂度是n^2^。要处理的凸包与插入排序中sorted部分本质是一样的，它们都不是静态不变的结构，而要随着算法执行而不断变化。若要每次在log(n)成本下完成待定点的in-convex-polygon test，必须将凸包存储为类似vector的数据结构，但是每次向这种数据结构插入新点的成本依旧是线性的。因此对凸包进行的所谓“预处理”是没有意义的，这种减治策略算法复杂度最低应该为O(n^2^)。到现在问题依旧没有解决，究竟如何用这种增量式的策略来构造凸包？其实复杂问题中最朴素、最基本的方法反而是最有效的。in-convex-polygon test最基本的方法是什么？就是按一定方向（约定为逆时针）凸包的每条边和待定点做to-left test，一旦有一次test为false就能断定点在凸包外面。这实际上就是将in-triangle test推广多边形的情况。因此每次in-convex-polygon test的成本就会变成当前凸包的规模，也就是n。对于每个新点做一次in-convex-polygon test，构造算法的整体复杂度就是O(n^2^)。算法的复杂度从极边法的O(n^3^)又下降了一个数量级。其实增量算法的整个思路可以分成两块：1、如何判断凸包与新点的位置关系（in-convex-polygon test）2、如何向凸包插入新点上面的方法已经解决了第一个问题。第二个问题看下面部分：如何向凸包插入新点~support-line现在来讨论如何向凸包插入新点：比如下面这个点，应该如何插入凸包之中呢？插入过程：将新点x插入原凸包的过程，本质上就是寻找两个连接点s和t，将x和t、s分别连接得到新的凸包。注意t和s两点将整个原凸包边界分为两部分：st和ts两个有向段。构造新凸包就要保留远端st、舍弃近端ts。取代近端ts的两条线就是x和t的连线xt和xs，被称为切线（tangent）或者support line（支撑线）。那如何查找t、s这两个点呢？我们在凸包上任取一点v，按逆时针方向v点会有一个直接前驱点和直接后继点。考察有向直线xv与点v直接前驱和直接后继的位置关系（两次to left test），记录为一个pattern表。结果无非是四种情况：v的直接前驱和直接后继相对于有向直线xv的位置是RL，LR，LL，RR。例如上图黄色点v，是R和L；蓝色点v分别是L和R。实际上凸包边界st上所有点的pattern都为RL，ts上所有点的pattern都为LR。关键点在于：点S的pattern是LL，点t的pattern为RR。因此对凸包边界每个点做两次to left test，判断其pattern就可找出s和t，花费时间成本为常数。incremental construction再来回顾整个凸包构造算法的两大问题：in-convex-polygon test和插入新点。分开考虑只是为了将思路简化，实际上这两个问题可以套用一个算法，同时来解决。具体做法就是：对于每个待定点x，不必特意去考虑它与凸包的位置关系，而是遍历凸包上每一个点。对于凸包边界上的每一个点，我们都能通过两次to left test迅速判断出pattern。对于x位于凸包外部的情况，经过遍历凸包的点，我们很容易就能得到s和t的位置，得到两条support line，从而构造出新的凸包；而对于x位于凸包内部的情况，凸包边界每个点都不可能出现RR或LL的情况，直接舍弃x即可。每次遍历凸包边界点的复杂度为O(n)，整个构造过程要增量式的逐点考察，自然得到了一个O(n^2^)的incremental construction算法。这就是所谓增量构造法来构造凸包的过程。构造过程巧妙的避开了特殊处理诸如5/5→6/6、7/7→7/8、7/8→6/9等复杂情况，采用一致的思路逐个考察“新点”，最终完成凸包的构造。代码部分待写……..小结：其实增量算法的整个思路可以分成两块：1、如何判断凸包与新点的位置关系（in-convex-polygon test）2、如何向凸包插入新点","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"凸包","slug":"凸包","permalink":"https://longlongqin.github.io/tags/%E5%87%B8%E5%8C%85/"}]},{"title":"Let’s Build A Simple Interpreter 7","slug":"学习笔记/Let's Build A Simple Interpreter/LSBASI-7","date":"2020-03-13T13:55:47.000Z","updated":"2020-03-25T14:12:11.797Z","comments":true,"path":"archives/5a757a52.html","link":"","permalink":"https://longlongqin.github.io/archives/5a757a52.html","excerpt":"","text":"前言原文链接：https://ruslanspivak.com/lsbasi-part7/之前的那几小结，我们都是把interpreter的代码和parser的代码混在一起，而且interpreter在parser识别出一个如加减乘除之类 的特定的语言结构(language construct)后，就会立刻对它进行求值。这种 interpreter 被称为 语法导向解释器(syntax-directed interpreter)。他们通常在输 入上做一个 pass 且只适合基础的语言应用。为了分析更复杂的编程语言 Pascal 的结构， 我们需要建立一个 中间表示 (intermediate representation, IR)。parser 会 负责构建 IRinterpreter 会用来解释由 IR 所代表的输入。事实证明树是一个表示 IR 非常合适的数据结构。关于数的一些术语terminology：树是一个包含一个或多个结点组成的层次数据结构。树有一个根结点，就是顶部结点。除根结点外的所有结点有唯一 一个父结点。下图中结点为*的是一个父结点。结点为 2 和 7 的是它的子结点；子结点从左到右排序。没有子结点的结点称为叶子结点。有一个或多个子结点的非根结点被称为中间结点。子结点也可以是完全子树。下图中结点＋的左子树（结点为*）就是一个有自己子结点的 完全子树。在计算机科学中我们把树倒过来画，根结点在最上边，分枝向下生长。下面是表达式 2 * 7 + 3 的带有解释的树形表示：本系列中我们会用到的 IR 被称为 抽象语法树 (abstract-syntax tree, AST)。但在深 入了解 AST 之前让我们简单聊聊 解析树 (parse tree)。尽管我们不会在解释器和编译 器中用到解析树，但它会通过可视化 parser 执行轨迹的方法，加深你对 parser 如何解释 输入的理解。我们也会将它和 AST 做比较，来表明为什么 AST 比解析树更适合用来做 IR。那么，什么是解析树呢？解析树（有时叫做 具体语法树concrete syntax tree ）是一个根据我们的语法定义来 表示一门语言的句法结构的树形结构。它基本上展示了你的 parser 如何识别语言结构或者， 换句话说，它展示了你语法的开始符号怎么派生出该编程语言中一个特定的字符串的。parser 的调用栈隐式地代表了一个解析树，且当parser 在试图识别一个特定的语言结构时，解析树 就会自动地在内存中构建出来。下面是表达式 2 * 7 + 3 的解析树：在上面的图片中可以看到：解析树记录了 parser 用来识别输入的一系列规则。解析树的根结点的标签是语法的开始符号(start symbol)。每个中间结点表示一个非终结符(non-terminal)，代表应用了一条语法规则，像我们的情况里的 expr, term和 factor.每个叶子结点代表了一个 token.我们不会手动构建解析树且在我们的解释器中用到它，但解析树可以通过可视化 调用过程帮助我们理解 parser 怎么解释输入。你可以使用一个名为 genptdot.py 的小应用（我很快写完用来帮助你的），来查看不同的 算术表达式看起来什么样。要使用这个应用你首先需要安装 Graphviz包，然后运行下面的 命令，你可以打开生成的图片文件 parsetree.png 查看你从命令行传入的表达式的解析树：12$ python genptdot.py \"14 + 2 * 3 - 6 / 2\" &gt; \\ parsetree.dot &amp;&amp; dot -Tpng -o parsetree.png parsetree.dot下面是由表达式 14 + 2 * 3 - 6 / 2 生成的图片 parsetree.png:parser抽象语法树(AST)现在我们来聊聊抽象语法树(AST)。它是在余下的文章中会大量用到的中间表示(IR)。它是我们的解释器和未来编译器项目的核心数据结构。让我们以把表达式 2 * 7 + 3 的 AST 和解析树放在一起看来开始我们的讨论：从上面的图片中可以看出，AST抓住了输入的精髓且更小。AST 和解析树最主要的区别有：AST 使用操作符/操作(operators/operations )作为根结点，操作数(operands)作为它们的子结点。不像解析树，AST 不使用中间结点来表示语法规则。AST 并不把真实句法中的所有结节都表示出来（这就是为什么它是抽象的）──例如，没有 规则结点和括号。对于相同的语言结构来说，AST 相比于解析树更紧凑。抽象语法树是什么？抽象语法树(AST)是表示一个语言结构的抽象句法结构的树形表示，它的中间结点和根结点代表了一个操作符，子结点代表了该操作符的操作数。看一下AST与解析树对比，显现他的紧凑性：如何将操作符的优先级(precedence)编码进 AST 呢？为了把操作符优先级编码进 AST，即，为了表示“X 在 Y 之前发生”你只需要在树中把 X 放在低于 Y 的位置。你在前面 的图片中已经见过到了。【例子】：在下面的图片中，左边是表达式 2 * 7 + 3 的 AST。让我们用括号把 7 + 3 围起来以改变 它的优先级。在右边是修改后的表达式 2 * (7 + 3) 的 AST：代码实现AST好了，让我们写些代码来实现不同的 AST 结点类 并修改我们的 parser 来生成包含这些结点的 AST 树：首先，新建一个基本结点类叫做 AST，其他类会从它继承：12class AST(): pass #pass 不做任何事情，一般用做占位语句。因为如果定义一个空函数程序会报错，当你没有想好函数的内容是可以用 pass 填充，使程序可以正常运行。回忆一下 AST 表示了操作符-操作数模型。到现在为止，我们有4个操作符和整型操作数。操作符有加、减、乘、除。我们原本可以新建单独的类来表示每个操作符如 AddNode, SubNode, MulNode 和 DivNode，相反我们只会新建一个 BinOp 类来表示所有 4 个二元操作符*binary operator* （二元操作符就是作用在两个操作数的操作符）：12345class BinOp(AST): def __init__(self, left, op, right): self.left = left self.token = self.op = op self.right = right构造函数的参数是 left, op, 和 right, 其中 left 和 right 分别指向了表示 左操作数和右操作数的结点。 op 保存了指向操作符本身的 token: Token(PLUS, &#39;+&#39;) 表示加操作符， Token(MINUS, &#39;-&#39;) 表示减操作符，等等。为了在 AST 中表示整数，我们定义一个 Num 类，它将保存一个 INTEGER token 和该 token 的值：1234class Num(AST): def __init__(self, token): self.token = token self.value = token.value和你注意到的一样，所有的note保存 token 从而则创建note(all nodes store the token used to create the node)。这主要是为了方便，将来会派上用场。回忆一下表达式 2 * 7 + 3 的 AST。我们会在代码中手工创建该表达式：1234567891011121314&gt;&gt;&gt; from spi import Token, MUL, PLUS, INTEGER, Num, BinOp&gt;&gt;&gt;&gt;&gt;&gt; mul_token = Token(MUL, '*')&gt;&gt;&gt; plus_token = Token(PLUS, '+')&gt;&gt;&gt; mul_node = BinOp(... left=Num(Token(INTEGER, 2)),... op=mul_token,... right=Num(Token(INTEGER, 7))... )&gt;&gt;&gt; add_node = BinOp(... left=mul_node,... op=plus_token,... right=Num(Token(INTEGER, 3))... )以下是在新定义的结点类下 AST 的样子。下面的图片也遵循了上面手工创建的过程：parser 代码下面是我们修改过的 parser 代码，在识别输入（算术表达式）时建立和返回一个 AST:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class AST(): passclass BinOp(AST): def __init__(self, left, op, right): self.left = left self.token = self.op = op self.right = rightclass Num(AST): def __init__(self, token): self.token = token self.value = token.valueclass Parser(): def __init__(self, lexer): self.lexer = lexer # set current token to the first token from the input self.current_token = self.lexer.get_next_token() def error(self): raise Exception('Invalid syntax') def eat(self, token_type): # compare the current token type with the passed token # type and if they match then \"eat\" the current token # and assign the next token to the self.current_token, # otherwise raise an exception. if self.current_token.type == token_type: self.current_token = self.lexer.get_next_token() else: self.error() def factor(self): \"\"\"factor : INTEGER | LPAREN expr RPAREN\"\"\" token = self.current_token if token.type == INTEGER: return Num(token) elif token.type == LPAREN: self.eat(LPAREN) node = self.expr() self.eat(RPAREN) return node def term(self): \"\"\"term : factor ((MUL | DIV) factor)*\"\"\" node = self.factor() while self.current_token.type in (MUL, DIV): token = self.current_token if token.type == MUL: self.eat(MUL) elif token.type == DIV: self.eat(DIV) node = BinOp(left=node, op=token, right=self.factor()) return node def expr(self): \"\"\" expr : term ((PLUS | MINUS) term)* term : factor ((MUL | DIV) factor)* factor : INTEGER | LPAREN expr RPAREN \"\"\" node = self.term() while self.current_token.type in (PLUS, MINUS): token = self.current_token if token.type == PLUS: self.eat(PLUS) elif token.type == MINUS: self.eat(MINUS) node = BinOp(left=node, op=token, right=self.term()) return node def parse(self): return self.expr()让我们看一些算术表达式的 AST 的构建过程。如果你看了上面的 parser 代码，可以看到它建立一个 AST 中的结点的时，把变量 node 的当前值做为 BinOp 结点的左子结点，把对 term 或 factor 调用的返回结果做为它 的右子结点，这实际上就是把结点推向左边，下面表达式 1 +2 + 3 + 4 + 5 的树结构就是 这种情况的一个好例子。下面是 parser 如何一步步地构建表达式 1 + 2 + 3 + 4 + 5 的 AST 的图形表示：遍历好了，下面是表达式 2 * 7 + 3 的 AST：你怎么遍历这个树并恰当地对它所代表的表达式进行求值呢？你可以使用后序遍历*postorder traversal* (深度优先遍历depth-first traversal 的一个特例) 。这种方式由根结点开始，递归由左至右访问每个结点的子结点。后序遍历从根结点开始尽可能快地访问离根结点远的结点(The postorder traversal visits nodes as far away from the root as fast as it can)。下面是后序遍历的伪代码，其中 &lt;&lt; postorder actions &gt;&gt;是一些操作的占位符，如 BinOp 结点的加减乘除操作或 Num 结点返回整数的简单操作：为什么要使用后续遍历呢？第一，我们需要对在树中更低的中间结点进行求值， 因为它们代表了优先级更高的操作符，第二，我们在对操作数 参与 对应操作符 的运算 之前需要对操作数进行求值。在下面的图片中，可以看到使用后序遍历时我们会首先对表达式 2*7 进行 求值，而只有在对 14 + 3 求值之后，我们才会得到正确答案 17:三种深度优先遍历：为了完整起见，三种深度优先遍历的方式：先序遍历，中序遍历和后序遍历。这 些遍历方式名字的来自于遍历代码中操作的位置：有时你可能需要在所有地方（先序，中序和后序）都执行一些操作。你会在本文的源代码仓 库中找到一些例子。先序遍历preorder traversal,在先序遍历中，我们先访问根节点，然后递归使用先序遍历访问左子树，再递归使用先序遍历访问右子树，即：根节点-&gt;左子树-&gt;右子树中序遍历inorder traversal,在中序遍历中，我们递归使用中序遍历访问左子树，然后访问根节点，最后再递归使用中序遍历访问右子树，即：左子树-&gt;根节点-&gt;右子树后序遍历 postorder traversal.在后序遍历中，我们先递归使用后序遍历访问左子树和右子树，最后访问根节点。 即：左子树-&gt;右子树-&gt;根节点Interpreter用代码来遍历和解释由 parser 建立的抽象语法树：好了，让我们写一些代码来遍历和解释由 parser 建立的抽象语法树，好吗？下面是实现了访问者模式的源代码：12345678class NodeVisitor(): def visit(self, node): method_name = 'visit_' + type(node).__name__ visitor = getattr(self, method_name, self.generic_visit) return visitor(node)#generic_visit 是一个备用函数，它会抛出一个异常来表示它遇到了一个实现类中没有相 应 #visit_NodeType 方法的结点。 def generic_visit(self, node): raise Exception('No visit_&#123;&#125; method'.format(type(node).__name__))NodeVisitor一个结点访问器的基类：它遍历抽象语法树并为找到的每个节点调用一个访问器函数。（这个函数可能会返回一个由visit()方法转发 的值）。This class is meant to be subclassed, with the subclass adding visitor methods.成员函数：1️⃣ visit(node)：访问一个结点。它默认调用self.visit_classname（其中的classname是结点类的名字，或者如果这个方法不存在时，classname就是 generic_visit() ）的方法。2️⃣ generic_visit(node)：这个访问器(visitor)对结点的所有子节点调用visit()。【注意：只有这个访问器调用generic_visit() 或者访问它本身，否则自定义访问器的结点的子节点将不会被访问】1getattr(object, name[, default])官方文档中说这个函数作用是返回对象的一个属性，第一个参数是对象实例obj,name是个字符串，是对象的成员函数名字或者成员变量，default当对象没有这个属相的时候就返回默认值，如果没有提供默认值就返回异常。如：提供不默认写法：1234567891011121314&gt;&gt;&gt; class Test(object):... def func(self):... print 'I am a test'...&gt;&gt;&gt; test = Test() # 实例化一个对象&gt;&gt;&gt; func = getattr(test, 'func') # 使用getattr函数获取func的值&gt;&gt;&gt; func()I am a test&gt;&gt;&gt; func = getattr(test, 'f') # 使用对象没有的属性，则会出现异常Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;AttributeError: 'Test' object has no attribute 'f'&gt;&gt;&gt;提供默认写法如果对象没有该属性可以提供一个默认值。1234&gt;&gt;&gt; func = getattr(test, 'f', None)&gt;&gt;&gt; print funcNone&gt;&gt;&gt;Interpreter 类的源代码下面是 Interpreter 类的源代码，它继承自 NodeVisitor 类且实现了形式为 visit_NodeType 的不同方法，其中 NodeType 会被如 BinOp, Num 等类名替换：12345678910111213141516class Interpreter(NodeVisitor): def __init__(self, parser): self.parser = parser def visit_BinOp(self, node): if node.op.type == PLUS: return self.visit(node.left) + self.visit(node.right) elif node.op.type == MINUS: return self.visit(node.left) - self.visit(node.right) elif node.op.type == MUL: return self.visit(node.left) * self.visit(node.right) elif node.op.type == DIV: return self.visit(node.left) / self.visit(node.right) def visit_Num(self, node): return node.value关于以上代码有两点值得在这里提一下：第一，操作 AST 结点的访问器(也就是对AST数据的操作)的代码 和 AST 结点(即，AST的数据结构)本身 分离（解耦了）。可以看到 AST 结点类(BinOp 和 Num)没有提供任何代码来操作存储在这些结点中的数据，该逻辑被封装在了实现 NodeVisitor 的 Interpreter 类中。（也就是对数据的操作在NodeVisitor 的 Interpreter 类中）。第二，在NodeVisitor的访问函数中，不像这样使用一个巨大的if语句:123456789101112131415def visit(node): node_type = type(node).__name__ if node_type == 'BinOp': return self.visit_BinOp(node) elif node_type == 'Num': return self.visit_Num(node) elif ... # ...#####或者##########def visit(node): if isinstance(node, BinOp): return self.visit_BinOp(node) elif isinstance(node, Num): return self.visit_Num(node) elif ...NodeVisitor 的 visit 方法非常通用，能根据传入的结点类型来调度适当的方法。正如前面提到的，为了利用这一点，我们的解释器继承了 NodeVisitor 类并实现了必要的方法。 因此：如果传递给 visit 函数的结点是 BinOp，那么visit 函数就会调用 visit_BinOp 方法。如果传递给 visit函数的结点是 Num,那么 visit 函数就会调用visit_Num 方 法，等等。花此时间研究一下这个方法（Python 的标准模块 ast 也使用了相同的机制来遍历结点）， 因为我们将来会用很多新的 visit_NodeType 方法来扩展我们的解释器。现在，让我们手工为表达式 2 * 7 + 3 建立一个 AST 并把它传递给解释器，通过对该表达式求值看看运行中的 visit 方法。下面是你从 Python shell 中尝试的方法：123456789101112131415161718&gt;&gt;&gt; from spi import Token, MUL, PLUS, INTEGER, Num, BinOp&gt;&gt;&gt;&gt;&gt;&gt; mul_token = Token(MUL, '*')&gt;&gt;&gt; plus_token = Token(PLUS, '+')&gt;&gt;&gt; mul_node = BinOp(... left=Num(Token(INTEGER, 2)),... op=mul_token,... right=Num(Token(INTEGER, 7))... )&gt;&gt;&gt; add_node = BinOp(... left=mul_node,... op=plus_token,... right=Num(Token(INTEGER, 3))... )&gt;&gt;&gt; from spi import Interpreter&gt;&gt;&gt; inter = Interpreter(None)&gt;&gt;&gt; inter.visit(add_node)17如你所见，我把表达式树的根结点传递给了 visit 方法，这一行为触发了树的遍历，遍历调用了 Interpreter 类正确的方法(visit_BinOp 和 visit_Num)并生成了结果。完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264\"\"\" SPI - Simple Pascal Interpreter \"\"\"# Token types## EOF (end-of-file) token is used to indicate that# there is no more input left for lexical analysisINTEGER, PLUS, MINUS, MUL, DIV, LPAREN, RPAREN, EOF = ( 'INTEGER', 'PLUS', 'MINUS', 'MUL', 'DIV', '(', ')', 'EOF')class Token(object): def __init__(self, type, value): self.type = type self.value = value def __str__(self): \"\"\"String representation of the class instance. Examples: Token(INTEGER, 3) Token(PLUS, '+') Token(MUL, '*') \"\"\" return 'Token(&#123;type&#125;, &#123;value&#125;)'.format( type=self.type, value=repr(self.value) ) def __repr__(self): return self.__str__()################################################################################ ## LEXER ## ################################################################################class Lexer(object): def __init__(self, text): # client string input, e.g. \"4 + 2 * 3 - 6 / 2\" self.text = text # self.pos is an index into self.text self.pos = 0 self.current_char = self.text[self.pos] def error(self): raise Exception('Invalid character') def advance(self): \"\"\"Advance the `pos` pointer and set the `current_char` variable.\"\"\" self.pos += 1 if self.pos &gt; len(self.text) - 1: self.current_char = None # Indicates end of input else: self.current_char = self.text[self.pos] def skip_whitespace(self): while self.current_char is not None and self.current_char.isspace(): self.advance() def integer(self): \"\"\"Return a (multidigit) integer consumed from the input.\"\"\" result = '' while self.current_char is not None and self.current_char.isdigit(): result += self.current_char self.advance() return int(result) def get_next_token(self): \"\"\"Lexical analyzer (also known as scanner or tokenizer) This method is responsible for breaking a sentence apart into tokens. One token at a time. \"\"\" while self.current_char is not None: if self.current_char.isspace(): self.skip_whitespace() continue if self.current_char.isdigit(): return Token(INTEGER, self.integer()) if self.current_char == '+': self.advance() return Token(PLUS, '+') if self.current_char == '-': self.advance() return Token(MINUS, '-') if self.current_char == '*': self.advance() return Token(MUL, '*') if self.current_char == '/': self.advance() return Token(DIV, '/') if self.current_char == '(': self.advance() return Token(LPAREN, '(') if self.current_char == ')': self.advance() return Token(RPAREN, ')') self.error() return Token(EOF, None)################################################################################ ## PARSER ## ################################################################################class AST(object): pass # 表示定义留空class BinOp(AST): def __init__(self, left, op, right): self.left = left self.token = self.op = op self.right = rightclass Num(AST): def __init__(self, token): self.token = token self.value = token.valueclass Parser(object): def __init__(self, lexer): self.lexer = lexer # set current token to the first token taken from the input self.current_token = self.lexer.get_next_token() def error(self): raise Exception('Invalid syntax') def eat(self, token_type): # compare the current token type with the passed token # type and if they match then \"eat\" the current token # and assign the next token to the self.current_token, # otherwise raise an exception. if self.current_token.type == token_type: self.current_token = self.lexer.get_next_token() else: self.error() def factor(self): \"\"\"factor : INTEGER | LPAREN expr RPAREN\"\"\" token = self.current_token if token.type == INTEGER: self.eat(INTEGER) return Num(token) elif token.type == LPAREN: self.eat(LPAREN) node = self.expr() self.eat(RPAREN) return node def term(self): \"\"\"term : factor ((MUL | DIV) factor)*\"\"\" node = self.factor() while self.current_token.type in (MUL, DIV): token = self.current_token if token.type == MUL: self.eat(MUL) elif token.type == DIV: self.eat(DIV) node = BinOp(left=node, op=token, right=self.factor()) return node def expr(self): \"\"\" expr : term ((PLUS | MINUS) term)* term : factor ((MUL | DIV) factor)* factor : INTEGER | LPAREN expr RPAREN \"\"\" node = self.term() while self.current_token.type in (PLUS, MINUS): token = self.current_token if token.type == PLUS: self.eat(PLUS) elif token.type == MINUS: self.eat(MINUS) node = BinOp(left=node, op=token, right=self.term()) return node def parse(self): return self.expr()################################################################################ ## INTERPRETER ## ################################################################################class NodeVisitor(object): def visit(self, node): method_name = 'visit_' + type(node).__name__ visitor = getattr(self, method_name, self.generic_visit) return visitor(node) def generic_visit(self, node): raise Exception('No visit_&#123;&#125; method'.format(type(node).__name__))class Interpreter(NodeVisitor): def __init__(self, parser): self.parser = parser def visit_BinOp(self, node): if node.op.type == PLUS: return self.visit(node.left) + self.visit(node.right) elif node.op.type == MINUS: return self.visit(node.left) - self.visit(node.right) elif node.op.type == MUL: return self.visit(node.left) * self.visit(node.right) elif node.op.type == DIV: return self.visit(node.left) / self.visit(node.right) def visit_Num(self, node): return node.value def interpret(self): tree = self.parser.parse() return self.visit(tree)def main(): while True: try: try: text = raw_input('spi&gt; ') except NameError: # Python3 text = input('spi&gt; ') except EOFError: break if not text: continue lexer = Lexer(text) parser = Parser(lexer) interpreter = Interpreter(parser) result = interpreter.interpret() print(result)if __name__ == '__main__': main()将以上代码保存到名为 spi.py 的文件中，或者直接从 GitHub 下载。自己试一试，确认 你的新的基于树的解释器可以正确地对算术表达式进行求值。下面是某次运行过程：1234567$ python spi.pyspi&gt; 7 + 3 * (10 / (12 / (3 + 1) - 1))22spi&gt; 7 + 3 * (10 / (12 / (3 + 1) - 1)) / (2 + 3) - 5 - 3 + (8)10spi&gt; 7 + (((3 + 2)))12小结今天你学习了关于解析树和 AST，如何构建 AST 以及遍历表示输入的 AST 并解释执行。你还修改了 parser 和 interpreter 并将这两部分解开了。现在 lexer, parser 和 interpreter 之间的接口看起来像这样：你可以把它读作“parser 从 lexer 中 得到 token 然后返回生成的 AST 给 Interpreter 进行遍历并解释执行所给输入”。递归这就是今天的所有内容，但在总结之前我还想简单地聊一聊递归下降 (recursive-descent) parser，即是仅仅给出它的定义。定义就是：一个 递归下降parser 就 是一个自顶向下的 parser，它使用一组递归过程来处理输入。自顶向下反映了 parser 从 构建解析树的顶部结点开始逐渐构建更低的结点这一事实。梳理本节与part6相比主要添加了AST：Lexer与part6中的是一样的，还是将输入的text分析转换为token。(这也是词法分析器的功能)Parser相比part6，它添加了构造AST的内容：添加了三个类：AST()：是一个基类BinOp(AST)：继承于AST()，主要功能是实现二元操作符binary operator 。（这里只有四种：加、减、乘、除法）Num(AST)：继承于AST()，它主要是表示AST中的整数integer token（它将保存一个 INTEGER token 和该 token 的值）第二个变化就是实现语法解析的这三个函数term、factor、expr中的返回的不在是result变量了，而是返回一个结点node。Interpreter：通过词法分析、语法分析之后，开始解释语法分析之后的算式，计算出它的结果，用Interpreter来解释：增添了访问者模式：将 对数据的操作(对数据的操作在interpreter中完成：访问、解释) 和 数据结构(数据结构 在parser中的三个类中构建) 进行分离（解耦合）。使得操作集合可相对自由地演化。这里通过创建 NodeVisitor()类 实现访问者模式。实现了通过什么方式去访问生成的AST又通过Interpreter（继承于 NodeVisitor()类）来实现解释生成的AST最后，再次提醒一下：之前的那几小结，我们都是把interpreter的代码和parser的代码混在一起，但这一小节我们把interpreter的代码和parser的代码分开了。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let's Build A Simple Interpreter","slug":"Let-s-Build-A-Simple-Interpreter","permalink":"https://longlongqin.github.io/tags/Let-s-Build-A-Simple-Interpreter/"}]},{"title":"Let’s Build A Simple Interpreter 6","slug":"学习笔记/Let's Build A Simple Interpreter/LSBASI-6","date":"2020-03-12T04:55:57.000Z","updated":"2020-03-17T09:40:01.085Z","comments":true,"path":"archives/167c.html","link":"","permalink":"https://longlongqin.github.io/archives/167c.html","excerpt":"新增了括号运算(parenthesized expressions)","text":"新增了括号运算(parenthesized expressions)原文链接：https://ruslanspivak.com/lsbasi-part6/本文在前面的基础上，新增了括号运算(parenthesized expressions)，如： 7 + 3 * (10 / (12 / (3 + 1) - 1))所以需要在part5中的语法基础上，进行修改，修改后的语法如下图：从上面的图可以看出来,在part6中，expr和term和part5中一样，唯一变的是factor的产生式 (production)。它新添加了两个 terminal ：LPAREN：表示一个左括号 left parenthesis ‘( ‘RPAREN：表示一个右括号 right parenthesis ‘)’还新添加了一个非终端符：exprexpr添加在两个括号之间下面是factor的语法图：（这里用到了递归）然后，再放一下没有改变的（与part5相同）expr、term的语法图：现在看一下算式：2 * (7 + 3) 的分解过程吧：现在把语法转换成代码。下面这两条是代码中主要改变的部分：Lexer被修改，使其在原来的基础上可以返回另外两个token：左括号LPAREN 、右括号RPARENInterpreter类的factor被修改，修改之后不仅可以解析整数integer，还可以解析括号表达式(parenthesized expressions)下面就是本小节的代码部分：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194# Token types## EOF (end-of-file) token is used to indicate that# there is no more input left for lexical analysisINTEGER, PLUS, MINUS, MUL, DIV, LPAREN, RPAREN, EOF = ( 'INTEGER', 'PLUS', 'MINUS', 'MUL', 'DIV', '(', ')', 'EOF')class Token(object): def __init__(self, type, value): self.type = type self.value = value def __str__(self): \"\"\"String representation of the class instance. Examples: Token(INTEGER, 3) Token(PLUS, '+') Token(MUL, '*') \"\"\" return 'Token(&#123;type&#125;, &#123;value&#125;)'.format( type=self.type, value=repr(self.value) ) def __repr__(self): return self.__str__()class Lexer(object): def __init__(self, text): # client string input, e.g. \"4 + 2 * 3 - 6 / 2\" self.text = text # self.pos is an index into self.text self.pos = 0 self.current_char = self.text[self.pos] def error(self): raise Exception('Invalid character') def advance(self): \"\"\"Advance the `pos` pointer and set the `current_char` variable.\"\"\" self.pos += 1 if self.pos &gt; len(self.text) - 1: self.current_char = None # Indicates end of input else: self.current_char = self.text[self.pos] def skip_whitespace(self): while self.current_char is not None and self.current_char.isspace(): self.advance() def integer(self): \"\"\"Return a (multidigit) integer consumed from the input.\"\"\" result = '' while self.current_char is not None and self.current_char.isdigit(): result += self.current_char self.advance() return int(result) def get_next_token(self): \"\"\"Lexical analyzer (also known as scanner or tokenizer) This method is responsible for breaking a sentence apart into tokens. One token at a time. \"\"\" while self.current_char is not None: if self.current_char.isspace(): self.skip_whitespace() continue if self.current_char.isdigit(): return Token(INTEGER, self.integer()) if self.current_char == '+': self.advance() return Token(PLUS, '+') if self.current_char == '-': self.advance() return Token(MINUS, '-') if self.current_char == '*': self.advance() return Token(MUL, '*') if self.current_char == '/': self.advance() return Token(DIV, '/') if self.current_char == '(': self.advance() return Token(LPAREN, '(') if self.current_char == ')': self.advance() return Token(RPAREN, ')') self.error() return Token(EOF, None)class Interpreter(object): def __init__(self, lexer): self.lexer = lexer # set current token to the first token taken from the input self.current_token = self.lexer.get_next_token() def error(self): raise Exception('Invalid syntax') def eat(self, token_type): # compare the current token type with the passed token # type and if they match then \"eat\" the current token # and assign the next token to the self.current_token, # otherwise raise an exception. if self.current_token.type == token_type: self.current_token = self.lexer.get_next_token() else: self.error() def factor(self): \"\"\"factor : INTEGER | LPAREN expr RPAREN\"\"\" token = self.current_token if token.type == INTEGER: self.eat(INTEGER) return token.value elif token.type == LPAREN: self.eat(LPAREN) result = self.expr() self.eat(RPAREN) return result def term(self): \"\"\"term : factor ((MUL | DIV) factor)*\"\"\" result = self.factor() while self.current_token.type in (MUL, DIV): token = self.current_token if token.type == MUL: self.eat(MUL) result = result * self.factor() elif token.type == DIV: self.eat(DIV) result = result / self.factor() return result def expr(self): \"\"\"Arithmetic expression parser / interpreter. calc&gt; 7 + 3 * (10 / (12 / (3 + 1) - 1)) 22 expr : term ((PLUS | MINUS) term)* term : factor ((MUL | DIV) factor)* factor : INTEGER | LPAREN expr RPAREN \"\"\" result = self.term() while self.current_token.type in (PLUS, MINUS): token = self.current_token if token.type == PLUS: self.eat(PLUS) result = result + self.term() elif token.type == MINUS: self.eat(MINUS) result = result - self.term() return resultdef main(): while True: try: # To run under Python3 replace 'raw_input' call # with 'input' text = raw_input('calc&gt; ') except EOFError: break if not text: continue lexer = Lexer(text) interpreter = Interpreter(lexer) result = interpreter.expr() print(result)if __name__ == '__main__': main()","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let's Build A Simple Interpreter","slug":"Let-s-Build-A-Simple-Interpreter","permalink":"https://longlongqin.github.io/tags/Let-s-Build-A-Simple-Interpreter/"}]},{"title":"Let’s Build A Simple Interpreter 5","slug":"学习笔记/Let's Build A Simple Interpreter/LSBASI-5","date":"2020-03-11T09:45:49.000Z","updated":"2020-04-03T14:51:52.352Z","comments":true,"path":"archives/173c.html","link":"","permalink":"https://longlongqin.github.io/archives/173c.html","excerpt":"本文为这一系列的part5，第五小节。这次将写一个可移植性加减乘除混合运算的解释器。","text":"本文为这一系列的part5，第五小节。这次将写一个可移植性加减乘除混合运算的解释器。原文链接：https://ruslanspivak.com/lsbasi-part5/本文为这一系列的part5，第五小节。这次将写一个可移植性加减乘除混合运算的解释器。在开始写代码之前，我们需要知道一些，比如：结合律、操作符(operator)的优先级(precedence)结合律(associativity)比如，7+3+1等同于(7+3)+1 ，7 - 3 - 1 等同于 (7 - 3) - 1。这没有什么奇怪的。但是再比如： 7 - 3 - 1 与 7 - (3 - 1) 的结果就不一样了。其实：加、减、乘、除 这些操作符(operator)是左结合(left-associative)。比如， 7 + 3 + 1 中的 操作数(operand) 3，它的左右都是 加号 ，但是这个操作数3是与它左边的加号“+”结合的， 所以加法是左结合。那加减乘除混合时，如 7 + 5 * 2 是否还是遵循左结合律呢？很显然，不遵循，因为 (7 + 5) * 2 不等于 7 + 5 * 2 。由此可知：​ 加法和减法是一类，所以它们在一起组成的运算是左结合；乘法和除法是一类，所以他们在一起组成的运算是左结合。（即，左结合律只适用于同一类的操作符(operator)）优先级(precedence)那我们如何规定这种加减乘除（这两类操作符(operator)）同时出现时的运算规则呢？（实际上我们都知道，但是这里是为实现代码来做出一种运算规则）在 7 + 5 * 2中，如果操作符“”能先比操作符“+”到他的操作数5，就说，操作符“”有更高的优先级(higher precedence)。在实际中我们也在用，也知道。乘除的优先级要高于加减法。好了，现在我们开始用表格来表示操作符的结合律与优先级：由上表可知：+ and - 是优先级相同，都是左结合；* and / 优先级相同，也都是左结合；我们还可以根据上面的优先级表格来制定一个语法规则：优先级相同的每一级都定义一个非终端符(non-terminal)。其中每个产生式(production)的body中应该包含:算数运算符(arithmetic operators) &amp; 非终端符(这里的非终端又参与构成下一较高的优先级的规则(产生式)的一部分)创建一个表示 基本表达式的非终端符factor，本文中指integer。一般的规则是：如果你有N个优先级，那么你就需要N+1个非终端符（一类是每一层优先级的一个非终端符，一类是表示基本表达式单元）构建语法(grammars)现在根据上面的规则来构建语法：由规则1，我们将定义两个非终结符(non-terminal)，一个是leve1的non-terminal叫做expr，另一个是level2的non-terminal叫做term。然后根据规则2，我们需要定义一个叫做factor的non-terminal来作为一个基本的表达式单元，integers。这个语法的开始符号（start symbol ）叫做expr。它的产生式(production)的body含有：1️⃣表示level2的操作符(在这指的是+ and - )，2️⃣和一个非终端符term(这个term是下一层优先级（更高的）level1 的一个产生式)开始符号（S）：最大的语法单位 或 最重要的语法单位。（如上面的那个英文句子中的，最大的语法单位是：句子。）非终端符term的production(产生式)的body包含:1️⃣表示level1的操作符(在这指的是 * and /)。2️⃣还有一个非终端符factor来表示基本的表达式单元，integers非终端符factor包含：1️⃣一个integer上面的三幅图是语法、语法图的一部分，这在之前的文章中也出现过。但现在需要将上面的三幅图结合在一起来考虑结合律和优先级（ associativity and precedence ）下面是本文的语法对应的语法图：上面语法图的每一个小方框都是其他语法图的：函数调用（“method call”）。如果你以表达式 7 + 5 * 2 为例并从顶 层图 expr 开始逐步分解到最底层的图 factor, 你应该可以看到位于中间的图的高优 先级操作符*和/会比上面的图的操作符+和-先执行。为了解释清楚运算符的优先级，让我们看看使用上面语法和句法图来分解相同算术表达式 7 + 5 * 2 的过程。这只是另一种展示高优先级运算符 先于 低优先级运算符执行这个事实的 方式。语法转换成代码让我们使用part 4中的准则把该语法转化成代码，看看它怎么工作，先看一张上面放过的语法图：下面是能处理可以包含任意数量加减乘除操作符的算术表达式的计算器的完整代码。相比于part 4代码的主要变化有：Lexer 类现在可以把+,-,*和/都 token 化了（没什么新方法，我们只是把前面文章中 的代码合并到一个类中来支持所有这些 token）回想语法中的每条规则（产生式）R都要变成一个同名的方法，且对该规则的引用都要变 成一个方法调用 R() 这一点。现在 Interpreter 类有了三个方法来对应语法中的非 终结符： expr, term, factor.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182# Token types## EOF (end-of-file) token is used to indicate that# there is no more input left for lexical analysisINTEGER, PLUS, MINUS, MUL, DIV, EOF = ( 'INTEGER', 'PLUS', 'MINUS', 'MUL', 'DIV', 'EOF')class Token(object): def __init__(self, type, value): # token type: INTEGER, PLUS, MINUS, MUL, DIV, or EOF self.type = type # token value: non-negative integer value, '+', '-', '*', '/', or None self.value = value def __str__(self): \"\"\"String representation of the class instance. Examples: Token(INTEGER, 3) Token(PLUS, '+') Token(MUL, '*') \"\"\" return 'Token(&#123;type&#125;, &#123;value&#125;)'.format( type=self.type, value=repr(self.value) ) def __repr__(self): return self.__str__()class Lexer(object): def __init__(self, text): # client string input, e.g. \"3 * 5\", \"12 / 3 * 4\", etc self.text = text # self.pos is an index into self.text self.pos = 0 self.current_char = self.text[self.pos] def error(self): raise Exception('Invalid character') def advance(self): \"\"\"Advance the `pos` pointer and set the `current_char` variable.\"\"\" self.pos += 1 if self.pos &gt; len(self.text) - 1: self.current_char = None # Indicates end of input else: self.current_char = self.text[self.pos] def skip_whitespace(self): while self.current_char is not None and self.current_char.isspace(): self.advance() def integer(self): \"\"\"Return a (multidigit) integer consumed from the input.\"\"\" result = '' while self.current_char is not None and self.current_char.isdigit(): result += self.current_char self.advance() return int(result) def get_next_token(self): \"\"\"Lexical analyzer (also known as scanner or tokenizer) This method is responsible for breaking a sentence apart into tokens. One token at a time. \"\"\" while self.current_char is not None: if self.current_char.isspace(): self.skip_whitespace() continue if self.current_char.isdigit(): return Token(INTEGER, self.integer()) if self.current_char == '+': self.advance() return Token(PLUS, '+') if self.current_char == '-': self.advance() return Token(MINUS, '-') if self.current_char == '*': self.advance() return Token(MUL, '*') if self.current_char == '/': self.advance() return Token(DIV, '/') self.error() return Token(EOF, None)class Interpreter(object): def __init__(self, lexer): self.lexer = lexer # set current token to the first token taken from the input self.current_token = self.lexer.get_next_token() def error(self): raise Exception('Invalid syntax') def eat(self, token_type): # compare the current token type with the passed token # type and if they match then \"eat\" the current token # and assign the next token to the self.current_token, # otherwise raise an exception. if self.current_token.type == token_type: self.current_token = self.lexer.get_next_token() else: self.error() def factor(self): \"\"\"factor : INTEGER\"\"\" token = self.current_token self.eat(INTEGER) return token.value def term(self): \"\"\"term : factor ((MUL | DIV) factor)*\"\"\" result = self.factor() while self.current_token.type in (MUL, DIV): token = self.current_token if token.type == MUL: self.eat(MUL) result = result * self.factor() elif token.type == DIV: self.eat(DIV) result = result / self.factor() return result def expr(self): \"\"\"Arithmetic expression parser / interpreter. calc&gt; 14 + 2 * 3 - 6 / 2 17 expr : term ((PLUS | MINUS) term)* term : factor ((MUL | DIV) factor)* factor : INTEGER \"\"\" result = self.term() while self.current_token.type in (PLUS, MINUS): token = self.current_token if token.type == PLUS: self.eat(PLUS) result = result + self.term() elif token.type == MINUS: self.eat(MINUS) result = result - self.term() return resultdef main(): while True: try: # To run under Python3 replace 'raw_input' call # with 'input' text = raw_input('calc&gt; ') except EOFError: break if not text: continue lexer = Lexer(text) interpreter = Interpreter(lexer) result = interpreter.expr() print(result)if __name__ == '__main__': main()将以上代码保存到名为 calc5.py 中，或者直接从 GitHub 上下载。和以往一样，自己尝 试一下，确认解释器可以对包含不同优先级操作符的算术表达式进行求值。梳理代码中有三个类(class)，他们中的函数及作用：Token：__init__：初始化实例__str__：字符串形式__repr__：字符串形式在Python中，所有以“_”双下划线包起来的方法，都统称为“Magic Method”（魔术方法）,例如类的初始化方法 __init_repr(self)定义当被 repr() 调用时的行为str(self)定义当被 str() 调用时的行为Lexer用于词法分析：__init__：初始化实例error：错误提示advance：使pos前进一个位置skip_whitespace：略过空格integer：识别整数（可以识别多位数）get_next_token：获得一个token（其实我觉得叫做：get_token_and_to_next更合适）Interpreter用于语法分析：__init__：初始化实例error：错误提示eat：负责检测当前的token.type与传入的token_type是否相同。若相同，则将当前的token“吃了”，然后把当前token的下一个token分配给current_token。下面就是语法分析的核心了，由上面的分析直到，它由：expr、term、factor构成。梳理完毕。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let's Build A Simple Interpreter","slug":"Let-s-Build-A-Simple-Interpreter","permalink":"https://longlongqin.github.io/tags/Let-s-Build-A-Simple-Interpreter/"}]},{"title":"Let’s Build A Simple Interpreter 4","slug":"学习笔记/Let's Build A Simple Interpreter/LSBASI-4","date":"2020-03-10T09:27:30.000Z","updated":"2020-03-24T07:56:38.973Z","comments":true,"path":"archives/3b16.html","link":"","permalink":"https://longlongqin.github.io/archives/3b16.html","excerpt":"","text":"原文链接：https://ruslanspivak.com/lsbasi-part4/在前面的文章中你学会了怎样识别和解释包含任意数量的加减操作的算术表达式，例如“7 - 3 + 2 - 1”。还学会了句法图以及它们如何被用来表示一门编程语言的语法。今天你将会学习解析(parse)和解释(interpret)包含任意乘除操作的算术表达式，例如“7 * 4 / 2 * 3”。在这篇文章中使用的是整数除法，所以对于表达式“9 / 4”来说，结果是一个 整数：2。我今天会讲很多另一个表示编程语言句法的广泛使用的表示法，叫 上下文无关语法 (context-free grammars, 简记为 grammars)或 BNF (Backus-Naur Form)。为了这篇文章的目的，我不会使用纯 BNF 记法，而更像是一个修改过的 EBNF 记法。文法(语法)：描述语言的语法结构的形式规则。上下文无关语法就是说这个文法中所有的产生式左边只有一个非终结符，比如：S -&gt; aSbS -&gt; ab这个文法有两个产生式，每个产生式左边只有一个非终结符S，这就是上下文无关文法，因为你只要找到符合产生式右边的串，就可以把它归约为对应的非终结符。比如：aSb -&gt; aaSbbS -&gt; ab这就是上下文相关文法，因为它的第一个产生式左边有不止一个符号，所以你在匹配这个产生式中的S的时候必需确保这个S有正确的“上下文”，也就是左边的a和右边的b，所以叫上下文相关文法。作者：徐辰链接：https://www.zhihu.com/question/21833944/answer/40689967来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。以下是一些使用语法的原因：语法使用了一种简明的方式来描述一门编程语言的句法。不像语法图，语法非常紧凑。 在以后的文章中，你会看到我越来越多地使用语法。语法可以做为文档保存。即使对从头开始写解析器(parser)来说，语法也是一个好的入手点。很多时候通过遵循 一套简单的规则你就可以把语法转化成代码。有一套工具，叫解析器生成器(parser generator)，可以把语法做为输入并自动根据它为你生成一个解析器。我会以后在这个系列中谈到这些工具。语法机制现在，我们来聊聊语法的机制方面：下面的语法描述了算术表达式，像“7 * 4 / 2 * 3”这样的（这只是该语法可以生成的许多表达式之一）：语法是由一系列规则组成的，也被称为产生式(production)。我们的语法中有两条规则(产生式)：1、一条规则由：一个非终结符(叫做 head或生成式的左边) + 一个分号（:）+ 一系列终结符 和/或 非终结符(叫做 body 或 右边)：2、在上面展示的语法中，像 MUL, DIV, 或 INTEGER 这样的 token 被称为 终结符(terminals), expr factor 这样的变量被称为 非终结符(not-terminals).第一条规则左边的非终结符被叫做 开始符号(start symbol). 在我们的语法中，开始符号是 expr:你可以这么理解 expr 这条规则：“expr 是一个 factor 后面可选地跟一个乘或除运算符再跟 另一个 factor，后面也相应可选地跟一个乘或除运算符再跟另一个 factor，如此重复”。factor 是什么？对于本文来说 factor 就是一个整数。语法中的符号让我们快速地过一遍语法中的符号及它们的意义。|多选一。竖线表示“或”。所以 (MUL | DIV) 表示 MUL 或 DIV(...)被括号包围表示把终结符 和/或 非终结符组成一组，就像 (MUL | DIV)(...)*分组中的内容被匹配 0 或 多次。语法通过解释可以组成什么样的句子来定义一门语言。通过语法派生出算术表达式的方式为：首先从开始符号 expr 开始，然后反复地使用所包含的非终结符的规则替换该非终结符， 直到生成一个只包含终结符的句子。语法能组成的句子构成了一门语言。下面举例说明：例1，下面是语法如何派生出表达式 3:例2，下面是语法如何派生出表达式 3 * 7:例3，下面是语法如何派生出表达式 3 * 7 / 2:将语法变成代码下面是一些我们在把语法转化成源代码时会用到的==四个准则==。按照这些准则，你真的就可以把语法翻译成一个可工作的 parser:对于语法中定义的每个规则 R，将它做成一个有相同名字的方法，对该规则的引用就变成了一个方法调用：R()。该方法的方法体遵循该规则的步骤，过程中使用相同的准则。多选一 (a1|a2|aN) 变成 if-elif-else 语句可选组 (...)* 变成一个可以执行 0 或多次的 while 循环（can loop over zero or more times）每个 Token 记为 T 变成一个 eat 方法调用: eat(T). eat 方法的工作是 当它匹配到当前的向前看 (lookahead) token 就消耗掉它，然后从 lexer 中得到一个新 token 并将它赋值给内部变量 current_token.这些准则看上去像这样：让我们继续并遵循上述准则把我们的语法转化为代码。我们的语法中有两条规则： expr 和 factor. 我们从 factor 规则（生成式）开始。 根据准则，需要新建一个名为 factor 的方法（准则1)，它调用了一次 eat 方法来消耗INTEGER token （准则4)：12def factor(self): #factor就是指的integer型数值 self.eat(INTEGER)expr 规则变成了 expr 方法（还是准则1）。规则体(body)开始的 factor 引用 变成了对 factor() 方法的调用。可行组 (...)* 变成了一个 while 循环，多选一 (MUL|DIV) 变成了一个 if-elif-else 语句。把这些片段合并在一起就得到了下面的expr 方法：1234567891011def expr(self): self.factor() #语法准则中的第一个factor while self.current_token.type in (MUL, DIV): token = self.current_token if token.type == MUL: self.eat(MUL) self.factor() elif token.type == DIV: self.eat(DIV) self.factor()原作者将本文的代码放在了文件 parser.py 中，它包含了 lexer 和 parser 但没有interpreter。你可以直接从 GitHub下载并尝试一下。它包含有一个 interpreter 提示符，你可以输入表达式来查看它是否合法，即查看根据语法建立的 parser 是否可以识别出表达式。下面是在我笔记本上的一次尝试：123456789101112131415161718192021$ python parser.pycalc&gt; 3calc&gt; 3 * 7calc&gt; 3 * 7 / 2calc&gt; 3 *Traceback (most recent call last): File \"parser.py\", line 155, in &lt;module&gt; main() File \"parser.py\", line 151, in main parser.parse() File \"parser.py\", line 136, in parse self.expr() File \"parser.py\", line 130, in expr self.factor() File \"parser.py\", line 114, in factor self.eat(INTEGER) File \"parser.py\", line 107, in eat self.error() File \"parser.py\", line 97, in error raise Exception('Invalid syntax')Exception: Invalid syntax这里再次提起语法图。这是相同的 expr 规则（也叫，产生式(production)）对应的句法图：下面是原作者的关于本文的源码。下面是可以处理包含任意数量整数 乘除（整数除法）操作的合法的算术表达式的计算器代码。这里把词法分析器重构 到了一个单独的类 Lexer 中，并让 Interpreter 类使用 Lexer 实例做为参数：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156# Token types## EOF (end-of-file) token is used to indicate that# there is no more input left for lexical analysisINTEGER, MUL, DIV, EOF = 'INTEGER', 'MUL', 'DIV', 'EOF'class Token(object): def __init__(self, type, value): # token type: INTEGER, MUL, DIV, or EOF self.type = type # token value: non-negative integer value, '*', '/', or None self.value = value def __str__(self): \"\"\"String representation of the class instance. Examples: Token(INTEGER, 3) Token(MUL, '*') \"\"\" return 'Token(&#123;type&#125;, &#123;value&#125;)'.format( type=self.type, value=repr(self.value) ) def __repr__(self): return self.__str__()#词法分析class Lexer(object): def __init__(self, text): # client string input, e.g. \"3 * 5\", \"12 / 3 * 4\", etc self.text = text # self.pos is an index into self.text self.pos = 0 self.current_char = self.text[self.pos] def error(self): raise Exception('Invalid character') def advance(self): \"\"\"Advance the `pos` pointer and set the `current_char` variable.\"\"\" self.pos += 1 if self.pos &gt; len(self.text) - 1: self.current_char = None # Indicates end of input else: self.current_char = self.text[self.pos] def skip_whitespace(self): while self.current_char is not None and self.current_char.isspace(): self.advance() def integer(self): \"\"\"Return a (multidigit) integer consumed from the input.\"\"\" result = '' while self.current_char is not None and self.current_char.isdigit(): result += self.current_char self.advance() return int(result) #不如叫做：get_token_and_next def get_next_token(self): \"\"\"Lexical analyzer (also known as scanner or tokenizer) This method is responsible for breaking a sentence apart into tokens. One token at a time. \"\"\" while self.current_char is not None: if self.current_char.isspace(): self.skip_whitespace() continue if self.current_char.isdigit(): return Token(INTEGER, self.integer()) if self.current_char == '*': self.advance() return Token(MUL, '*') if self.current_char == '/': self.advance() return Token(DIV, '/') self.error() return Token(EOF, None)class Interpreter(object): def __init__(self, lexer): self.lexer = lexer # set current token to the first token taken from the input self.current_token = self.lexer.get_next_token() def error(self): raise Exception('Invalid syntax') def eat(self, token_type): # compare the current token type with the passed token # type and if they match then \"eat\" the current token # and assign the next token to the self.current_token, # otherwise raise an exception. if self.current_token.type == token_type: self.current_token = self.lexer.get_next_token() else: self.error() def factor(self): \"\"\"Return an INTEGER token value. factor : INTEGER \"\"\" token = self.current_token self.eat(INTEGER) return token.value def expr(self): \"\"\"Arithmetic expression parser / interpreter. expr : factor ((MUL | DIV) factor)* factor : INTEGER \"\"\" result = self.factor() while self.current_token.type in (MUL, DIV): token = self.current_token if token.type == MUL: self.eat(MUL) result = result * self.factor() elif token.type == DIV: self.eat(DIV) result = result / self.factor() return resultdef main(): while True: try: # To run under Python3 replace 'raw_input' call # with 'input' text = raw_input('calc&gt; ') except EOFError: break if not text: continue lexer = Lexer(text) interpreter = Interpreter(lexer) result = interpreter.expr() print(result)if __name__ == '__main__': main()将以上代码保存到名为 calc4.py 中，或者直接从 GitHub 上下载。和以往一样，自己尝 试一下，确认它能工作。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let's Build A Simple Interpreter","slug":"Let-s-Build-A-Simple-Interpreter","permalink":"https://longlongqin.github.io/tags/Let-s-Build-A-Simple-Interpreter/"}]},{"title":"Let’s Build A Simple Interpreter 3","slug":"学习笔记/Let's Build A Simple Interpreter/LSBASI-3","date":"2020-03-10T06:28:09.000Z","updated":"2020-03-24T05:48:57.917Z","comments":true,"path":"archives/f957.html","link":"","permalink":"https://longlongqin.github.io/archives/f957.html","excerpt":"","text":"原文链接：https://ruslanspivak.com/lsbasi-part3/目前为止，你已经学习了如何解释整数相加或相减的算术表达式如“7+3”或“12-9”。今天我 会聊一聊怎样解析（识别）并解释包含多位整数的加减法的算术表达式，如“7 - 3 + 2 - 1”。语法图本文中的算术表达式可以用如下的语法图(syntax diagram)表示：语法图(syntax diagram)：就是程序语言句法规则的图形表示。基本上，语法图从视觉上向你展示了在你的程序语言中哪些语句是允许的哪些是不允许的。句法图很容易阅读：只需跟随箭头所指示的路径即可。一些路径表示选择，一些路径表示循环。你可以这样阅读上面的句法图：一个 term 后面可以跟一个加号或减号，后面又跟另一个 term， 相应地它后面又可以跟一个加号或减号，后面又跟另一个 term，如此循环。你已经读懂了 这幅图片，真的。你可能会疑惑什么是“term”。在这篇文章中“term”就是一个整数。语法图的用途本文中的语法图主要有两个用途：从图形上表示一个编程语言的标准（语法）。用来帮助你编写parser(语法分析器)，你可以通过下面简单的规则将图映射到代码。语法分析器你已经学过了从 token 流中识别组合的过程叫 parsing. 且解释器或编译器中执行这部分任务的叫 parser. parsing也被称为 语法分析 (syntax analysis)，parser也相应地被称为语法分析器(syntax analyzer)，你应该也猜到这点了。根据上面的句法图，下面所有的算术表达式都是合法的：33 + 47 - 3 + 2 - 1因为在不同的程序语言中算术表达式的句法规则都相似，我们可以使用 Python shell 来 “测试”我们的句法图。启动 Python shell 自己试一下：123456&gt;&gt;&gt; 33&gt;&gt;&gt; 3 + 47&gt;&gt;&gt; 7 - 3 + 2 - 15一切正常。但表达式“3+”就不是合法的算术表达式，因为根据句法图加号后面必须跟一个 term（整数）， 否则就是句法错误。两次启动 Python shell 自己查看结果：12345&gt;&gt;&gt; 3 + File \"&lt;stdin&gt;\", line 1 3 + ^SyntaxError: invalid syntax使用 Python shell 来做测试是挺不错的，不过我们还是把上面的句法图映射到代码，用我 们自己的解释器来测试，是吧？从前面的文章（第一部分和第二部分）你知道了 parser 和 interpreter 都在 expr 方 法中。再重复一下，parser只是识别出结构并保证它符合某些规范，interpreter在parser成功识别后对表达式进行求值。下面的代码片段展示了与句语法图相对应的 parser 的代码。语法图中的矩形盒子变成了解析一个整数的 term 方法， expr 方法则只是跟随了语法图的指示：123456789101112131415def term(self): self.eat(INTEGER)def expr(self): # set current token to the first token taken from the input self.current_token = self.get_next_token() self.term() while self.current_token.type in (PLUS, MINUS): token = self.current_token if token.type == PLUS: self.eat(PLUS) self.term() elif token.type == MINUS: self.eat(MINUS) self.term()可以看到 expr 方法首先调用了 term 方法。然后是一个可能执行 0 或多次的循环。 在循环中，parser 根据 token （是加号还是减号）来做选择。Parser 本身并不解释任何事：如果识别到一个表达式它就沉默，否则就抛出一个句法错误。 让我们修改 expr 方法来添加 interpreter 代码：12345678910111213141516171819202122def term(self): \"\"\"Return an INTEGER token value\"\"\" token = self.current_token self.eat(INTEGER) return token.valuedef expr(self): \"\"\"Parser / Interpreter\"\"\" # set current token to the first token taken from the input self.current_token = self.get_next_token() result = self.term() while self.current_token.type in (PLUS, MINUS): token = self.current_token if token.type == PLUS: self.eat(PLUS) result = result += self.term() elif token.type == MINUS: self.eat(MINUS) result = result - self.term() return result因为 interpreter 需要对表达式进行求值，所以 term 方法被修改为返回一个整数值， expr 方法被修改为在适当的地方执行加减法并返回解释的结果。让我们继续前进，来看一下现在解释器的完整代码怎么样？下面是你新版计算器的源代码，它可以处理包含任意多个整数的加减操作的合法算术表达式：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128# Token的类型：'INTEGER', 'PLUS', 'MINUS', 'EOF'# Token的值(value)：整数，'+', '-', or NoneINTEGER, PLUS, MINUS, EOF = 'INTEGER', 'PLUS', 'MINUS', 'EOF'#定义Token类class Token(object): def __init__(self, type, value): self.type = type self.value = value def __str__(self): return 'Token( &#123;type&#125;, &#123;value&#125; ) ' .format( type = self.type , value = repr(self.value) #repr与下面的__repr__不一样，下面的是重构的。 ) def __repr__(self): return self.__str__()class Interpreter(object): def __init__(self, text): self.text = text self.pos = 0 self.currrent_token = None #此时还没有token实例所以是None self.current_char =self.text[self.pos] ########################################################## # Lexer code # ########################################################## def error(self): raise Exception('Invalid syntax') def advance(self): self.pos += 1 if self.pos &gt; len(self.text) -1 : self.current_char =None else: self.current_char = self.text[self.pos] def skip_whitespace(self): while self.current_char is not None and self.current_char.isspace(): self.advance() def integer(self): result = '' while self.current_char is not None and self.current_char.isdigit(): result += self.current_char self.advance() return int(result) #词法分析(分析之后形成一个个的token) def get_next_token(self): while self.current_char is not None: if self.current_char.isspace(): self.skip_whitespace() continue #识别整数 if self.current_char.isdigit(): return Token(INTEGER, self.integer() ) # 识别是否为+ - 运算符号 if self.current_char == '+': self.advance() return Token(PLUS, '+') if self.current_char == '-': self.advance() return Token(MINUS, '-') self.error() return Token(EOF, None) ########################################################## # Parser / Interpreter code # ########################################################## #比较当前的token的类型与传来的类型是否相同 def eat(self, token_type): if self.currrent_token.type == token_type: self.currrent_token = self.get_next_token() else: self.error() #返回一个整型的token的value def term(self): token = self.currrent_token self.eat(INTEGER) return token.value def expr(self): self.currrent_token = self.get_next_token() result = self.term() while self.currrent_token.type in (PLUS , MINUS): #循环是为了算不止一次的加or减法，从而达到混合运算的目的 token = self.currrent_token if token.type == PLUS: self.eat(PLUS) result = result + self.term() elif token.type == MINUS: self.eat(MINUS) result = result - self.term() return result def main(): while True: try: # To run under Python3 replace 'raw_input' call # with 'input' text = input('calc&gt; ') except EOFError: break if not text: continue interpreter = Interpreter(text) result = interpreter.expr() print(result)if __name__ == '__main__': main()将以上代码保存到名为 calc3.py 中，或者直接从 GitHub 上下载。试一试。亲眼看一下 它可以处理之前展示给你的句法图中包含的算术表达式规则。梳理输入字符串表达式（如“2+8-6+1”)，存入变量text中将text进行词法分析，执行此功能的是get_next_token()函数，词法分析会生成一个个的token然后对词法分析之后的token按照规定的语法，进行语法分析，相应函数为expr()最后输出结果","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let's Build A Simple Interpreter","slug":"Let-s-Build-A-Simple-Interpreter","permalink":"https://longlongqin.github.io/tags/Let-s-Build-A-Simple-Interpreter/"}]},{"title":"3、布尔逻辑和逻辑门","slug":"学习笔记/《计算机科学速成课》笔记/3、布尔逻辑和逻辑门","date":"2020-03-09T17:01:26.000Z","updated":"2020-03-17T08:46:49.337Z","comments":true,"path":"archives/87ef.html","link":"","permalink":"https://longlongqin.github.io/archives/87ef.html","excerpt":"计算机最早的是机电设备，一般使用十进制计数，比如用齿轮数来代表十进制。但是其实只用开/关两种状态已经足够表示信息了，将其称为二进制（Binary）。","text":"计算机最早的是机电设备，一般使用十进制计数，比如用齿轮数来代表十进制。但是其实只用开/关两种状态已经足够表示信息了，将其称为二进制（Binary）。在计算机中，当电流流过时，为闭合状态，表示true（1），当没有电流流过时，为断开状态，表示false（0）。但是其实晶体管可以不只是开/关状态，还可以让不同大小的电流通过，一些早期电子计算机，通过对不同电流大小进行划分，可以使用三进制、五进制等等。但问题是，状态越多就越难区分信号，如果存在电噪音，可能就会使状态十分混乱。所以为了让信号更加清晰，可以只使用“开”和“关”两种状态。另一个使用二进制的原因是，有一整个数学分支专门处理“真”和“假”，它已解决了所有法则和运算，即布尔代数（Boolean Algebra）。布尔代数（Boolean Algebra）与逻辑门在布尔代数中，变量的值是true和false，能够对其进行逻辑操作。布尔代数中有三个基本操作：NOT、AND和OR。NOT GATENOT：把输出端（就像水龙头左边部分送水，它送电）接在上面的电极，如果打开输出，电流就可以流过，然后“接地”，输出就没有电流，所以输出是off。当输入关闭时，电流没法接地，就流过了输出，所以输出是on。就像是水龙头一样：​​ NOT操作：把布尔值进行翻转，所以NOT操作的真值表为AND GATEAND：为了实现“AND 门”，我们需要2个晶体管连接在一起，这样有2个输入和1个输出。如果只打开A，不打开B，电流无法留到output，所以输出是false；如果只打开B，不打开A，也一样，电流无法留到output；只有当A、B都打开了，output才有电流。OR GATEOR：实现OR 门除了晶体管还需要额外的线将两个晶体管(transistor)并联起来，即得到OR GATE左侧电极为电源，下方两个电极分别表示两个输入，右侧电极为输出。只要任意一个输入开启，就能使得电源和输出电极接通，使得输出开启；当两个输入都关闭时，就使得电源和输出电极保持断开状态，使得输出保持关闭。由此通过上方的三个组件（NOT门、AND门和OR门）可以构建出更加复杂的组件。另一个常见的布尔操作叫做异或操作。XOR(异或)我们有两个输入，A和B，还有一个输出。先放一个OR门。因为OR和XOR的逻辑表很像，只有一个不同点就是：当两个输入都为true时，XOR输出false，而OR输出true。通过对AND操作真值表取反，再和OR操作真值表进行对比，可以发现，第二三行都为true，而第一四行结果不同，因此只要在这两个结果后面加个AND就能得到XOR的真值表。小结操作真值表：对应的罗基本表示：","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"计算机科学速成课","slug":"计算机科学速成课","permalink":"https://longlongqin.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE/"},{"name":"布尔逻辑和逻辑门","slug":"布尔逻辑和逻辑门","permalink":"https://longlongqin.github.io/tags/%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91%E5%92%8C%E9%80%BB%E8%BE%91%E9%97%A8/"}]},{"title":"Let’s Build A Simple Interpreter 2","slug":"学习笔记/Let's Build A Simple Interpreter/LSBASI-2","date":"2020-03-09T13:55:47.000Z","updated":"2020-03-23T09:50:36.594Z","comments":true,"path":"archives/d57d.html","link":"","permalink":"https://longlongqin.github.io/archives/d57d.html","excerpt":"If you learn only methods, you’ll be tied to your methods. But if you learnprinciples, you can devise your own methods.","text":"If you learn only methods, you’ll be tied to your methods. But if you learnprinciples, you can devise your own methods.原文地址：https://ruslanspivak.com/lsbasi-part2/这是第二个版本V2.0，第二个版本较第一个版V1.0，它可以做到：处理输入字符串中任何位置的空白符处理输入中的多位数两个整数相减（版本V1.0中只有加法）下面先给出V2.0的新版计算器的源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152# Token types# EOF (end-of-file) token is used to indicate that# there is no more input left for lexical analysisINTEGER, PLUS, MINUS, EOF = 'INTEGER', 'PLUS', 'MINUS', 'EOF'class Token(): def __init__(self, type, value): # token type: 'INTEGER', 'PLUS', 'MINUS', or 'EOF' self.type = type # token value: non-negative integer value, '+', '-', or None self.value = value def __str__(self): \"\"\"String representation of class instance Examples: Token(INTEGER, 3) Token(PLUS, '+') \"\"\" return f'Token(&#123;self.type&#125;, &#123;self.value&#125;)' def __repr__(self): return self.__str__()##__repr__() 与 __str__() 的主要区别在于，前者在交互式步骤中显示结果，后者在 print 函数中显示结果。 class Interpreter(): def __init__(self, text): # client string input, e.g. \"3 + 5\", \"12 - 5\", etc self.text = text # self.pos is an index into self.text self.pos = 0 # current token instance self.current_token = None self.current_char = self.text[self.pos] def error(self): raise Exception('Error parsing input') ########新增####### def advance(self): \"\"\"Advance the 'pos' pointer and set the 'current_char' variable.\"\"\" self.pos += 1 if self.pos &gt;= len(self.text): self.current_char = None # Indicates end of input else: self.current_char = self.text[self.pos] def skip_whitespace(self): while self.current_char is not None and self.current_char.isspace(): self.advance() def integer(self): \"\"\"Return a (multidigit) integer consumed from the input.\"\"\" result = '' while self.current_char is not None and self.current_char.isdigit(): result += self.current_char self.advance() return int(result) ##新增 完毕##### def get_next_token(self): \"\"\"Lexical analyzer (also known as scanner or tokenizer) This method is responsible for breaking a sentence apart into tokens. \"\"\" while self.current_char is not None: if self.current_char.isspace(): self.skip_whitespace() continue if self.current_char.isdigit(): return Token(INTEGER, self.integer()) if self.current_char == '+': self.advance() return Token(PLUS, '+') if self.current_char == '-': self.advance() return Token(MINUS, '-') self.error() return Token(EOF, None) def eat(self, token_type): # compare the current token type with the passed token # type and if they match then \"eat\" the current token # and assign the next token to the self.current_token, # otherwise raise an exception. if self.current_token.type == token_type: self.current_token = self.get_next_token() else: self.error() def expr(self): \"\"\"Parser / Interpreter expr -&gt; INTEGER PLUS INTEGER expr -&gt; INTEGER MINUS INTEGER \"\"\" # set current token to the first token from the input self.current_token = self.get_next_token() # we expect the current token to be an integer left = self.current_token self.eat(INTEGER) # we expect the current token to be either a '+' or '-' op = self.current_token if op.type == PLUS: self.eat(PLUS) elif op.type == MINUS: self.eat(MINUS) else: self.error() # we expect the current token to be an integer right = self.current_token self.eat(INTEGER) # after the above call the self.current_token is set to # EOF token # at this point either the INTEGER PLUS INTEGER or # the INTEGER MINUS INTEGER sequence of tokens # has been successfully found and the method can just # return the result of adding or subtracting two integers, # thus effectively interpreting client input if op.type == PLUS: result = left.value + right.value elif op.type == MINUS: result = left.value - right.value else: self.error() return resultdef main(): while True: try: # To run under Python3 replace 'raw_input' call with 'input' text = input('calc&gt; ') except EOFError: break if not text: continue interpreter = Interpreter(text) result = interpreter.expr() print(result)if __name__ == '__main__': main()把以上代码保存到名为 calc2.py 中，或者直接从 GitHub 上下载。试一试。亲眼看一下 它可以按预期运行：它可以处理输入中的任何位置的空白符；它接受多位整数，除了整数相 加还可以处理整数相减。下面可以再笔记本上次尝试：123456$ python calc2.pycalc&gt; 27 + 330calc&gt; 27 - 720calc&gt;与第一部分相比代码的主要变化有：get_next_token 方法做了一点重构。增加指针 pos 的逻辑被重构到了方法 advance 中。增加了两个方法： skip_whitespace 用来忽略空白符， integer 用来处理输入中的多位整数。expr 方法在修改后，除了可以识别 INTEGER -&gt; PLUS -&gt; INTEGER 这个组合(phrase) 之外，还可以识别INTEGER -&gt; MINUS -&gt; INTEGER。而且在成功识别相应的组合后，也可以进行相应的加减操作。在第一部分你尝到了两个重要的概念，即 token 和 词法分析器 。今天我想聊一聊 lexeme 、 parsing 和 parser 。你已经知道 token 了。但为了叙述方便，需要介绍一下 lexeme。什么是 lexeme？ lexeme 是组成 token 的一个字符序列。在下面的图片中是一些 token 和 lexeme 的例子， 希望它能把两者之间的关系表达清楚：现在还记得 expr 方法吗？我以前说过这是真正解释算术表达式的地方。但在解释一个表达式之前，你需要知道它是哪种组合，比如相加或相减。这是 expr 方法本质上做的事： 它从 get_next_token 方法得到的 token 流中找到结构，然后解释它识别出的组合，产 生算术表达式的结果。又到了做练习的时间了。扩展计算器以处理两个整数相乘扩展计算器以处理两个整数相除修改代码以使它可以解释包含任意个数字的加减操作，如“9 - 5 + 3 + 11”本节检测：什么是 lexeme？在 token 流中找到结构的过程叫什么？或者这么问，在 token 流中识别出特定组合的过程叫什么？解释器（编译器）做 parsing 工作的部分叫什么？梳理：首先输入一个表达式，如“3+9”，送给解释器Interpreter开始对这个表达式拆分成一个个的token，这一步叫做词法分析，由词法分析器(lexical analyzer)来完成。在本文中，函数get_next_token就相当于词法分析器。词法分析器get_next_token处理完之后的是一个个的token(type , value)然后开始进行语法分析（由于本文中只实现了加法、减法），所以这里的语法分析就是分析：加、减法的表达式。执行这个步骤的是expr函数，其中expr 方法使用了辅助方法eat来验证传给token的类型与当前类型是否相匹配。与现有语法规则（即，加法规则和减法规则）不匹配，eat就会抛出异常。语法分析完成之后，就直接得出算式的结果。（这也很符合解释器的特性嘛：边解释边执行，不会生成目标代码）其他的函数：Interpretererror(self)：当有错误的时候，就调用它advance(self)：增加指针pos的作用，即，将指向下一个tokenskip_whitespace(self)：跳过空格，V2.0新增加的功能integer(self)：为了可以算多位数的加减法。这里要注意：如3和233是两个整数类型的token，但是值得注意的是这篇文章中的token是按照输入的一串字符串（如“3+155”）每一个都当成一个token。也就是说本来155是一个token，但是从细节上看，在代码实现中155是被当成了三次“token”然后经过integer函数才形成了最终形体155这个token。在本系列的下一篇文章中你会扩展你的计算器来处理更复杂的算术表达式。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let’s Build A Simple Interpreter","slug":"Let’s-Build-A-Simple-Interpreter","permalink":"https://longlongqin.github.io/tags/Let%E2%80%99s-Build-A-Simple-Interpreter/"}]},{"title":"Let’s Build A Simple Interpreter 1","slug":"学习笔记/Let's Build A Simple Interpreter/LSBASI-1","date":"2020-03-08T09:26:27.000Z","updated":"2020-04-19T14:38:29.546Z","comments":true,"path":"archives/427485bf.html","link":"","permalink":"https://longlongqin.github.io/archives/427485bf.html","excerpt":"为什么要你学解释器和编译器？这里有三条理由。","text":"为什么要你学解释器和编译器？这里有三条理由。要写一个解释器或编译器，你必须同时用到很多技术。编写一个解释器或编译器会帮助 你提高这些技能并且成为一个更好的软件开发者。而且，你将学到的这些技能在开发任 何软件时都有可能用到，而不仅仅是解释器或编译器。你确实想要知道计算机如何工作。一般解释器和编译器看上去都像魔法一样。但你不应 该对这些魔法感到舒服。你想要揭开解释器和编译器的神秘面纱，理解它们如何工作并 控制所有一切。你想要创造自己的编程语言或者领域特定语言。如果是这样，你就需要为这个语言创建 一个解释器或编译器。最近，创建新语言再度兴起。你几乎每天都可以看到一门新语言 的诞生：Elixir, Go, Rust 等。原文链接：https://ruslanspivak.com/lsbasi-part1/好了，但什么是解释器和编译器呢？解释器与编译器解释器与编译器都是“高级语言与机器之间的翻译官”。都是将代码翻译成机器可以执行的二进制机器码，只不过在运行原理和翻译过程不同。那它们的区别在于：编译器：先整体编译完，然后一次性执行。比如：C语言代码被编译成二进制代码（exe程序），在windows平台上执行。解释器：解释一句后就提交计算机执行一句，即边解释边执行。比如php，postscritp，javascript就是典型的解释性语言。用一个通俗的例子来讲：我们去饭馆吃饭，点了八菜一汤。编译器的方式就是厨师把所有的菜给你全做好了，一起给你端上来，至于你在哪吃，怎么吃，随便。解释器的方式就是厨师做好一个菜给你上一个菜，你就吃这个菜，而且必须在饭店里吃。编译器与解释器的工作流程的差别：编译器与解释器的各自的特点：构造解释器V1.0该系列文章的作者使用 Python 编写Pascal语言的解释器。第一版V1.0，构造的计算器有诸多限制。如：只输入一位的数字现阶段仅支持加法操作输入中不允许有空白符这些约束使得构建一个计算器很简单，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125# Token types：# EOF (end-of-file) token is used to indicate that# there is no more input left for lexical analysisINTEGER, PLUS, EOF = 'INTEGER', 'PLUS', 'EOF'class Token(object): def __init__(self, type, value): # token type: INTEGER, PLUS, or EOF self.type = type # token value: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, '+', or None self.value = value def __str__(self): \"\"\"String representation of the class instance. Examples: Token(INTEGER, 3) Token(PLUS, '+') \"\"\" return 'Token(&#123;type&#125;, &#123;value&#125;)'.format( type=self.type, value=repr(self.value) ) def __repr__(self): return self.__str__()class Interpreter(object): def __init__(self, text): # client string input, e.g. \"3+5\" self.text = text # self.pos is an index into self.text self.pos = 0 # current token instance self.current_token = None def error(self): raise Exception('Error parsing input') def get_next_token(self): \"\"\"Lexical analyzer (also known as scanner or tokenizer) This method is responsible for breaking a sentence apart into tokens. One token at a time. \"\"\" text = self.text # is self.pos index past the end of the self.text ? # if so, then return EOF token because there no more # input left to convert into tokens if self.pos &gt; len(text) - 1: return Token(EOF, None) # get a character at the position self.pos and decide # what token to create based on the single character current_char = text[self.pos] # if the character is a digit then convert it to # integer, create an INTEGER token, increment self.pos # index to point to the next character after the digit, # and return the INTEGER token if current_char.isdigit(): token = Token(INTEGER, int(current_char)) self.pos += 1 return token if current_char == '+': token = Token(PLUS, current_char) self.pos += 1 return token self.error() def eat(self, token_type): # compare the current token type with the passed token # type and if they match then \"eat\" the current token # and assign the next token to the self.current_token, # otherwise raise an exception. if self.current_token.type == token_type: self.current_token = self.get_next_token() else: self.error() def expr(self): \"\"\"expr -&gt; INTEGER PLUS INTEGER\"\"\" # set current token to the first token taken from the input self.current_token = self.get_next_token() # we expect the current token to be a single-digit integer left = self.current_token self.eat(INTEGER) # we expect the current token to be a '+' token op = self.current_token self.eat(PLUS) # we expect the current token to be a single-digit integer right = self.current_token self.eat(INTEGER) # after the above call the self.current_token is set to # EOF token # at this point INTEGER PLUS INTEGER sequence of tokens # has been successfully found and the method can just # return the result of adding two integers, thus # effectively interpreting client input result = left.value + right.value return resultdef main(): while True: try: # To run under Python3 replace 'raw_input' call with 'input' text = input('calc&gt; ') except EOFError: break if not text: continue interpreter = Interpreter(text) result = interpreter.expr() print(result)if __name__ == '__main__': main()把以上代码保存到名为 calc1.py 中，或者直接从 GitHub 上下载。在你开始仔细研究代 码之前，在命令行上运行这个计算器并看它实现运行。把玩一下！下面是在我笔记本上的一 次尝试（如果你想在 Python3 下运行，就需要把 raw_input 替换为 input）：12345678$ python calc1.pycalc&gt; 3+47calc&gt; 3+58calc&gt; 3+912calc&gt;代码分析假设我们在命令行输入一个表达式“3+5”。你的解释器得到一个字符串 “3+5”。为了使解释器真正理解如何处理这个字符串，需要先把输入的 “3+5” 拆分成被叫做 token 的部件。词法分析：（lexical analysis，简称lexer，亦称scanner 或 tokenizer）​ 词法分析也称为 分词 ，此阶段编译器从左向右扫描源文件，将其字符流分割成一个个的 词 （ token 、 记号 ，后文中将称为 token ）。Token：​ 所谓 token ，就是源文件中不可再进一步分割的一串字符，类似于英语中单词，或汉语中的词。这里的 token 就是一个有类型的值的对象（即，token还存着值的类型）。例如对于字符串“3”来说，token 类型为 INTEGER ， 相应的值是整数 3 。解释器Interpreter要做的第一步就是读取输入的字符串并把他转化成 token 流。解释器中做这个工作的部分被称为 词法分析器(lexical analyzer)，简称 lexer 。也可以称它为： scanner 或 tokenizer 。他们的含义是一样的：表示解释器或编译器中将输入的字符串转化为 token 流的部分。那是如何转化为token流呢？解释器 Interpreter中的 get_next_token 方法就是你的词法分析器。你每次调用它，就会从输入到解释器的字符流中得到下一个 token。让我们仔细看一下这个方法，看看它是怎么把字符转化 为 token 的。输入被存放在变量 text 中，它保存了输入的字符串， pos 是指向该字符串的一个索引（把字符串看作是一个字符数组）。 pos 的初值被设为 0, 指向字符‘3’。 该方法首先检查该字符是不是数字，若是数字，就递增 pos 并返回一个类型为 INTEGER 值 为整数 3 的 token：现在 pos 指向了 text 中的字符‘+’，下次你调用这个方法时，它会先测试 pos 位 置的字符是否是数字，然后再测试它是否是加号，此时它是加号。这样该方法就递增 pos 并返回一个类型为 PLUS 值为‘+’的 token：现在 pos 指向了字符‘5’。当你再次调用 get_next_token 时，它会检查 pos 位置 是否是一个数字，此时是的，因此它递增 pos 并返回一个类型为 INTEGER 值为‘5’的 token：现在索引 pos 越过了字符串“3+5”的末尾，接下来每次调用 get_next_token 方法都会 返回 EOF token：自己动手试试看看你的计算器的 lexer 组件怎么工作的：123456789101112131415&gt;&gt;&gt; from calc1 import Interpreter&gt;&gt;&gt;&gt;&gt;&gt; interpreter = Interpreter('3+5')&gt;&gt;&gt; interpreter.get_next_token()Token(INTEGER, 3)&gt;&gt;&gt;&gt;&gt;&gt; interpreter.get_next_token()Token(PLUS, '+')&gt;&gt;&gt;&gt;&gt;&gt; interpreter.get_next_token()Token(INTEGER, 5)&gt;&gt;&gt;&gt;&gt;&gt; interpreter.get_next_token()Token(EOF, None)&gt;&gt;&gt;此时你的解释器已经可以从输入的字符流中获得 token 流了，解释器需要对它做点什么： 它需要从使用 lexer get_next_token 得到的字符流中找到结构。你的解释器期望从 流中找到如下的结构： INTEGER -&gt; PLUS -&gt; INTEGER. 即，它试着找到这样一个 token 序 列：整数后跟一个加号再跟一个整数。负责查找和解释这个结构的方法是 expr. 这个方法验证一个 token 序列是否遵从期望的 token 序列，即 INTEGER -&gt; PLUS -&gt; INTEGER. 当确定遵从这个结构后，它就把 PLUS 左 边和右边 token 的值相加来生成结果，从而成功地解释了你传给解释器的算术表达式。expr 方法使用了辅助方法 eat 来验证传给 eat 的 token 类型与当前的 token 类 型相匹配。在匹配到传入的 token 类型后， eat 方法会取得下一个 token 并把它赋值 给变量 current_token, 这样实际上是“吃掉”了当前匹配的 token 并把想象中的 token 流中的指针向前移动了。如果 token 流中的结构不遵从期望的 INTEGER PLUS INTEGER 序 列， eat 方法就会抛出一个异常。小结回顾一下你的解释器为了对一个算术表达式求值都做了什么：解释器接Interpreter收一个输入字符串，假设为“3+5”解释器调用了 expr 方法来从词法解析器 get_next_token 返回的 token 流中寻找一个结构。这个结构就是一个 INTEGER PLUS INTEGER 的形式。当确认了这个结构以后，它就使用把两个 INTEGER token 相加的方式来解释这个输入，因为此时解释器已经清楚 地知道它要做的就是把 3 和 5 两个整数相加。祝贺你。你刚刚学会了怎么构造你的第一个解释器！现在是时候做此练习了。你不会觉得你刚刚读了这篇文章就足够了，是吧？好了，自己动手做下面的练习：修改代码使得允许输入多位整数，例如“12+3”增加一个跳过空白符的方法，使你的计算器可以处理包含空白符的输入如 “ 12 + 3”修改代码使得它可以处理‘-’而非‘+’的情况检查你的理解。什么是解释器？什么是编译器？解释器和编译器的区别是什么？什么是 token？将输入拆分成 token 的过程叫什么？解释器中做词法分析的部分叫什么？解释器或编译器的这个部分还有什么其他常见的名字？相关文章链接：编译器与解释器：https://www.liujiangblog.com/course/python/9Let’s Build A Simple Interpreter. Part 1：https://feng-qi.github.io/2018/01/23/lets-build-a-simple-interpreter-part-01/","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let’s Build A Simple Interpreter","slug":"Let’s-Build-A-Simple-Interpreter","permalink":"https://longlongqin.github.io/tags/Let%E2%80%99s-Build-A-Simple-Interpreter/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.github.io"}},{"title":"2、电子计算机","slug":"学习笔记/《计算机科学速成课》笔记/2、电子计算机","date":"2020-03-07T19:02:53.000Z","updated":"2020-03-17T09:03:42.618Z","comments":true,"path":"archives/d84f.html","link":"","permalink":"https://longlongqin.github.io/archives/d84f.html","excerpt":"这个系列的课程还是值得大家去看一看的。这个系列的视频叫《计算机科学速成课》。虽然叫速成课，我们也要做到心中有数，它肯定不是让你看了这些内容你就什么都知道了。这是科普性的视频。这个视频都是被翻译好的，再次感谢这些翻译者。","text":"这个系列的课程还是值得大家去看一看的。这个系列的视频叫《计算机科学速成课》。虽然叫速成课，我们也要做到心中有数，它肯定不是让你看了这些内容你就什么都知道了。这是科普性的视频。这个视频都是被翻译好的，再次感谢这些翻译者。前言视频在B站上都有全集的，传送门：https://www.bilibili.com/video/av21376839在GitHub上的地址：https://github.com/1c7/crash-course-computer-science-chinese这门课总共有40节，每节课的标题为：计算机早期历史电子计算布尔逻辑与逻辑电路二进制算术逻辑单元寄存器 &amp; 内存中央处理器指令和程序高级 CPU 设计编程史话编程语言编程原理：语句和函数算法初步数据结构阿兰·图灵软件工程集成电路、摩尔定律操作系统内存 &amp; 储存介质文件系统压缩命令行界面屏幕 &amp; 2D 图形显示冷战和消费主义个人计算机革命图形用户界面3D 图形计算机网络互联网万维网网络安全黑客与攻击加密机器学习与人工智能计算机视觉自然语言处理机器人计算机中的心理学教育型科技奇点，天网，计算机的未来计算机早期历史这一张图大致说明了计算机早期发展的历史。图片来源：请查看图片本身链接。后面的课会较详细的讲解。电子计算机继电器在1937年最大的机电计算机之一是哈佛的马克一号(Harvard Mark Ⅰ)，是IBM在1944年给二战的同盟国建造的。该机器的大脑(CPU的基础器件)是“继电器”。继电器：是用电控制的机械开关，继电器里有根“控制线路”控制着电路的开关，“控制线路”连着一个线圈，当线圈通电时，会产生感应磁场，由此由此能够吸引上方的金属臂，从而闭合电路，得到高电平。它的性能：1940年一个好的继电器1秒能翻转50次。哈佛马克一号1秒能做3次加减法运算，一次乘法需要6秒，除法需要15秒，三角函数需要一分钟以上。它的缺点：控制开关的金属臂是“有质量的”，因此无法快速开关。并且金属臂的反复移动就会存在磨损（任何会动的机械都会随时间磨损），哈佛马克一号平均每天需要更换一个故障继电器。真空管在1904年，英国物理学家John Ambrose Fleming开发了新的电子组件——热电子管（Thermionic valve）。热电子管：把两个电极装在一个气密的真空玻璃灯泡中。其中一个点击A可以加热，从而发射电子，称为热电子发射（Thermionic emission）；另一个电极B会吸引电子，来形成电流。但只有当电极B带正电时才能吸引电子，否则当电极B带负电荷或者中性电荷时，电子就无法跨越真空区。美国发明家Lee de Forest在此基础上加入了第三个控制电极。通过向控制电极施加正电荷，就能吸引电子，从而闭合电路；而通过施加负电荷，就能闭合电路。特点：每秒可开闭数千次。和继电器相同的是，可以通过一个控制线路来控制断开或闭合电路，并且真空管内没有会动的组件，因此存在更少的磨损。比较脆弱，会像灯泡一样烧坏，并且体积比较大。真空管的出现，标志着计算机从机电转向电子，电子数值积分计算机ENIAC，在1946年于宾夕法尼亚大学设计制造，这是世上第一个真正的通用可编程电子计算机，每秒可执行5000次十位加减法。但是由于存在大量的真空管，因此ENIAC运行半天左右就会出现一次故障。晶体管晶体管：类似于继电器和真空管，晶体管也是一个用于控制电路闭合断开的开关。晶体管有两个电极，这两个电极之间通过半导体材料隔开。控制线连接到一个“门”电极，通过改“门”的电荷，我们可以控制半导体的导电性，由此来控制电流是否流动。当控制线路通电时，两个电极接通，否则两个电极断开。特点：每秒可开关10000次。相比玻璃制成的真空管，晶体管是固体的，并且体积远小于继电器和真空管。第一个消费者可购买的，完全由晶体管构成的计算机是1957年发布的IBM 608，它有3000个晶体管，每秒执行4500次加减法，或80次左右的乘除法。如今，计算机里的晶体管小于50nm，并且每秒可切换上百万次，工作几十年。很多晶体管和半导体开发在圣克拉拉谷，位于旧金山和圣河西之间，由于制造半导体最常见的材料是硅，由此这个地方被称为“硅谷”。并且William Shockley搬过去创建了肖克利半导体，里面的员工后来成立了仙童半导体，而这里面的员工后来创立了英特尔。所以，计算机的大脑基础单元的发展路径，可概括为：继电器-&gt;电子管-&gt;晶体管","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"《计算机科学速成课》","slug":"《计算机科学速成课》","permalink":"https://longlongqin.github.io/tags/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE%E3%80%8B/"}]},{"title":"Hexo之 Yilia主题配置","slug":"Hexo博客搭建/hexo之Ylia主题配置","date":"2020-03-06T14:50:08.000Z","updated":"2020-03-18T08:51:47.606Z","comments":true,"path":"archives/460671de.html","link":"","permalink":"https://longlongqin.github.io/archives/460671de.html","excerpt":"Yilia主题配置","text":"Yilia主题配置在左侧显示总文章数将themes\\yilia\\layout_partial\\left-col.ejs文件的1234567&lt;nav class=\"header-menu\"&gt; &lt;ul&gt; &lt;% for (var i in theme.menu)&#123; %&gt; &lt;li&gt;&lt;a href=\"&lt;%- url_for(theme.menu[i]) %&gt;\"&gt;&lt;%= i %&gt;&lt;/a&gt;&lt;/li&gt; &lt;%&#125;%&gt; &lt;/ul&gt;&lt;/nav&gt;后面加上123&lt;nav&gt; 总文章数 &lt;%=site.posts.length%&gt;&lt;/nav&gt;字数、阅读时长添加首先安装 hexo-wordcount使用如下命令安装：1npm i --save hexo-wordcount #如果安装了cnpm，可换为cnpm安装Node 版本7.6.0之前,请安装 2.x 版本 (Node.js v7.6.0 and previous)1Copynpm install hexo-wordcount@2 --save然后在 themes\\yilia\\layout\\_partial\\left-col.ejs中添加：123Copy&lt;nav&gt; 总字数 &lt;span class&#x3D;&quot;post-count&quot;&gt;&lt;%&#x3D; totalcount(site, &#39;0,0.0a&#39;) %&gt;&lt;&#x2F;span&gt;&lt;&#x2F;nav&gt;添加位置在如下代码的下面：123Copy&lt;nav&gt; 总文章数 &lt;%&#x3D;site.posts.length%&gt;&lt;&#x2F;nav&gt;编辑 themes\\yilia\\layout\\_partial\\article.ejs在header下面加入：123&lt;div align&#x3D;&quot;left&quot; class&#x3D;&quot;post-count&quot;&gt; &lt;!--其中align可以在：right、center、left--&gt; 字数：&lt;%&#x3D; wordcount(post.content) %&gt;字 | 预计阅读时长：&lt;%&#x3D; min2read(post.content) %&gt;分钟&lt;&#x2F;div&gt;即可显示单篇字数和预计阅读时长。置顶文章安装插件12npm uninstall hexo-generator-index --savenpm install hexo-generator-index-pin-top --save配置置顶标准打开：/themes/*/layout（/_macro）/post.ejs 直接在最前面加入以下代码即可12345&lt;% if (page.top) &#123; %&gt; &lt;i class=\"fa fa-thumb-tack\"&gt;&lt;/i&gt; &lt;font color=7D26CD&gt;置顶&lt;/font&gt; &lt;span class=\"post-meta-divider\"&gt;|&lt;/span&gt;&lt;% &#125; %&gt;配置文章然后在需要置顶的文章的Front-matter中加上top选项即可 top后面的数字越大，优先级越高12345---title: 2019date: 2019-02-14 16:10:03top: 5---增加不蒜子统计利用这个统计，可以知道你博客的访问量。安装不蒜子脚本：在themes\\yilia\\layout\\ _partial\\after-footer.ejs最后添加：1&lt;script async src=\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt;单篇文章点击量：在themes/yilia/layout/_partial/article.ejs中 在1&lt;%- partial(&#39;post&#x2F;title&#39;, &#123;class_name: &#39;article-title&#39;&#125;) %&gt;后面插入如下代码1234567891011&lt;!--显示阅读次数--&gt;&lt;% if (!index &amp;&amp; post.comments)&#123; %&gt; &lt;br/&gt; &lt;a class=\"cloud-tie-join-count\" href=\"javascript:void(0);\" style=\"color:gray;font-size:14px;\"&gt; &lt;span class=\"icon-sort\"&gt;&lt;/span&gt; &lt;span id=\"busuanzi_container_page_pv\" style=\"color:#ef7522;font-size:14px;\"&gt; 阅读数: &lt;span id=\"busuanzi_value_page_pv\"&gt;&lt;/span&gt;次 &amp;nbsp;&amp;nbsp; &lt;/span&gt; &lt;/a&gt;&lt;% &#125; %&gt;&lt;!--显示阅读次数完毕--&gt;增加版权声明配置yilia：在themes/yilia/layout/_partial/article.ejs中，标注的位置添加代码：1234567891011121314&lt;div class=\"article-entry\" itemprop=\"articleBody\"&gt; &lt;% if (post.excerpt &amp;&amp; index)&#123; %&gt; &lt;%- post.excerpt %&gt; &lt;% if (theme.excerpt_link) &#123; %&gt; &lt;a class=\"article-more-a\" href=\"&lt;%- url_for(post.path) %&gt;#more\"&gt;&lt;%= theme.excerpt_link %&gt; &gt;&gt;&lt;/a&gt; &lt;% &#125; %&gt; &lt;% &#125; else &#123; %&gt; &lt;%- post.content %&gt; &lt;% &#125; %&gt; &lt;-- 在此处添加代码--&gt; &lt;-- 在此处添加代码--&gt; &lt;-- 在此处添加代码--&gt; &lt;-- 在此处添加代码--&gt; &lt;% if ((theme.reward_type === 2 || (theme.reward_type === 1 &amp;&amp; post.reward)) &amp;&amp; !index)&#123; %&gt; &lt;div class=\"page-reward\"&gt; &lt;a href=\"javascript:;\" class=\"page-reward-btn tooltip-top\"&gt; &lt;div class=\"tooltip tooltip-east\"&gt;在目录：themes/yilia/source-src/css中创建新文件：declare.scss，并添加如下CSS代码：123456.declare &#123; background-color: #eaeaea; margin-top: 2em; border-left: 3px solid #ff1700; padding: .5em 1em;&#125;然后，为themes/yilia/source-src/css/main.scss，添加如下代码：1@import \"./declare\";配置显示：现在该让其显示出来，在themes/yilia/_config.yml，中加入：123456789#版权基础设定：0-关闭声明； 1-文章对应的md文件里有declare: true属性，才有版权声明； 2-所有文章均有版权声明#当前应用的版权协议地址。#版权协议的名称#版权协议的Logodeclare_type: 1licensee_url: https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by-nc-sa&#x2F;4.0&#x2F;licensee_name: &#39;知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议&#39;licensee_img: https:&#x2F;&#x2F;i.creativecommons.org&#x2F;l&#x2F;by-nc-sa&#x2F;4.0&#x2F;88x31.png然后在需要进行版权声明的文章的md文件头部，设置属性1declare:true即可。在主页时文章显示摘要在你 MD 格式文章正文插入 &lt;!-- more --&gt; 即可，只会显示它之前的，此后的就不显示，点击文章标题，，或者点击下面的按钮，即可进入全文。如：文章显示目录增加文章目录 TOC ( table of content )，方便阅读文章，在 themes/yilia/_config.yml 中进行配置 toc: 2 即可，它会将你 Markdown 语法的标题，生成目录，目录查看在右下角。头像设置设置存放位置：头像/图标图片的存放位置是/themes/yilia/source/下任意位置，可以自己新建一个文件夹存放，我存放在assets文件夹下。（我之前放在img中，但是不知道为什么，它就显示不出来）配置修改：配置文件为/themes/yilia/_config.yml。设置头像为配置文件中avatar一项，设置图标为配置文件中favicon一项，设置路径的根目录为/themes/yilia/source/。例如，我的头像存放的地址是/themes/yilia/source/assets/me.png，设置则为avatar: /assets/me.png。（图标同理）提交网页sitemap方式提交网页在 Hexo 根目录打开命令行工具，执行以下命令：123npm install hexo-generator-sitemap --savehexo cleanhexo g查看1&#123;your_hexo_path&#125;&#x2F;public文件夹，可以看到文件：1sitemap.xmlsitemap 的初衷是给搜索引擎看的，为了提高搜索引擎对自己站点的收录效果，我们最好手动到 google 和百度等搜索引擎提交 sitemap.xml。baidu提交网址：https://ziyuan.baidu.com/?castk=LTE%3D百度自动推送方式提交网页在本机1&lt;博客根目录&gt;&#x2F;themes&#x2F;yilia&#x2F;layout&#x2F;_partial目录下打开article.ejs文件，定位到如下这段代码：1234&lt;% var sUrl &#x3D; url.replace(&#x2F;index\\.html$&#x2F;, &#39;&#39;); sUrl &#x3D; &#x2F;^(http:|https:)\\&#x2F;\\&#x2F;&#x2F;.test(sUrl) ? sUrl : &#39;https:&#39; + sUrl; %&gt;在它前面加上：123456789101112131415161718&lt;!- 百度自动推送方式提交 --&gt;&lt;% if (1)&#123; %&gt; &lt;script&gt; (function()&#123; var bp &#x3D; document.createElement(&#39;script&#39;); var curProtocol &#x3D; window.location.protocol.split(&#39;:&#39;)[0]; if (curProtocol &#x3D;&#x3D;&#x3D; &#39;https&#39;) &#123; bp.src &#x3D; &#39;https:&#x2F;&#x2F;zz.bdstatic.com&#x2F;linksubmit&#x2F;push.js&#39;; &#125; else &#123; bp.src &#x3D; &#39;http:&#x2F;&#x2F;push.zhanzhang.baidu.com&#x2F;push.js&#39;; &#125; var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(bp, s); &#125;)(); &lt;&#x2F;script&gt;&lt;% &#125; %&gt;&lt;!- 百度自动推送方式提交结束 --&gt;即完成了新增博客文章页面（不包括其他页面）的自动推送方式提交。链接提交百度站长平台的链接提交方式分为自动提交和手动提交两种，此处只讲自动提交，手动提交按照要求操作即可。主动推送设置主动推送最为快速的提交方式，是被百度收录最快的推送方式。主动推送可以通过安装插件实现：首先安装插件：1npm install hexo-baidu-url-submit --save修改站点根目录下的配置文件_config.yml，添加以下内容：12345baidu_url_submit: count: 20 ## 提交最新的20个链接 host: www.dongshuyan.com ## 百度站长平台中注册的域名 token: ## 16位准入秘钥 path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里准入秘钥获取:在如下图的网址中：下拉，找到这里：点击进去就是准入秘钥。检查:其次，记得查看根目录下的_config.yml文件中url的值， 必须包含是百度站长平台注册的域名， 比如:123456# URL## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;url: http:&#x2F;&#x2F;dongshuyan.comroot: &#x2F;permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;permalink_defaults:最后，加入新的deployer最后，加入新的deployer:12345deploy:- type: git ## 这是我原来的deployer repo: branch:- type: baidu_url_submitter ## 添加这里内容即可这里的”-“,必不可少！ 否则报错。使用其主动推送的实现原理如下：新链接的产生， hexo generate 会产生一个文本文件，里面包含最新的链接新链接的提交， hexo deploy 会从上述文件中读取链接，提交至百度搜索引擎自动推送装自动推送JS代码的网页，在页面被访问时，页面URL将立即被推送给百度。修改主题目录下的layout/post.ejs文件，末尾添加自动推送代码，代码如下：1234567891011121314&lt;script&gt;(function()&#123; var bp &#x3D; document.createElement(&#39;script&#39;); var curProtocol &#x3D; window.location.protocol.split(&#39;:&#39;)[0]; if (curProtocol &#x3D;&#x3D;&#x3D; &#39;https&#39;) &#123; bp.src &#x3D; &#39;https:&#x2F;&#x2F;zz.bdstatic.com&#x2F;linksubmit&#x2F;push.js&#39;; &#125; else &#123; bp.src &#x3D; &#39;http:&#x2F;&#x2F;push.zhanzhang.baidu.com&#x2F;push.js&#39;; &#125; var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(bp, s);&#125;)();&lt;&#x2F;script&gt;出处：(http://dongshuyan.com/2019/05/24/hexo博客注意事项/#14-Hexo添加百度统计)添加百度统计和谷歌统计代码百度统计首先打开百度站长平台，注册账户。然后登陆 百度统计》管理》新增站点。然后复制生成的代码：123456789&lt;script&gt;var _hmt = _hmt || [];(function() &#123; var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?这里是你的专属字符串\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s);&#125;)();&lt;/script&gt;这一段代码，最重要的就是你那段专属的字符串。开始配置：首先，打开1themes&#x2F;yilia&#x2F;_config.yml里面1baidu_analytics: ''改为1baidu_analytics: true然后，打开：1themes/yilia/layout/_partial/baidu-analytics.ejs你会看到：1234567891011&lt;% if (theme.baidu_analytics)&#123; %&gt;&lt;script&gt;var _hmt &#x3D; _hmt || [];(function() &#123; var hm &#x3D; document.createElement(&quot;script&quot;); hm.src &#x3D; &quot;https:&#x2F;&#x2F;hm.baidu.com&#x2F;hm.js?&lt;%&#x3D; theme.baidu_analytics %&gt;&quot;; var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(hm, s);&#125;)();&lt;&#x2F;script&gt;&lt;% &#125; %&gt;这里，我们直接用你的专属字符串去替换&lt;%= theme.baidu_analytics %&gt;就行了。替换后为：1234567891011&lt;% if (theme.baidu_analytics)&#123; %&gt;&lt;script&gt;var _hmt &#x3D; _hmt || [];(function() &#123; var hm &#x3D; document.createElement(&quot;script&quot;); hm.src &#x3D; &quot;https:&#x2F;&#x2F;hm.baidu.com&#x2F;hm.js?你的专属字符串&quot;; var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(hm, s);&#125;)();&lt;&#x2F;script&gt;&lt;% &#125; %&gt;谷歌统计参考：http://yansheng836.coding.me/article/eda67a25.html","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://longlongqin.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Yilia主题配置","slug":"Yilia主题配置","permalink":"https://longlongqin.github.io/tags/Yilia%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"}]},{"title":"Hexo之Matery主题配置","slug":"Hexo博客搭建/Hexo之Matery主题配置","date":"2020-03-05T09:29:38.000Z","updated":"2020-03-17T08:27:59.163Z","comments":true,"path":"archives/514b.html","link":"","permalink":"https://longlongqin.github.io/archives/514b.html","excerpt":"最近的三天一直在折腾hexo框架的博客，先是使用yilia主题，但是用来一天觉得我不适合这个主题，随即看到了matery主题。","text":"最近的三天一直在折腾hexo框架的博客，先是使用yilia主题，但是用来一天觉得我不适合这个主题，随即看到了matery主题。前言今天又折腾了白天一天时间，我这个是直接克隆的hongweiの博客，这是一个大佬呀，还要多多向他学习。然后，只把一些简单的配置弄好了。现在梳理一下：已完成的配置：404页面简历建站时间设置个人域名（已购买域名，单还需要审核，明天再去弄。）不蒜子设置 添加评论插件 网站SEO优化 百度收录站点 1.验证网站所有权 谷歌收录站点 优化你的URL 添加代码块复制功能 添加文章更新时间功能非必要配置（已经取消）：添加网易云音乐BGM添加鼠标点击烟花爆炸效果添加页面樱花飘落效果添加鼠标点击文字特效添加页面雪花飘落动效优化网站加载速度数学公式渲染和代码高亮其他搜索引擎收录你的站点添加动漫人物增加emoji支持添加博客动态标签添加博客天气插件GitHub&amp;coding pages双部署修复Valine评论的头像不显示问题配置代码高亮由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 hexo-prism-plugin 的 Hexo 插件来做代码高亮，安装命令如下：1npm i -S hexo-prism-plugin然后，修改 Hexo 根目录下 _config.yml 文件中 highlight.enable 的值为 false，并新增 prism 插件相关的配置，主要配置如下：12345678highlight: enable: falseprism_plugin: mode: 'preprocess' # realtime/preprocess theme: 'tomorrow' line_number: false # default false custom_css:遇到的问题1、Cannot set property &#39;lastIndex&#39; of undefined运行hexo g出现Cannot set property ‘lastIndex’ of undefined解决方法：修改配置文件的 _config.yml，注意不是主题里面的配置文件，把 auto_detect 设置为false 即可。2、代码显示异常解决方法：首先，修改 Hexo 根目录下 _config.yml 文件中 highlight.enable 的值为 false。然后hexo clean&amp; hexo g&amp; hexo s好了。注：作者给的解决方案比我这个要多一步，我在这里贴出来，供大家参考。3、目录定位内容有偏差我反复的去测试，后来发现，可能有两个原因会导致这个问题的出现：网页没有刷新完全的时候，点击目录他有可能不会跳转。解决方法：法一：等待网页刷新完全。法二：手动的去停止网页的刷新（这个来的比较快一点，哈哈）你的文章的标题格式有问题，比如，我用Typora软件来写文章，这个软件就是所写即所得。但是这样你就不容易发现格式细节处的错误。错误示范：我先写了一个一级标题，然后，我又点击引用，就变成这样了：这种写法在Typora中，是不会认为它是一级标题的。我们打开源码查看他的格式：&gt; # 配置。他的格式是这样的。就是这里出错了，在matery主题中这样写它仍然会识别成标题，然后就导致从这个标题开始后面的标题，在你点击这些标题的时候，它会定位错误。解决方法：我们一定要遵循Markdown格式的语法，一定要，一定要。","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://longlongqin.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"matery主题配置","slug":"matery主题配置","permalink":"https://longlongqin.github.io/tags/matery%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"}]},{"title":"Tsinghua_Online_Judge_练习","slug":"Tsinghua-Online-Judge-练习","date":"2020-03-04T09:23:29.000Z","updated":"2020-04-13T10:24:02.448Z","comments":true,"path":"archives/d4fa.html","link":"","permalink":"https://longlongqin.github.io/archives/d4fa.html","excerpt":"","text":"CG2017 PA1-1 Convex Hull (凸包)题目Description (描述)After learning Chapter 1, you must have mastered the convex hull very well. Yes, convex hull is at the kernel of computational geometry and serves as a fundamental geometric structure. That’s why you are asked to implement such an algorithm as your first programming assignments.Specifically, given a set of points in the plane, please construct the convex hull and output an encoded description of all the extreme points.经过了第一章的学习，想必你对于凸包的认识已经非常深刻。是的，凸包是计算几何的核心问题，也是一种基础性的几何结构。因此你的第一项编程任务，就是来实现这样的一个算法。具体地，对于平面上的任意一组点，请构造出对应的凸包，并在经过编码转换之后输出所有极点的信息。Input (输入)The first line is an integer n &gt; 0, i.e., the total number of input points.The k-th of the following n lines gives the k-th point:pk = (xk, yk), k = 1, 2, …, nBoth xk and yk here are integers and they are delimited by a space.第一行是一个正整数首行为一个正整数n &gt; 0，即输入点的总数。随后n行中的第k行给出第k个点：pk = (xk, yk), k = 1, 2, …, n这里，xk与yk均为整数，且二者之间以空格分隔。Output (输出)Let { s1, s2, …, sh } be the indices of all the extreme points, h ≤ n. Output the following integer as your solution:( s1 * s2 * s3 * … * sh * h ) mod (n + 1)若 { s1, s2, …, sh } 为所有极点的编号, h ≤ n，则作为你的解答，请输出以下整数：( s1 * s2 * s3 * … * sh * h ) mod (n + 1)Sample Input (输入样例)12345678910111213141516171819202122231234567891011107 9-8 -1-3 -11 4-3 96 -47 56 6-6 100 8Sample Output (输出样例)12317 &#x2F;&#x2F; ( 9 x 2 x 6 x 7 x 1 x 5 ) % (10 + 1)Limitation (限制)3 ≤ n ≤ 10^5Each coordinate of the points is an integer from (-10^5, 10^5). There are no duplicated points. Each point is selected uniformly randomly in (-10^5, 10^5) x (-10^5, 10^5).All points on extreme edges are regarded as extreme points and hence should be included in your solution.Time Limit: 2 secSpace Limit: 512 MB3 ≤ n ≤ 10^5所有点的坐标均为范围(-10^5, 10^5)内的整数，且没有重合点。每个点在(-10^5, 10^5) x (-10^5, 10^5)范围内均匀随机选取极边上的所有点均被视作极点，故在输出时亦不得遗漏时间限制：2 sec空间限制：512 MBHint (提示)Use the CH algorithms presented in the lectures.课程中讲解过的凸包算法解答：Graham Scan算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;struct point &#123; long long x, y, id; point() :x(0), y(0) &#123;&#125; point(long long x, long long y) :x(x), y(y) &#123;&#125; bool operator ==(const point&amp; p) const &#123; return x == p.x &amp;&amp; y == p.y; &#125;&#125;PP; //PP: Polar Pointvector&lt;point&gt; points;long long area2(point p, point q, point s) &#123; /* |p.x p.y 1| |q.x q.y 1| == 2*DirectedTriangleArea(p,q,s) |s.x s.y 1| */ return p.x * q.y - s.x * q.y + q.x * s.y - q.x * p.y + s.x * p.y - p.x * s.y;&#125;bool toLeftTest(point p, point q, point s) &#123; //When return value large than 0, S is on the left side of ray PQ return area2(p, q, s) &gt; 0;&#125;bool toLeftTest2(point p, point q, point s) &#123; //When return value large than 0, S is on the left side of ray PQ return area2(p, q, s) &gt;= 0;&#125;bool cmp(const point&amp; p1, const point&amp; p2) &#123; // Sort according to polar angle return PP == p1 || !(PP == p2) &amp;&amp; toLeftTest(PP, p1, p2);&#125;point LTL(vector&lt;point&gt;&amp; points) &#123; //Lowest then leftmost point ltl = points[0]; for (int i = 1; i &lt; points.size(); i++) &#123; if (points[i].y &lt; ltl.y || points[i].y == ltl.y &amp;&amp; points[i].x &lt; ltl.x) ltl = points[i]; &#125; return ltl;&#125;vector&lt;point&gt; grahamScan() &#123; PP = LTL(points); sort(points.begin(), points.end(), cmp); vector&lt;point&gt; S, T; S.push_back(points[0]); S.push_back(points[1]); for (int i = points.size() - 1; i &gt; 1; i--)T.push_back(points[i]); while (!T.empty()) &#123; if (toLeftTest2(S[S.size() - 2], S[S.size() - 1], T[T.size() - 1])) &#123; S.push_back(T[T.size() - 1]); T.pop_back(); &#125; else S.pop_back(); &#125; return S;&#125;int main() &#123; ios::sync_with_stdio(false); long long n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; point tmp; cin &gt;&gt; tmp.x &gt;&gt; tmp.y; tmp.id = i; points.push_back(tmp); &#125; vector&lt;point&gt; result; if (points.size() &gt; 2)result = grahamScan(); else result = points; long long res = 1; for (int i = 0; i &lt; result.size(); i++) &#123; //cout &lt;&lt; result[i].id &lt;&lt; endl;//debug res = ((res % (n + 1)) * (result[i].id % (n + 1))) % (n + 1); &#125; res = ((res % (n + 1)) * (result.size() % (n + 1))) % (n + 1); cout &lt;&lt; res; system(\"pause\"); return 0;&#125;分数：92.5使用Graham Scan算法。凸包板子题。","categories":[{"name":"OJ","slug":"OJ","permalink":"https://longlongqin.github.io/categories/OJ/"}],"tags":[{"name":"OJ","slug":"OJ","permalink":"https://longlongqin.github.io/tags/OJ/"}]},{"title":"32、黑客&攻击","slug":"学习笔记/《计算机科学速成课》笔记/32、黑客&攻击","date":"2020-03-04T08:59:43.000Z","updated":"2020-04-01T02:29:03.700Z","comments":true,"path":"archives/622.html","link":"","permalink":"https://longlongqin.github.io/archives/622.html","excerpt":"黑客入侵最常见的方式不是通过技术，而是欺骗别人，这个称为社会工程学（Social Engineering），通过欺骗别人来让人泄露秘密，或让人配置电脑系统来变得易于攻击。最常见的攻击是网络钓鱼（Phishing），其次还有假托（Pretexting），攻击者给某个公司打电话，假装是IT部门的人，攻击者的第一通电话一般会叫人转接，这样另一个接的时候，电话看起来就像内部的，然后让别人把电脑配置得易于入侵，或者让他们泄露机密信息，比如密码或网络配置。","text":"黑客入侵最常见的方式不是通过技术，而是欺骗别人，这个称为社会工程学（Social Engineering），通过欺骗别人来让人泄露秘密，或让人配置电脑系统来变得易于攻击。最常见的攻击是网络钓鱼（Phishing），其次还有假托（Pretexting），攻击者给某个公司打电话，假装是IT部门的人，攻击者的第一通电话一般会叫人转接，这样另一个接的时候，电话看起来就像内部的，然后让别人把电脑配置得易于入侵，或者让他们泄露机密信息，比如密码或网络配置。邮件里带木马（trojan horse）也是常见手段，木马通常会伪装成无害的东西，比如照片或发票，但实际上是恶意软件，有的会偷数据，有的会加密文件。如果攻击者无法用木马或电话欺骗，攻击者只能被迫使用其他手段，方法之一就是暴力破解，尝试所有可能的密码，直到进入系统，大多数现代系统会加长等待时间来抵御这种攻击，每次失败就加长等待时间，甚至超过一定次数后，完全封锁。现在出现了一种攻破方法称为NAND镜像，如果能物理接触到电脑，可以往内存上接几根线，复制整个内存，然后暴力尝试密码，直到设备让你等待。这时只要把复制的内容覆盖掉内存，本质上重置了内存，就不用等待，可以继续尝试密码。如果无法物理接触到设备，就需要远程攻击，比如通过互联网，这一般需要攻击者利用系统漏洞，来获得某些能力或访问权限，称为漏洞利用（Exploit）。一种常见的漏洞利用叫缓冲区溢出（Buffer Overflow），这里的缓冲区是指预留的一块内存空间，比如我们在系统登录界面输入用户名和密码，而系统是用缓冲区来存储输入值的，假设缓冲区大小为10，并且缓冲区前后肯定还有其他数据，当用户输入用户名和密码时，这些值就会被复制到缓冲区中来进行验证，而该方法会溢出缓冲区，比如输入超过10个字符的密码，会覆盖掉相邻的数据，有时会让程序或系统崩溃，因为重要值被垃圾数据覆盖掉了。这里只是让系统崩溃，但是攻击者可以输入有意义的新值到程序的内存中，比如把is_admin标志位的值改为true，有了任意修改内存的能力，黑客就可以绕过登录这类东西，甚至使用那个程序劫持整个系统。有许多方法阻止缓冲区溢出，最简单的方法就是复制到内存之前先检查长度，称为边界检查（Bounds checking），许多现代编程语言都自带边界检查，程序也会随机存放变量在内存中的位置，这样黑客就不知道应该覆盖内存的哪部分，使得更容易让程序崩溃，而不是获得访问权限。程序也可以在缓冲区后，预留一些不用的空间，然后跟踪里面的值，看是否发生变化，来判断是否有攻击，这些不用的内存空间称为金丝雀（Canaries）。另一种经典手段是代码注入（Code Injection），最常用于攻击用数据库的网站。假设网页上有登录提示，当用户点击“登录”，输入文本就会发送服务器，服务器就会运行代码，检查用户名是否存在，如果存在就看密码是否匹配。为此服务器会执行一段sql查询代码，比如1SELECT password FROM users WHERE username='___';这里语句就是要从users表中查找username为___的密码password。 这里的___就是用户输入的用户名。由此攻击者就能把sql命令输入到用户名中，比如whatever&#39;;DROP TABLE users;&#39;，这时上面的查询语句就会变成1SELECT password FROM users WHERE username='whatever';DROP TABLE users;';如果服务器存在用户名wharever，数据库就会返回密码， 当然我们无法得知密码是什么，所以服务器会拒绝我们；如果不存在用户名wharever，服务器会返回空密码或者直接错误，服务器也会拒绝我们。 但是我们关心的是后面的代码DROP TABLE users;这个是我们注入的命令，这个命令是删掉users这张表。如今几乎所有服务器都会防御这种手段。程序员需要认识到从外界输入的信息都是危险的，必须要好好检查，很多用户名和密码表单，不会让你直接输入特殊符号，比如分号或括号，来作为第一道防御。好的服务器也会清理输入，比如修改或删除特殊字符，然后才放到数据库查询语句中。当软件制造者不知道的新漏洞被发现时，称为0day漏洞（Zero Day Vulnerability），黑客就会抢在白帽程序员做出补丁之前尽可能利用漏洞。如果有足够多的电脑有漏洞，让恶意程序可以自动地在电脑之间互相传播，称为蠕虫（Worm）。如果黑客拿下大量电脑，这些电脑可以组成僵尸网络（Botnet），可以用于很多目的，比如发大量垃圾邮件等，用别人电脑的计算能力来挖比特币，或发起DDOS来攻击服务器。DDOS就是僵尸网络里的所有电脑发一大堆垃圾信息到服务器上，造成服务器的阻塞。完~~~","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"《计算机科学速成课》","slug":"《计算机科学速成课》","permalink":"https://longlongqin.github.io/tags/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE%E3%80%8B/"}]},{"title":"Hexo 博客框架搭建","slug":"Hexo博客搭建/Hexo博客框架搭建","date":"2020-03-01T13:27:52.000Z","updated":"2020-03-17T08:12:17.477Z","comments":true,"path":"archives/7f7e.html","link":"","permalink":"https://longlongqin.github.io/archives/7f7e.html","excerpt":"搭建这个博客起因是2020年的二月末的某一天晚上，无聊逛B站，然后就看到了一个博客搭建教程，随机就有了这一系列的文章了。","text":"搭建这个博客起因是2020年的二月末的某一天晚上，无聊逛B站，然后就看到了一个博客搭建教程，随机就有了这一系列的文章了。前言我的是在windows操作系统上面，在其他的系统上面大同小异。也参考了很多文章及视频教程。主要参考的是：程序羊的视频：https://www.bilibili.com/video/av44544186?from=search&amp;seid=12981624311298276946文章：https://ouwen666.gitee.io/2020/01/29/Hexo+Gitee搭建个人博客作者部署的是giteehttps://godweiyang.com/2018/04/13/hexo-blog/#toc-heading-6含有个性化配置注：文中的指令都是在cmd（Windows中的命令提示符）中完成的。如果在这之前电脑上就已经安装了Git bash，那么也可以在Git bash中运行指令。下面会用得到的命令npm install=npm i。在git clone项目的时候，项目文件中并没有 node_modules文件夹，项目的依赖文件可能很大。直接执行，npm会根据package.json配置文件中的依赖配置下载安装。-global=-g，全局安装，安装后的包位于系统预设目录下--save=-S，安装的包将写入package.json里面的dependencies，dependencies：生产环境需要依赖的库开始配置安装Node.js博客框架Hexo是基于Node.js制作的静态博客，我们待会要用到Node.js里面的npm(node package manager)包管理器来安装插件。可以点击这里进入其官网。进入之后，按照操作系统进行下载安装。如上图是Windows系统64位的版本，上面官方推荐下载的版本。安装选项就按默认的，一直点击Next。然后，检验是否安装成功：用Win+R命令打开命令提示符，输入node -v 和npm -v ，出现版本号，则说明安装成功。添加cnpm注：因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，如果npm的服务器在中国就好了，所以我们乐于分享的淘宝团队干了这事。来自官网：“这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。”所以我们可以利用npm安装cnpm，再cmd中输入：1npm install cnpm -g –registry=https://registry.npm.taobao.org再输入：cnpm -v来检验是否安装成功。此时，假设我们Node.js安装成功。安装Hexo框架我们要利用Hexo框架模型来搭建我们的博客。点击这里可以进入其官网。下载该框架也仍然是在cmd（Windows中的“命令提示符”）中输入指令完成的。在上一步我们安装了cnpm，现在我们要用它来安装hexo，用cnpm安装的速度更快一些，也可以用npm：1cnpm install -g hexo-cli检验是否安装成功，当运行之后出现版本号则安装成功：1hexo -v现在，我们的Hexo框架已经安装成功了。初始化Hexo想要看到博客运行起来，我们现在还需要对Hexo框架进行初始化。在你的电脑上找一个合适的位置，创建一个文件夹，名字可以随便取，可以用Blog等等的名字，随个人喜好取名。为了便于演示，假设你取的名字叫做：blog注意，初始化是在我们创建的这个blog文件夹中初始化的，所以，我们的命令提示符（cmd）左边的路径要在这个blog文件夹中。进入刚刚创建的文件夹中然后，在输入指令 ：1hexo init初始化完成后，我们的blog文件夹中，就会生成这些文件：node_modules: 依赖包public：存放生成的页面scaffolds：生成文章的一些模板source：用来存放你的文章themes：主题_config.yml: 博客的配置文件在安装一些必要的包：1npm install初始化完成，在打开hexo服务器：123$ hexo sINFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.我们，打开浏览器，输入：localhost:4000，就可以看到你的博客的雏形已经好了。更换主题加入你觉得这个主题你不喜欢，想要找一个其他的主题，你可以进入Hexo的官网的主题板块，来选择你喜欢的主题：假如，你想更换为3-hexo，那就点击它，会跳转到该主题的创作者的GitHub上：安装3-hexo主题，其中命令的themes/3-hexo指的是该主题的安装位置：1git clone https://github.com/yelog/hexo-theme-3-hexo.git themes/3-hexo安装完之后，我们需要运行：123$ hexo clean # 清除所有记录 $ hexo generate # 生成静态网页 简写：hexo g$ hexo server # 启动服务 简写：hexo s然后，我们就能在本地localhost:4000中，查看修改好的主题了。安装Git如果你不想只在本地上查看你的博客，也想有自己的博客网址链接，那我们可以下载Git，把博客内容部署到GitHub或者gitee上面。我们这里以GitHub为例。Git的官网点击这里。然后按照你的电脑的操作系统下载相应的版本。安装选项还是全部默认，只不过最后一步添加路径时选择Use Git from the Windows Command Prompt，这样我们就可以直接在命令提示符里打开git了。安装完成后在命令提示符中输入git --version验证是否安装成功。GitHub账号如果你没有GitHub账号，我们现在去创建一个吧。点击这里创建。创建完成之后，我们新建一个github仓库：注意你的仓库名字不要随便起，待会我们要用到。加入你GitHub名字叫“AAA”，那么仓库个名字就一定是：AAA.github.io：部署博客将博客部署在github中目前，还不能部署到GitHub上。还需要下载hexo-deployer-git插件：1cnpm install hexo-deployer-git --save #通过cpnm安装git插件如果，你是刚刚才下载的Git，则还需要设置你的姓名和邮箱：12git config --global user.name \"Firstname Lastname\" // 名字使用英文输入git config --global user.email \"your_email@example.com\"还有你的SSH Key，创建公开密钥：1ssh-keygen -t rsa -C &quot;your_email@example.com&quot;​ 把生成的密钥添加到GitHub中去：找到生成的密钥：如果一切顺利的话，可以在用户主目录里找到.ssh目录，我的在：C:\\Users\\xxxx\\.ssh（xxxx是我的一个目录）。里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便，把公钥复制进去。到这里，我们的git与远程的GitHub已经建立起关系了。我们还需要把blog文件夹中的设置文件，即：_config.yml，将最后一行进行修改,：1234deploy: type: git repository: https://github.com/longlongqin/longlongqin.github.io.git branch: master​ repository修改为你自己的github项目地址，在实际操作过程中，repository: git@github.com:longlongqin/longlongqin.github.io.git,也是可以的。修改之后，我们才能部署到GitHub上：12$ hexo deployer## 初次使用这个命令，需要输入github的用户名username和密码password​ 这里，就是利用刚下载的插件：hexo-deployer-git现在我们可以访问我们在github服务器上的博客网址，网址就是我们刚刚创建仓库的名字，比如我的仓库名是：longlongqin.github.io，我们复制粘贴它到浏览器，然后你就可以看到你的博客内容了。😊Git提交到多个仓库https://yuxiang.ren/2017/08/25/hexo%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%88%B0%E5%A4%9A%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/部署在gitee部署在gitee上的坑在gitee上面，和在GitHub上面部署差不多，但是有些地方我们还是要注意的。仓库命名问题在创建gitee仓库时，最好也是将仓库名字命名为你的账号的用户名，比如我的：​ 当然，你也可以命名为其他名字，但是换成其他名字之后，可能会带来一系列其他的问题，比如图片无法显示。其实我之前命名成其他名字，就出现了很大的问题：这种情况是因为，他找不到资源，加载错误：熬了一个晚上，终于发现了。在官方文档中有：网站在子目录的情况如果你的网站在一个子目录（例如http://example.org/blog） 设置url为http://example.org/blog并且设置root为/blog/说来也奇怪，在GitHub上面，和本地运行的时候都是好好的。就是在gitee上面出错了。o(︶︿︶)o 唉解决它的办法就是：​ 将root添加上缺少的那一级目录，即可1234567891011121314151617# URL## If your site is put in a subdirectory, set url as'http://yoursite.com/child' and root as '/child/'url: http://yoursite.com/childroot: /blog/permalink: :year/:month/:day/:post_title/permalink_defaults:pretty_urls: trailing_index: false # Set to false to remove trailing 'index.html' from permalinks trailing_html: true # Set to false to remove trailing '.html' from permalinks这一篇帖子里面也有人遇到了同样的问题，最后也是通过root的修改解决的。：https://gitee.com/oschina/git-osc/issues/IFVWV?from=project-issuegitee pages刷新除了仓库名字需要注意，我们还需要注意，gitee个人版似乎不能自动刷新，所以你每次hexo d之后，需要手动的刷新gitee pages，才能显示你新提交的内容。写文章编辑器推荐推荐使用Typora这款软件，点击这里进入官网，他可以写Markdown格式的内容，这个软件的方便之处在于直接将markdown语法呈现出其效果，并且已经集成了很多方便的功能，你无需记住插入代码的语法格式，无需记住插入图片的语法格式，这使得我可以专心写博客而无法关心学习markdown语法。有很多md编辑器，他们分成两个界面，一个界面是md源代码，另外一个界面实时更新显示其效果，而Typora是浑然一体的，真正所见即所得，就跟在使用word一样方便。不仅如此，它还可以导出PDF、Word、HTML、图片等格式。待续……图片问题http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/Hexo的操作指令我们刚开始，对于Hexo的指令不太熟悉，我们可以在他的官网上去查找相应的操作指令。文章的front-matterFront-matter 选项详解Front-matter 选项中的所有内容均为非必填的。但我仍然建议至少填写 title 和 date的值。配置选项默认值描述titleMarkdown 的文档标题文章标题，强烈建议填写此选项date文档创建时的日期时间发布时间，强烈建议填写此选项，且最好保证全局唯一author根 _config.yml中的 author文章作者imgfeatureImages中的某个值文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: http://xxx.com/xxx.jpgtoptrue（文章是否置顶），如果 top 值为 true，则会作为首页password无文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项toctrue是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项mathjaxfalse是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文档中也需要开启才行summary无文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则进程会自动截取文章的部分内容作为摘要categories无文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类tags无文章标签，一篇文章可以多个标签Front-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量，举例来说：1234---title: Hello Worlddate: 2013/7/13 20:46:25---分类和标签只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。12345categories:- Diarytags:- PS3- Games分类方法的分歧如果您有过使用 WordPress 的经验，就很容易误解 Hexo 的分类方式。WordPress 支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是 Hexo 不支持指定多个同级分类。下面的指定方法：123categories: - Diary - Life会使分类Life成为Diary的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。1234categories:- [Diary, PlayStation]- [Diary, Games]- [Life]此时这篇文章同时包括三个分类： PlayStation 和 Games 分别都是父分类 Diary 的子分类，同时 Life 是一个没有子分类的分类。JSON Front-matter除了 YAML 外，你也可以使用 JSON 来编写 Front-matter，只要将 --- 代换成 ;;; 即可。123&quot;title&quot;: &quot;Hello World&quot;,&quot;date&quot;: &quot;2013&#x2F;7&#x2F;13 20:46:25&quot;;;;配置过程遇到的问题Hexo博客中文章图片不显示的坑这个是真的坑，搞了好久，终于看到一篇博文，才解决了这个问题。放一下这篇文章的传送门。在coding中SSL证书申请失败的坑在搭建到coding中步骤其实和在github中比较相似，就是给仓库命名原则的时候需要注意，尽量让仓库名字与你的用户名相同，即和在github中命名规则相似。如果你之前都很顺利，那么在SSL证书申请时，需要注意了：你会遇到证书申请一直失败的情况。这是为什么呢？是这样的：第一次尝试，查资料说是如果之前你已经在github oages上部署了，你自己买的域名也已经解析过了。此时直接在coding pages中申请ssl的话，会失败。解决的办法就是：先把用于解析github pages的那两条暂停了，如下图所示：然后，我再试试，还是申请失败。出现类似于下面的错误：继续去查。嗯，找到了，申请失败是因为我的域名在国外无法解析，这是我的DNS设置导致的。解决办法：在解析的时候，需要将线路类型改成默认。去试一试，等待一小会哇，终于申请成功了。#Hexo博客备份有时候我们外出，自己的电脑没有带，这时候想写博客怎么办。这也是有办法的，就是我们要先备份我们的博客。这里我们可以备份到github或者gitee.拿github举例：首先，我们先要在GitHub上面建立一个仓库，仓库名字自取，仓库是public还是private，按照自己的心情来就好了。然后，我们要在本地关联远程仓库：我们进入你的本地博客所在的目录，比如我的在D:\\Blog，然后，打开你的Git bash，按顺序输入以下命令：12git init #初始化本地仓库git remote add origin &lt;你的远程仓库的SSH或HTTPS链接&gt; #关联远程仓库（ssh的链接比较快一点）关联完成，然后我们还需要，将本地的推送到远端，同样，按顺序输入一下命令：123git add . #这个‘.’表示将整个文件夹都一起添加到暂存区（不然还要一个个输入文件名）git commit -m \"输入你这次提交的说明\" git push origin master #推送到远程仓库好了，记得按时将本地的备份到远程仓库。至此，本地备份已经完成。如果你想同时备份到gitee和github上面，你可以参考这里。在另外一台电脑上写博客前提是我们把博客备份在github、gitee等上面。然后在新电脑上面：安装 Git、nodejs把你远程的博客备份，clone下来到一个指定的位置（位置自己定）在本地的博客仓库运行：npm install，来 安装依赖包好了，你可开始写博客了。优化技巧优化文章URLseo搜索引擎优化认为，网站的最佳结构是用户从首页点击三次就可以到达任何一个页面，但是我们使用hexo编译的站点打开文章的url是：sitename/year/mounth/day/title四层的结构，这样的url结构很不利于seo，爬虫就会经常爬不到我们的文章，于是，我们需要优化一下网站文章url方案一：我们可以将url直接改成sitename/title的形式，并且title最好是用英文，在根目录的配置文件下修改permalink如下：1234url: https://sunhwee.comroot: /permalink: :title.htmlpermalink_defaults:方案二：使用插件优化url插件hexo-abbrlink实现了这个功能，它将原来的URL地址重新进行了进制转换和再编码。安装hexo-abbrlink。1npm install hexo-abbrlink --save配置博客根目录下的_config.yml文件。12345# permalink: :title/permalink: archives/:abbrlink.htmlabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex运行hexo clean和hexo g命令来重新生成文件看看，可以清楚的看到，URL结构成功变为了3层。来源: 洪卫の博客作者: 洪卫文章链接: https://sunhwee.com/posts/6e8839eb.html#toc-heading-59本文章著作权归作者所有，任何形式的转载都请注明出处。其他参考文章列表：http://dongshuyan.com/2019/05/24/hexo%E5%8D%9A%E5%AE%A2%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/#14-Hexo添加百度统计网络编程系列 Hexo + Github搭建个人博客 · 花田半亩","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://longlongqin.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Hexo主题","slug":"Hexo主题","permalink":"https://longlongqin.github.io/tags/Hexo%E4%B8%BB%E9%A2%98/"}]}]}