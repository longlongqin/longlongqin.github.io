{"meta":{"title":"龙龙‘S BLOG","subtitle":"","description":"","author":"longlongqin","url":"https://www.longlongqin.top","root":"/"},"pages":[{"title":"关于","date":"2020-03-17T07:38:49.496Z","updated":"2020-03-17T07:38:49.496Z","comments":true,"path":"about/index.html","permalink":"https://www.longlongqin.top/about/index.html","excerpt":"","text":"路漫漫其修远兮，吾将上下而求索一个本科生化环材的跨考生，现专业软件工程。本博客主要记录自己的学习之路。现阶段学习内容：编译原理Let’s Build A Simple Interpreter计算几何邓俊辉老师的学堂在线课程C/C++基础学习：https://www.learncpp.com/"},{"title":"所有分类","date":"2020-03-16T13:58:21.496Z","updated":"2020-03-15T14:08:19.000Z","comments":true,"path":"categories/index.html","permalink":"https://www.longlongqin.top/categories/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-03-21T17:19:06.339Z","updated":"2020-03-15T14:08:19.000Z","comments":true,"path":"comment/index.html","permalink":"https://www.longlongqin.top/comment/index.html","excerpt":"","text":"欢迎前来灌水。。。"},{"title":"404 Not Found","date":"2020-03-16T18:44:23.649Z","updated":"2020-03-16T18:44:23.649Z","comments":true,"path":"404.html","permalink":"https://www.longlongqin.top/404.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-03-16T13:21:42.616Z","updated":"2020-03-15T14:08:19.000Z","comments":true,"path":"tags/index.html","permalink":"https://www.longlongqin.top/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-03-21T17:20:09.632Z","updated":"2020-03-21T17:20:09.632Z","comments":true,"path":"个人书签/index.html","permalink":"https://www.longlongqin.top/%E4%B8%AA%E4%BA%BA%E4%B9%A6%E7%AD%BE/index.html","excerpt":"","text":""},{"title":"Friends","date":"2020-03-22T18:20:52.228Z","updated":"2020-03-22T18:20:52.228Z","comments":true,"path":"friends/index.html","permalink":"https://www.longlongqin.top/friends/index.html","excerpt":"","text":"欢迎和我交换友链各位大佬想交换友链的话可以在下方留言，必须要提供名称、头像和链接哦~请先将本站添加到你滴友链中喔，谢谢~友链提交模板：123456- name: 龙龙‘S Blog avatar: https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg url: https://www.longlongqin.top backgroundColor: '#FFA500' textColor: '#624739' tag: #你的简介背景、字体颜色可以按自己风格设置呀！"},{"title":"Projects","date":"2020-03-21T17:16:38.679Z","updated":"2020-03-15T14:08:19.000Z","comments":true,"path":"projects/index.html","permalink":"https://www.longlongqin.top/projects/index.html","excerpt":"","text":""},{"title":"","date":"2020-03-23T03:57:20.827Z","updated":"2020-03-23T03:57:20.827Z","comments":true,"path":"学习笔记/index.html","permalink":"https://www.longlongqin.top/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html","excerpt":"","text":"学习笔记编译原理Let’s Build A Simple Interpreterpart1、part2、part3、part4、part5、part6、part7、part8、part9计算几何学堂在线课程-邓俊辉老师凸包：Convex-Hull-凸包、增量构造、Jarvis-March、Lower-Bound、Graham Scan、Divide-And-Conquererer计算机科学速成课2 电子计算机、3 布尔逻辑和逻辑门、32 黑客&amp;攻击"},{"title":"","date":"2020-03-23T05:40:18.036Z","updated":"2020-03-23T05:40:18.036Z","comments":true,"path":"easysearch/about/index.html","permalink":"https://www.longlongqin.top/easysearch/about/index.html","excerpt":"","text":"关于本页丨龙龙'S BLOG 关于本页在自己电脑上建立了很多书签，但是不方便使用。就想建立一个在线的网址导航，这样无论在哪都可以方便快捷的使用导航了。powered by webstack.cc关于我longlongqin一个跨考软工的初学者努力学习C++ 2020 - 2020 | 丨 DESIGNED BY Viggo 丨 MODIFIED BY longlongqin!function(e){var c=Array.prototype.slice.call(document.querySelectorAll(\"img[data-original]\"));function i(){for(var r=0;r"},{"title":"","date":"2020-03-23T08:02:02.766Z","updated":"2020-03-23T08:02:02.766Z","comments":true,"path":"easysearch/index.html","permalink":"https://www.longlongqin.top/easysearch/index.html","excerpt":"","text":"easysearch丨龙龙'S BLOG 开发社区 代码托管 语言文档 技能训练在线平台高校平台游戏编程 HOT Pythoner文档资料博客收藏学习资源组织社区爬虫相关 HOT 学习教程在线视频博客论坛学习平台 常用工具站长工具 HOTIT工具箱文件处理 HOT设计素材效率软件 HOT 服务平台 云服务商 众包平台 更多导航 FORME计算几何C++关注的博客 HOT常用网址公众号&写作 关于本页 隐藏/显示侧边栏 博客首页 友情链接 评论留言 关于博主!function(e,t,n,a,o,i,c,r){r=function(){i=t.createElement(n),c=t.getElementsByTagName(n)[0],i.src=o,i.charset=\"utf-8\",i.async=1,c.parentNode.insertBefore(i,c)},e.SeniverseWeatherWidgetObject=a,e[a]||(e[a]=function(){(e[a].q=e[a].q||[]).push(arguments)}),e[a].l=+new Date,e.attachEvent?e.attachEvent(\"onload\",r):e.addEventListener(\"load\",r,!1)}(window,document,\"script\",\"SeniverseWeatherWidget\",\"//cdn.sencdn.com/widget2/static/js/bundle.js?t=\"+parseInt(((new Date).getTime()/1e8).toString(),10)),window.SeniverseWeatherWidget(\"show\",{flavor:\"slim\",location:\"WX4FBXXFKE4F\",geolocation:!0,language:\"auto\",unit:\"c\",theme:\"auto\",token:\"a39cd5a0-4024-4cb2-85c6-0250317058db\",hover:\"enabled\",container:\"tp-weather-widget\"})开发社区Stack Overflow全球最受程序员欢迎的开发社区V2EXV2EX = way to explore SegmentFault改变并提升人们获取知识的方式和效率，帮助更多的开发者获得成长与成功 开源中国国内最大的开源技术社区 ITeyeITeye软件开发交流社区 - Java编程 Spring框架 Ajax技术 agile敏捷软件开发 ruby on rails实践 51CTO技术成就梦想 ITPUB全球最大的学习分享平台 知乎国内最受欢迎的知识性问答社区 简书创作你的创作 云+社区来自腾讯的开发者技术分享社区云栖社区阿里云面向开发者的开放型技术平台 掘金一个帮助开发者成长的社区CSDN全球最大中文IT社区，为IT专业技术人员提供最全面的信息传播和服务平台博客园代码改变世界代码托管Github全球最大的面向开源及私有软件项目的托管平台Gitlab支持无限的公有项目和私有项目的代码托管平台Bitbucket同时支持 Git 和 Mercurial 这两个版本控制软件，免费的私有仓库，支持5人以内的合作开发SourceForge又称 SF.net，是开源软件开发者进行开发管理的集中式场所Coding国内首个一站式云端软件服务平台Gitee国内最大的开源社区 OSChina 的代码托管平台阿里云代码托管阿里云旗下代码托管平台百度效率云百度云旗下的 Git 代码托管平台语言文档Zeal脱机文档浏览器，包含196种语言API文档，支持Windows、Linux和macOSDash适用于Mac OS平台的软件编程文档管理工具,可以浏览API文档,以及管理代码片段工具。自带了丰富的API文档,涉及各种主流的编程语言和框架DevDocs在快速，有条理和可搜索的界面中结合了多个API文档，可以在移动设备上离线运行，并且可以安装在Chrome上C/C++C/C++ API 文档C#C# API 文档JavaJava API 文档.NET.NET API 文档PHPPHP API 文档JavaScriptJavaScript API 文档PythonPython API 文档AndroidAndroid API 文档iOSiOS API 文档SQLSQL API 文档SwiftSwift API 文档RubyRuby API 文档GOGO API 文档RR API 文档MATLABMATLAB API 文档Node.jsNode.js API 文档HTMLHTML API 文档CSSCSS API 文档RedisRedis API 文档MongoDBMongoDB API 文档DjangoDjango API 文档在线平台 LeetCode全球极客挚爱的技术成长平台Topcoder全世界规模最大的程序竞赛网站，也会有一些算法竞赛，适合一些高端的或者搞ACM的，也会举办一些比赛Codeforces俄罗斯最大的算法比赛网站Hihocoder技术团队来自原北京大学POJ (PKU Online Judge)开发团队，收集了全球范围内很多地区、高校举办的比赛试题， 提供365天*24小时的在线提交、评判程序的服务LintCode被称作中文版的leetcode，也是可以做为编程能力提升的一个中转站SPOJ波兰的算法刷题网站NEUQ OJ一个在线的判题平台洛谷创办于2013年，致力于为参加noip、noi、acm的选手提供清爽、快捷的编程体验牛客网中国最大的IT题库C语言网在这里可以参加包括ACM、NOI在内的各种C/C++/java程序比赛，也可以DIY举办各类程序比赛活动！计蒜客计蒜客OI题库致力于为参加noi、noip、信息学竞赛的选手提供优秀的Online Judge系统高校平台POJ北京大学程序在线评测系统FDU OJ复旦大学程序在线评测系统TJ OJ同济大学程序在线评测系统USTC OJ中国科学技术大学程序在线评测系统ZOJ浙江大学程序在线评测系统HDU OJ杭州电子科技大学程序在线评测系统CSU-ACM中南大学程序在线评测系统HOJX哈尔滨工业大学程序在线评测系统HRBUST OJ哈尔滨理工大学程序在线评测系统PowerOJ西南科技大学程序在线评测系统SCU OJ四川大学程序在线评测系统FZU CoidngOJ福州大学程序在线评测系统NBUT OJ宁波工程学院程序在线评测系统Lutece电子科技大学程序在线评测系统武汉大学 ACM 协会武汉大学 ACM 协会ZJUT OJ浙江工业大学程序在线评测系统游戏编程CheckiO面向初学者和高级程序员的编码游戏，使用Python和JavaScript解决棘手的挑战和有趣的任务，从而提高您的编码技能Coding Games支持包括PHP、C、JavaScript在内的20多种编程语言。用户界面功能强大，可以定制Codewars一个外国的在线练习编程的网站,做题的过程类似打怪,做题升级,而且可以看到别人的解法,里面有很多巧妙的写法可以学习CodeCombat一个面向学生的游戏和CS学习平台。这是一个社区项目，有数百玩家自愿提供支持。支持语言包括Java、JS、Python、Lua、CoffeeScriptScreeps在游戏中学习JavaScript。世界上第一款针对程序员的MMO沙盒游戏VIM Adventures玩游戏的时候学VIMCyber-Dojo一个提供给程序员们练习写程序的地方。支持语言包括JavaScript、Java、Python、PHP、Ruby和很多其他语言Elevator Saga电梯编程游戏，跟随关卡解决所有挑站，使用语言为JavaScriptRuby Quiz一个Ruby程序员提供的每周编程挑战项目hacker.org这项挑战由一系列本设计来强化你黑客技巧的解密、诡计、测试、烧脑环节组成。想要通关本系列，你必须学会解密、编码、渗透Ruby Warrior玩游戏学Ruby，通过Ruby脚本来控制一个Warrior通过每一关，每一关的代码难度都会有所增加，使玩家逐渐了解Ruby基本的函数、控制、变量、数组等语言特性的用法文档资料Python 官方文档Python 官方文档Python 标准库Python 标准库Python RequestsPython Requests 文档Python UrllibPython Urllib 文档Python SeleniumPython Selenium 中文翻译文档正则表达式Python 正则表达式官方文档Beautiful SoupBeautiful Soup 文档ScrapyScrapy 爬虫框架官方文档PySpiderPySpider 爬虫框架官方文档MatplotlibMatplotlib 2D绘图库 官方中文文档NumpyNumpy 科学计算 官方中文文档PandasPandas 结构化数据分析 官方中文文档博客收藏廖雪峰廖雪峰的官方网站 - 研究互联网产品和技术，提供原创中文精品教程崔庆才崔庆才的个人博客,专注PHP,Python,爬虫,深度学习,机器学习,数据分析莫烦Python专注Python、机器学习、深度学习唐松专注Python网络爬虫, 数据科学, 数据挖掘, 数据分析捕蛇者说编程、程序员、PythonFxxkPython学习python的正确姿势wistbeanPython 大佬PigleiPython 大佬TendCodePython 大佬追梦人物的博客Python Django 大佬the5fire《Django企业开发实战》作者，关注Python、Django、Vim、Linux、Web开发小明明S À DOMICILE《Python Web开发实战》作者，Python 大佬Python之禅Python 大佬Python 知识圈Python知识圈 - 实用的Python教程网站Python 教程网小詹学Python，专注Python学习烂笔头 j_hao104Python大佬咸鱼日常专注Python爬虫，有许多JS逆向文章AnShengPython 全栈大佬夏溪辰云栖社区特邀爬虫工程师，Python大佬高级农民工Python大佬云爬虫技术研究笔记Lateautumn4lin 爬虫开发工程师，多年反爬虫破解经验，沉迷数据分析和黑客增长，CSDN博客专家，华为云享专家云爬虫技术研究笔记(CSDN)Lateautumn4lin 爬虫开发工程师，多年反爬虫破解经验，沉迷数据分析和黑客增长，CSDN博客专家，华为云享专家Jack CuiCSDN博客专家，Python 大佬学习资源Python爬虫人工智能学习教程Python爬虫人工智能学习教程分享Python 中文学习大本营Python 中文学习大本营Python 资源大全中文版Python 资源大全中文版爱湃森各种 Python 教程组织社区PyChinaPython 中国社区PyCon China中国 Python 开发者大会蠎周刊蠎周刊 - 汇集全球蠎事儿爬虫相关镀金的天空GlidedSky 镀金的天空，在线爬虫练习题库夜幕爬虫安全论坛一个专注于爬虫与 PC/Web/ 移动端安全领域技术交流的社区，社区由夜幕团队 NightTeam 创办，旨在提升开发者对爬虫与软件安全防护的理解西刺免费代理IP每日更新免费HTTP代理，所有代理均为6675端口高匿代理，可隐藏IP爬虫IP代理池爬虫IP代理池云打码采用全球领先的秒传识别系统，50%图片零秒识别，人工平均处理时间0-3秒超级鹰专业的验证码云端识别服务,让验证码识别更快速、更准确、更强大八爪鱼采集器一款使用简单、功能强大的网络爬虫工具，完全可视化操作，无需编写代码，内置海量模板，支持任意网络数据抓取Python 逆向Python 逆向相关资源Python 爬虫集合Python 爬虫集合Python 入门网络爬虫之精华版Python 入门网络爬虫之精华版爬虫项目进阶实战Python3 爬虫项目进阶实战、JS加解密、逆向教程、css 加密、字体加密Python 模拟登陆一些大型网站Python 模拟登陆一些大型网站系统化学习 Python 爬虫系统化学习 Python 爬虫Python3 网络爬虫实战Python3 网络爬虫实战在线视频腾讯课堂腾讯推出的专业在线教育平台，聚合大量优质教育机构和名师网易云课堂网易旗下一个专注职业技能提升的在线学习平台。立足于实用性的要求，与多家教育培训机构和行业的专家、讲师建立合作中国大学 MOOC中国大学MOOC(慕课)，国家精品课程在线学习平台黑马程序员致力于培养中级程序员，是业内以口碑闻名的IT教育培训机构课工场更可靠的IT就业教育平台，针对大学生量身定制人工智能、大数据、云计算、区块链、Java大数据开发等大学生IT培训课程极客学院极客学院作为中国专业IT职业在线教育平台,拥有海量高清IT职业课程,涵盖30+个技术领域慕课网慕课网（IMOOC）是IT技能学习平台。慕课网(IMOOC)提供了丰富的移动端开发、php开发、web前端、android开发以及html5等视频教程资源公开课尚硅谷尚硅谷Java培训，谷粉与老学员为你推荐的Java培训、Web前端培训、前端培训、大数据培训、Python培训；0基础入学，学员就业起薪屡创新高！实验楼国内领先的IT在线编程及在线实训学习平台，专业导师提供精选的实践项目，创新的技术使得学习者无需配置繁琐的本地环境，随时在线流畅使用优达学城Udacity是来自硅谷的前沿技术平台，为广大学子提供WEB前端开发、Python/JAVA编程、IOS/Android开发、人工智能开发等一系列在线课程及实战项目，满足学员灵活的学习需求51CTO学院51CTO学院IT职业在线教育平台是依托12年行业品牌、1400万IT技术用户建立的专业IT技能学习培训平台，已签约1000多位技术专家发布了12万个自学式实战视频教程CSDN 学院CSDN 学院作为IT在线教育平台,涵盖人工智能、考试认证、移动开发、大数据技术领域职业课程老男孩IT教育隶属北京一天天教育科技有限公司,是一直专注于Linux培训、Linux系统及架构师培训、Python培训、网络安全培训，大数据实战的高端培训机构千锋教育千锋教育 - 坚持教育初心，坚持面授品质，IT培训良心品牌博客论坛鱼C工作室鱼C工作室-免费编程视频教学|Python教学|Web开发教学|全栈开发教学|C语言教学|汇编教学|Win32开发|加密与解密|Linux教学吾爱破解致力于软件安全与病毒分析的前沿，丰富的技术版块交相辉映，由无数热衷于软件加密解密及反病毒爱好者共同维护廖雪峰廖雪峰的官方网站 - 研究互联网产品和技术，提供原创中文精品教程崔庆才崔庆才的个人博客,专注PHP,Python,爬虫,深度学习,机器学习,数据分析莫烦Python专注Python、机器学习、深度学习唐松专注Python网络爬虫, 数据科学, 数据挖掘, 数据分析阮一峰上海财经大学世界经济博士研究生，计算机科普博主，对自由软件有着坚定不移的信念学习平台菜鸟教程提供了编程的基础技术教程, 介绍了HTML、CSS、Javascript、Python，Java，Ruby，C，PHP , MySQL等各种编程语言的基础知识 W3school领先的 Web 技术教程C语言网C语言网 - 领先实用的编程在线学习网站前端网前端网，最好的自学web前端网站 牛客网牛客网 - 互联网求职神器和备考学习平台How2JHow2J的Java教程, 内容涵盖J2SE、WEB前端、J2EE、框架技术等全面的Java内容站长工具新浪短网址多种后缀短网址生成百度短网址百度旗下专业的网址缩短服务站长工具 - 站长之家站长工具,SEO工具,权重查询,收录查询,PR查询,ICP备案查询,whois查询,友情链接查询,反向链接查询,网站测试,IP查询,Alexa查询阿里云 whois 查询whois查询,域名whois,域名注册信息,whois查询工具,whois信息,域名信息NnameBeta国际域名搜索、域名注册、国别域名注册、域名比价Domcomp域名比价，Domain Name Price and Availability.仿站工具箱在线仿站工具箱超级 SEO 外链工具网站自动化宣传机器/免费的超级外链工具可批量增加外链百度站长平台百度搜索资源平台 - 让网站更具价值搜狗站长平台搜狗站长平台 - 全面掌握在搜狗搜索中的数据表现360 站长平台360 站长平台 - 给网站带来更多流量和展现Google 站长平台Google 网站站长 - 支持、学习、互动交流和 Search Console – GoogleBing 网站管理员工具Bing 网站管理员工具百度广告联盟百度广告联盟为您的流量增值Google AdSenseGoogle 广告平台百度统计百度统计 — 最大的中文网站分析平台友盟+国内领先的第三方全域数据智能服务商ICP/IP地址/域名信息备案管理系统工业和信息化部ICP/IP地址/域名信息备案管理系统全国互联网安全管理服务平台公安备案网 - 全国互联网安全管理服务平台IT工具箱在线工具 - 程序员的工具箱站长工具、代码格式化、压缩、加密、解密、下载链接转换等在线工具 - OSCHINA.NET社区常用文档、常用对照表、代码处理、Html/Js/Css工具、加密/转码工具等记磊工具箱Dns检测、CSS格式化、超级Ping、端口扫描等孟坤工具箱css一键美化、文本差异比较、代码高亮等Syntax HighlightSyntax Highlight Code In Word Documents，在Word文档中插入漂亮的代码Text to ASCII Art GeneratorText to ASCII Art Generator，字符串转成 ASCII 码图案MDEditor开源在线 Markdown 编辑器临时邮箱匿名注册不常用的网站/论坛，保护隐私免骚扰SM.MSSM 免费图床，每个文件最大支持 5MB路过图床免费公共图床，支持最大10MB、批量上传Greasy Fork安全、实用的用户脚本大全Hello World 大全收集了大约481种 Hello World 程序，涵盖了目前已知的所有编程语言，另加上 67 人类语言动画展示各种路径搜索算法动画展示各种路径搜索算法IT eBooks可以下载IT电子书籍的网站（英文）GEEKTyper在线模拟黑客工作的虚拟桌面系统，提供多种黑客工作的场景免费计算机编程类中文书籍免费计算机编程类中文书籍EaseUS Partition Master磁盘分区管理软件，不用重装系统，就可以重新划分磁盘空间文件处理Convertio在线文件转换工具，支持超过309种不同的文档、图像、电子表格、电子书、文档、演示文稿、音频和视频格式Office-Converter免费在线转换视频，在线音频转换，在线图形转换，在线文档转换和在线压缩格式TinyPNGPNG/JPG图片在线压缩利器SquooshGoogle开源在线压缩、调整工具，支持WebPILoveIMG永远免费的在线图片处理工具，可在线编辑，压缩、裁剪、转换、水印等SmallpdfSmallpdf - A Free Solution to all your PDF Problems,PDF压缩、转换、分割、合并等PHOTOMOSH故障艺术在线生成，可以输出jpg、gif和视频稿定抠图免费在线抠图软件,图片快速换背景-抠白底图U钙网完全免费的LOGO在线设计制作工具SVGOMGSVG在线压缩平台在线图片透明圆角处理在线图片透明圆角处理草料二维码国内创建二维码在线应用Logaster在线免费创建简单logo及名片设计PreloadersLoading 懒加载动画在线制作Loading制作GIF、SVG、CSS加载动画图标waifu2x图片智能无损放大2倍，适合动漫、插画等智图腾讯ISUX前端团队开发的一个专门用于图片压缩和图片格式转换的平台音乐免费下载全网音乐免费下载工具OK资源采集OK资源采集-最新影视资源大全网易见外工作台针对视频、图片、文档、音频都可以进行翻译转写操作，每天两小时免费使用HiPDF一站式解决所有PDF相关的问题视频鱼在线下载各大网站视频的网站ScreenToGif开源、轻量级却非常强大的录屏软件，快速将屏幕录制成高清GIF设计素材Iconfont阿里巴巴矢量图标库，提供矢量图标下载、在线存储、格式转换等功能Font Awesome一个基于CSS 和 LESS 的字体和图标工具包Flaticon海量扁平化免费的图标库icons8独特系统平台风格和web图标库，下载免费图标，音乐千图网海量原创设计模板免费下载昵图网国内海量平面免费素材下载千库网免费 png 图片背景素材下载Pexels才华横溢的摄影作者在这里免费分享最精彩的素材照片和视频必应壁纸必应每日高清壁纸Piqsels精美的免版税图库私藏字体优质字体免费下载站第一 PPT 网免费 PPT 模板下载吾道幻灯片全新的office生产力工具，支持演示文稿、PPT模板、协同办公，可以帮助用户轻松创建具有视觉吸引力的幻灯片Mixkit免费、高质量、可商用的视频素材分享网站The Stocks对各大图片网站进行整合，免费优质图片下载极简壁纸高质量精品壁纸网站NASA Image and Video Library美国国家航天局的官方库，从此太空类的素材再也不是问题Unsplash质量超高的免费图片素材库，无需注册，直接下载WordArt文字云工具效率软件分流抢票全程自动抢票,自动抢候补,自动识别验证码,多线程秒单、稳定捡漏,支持多天、多车次、多席别、多乘客等功能PanDownload百度网盘下载神器Quicker为常用操作建立捷径，PC 快捷动作面板，让效率触手可及!万彩办公大师免费、轻松处理文档/音视频/图片的工具LICEcap简洁易用的动画屏幕录制软件，它可将屏幕录像的内容直接保存为高质量（每帧颜色数量可超过256）GIF动态图片格式Snipaste简单但强大的截图工具，支持截图 + 贴图FSCapture一个强大的，轻量级的，功能齐全的屏幕捕获工具Everything速度最快的的文件搜索工具DeskPins顶置任意窗口TrafficMonitor一个用于显示当前网速、CPU及内存利用率的桌面悬浮窗软件PicGo由 electronic-vue 构建的简单而精美的图片上传工具PowerToys微软为 Windows 系统推出的一系列免费实用小工具合集Dism++一款根据微软底层的架构结构设计的一个系统维护工具，全球第一款基于 CBS 的 Dism GUI 实现ColorPix屏幕取色小工具CCleaner一款免费的系统优化和隐私保护工具GifCam集录制与剪辑为一体的屏幕 GIF 动画制作工具，录制后的动画可以逐帧编辑EV录屏一款免费并且不添加水印的录屏工具Fliqlo一款极简主义的时钟屏保软件Fences栅栏管理桌面，使桌面更加整洁有条理Q-dir多窗口文件整理工具WGestures鼠标手势工具XMind一个全功能的思维导图和头脑风暴软件速盘免登录，自动查询提取码，极速的度盘下载工具f.lux国外开源的护眼软件，通过根据时间调节屏幕颜色，减少蓝光对视力的影响云服务商 阿里云阿里云 - 为了无法计算的价值腾讯云腾讯云 - 产业智变 云启未来百度云百度云 - 计算无限可能华为云华为云 - +智能，见未来京东云京东云 - 遇见无限可能西部数码西部数码 - 云服务器、虚拟主机、域名注册17年知名云计算服务提供商！景安云景安云 - 专业的数据中心服务商七牛云七牛云 - 国内领先的企业级云服务商又拍云又拍云 - 加速在线业务-CDN-云存储美橙互联美橙互联 - 域名注册、企业建站、云服务器、企业网络推广整体解决方案服务商！UCloudUCloud - 中立 安全 可信赖的云计算服务商AWSAWS 云服务 - 专业的大数据和云计算服务以及云解决方案提供商Microsoft AzureAzure. Invent with purpose.GoDaddyGoDaddy - 提供域名注册和互联网主机服务的美国公司CloudflareCloudflare - 网络性能和安全公司jsDelivrjsDelivr - A free, fast, and reliable Open Source CDN for npm and GitHub众包平台 猿急送专注于 IT 众包领域，职位内容大多集中于 UI 设计、产品设计、程序开发、产品运营等需求开源众包开源中国旗下外包网站，项目大多是团队的整包项目，适合多人组团接单外包大师PMCAFF旗下的一个众包开发平台，目前以技术开发为主，以众包开发和自有开发相结合形式运营人人开发集可视化开发，应用市场，威客众包，PaaS云于一体的企业级应用服务平台快码提供智能硬件、各种智能共享项目解决方案，为互联网创业者提供APP、小程序、公众号开发。我爱方案网专注于硬件类外包，电子方案开发供应链众包平台，软件外包，方案，硬件开发方案，硬件设计开发英选提供可信赖的定制开发外包服务，包括企业品牌官网、电商系统及创新定制产品开发智筹为企业&创业者提供互联网高级人才直租服务。按次直租，解决临时、突发问题；按月直租，建立长期兼职合作；按任务直租，解决有明确预算的外包任务开发邦互联网软件定制开发与软件外包开发服务，十年互联网软件定制开发经验码市Coding 推出的互联网软件外包服务平台，意在连接需求方与广大开发者。让项目的需求方快速的找到合适的开发者，完成项目开发工作自由职客自由职客是权威的IT互联网行业灵活用工交易平台，外包，众包，兼职，招聘，erp，sap解放号解放号众包平台提供软件开发外包、人力驻场服务等软件项目外包服务。解放号的软件项目交付全流程可视化监控与全生命周期管理能力程序员客栈领先的程序员自由工作平台，38万+优秀开发者，您的专属云端开发团队，BAT级别的开发者，标准化的服务和交付码易智网易联旗下IT软件服务平台，集软件商城、企业应用、电商软件、crm软件、商务服务平台于一体的一站式软件外包开发服务平台电鸭社区电鸭社区旨在推动自由工作方式在国内渐进式发展，区别于传统方式的工作职位，倡导「只工作，不上班」的工作心态Sxsoft中国最早的外包服务平台，18年口碑服务，20万程序员、100+专业软件开发公司，专注解决各类软件开发需求实现网为企业提供BAT等名企背景的、靠谱的开发设计兼职人才和自由职业者，满足企业项目外包、驻场开发、远程兼职、技术咨询等短期人力需求智城外包网零佣金开发资源平台，认证担保，全程无忧，专业的软件外包网和项目外包、项目开发、人力外派、短期招聘、人力资源交易平台更多导航 创造狮导航创造狮，一个创意工作者的导航，专注分享正版优质设计、前端、产品、运营的书签导航，设计教程、设计规范、颜色搭配、灵感创意、前端框架、开发者工具、互联网新品推荐、运营数据分析、自媒体和工具利器好用的分类导航大全大数据导航大数据导航，以大数据产业为主，大数据工具为辅，给用户提供一个更加快速找到大数据相关的工具平台优设导航优设网站导航为设计师提供ps教程、UI设计、素材下载、高清图库、配色方案、用户体验、网页设计等全方位设计师网站导航指引牛导航实用工具导航聚BT聚BT - 聚合最优质的BT、磁力资源ShareHubShareHub - 资源和工具的集合狼牌工作网址导航工具，资源，方法，All IN ONE的办公工作网址导航计算几何xuetangx邓俊辉老师的《计算几何》Tsinghua Online Judge邓俊辉老师的《计算几何》上机练习C++LearnCppC++基础教学Project Based Learninggithub中C++项目式学习CTOLIBC/C++开发项目(中文)STLSTL入门教程(中文)cppreferenceC/C++ API 文档写作坚果云好用的文件自动同步，再也不担心typora出bugfont awesomeicon图标TEA写作软件极简又极其强大的笔记应用关注的博客知名博客随机推荐推荐一些比较知名的程序开发大神和团队博客、他们的github和他们网站等，跟随大神的脚步，学习最新的程序开发知识，时刻让自己走在前面！欢迎邮箱推荐或者自荐酷壳-陈皓一个IT技术技术性BLOG。是一个分享技术见闻，知识，趋势的网站。阮一峰大佬分享IT技术、以及其他感悟廖雪峰廖雪峰的官方网站 -git教程 & 研究互联网产品和技术，提供原创中文精品教程演算法笔记诸如图论、数论、计算几何、数值方法、资料处理、诸如自然语言处理、声音处理、影像处理、计算机图学 …… 常用网址我的云书签将本地的浏览器的收藏夹转化为云书签Stack Overflow全球最受程序员欢迎的开发社区 公众号&写作微信公众平台公众号管理135编辑器功能强大的微信公众号文章排版编辑器坚果云好用的文件自动同步，再也不担心typora出bugfont awesomeicon图标TEA写作软件极简又极其强大的笔记应用COPYRIGHT 2020 - 2020 WEBSTACK 丨 DESIGNED BY VIGGO 丨 CHANGED BY longlongqin​ ​$(document).ready(function(){return $(document).on(\"click\",\".has-sub\",function(){var e=$(this);$(this).hasClass(\"expanded\")?$(\".has-sub ul\").each(function(s,i){var t=$(this);e.find(\"ul\")[0]!=i&&setTimeout(function(){t.attr(\"style\",\"\")},300)}):setTimeout(function(){e.find(\"ul\").attr(\"style\",\"\")},300)}),$(\".user-info-menu .hidden-sm\").click(function(){$(\".sidebar-menu\").hasClass(\"collapsed\")?$(\".has-sub.expanded > ul\").attr(\"style\",\"\"):$(\".has-sub.expanded > ul\").show()}),$(\"#main-menu li ul li\").click(function(){$(this).siblings(\"li\").removeClass(\"active\"),$(this).addClass(\"active\")}),$(\"a.smooth\").click(function(s){s.preventDefault(),public_vars.$mainMenu.add(public_vars.$sidebarProfile).toggleClass(\"mobile-is-visible\"),ps_destroy(),$(\"html, body\").animate({scrollTop:$($(this).attr(\"href\")).offset().top-30},{duration:500,easing:\"swing\"})}),!1});var href=\"\",pos=0;$(\"a.smooth\").click(function(s){$(\"#main-menu li\").each(function(){$(this).removeClass(\"active\")}),$(this).parent(\"li\").addClass(\"active\"),s.preventDefault(),href=$(this).attr(\"href\"),pos=$(href).position().top-30})!function(e){var c=Array.prototype.slice.call(document.querySelectorAll(\"img[data-original]\"));function i(){for(var r=0;r"}],"posts":[{"title":"LearnCpp chapter2","slug":"C&C++/LearnCpp-chapter2","date":"2020-03-26T09:07:50.000Z","updated":"2020-03-28T13:21:27.649Z","comments":true,"path":"archives/28c74e52.html","link":"","permalink":"https://www.longlongqin.top/archives/28c74e52.html","excerpt":"LearnCpp-chapter2https://www.learncpp.com","text":"LearnCpp-chapter2https://www.learncpp.com2.1 函数当你读一本书的时候，突然有人给你打电话。然后你就用“书签”夹在当前阅读位置，去接电话。等你电话接完，再回到你放书签的那个地方继续读书。函数调用(function call)是一个表达式。它告诉CPU中断当前函数并在这里“放一个书签”，然后执行另一个函数(就是函数调用中提及的那个函数)。当调用结束后，CPU就返回到“书签”的位置，然后再继续执行。caller：发起函数调用的函数叫做caller；callee(called function)：被调用的函数叫做callee(called function)。int main()的返回值：在int main()函数最后，会有返回值，这个值是返回到操作系统的，为了让操作系统知道这个程序执行成功与否。main函数的返回值，有一个特定名字叫做：status code （状态码）一般 return 0; 表示程序执行成功。返回非零值，表示程序执行错误。【Note】：C++规定，main函数必须是int型的。即： int main()2.3 函数的形参与实参形参(parameter)：是指函数定义中参数；(形参初始化是通过调用者传来的值(即，实参)来初始化的 )实参(argument)：函数调用时的实际参数：1234567891011121314#include &lt;iostream&gt;void printValues(int x, int y) //函数定义时的参数x,y，即这里的x,y是形参&#123; std::cout &lt;&lt; x &lt;&lt; '\\n'; std::cout &lt;&lt; y &lt;&lt; '\\n';&#125; int main()&#123; printValues(6, 7); //调用函数。即，6和7是实参 return 0;&#125;实参与形参如何一起工作？当调用一个函数时，函数所有的parameters都被创建为变量，并且每个arguments的值都被复制到匹配的parameters中。这个过程称为pass by value(按值传递)。关于函数参数求值顺序的警告在C++中，没有规定实参匹配的顺序（顺序：从左→右，还是从右→左），因为匹配顺序不重要。但是，如果实参是函数调用，那就需要注意了：1someFunction(a(), b()); // a() or b() may be called first是从右→左，还是从右→左：取决于a()和b()的功能。如果你想要规定谁先的话，你可以显示的规定匹配顺序，如：1234int avar&#123; a() &#125;; // a() will always be called firstint bvar&#123; b() &#125;; // b() will always be called second someFunction(avar, bvar); // it doesn't matter whether avar or bvar are copied first because they are just values2.4 局部范围局部变量Local variables：函数的形参，和它内部定义的变量 属于“局部变量”。如：123456int add(int x, int y) // function parameters x and y are local variables&#123; int z&#123; x + y &#125;; // z is a local variable too return z;&#125;局部变量生命周期：123456789101112131415161718#include &lt;iostream&gt; int add(int x, int y) // x and y are created and enter scope here&#123; // x and y are visible/usable within this function only return x + y;&#125; // y and x go out of scope and are destroyed here int main()&#123; int a&#123; 5 &#125;; // a is created, initialized, and enters scope here int b&#123; 6 &#125;; // b is created, initialized, and enters scope here // a and b are usable within this function only std::cout &lt;&lt; add(a, b) &lt;&lt; '\\n'; // calls function add() with x=5 and y=6 return 0;&#125; // b and a go out of scope and are destroyed here执行过程：程序开始执行于main()函数；main()函数的变量a被创建并赋值为5；（初始化）★main()函数的变量b被创建并赋值为6；（初始化）★函数add()被调用，并传入实参5，6；add()函数的变量x被创建，并初值为5;（初始化）★add()函数的变量y被创建，并初值为6;（初始化）★操作符“+”计算表达式”x+y”，产生值11；add函数将值11复制回调用者main()函数；add函数的x、y被摧毁；★main()函数在控制台上打印出11；main()函数返回0到操作系统；main()函数的a、b被摧毁。★由此可知，局部变量的生命周期：是从他开始被创建（如上述的第2步，变量a被创建）一直到执行完这个它所在的函数（如上述的第9步）被摧毁。【Note】：变量的创建和摧毁发生在程序的运行期间（runtime）。所以生命周期是一个runtime属性。局部范围标识符的范围决定了在源代码中标识符可以被访问的位置。范围是一个编译期间(compile-time)的属性。（当使用的标识符不在范围内时，编译器会报错）局部变量的范围：开始于它的定义，结束于定义它们的花括号集合的末尾。如下：123456789101112131415161718#include &lt;iostream&gt; // x is not in scope anywhere in this functionvoid doSomething()&#123; std::cout &lt;&lt; \"Hello!\\n\";&#125; int main()&#123; // x can not be used here because it's not in scope yet int x&#123; 0 &#125;; // x enters scope here and can now be used doSomething(); return 0;&#125; // x goes out of scope here and can no longer be used2.5 为什么要用函数使用函数的优势：有组织性Organization：随着程序越来越复杂，若将全部的代码都写在main()函数中，势必会增加复杂性。一个函数就像一个小型程序。将它与main函数分开写，我们就不必去考其余代码。可重用性Reusability：一个函数可以被调用无数次。就可以避免这种情况：如果写在main函数中，要调用n次这个功能，就要重新写这个功能n次。便于测试Testing：因为函数减少了代码冗余，所以首先要测试的代码就更少了。另外，因为函数是自包含的，所以一旦我们测试了一个函数以确保它可以工作，我们就不需要再次测试它，除非我们修改它。这减少了我们必须一次测试的代码量，使得查找bug(或者在第一时间避免bug)变得更加容易。可扩展性Extensibility：抽象化Abstraction：在每次用这个函数时，我们只需要知道它的名字。输入和输出。不必知道它是如何工作的。如何高效的使用函数？在一个程序中出现多次的语句通常应该构成一个函数。例如，如果我们以相同的方式多次读取来自用户的输入，那么这就是一个很好的函数候选。如果我们以相同的方式输出多次，这也是一个很好的候选函数。一个函数通常应该执行一个(且仅一个)任务。当一个函数变得太长、太复杂或难以理解时，可以将其分解为多个子函数。这就是所谓的重构refactoring。2.6 空白与基本格式空白空白Whitespace：是一个术语，指的是用于格式化目的的字符。在c++中，这主要指空格、制表符(tab)和换行。c++编译器通常会忽略空白，只有少数例外(在处理文本时)。因此，我们说c++是一种与空白无关的语言。123456789/*下面这三个都是一样的作用*/std::cout &lt;&lt; \"Hello world!\"; std::cout &lt;&lt; \"Hello world!\"; std::cout &lt;&lt; \"Hello world!\"; std::cout &lt;&lt; \"Hello world!\";【注意】在文本中，不允许换行：123//这种是不被允许的std::cout &lt;&lt; \"hello world!\" ;但是这种情况是可以的：文本只是被空白(空格、制表符(tab)、换行)分离，他将会被连接：123//这里的hello与world都是被双引号包含起来的std::cout &lt;&lt; \"Hello \" \"world!\"; // prints \"Hello world!\"基本格式缩进(indentation)可以用：空格spaces或者tabs（制符表）。如果用制符表，建议将其调整为4个空格的缩进，3个也可以。大花括号（brace）：Google中的C++风格：12int main() &#123;&#125;另一种风格：这一种不容易出错，更容易找出花括号123int main()&#123;&#125;在大花括号中的每条语句，应该从其所在花括号算起隔开一个tab的距离，开始写：12345int main()&#123; std::cout &lt;&lt; \"Hello world!\\n\"; // tabbed in one tab (4 spaces) std::cout &lt;&lt; \"Nice to meet you.\\n\"; // tabbed in one tab (4 spaces)&#125;每一行的字符不要过长，一般不超过80个字符如果一行别操作符(如，&lt;&lt; 、+)分割(split)。这个操作符应该被卸载下一行的开头：123std::cout &lt;&lt; 3 + 4 + 5 + 6 * 7 * 8;通过对齐值或注释或在代码块之间添加间距，使用空白使代码更易于阅读。1234567891011//不易读cost = 57;pricePerItem = 24;value = 5;numberOfItems = 17;//易读cost = 57;pricePerItem = 24;value = 5;numberOfItems = 17;123456789//不易读std::cout &lt;&lt; \"Hello world!\\n\"; // cout lives in the iostream librarystd::cout &lt;&lt; \"It is very nice to meet you!\\n\"; // these comments make the code hard to readstd::cout &lt;&lt; \"Yeah!\\n\"; // especially when lines are different lengths//易读std::cout &lt;&lt; \"Hello world!\\n\"; // cout lives in the iostream librarystd::cout &lt;&lt; \"It is very nice to meet you!\\n\"; // these comments are easier to readstd::cout &lt;&lt; \"Yeah!\\n\"; // especially when all lined up1234567891011121314151617//不易读// cout lives in the iostream librarystd::cout &lt;&lt; \"Hello world!\\n\";// these comments make the code hard to readstd::cout &lt;&lt; \"It is very nice to meet you!\\n\";// especially when all bunched togetherstd::cout &lt;&lt; \"Yeah!\\n\";//易读// cout lives in the iostream librarystd::cout &lt;&lt; \"Hello world!\\n\"; // these comments are easier to readstd::cout &lt;&lt; \"It is very nice to meet you!\\n\"; // when separated by whitespacestd::cout &lt;&lt; \"Yeah!\\n\";2.7 提前声明与定义一个例子：123456789101112#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; \"The sum of 3 and 4 is: \" &lt;&lt; add(3, 4) &lt;&lt; '\\n'; return 0;&#125; int add(int x, int y)&#123; return x + y;&#125;在vs 2013中运行，会出现：add.cpp(5) : error C3861: &#39;add&#39;: identifier not found原因：因为编译器是按照顺序进行编译的。当编译器在main函数的第5行中调用add函数，他不知道add是什么。因为目前为止还没有定义add函数（因为add函数的定义在第9行）如何解决呢？法一：调整代码顺序：让被调用的函数在调用者之前【在复杂程序中，不实用】123456789101112#include &lt;iostream&gt; int add(int x, int y)&#123; return x + y;&#125; int main()&#123; std::cout &lt;&lt; \"The sum of 3 and 4 is: \" &lt;&lt; add(3, 4) &lt;&lt; '\\n'; return 0;&#125;如果在一个复杂的程序中，会调用很多函数，还有嵌套型的调用。如果去一个个个去找出调用顺序，然后去调整代码。这样是很乏味低效的。法二[推荐]：提前声明forward declaration：在使用函数之前，先声明它。（然后就不用关注代码实现的顺序了）提前向声明允许我们在实际定义标识符之前告诉编译器标识符的存在。为了编写一个函数的提前向声明，我们使用一个称为函数原型(function prototype)的声明语句。函数原型包括：函数的 返回类型、名字、形参，以分号(semicolon)结束。但是不包含函数主体(function body)1234567891011121314#include &lt;iostream&gt; int add(int x, int y); // forward declaration of add() (using a function prototype) int main()&#123; std::cout &lt;&lt; \"The sum of 3 and 4 is: \" &lt;&lt; add(3, 4) &lt;&lt; '\\n'; // this works because we forward declared add() above return 0;&#125; int add(int x, int y) // even though the body of add() isn't defined until here&#123; return x + y;&#125;忘记定义函数主题如果声明了函数，但没定义函数，而且这个函数没有被调用，那么这个程序可以被编译&amp;运行；如果声明了函数，但没定义函数，而且而且这个函数有被调用，那么这个程序可以被编译，但链接会出错。1234567891011#include &lt;iostream&gt; int add(int x, int y); // forward declaration of add() using function prototype int main()&#123; std::cout &lt;&lt; \"The sum of 3 and 4 is: \" &lt;&lt; add(3, 4) &lt;&lt; '\\n'; return 0;&#125; // note: No definition for function add上面程序在visual studio 中，会出现：编译成功，链接失败12345Compiling...add.cppLinking...add.obj : error LNK2001: unresolved external symbol &quot;int __cdecl add(int,int)&quot; (?add@@YAHHH@Z)add.exe : fatal error LNK1120: 1 unresolved externals声明 VS. 定义定义(define)：实现(函数或类型）或者是 实例化(对于变量）标识符。123456int add(int x, int y) // implements function add()&#123; int z&#123; x + y &#125;; // instantiates variable z return z;&#125;对于链接器(linker)来说定义（define）是必要的的。单定义规则单定义规则（one definition rule）简称：ODR：在C++中非常有名的规则，主要分三部分：在给定的文件中（这里翻译不准确），每个函数、对象、类型、模板只能有一次定义。在整个程序中，一个对象或者函数只能被定义一次；类型、模板、内置函数、变量 被允许在不同的文件中有相同的定义。违背第1条，将会使编译器发出重新定义错误；123456789101112131415int add(int x, int y)&#123; return x + y;&#125; int add(int x, int y) // violation part1 of ODR, we've already defined function add&#123; return x + y;&#125; int main()&#123; int x; int x; // violation of ODR, we've already defined x&#125;在visual studio中，会出现：1234project3.cpp(9): error C2084: function &#39;int add(int,int)&#39; already has a bodyproject3.cpp(3): note: see previous definition of &#39;add&#39;project3.cpp(16): error C2086: &#39;int x&#39;: redefinitionproject3.cpp(15): note: see declaration of &#39;x&#39;违背第2条，将会使连接器发出重新定义的错误；违背第3条，将会产生未定义的行为。声明声明(declaration)：是一个语句。它告诉编译器这里存在一个标识符和它的类型。12int add(int x, int y); // tells the compiler about a function named \"add\" that takes two int parameters and returns an int. No body!int x; // tells the compiler about an integer variable named x对编译器(complier)而言声明(declaeation)是必要的。在C++中，所有的定义也用作声明。上述例子中的int x是 定义，也是声明。多数情况下，定义符合我们的目的，因为定义能同时满足“编译器”和“链接器”的要求。【所有的定义都是声明，但所有的声明并不一定是定义。这些不是定义的声明有一个名字：纯声明(pure declarations)】一个典型的例子就是：函数原型(function prototype)，它满足编译器的要求，但不满足链接器的要求。其他类型的纯声明包含：提前声明变量 和 类型声明。单定义规则不适用于纯声明。所以，你可以对一些标识符声明n多次都可以（虽然声明n次，会有很多次是冗余的）小结：在很多编程语言中，“声明”就是指“纯声明”；“定义”就是指“定义也可以用于声明”。所以，int x;是一个定义（虽然他既是定义，也是声明）2.9 命名冲突&amp;命名空间命名冲突命名冲突：naming collision (or naming conflict).将两个同名的标识符放在同一个程序中，编译器或者链接器无法区分它们时，就会报错。这种情况就是：命名冲突例如：a.cpp123456#include &lt;iostream&gt; void myFcn(int x)&#123; std::cout &lt;&lt; x;&#125;main.cpp1234567891011#include &lt;iostream&gt; void myFcn(int x)&#123; std::cout &lt;&lt; 2 * x;&#125; int main()&#123; return 0;&#125;当编译器编译这个程序时，它将会单独的编译a.cpp和main.cpp，每个cpp文件都编译成功。但是，当链接时，链接器将会链接a.cpp和main.cpp中所有的定义到一起，此时就发现函数myFun命名冲突了。【注意，虽然函数myFun没有被调用，但在链接时还是会出错】命名冲突一般出现在以下两种情况：一个函数(或全局变量)的两个(或多个)定义被引入到不同的文件中，这些文件被编译到同一个程序中。这将导致一个链接器错误，如上所示。一个函数(或全局变量)的两个(或多个)定义被引入到同一个文件中(通常通过#include)。这将导致编译器错误。对于局部变量，C++提供一种局部范围的机制，它使定义在函数内部的局部变量不会冲突。但这种机制对于函数的名字无效。命名空间命名空间：namespace命名空间：之所以出来这样一个东西，是因为人类可用的单词数太少，并且不同的人写的程序不可能所有的变量都没有重名现象，对于库来说，这个问题尤其严重，如果两个人写的库文件中出现同名的变量或函数(不可避免)，使用起来就有问题了。为了解决这个问题，引入了名字空间这个概念，通过使用 namespace xxx；你所使用的库函数或变量就是在该名字空间中定义的，这样一来就不会引起不必要的冲突了。注意，在同一命名空间中，所有的名字必须是独一无二的。全局命名空间在C++中，任何没有定义在 类、函数、或 命名空间 的名字，都被默认的归为“全局命名空间(global namespace)”，有时也叫“全局范围(global scope)”std 命名空间在最初设计c++时，c++标准库中的所有标识符(包括std::cin和std::cout)都可以在没有std::前缀的情况下使用(它们是全局命名空间的一部分)。但是，这意味着标准库中的任何标识符都可能与你自己定义的标识符的名字(也在全局名称空间中定义)发生冲突。为了避免这种冲突，C++将所有标准库中的所有函数都移入一个叫做“std(是standard的简称)”的命名空间，即：std namespace所以，你看到的std::cout，这并不是它的名字，它实际上只是cout，std只是命名空间的名字，而cout是std namespace中的一部分。【注】：如果你使用一个命名空间中的标识符，你必须告诉编译器，这个标识符是在这个命名空间内。显示的命名空间限定符 std::最直接的方法是：告诉编译器我们使用cout是来自 std这个namespace(命名空间)的。可以使用前缀 “std::” 来完成：1234567#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; \"Hello world!\"; // when we say cout, we mean the cout defined in the std namespace return 0;&#125;‘::’ 是一个操作符，叫做“作用域解析符(scope resolution operator)”。在它左边的标识符表示：所在命名空间的名称；在它右边的标识符表示：这个命名空间的一个 标识符。【注】如果“::”的左边没有东西，则默认为它在全局命名空间( global namespace )中。std::cout就表示cout是在 std namsoace 中。using namespace std另一种方法是：用使用指令(using directive)**using namespace std。123456789#include &lt;iostream&gt; using namespace std; // this is a using directive telling the compiler to check the std namespace when resolving identifiers with no prefix int main()&#123; cout &lt;&lt; \"Hello world!\"; // cout has no prefix, so the compiler will check to see if cout is defined locally or in namespace std return 0;&#125;using directive：告诉编译器 当试图解析一个没有使用命名空间前缀(namespace prefix)的标识符时，检查一个指定的命名空间。【不推荐此方法】：123456789101112131415#include &lt;iostream&gt; // imports the declaration of std::cout using namespace std; // makes std::cout accessible as \"cout\" int cout() // declares our own \"cout\" function&#123; return 5;&#125; int main()&#123; cout &lt;&lt; \"Hello, world!\"; // Compile error! Which cout do we want here? The one in the std namespace or the one we defined above? return 0;&#125;这种情况，将不会被编译。因为编译器不知道我们到底想用我们自己定义的cout函数，还是想用 std命名空间 中的cout函数。并且，虽然标识符名称现在可能不冲突，但在将来的语言修订中，它可能与添加到std名称空间的新标识符发生冲突。2.10 预处理器在编译之前，代码要经过一个阶段，叫做“翻译(translation)”。在翻译阶段会发生许多事情，以使您的代码准备好被编译(如果您感兴趣，可以在这里找到翻译阶段的列表)。应用翻译的代码文件称为翻译单元(translation unit)。最值得注意的是：翻译阶段包含预处理器(preprocessor)。最好将预处理器看作是一个单独的程序，它处理每个代码文件中的文本部分。当预处理器运行时，它从头到尾的扫描源码文件，寻找预处理程序指令。预处理指令(preprocessor directives)，也称作directives：是以“#”符号开始，以换行符结束的指令(不是分号，即不要加分号)。“使用指令(using directives)”不是预处理指令，所以不会被预处理器处理。所以当提起“directive”，通常指的是“preprocessor directive”include当你#include*一个文件，预处理器将会把#include*指令 替换为 include file的内容。（include file 的内容将会被预处理，然后被编译）1234567#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; \"Hello, world!\"; return 0;&#125;当预处理器运行时，预处理器将会把#include &lt;iostream&gt;替换为 名为“iostream”的文件。宏定义宏定义：Macro defines#include 指令可以用来创建宏。在C++中，宏是定义如何将 ‘输入文本’ 转换为 ‘替换输出文本’。宏有两种基本类型：1️⃣对象式宏(object-like macros)。2️⃣函数式宏( function-like macros)函数式宏函数式宏的作用类似于函数，并具有类似的用途。对象式宏可以被定义成以下两种形式：#define identifier#define identifier substitution_text此处，identifier：宏名【一般是大写字母，用下划线表示空格】；substitution_text：替换文本(替换输出文本)1.带有输出文本(substitution_text)：当预处理器处理此条指令时，宏名 将会被替换为‘输出文本’。123456789101112131415161718#include &lt;iostream&gt; #define MY_NAME \"Alex\" int main()&#123; std::cout &lt;&lt; \"My name is: \" &lt;&lt; MY_NAME; return 0;&#125;//预处理程序将上述转换为以下内容:int main()&#123; std::cout &lt;&lt; \"My name is: \" &lt;&lt; \"Alex\"; return 0;&#125;2.不带输出文本：1#define USE_YEN如你所想，这条宏指令工作方式：标识符的任何进一步出现都将被删除，并将被nothing替换!条件编译条件编译：conditional compilation使用条件编译的预处理指令可以设置在什么条件下编译，什么条件下不编译。比较常见的条件编译指令有以下三个：#ifdef*、#ifndef、#endif*#ifdef 预处理指令允许预处理器检查这个标识符(identifier)是否已经被 #define(定义了)。如果被定义，那么在#ifdef*和#endif*之间的代码将会被编译；如果没被定义，这些代码将会被忽略。12345678910111213141516#include &lt;iostream&gt; #define PRINT_JOE int main()&#123;#ifdef PRINT_JOE std::cout &lt;&lt; \"Joe\\n\"; // if PRINT_JOE is defined, compile this code#endif #ifdef PRINT_BOB std::cout &lt;&lt; \"Bob\\n\"; // if PRINT_BOB is defined, compile this code#endif return 0;&#125;ifndef指令和ifdef*指令的作用是相反的。即，如果这个标识符没有被 #define，那么在#ifndef和#endif*之间的代码才会被编译12345678910#include &lt;iostream&gt; int main()&#123;#ifndef PRINT_BOB std::cout &lt;&lt; \"Bob\\n\";#endif return 0;&#125;输出结果是“Bob”,因为PRINT_BOB没有被 #define，所有才会执行。#if 0 ：条件编译的另一个常见用法是使用#if 0来排除正在编译的代码块(就像它在一个注释块中一样):12345678910111213#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; \"Joe\\n\"; #if 0 // Don't compile anything starting here std::cout &lt;&lt; \"Bob\\n\"; std::cout &lt;&lt; \"Steve\\n\";#endif // until this point return 0;&#125;【注】对象式宏不会影响预处理器的其他指令如：12345#define FOO 9 // Here's a macro substitution #ifdef FOO // This FOO does not get replaced because it’s part of another preprocessor directive std::cout &lt;&lt; FOO; // This FOO gets replaced with 9 because it's part of the normal code#endif宏定义的范围指令在编译之前，从上到下逐个文件地解析。同一文件中12345678910111213#include &lt;iostream&gt; void foo()&#123;#define MY_NAME \"Alex\"&#125; int main()&#123; std::cout &lt;&lt; \"My name is: \" &lt;&lt; MY_NAME; return 0;&#125;虽然，上面的代码表面上看起来：#define MY_NAME “Alex”是定义在函数foo内部的。但是预处理器将不会注意，因为它不懂C++中的概念，例如函数。所以，这个程序的执行流程与#define MY_NAME “Alex”在函数foo之前或之后定义的行为相同。但是，一般情况下，我们习惯于将 #define identifiers这种宏定义放在函数的外面。同一项目的不同文件中预处理程序完成后，将丢弃该文件中定义的所有标识符。这意味着指令仅从定义点到定义它们的文件末尾有效。在一个代码文件中定义的指令不会影响同一项目中的其他代码文件。example：function.cpp:1234567891011#include &lt;iostream&gt; void doSomething()&#123;#ifdef PRINT std::cout &lt;&lt; \"Printing!\";#endif#ifndef PRINT std::cout &lt;&lt; \"Not printing!\";#endif&#125;main.cpp12345678910void doSomething(); // forward declaration for function doSomething() #define PRINT int main()&#123; doSomething(); return 0;&#125;运行的结果是：Not printing!因为文件之间的宏定义互不影响。2.11 头文件头文件：Header files当程序变得越来越大了，对每个函数都进行提前声明是很乏味无趣的。如果能够将所有的 提前声明 放在一个地方，然后在需要时导入它们，这不是很好吗?code files：源文件(后缀 .cpp)；header files：头文件(后缀 .h 或 .hpp)头文件的主要用途就是：将 声明 引入 源文件 中。使用标准库头文件1234567#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; \"Hello, world!\"; return 0;&#125;这个程序使用std::cout。但是这个程序没有提供关于std::cout的声明或者定义，那编译器是如何知道std::cout是什么呢？答：因为std::cout在头文件“iostream” 中 已经提前声明过了。当我们#include &lt;iostream&gt;时，我们就请求预处理器将头文件“iostream”中的所有内容(当然也包含std::cout)都复制过来。注意：当#include xxx时，xxx头文件的所有内容都被引入到当前文件中。头文件通常只包含：函数和对象的声明，不包含它们的定义。如 std::cout在头文件“iostream”中声明， 但 定义为c++标准库的一部分，在链接器阶段自动链接到程序中。创建自己的头文件步骤：头文件保护符(header guaed)然后添加头文件(后缀 .h)进行声明；相应的也要添加源文件(后缀 .cpp)进行定义。【注意头文件、源文件的名字要一样】创建完之后：add.h：1234// 1) We really should have a header guard here, but will omit it for simplicity (we'll cover header guards in the next lesson) // 2) This is the content of the .h file, which is where the declarations goint add(int x, int y); // function prototype for add.h -- don't forget the semicolon!add.cpp：1234int add(int x, int y)&#123; return x + y;&#125;main.cpp：12345678#include &lt;iostream&gt;#include \"add.h\" // Insert contents of add.h at this point. Note use of double quotes here.【不是标准库的头文件，一般用双引号\"\"】 int main()&#123; std::cout &lt;&lt; \"The sum of 3 and 4 is \" &lt;&lt; add(3, 4) &lt;&lt; '\\n'; return 0;&#125;上面的程序的编译、链接过程：头文件的&lt;&gt;&amp;””尖括号：Angled brackets ，即&lt;&gt;。尖括号用来告诉预处理程序我们包含了编译器包含的头文件，所以它应该在系统目录中查找那个头文件。双引号：double-quotes，即“”。双引号告诉预处理器这是一个用户定义的头文件，所以它应该在当前目录中寻找这个头文件。如果没找到，它会检查其他的包含路径(已指定为compiler/IDE设置的一部分的路径)。如果还是失败的话，它将去系统目录中寻找这个头文件。“iostream”没 .h 后缀？好奇，为什么“iostream”(或者其他标准库头文件)没有后缀 .h？答：因为iostream.h是另一个头文件iostream.h与iostream：在C++最开始创建的时候，所有标准库都是有 .h 后缀的。但是，后来ANSI委员会修改C++，将所有的标准库放在 std 命名空间 中，进而避免与用户自定义的标识符 冲突。但是为题来了，将这些标准库移入std 命名空间 后，以前的程序将无法运行。为了解决这个问题，一个新的头文件：iostream出现，这个新头文件包含了 iostream.h的所有内容。然后，旧的程序依然可以用#include &lt;iostream.h&gt;，新程序就用#include &lt;iostream&gt;头文件路径建议12#include \"headers/myHeader.h\"#include \"../moreHeaders/myOtherHeader.h\"这种设置成路径形式的头文件，假设现在路径没问题。但是很有可能在某一天，你的文件位置就不小心的被移动了，这时候就用不了了。【建议】将你平常会用到的很多不同的文件放在比较固定的地方，然后在你的 compiler/IDE 这个固定地方的位置。这样当它在当前目录中找不到它们时，它就会去你设置的固定位置找。这通常可以通过在IDE项目设置中设置包含路径或搜索目录来实现。visual studio设置方法：在“解决方案”中，点击project的“属性”，然后看到“VC++目录”中的“包含目录(include directories)”，在这里面添加你要使用的头文件的目录。这种方法的优点是，如果要更改目录结构，只需更改单个编译器或IDE设置，而不必更改每个代码文件。2.12 头文件保护符头文件保护符：header guards重复定义duplicate definition：重复定义123456789101112131415161718192021222324252627//变量重定义int main()&#123; int x; // this is a definition for variable x int x; // compile error: duplicate definition return 0;&#125;//函数重定义#include &lt;iostream&gt; int foo() // this is a definition for function foo&#123; return 5;&#125; int foo() // compile error: duplicate definition&#123; return 5;&#125; int main()&#123; std::cout &lt;&lt; foo(); return 0;&#125;这种比较容易修复。但是在头文件中，很容易出现一个头文件中的定义被include不止一次。这通常发生在 一个头文件 又#include 其他头文件：square.h:12345//在头文件中，不建议出现 定义；但是这里为了方便举例int getSquareSides()&#123; return 4;&#125;geometry.h:1#include \"square.h\"main.cpp:1234567#include \"square.h\"#include \"geometry.h\"int main()&#123; return 0;&#125;上面这个程序。首先，在main.cpp中#include square.h ，它(square.h)将getSquareSides函数的定义复制到main.cpp中。然后，main.cpp又#include geometry.h ，它(geometry.h)又包含了square.h，所以也会将square.h中的内容(包括getSquareSides函数)复制到geometry.h，进而也就被复制到main.cpp中。所以，当解析完所有的#include之后，main.cpp就变成这样：1234567891011121314int getSquareSides() // from square.h&#123; return 4;&#125; int getSquareSides() // from geometry.h (via square.h)&#123; return 4;&#125; int main()&#123; return 0;&#125;所以，就会出现重复定义，编译也会出错。每个单独的文件没问题，但是因为main.cpp最终#include了两次square.h的内容，所以我们遇到了问题。如何解决呢？？？答：使用header guard头文件保护符头文件保护符(header guard)是条件编译(conditional compilation)的指令，它的形式如下：123456#ifndef SOME_UNIQUE_NAME_HERE //SOME_UNIQUE_NAME_HERE：你可以用任何名字代替它#define SOME_UNIQUE_NAME_HERE//这里是写关于 声明 的代码#endif当这个头文件被#included时，预处理器检查SOME_UNIQUE_NAME_HERE是否被定义过。如果这是我们第一次包含这个头文件，SOME_UNIQUE_NAME_HERE还没有被创建。然后就会定义SOME_UNIQUE_NAME_HERE，而且会包含文件的内容。如果这个头文件之前已经被包含到这个文件中，那么SOME_UNIQUE_NAME_HERE是已经被定义过的，而且其内容也以经被包含在这个文件中。所以这个头文件的内容将会被忽略（由于#ifndef）。每一个头文件都应该要有头文件保护符。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.longlongqin.top/tags/C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.top"}},{"title":"Let’s Build A Simple Interpreter-10","slug":"LSBASI-10","date":"2020-03-25T05:21:04.000Z","updated":"2020-03-25T14:19:34.915Z","comments":true,"path":"archives/2f66ae56.html","link":"","permalink":"https://www.longlongqin.top/archives/2f66ae56.html","excerpt":"今天的改进内容：如何进行语法Fenix和解释Pascal的程序头部；如何进行语法分析Pascal的变量声明；将更新解释器，用DIV关键字来表示整数的出发、用品”/“来表示浮点数的除法；添加Pascal语言的注释功能","text":"今天的改进内容：如何进行语法Fenix和解释Pascal的程序头部；如何进行语法分析Pascal的变量声明；将更新解释器，用DIV关键字来表示整数的出发、用品”/“来表示浮点数的除法；添加Pascal语言的注释功能源码下载在进行细致的讲解之前，我们先下载本节的解释器的源码：spy.py和一个简单的Pascal语言的程序：part10.pas。然后再在命令提示符(Windows10系统 可直接在左下角搜索框中搜索“cmd”)中进行输入：python spi.py part10.pas：好了。现在来看看今天要改进的内容，我们将学习：如何进行语法Fenix和解释Pascal的程序头部；如何进行语法分析Pascal的变量声明；将更新解释器，用DIV关键字来表示整数的出发、用品”/“来表示浮点数的除法；添加Pascal语言的注释功能更新后的语法规则更新后的语法规则，如下图所示：这里给出一个简单地Pascal语言的程序，便于理解其语法：12345678910111213141516171819202122PROGRAM Part10;VAR number : INTEGER; a, b, c, x : INTEGER; y : REAL;BEGIN &#123;Part10&#125; BEGIN number := 2; a := number; b := 10 * a + 10 * number DIV 4; c := a - - b END; x := 11; y := 20 / 7 + 3.14; &#123; writeln('a = ', a); &#125; &#123; writeln('b = ', b); &#125; &#123; writeln('c = ', c); &#125; &#123; writeln('number = ', number); &#125; &#123; writeln('x = ', x); &#125; &#123; writeln('y = ', y); &#125;END. &#123;Part10&#125;1. program程序定义的语法规则，包括：保留字“PROGRAM”、程序的名字、一个以点“.”结尾的block。如：123PROGRAM Part10;BEGINEND.上面是一个完整的Pascal程序2. blockblock包含：一个声明规则、复合语句，如：12345678910//示例1VAR number : INTEGER;BEGINEND//示例2BEGINEND3. declarationsPascal的声明有几个部分，每个部分都是可选的。本节中，我们只讨论变量声明的部分。变量声明规则：要么有一个变量声明的子规则，要么是空的。4. VARPascal是静态类语言，也就是说在使用每一个变量之前，都需要明确的声明它的类型。变量的声明在程序中用VAR保留字，如：1234VAR number : INTEGER; a, b, c, x : INTEGER; y : REAL;5. type_spec在本节中，数据类型是两种：INTEGER 和 REAL(float)，常出现在变量声明部分：123VAR a : INTEGER; b : REAL;本节中没有进行设计类型检查，这将会在后续文章中添加6. termterm规则更新之后，将整数、浮点数的出发分开表示：DIV、/1220 / 7 = 2.85714285714 //浮点数出发20 DIV 7 = 2 //整数除法7. factor更新之后可以处理整数、浮点数的常量。以下是今天的完整语法：123456789101112131415161718192021222324252627282930313233343536program : PROGRAM variable SEMI block DOTblock : declarations compound_statementdeclarations : VAR (variable_declaration SEMI)+ | emptyvariable_declaration : ID (COMMA ID)* COLON type_spectype_spec : INTEGER | REALcompound_statement : BEGIN statement_list ENDstatement_list : statement | statement SEMI statement_liststatement : compound_statement | assignment_statement | emptyassignment_statement : variable ASSIGN exprempty :expr : term ((PLUS | MINUS) term)*term : factor ((MUL | INTEGER_DIV | FLOAT_DIV) factor)*factor : PLUS factor | MINUS factor | INTEGER_CONST | REAL_CONST | LPAREN expr RPAREN | variablevariable: ID更新Lexer总结一下，lexer的改变：新的tokens新的保留字添加处理Pascal语言的注释，用skip_comment更新integer更新get_next_token ，使其能够返回新添加的tokens让我们深入研究一下上面提到的变化:为了处理程序头、变量的声明、整数与浮点数常量以及它们的除法。我们需要添加新的tokens，我们还需要更新“INTEGER”的含义：表示一个整数类型，而不是一个整数常量。下面是更新后全部的tokens:PROGRAM (reserved keyword)VAR (reserved keyword)COLON (:)COMMA (,)INTEGER (we change it to mean integer type and not integer constant like 3 or 5)REAL (for Pascal REAL type)INTEGER_CONST (for example, 3 or 5)REAL_CONST (for example, 3.14 and so on)INTEGER_DIV for integer division (the DIV reserved keyword)FLOAT_DIV for float division ( forward slash / )全部的保留字token：123456789RESERVED_KEYWORDS = &#123; 'PROGRAM': Token('PROGRAM', 'PROGRAM'), 'VAR': Token('VAR', 'VAR'), 'DIV': Token('INTEGER_DIV', 'DIV'), 'INTEGER': Token('INTEGER', 'INTEGER'), 'REAL': Token('REAL', 'REAL'), 'BEGIN': Token('BEGIN', 'BEGIN'), 'END': Token('END', 'END'),&#125;处理注释，添加一个skip_comment 函数来处理注释，它的原理就是在找到右花括号“｛”之前，丢弃所有字符：1234def skip_comment(self): while self.current_char != '&#125;': self.advance() self.advance() # the closing curly brace重新命名integer函数为number函数，，使其能够处理整型常量和浮点型常量，如3和3.14：1234567891011121314151617181920212223def number(self): \"\"\"Return a (multidigit) integer or float consumed from the input.\"\"\" result = '' while self.current_char is not None and self.current_char.isdigit(): result += self.current_char self.advance() if self.current_char == '.': result += self.current_char self.advance() while ( self.current_char is not None and self.current_char.isdigit() ): result += self.current_char self.advance() token = Token('REAL_CONST', float(result)) else: token = Token('INTEGER_CONST', int(result)) return token更新get_next_token函数，使其能够返回新增的tokens：1234567891011121314151617181920212223def get_next_token(self): while self.current_char is not None: ... if self.current_char == '&#123;': self.advance() self.skip_comment() continue ... if self.current_char.isdigit(): return self.number() if self.current_char == ':': self.advance() return Token(COLON, ':') if self.current_char == ',': self.advance() return Token(COMMA, ',') ... if self.current_char == '/': self.advance() return Token(FLOAT_DIV, '/') ...更新Parser总结Parser的变化：新的抽象语法树结点（AST nodes）：Program, Block, VarDecl, Type对应新的语法规则的函数：block, declarations, variable_declaration, 和 type_spec.更新已经存在的paeser中的方法：program, term, and factor让我们深入研究一下上面提到的变化:新的AST nodes：Program AST node：表示一个程序，也是我们的根节点：1234class Program(AST): def __init__(self, name, block): self.name = name self.block = blockBlock AST node：包含声明与复合语句：1234class Block(AST): def __init__(self, declarations, compound_statement): self.declarations = declarations self.compound_statement = compound_statementVarDecl AST node：表示一个变量声明，它包含一个边梁节点和变量的类型结点：1234class VarDecl(AST): def __init__(self, var_node, type_node): self.var_node = var_node self.type_node = type_nodeType AST node：表示一个变量类型（INTEGER or REAL）：1234class Type(AST): def __init__(self, token): self.token = token self.value = token.value对应新增的语法规则的函数(方法)：block, declarations, variable_declaration, 和 type_spec.【这些方法负责解析新的语言结构和构造新的AST nodes】：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051def block(self): \"\"\"block : declarations compound_statement\"\"\" declaration_nodes = self.declarations() compound_statement_node = self.compound_statement() node = Block(declaration_nodes, compound_statement_node) return nodedef declarations(self): \"\"\"declarations : VAR (variable_declaration SEMI)+ | empty \"\"\" declarations = [] if self.current_token.type == VAR: self.eat(VAR) while self.current_token.type == ID: var_decl = self.variable_declaration() declarations.extend(var_decl) self.eat(SEMI) return declarationsdef variable_declaration(self): \"\"\"variable_declaration : ID (COMMA ID)* COLON type_spec\"\"\" var_nodes = [Var(self.current_token)] # first ID self.eat(ID) while self.current_token.type == COMMA: self.eat(COMMA) var_nodes.append(Var(self.current_token)) self.eat(ID) self.eat(COLON) type_node = self.type_spec() var_declarations = [ VarDecl(var_node, type_node) for var_node in var_nodes ] return var_declarationsdef type_spec(self): \"\"\"type_spec : INTEGER | REAL \"\"\" token = self.current_token if self.current_token.type == INTEGER: self.eat(INTEGER) else: self.eat(REAL) node = Type(token) return node更新已有的program, term, 和, factor 方法来适应语法的改变：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859def program(self): \"\"\"program : PROGRAM variable SEMI block DOT\"\"\" self.eat(PROGRAM) var_node = self.variable() prog_name = var_node.value self.eat(SEMI) block_node = self.block() program_node = Program(prog_name, block_node) self.eat(DOT) return program_nodedef term(self): \"\"\"term : factor ((MUL | INTEGER_DIV | FLOAT_DIV) factor)*\"\"\" node = self.factor() while self.current_token.type in (MUL, INTEGER_DIV, FLOAT_DIV): token = self.current_token if token.type == MUL: self.eat(MUL) elif token.type == INTEGER_DIV: self.eat(INTEGER_DIV) elif token.type == FLOAT_DIV: self.eat(FLOAT_DIV) node = BinOp(left=node, op=token, right=self.factor()) return nodedef factor(self): \"\"\"factor : PLUS factor | MINUS factor | INTEGER_CONST | REAL_CONST | LPAREN expr RPAREN | variable \"\"\" token = self.current_token if token.type == PLUS: self.eat(PLUS) node = UnaryOp(token, self.factor()) return node elif token.type == MINUS: self.eat(MINUS) node = UnaryOp(token, self.factor()) return node elif token.type == INTEGER_CONST: self.eat(INTEGER_CONST) return Num(token) elif token.type == REAL_CONST: self.eat(REAL_CONST) return Num(token) elif token.type == LPAREN: self.eat(LPAREN) node = self.expr() self.eat(RPAREN) return node else: node = self.variable() return node现在来看看我们的抽象语法树Abstract Syntax Tree，下面是一个Pascal程序：12345678910PROGRAM Part10AST;VAR a, b : INTEGER; y : REAL;BEGIN &#123;Part10AST&#125; a := 2; b := 10 * a + 10 * a DIV 4; y := 20 / 7 + 3.14;END. &#123;Part10AST&#125;它的解析树为：在图中可以看到我们添加的新节点。更新Interpreter现在，剩下的就是向解释器类添加新的访问者方法。下面是将要新增的四个访问方法（对应新增的四种结点）：visit_Programvisit_Blockvisit_VarDeclvisit_Type其中对于VarDecl和Type，解释器对他们什么都不做：123456789101112131415def visit_Program(self, node): self.visit(node.block)def visit_Block(self, node): for declaration in node.declarations: self.visit(declaration) self.visit(node.compound_statement)def visit_VarDecl(self, node): # Do nothing passdef visit_Type(self, node): # Do nothing pass更新visit_BinOp 方法，使其能够准确的解释整数和浮点数的除法：1234567891011def visit_BinOp(self, node): if node.op.type == PLUS: return self.visit(node.left) + self.visit(node.right) elif node.op.type == MINUS: return self.visit(node.left) - self.visit(node.right) elif node.op.type == MUL: return self.visit(node.left) * self.visit(node.right) elif node.op.type == INTEGER_DIV: return self.visit(node.left) // self.visit(node.right) elif node.op.type == FLOAT_DIV: return float(self.visit(node.left)) / float(self.visit(node.right))总结总结一下，在本文中，扩展了Pascal解释器的哪些部分：添加新的语法规则和更新现有的规则；添加新token，并相应地添加新方法去处理这些tokens，更新了现有的方法；parser中：为新的语法结构添加新的AST nodes；向我们的递归下降解析器添加与新语法规则相对应的新方法，并更新一些现有的方法；interpreter中添加新的访问方法，更新了一个现存的访问方法我们也出去了一些“HACKS”(part9 中提到的)：本文的解释器可以处理程序头部(PROGRAM header)变量可以用VAR关键字来声明将整数与浮点数的除法分开来","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let’s Build A Simple Interpreter","slug":"Let’s-Build-A-Simple-Interpreter","permalink":"https://www.longlongqin.top/tags/Let%E2%80%99s-Build-A-Simple-Interpreter/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.top"}},{"title":"LSBASI整理","slug":"学习笔记/Let's Build A Simple Interpreter/1-8整理","date":"2020-03-24T05:34:22.000Z","updated":"2020-03-26T08:45:58.767Z","comments":true,"path":"archives/6fc94bb0.html","link":"","permalink":"https://www.longlongqin.top/archives/6fc94bb0.html","excerpt":"持续更新","text":"持续更新part 3实现了加减混合运算，并引入语法图概念part 4实现了整数的乘除混合运算，引入上下文无关语法(context-free-grammars)，即BNFpart 5实现了加减乘除混合运算，引入结合律(associativity)和优先级(precedence)part 6新增括号运算part 7从本小节开始，将interpreter和parser分开来实现。并引入抽象语法树(AST)和解析树(parse tree)概念part 8新增一元操作符(unary operators)：“+”，“-”part 9整体分析整体分析，不管是part x，都一起分析，看看他的整体结构：Lexertoken类型：12345678910111213141516171819202122INTEGER = 'INTEGER' #用于表示整数类型REAL = 'REAL' #表示浮点型INTEGER_CONST = 'INTEGER_CONST' #整型常量REAL_CONST = 'REAL_CONST' #浮点型常量PLUS = 'PLUS'MINUS = 'MINUS'MUL = 'MUL'INTEGER_DIV = 'INTEGER_DIV' #整型数的除法FLOAT_DIV = 'FLOAT_DIV' #浮点数的除法LPAREN = 'LPAREN' #左小括号RPAREN = 'RPAREN' #右小括号ID = 'ID' #表示有效的标识符ASSIGN = 'ASSIGN' #这种token表示两个字符，“:=”,用于赋值语句BEGIN = 'BEGIN' END = 'END'SEMI = 'SEMI' # 表示分号，用于标记复合语句中的一个句子的结尾DOT = 'DOT' #点，用于Pascal语言中program的定义PROGRAM = 'PROGRAM' VAR = 'VAR'COLON = 'COLON' #冒号COMMA = 'COMMA' #逗号EOF = 'EOF'保留字123456789RESERVED_KEYWORDS = &#123; 'PROGRAM': Token('PROGRAM', 'PROGRAM'), 'VAR': Token('VAR', 'VAR'), 'DIV': Token('INTEGER_DIV', 'DIV'), 'INTEGER': Token('INTEGER', 'INTEGER'), 'REAL': Token('REAL', 'REAL'), 'BEGIN': Token('BEGIN', 'BEGIN'), 'END': Token('END', 'END'),&#125;词法分析器的结构：有一个___init__的函数，在创建实例的时候，就会自动调用这个方法；一个提示错误的函数error；然后开始处理“词”，这里有一个函数advance用于向前进一步(pos会➕1）：peek：为了在以相同的字符开头时，区分是“保留字”还是“标识符”。在这里，我们可以在不消耗下一个字符的情况下去查看缓冲区：就是利用peek_pos移动查看下一个字符，而真正的pos不动。skip_comment：处理注释；skip_whitespace：处理空格；number：在part10之前，叫做integer，因为现在不仅有整型数据，还有浮点型的。所以改名为number。_id：处理“标识符”和“保留字”get_next_token：词法分析器的核心部分，前面的都是设计，现在才开始识别出一个个的token，下面就是列出识别token的种类：其实这里叫做：get_token_and_go_next比较直观，这个函数是，先识别出一个token，然后再继续寻找下一个token左括号token：“{”保留字token、标识符token。（用函数_id()来完成）整型变量token赋值符号“:=”token冒号“:”token分号“;”token逗号“,”token加、减、乘 token除法token整数除法：“DIV” token浮点数除法：“/” token左小括号“(” token ； &amp; 右小括号“)” token点“.” tokenParser​ 语法分析，主要是分析词法分析器传过来的一个个token，分析它们之间的运算关系，即语法：它们之间的关系，即语法，用抽象语法树来表示：一个基类：AST。（后面的继承于它）一个二元操作符类：BinOp(AST)（表示加减乘除运算）","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let's Build A Simple Interpreter","slug":"Let-s-Build-A-Simple-Interpreter","permalink":"https://www.longlongqin.top/tags/Let-s-Build-A-Simple-Interpreter/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.top"}},{"title":"我的云书签","slug":"资源整合","date":"2020-03-22T16:05:49.000Z","updated":"2020-03-27T17:14:21.970Z","comments":true,"path":"archives/eaabd222.html","link":"","permalink":"https://www.longlongqin.top/archives/eaabd222.html","excerpt":"搜集学习资料&好用的工具","text":"搜集学习资料&好用的工具免费无版权图片Pixabay：https://pixabay.com/images/search/Pixabay是一个支持中文搜索的免费可商用图库。Gratisography：https://gratisography.com/Gratisography是一个免费高分辨率摄影图片库，所有的图片都可以用于个人或者商业用途，每周更新图片你只需要点击即可下载。Unsplash：https://unsplash.com/每天更新一张高质量的图片素材，全是生活中的景象作品，清新的生活气息图片。Pexels：https://www.pexels.com/根据英文关键词搜索图片，还能根据不同颜色分类查找，匹配的图片复古自带滤镜，风格简约，图片质量很高，素材丰富。VisualHunt：https://visualhunt.com/可以通过颜色来查找图片。Photock：https://www.photock.jp/天空、水、河、海、草坪、火、山、动物、建筑、夜景、日本景点、日本历史文化图片等等。pngimg：http://pngimg.com/全部都是无背景图片，非常适合那些需要png透明底配图的。而且它分类也很细，找起来方便。Foodiesfeed：https://www.foodiesfeed.com/专注于美食的图片网站，高清无水印，根据分类选择匹配关键词。Everypixel：https://www.everypixel.com/Everypixel 是一款帮助用户寻找免费图片素材的搜索引擎，选择免费或付费，利用AI和图片分析技术筛选图片，并查看图片来源网站。https://www.howtostartanllc.org/free-stock-photos/这是一个汇总了很多个免费图片网站的导航。写作插件编辑器135编辑器：一款强大的微信公众号文章排版 https://www.135editor.com/插件壹伴：壹伴运营神器_新媒体小编最喜欢的微信排版工具 https://yiban.io/云同步备份功能坚果云：https://www.jianguoyun.com/可以实现本地与云端实时同步，还带有历史版本回退功能。缺点：每月上传只有1G容量，只能同步体积较小的文件。亿方云：https://www.fangcloud.com/可以实现本地与云端实时同步，还带有历史版本回退功能。功能和坚果云类似。学习0.0 各科目知识点总结技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计、Java、Python、C++ 【备用链接】准备秋招，欢迎来树上取果实《互联网面试笔记》收集和分析互联网常见面试题，并将这些面试知识整理成文方便大家查阅。主要是面向java程序员，但基础知识部分不同语言程序员(c,c++,python等）都可以参考0.1 编程相关书籍英文版中文版1. 数据结构资料github中：https://github.com/xiufengcheng/DATASTRUCTURE工具Visualgo：可视化的观察数据结构的操作旧金山大学David Galles可视化演示(JS)：http://www.cs.usfca.edu/~galles/visualization/Algorithms.html2. learn OpenGL中文教学网址：https://learnopengl-cn.github.io/intro/3. C/C++学习路线：C++学习进阶","categories":[],"tags":[{"name":"forme","slug":"forme","permalink":"https://www.longlongqin.top/tags/forme/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.top"}},{"title":"凸包总结","slug":"学习笔记/计算几何/Convex-Hull/凸包总结","date":"2020-03-22T08:08:18.000Z","updated":"2020-03-23T08:39:43.485Z","comments":true,"path":"archives/bf113a1c.html","link":"","permalink":"https://www.longlongqin.top/archives/bf113a1c.html","excerpt":"","text":"凸包的相关“test”测试一些定义：凸包[Convex Hull]：简单理解为将很多钉子围住的“皮筋”。极点(Extreme Point)：有一个点集S。如果存在通过点P的直线L，使得点集S中除了点P之外的其他的点都在这个直线的同一侧，则这个点P就是极点(Extreme Points)。极边(Extreme Edge)：两个极点连成的边，剩余的所有点均会在该边的一侧。To-Left TestTo-Left测试是相对于另外这两个点所确定的那条有向直线而言的，任何一条有向直线不仅会把平面分成两部分，我们还可以知道哪一边是左边，哪一边是右边。To-Left，其实就是说这个点相对于刚才的那条有向线而言到底是位于它的左侧(就是true)，还是右侧(就是false)。这里用到了行列式来求三角形面积（请看下面手写证明）。下图中的这个行列式实际上算的是它的”面积(指：有向面积）”的两倍。12345678910bool ToLeft (Point p, Point q, Point s) //判断点s对于线段pq的位置&#123; return Area2(p,q,s);&#125;int Area2(Point p, Point q, Point s)&#123; return p.x*q.y - p.y*q.x + q.x*s.y - q.y*s.x +s.x * p.y - s.y *p.x;&#125;行列式来求三角形面积的证明：图片来源于：https://zhuanlan.zhihu.com/p/35543479In-Trangle Test其实这个算法就是判断点是否在三角形内部。这个测试最直接的理解为：使用了三次To-Left Test，三角形有三条边，所以每一条边都测试一次：三次To-Left Test结果相同的（均为true或者是false），则证明在三角形内部。三次结果中有一次不相同，则证明在三角形外部。判断极边123456789101112 //判断极边的核心void checkEdge(Point S[], int n, int p, int q)&#123; bool lEmpty =TRUE, REmpty = TRUE; for( int k=0; k&lt;n&amp;&amp;(LEmpty||REmpty); k++) &#123; if (k!=p &amp;&amp; k!=q) ToLeft(S[p], S[q], S[k]) ? LEmpty=FALSE: REmpty=FALSE; &#125; if(LEmpty || REmpty) S[p].extreme =S[q].extreme= TRUE;&#125;in-convex-polygon test判定待定点是否位于某多边形内部（in-convex-polygon test）实现的方法就是：按一定方向（约定为逆时针）凸包的每条边和待定点做ToLeft test，一旦有一次test为false就说明改点在凸包外面。构造凸包的方法1 利用极点法123456789101112131415void extremePoint (point S[], int n)&#123; for(int s=0; s&lt;n; s++) S[s].extreme = TRUE; for(int p=0; p&lt;n; p++) for(int q=p+1; q&lt;n; q++) for(int r=q+1; r&lt;n; r++) for(int s=0; s&lt;n; s++) &#123; if(s==p || s==q || s==r ||!S[s].extreme) continue; if(Intriangle(S[p],S[q],S[r],S[s])) S[s].extreme = FALSE; &#125;&#125;时间复杂度：O(n^4)2 利用极边法1234567891011121314151617181920void markEE（point S[], int n）&#123; for (int k=0;k&lt;n;k++) //将所有点的初始状态都设置成：非极点 S[K].extreme = FALSE; for (int p=0; p&lt;n; p++) //遍历每条边，看他是否是极边 for(q=p+1; q&lt;n; q++) checkEdge(S,n,p,q) //判断极边的核心&#125; //判断极边的核心void checkEdge(Point S[], int n, int p, int q)&#123; bool lEmpty =TRUE, REmpty = TRUE; for( int k=0; k&lt;n&amp;&amp;(LEmpty||REmpty); k++) &#123; if (k!=p &amp;&amp; k!=q) ToLeft(S[p], S[q], S[k]) ? LEmpty=FALSE: REmpty=FALSE; &#125; if(LEmpty || REmpty) S[p].extreme =S[q].extreme= TRUE;&#125;时间复杂度：O(n^3)3 incremental construction（增量构造）详细讲解：https://www.longlongqin.top/archives/7c53.html该算法的核心步骤就是：复杂度 O(n^2)判定新加入点与凸包的位置关系：用in-convex-polygon testin-convex-polygon test在上面有讲向凸包插入新点：support-line如上面的点x，如何插入现有凸包当中呢？插入过程：插入过程其实就是寻找两个连接点s和t，然后将新点x与t、s分别连接得到新的凸包。t、s两个点将原凸包的边界分成两部分：st和ts两个邮箱线段。构造新凸包就要保留远端st，舍弃近端ts。取代ts的是x和s、t的连接线xt和xs。其中xt、xs被称为切线（tangent）或者support line（支撑线）。（配合下图理解）现在就是如何找到t、s这两个点？在凸包上任取一点v，按逆时针方向v点会有一个直接前驱点和直接后继点。考察有向直线xv与点v直接前驱和直接后继的位置关系（两次to left test），记为一个pattern表。【结果无非是四种情况：v的直接前驱和直接后继相对于有向直线xv的位置是RL，LR，LL，RR。例如上图黄色点v，是R和L；蓝色点v分别是L和R。实际上凸包边界st上所有点的pattern都为RL，ts上所有点的pattern都为LR。关键点在于：点S的pattern是LL，点t的pattern为RR。】说了这么多，其实我们可以将上面的两步合为一步：对于每个待定点x，不必特意去考虑它与凸包的位置关系，而是遍历凸包上每一个点。对于凸包边界上的每一个点，我们都能通过两次to left test迅速判断出pattern。对于x位于凸包外部的情况，经过遍历凸包的点，我们很容易就能得到s和t的位置，得到两条support line，从而构造出新的凸包；而对于x位于凸包内部的情况，凸包边界每个点都不可能出现RR或LL的情况，直接舍弃x即可。4 Jarvis March详细讲解：https://longlongqin.top/archives/9c7f.html又称：Gift Wrapping算法步骤：初始化所有点，设置点集的初态为 非极点找到开始的第一个极点：用LTL方法寻找下一个极点：用ToLeft test寻找下一个极点循环步骤3，直到找到所有极点也就是：首先从任何一个极点（用LTL确定）开始，然后找到一条以这个极点为端点的极边。然后沿着这个极边的另一个端点（endpoint）出发，再找出下一条极边。如此反复操作，最终会找到一条以最初极点为endpoint的极边，得到一个封闭的环，凸包也构造完成。123456789101112131415161718192021222324252627282930313233int LTL(Point S[], int n) //寻找最下and最左的点作为第一个极点&#123; int ltl = 0; for (int k=1; k&lt;n; k++) &#123; if(S[k].y &lt; S[ltl].y || (S[k].y==S[ltl].y &amp;&amp; S[k].x&lt;S[ltl].x) ) ltl = k; &#125; return ltl;&#125;void Javis (Point S[], int n)&#123; for (int k=0; k&lt;n; k++) S[k].extreme=FALSE; //1.将所有点标记为非极点 int ltl = LTL(S, n); //2.找到ltl int k = ltl; do &#123; S[k].extreme = true; int s = -1; //要找的下一个极点用s表示 for (int t=0; t&lt;n; t++) &#123; if (t!=k &amp;&amp; t!=s &amp;&amp; ( s==-1 || !ToLeft(S[K],S[s],S[t]) ) ) s = t; &#125; S[k].succ = s; //新的极边确定 k = s； //更新k的值，变为下一次查找的边的起点 &#125; while(k != ltl) //如果循环回到了原来的点，则结束&#125;复杂度：Jarvis March算法算法的复杂度更准确的表示为O(nh)。h（凸包边界的点的个数）又由最终输出结果，即凸包本身来决定，输出结果决定了构造过程的复杂度，这就是所谓的“输出敏感性”。这种类型的算法又被称为output sensitive algorithm。这种特性在其它凸包算法中也会体现。5 Graham Scan详细讲解；https://longlongqin.top/archives/3478.html算法流程：预排序(presorting)：即找到某个基准点，然后将其余所有的点按照相对于基准点的极坐标排序。它主要做了三个事情：1、找出基准点：用lowest-then-leftmost point（LTL），然后对其他点按照极坐标排序：根据极角排序的方法，在：（https://longlongqin.top/archives/510d.html#补：根据极角排序）2、找出起始边：从排好序的点集，选取前两个点，就是起始边。3、将起始边 与 剩下的n-2条边分别存储在不同的栈(stack)中：如下图Scan扫描这一步是算法的核心。scan的过程主要关注三个点：栈S的栈顶（S[0]）、次栈顶（S[1]）和栈T的栈顶（T[0]）。也就下图红色标注的三个点：可以观察到，每次待处理的S[0]和S[1]构成的边一定是一条极边（如上图点1和点2），算法关键步骤就是对边这条极边和T[0]做to left test，判断T[0]位于边S[0]S[1]的左边还是右边。若在左边则继续拓展，若在右边则否定掉此前认定的极边。无论结果如何，每次判定都会将问题规模缩小一个单元，算法结束时T最终肯定为空。T空后，S中存留下的点正是凸包的极点，这些点自底而上正是凸包边界点的逆时针遍历，也得到了整个凸包构造问题的解。复杂度：Graham Scan算法复杂度由三部分决定：persorting，采用一般排序算法，复杂度是O(nlogn)逐步迭代，O(n)：算法一步步纳入新点，会迭代n步。scan，O(?)所以算法的总体复杂度：O(nlogn + n * ?) ，可见scan的复杂度决定了算法总体的复杂度。算法一步步纳入新点，会迭代n步。但是在每个点上都有可能做回溯操作，所以scan的复杂度是不确定的。我们来以上图最坏情况为例，到第8个点时判定为false，舍弃点7，回溯。下一步判断也为false，舍弃点6，回溯。如此回溯直到算法开始的点2。这次scan倒退了高达O(n)个点，如果每次scan都是如此那么算法整体复杂度就为：O(nlogn + n * n) = O(n^2)了，那这种算法的意义也就不大了。其实上述分析并非错误，只是不够精确。O(n^2)确实是Graham Scan算法的一个上界，但是这个上界并不是紧的。问题就出在分析假定了每次都会出现回退高达O(n)个点。代码部分：https://longlongqin.top/archives/d4fa.html6 [Divide And Conquer]详细讲解：https://longlongqin.top/archives/f32f.html","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"凸包","slug":"凸包","permalink":"https://www.longlongqin.top/tags/%E5%87%B8%E5%8C%85/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.top"}},{"title":"读书笔记","slug":"程序员练级攻略2018","date":"2020-03-21T17:42:57.000Z","updated":"2020-03-26T16:34:15.862Z","comments":true,"path":"archives/7b67faab.html","link":"","permalink":"https://www.longlongqin.top/archives/7b67faab.html","excerpt":"","text":"陈皓——程序员练级攻略提及的书籍&amp;手册等书籍列表：https://github.com/git-zjx/programmer_training_strategy","categories":[],"tags":[],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.top"}},{"title":"hexo中插入pdf","slug":"Hexo博客搭建/hexo中插入pdf","date":"2020-03-20T19:10:35.000Z","updated":"2020-03-26T06:50:37.485Z","comments":true,"path":"archives/448ac7f1.html","link":"","permalink":"https://www.longlongqin.top/archives/448ac7f1.html","excerpt":"法1：安装hexo-pdf插件法2：利用html语法：可以轻松设定尺寸why? 我的本地浏览成功。但在线上却是一片空白。希望只有我一个人是这样吧","text":"法1：安装hexo-pdf插件法2：利用html语法：可以轻松设定尺寸why? 我的本地浏览成功。但在线上却是一片空白。希望只有我一个人是这样吧安装hexo-pdf插件hexo-pdfHexo tag for embeded pdfInstall1$ npm install --save hexo-pdfNormal PDFpdf链接1&#123;% pdf http:&#x2F;&#x2F;7xov2f.com1.z0.glb.clouddn.com&#x2F;bash_freshman.pdf %&#125;本地（我的失败了，还没找到原因）1&#123;% pdf .&#x2F;bash_freshman.pdf %&#125;Google drive1&#123;% pdf https:&#x2F;&#x2F;drive.google.com&#x2F;file&#x2F;d&#x2F;0B6qSwdwPxPRdTEliX0dhQ2JfUEU&#x2F;preview %&#125;Slideshare1&#123;% pdf http:&#x2F;&#x2F;www.slideshare.net&#x2F;slideshow&#x2F;embed_code&#x2F;key&#x2F;8Jl0hUt2OKUOOE %&#125;示例：图片来源于网络利用html语法首先修改_config.yml文件将_config.yml中的post_asset_folder选项置为true1post_asset_folder: true关于这个选项的功能说明如下:当您设置post_asset_folder为true参数后，在建立文件时，Hexo会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。然后新建一篇文章1$ hexo new由于上一步已经将post_asset_folder选项设为了true所以这一步新建文章时会创建一个md文件和一个同名的文件夹为了方便叙述，我用test作为文件和文件夹名编辑test.md用vim或者别的编辑器打开test.mdtest.md文件中加入如下代码&lt;object data=&quot;./test/test.pdf&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;关于这句代码简单的解释data表示你要上传的pdf的路径,使用相对路径，将你要上传的pdf放入第二步生成的test文 件夹type和width就不说了，这里注意height不能设成100%，不然太矮了，显示效果不好可以用浏览器预览，通过F12预估一下高度。我最后代码如下，供参考&lt;object data=&quot;https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/PDF/Google_Cpp_Style_guide_CN.pdf &quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;877px&quot;&gt;这里不一定非用object标签，embed、iframe标签也一样具体参考:网页链接注意：用html方法，在我的主题中，如果它后面有文字，会显示不出来，原因不详。所以实例我放在文章底部展示了参考文章hexo-pdf官方教程hexo中插入pdf解决方法相关文章theme-hexo-pdf使用技巧—-解决hexo-pdf文件显示不全的问题","categories":[{"name":"hexo博客搭建","slug":"hexo博客搭建","permalink":"https://www.longlongqin.top/categories/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"hexo显示pdf","slug":"hexo显示pdf","permalink":"https://www.longlongqin.top/tags/hexo%E6%98%BE%E7%A4%BApdf/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.top"}},{"title":"LearnCpp chapter1","slug":"C&C++/LearnCpp-chapter1","date":"2020-03-18T15:35:37.000Z","updated":"2020-03-28T08:30:13.632Z","comments":true,"path":"archives/a0a78e77.html","link":"","permalink":"https://www.longlongqin.top/archives/a0a78e77.html","excerpt":"LearnCpp-chapter1https://www.learncpp.com","text":"LearnCpp-chapter1https://www.learncpp.com0.5 介绍compiler, linker, and librariesStep 4: Compiling your source code为了编译C++程序，我们需要一个编译器。编译器主要是对每一个.cpp文件做两件事情：它检查你的代码是否符合C++的规则。如果不符合，就会报错（同时返回相应的行号）来帮助你确定什么需要修改，同时停止编译它将C++源代码翻译成机器代码文件（叫做：object file）。object file的名字通常是这种形式：name*.o* 或者 *name.obj***（其中name与.cpp文件的name是对应的）。例如：下面的三个.cpp的源文件，编译之后形成：Step 5: Linking object files and libraries编译器compiler **编译完成后，生成若干的 object files。接下来就需要链接器Linker**出马了。linker的工作主要有三方面：将所有的object files（编译之后生成的）合并成为一个可执行程序executable program此外，linker还可以链接库文件library files（library files是一个已经预编译好的代码经过“打包”，在其他程序中重用）C++有有一个扩充的库，叫做：标准库C++ Standard Library。它提供额外的功能性库，比如我们常用的iostream library你可以有选择性的去链接其他库，比如当你想写一个播放声音的程序。你肯定不想从头到尾的去写如何去读取文件、检查文件是否有效….. 这时候，我们只需要下载相关的库进行利用就方便很多了。连接器会确保所有的跨文件依赖项都正确的解析了。例如：如果你在一个.cpp文件中定义了”A”，然后在另一个.cpp文件中去使用”A”。linker就会将这两个文件联系起来。如果链接不成功，就会报错并且连接终止只要linker成功的完成所有的“object files 和 libraries ”的链接工作，你就会得到一个可执行文件，然后你就可以运行它。Makefile【注】有些开发环境使用Makefile，它是一个描述如何构建一个程序的文件（哪一个文件要编译&amp;链接，或者以不同方式处理）它是一个强大的工具。但是在本系列课程我们不回去讲解它。Steps 6 &amp; 7: Testing and Debugging如果你的可执行程序没有按照预期的工作，那么你就需要调试。Integrated development environments (IDEs)【note】step3、4、5、7（editor, compiler, linker, debugger）都是需要软件的。当然，你可以每一部分都是用独立的软件，但是有这样的一个软件包：integrated development environment (IDE)集成开发环境 将上面四步一体化。0.6 compling your first programConsole projects控制台项目没有graphical user interface (GUI)图形用户界面，它在控制台中打印text，从输入设备键盘读取信息。并且被编译成独立的可执行文件。Workspaces / solutions当创建一个项目时，许多IDE会自动给这个项目创建一个 “workspace” 或 “solution” 。workspace or solution：是一个可以容纳多个相关的项目的container。（例如，你正在写一个游戏，你想有一个单人 与 多人分开的可执行文件，那就需要创建两个项目。但是将这两个项目分开始没有意义的，因为它们属于同一个游戏的。所以，最好的就是每一个都被配置为单个工作空间/解决方案中的 一个单独项目。）0.8 C++中常见问题General run-time issues当执行程序时，控制台窗口闪烁，然后立即关闭？1、首先确保下面的这几行在你的源程序的最上部（visio studio 用户，请确认如果有 #include “pch.h” or #include “stdafx.h” ，那么让它在最顶顶顶部的）12#include &lt;iostream&gt;#include &lt;limits&gt;2、在main()函数中的结束部分（但要在return 语句之前）添加如下：12345std::cin.clear(); // reset any error flagsstd::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n'); // ignore any characters in the input buffer until we find an enter characterstd::cin.get(); // get one more char from the user避免使用：system(&quot;pause&quot;) 因为它只能在特定的操作系统中使用运行程序，得到窗口，但没有输出？有可能是你的xx安全管家等拦截的。试着关闭它们，然后重新运行程序编译成功，但是没有正确工作？去debug它General compile-time issues当编译程序时，得到一个未解析的外部符号：_main or _WinMain@16 ？说明你的编译器找不到main()函数。Visual Studio issues使用Microsoft Visual c++进行编译时，得到C1010 fatal error，并且伴随着提示信息，如：”c:\\vcprojects\\test.cpp(263) :fatal error C1010: unexpected end of file while looking for precompiled header directive”答：这种问题出现在：当microsoft visual c++编译器被设置为使用预编译头文件，但您的c++代码文件中有一个(或多个)没有将#include “stdafx.h” or #include “pch.h”作为代码文件的第一行。建议：在创建项目时，将预编译头 precompiled headers选项关闭。如果您希望保持打开预编译头文件，要修复这个问题，只需找到产生错误的文件(在上面的错误中，test.cpp是罪魁祸首)，并在文件的最顶部添加以下行:#include “pch.h”或者#include “stdafx.h”【老版本的VS使用“stdafx.h” ，当其中一个不起作用，可以换成另外一个】注意，每一个C++文件都是从这一行开始的。如果不想从这一行开始，那就在创建项目的时候关闭“预编译头文件”选项出现错误：“1MSVCRTD.lib(exe_winmain.obj) : error LNK2019: unresolved external symbol _WinMain@16 referenced in function “int __cdecl invoke_main(void)” (?invoke_main@@YAHXZ)”答：您可能已经创建了一个Windows图形化应用程序，而不是控制台应用程序。重新创建项目，并确保将其创建为Windows(或Win32)控制台项目。0.9 配置编译器:“生成（build）”配置debug configuration ：可以帮助你调试你的程序，而且也是IDE默认的。但是它会关掉所有的优化，包含调试信息（这会让你的项目变得很大、很慢）。release configuration：当你将你的程序发布给公众的时候使用release模式。这个模式会优化项目的大小和它的性能，而且不会包含额外的调试信息。所以这种模式适用于：测试你的代码的性能.0.10 配置编译器:编译器扩展c++标准定义了关于程序在特定环境下应该如何表现的规则。在大多数情况下，编译器将遵循这些规则。然而，许多编译器实现自己对语言的更改，通常是为了增强与该语言的其他版本(例如C99)的兼容性，或者是出于历史原因。这些特定于编译器的行为称为编译器扩展（Compiler extensions）。编写使用编译器扩展的程序允许你编写与c++标准不兼容的程序。使用非标准扩展的程序通常无法在其他编译器上编译(这些编译器不支持相同的扩展)，或者即使它们支持，也可能无法正确运行。注意，编译器扩展通常是默认启用的，这对初学者是不友好的，因为它会让初学者觉得某些行为是符合官方C++的标准，但是实际上是因为编译器只是过于宽松。因为，编译器扩展从来都不是必须的，如果开启可能让你误以为你写的代码是符合C++标准的。所以，建议，建议关闭编译器扩展。0.11 配置编译器:warning和error出现error提示：说明你写的代码可能不符合C++语言的标准。出现warning提示：说明编译器认为你的代码的某些地方可能有些错误，但是编译器不能百分百确定。好习惯：不要让warning提示堆积，要尽你所能的去解决warning提示。在大多数情况下出现的warning是需要我们尽量去解决的。但在极少数情况的warning提示，我们需要明确告诉编译器不要产生这个警告。C++官方不支持这样，但是有很多单独的编译器（如：visio studio xx 和GCC）会提供解决方案：利用不可移植 # pragma 指令 来暂时的关闭这个警告。好习惯：将你的经高级别调到最大，特别是在你学习的时候，他会帮你识别潜在的问题。将warnings视为errors如果在你学习的时候，最好告诉编译器让它把warning当做error对待，然后你就不得不去解决出现的warning了。0.12 配置编译器: 选择一个C++标准C++的标准有很多，如：C++98, C++03, C++11, C++14, C++17, 等. 通常情况，编译器的标准都是默认的，而不是最新的C++标准。如果你想使用指定的标准版本，需要手动设置。正在制定中的标准的名字有一些语言标准是按照他最终定案时候的年份（如，C++17是在2017年完成的）。但是，当一个新的语言标准正在制定ing的时候，我们不能确定它最终完成的时间。这个时候这个语言标准的名字 将会被最终完成时候的名字替代，（如，C++11在制作ing时，名字为C++1x，当最终完成的时候“C++1x”就会被替换），比如下面的一些：c++1x = C++11c++1y = C++14c++1z = C++17c++2a = C++20所以，如果你看见C++1Z，这就代表C++17【注意】：在VS xxxx系列的IDE中，是不能设置全局的语言标准的，你只能一个一个项目的去设置1.1 语句与程序结构Statements and the structure of a program语句语句(Statements)是一种指令类型，它使程序执行某些操作。它是最小的独立计算单元。在C++中，一个单独的语句就可能会被编译成很多机器语言指令。下面列出了很多种语句：Declaration statements(声明语句)Jump statements（循环语句）Expression statements（表达式语句）Compound statements（复合语句）Selection statements (conditionals) (条件语句)Iteration statements (loops) （循环语句）Try blocks函数与main函数函数是按照顺序执行的语句集合。每一个C++程序都必须要有一个main函数。一个程序开始执行的时候，开始于main函数中的第一条语句，然后按照顺序执行余下语句。说到函数，你可能会看到main() 或者 doSomething()，后面的括号其实起了一个说明作用。这个括号就说明他前面的那个字符是一个函数的名字。分析“hello world”1234567#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; \"Hello world!\" return 0;&#125;第一行：一个预处理指令。这个预处理器指令指示，我们希望使用iostream库的内容，它是c++标准库的一部分，允许我们从控制台上读写文本。我们需要这一行以便在第5行上使用std::cout。排除这一行将导致第5行出现编译错误，因为编译器不知道std::cout是什么。第2行是空的，编译器会忽略它。这一行的存在只是为了帮助使程序对人类更具可读性(通过分隔#include预处理指令和程序的后续部分)。第3行告诉编译器我们要编写(定义)一个名为main的函数。每个c++程序必须有一个主函数，否则它将无法编译。第4行和第7行告诉编译器哪些行是主函数的一部分。第4行上的左大括号和第7行上的右大括号之间的所有内容都被认为是主函数的一部分。这叫做函数体第5行是main函数中的第一个语句，也是运行程序时执行的第一个语句。cout(代表“字符输出”)和&lt;&lt;操作符允许我们将字母或数字发送到要输出的控制台。在本例中，我们向它发送文本“Hello world!”，将输出到控制台。此语句创建程序的可见输出。第6行是一个返回语句。当可执行程序完成运行时，程序将一个值发送回操作系统，以指示它是否成功运行。按照惯例，这个特殊的return语句将0的值返回给操作系统，这意味着“一切正常!”这是执行的程序中的最后一条语句。结尾，什么是C++ 标准库？答：一个标准库文件是一个 预编译代码的集合，它被“打包”起来，以供其他程序重用。1.2 注释正确的注释：At the library, program, or function level, use comments to describe what.Inside the library, program, or function, use comments to describe how.At the statement level, use comments to describe why.1.3 — Introduction to variablesdata：数据data就是可以被电脑移动、存储、处理的任何信息。计算机上的数据通常以一种便于存储或处理的格式存储(因此人类无法读懂)，这种格式就是：二进制（binary）Objects and variables：对象和数据RAM(random access memory)：随机存取存储器。在程序中，你可以把RAM看作一列邮箱，它可以在程序运行时存储数据。存储在内存中的单个数据，称为value在C++中，不允许直接访问内存。但可以通过object来访问内存。一旦创建object，编译器就自动的决定这个object存放在内存中的位置。object：是具有value和其他相关属性的存储区域。这样，我们就可以说，获取这个object的value，编译器直到这个value存储在内存的具体位置。也就是说，我们可以只关注使用object(对象)来存储和检索value，而且不用担心它在内存中的存储位置。object(对象)可以命名也可以不命名。有名字的object叫做：variable(变量)。这个object的名字，叫做：标识符(identifier)。在一般编程中，对象通常指内存中的变量、数据结构或函数。在c++中，“对象”的定义较窄，将函数排除在外。Variable instantiation：变量实例化为了创建一个变量，需要用一种特殊的声明：定义1int x; // define a variable named x, of type int在编译时，当编译器看到这个语句，它会告诉自己我们需要定义一个变量，变量名字叫x，类型为int。从此之后，只要编译器看到标识符x，它就知道我们在引用这个变量。程序运行时(称为：runtime)，该变量将会被实例化。变量在用来存储values之前，必须要先实例化。实例化：对象(object)将会被创建，并且会分配一个内存地址。为了便于举例，假设变量x是在内存位置140处实例化的。当程序使用变量x时，它将访问内存位置140中的值。实例化的对象有时也称为实例。Data types：数据类型Data types(更通用的称呼：type)：它告诉编译器变量将会存储什么类型的value在c++中，变量的类型必须在编译时(当程序被编译时)已知，如果不重新编译程序，就不能更改该类型。这意味着一个整型变量只能包含整型值。如果希望存储其他类型的值，则需要使用不同的变量。SummaryData is any sequence of symbols (numbers, letters, etc…) that can be interpreted to mean something.A value is a single piece of data stored in memory.【值是存储在内存中的单个数据块。】A variable is a named region of memory.【变量是一个命名的内存区域。】An identifier is the name that a variable is accessed by.【标识符是变量被访问的名称】A type tells the program how to interpret a value in memory.【类型是告诉程序如何解释内存中的值】1.4 变量赋值与初始化定义变量：12int x; // define an integer variable named xint y, z; // define two integer variables, named y and z变量赋值：12int width; // define an integer variable named widthwidth = 5; // copy assignment of value 5 into variable width初始化变量：(定义&amp;赋值同时进行)1int a = 1; //初始化变量a为1C++初始化变量的形式有三种：使用“=” copy initialization1int width = 5; // copy initialization of value 5 into variable width使用括号“()” direct initialization 【这种在一些高级数据类型上，性能较好】1int width(5); // direct brace initialization of value 5 into variable width (preferred)使用大括号“{}” Brace initialization(uniform initialization)[推荐这种]这种可以用于对象初始化一系列的数据123/*推荐第一种形式*/int width&#123; 5 &#125;; // direct brace initialization of value 5 into variable width (preferred)int height = &#123; 6 &#125;; // copy brace initialization of value 6 into variable height另外，空初始化：用空的花括号对数据进行Zero initialization。它表示对该变量初始化为0，或者为空。1int width&#123;&#125;; //zero initialization to value 0对于上述三种初始化方法，看一下下面的例子：1234567891011121314#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 1.2; int b(2.8); int c&#123; 3.1 &#125;; cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; endl; cin.clear(); cin.ignore(numeric_limits&lt;streamsize&gt;::max(), '\\n'); cin.get();&#125;运行结果：从运行结果可以看出，第1和2种方法只会基于“警告”，它们运行结果就是只把整数部分初始化给响应变量；而第三种就直接提示“出错”。变量初始化是很有必要的。如果不初始化，编译器可能报错的ヾ(≧O≦)〃嗷~1.5介绍输入输出流：cout cin endlstd::endl 与 ‘\\n’使用’\\n’的效率比std::endl高。因为：std::endl做两件事：1、将光标一刀下一行；2、它“刷新”输出(确保它立即显示在屏幕上)‘\\n’只做一件事：1、将光标一刀下一行；&lt;&lt; 、&gt;&gt;&lt;&lt;： insertion operator (&lt;&lt;)&gt;&gt;： extraction operator (&gt;&gt;)1.6 未初始化&amp;未定义初始化、赋值、未初始化：不像其他语言，C/C++在定义的时候，不会自动的给变量赋值(比如说 0)。所以说，如果一个变量被编译器分配到一个内存地址，如果他没有被人为的赋值，它默认的值就是这个内存地址原来存储的值（也叫“垃圾值”）。Initialization = 在对象被定义的同时给它赋值；Assignment = 在对象被定义之后，再赋值给它；Uninitialized = 对象只是被定义，但是还没有被赋值。所以，我们应该记住要初始化对象（因为现在，初始化对象的成本与带来的好处相比，成本不值一提）。不初始化对象，可能会出现无法预料的错误。未初始化行为，可能带来以下症状：程序每次运行都会有不同的结果；程序每次运行都会出现一个相同的错误结果；程序结果不稳定：有时结果正确，有时结果是错误的；程序似乎工作，但是稍后的结果不正确；程序崩溃；程序可以在一些编译器上运行，但在其他编译器中不能运行；1.7 关键字&amp;标识符关键字：C++17中的关键字（keywords 或者 reserved words）有84个关键字。标识符：变量、函数、类、模块、或任何其他用户自定义项目的 的名字 叫做：标识符。命名规则：标识符名字不能和保留字重名；标识符只能由字母、下划线、数字；标识符必须以 字母 或 数字 开头（“以下划线开头”的一般都是操作系统的保留字；库，或者是编译器使用的）；C++对大小写敏感，所以wa和WA和Wa和wA互不相同。1.8 常量&amp;操作符常量(literal，literal constant)：是一个已直接插入源代码的固定值。常量与变量都有一个value（和一个type）。但是，常量的值不可更改。操作符(Operators)：在数学中，操作是一种数学计算，包括0个或多个输入值(称为操作数operands)，它们产生一个新值(称为输出值)。要执行的特定操作由一个称为操作符的结构(通常是一个符号或一对符号)表示。操作符分为三类：一元操作符(Unary operators)：只有一个操作数；二元操作符(Binary operators)：有两个操作数（左边、右边各一个）；三元操作符(Ternary operators)：有三个操作数。在C++中只有一个三元操作符。1.9 表达式表达式与语句的区别？当我们需要程序执行某个操作时，使用语句；当我们需要程序计算有一个值的时候，使用表达式。表达式、语句、表达式语句？123int x; //语句不含表达式int x=5; //语句包含表达式x=5; //表达式语句总结chapter 1语句(statement)：是一种指令，它通常使程序执行某些操作，语句以分号（semicolon）结尾。预处理指令(Preprocessor directives)：告诉编译器执行一种特殊任务。在本章中，用到的是”#include &lt;iostream&gt;“","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.longlongqin.top/tags/C/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.top"}},{"title":"Let’s Build A Simple Interpreter-9","slug":"学习笔记/Let's Build A Simple Interpreter/LSBASI-9","date":"2020-03-18T06:44:30.000Z","updated":"2020-03-24T13:24:19.190Z","comments":true,"path":"archives/8632918.html","link":"","permalink":"https://www.longlongqin.top/archives/8632918.html","excerpt":"今天要学习的内容：如何parse and interpret 一个Pascal程序的定义 definition如何parse and interpret 复合语句compound statements如何parse and interpret 赋值语句(包括变量)assignment statements, including variables.介绍符号表，以及如何存储和查找变量。","text":"今天要学习的内容：如何parse and interpret 一个Pascal程序的定义 definition如何parse and interpret 复合语句compound statements如何parse and interpret 赋值语句(包括变量)assignment statements, including variables.介绍符号表，以及如何存储和查找变量。原文链接：https://ruslanspivak.com/lsbasi-part9/本节源代码：https://github.com/rspivak/lsbasi/tree/master/part9/python下面是一个简单的 Pascal程序，来介绍新概念：123456789BEGIN BEGIN number := 2; a := number; b := 10 * a + 10 * number / 4; c := a - - b END; x := 11;END.今天所学内容与前面的part1~8相比有了很大的飞跃，现在不再是像以前一样只是一个计算器了。我们要提升一下档次了😊新的语法树及规则现在，来看看新语言结构的语法树syntax diagrams 以及其对应的语法规则grammar rules)pascal语法一个Pascal语法由一下组成&lt;这不是完整的定义，会在后面文章慢慢扩展&gt;：BEGIN开头中间是复合语句compound statement一个点(dot) “.”结束compound statementcompound statement是一个block(区块)：它标有BEGIN 和 END ，中间可能(也可能没有)包含有一段语句或其他的复合语句compound statement所有嵌入在复合语句中的句子，除了最后一个，其他的都要以分号“;”结尾在block中的最后一个句子(last statement)可能或可能没有 中断分号“;”如下面所示：1234“BEGIN END”“BEGIN a := 5; x := 11 END”“BEGIN a := 5; x := 11; END”“BEGIN BEGIN a := 5 END; x := 11 END”statement list一个statement list 含有0个或多个语句，其位于compound statement内。如上面的例子statement一个statement可以是一个 *compound statement， 一个赋值语句assignment statement，或者是一个空语句*empty statement。assignment statement一个赋值语句的组成：一个变量 后面跟着 一个指定的token（two characters, ‘:’ and ‘=’） 后面跟着 一个表达式。如下所示：12“a := 11”“b := a + 9 - 5 * 2”varible一个 变量variable是一个标识符identifier。我们将用ID token来表示variables，这个token的value是变量的名字(如，‘a’、‘number’、‘x’…..)。在下面的一个block的代码中的‘a’、‘b’就是变量：1“BEGIN a := 11; b := a + 9 - 5 * 2 END”empty statement一个空语句表示一个语法规则，这个语法规则没有更深层的产生式productions。我们使用empty_statement语法规则来描述语法分析中末尾的statement_list ；同时也允许一个空的复合语句compound statements表示为：‘BEGIN END’factorfactor的规则更新为处理变量。完整的语法1234567891011121314151617181920212223242526program : compound_statement DOTcompound_statement : BEGIN statement_list ENDstatement_list : statement | statement SEMI statement_liststatement : compound_statement | assignment_statement | emptyassignment_statement : variable ASSIGN exprempty :expr: term ((PLUS | MINUS) term)*term: factor ((MUL | DIV) factor)*factor : PLUS factor | MINUS factor | INTEGER | LPAREN expr RPAREN | variablevariable: ID上面的语法中，在compound_statement rule 中没有用“*”来表示重复（0或多次），而是明确的制定了 statement_list rule。这是另一种方法来表示“0或多次”的操作。这在后面的语法分析器（如PLY）会派上用场。我还将规则：“(PLUS | MINUS) factor”也细分成两个规则。修改lexer,parser,interpreter为了支持更新后的语法，我们需要修改我们的此番分析器、语法分析器和解释器。lexer的改变下面是我们此番分析器有改动的地方：为了支持Pascal程序的定义、复合语句、赋值语句、变量。我们需要新的token类型：（Pascal program’s definition, compound statements, assignment statements, and variables）BEGIN (标记复合语句的开始)END (标记复合语句的结束)DOT (一个token表示 点，用于Pascal程序的定义)ASSIGN (一个token表示两个字符， ‘:=’)在Pascal中，赋值操作符不同于其他语言（如C语言用 “=”）SEMI (一个token表示分号‘ ; ’ 。用来标记在复合语句中的一个句子的结尾)ID（一个token表示 有效的标识符。）有时候，为了区分不同token（它们都以相同的字符为开头，如：‘:’ vs ‘:=’ or ‘==’ vs ‘=&gt;’），我们需要在不消耗下一个字符的情况下去查看输入缓冲区。为了这个特殊的目的，我介绍一种查看方法peek method，这种方法将帮助我们标记赋值语句。这个方法不是必要的，但是还是想早一点介绍一下，并且它也使得get_next_token函数简洁一些。它所做的目的就是：从文本缓冲区返回下一个字符，但不增加self.pos的值。下面是这个方法的代码：123456def peek(self): peek_pos = self.pos + 1 if peek_pos &gt; len(self.text) - 1: return None else: return self.text[peek_pos]因为pascal中的 变量 和 保留字 都是 标识符。所以我们需要用一个方法来区分它们，方法为：_id。它工作的原理：词法分析器对这个字母、数字序列进行检查，看这个序列是否是保留字reserved keyword，如果是，就返回一个预先构造的token来表示这个保留字；如果不是，就返回一个新的ID token（它的值就是这个字符串）（lexeme）.下面是它的代码：1234567891011121314RESERVED_KEYWORDS = &#123; 'BEGIN': Token('BEGIN', 'BEGIN'), 'END': Token('END', 'END'),&#125;def _id(self): \"\"\"Handle identifiers and reserved keywords\"\"\" result = '' while self.current_char is not None and self.current_char.isalnum(): result += self.current_char self.advance() token = RESERVED_KEYWORDS.get(result, Token(ID, result)) return token词法分析器的函数get_next_token的改变:12345678910111213141516171819def get_next_token(self): while self.current_char is not None: ... if self.current_char.isalpha(): return self._id() if self.current_char == ':' and self.peek() == '=': self.advance() self.advance() return Token(ASSIGN, ':=') if self.current_char == ';': self.advance() return Token(SEMI, ';') if self.current_char == '.': self.advance() return Token(DOT, '.') ...parser的改变下面是它的总的变化：新的AST结点：Compound AST node：表示一个复合语句，在它的孩子的变量中包含着语句节点的列表；1234class Compound(AST): \"\"\"Represents a 'BEGIN ... END' block\"\"\" def __init__(self): self.children = []Assign AST node：表示赋值语句。它的左孩子的值是Var node，右孩子结点存储着由expr解析器返回的结点。12345class Assign(AST): def __init__(self, left, op, right): self.left = left self.token = self.op = op self.right = rightVar AST node：表示一个变量，它的value就是着这个变量的名字12345class Var(AST): \"\"\"The Var node is constructed out of ID token.\"\"\" def __init__(self, token): self.token = token self.value = token.valueNoOp node：用来表示一个空语句。如‘BEGIN END’ 是一个有效的复合语句但没有句子。12class NoOp(AST): pass我们之前讲过，在我们的递归的语法分析器中每一个语法的规则都有相应的函数(method)。这次将增加7个新的函数。这些函数都是用于语法分析中新的语法和新的AST结点。下面就是：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374def program(self): \"\"\"program : compound_statement DOT\"\"\" node = self.compound_statement() self.eat(DOT) return nodedef compound_statement(self): \"\"\" compound_statement: BEGIN statement_list END \"\"\" self.eat(BEGIN) nodes = self.statement_list() self.eat(END) root = Compound() for node in nodes: root.children.append(node) return rootdef statement_list(self): \"\"\" statement_list : statement | statement SEMI statement_list \"\"\" node = self.statement() results = [node] while self.current_token.type == SEMI: self.eat(SEMI) results.append(self.statement()) if self.current_token.type == ID: self.error() return resultsdef statement(self): \"\"\" statement : compound_statement | assignment_statement | empty \"\"\" if self.current_token.type == BEGIN: node = self.compound_statement() elif self.current_token.type == ID: node = self.assignment_statement() else: node = self.empty() return nodedef assignment_statement(self): \"\"\" assignment_statement : variable ASSIGN expr \"\"\" left = self.variable() token = self.current_token self.eat(ASSIGN) right = self.expr() node = Assign(left, token, right) return nodedef variable(self): \"\"\" variable : ID \"\"\" node = Var(self.current_token) self.eat(ID) return nodedef empty(self): \"\"\"An empty production\"\"\" return NoOp()factor 函数的修改：12345678910111213141516def factor(self): \"\"\"factor : PLUS factor | MINUS factor | INTEGER | LPAREN expr RPAREN | variable \"\"\" token = self.current_token if token.type == PLUS: self.eat(PLUS) node = UnaryOp(token, self.factor()) return node ... else: node = self.variable() return nodeparse ：更新之后，它从程序的定义开始语法的分析：123456def parse(self): node = self.program() if self.current_token.type != EOF: self.error() return node下面是一个简单的程序：123456789BEGIN BEGIN number := 2; a := number; b := 10 * a + 10 * number / 4; c := a - - b END; x := 11;END.它的解析树为（为了简洁，下面的树中变量的名字所在结点就是Var node， Assign node赋值结点表示为 ‘:=’ ）：interpreter的改变为了解释新的AST结点，我们需要在interpreter中添加相应的visitor 函数：visit_Compoundvisit_Assignvisit_Varvisit_NoOp其中，visit_Compound：遍历它的孩子节点，visit_NoOp：什么都不做。123456def visit_Compound(self, node): for child in node.children: self.visit(child)def visit_NoOp(self, node): passvisit_Assign：当我们给变量赋值时，需要将该变量的值存到某个地方，待用。这也就是此函数的功能：123def visit_Assign(self, node): var_name = node.left.value self.GLOBAL_SCOPE[var_name] = self.visit(node.right)这个函数存储了一个键-值对key-value pair（一个变量名、一个变量的值），存储在symbol table GLOBAL_SCOPE。what is symbol table?symbol table是一个抽象数据类型（abstract data type (ADT)），用于跟踪源码中各种符号。目前的符号类型还只有变量，我们用Python字典趋势线符号表的ADT。（在这里用符号字表 实现的笨拙：因为它不是一个带有特殊方法的独立类，而是一个简单的Python字典，而且它的另外职责是 内存空间。在后面的文章中，原作者将会带我们了解symbol tables的细节）让我们来看一下“a := 3;” 的AST，和它的 symbol table （visit_Assign 函数处理前和处理后的）：现在让我们看看句子：“b := a + 7;”的AST：visit_Var：可以看出，赋值语句得到右半部分：“a + 7” 提及变量a，所以我们要先知道变量a的value，这就是visit_Var函数要干的事情：1234567def visit_Var(self, node): var_name = node.value val = self.GLOBAL_SCOPE.get(var_name) if val is None: raise NameError(repr(var_name)) else: return valvisit 一个 Var 结点：它首先得到变量的名字；然后这个变量名字作为进入GLOBAL_SCOPE dictionary的key🔑去寻找变量的value，如果找到了 就返回变量地值，如果找不到就NameError函数伺候。下面是“b := a + 7;”的AST和符号表（赋值前和复制后）上面就是今天所有需要进行的update了。At the end of the main program, we simply print the contents of the symbol table GLOBAL_SCOPE to standard output.Let’s take our updated interpreter for a drive both from a Python interactive shell and from the command line. Make sure that you downloaded both the source code for the interpreter and the assignments.txt file before testing:Launch your Python shell:123456789101112131415161718192021$ python&gt;&gt;&gt; from spi import Lexer, Parser, Interpreter&gt;&gt;&gt; text &#x3D; &quot;&quot;&quot;\\... BEGIN...... BEGIN... number :&#x3D; 2;... a :&#x3D; number;... b :&#x3D; 10 * a + 10 * number &#x2F; 4;... c :&#x3D; a - - b... END;...... x :&#x3D; 11;... END.... &quot;&quot;&quot;&gt;&gt;&gt; lexer &#x3D; Lexer(text)&gt;&gt;&gt; parser &#x3D; Parser(lexer)&gt;&gt;&gt; interpreter &#x3D; Interpreter(parser)&gt;&gt;&gt; interpreter.interpret()&gt;&gt;&gt; print(interpreter.GLOBAL_SCOPE)&#123;&#39;a&#39;: 2, &#39;x&#39;: 11, &#39;c&#39;: 27, &#39;b&#39;: 25, &#39;number&#39;: 2&#125;And from the command line, using a source file as input to our interpreter:12$ python spi.py assignments.txt&#123;&#39;a&#39;: 2, &#39;x&#39;: 11, &#39;c&#39;: 27, &#39;b&#39;: 25, &#39;number&#39;: 2&#125;If you haven’t tried it yet, try it now and see for yourself that the interpreter is doing its job properly.summary让我们来总结一下，你今天扩展了Pascal解释器的哪些部分：添加新的语法规则添加新的token，和它对应词法分析器中的方法（也更新了get_next_token）在 parser 中为新的语法结构添加新的AST结点在（递归下降的）语法分析中 添加相应对应新语法规则的新函数，在interpreter中增添了新的visitor函数新增 用于存储和查找变量的字典HACKS现在要介绍一下“hacks”（不完善的地方），并且随着系列文章的深入，我们还将一步步解决这些内容：上图中的不完善的地方，也就是这些：program 语法规则目前不完善，在后续文章会扩展；Pascal语言是一个静态类型语言，在使用变量之前必须要先声明；没有类型检测，目前还不是什么大问题。但当有更多类型的时候，就需要类型检测；符号表目前为止，都是用“/”来表示除法。但在Pascal语言中，必须要用关键字“div”来表示整数除法；在Pascal语言中，标识符 和 保留字 是不区分大小写的(case insensitive)。但是在目前的文章中，我们把它设计成了区分大小写。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let's Build A Simple Interpreter","slug":"Let-s-Build-A-Simple-Interpreter","permalink":"https://www.longlongqin.top/tags/Let-s-Build-A-Simple-Interpreter/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.top"}},{"title":"Front-matter的规则","slug":"Hexo博客搭建/Front-matter的规则","date":"2020-03-16T14:08:32.497Z","updated":"2020-03-17T08:15:54.491Z","comments":true,"path":"archives/138a.html","link":"","permalink":"https://www.longlongqin.top/archives/138a.html","excerpt":"文章写作时，的front matter 的参数","text":"文章写作时，的front matter 的参数参数描述layout布局title标题date建立日期updated更新日期comments开启文章的评论功能tags标签（不适用于分页）categories分类（不适用于分页）permalink覆盖文章网址其中，分类和标签需要区别一下，分类具有顺序性和层次性，也就是说Foo，Bar不等于Bar，Foo；而标签没有顺序和层次。注意：每个冒号后面是有一个空格的。1234567891011121314151617title: 文章的front-matter规则 // 你的博客名字 date: 2019-08-10 21:44:44 //文章创建的日期author: longlongqin //作者名字img: /medias/banner/6.jpg //文章的显示的时候的背景coverImg: /medias/banner/6.jpg top: truecover: truetoc: truepassword: mathjax: truesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要tags:- Hexo- Github- 博客categories:- 软件安装与配置配置选项默认值描述titleMarkdown 的文件标题文章标题，强烈建议填写此选项date文件创建时的日期时间发布时间，强烈建议填写此选项，且最好保证全局唯一author根 _config.yml中的 author文章作者imgfeatureImages中的某个值文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: http://xxx.com/xxx.jpgtoptrue推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章coverfalsev1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中coverImg无v1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片password无文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项toctrue是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项mathjaxfalse是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行summary无文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories无文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类tags无文章标签，一篇文章可以多个标签reprintPolicycc_by文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个注意:如果 img 属性不填写的话，文章特色图会根据文章标题的 hashcode 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。date 的值尽量保证每篇文章是唯一的，因为本主题中 Gitalk 和 Gitment 识别 id 是通过 date 的值来作为唯一标识的。如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 _config.yml 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：开源中国在线工具、chahuo、站长工具。","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.longlongqin.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"front-matter配置","slug":"front-matter配置","permalink":"https://www.longlongqin.top/tags/front-matter%E9%85%8D%E7%BD%AE/"}]},{"title":"Let’s Build A Simple Interpreter-8","slug":"学习笔记/Let's Build A Simple Interpreter/LSBASI-8","date":"2020-03-15T10:04:49.000Z","updated":"2020-03-18T06:21:29.606Z","comments":true,"path":"archives/ae12.html","link":"","permalink":"https://www.longlongqin.top/archives/ae12.html","excerpt":"今天，将要在前面的基础上，添加一元操作符unary operators：unary plus (+) and unary minus (-) operators。","text":"今天，将要在前面的基础上，添加一元操作符unary operators：unary plus (+) and unary minus (-) operators。今天将要完成的任务：扩展语法，能够处理“+”、“-”一元操作符；添加一个新的结点类：UnaryOp AST node class；扩展语法分析器parser，生成含有UnaryOp nodes结点的抽象语法树；扩展解释器interpreter。并且增添一个新的visit_UnaryOp method函数，它可以解析一元操作符现在，开始吧。一元操作符一元操作符是什么？二元操作符：之前，我们的计算器都是围绕着这些二元操作符 (+, -, *, /)在工作，这些操作符操作两个操作数（the operators that operate on two operands.）。一元操作符unary operator ：那么，我们就能知道一元操作符是：一个操作符只操作一个操作数。（A unary operator is an operator that operates on one operand only.）一元操作符的规则下面是一元操作符“+、-”的规则：一元操作符-：它会使它的操作数取反（negation）一元操作符+：他对于它的操作数没影响，即，它的操作数不改变什么一元操作符比二元操作符（+, -, *, and /）有着更高的优先级（precedence）例子：“+ - 3”其中，这第一个位置的“+”表示一元操作符加号操作；第二个位置的“-”表示一元操作符减号操作。所以，“+ - 3”就相当于“+ (- (3))”，即，等于-3。【注】：这里的-3平常情况说它是一个负整数（negative integer），但是在这里我们称它是：一个一元操作符“-”，它的操作数是3。“5 - - 2”在这个表达式中，第一个“-”表示一个二元操作符：减法。第二个“-”表示一个一元操作符：取反。比如下面的一些例子，也是这个样子：开始修改将一元操作符添加入语法修改factor因为，一元操作符的优先级高于二元操作符。所以，函数factor需要需改。它之前的规则为：更新后的，规则为：从更新后的factor函数的规则，可知：它扩展之后能够引用它本身。这样我们就能够写出类似于：- - - + - 3”这样的式子，这是合法的带有很多一元操作符的表达式。其实，这里修改语法，只用修改factor函数的产生式，其他的expr、term产生式不变：扩展抽象语法树的结点类下一步就是要添加一个AST node class，来表示一元操作符：1234class UnaryOp(AST): def __init__(self, op, expr): self.token = self.op = op self.expr = expr这个函数有两个参数：op、expr：op：代表一元操作符的token（+或-）expr：表示一个AST的结点（要与expr函数区分，这两个知识名字一样，但是代表的东西不一样）扩展语法分析器parser之前我们修改了语法规则，当中的factor函数的产生式也发生了变化，所以现在我们将要修改代码，使其能够处理产生式中的 “(PLUS | MINUS) factor” 子规则：1234567891011121314151617181920def factor(self): \"\"\"factor : (PLUS | MINUS) factor | INTEGER | LPAREN expr RPAREN\"\"\" token = self.current_token if token.type == PLUS: self.eat(PLUS) node = unaryop(token, self.factor()) return node elif token.type == MINUS: self.eat(MINUS) node = unaryop(token, self.facot()) return node elif token.type == INTEGER: self.eat(INTEGER) node = NUM(token) return node elif token.type == LPAREN: self.eat(LPAREN) node = self.expr() self.eat(RPAREN) return node扩展解释器Interpreter现在我们还需要扩展解释器类Interpreter class ，向其中添加visit_UnaryOp 函数，来解释一元操作符结点：123456def visit_UnaryOp(self, node) op = node.op.type #token的类型 if op == PLUS: return +self.visit(node.expr) elif op == MINUS: return -self.visit(node.expr)例子让我们看一个例子，表达式 “5 - - - 2” ，通过我们的解析器来证实这个新的visit_UnaryOp函数确实起作用了。下面是如何从Python shell中实现:12345678910111213&gt;&gt;&gt; from spi import BinOp, UnaryOp, Num, MINUS, INTEGER, Token&gt;&gt;&gt; five_tok = Token(INTEGER, 5)&gt;&gt;&gt; two_tok = Token(INTEGER, 2)&gt;&gt;&gt; minus_tok = Token(MINUS, '-')&gt;&gt;&gt; expr_node = BinOp(... Num(five_tok),... minus_tok,... UnaryOp(minus_token, UnaryOp(minus_token, Num(two_tok)))... )&gt;&gt;&gt; from spi import Interpreter&gt;&gt;&gt; inter = Interpreter(None)&gt;&gt;&gt; inter.visit(expr_node)3上面的AST树看起来是这样的:","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let's Build A Simple Interpreter","slug":"Let-s-Build-A-Simple-Interpreter","permalink":"https://www.longlongqin.top/tags/Let-s-Build-A-Simple-Interpreter/"}]},{"title":"构造凸包——Divide And Conquer","slug":"学习笔记/计算几何/Convex-Hull/Divide-And-Conquererer","date":"2020-03-15T08:12:57.000Z","updated":"2020-03-22T06:58:07.022Z","comments":true,"path":"archives/f32f.html","link":"","permalink":"https://www.longlongqin.top/archives/f32f.html","excerpt":"Graham Scan算法说明了凸包构造问题的下界O(nlogn)是可以达到的。其实O(nlogn)的算法远不止这一种，分治法就是一种能达到O(nlogn)复杂度的思想。在此引入运用分治思想的两种算法来构造凸包。","text":"Graham Scan算法说明了凸包构造问题的下界O(nlogn)是可以达到的。其实O(nlogn)的算法远不止这一种，分治法就是一种能达到O(nlogn)复杂度的思想。在此引入运用分治思想的两种算法来构造凸包。归并排序与分治思想引入新算法之前依旧先来回顾一个经典排序算法：归并排序（merge sort）。归并排序的基本流程如下：算法分为两个阶段：分（divide）和归并（merge）。分的阶段将待排序列均分到一个个子序列（如图中划分到单个元素）。归并阶段将分好的子序列两两合并成有序序列，重复合并的过程直到整体归为一个序列。归并过程共logn步，每步耗费n的时间，总体复杂度为O(nlogn)。归并排序的过程就是一个典型的分治（divide-and-conquer）策略。凸包构造问题也可以套用这种策略来分而治之，逐步求解。我们可以将待处理点集S分为同等规模的两个子点集，并分别对其求凸包。有了两个子解后，问题就变成了如何适当加一些边，将两个子凸包merge成整体解。分治法核心的任务就是如何merge。Divide And Conquer（1）预处理为star-shaped polygon分治法解决问题的过程可以概括为：大事化小，小事化了。就是首先将问题划分为易求解的子问题，子问题套用已知方法解答即可。例如子凸包的构造就能用Graham Scan来解决。Graham Scan解决问题的前提是：参照基准点，其他点按极角有序排列，也就是构成了一个有序的星形多边形（star-shaped polygon）。首先要做的就是将两个子凸包预处理成两个star-shaped polygon。star-shaped polygon星形多边形是什么呢？其实就是在多边形内部存在一个点A，这个点与多边形内任意一点的连线都在多边形内部，就叫做星形多边形，这一个点A就叫做多边形的内核。由于任何一个凸多边形都是star-shaped polygon，它必然有一个核，其他点按极角有序排列。问题在于如何找到一个公共核，使得两个子凸包同时关于这个核是极角有序排列的。也就是公共核处于两个凸包的交部分，这样是最好处理的情况（如下左图）。不过还有可能有其他情况，不能找到公共核（如下中图），甚至两个凸包根本不相交（如下右图）：这就要将分治策略分不同情况来实现：两个子凸包有公共核：先找其中一个子凸包的核：我们可以任取该子凸包上的三点构成三角形，求三角形重心作为核。然后判断这个核是否也在另一个子凸包内部，若判定为真，就是有公共核的最简单情况。判定方法也就是之前提过的in convex polygon test，对凸包每条边做to left test即可，在线性时间内可以判定。找到公共核之后，进行凸包形成：—-用二路归并相对于公共核，两个子凸包的各自有序排列，相互交错。要做的就是将二者点序列合并，方法正是经典的二路归并，线性时间可以完成。最后进行Graham Scan即可得到大凸包。一个子凸包的核落在另一个子凸包外部：存在公共核的情况处理是很简单的，再看第一个子凸包的核落在第二个子凸包外部的情况。如下图所示：这中情况与增量构造法的情况很相似，P1的核x相对于P2就是一个新加入的点。做出两条support line：x→t和x→s，舍弃P2上t→s路径的点即可。这样P2中剩余点与x构成了一个星形多边形，x也成为了P2的核。这就转化成了第一种有公共核的情况。Divide And Conquer（2）上述分治策略的算法过于复杂，所以引入一种更加简明的分治策略。这种分治策略也会为三角剖分等问题提供思路。首先规定一种点集划分的策略。假设待合并的两个子凸包是沿着某方向是分离的，二者不相交（Divide And Conquer（1）中是有相交的）。例如下图凸包P1和P2就是相互分离的：这样划分会使得合并更加简明，不必区分多种复杂情况。预处理为了满足这种划分策略，需要引入一种预处理，也就是一个x方向的排序过程（X-sorting）。排序后就可取点x坐标的中值，将点集划分为规模相当的左右两个子集。每个凸包都有其最左点l和最右点r，如上图。merge操作现在merge操作就是将两个左右相离的两个子凸包合并为一个大凸包的过程了。运算的关注的正是两对l和r点。先直观感受一下merge操作要添加的新极边：上下两条紫色边正是要求的新边，又称支撑边（support line），并且每次merge只会增加两条新边。两条边类似两个圆的公切线（common tangent），将二者连接起来。注意，注意，注意：眼睛可能会欺骗你直观上感觉，两条support line正是两个子凸包的最高点t和最低点b相互连接得到的，这些点只需线性时间就能找到。当真如此的话凸包构造的下界就成了O(n)，显然直觉是错误的。例如下面的两种情况，support line就和b、t两点没有直接关系了：)构造support line的过程需要缜密的分析，并非凭直觉能得到的。缝合（stitch）—构造support line将两个子凸包连接的过程更像古代妇女用针将两块布缝合在一起（但是这里的两个凸包的间距是不能变的，仅仅是用线将其连接在一起。而且这里连接只需要最后找出来的那两条线，其余剩下的中间“工具线”都要舍去）。构造过程首先从左凸包的r点和右凸包的l点连线开始，以这条线为基础逐步得到support line。注意一个细节问题：如何得到各子凸包的l点和r点。每次合并都会产生新的凸包，所以凸包是一个动态的结构。当然可以每次计算出最左点和最右点，只需要线性时间。但是这并不是最优的方式。考虑分治的思想，就整个merge流程来讲，是自底向上将子凸包两两合并的过程。因此只要在最底层上最小的子凸包中记录最左点和最右点，每次merge更新一下这两个变量即可，只需要O(1)的常数时间！这种优化对整体的复杂度上线nlogn虽然没有影响，也能为程序节省一部分的开销。缝合上半部分再看如何将最初的r-l线变成support line，在此以寻找upper support line为例（上切线，相应的还需要计算下切线）。算法的核心依然是to left test。首先看l点，从r-l线出发，可以发现相对于对于r→l时，l的前驱、后继是LR型的。而我们想要的是RR型的。所以必须要找l的前驱。直到在某一个时刻，我们找到了l的一个前驱点满足RR型：再看r点，同样的，从此时的状态，来观察r的类型：是RL型的。要想成为LL型，r必须要找它的后驱。在某一时刻，r找到r的后继（就是该凸包点t）使其满足LL型：反过来继续看l，此时，具体的说应该是检测l的前驱点l&#39;，经检测，l&#39;已经不再满足RR型了，编程了LR型，所以还要继续寻找它的前驱点，使其再次满足RR型。某一时刻，找到它的前驱（就是该凸包的点t），使其成为RR型。反过来继续看r，此时，更准确的应该说是在看r&#39;，经检测，该店符合LL型。至此，所谓的r和l都已经符合RR或LL型了。从而已经找到upper support line了。结束上半部分。回顾由r-l线逐步推进得到support line的过程，每次操作一个端点，得到是一种“Z”字形（zig-zag）的推进轨迹。操作点的切换由另一点满足要求决定，而算法停止的依据是两个端点同时满足了要求。这种方式类似快速排序构造轴点的过程，左右两轴点交替操作，直到二者都满足要求时算法停止。缝合下半部分缝合下半部分的流程与，上半部分流程一样。时间复杂度分析一下算法时间复杂度。算法首先要按照x坐标排序，排序复杂度为O(nlogn)。再看merge过程，无论是左侧子凸包还是右侧子凸包，对于其每个点的操作至多只有以此，也就是每次归并是线性时间。归并共logn次，算法的总体复杂度就是O(nlogn)了。更多的考虑在这些算法讲解中，通常都是不考虑退化的情况，如，三点共线……最后总结一下第二种分治法的特点。此前Jarvis March算法虽然以平方复杂度为上界，但其”输出敏感性“使得实际复杂度为O(hn)，最好情况下仅甚至为线性。例如如下情况：Jarvis March算法的复杂度变为了O(4n)，而此时分治法依旧会经历按部就班的X-sorting，一上来就注定了O(nlogn)的复杂度，然后经历同样O(nlogn)的merge过程。也就是说这种分治法在各种情况下的表现都是很均匀的。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"计算几何","slug":"计算几何","permalink":"https://www.longlongqin.top/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"}]},{"title":"构造凸包-Graham Scan法","slug":"学习笔记/计算几何/Convex-Hull/Graham-Scan","date":"2020-03-14T09:40:32.000Z","updated":"2020-03-22T15:09:59.625Z","comments":true,"path":"archives/3478.html","link":"","permalink":"https://www.longlongqin.top/archives/3478.html","excerpt":"","text":"Graham Scan算法的流程假设待处理点集S共有n个点。1、预处理预排序(presorting）Graham Scan首先要做的是一个预处理排序操作（presorting）。即找到某个基准点，然后将其余所有的点按照相对于基准点的极坐标排序。如下图：点的排序可以套用任意排序算法的框架，只是将排序对象由数值变为了平面上的点，而比较器改为to left test实现。如何找出第一个点：点1？以点1为基准点，其余点按照相当于点1的极角依次排序为2、3、4……理论上讲任何一个点都能当第一个基准点，为了简化算法通常选择lowest-then-leftmost point（LTL）作为基准点。找出起始边对于与基准点1极角最小的点，也就是图中点2（假设没有三点共线的情况）。将点1和点2作为算法的起始点。将起始边 与 剩下的n-2条边分别存储在不同的栈(stack)中：算法开始前先将起始点1和2入栈S，其他的n-2个点入栈T，如下图。注意S和T中元素的入栈顺序。至此预处理已经完成。Graham Scan用到的数据结构。整个算法非常简明，核心数据结构只有两个栈，分别记作栈S和栈T。便于理解我们将S和T画成开口相对的形式，如上图。2、scan操作(此处为逆时针扫描)完成预处理之后，就能开始算法的核心：scan操作。scan的过程主要关注三个点：栈S的栈顶（S[0]）、次栈顶（S[1]）和栈T的栈顶（T[0]）。也就下图红色标注的三个点：对这三个关注的点，进行检测，检测的框架为：可以观察到，每次待处理的S[0]和S[1]构成的边一定是一条极边（如上图点1和点2），算法关键步骤就是对边这条极边和T[0]做to left test，判断T[0]位于边S[0]S[1]的左边还是右边。若在左边则继续拓展，若在右边则否定掉此前认定的极边。无论结果如何，每次判定都会将问题规模缩小一个单元，算法结束时T最终肯定为空。T空后，S中存留下的点正是凸包的极点，这些点自底而上正是凸包边界点的逆时针遍历，也得到了整个凸包构造问题的解。举例1、先来看一个最简单的例子，即点集S中所有的点都在凸包边界上。如下图：先找到LTL，也就是图中点1。然后基于点1对其余点按极角排序为点2、3、4……（实际上以一个点为中心的有序的点集，构成了所谓的星形多边形（star-shaped polygon），中心点正是星形多边形核（kernel）的一部分。凸多边形必然是星形多边形，反之则不然。）然后找到点1的后继2，点1和点2构成第一条极边。初始化栈S和栈T。现在要关心S[1], S[0]和T[0]，就是点1，2和3。点3位于边12左侧，to left关系为true，S.push ( T.pop() )，向前拓展了一条暂定极边。接下来重复上述过程。考虑点2，3和4。to left关系为true，S.push( T.pop() )……最终栈T空，算法结束，凸包由栈S自底向上得到。S和T的变化过程如下图：2、上面列举了最简单的情况下Graham Scan的过程，接下来列举一个更有代表性的实例深入算法的细节。输入的点集S，并进行预处理排序，并初始化栈S、T，如下图：接下来对点1，2和3进行to left测试，本质上就是判断边2→3（图中黄色边）能否被暂时采纳。测试结果为true，暂时采纳边2→3，S.push( T.pop() )。如下图所示：注意图中蓝色边表示已经被暂时接纳的边，也就是算法暂时认定的极边。上一次操作将蓝色边推进一个单元接下来关注点2，3和4，来判断下一条黄色边3→4能否被接纳。to left测试为true，S.push( T.pop() )，接纳边3→4。如下图右侧所示：然后判断点3，4和5。点5在边3→4的右侧，即to left测试为false。S.pop()，也就是判断出点4不可能为极点，丢弃4。因此算法回溯到点3，判断点2，3和5的关系。5在2→3的左侧，暂时接纳边3→5，S.push( T.pop() )。如下图：算法经历了无效操作，进行了回溯，得到了目前来说最优的“极边”。虽然这些”极边“不一定能最终保留，但问题的规模得到了削减。下一次scan考察的就是3，5和6了。3，5和6的to left测试为false，S.pop()，舍弃点5。然后考察点2，3和6，to left测试为false，S.pop()舍弃点3。如下图：……..………直遍历完剩下其他点，凸包就构造完成。验证算法的正确性思路上的正确性了解了算法的整体流程之后，我们再来论证一下算法的正确性。证明一个算法正确性的方法有很多，在此选用数学归纳法。数学归纳法的思想可用多米诺骨牌类比，要做的无非是两件事：证明第1张骨牌会倒；证明如果第n张骨牌会倒则第n+1张骨牌也会倒下。Graham Scan过程就是一个个引入点的过程。每当我们得到第k个点的时候，算法所得到的就是前k个点对应的“最好的凸包”。因此当k = n时得到的是整体的凸包。归纳的第一步就是证明k = 3时得到的是当前点集S‘ = {1，2，3}中的极边——也就是证明第1张骨牌会倒。显然边1→2是S’的一条极边。而根据预处理的方式，3相较于1的极角一定大于2，因此点3一定在边1→2的左侧，因此边2→3会得到保留。对于这三个点来说，任意两条边一定都是极边，2→3也是一条极边。然后证明：假设已经处理到第k个点，得到的是前点集S’ = {1，2，3，…，k}中所谓“最好的凸包”。根据算法处理方式，接下来从S’’ = {1，2，3，…，k，k+1}得到的结果是否也是正确的——也就是证明第n张骨牌会倒，则第n+1张骨牌也会倒下。预处理的方式是对2~n所有点相较于点1按极角排序，因此下一个要处理点k+1一定出现在线1→k的左侧，也就是下图蓝色区域和绿色区域（假设k = 9）：而根据目前接纳的最后一条极边( k-1)→k （例如图中8→9）来划分，点k+1可能出现的区域又分为两块，即该极边的左侧（绿色区域）和右侧（蓝色区域）。这也正对应于算法判定的两个分支。左侧：左侧的情况很简单，点k+1显然会是一个新的极点。Graham Scan要做的正是暂时接纳边k→k+1，拓展了一个新的单位。右侧：再看k+1落在右侧的情况。如下图点10：Graham Scan要做的是丢弃点k（图中点9），也就是判定出点k不可能是极点。这样做的原因：是引入点k+1后，点k一定会被包含在三角形(1, k-1, k+1)内部。如图中点9一定包含于三角形(1, 8, 10)内部。正如极点法中排除非极点的做法，点k被排除是正确的做法。接下来点k-1，k-2等（如图中点8，点7等）也可能是非极点，按照算法的流程，它们总会被判定在某个三角形的内部（例如点7在三角形(1, 5, 10)内部）而被排除，直到left test为true，回溯停止。换个角度考虑，回溯停止时得到的新边正是增量构造法中每步得到的support line，即切线。例如图中线5→10正是算法当前保留的”凸包“的切线。这也能论证Graham Scan处理方式的正确性。至此，算法思路上的正确性已经证明完毕。表述方式的正确性接下来还要考虑算法的表述方式是否有漏洞：代码中每次to left test之前并没有判断S栈中是否有≥2个元素。这也可以由预处理的方式来论证。点1选取的是LTL，而点2是相对于点1极角最小的点，这样的做法保证了除了点1和点2之外所有的点一定是在边1→2左侧的。因此算法回溯最多到点2，永远不可能把点2丢弃，S中元素任何时候至少有两个。Graham Scan算法的正确性论证完毕。预处理操作的必要性最后来思考一下预处理操作：presorting。仔细回顾上述论证过程会发现，每一步的正确性都是建立在最初的排序上的。那么这个预处理排序真的是必要的吗？可以来举极端的反例，每次选取下一个点都是随机的，例如下图的路径：上图中从点1开始出发进行to left测试，可以发现，每次判定结果都为true，最终所有的点都被保留了下了，而显然这并不是一个凸包。因此presorting是整个算法成立的基础。分析复杂度上面证明了Graham Scan算法的正确性，接下来分析其复杂度是否满足O(nlogn)，实现所谓的最优算法。直观上无法断定Graham Scan是一个最优的算法，尤其是以下极端情况令人质疑其效率：Graham Scan算法复杂度由三部分决定：persorting，采用一般排序算法，复杂度是O(nlogn)逐步迭代，O(n)：算法一步步纳入新点，会迭代n步。scan，O(?)所以算法的总体复杂度：O(nlogn + n * ?) ，可见scan的复杂度决定了算法总体的复杂度。算法一步步纳入新点，会迭代n步。但是在每个点上都有可能做回溯操作，所以scan的复杂度是不确定的。我们来以上图最坏情况为例，到第8个点时判定为false，舍弃点7，回溯。下一步判断也为false，舍弃点6，回溯。如此回溯直到算法开始的点2。这次scan倒退了高达O(n)个点，如果每次scan都是如此那么算法整体复杂度就为：O(nlogn + n * n) = O(n^2)了，那这种算法的意义也就不大了。其实上述分析并非错误，只是不够精确。O(n^2)确实是Graham Scan算法的一个上界，但是这个上界并不是紧的。问题就出在分析假定了每次都会出现回退高达O(n)个点。下图展示了整个Graham Scan的流程：图中黄色边是没有采纳的，就是to left测试判定为false后直接舍去的。紫色边则是曾经被认为是极边而接纳的，后来经过回溯又舍去了。无论是黄边还是紫边，在其上耗费的都是常数时间，关键就在于黄色边和紫色边的数目了。通过观察可以发现，从图论的角度看，所有的黄色边和紫色边连在一起构成了一张平面图，也就是它们互相是不可能内部相交的。平面图的一个重要性质：平面图中所有边的数目和顶点数目保持同阶这个性质来自欧拉公式：有n个点的平面图，边的数目上限是3n，也就是O(3n)。回溯（backtrack）可能会倒退的边数：在0~n之间。【但是注意，不是每次回溯都能回退到n，因为由上面可知，点集边数最多为3n，而这里面的每一个边，会被回退0次（极边），或者1次（非极边）。所以，某条边一旦被回退过，之后就不可能再被回退了】根据这个性质，在persorting之后的整个流程中，Graham Scan所能走过的所有边不仅不会到达n^2，而顶多到达和n同阶的一个线性数目。因此整个算法的复杂度也就取决于persorting的O(nlogn)了。算法推广Graham Scan算法不仅可以用于凸包构造问题，在其他许多场景下中也十分有效。为了推广Graham Scan算法，首先可以对其做简化，以方便利用在其他问题。首先再来回顾一下预处理排序，这是算法成立必不可少的一步。排序算法套用成熟的方法即可，利用数学方法计算偏角不仅复杂而且引入了误差，所以要采用to left test。要做的就是两点：套用成熟的排序算法，将待排序元素由数值变为点将排序算法的比较器改为to left test实现按照这样的流程就能间接地实现persorting。1、原始点集已经有某种次序有时候我们并不是从零开始构造凸包，例如得到的待处理点集已经是有某种次序的（比如已经按x坐标大小排序，如下图）。这种情况也不一定非得进行persorting构造新的次序，通常改变观察的角度，换一种理解方式就能免去预处理而直接进行后面的线性的scan操作了。上半部分凸包：考虑y轴负方向无穷远一个点，所有的点相对于这个点的极角排序恰好就是各点的x坐标序！也就是将无穷远的点看作起始点①，最右侧点（图中点8）看作点②，进行scan过程直到最左边的点（图中点1）结束，就得到了凸包的上半部分（upper hull），也就是下图的8→7→2→1：注：对 “考虑y轴负方向无穷远一个点，所有的点相对于这个点的极角排序恰好就是各点的x坐标序！” 这句话的理解：就像太阳光照在地球上的道理是一样的，太阳离地球足够的远，那么它的光到达地球上的时候，就近似的是平行的。下半部分凸包（lower hull）的构造也是如此。考虑一个在y轴正方向无穷远的一个点，以此为起点进行scan，最终得到lower hull：1→4→7。最后将两个凸包合二为一即可。代码实现","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"凸包","slug":"凸包","permalink":"https://www.longlongqin.top/tags/%E5%87%B8%E5%8C%85/"}]},{"title":"Lower Bound","slug":"学习笔记/计算几何/Convex-Hull/Lower-Bound","date":"2020-03-14T09:29:23.000Z","updated":"2020-03-22T14:50:08.237Z","comments":true,"path":"archives/ba04.html","link":"","permalink":"https://www.longlongqin.top/archives/ba04.html","excerpt":"","text":"Lower Bound从极点法的O(n^4^)复杂度，到极边法的O(n^3^)，再到增量构造法和Jarvis March的O(n^2^)，我们经历了将特定问题算法不断优化、降低复杂度的过程。那么还有比O(n^2^)更高效的算法吗？凸包构造算法的下界是什么？推广到一般情况，在计算模型固定的情况下特定问题的复杂度下界又是如何确定的？在计算模型固定的情况下特定问题的复杂度下界（lower bound）是确定的。严谨考虑，在设计算法前应该先确定下界是多少。对于某个问题的特定算法，我们可以用时间复杂度来评价算法的好坏。算法能达到的下界也就是所谓问题的难度。当然这种评价通常是比较麻烦的，有时候甚至是不可行的。这就要引入新的的方式来衡量一个算法的好坏。规约（reduction）我们引入规约（reduction）的方法来间接衡量一个算法。规约简单来讲就是用一个“参照物”对比待评算法，得到算法的复杂度。规约的一般方法如图：左侧是已知的问题A，已经明确它的难度，右侧是待分析问题B，复杂度未知。我们在二者之间建立起一种基本reduction关系：linear-time reduction。linear-time reduction具体表述为：任何一个A的输入（input of A），都可以在O(n)复杂度转化为一个B的输入（input of B），然后通过B的某种算法（any algorithm）计算出结果（output of B）;而对于output of B又都可以在在O(n)复杂度转化为A问题的结果（output of A）。两次转换的复杂度不能超过线性，也就是linear-time（线性时间）。能够进行上述操作，就称为：A问题可以规约到B问题（problem A is linear-time reducible to problem B）。注意表述方式防止搞混A和B的位置。曹冲称象可以通过曹冲称象的故事来帮助理解规约的思想。要解决的问题是：没有秤能直接称量大象重量（问题B的难度无法直接衡量），解决方案是：利用船和石块间接称量。石头块的重量是可以直接称量的（问题A的难度是已知的），利用船和水来转换石头和大象的重量是可操作的（规约的方法是可操作的）。【这里的规约关系(Reduction relationship)是指曹冲成像时的船和水】规约记号引入规约记号，problem A is linear-time reducible to problem B表示为：$$A≤_NB$$将问题A、B的难度分别表示为|A|，|B|。规约记号的意思相当于|A|≤|B|，A的下界必然就是B的下界。规约的过程：将A的输入转化为B的输入经过B的某种算法获得解后又转化为A的解，也就是这个算法也是解决A问题的算法。已知A问题的下界，那么这个算法必然不会低于A的这个下界。构造凸包的下界按照“曹冲称象”的规约思想，分析问题的难度，最重要的在于找到“石头”，而船就是规约这种方法。以二维凸包（2d-CH）来分析，首先将待解决的问题放到规约记号右边，而左边的“石头”就是排序算法。$$Sorting≤_N2D-CH$$排序是纯粹的数值计算问题，而凸包是典型的几何问题，二者是如何联系在一起的呢？前面增量构造法和Jarvis March算法正是分别由两种排序算法来类比引入的，可见排序和凸包之间有深刻的内在联系。二者之间的联系可以通过下图表示：首先清点要做的任务：可以在线性时间内，将排序问题的输入转化为凸包问题的输入排序问题的输入可以表示为x轴上的一系列的点（图中蓝色点）。然后将这些点转化为凸包问题的输入，就是将这些待排序的数转化为平面上的点。引入辅助线——一条抛物线，例如图中蓝色虚线。接下来要对蓝色点做到抛物线上的映射（O(n)），映射在抛物线上的点用绿色标出。这样就完成了将待排序数字转化为平面上点的操作。接下来就可以用某种算法将绿色点构造为凸包，即图中CH(P)。可以在线性时间内，将凸包问题的结果转化为排序问题的结果凸包CH(P)就是问题B的解，如何将B的解转化为A的解？注意最左和最右边两点的连线，即图中1和4的连线4→1。除去这条连线之外，其他首尾相接的连线：1→2，2→3和3→4都是“沿着x方向单调的”，遍历这些首尾相连的边（O(n)）就能得到一系列的数值，并且已经是有序的了。这样就将凸包问题的解——凸包CH(P) 转化为了排序问题的解——有序数值序列。两次转化说明规约是可行的，因此2d-CH问题的下界可由sorting的下界确定。一般而言，排序问题的难度是确定的：O(nlogn)。2d-CH问题的下界也就是：$$O(nlogn)$$更高维的凸包问题下界也是如此。增量构造法和Jarvis March的O(n^2^)到O(nlogn)之间的鸿沟能否跨越呢？是否存在O(nlogn)复杂度的凸包构造算法？后续文章会有回答。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"凸包","slug":"凸包","permalink":"https://www.longlongqin.top/tags/%E5%87%B8%E5%8C%85/"}]},{"title":"构造凸包-Jarvis March(Gift Wrapping)算法","slug":"学习笔记/计算几何/Convex-Hull/Jarvis-March","date":"2020-03-14T09:23:45.000Z","updated":"2020-03-22T13:53:01.986Z","comments":true,"path":"archives/9c7f.html","link":"","permalink":"https://www.longlongqin.top/archives/9c7f.html","excerpt":"回顾凸包构造算法：极点法、极边法和增量构造法，其复杂度分别为O(n^4^)、O(n^3^)和O(n^2^)，效率经过优化已经大大提高了。接下来引入一种新的算法——Jarvis March，其复杂度也是O(n^2^)，但是相较于增量构造在最好情况下效率是较高的。","text":"回顾凸包构造算法：极点法、极边法和增量构造法，其复杂度分别为O(n^4^)、O(n^3^)和O(n^2^)，效率经过优化已经大大提高了。接下来引入一种新的算法——Jarvis March，其复杂度也是O(n^2^)，但是相较于增量构造在最好情况下效率是较高的。实现策略先想一下为何极边法复杂度高达O(n^3^)。实际上我们要对点集中所有边进行遍历，这需要n^2^复杂度，然后对每个边进行鉴别，又需要n复杂度，因此总体复杂度高达O(n^3^)。那么该如何改进呢？这就可以运用选择排序的思想：将下一个要查找的边缩小到一个小范围，而非遍历所有边。选择排序每次选取出的unsorted最大元素放在sorted 部分的首部，也就意味着整个unsorted部分必然不会超过sorted部分。从算法整体框架考虑，每次我们都是维护一个局部解（也就是sorted部分），然后从尚未处理的部分（也就是unsorted部分）找到一个与当前局部解“紧密相关的元素”（相当于选取的最大元素）。这个思想为解决凸包问题带来了新思路。对算法的大致过程进行描述(标识为：已找到极边数/所有极边数)：首先从任何一个极点（后面说明如何找到这个点）开始（图中0/5），然后找到一条以这个极点为端点的极边（1/5）。接着沿着极边另一个端点（endpoint）出发，再找出下一条极边（2/5）。如此反复操作，最终会找到一条以最初极点为endpoint的极边，得到一个封闭的环，凸包也构造完成。凸包构造过程类似于选择排序中sorted不断向前扩展一样，不断扩展局部解，最后得到问题最终解。凸包构造的问题由此分解为一个个子问题：如何从endpoint出发找到下一条极边。用to left test找到下一条极边现分析如何从endpoint找到下一条极边。考虑一下的一般情况：我们从极点o开始寻找极边，假设当前找到的极边是ik，接下来要做的工作是找到从k出发的另一条极边ks，即找到极点s。显然，s来自于其他那些尚未处理的点中，那么s与其他点相比有什么特征？观察发现，ik作为一条极边，它的右侧肯定都是空的，所有其他点都在ik左侧。画出k与其他候选点的有向直线，例如下图中的ks，kt：注意图中红色标出的角度，可以看出ks与ik的夹角比kt小，也就是ks比kt相较于ik偏左的角度更小。实际上ks偏左的角度比其他任何从k出发的边都小，这就是s点的判定依据。这样就找到了从其余点中选择s点的思路：任选两个点，从k出发过这两点做有向边，看哪个偏左的角度更小就留下，另一点丢弃。然后再拿一点与留下的点比较，反复这个过程，最终留下的就是要找的s点。问题至此转化为：如何比较两条有向边（例如ks和kt）相较于另一有向直线（例如ik）谁偏左的角度更小。当然可以通过计算三角函数的方法来比较，这是最直观的数学思维。但是这样计算十分复杂，更重要的是引入了误差。这时候又要使用to left test这个基础方法来解决问题了具体做法就是以在ks和kt中以任意个为基准（如以ks为基准），对另一点（如t）做to left test。上图点t和有向边ks的to left test结果为true，t在ks左边，因此ks偏左的角度更小，舍弃点t。类比选择排序来理解:已得到的极边（从极点o开始到ik的首尾相连的极边）——相当于 sorted部分其余点——相当于 unsorted部分找到点s（能构成最小偏角的点）——相当于 从unsorted部分取出极大值选择排序中的选择过程需要比较元素大小，就要由一种比较器完成，而上述比较偏角的过程也可以抽象为一种比较器的操作。构造凸包的算法框架与选择排序相同，只是比较器替换为to left test而已。此处只是考虑一般情况，一些特殊细节未进行处理。例如在st上有s和s’两点，这两点的取舍问题未考虑。当然为了理解算法整体框架忽略特殊情况是很必要的。确定第一个极点一个细节：上文一开始提到的算法的最开始的第一个极点如何确定？任何一个极点都可以使用，我们没必要去计算出哪个点是极点。可以选取y坐标最小的点，也就是最低点，在没有退化的情况下，这个点一定是一个极点。如果情况退化，有多个最低点（如例图中所示），我们就去选x坐标最小的那个点，也就是最左边的点即可。这种方法选出的点称为lowest-then-leftmost point（LTL）。注意选取的规则的先后顺序，先选lowest，若点不唯一再选leftmost。Jarvis March类比选择排序的过程，我们得到的凸包构造算法就是Jarvis March算法，又称gift wrapping算法（算法过程如包装礼物一样）。接下来看算法具体实现方法。12345678910111213141516171819202122232425262728293031323334353637383940bool ToLeft(Point P, Point q, Point s)&#123; int area2 = p.x*q.y - p.y*q.x + q.x*s.y -q.y*s.x + s.x*p.y - s.y*p.x; return area2 &gt;0 ; //左侧为真&#125;int LTL (Point S[], int n)&#123; int ltl = 0; //the lowest-then-leftmost point for(int k=1; k&lt;n;k++)&#123; if(S[k].y &lt; S[ltl].y || (S[k].y==S[ltl].y &amp;&amp; S[k].x&lt;S[ltl].x)) ltl =k; &#125; return ltl;&#125;void Javis(Point S[], int n)&#123; for (int k=0; k&lt;n; k++) S[k].extreme =FALSE; //首先将所有点标记为非极点 int ltl=LTL(S, n); //找到LTL int k=ltl; //将LTL作为第一个极点 do &#123; S[k].extrem = true; int s =-1; //s是要找的下一个极点，用t去循环找 for (int t=0; t&lt;n; t++) &#123; if(t != k &amp;&amp;t != s &amp;&amp; ( s == -1 || !ToLeft(S[K],S[s],S[t]) ) ) s = t; //如果t在pq的右侧，则更新s &#125; S[k].succ = s; k = s; //新的极边pq确定 k = s; //更新k的值，变为下一次查找的起点 &#125;while(ltl != k) //如果循环回到了原来的点，则结束&#125;梳理首先，初始化将所有点都设为：非极点然后，开始找到第一个极点（用LTL方法），找到之后赋值给k接下来，开始找下一个极点s：主要用ToLeft Test来找出下一个极点循环第3步骤，直到找到所有极点小结最后分析Jarvis March算法相较于增量构造法的优势。二者都是O(n^2^)的复杂度，Jarvis March算法的优势在于其的“输出敏感性（output sensitive）”。考虑点集S，共有n个点，来构造S上的凸包。何为“输出敏感性”？Jarvis March算法每次新加入一条边都会耗费n的复杂度，但是构造过程一共会加入的边数往往比n少。如下图（设n = 7）：在非退化为共线的前提下，最好情况为只加入3条边（复杂度为O(3n)），最坏情况为所有点都是极点，加入n-1条边（复杂度为O(n^2^)）。实际情况中最坏情况出现的几率很小，我们引入一个指标h来衡量凸包的极边数（the size of convex hull）：$$h = |CH(S)|$$Jarvis March算法算法的复杂度更准确的表示为O(nh)。h又由最终输出结果，即凸包本身来决定，输出结果决定了构造过程的复杂度，这就是所谓的“输出敏感性”。这种类型的算法又被称为output sensitive algorithm。这种特性在其它凸包算法中也会体现。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"凸包","slug":"凸包","permalink":"https://www.longlongqin.top/tags/%E5%87%B8%E5%8C%85/"}]},{"title":"Convex Hull(凸包)","slug":"学习笔记/计算几何/Convex-Hull/Convex-Hull-凸包","date":"2020-03-14T09:15:07.000Z","updated":"2020-03-22T14:23:34.120Z","comments":true,"path":"archives/510d.html","link":"","permalink":"https://www.longlongqin.top/archives/510d.html","excerpt":"这山之高，就叫凸碧；山之低洼近水处，就叫作凹晶。这凸、凹二字，历来用的人最少，如今直用做轩馆之名，更觉新鲜，不落窠臼。","text":"这山之高，就叫凸碧；山之低洼近水处，就叫作凹晶。这凸、凹二字，历来用的人最少，如今直用做轩馆之名，更觉新鲜，不落窠臼。欧拉公式简单介绍一下欧拉公式：虚数中：i^2^=-1 ; i=√(-1)其中θ为实数，i表示虚数中的虚数单位 i；欧拉恒等式：当θ=π时；几何学中的欧拉公式：V-E+F=2 【v：几何体的顶点数；E：边数；F：面数】凸包凸包：比如，我们有很多很多钉子钉在木板上面，然后用一个皮筋将这些钉子包围起来，当我们松手后，皮筋就把这些定在全都包围起来。此时，这个皮筋所形成的凸多边形就叫凸包。如下图的蓝色的多边形就是凸包。凸性(Convexity)下图中，假设x,y,z是三种颜色，如果仅以x,y就能调出来的颜色，那么如u所示它一定会落在x,y中；若需要x,y,z三种 一起，那么如v所示会落在以x,y,z三点连成的三角形内部。极点(Extreme Point)有一个点集S。如果存在通过点P的直线L，使得点集S中除了点P之外的其他的点都在这个直线的同一侧，则这个点P就是极点(Extreme Points)。判断一个点是否为极点：该点P是否会被包含在其他点中任意三个点形成的三角形中，如果点P不在任何三角形内部，则说明点P是极点。反之，则不是极点。如下图：下图中，S就不是极点，因为他在三角形内部。判断极点的算法In-Trangle Test算法描述伪代码：其实这个算法就是判断点是否在三角形内部。代码实现：123456789101112131415void extremePoint (point S[], int n)&#123; for(int s=0; s&lt;n; s++) S[s].extreme = TRUE; for(int p=0; p&lt;n; p++) for(int q=p+1; q&lt;n; q++) for(int r=q+1; r&lt;n; r++) for(int s=0; s&lt;n; s++) &#123; if(s==p || s==q || s==r ||!S[s].extreme) continue; if(Intriangle(S[p],S[q],S[r],S[s])) S[s].extreme = FALSE; &#125;&#125;可知，该算法的时间复杂度为O(n^4^)，其实挺大的，在后面我们会进一步改善。这样基于极点的凸包算法虽然效率不高，但是它会引出一个非常重要的操作我们称之为To-Left Test在后面我们可以看到这个测试几乎是贯穿于我们计算几何这个课程的始终的。如果说我们刚才所给出的那个算法还有什么需要补充的话其实最重要的也就是那样的一个细节也就是所谓的In-Triangle test。To-Left Test我们将刚才这个In-Triangle Test转化为三次To-Left测试也就是说一个点如果确实落在某一个三角形的内部的话那么相对于这个三角形的三条边所做的这个To-Left测试都会统一的返回true或者统一地返回false。1234567bool InTriangle(Point p, Point q, Point r, Point s)&#123; bool pqLeft = ToLeft(p, q, s); bool qrLeft = ToLeft(q, r, s); bool rpLeft = ToLeft(r, p, s); return (pdLeft == qrLeft) &amp;&amp; (qrLeft == rqLeft);&#125;To-Left测试是相对于另外这两个点所确定的那条有向直线而言的，任何一条有向直线不仅会把平面分成两部分，我们还可以知道哪一边是左边，哪一边是右边。To-Left，其实就是说这个点相对于刚才的那条有向线而言到底是位于它的左侧，还是右侧。如果是前者就是true，否则的话就是false。因为三角形有三条边，所以我们要用三次To-Left Test。To-Left Test具体实现：这里用到了行列式来求三角形面积（至于原理，这里就不多说了）。下图中的这个行列式实际上算的首先是它的面积的两倍。123456789101112bool ToLeft(Point p, Point q, Point s)&#123; return Area2(p, q, s) &gt; 0; &#125;int Area2(Point p, Point q, Point s)&#123; return p.x * q.y - p.y * q.x +q.x * s.y - q.y * s.x +s.x * p.y - s.y *p.x;&#125;注意：这里的面积其实是“有向面积”，也就是说这里的面积分正负（相对于这样一个逆时针的一个编号pqs的这样的一个面积 与 s在右侧也就是按照顺时针的pqs所构成的面积虽然有可能大小是一样完全对称但是它们的符号是相反的）。整个这个To-Left的测试的判断的依据也就在于这个符号。这个行列式取正条件为：当且仅当s位于pq所确定的这条有向直线的左侧。其中转换成代码也是非常简明的，代码如上图所示。至此，To-Left Test实现完成。极边(Extreme Edge)极边：两个极点连成的边，剩余的所有点均会在该边的一侧。判断是否为极边：代码实现：12345678void markEE(point S[], int n)&#123; for (int k=0; k&lt;n; k++) S[k].extreme = FALSE; for (int p=0; p&lt;n; p++) //test for(int q=p+1; q&lt;n; q++) //检验每一条边 checkEdge(S,n,p,q) //有向边pq&#125;1234567891011void checkEdge(Point S[], int n, int p, int q)&#123; bool LEmpty =TRUE, REmpty =TRUE; for (int k=0; k&lt;n &amp;&amp; (LEmpty || REmpty); k++) &#123; if (k != p &amp;&amp; k != q) ToLeft(S[p], S[q], S[k]) ? LEmpty=FALSE : REmpty=FALSE; &#125; if(LEmpty || REmpty) S[p].extreme=S[q].extreme=TRUE;&#125;实现的步骤：初始时，先假设所有的点都不是极点。开始遍点集S中的点，它们两两组合成一个线段，然后进行checkEdge(检查这些线段是否是极边)。检查的方法checkEdge：利用ToLeft测试，每次都将当前的线段与其他点（即，除了这两个点之外的点）进行ToLeft测试，如果测试结果中：LEmpty、REmpty 其中之一为true，就表明这两个点构成的线段为*极边*，而且同时也检测出这两个点是*极点*。（其实两个点组成的线段进行checkEdge的结果中的LEmpty、REmpty最多只有一个是true,因为这里不存在一条边的两侧都没有其他点的情况）12345678910111213141516171819202122void markEE(Point S[], int n) //n&gt;2&#123; for(int k = 0; k &lt;n; k ++) S[k].extreme = False; //先假设所有的点都不是极点 for(int p = 0; p &lt; n; p ++) for(int q = p + 1; q &lt; n; q ++) checkEdge(S, n, p, q);&#125;void checkEdge(Point S[], int n, int p, int q)&#123; //LEmpty、REmpty表示改边的左侧、右侧，等于True时表示该侧是没有点的。 bool LEmpty = True, REmpty = True; for(int k = 0; k &lt; n &amp;&amp; (LEmpty || REmpty); k ++) &#123; if(k != p &amp;&amp; k != q) &#123; ToLeft(S[p], S[q], S[k]) ? LEmpty = False : REmpty = False; &#125; &#125; if(LEmpty || REmpty) S[p].extreme = S[q].extreme = True;&#125;同样可利用此来判断是否是极点（复杂度为O(n^3)）。补：根据极角排序定义：我们平常所使用的坐标系都是直角坐标系，而极角排序是在极坐标系下进行的。这里首先要选取一个点，然后其它点根据与参考点的连线与x轴所成的夹角的大小进行排序的。这里我们可以简单理解为绕着一个点逆时针转圈访问。代码：在讲具体实现方法之前，先给出用到的函数和结构体：1234567891011121314struct point//存储点&#123; double x,y;&#125;;double cross(double x1,double y1,double x2,double y2) //计算叉积&#123; return (x1*y2-x2*y1);&#125;double compare(point a,point b,point c)//计算极角&#123; return cross((b.x-a.x),(b.y-a.y),(c.x-a.x),(c.y-a.y));&#125;利用叉积的正负来排序 关于叉积：叉积=0是指两向量平行（重合）；叉积&gt;0，则向量a在向量b的顺时针方向（粗略的理解为在a在b的下方）；叉积&lt;0，则向量a在向量b的逆时针方向（粗略的理解为在a在b的上方）123456789bool cmp(point a,point b) &#123; point c;//原点 c.x = 0; c.y = 0; if(compare(c,a,b)==0)//计算叉积，函数在上面有介绍，如果叉积相等，按照X从小到大排序 return a.x&lt;b.x; else return compare(c,a,b)&gt;0;&#125;用 complex 的内建函数，算出极角大小。12345678910#include &lt;complex&gt;#define x real()#define y imag()#include &lt;algorithm&gt;using namespace std;bool cmp(const Point&amp; p1, const Point&amp; p2)&#123; return arg(p1) &lt; arg(p2);&#125;用 arctan 计算极角大小。注意角的大小范围是(-180°, +180°]。弧度表示。这里用 arctan2 函数应该是为了提高精度。关于atan2()函数：在C语言的math.h或C++中的cmath中有两个求反正切的函数atan(double x)与atan2(double y,double x) 他们返回的值是弧度要转化为角度再自己处理下。前者接受的是一个正切值（直线的斜率）得到夹角，但是由于正切的规律性本可以有两个角度的但它却只返回一个，因为atan的值域是从-90°~90° 也就是它只处理一四象限，所以一般不用它。推荐这个：第二个atan2(double y,double x) 其中y代表已知点的Y坐标，同理x ,返回值是此点与远点连线与x轴正方向的夹角，这样它就可以处理四个象限的任意情况了，它的值域相应的也就是-180~180了1234bool cmp1(const Point&amp; p1, const Point&amp; p2)&#123; return atan2(p1.y, p1.x) &lt; atan2(p2.y, p2.x);&#125;先判断象限，再用外积判断顺序，最后根据长度排序。123456789101112131415int Quadrant(point a) //象限排序，注意包含四个坐标轴&#123; if(a.x&gt;0&amp;&amp;a.y&gt;=0) return 1; if(a.x&lt;=0&amp;&amp;a.y&gt;0) return 2; if(a.x&lt;0&amp;&amp;a.y&lt;=0) return 3; if(a.x&gt;=0&amp;&amp;a.y&lt;0) return 4;&#125;bool cmp3(point a,point b) //先按象限从小到大排序 再按极角从小到大排序&#123; if(Quadrant(a)==Quadrant(b))//返回值就是象限 return cmp1(a,b); else Quadrant(a)&lt;Quadrant(b);&#125;向量的点乘与叉乘的几何意义向量的点乘（内积）：$$\\vec{a} \\cdot \\vec{b}=|\\vec{a}| \\cdot |\\vec{b}|\\cdot cos\\theta$$点乘的几何意义是可以用来表征或计算两个向量之间的夹角，以及在b向量在a向量方向上的投影向量的叉乘（外积）：$$\\vec{a} \\times \\vec{b}=|\\vec{a}| \\cdot |\\vec{b}|\\cdot sin\\theta$$向量积被定义为：模长：（在这里θ表示两向量之间的夹角(共起点的前提下)（0° ≤ θ ≤ 180°），它位于这两个矢量所定义的平面上。）方向：a向量与b向量的向量积的方向与这两个向量所在平面垂直，且遵守右手定则。（一个简单的确定满足“右手定则”的结果向量的方向的方法是这样的：若坐标系是满足右手定则的，当右手的四指从a以不超过180度的转角转向b时，竖起的大拇指指向是c的方向。c = a ∧ b）特别的，在二维中，两个向量的向量积的模的绝对值等于由这两天向量组成的平行四边形的面积。向量的叉乘，即求同时垂直两个向量的向量，即c垂直于a，同时c垂直于b（a与c的夹角为90°，b与c的夹角为90°）参考文献极角排序：https://sumygg.com/2013/07/30/Sorting-Points-by-Polar-Angle/关于极角排序：https://www.cnblogs.com/aiguona/p/7248311.html","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"凸包","slug":"凸包","permalink":"https://www.longlongqin.top/tags/%E5%87%B8%E5%8C%85/"}]},{"title":"构造凸包-增量构造法","slug":"学习笔记/计算几何/Convex-Hull/增量构造","date":"2020-03-14T09:15:07.000Z","updated":"2020-03-22T15:43:30.666Z","comments":true,"path":"archives/7c53.html","link":"","permalink":"https://www.longlongqin.top/archives/7c53.html","excerpt":"","text":"在引入新算法之前首先来回顾一下经典的算法思想：减治（decrease and conquer），注意不是分治（divided and conquer），二者稍有区别。简单来讲就是将问题划分为一个个简单的小问题，减而治之，逐个求解，最终就能得到整个问题的解。减治法的经典例子就是插入排序（insertion sort）。插入排序的过程可以归结成下图：排序的过程中将序列分为两部分：已排序部分（sorted）和未排序部分（unsorted）。每次排序都是从unsorted中拿出一个元素，通过一次顺序查找过程在sorted部分中找到位置并插入其中。整个插入排序的过程就是逐个元素的去“蚕食”unsorted部分的过程，连续的进行这个操作就会将整个问题解决。这种将大问题分解成小问题的减治过程，又被看成一种递增的、增量式的策略（incremental strategy）。这种思想为解决凸包问题提供了新的思路：从逐个插入新点的角度构造凸包。典型流程如下图（标识为：极点/整体规模）：插入新的点可能的情况有：新点对凸包有“贡献”，例如5/5→6/6，6/6→7/7；新点也有可能没有“贡献”，例如7/7→7/8；还有可能使原先有“贡献”的点失效，极点数量减少，例如7/8→6/9。那么如何对不同情况进行处理呢？确定新点与现有凸包的关系~in-convex-polygon test构造过程的核心算法应该是：判定待定点是否位于某多边形内部（in-convex-polygon test）。再看上图流程，实际上每步的核心就是判断点位于多边形内部还是外部，若落在外部，则新插入的点就是下一个极点，否则舍弃。考虑基本情况，给定一个点和一个多边形，如何高效判断该点与多边形的位置关系呢？一种思路是：我们可以先对多边形进行一个“预处理”，给每个点按序编号，类比有序向量二分查找的思想，来逐步缩小规模。如下图：首先任选一点为基准点（蓝色点），然后用二分法选取其余点的“中点“（预处理已经为所有点排了序），然后判断基准点到终点的有向直线与待定点的位置关系（to-left test）。然后可将搜索范围减半，反复上述过程，直到最后退化为平凡情况：三角形与点的位置关系（in-triangle test）。分析一下算法的整体复杂度：整个算法共log(n)步，每步的to-left test或in-triangle test都为常数成本，则整体复杂度为log(n)。至此，我们似乎得到了一个log(n)的“高效”算法，但是这种方法真的可行吗？注意，每步都会将原凸包规模减半，也就是说凸包是动态的，随时可能变化。这种方法和极点法或极边法中静态查找的情况是完全不同的。类比插入排序的过程来解释这个问题。为何插入排序的复杂度是n^2^而非nlog(n)？每次插入时，既然sorted部分已经有序，为何不使用二分查找来取代顺序查找（复杂度由n变为log(n)）？这不得不考虑sorted部分的动态性，每次插入后它的结构都会改变，而二分查找必须在静态结构中实现。当然可以使用std::vector这类支持按秩访问（call by rank）的数据结构，但是插入时维护vector的成本依旧是线性复杂度。因此插入排序的总体复杂度是n^2^。要处理的凸包与插入排序中sorted部分本质是一样的，它们都不是静态不变的结构，而要随着算法执行而不断变化。若要每次在log(n)成本下完成待定点的in-convex-polygon test，必须将凸包存储为类似vector的数据结构，但是每次向这种数据结构插入新点的成本依旧是线性的。因此对凸包进行的所谓“预处理”是没有意义的，这种减治策略算法复杂度最低应该为O(n^2^)。到现在问题依旧没有解决，究竟如何用这种增量式的策略来构造凸包？其实复杂问题中最朴素、最基本的方法反而是最有效的。in-convex-polygon test最基本的方法是什么？就是按一定方向（约定为逆时针）凸包的每条边和待定点做to-left test，一旦有一次test为false就能断定点在凸包外面。这实际上就是将in-triangle test推广多边形的情况。因此每次in-convex-polygon test的成本就会变成当前凸包的规模，也就是n。对于每个新点做一次in-convex-polygon test，构造算法的整体复杂度就是O(n^2^)。算法的复杂度从极边法的O(n^3^)又下降了一个数量级。其实增量算法的整个思路可以分成两块：1、如何判断凸包与新点的位置关系（in-convex-polygon test）2、如何向凸包插入新点上面的方法已经解决了第一个问题。第二个问题看下面部分：如何向凸包插入新点~support-line现在来讨论如何向凸包插入新点：比如下面这个点，应该如何插入凸包之中呢？插入过程：将新点x插入原凸包的过程，本质上就是寻找两个连接点s和t，将x和t、s分别连接得到新的凸包。注意t和s两点将整个原凸包边界分为两部分：st和ts两个有向段。构造新凸包就要保留远端st、舍弃近端ts。取代近端ts的两条线就是x和t的连线xt和xs，被称为切线（tangent）或者support line（支撑线）。那如何查找t、s这两个点呢？我们在凸包上任取一点v，按逆时针方向v点会有一个直接前驱点和直接后继点。考察有向直线xv与点v直接前驱和直接后继的位置关系（两次to left test），记录为一个pattern表。结果无非是四种情况：v的直接前驱和直接后继相对于有向直线xv的位置是RL，LR，LL，RR。例如上图黄色点v，是R和L；蓝色点v分别是L和R。实际上凸包边界st上所有点的pattern都为RL，ts上所有点的pattern都为LR。关键点在于：点S的pattern是LL，点t的pattern为RR。因此对凸包边界每个点做两次to left test，判断其pattern就可找出s和t，花费时间成本为常数。incremental construction再来回顾整个凸包构造算法的两大问题：in-convex-polygon test和插入新点。分开考虑只是为了将思路简化，实际上这两个问题可以套用一个算法，同时来解决。具体做法就是：对于每个待定点x，不必特意去考虑它与凸包的位置关系，而是遍历凸包上每一个点。对于凸包边界上的每一个点，我们都能通过两次to left test迅速判断出pattern。对于x位于凸包外部的情况，经过遍历凸包的点，我们很容易就能得到s和t的位置，得到两条support line，从而构造出新的凸包；而对于x位于凸包内部的情况，凸包边界每个点都不可能出现RR或LL的情况，直接舍弃x即可。每次遍历凸包边界点的复杂度为O(n)，整个构造过程要增量式的逐点考察，自然得到了一个O(n^2^)的incremental construction算法。这就是所谓增量构造法来构造凸包的过程。构造过程巧妙的避开了特殊处理诸如5/5→6/6、7/7→7/8、7/8→6/9等复杂情况，采用一致的思路逐个考察“新点”，最终完成凸包的构造。代码部分待写……..小结：其实增量算法的整个思路可以分成两块：1、如何判断凸包与新点的位置关系（in-convex-polygon test）2、如何向凸包插入新点","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"凸包","slug":"凸包","permalink":"https://www.longlongqin.top/tags/%E5%87%B8%E5%8C%85/"}]},{"title":"Let’s Build A Simple Interpreter 7","slug":"学习笔记/Let's Build A Simple Interpreter/LSBASI-7","date":"2020-03-13T13:55:47.000Z","updated":"2020-03-25T14:12:11.797Z","comments":true,"path":"archives/5a757a52.html","link":"","permalink":"https://www.longlongqin.top/archives/5a757a52.html","excerpt":"","text":"前言原文链接：https://ruslanspivak.com/lsbasi-part7/之前的那几小结，我们都是把interpreter的代码和parser的代码混在一起，而且interpreter在parser识别出一个如加减乘除之类 的特定的语言结构(language construct)后，就会立刻对它进行求值。这种 interpreter 被称为 语法导向解释器(syntax-directed interpreter)。他们通常在输 入上做一个 pass 且只适合基础的语言应用。为了分析更复杂的编程语言 Pascal 的结构， 我们需要建立一个 中间表示 (intermediate representation, IR)。parser 会 负责构建 IRinterpreter 会用来解释由 IR 所代表的输入。事实证明树是一个表示 IR 非常合适的数据结构。关于数的一些术语terminology：树是一个包含一个或多个结点组成的层次数据结构。树有一个根结点，就是顶部结点。除根结点外的所有结点有唯一 一个父结点。下图中结点为*的是一个父结点。结点为 2 和 7 的是它的子结点；子结点从左到右排序。没有子结点的结点称为叶子结点。有一个或多个子结点的非根结点被称为中间结点。子结点也可以是完全子树。下图中结点＋的左子树（结点为*）就是一个有自己子结点的 完全子树。在计算机科学中我们把树倒过来画，根结点在最上边，分枝向下生长。下面是表达式 2 * 7 + 3 的带有解释的树形表示：本系列中我们会用到的 IR 被称为 抽象语法树 (abstract-syntax tree, AST)。但在深 入了解 AST 之前让我们简单聊聊 解析树 (parse tree)。尽管我们不会在解释器和编译 器中用到解析树，但它会通过可视化 parser 执行轨迹的方法，加深你对 parser 如何解释 输入的理解。我们也会将它和 AST 做比较，来表明为什么 AST 比解析树更适合用来做 IR。那么，什么是解析树呢？解析树（有时叫做 具体语法树concrete syntax tree ）是一个根据我们的语法定义来 表示一门语言的句法结构的树形结构。它基本上展示了你的 parser 如何识别语言结构或者， 换句话说，它展示了你语法的开始符号怎么派生出该编程语言中一个特定的字符串的。parser 的调用栈隐式地代表了一个解析树，且当parser 在试图识别一个特定的语言结构时，解析树 就会自动地在内存中构建出来。下面是表达式 2 * 7 + 3 的解析树：在上面的图片中可以看到：解析树记录了 parser 用来识别输入的一系列规则。解析树的根结点的标签是语法的开始符号(start symbol)。每个中间结点表示一个非终结符(non-terminal)，代表应用了一条语法规则，像我们的情况里的 expr, term和 factor.每个叶子结点代表了一个 token.我们不会手动构建解析树且在我们的解释器中用到它，但解析树可以通过可视化 调用过程帮助我们理解 parser 怎么解释输入。你可以使用一个名为 genptdot.py 的小应用（我很快写完用来帮助你的），来查看不同的 算术表达式看起来什么样。要使用这个应用你首先需要安装 Graphviz包，然后运行下面的 命令，你可以打开生成的图片文件 parsetree.png 查看你从命令行传入的表达式的解析树：12$ python genptdot.py \"14 + 2 * 3 - 6 / 2\" &gt; \\ parsetree.dot &amp;&amp; dot -Tpng -o parsetree.png parsetree.dot下面是由表达式 14 + 2 * 3 - 6 / 2 生成的图片 parsetree.png:parser抽象语法树(AST)现在我们来聊聊抽象语法树(AST)。它是在余下的文章中会大量用到的中间表示(IR)。它是我们的解释器和未来编译器项目的核心数据结构。让我们以把表达式 2 * 7 + 3 的 AST 和解析树放在一起看来开始我们的讨论：从上面的图片中可以看出，AST抓住了输入的精髓且更小。AST 和解析树最主要的区别有：AST 使用操作符/操作(operators/operations )作为根结点，操作数(operands)作为它们的子结点。不像解析树，AST 不使用中间结点来表示语法规则。AST 并不把真实句法中的所有结节都表示出来（这就是为什么它是抽象的）──例如，没有 规则结点和括号。对于相同的语言结构来说，AST 相比于解析树更紧凑。抽象语法树是什么？抽象语法树(AST)是表示一个语言结构的抽象句法结构的树形表示，它的中间结点和根结点代表了一个操作符，子结点代表了该操作符的操作数。看一下AST与解析树对比，显现他的紧凑性：如何将操作符的优先级(precedence)编码进 AST 呢？为了把操作符优先级编码进 AST，即，为了表示“X 在 Y 之前发生”你只需要在树中把 X 放在低于 Y 的位置。你在前面 的图片中已经见过到了。【例子】：在下面的图片中，左边是表达式 2 * 7 + 3 的 AST。让我们用括号把 7 + 3 围起来以改变 它的优先级。在右边是修改后的表达式 2 * (7 + 3) 的 AST：代码实现AST好了，让我们写些代码来实现不同的 AST 结点类 并修改我们的 parser 来生成包含这些结点的 AST 树：首先，新建一个基本结点类叫做 AST，其他类会从它继承：12class AST(): pass #pass 不做任何事情，一般用做占位语句。因为如果定义一个空函数程序会报错，当你没有想好函数的内容是可以用 pass 填充，使程序可以正常运行。回忆一下 AST 表示了操作符-操作数模型。到现在为止，我们有4个操作符和整型操作数。操作符有加、减、乘、除。我们原本可以新建单独的类来表示每个操作符如 AddNode, SubNode, MulNode 和 DivNode，相反我们只会新建一个 BinOp 类来表示所有 4 个二元操作符*binary operator* （二元操作符就是作用在两个操作数的操作符）：12345class BinOp(AST): def __init__(self, left, op, right): self.left = left self.token = self.op = op self.right = right构造函数的参数是 left, op, 和 right, 其中 left 和 right 分别指向了表示 左操作数和右操作数的结点。 op 保存了指向操作符本身的 token: Token(PLUS, &#39;+&#39;) 表示加操作符， Token(MINUS, &#39;-&#39;) 表示减操作符，等等。为了在 AST 中表示整数，我们定义一个 Num 类，它将保存一个 INTEGER token 和该 token 的值：1234class Num(AST): def __init__(self, token): self.token = token self.value = token.value和你注意到的一样，所有的note保存 token 从而则创建note(all nodes store the token used to create the node)。这主要是为了方便，将来会派上用场。回忆一下表达式 2 * 7 + 3 的 AST。我们会在代码中手工创建该表达式：1234567891011121314&gt;&gt;&gt; from spi import Token, MUL, PLUS, INTEGER, Num, BinOp&gt;&gt;&gt;&gt;&gt;&gt; mul_token = Token(MUL, '*')&gt;&gt;&gt; plus_token = Token(PLUS, '+')&gt;&gt;&gt; mul_node = BinOp(... left=Num(Token(INTEGER, 2)),... op=mul_token,... right=Num(Token(INTEGER, 7))... )&gt;&gt;&gt; add_node = BinOp(... left=mul_node,... op=plus_token,... right=Num(Token(INTEGER, 3))... )以下是在新定义的结点类下 AST 的样子。下面的图片也遵循了上面手工创建的过程：parser 代码下面是我们修改过的 parser 代码，在识别输入（算术表达式）时建立和返回一个 AST:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class AST(): passclass BinOp(AST): def __init__(self, left, op, right): self.left = left self.token = self.op = op self.right = rightclass Num(AST): def __init__(self, token): self.token = token self.value = token.valueclass Parser(): def __init__(self, lexer): self.lexer = lexer # set current token to the first token from the input self.current_token = self.lexer.get_next_token() def error(self): raise Exception('Invalid syntax') def eat(self, token_type): # compare the current token type with the passed token # type and if they match then \"eat\" the current token # and assign the next token to the self.current_token, # otherwise raise an exception. if self.current_token.type == token_type: self.current_token = self.lexer.get_next_token() else: self.error() def factor(self): \"\"\"factor : INTEGER | LPAREN expr RPAREN\"\"\" token = self.current_token if token.type == INTEGER: return Num(token) elif token.type == LPAREN: self.eat(LPAREN) node = self.expr() self.eat(RPAREN) return node def term(self): \"\"\"term : factor ((MUL | DIV) factor)*\"\"\" node = self.factor() while self.current_token.type in (MUL, DIV): token = self.current_token if token.type == MUL: self.eat(MUL) elif token.type == DIV: self.eat(DIV) node = BinOp(left=node, op=token, right=self.factor()) return node def expr(self): \"\"\" expr : term ((PLUS | MINUS) term)* term : factor ((MUL | DIV) factor)* factor : INTEGER | LPAREN expr RPAREN \"\"\" node = self.term() while self.current_token.type in (PLUS, MINUS): token = self.current_token if token.type == PLUS: self.eat(PLUS) elif token.type == MINUS: self.eat(MINUS) node = BinOp(left=node, op=token, right=self.term()) return node def parse(self): return self.expr()让我们看一些算术表达式的 AST 的构建过程。如果你看了上面的 parser 代码，可以看到它建立一个 AST 中的结点的时，把变量 node 的当前值做为 BinOp 结点的左子结点，把对 term 或 factor 调用的返回结果做为它 的右子结点，这实际上就是把结点推向左边，下面表达式 1 +2 + 3 + 4 + 5 的树结构就是 这种情况的一个好例子。下面是 parser 如何一步步地构建表达式 1 + 2 + 3 + 4 + 5 的 AST 的图形表示：遍历好了，下面是表达式 2 * 7 + 3 的 AST：你怎么遍历这个树并恰当地对它所代表的表达式进行求值呢？你可以使用后序遍历*postorder traversal* (深度优先遍历depth-first traversal 的一个特例) 。这种方式由根结点开始，递归由左至右访问每个结点的子结点。后序遍历从根结点开始尽可能快地访问离根结点远的结点(The postorder traversal visits nodes as far away from the root as fast as it can)。下面是后序遍历的伪代码，其中 &lt;&lt; postorder actions &gt;&gt;是一些操作的占位符，如 BinOp 结点的加减乘除操作或 Num 结点返回整数的简单操作：为什么要使用后续遍历呢？第一，我们需要对在树中更低的中间结点进行求值， 因为它们代表了优先级更高的操作符，第二，我们在对操作数 参与 对应操作符 的运算 之前需要对操作数进行求值。在下面的图片中，可以看到使用后序遍历时我们会首先对表达式 2*7 进行 求值，而只有在对 14 + 3 求值之后，我们才会得到正确答案 17:三种深度优先遍历：为了完整起见，三种深度优先遍历的方式：先序遍历，中序遍历和后序遍历。这 些遍历方式名字的来自于遍历代码中操作的位置：有时你可能需要在所有地方（先序，中序和后序）都执行一些操作。你会在本文的源代码仓 库中找到一些例子。先序遍历preorder traversal,在先序遍历中，我们先访问根节点，然后递归使用先序遍历访问左子树，再递归使用先序遍历访问右子树，即：根节点-&gt;左子树-&gt;右子树中序遍历inorder traversal,在中序遍历中，我们递归使用中序遍历访问左子树，然后访问根节点，最后再递归使用中序遍历访问右子树，即：左子树-&gt;根节点-&gt;右子树后序遍历 postorder traversal.在后序遍历中，我们先递归使用后序遍历访问左子树和右子树，最后访问根节点。 即：左子树-&gt;右子树-&gt;根节点Interpreter用代码来遍历和解释由 parser 建立的抽象语法树：好了，让我们写一些代码来遍历和解释由 parser 建立的抽象语法树，好吗？下面是实现了访问者模式的源代码：12345678class NodeVisitor(): def visit(self, node): method_name = 'visit_' + type(node).__name__ visitor = getattr(self, method_name, self.generic_visit) return visitor(node)#generic_visit 是一个备用函数，它会抛出一个异常来表示它遇到了一个实现类中没有相 应 #visit_NodeType 方法的结点。 def generic_visit(self, node): raise Exception('No visit_&#123;&#125; method'.format(type(node).__name__))NodeVisitor一个结点访问器的基类：它遍历抽象语法树并为找到的每个节点调用一个访问器函数。（这个函数可能会返回一个由visit()方法转发 的值）。This class is meant to be subclassed, with the subclass adding visitor methods.成员函数：1️⃣ visit(node)：访问一个结点。它默认调用self.visit_classname（其中的classname是结点类的名字，或者如果这个方法不存在时，classname就是 generic_visit() ）的方法。2️⃣ generic_visit(node)：这个访问器(visitor)对结点的所有子节点调用visit()。【注意：只有这个访问器调用generic_visit() 或者访问它本身，否则自定义访问器的结点的子节点将不会被访问】1getattr(object, name[, default])官方文档中说这个函数作用是返回对象的一个属性，第一个参数是对象实例obj,name是个字符串，是对象的成员函数名字或者成员变量，default当对象没有这个属相的时候就返回默认值，如果没有提供默认值就返回异常。如：提供不默认写法：1234567891011121314&gt;&gt;&gt; class Test(object):... def func(self):... print 'I am a test'...&gt;&gt;&gt; test = Test() # 实例化一个对象&gt;&gt;&gt; func = getattr(test, 'func') # 使用getattr函数获取func的值&gt;&gt;&gt; func()I am a test&gt;&gt;&gt; func = getattr(test, 'f') # 使用对象没有的属性，则会出现异常Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;AttributeError: 'Test' object has no attribute 'f'&gt;&gt;&gt;提供默认写法如果对象没有该属性可以提供一个默认值。1234&gt;&gt;&gt; func = getattr(test, 'f', None)&gt;&gt;&gt; print funcNone&gt;&gt;&gt;Interpreter 类的源代码下面是 Interpreter 类的源代码，它继承自 NodeVisitor 类且实现了形式为 visit_NodeType 的不同方法，其中 NodeType 会被如 BinOp, Num 等类名替换：12345678910111213141516class Interpreter(NodeVisitor): def __init__(self, parser): self.parser = parser def visit_BinOp(self, node): if node.op.type == PLUS: return self.visit(node.left) + self.visit(node.right) elif node.op.type == MINUS: return self.visit(node.left) - self.visit(node.right) elif node.op.type == MUL: return self.visit(node.left) * self.visit(node.right) elif node.op.type == DIV: return self.visit(node.left) / self.visit(node.right) def visit_Num(self, node): return node.value关于以上代码有两点值得在这里提一下：第一，操作 AST 结点的访问器(也就是对AST数据的操作)的代码 和 AST 结点(即，AST的数据结构)本身 分离（解耦了）。可以看到 AST 结点类(BinOp 和 Num)没有提供任何代码来操作存储在这些结点中的数据，该逻辑被封装在了实现 NodeVisitor 的 Interpreter 类中。（也就是对数据的操作在NodeVisitor 的 Interpreter 类中）。第二，在NodeVisitor的访问函数中，不像这样使用一个巨大的if语句:123456789101112131415def visit(node): node_type = type(node).__name__ if node_type == 'BinOp': return self.visit_BinOp(node) elif node_type == 'Num': return self.visit_Num(node) elif ... # ...#####或者##########def visit(node): if isinstance(node, BinOp): return self.visit_BinOp(node) elif isinstance(node, Num): return self.visit_Num(node) elif ...NodeVisitor 的 visit 方法非常通用，能根据传入的结点类型来调度适当的方法。正如前面提到的，为了利用这一点，我们的解释器继承了 NodeVisitor 类并实现了必要的方法。 因此：如果传递给 visit 函数的结点是 BinOp，那么visit 函数就会调用 visit_BinOp 方法。如果传递给 visit函数的结点是 Num,那么 visit 函数就会调用visit_Num 方 法，等等。花此时间研究一下这个方法（Python 的标准模块 ast 也使用了相同的机制来遍历结点）， 因为我们将来会用很多新的 visit_NodeType 方法来扩展我们的解释器。现在，让我们手工为表达式 2 * 7 + 3 建立一个 AST 并把它传递给解释器，通过对该表达式求值看看运行中的 visit 方法。下面是你从 Python shell 中尝试的方法：123456789101112131415161718&gt;&gt;&gt; from spi import Token, MUL, PLUS, INTEGER, Num, BinOp&gt;&gt;&gt;&gt;&gt;&gt; mul_token = Token(MUL, '*')&gt;&gt;&gt; plus_token = Token(PLUS, '+')&gt;&gt;&gt; mul_node = BinOp(... left=Num(Token(INTEGER, 2)),... op=mul_token,... right=Num(Token(INTEGER, 7))... )&gt;&gt;&gt; add_node = BinOp(... left=mul_node,... op=plus_token,... right=Num(Token(INTEGER, 3))... )&gt;&gt;&gt; from spi import Interpreter&gt;&gt;&gt; inter = Interpreter(None)&gt;&gt;&gt; inter.visit(add_node)17如你所见，我把表达式树的根结点传递给了 visit 方法，这一行为触发了树的遍历，遍历调用了 Interpreter 类正确的方法(visit_BinOp 和 visit_Num)并生成了结果。完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264\"\"\" SPI - Simple Pascal Interpreter \"\"\"# Token types## EOF (end-of-file) token is used to indicate that# there is no more input left for lexical analysisINTEGER, PLUS, MINUS, MUL, DIV, LPAREN, RPAREN, EOF = ( 'INTEGER', 'PLUS', 'MINUS', 'MUL', 'DIV', '(', ')', 'EOF')class Token(object): def __init__(self, type, value): self.type = type self.value = value def __str__(self): \"\"\"String representation of the class instance. Examples: Token(INTEGER, 3) Token(PLUS, '+') Token(MUL, '*') \"\"\" return 'Token(&#123;type&#125;, &#123;value&#125;)'.format( type=self.type, value=repr(self.value) ) def __repr__(self): return self.__str__()################################################################################ ## LEXER ## ################################################################################class Lexer(object): def __init__(self, text): # client string input, e.g. \"4 + 2 * 3 - 6 / 2\" self.text = text # self.pos is an index into self.text self.pos = 0 self.current_char = self.text[self.pos] def error(self): raise Exception('Invalid character') def advance(self): \"\"\"Advance the `pos` pointer and set the `current_char` variable.\"\"\" self.pos += 1 if self.pos &gt; len(self.text) - 1: self.current_char = None # Indicates end of input else: self.current_char = self.text[self.pos] def skip_whitespace(self): while self.current_char is not None and self.current_char.isspace(): self.advance() def integer(self): \"\"\"Return a (multidigit) integer consumed from the input.\"\"\" result = '' while self.current_char is not None and self.current_char.isdigit(): result += self.current_char self.advance() return int(result) def get_next_token(self): \"\"\"Lexical analyzer (also known as scanner or tokenizer) This method is responsible for breaking a sentence apart into tokens. One token at a time. \"\"\" while self.current_char is not None: if self.current_char.isspace(): self.skip_whitespace() continue if self.current_char.isdigit(): return Token(INTEGER, self.integer()) if self.current_char == '+': self.advance() return Token(PLUS, '+') if self.current_char == '-': self.advance() return Token(MINUS, '-') if self.current_char == '*': self.advance() return Token(MUL, '*') if self.current_char == '/': self.advance() return Token(DIV, '/') if self.current_char == '(': self.advance() return Token(LPAREN, '(') if self.current_char == ')': self.advance() return Token(RPAREN, ')') self.error() return Token(EOF, None)################################################################################ ## PARSER ## ################################################################################class AST(object): pass # 表示定义留空class BinOp(AST): def __init__(self, left, op, right): self.left = left self.token = self.op = op self.right = rightclass Num(AST): def __init__(self, token): self.token = token self.value = token.valueclass Parser(object): def __init__(self, lexer): self.lexer = lexer # set current token to the first token taken from the input self.current_token = self.lexer.get_next_token() def error(self): raise Exception('Invalid syntax') def eat(self, token_type): # compare the current token type with the passed token # type and if they match then \"eat\" the current token # and assign the next token to the self.current_token, # otherwise raise an exception. if self.current_token.type == token_type: self.current_token = self.lexer.get_next_token() else: self.error() def factor(self): \"\"\"factor : INTEGER | LPAREN expr RPAREN\"\"\" token = self.current_token if token.type == INTEGER: self.eat(INTEGER) return Num(token) elif token.type == LPAREN: self.eat(LPAREN) node = self.expr() self.eat(RPAREN) return node def term(self): \"\"\"term : factor ((MUL | DIV) factor)*\"\"\" node = self.factor() while self.current_token.type in (MUL, DIV): token = self.current_token if token.type == MUL: self.eat(MUL) elif token.type == DIV: self.eat(DIV) node = BinOp(left=node, op=token, right=self.factor()) return node def expr(self): \"\"\" expr : term ((PLUS | MINUS) term)* term : factor ((MUL | DIV) factor)* factor : INTEGER | LPAREN expr RPAREN \"\"\" node = self.term() while self.current_token.type in (PLUS, MINUS): token = self.current_token if token.type == PLUS: self.eat(PLUS) elif token.type == MINUS: self.eat(MINUS) node = BinOp(left=node, op=token, right=self.term()) return node def parse(self): return self.expr()################################################################################ ## INTERPRETER ## ################################################################################class NodeVisitor(object): def visit(self, node): method_name = 'visit_' + type(node).__name__ visitor = getattr(self, method_name, self.generic_visit) return visitor(node) def generic_visit(self, node): raise Exception('No visit_&#123;&#125; method'.format(type(node).__name__))class Interpreter(NodeVisitor): def __init__(self, parser): self.parser = parser def visit_BinOp(self, node): if node.op.type == PLUS: return self.visit(node.left) + self.visit(node.right) elif node.op.type == MINUS: return self.visit(node.left) - self.visit(node.right) elif node.op.type == MUL: return self.visit(node.left) * self.visit(node.right) elif node.op.type == DIV: return self.visit(node.left) / self.visit(node.right) def visit_Num(self, node): return node.value def interpret(self): tree = self.parser.parse() return self.visit(tree)def main(): while True: try: try: text = raw_input('spi&gt; ') except NameError: # Python3 text = input('spi&gt; ') except EOFError: break if not text: continue lexer = Lexer(text) parser = Parser(lexer) interpreter = Interpreter(parser) result = interpreter.interpret() print(result)if __name__ == '__main__': main()将以上代码保存到名为 spi.py 的文件中，或者直接从 GitHub 下载。自己试一试，确认 你的新的基于树的解释器可以正确地对算术表达式进行求值。下面是某次运行过程：1234567$ python spi.pyspi&gt; 7 + 3 * (10 / (12 / (3 + 1) - 1))22spi&gt; 7 + 3 * (10 / (12 / (3 + 1) - 1)) / (2 + 3) - 5 - 3 + (8)10spi&gt; 7 + (((3 + 2)))12小结今天你学习了关于解析树和 AST，如何构建 AST 以及遍历表示输入的 AST 并解释执行。你还修改了 parser 和 interpreter 并将这两部分解开了。现在 lexer, parser 和 interpreter 之间的接口看起来像这样：你可以把它读作“parser 从 lexer 中 得到 token 然后返回生成的 AST 给 Interpreter 进行遍历并解释执行所给输入”。递归这就是今天的所有内容，但在总结之前我还想简单地聊一聊递归下降 (recursive-descent) parser，即是仅仅给出它的定义。定义就是：一个 递归下降parser 就 是一个自顶向下的 parser，它使用一组递归过程来处理输入。自顶向下反映了 parser 从 构建解析树的顶部结点开始逐渐构建更低的结点这一事实。梳理本节与part6相比主要添加了AST：Lexer与part6中的是一样的，还是将输入的text分析转换为token。(这也是词法分析器的功能)Parser相比part6，它添加了构造AST的内容：添加了三个类：AST()：是一个基类BinOp(AST)：继承于AST()，主要功能是实现二元操作符binary operator 。（这里只有四种：加、减、乘、除法）Num(AST)：继承于AST()，它主要是表示AST中的整数integer token（它将保存一个 INTEGER token 和该 token 的值）第二个变化就是实现语法解析的这三个函数term、factor、expr中的返回的不在是result变量了，而是返回一个结点node。Interpreter：通过词法分析、语法分析之后，开始解释语法分析之后的算式，计算出它的结果，用Interpreter来解释：增添了访问者模式：将 对数据的操作(对数据的操作在interpreter中完成：访问、解释) 和 数据结构(数据结构 在parser中的三个类中构建) 进行分离（解耦合）。使得操作集合可相对自由地演化。这里通过创建 NodeVisitor()类 实现访问者模式。实现了通过什么方式去访问生成的AST又通过Interpreter（继承于 NodeVisitor()类）来实现解释生成的AST最后，再次提醒一下：之前的那几小结，我们都是把interpreter的代码和parser的代码混在一起，但这一小节我们把interpreter的代码和parser的代码分开了。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let's Build A Simple Interpreter","slug":"Let-s-Build-A-Simple-Interpreter","permalink":"https://www.longlongqin.top/tags/Let-s-Build-A-Simple-Interpreter/"}]},{"title":"Let’s Build A Simple Interpreter 6","slug":"学习笔记/Let's Build A Simple Interpreter/LSBASI-6","date":"2020-03-12T04:55:57.000Z","updated":"2020-03-17T09:40:01.085Z","comments":true,"path":"archives/167c.html","link":"","permalink":"https://www.longlongqin.top/archives/167c.html","excerpt":"新增了括号运算(parenthesized expressions)","text":"新增了括号运算(parenthesized expressions)原文链接：https://ruslanspivak.com/lsbasi-part6/本文在前面的基础上，新增了括号运算(parenthesized expressions)，如： 7 + 3 * (10 / (12 / (3 + 1) - 1))所以需要在part5中的语法基础上，进行修改，修改后的语法如下图：从上面的图可以看出来,在part6中，expr和term和part5中一样，唯一变的是factor的产生式 (production)。它新添加了两个 terminal ：LPAREN：表示一个左括号 left parenthesis ‘( ‘RPAREN：表示一个右括号 right parenthesis ‘)’还新添加了一个非终端符：exprexpr添加在两个括号之间下面是factor的语法图：（这里用到了递归）然后，再放一下没有改变的（与part5相同）expr、term的语法图：现在看一下算式：2 * (7 + 3) 的分解过程吧：现在把语法转换成代码。下面这两条是代码中主要改变的部分：Lexer被修改，使其在原来的基础上可以返回另外两个token：左括号LPAREN 、右括号RPARENInterpreter类的factor被修改，修改之后不仅可以解析整数integer，还可以解析括号表达式(parenthesized expressions)下面就是本小节的代码部分：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194# Token types## EOF (end-of-file) token is used to indicate that# there is no more input left for lexical analysisINTEGER, PLUS, MINUS, MUL, DIV, LPAREN, RPAREN, EOF = ( 'INTEGER', 'PLUS', 'MINUS', 'MUL', 'DIV', '(', ')', 'EOF')class Token(object): def __init__(self, type, value): self.type = type self.value = value def __str__(self): \"\"\"String representation of the class instance. Examples: Token(INTEGER, 3) Token(PLUS, '+') Token(MUL, '*') \"\"\" return 'Token(&#123;type&#125;, &#123;value&#125;)'.format( type=self.type, value=repr(self.value) ) def __repr__(self): return self.__str__()class Lexer(object): def __init__(self, text): # client string input, e.g. \"4 + 2 * 3 - 6 / 2\" self.text = text # self.pos is an index into self.text self.pos = 0 self.current_char = self.text[self.pos] def error(self): raise Exception('Invalid character') def advance(self): \"\"\"Advance the `pos` pointer and set the `current_char` variable.\"\"\" self.pos += 1 if self.pos &gt; len(self.text) - 1: self.current_char = None # Indicates end of input else: self.current_char = self.text[self.pos] def skip_whitespace(self): while self.current_char is not None and self.current_char.isspace(): self.advance() def integer(self): \"\"\"Return a (multidigit) integer consumed from the input.\"\"\" result = '' while self.current_char is not None and self.current_char.isdigit(): result += self.current_char self.advance() return int(result) def get_next_token(self): \"\"\"Lexical analyzer (also known as scanner or tokenizer) This method is responsible for breaking a sentence apart into tokens. One token at a time. \"\"\" while self.current_char is not None: if self.current_char.isspace(): self.skip_whitespace() continue if self.current_char.isdigit(): return Token(INTEGER, self.integer()) if self.current_char == '+': self.advance() return Token(PLUS, '+') if self.current_char == '-': self.advance() return Token(MINUS, '-') if self.current_char == '*': self.advance() return Token(MUL, '*') if self.current_char == '/': self.advance() return Token(DIV, '/') if self.current_char == '(': self.advance() return Token(LPAREN, '(') if self.current_char == ')': self.advance() return Token(RPAREN, ')') self.error() return Token(EOF, None)class Interpreter(object): def __init__(self, lexer): self.lexer = lexer # set current token to the first token taken from the input self.current_token = self.lexer.get_next_token() def error(self): raise Exception('Invalid syntax') def eat(self, token_type): # compare the current token type with the passed token # type and if they match then \"eat\" the current token # and assign the next token to the self.current_token, # otherwise raise an exception. if self.current_token.type == token_type: self.current_token = self.lexer.get_next_token() else: self.error() def factor(self): \"\"\"factor : INTEGER | LPAREN expr RPAREN\"\"\" token = self.current_token if token.type == INTEGER: self.eat(INTEGER) return token.value elif token.type == LPAREN: self.eat(LPAREN) result = self.expr() self.eat(RPAREN) return result def term(self): \"\"\"term : factor ((MUL | DIV) factor)*\"\"\" result = self.factor() while self.current_token.type in (MUL, DIV): token = self.current_token if token.type == MUL: self.eat(MUL) result = result * self.factor() elif token.type == DIV: self.eat(DIV) result = result / self.factor() return result def expr(self): \"\"\"Arithmetic expression parser / interpreter. calc&gt; 7 + 3 * (10 / (12 / (3 + 1) - 1)) 22 expr : term ((PLUS | MINUS) term)* term : factor ((MUL | DIV) factor)* factor : INTEGER | LPAREN expr RPAREN \"\"\" result = self.term() while self.current_token.type in (PLUS, MINUS): token = self.current_token if token.type == PLUS: self.eat(PLUS) result = result + self.term() elif token.type == MINUS: self.eat(MINUS) result = result - self.term() return resultdef main(): while True: try: # To run under Python3 replace 'raw_input' call # with 'input' text = raw_input('calc&gt; ') except EOFError: break if not text: continue lexer = Lexer(text) interpreter = Interpreter(lexer) result = interpreter.expr() print(result)if __name__ == '__main__': main()","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let's Build A Simple Interpreter","slug":"Let-s-Build-A-Simple-Interpreter","permalink":"https://www.longlongqin.top/tags/Let-s-Build-A-Simple-Interpreter/"}]},{"title":"Let’s Build A Simple Interpreter 5","slug":"学习笔记/Let's Build A Simple Interpreter/LSBASI-5","date":"2020-03-11T09:45:49.000Z","updated":"2020-03-18T13:32:38.306Z","comments":true,"path":"archives/173c.html","link":"","permalink":"https://www.longlongqin.top/archives/173c.html","excerpt":"本文为这一系列的part5，第五小节。这次将写一个可移植性加减乘除混合运算的解释器。","text":"本文为这一系列的part5，第五小节。这次将写一个可移植性加减乘除混合运算的解释器。原文链接：https://ruslanspivak.com/lsbasi-part5/本文为这一系列的part5，第五小节。这次将写一个可移植性加减乘除混合运算的解释器。在开始写代码之前，我们需要知道一些，比如：结合律、操作符(operator)的优先级(precedence)结合律(associativity)比如，7+3+1等同于(7+3)+1 ，7 - 3 - 1 等同于 (7 - 3) - 1。这没有什么奇怪的。但是再比如： 7 - 3 - 1 与 7 - (3 - 1) 的结果就不一样了。其实：加、减、乘、除 这些操作符(operator)是左结合(left-associative)。比如， 7 + 3 + 1 中的 操作数(operand) 3，它的左右都是 加号 ，但是这个操作数3是与它左边的加号“+”结合的， 所以加法是左结合。那加减乘除混合时，如 7 + 5 * 2 是否还是遵循左结合律呢？很显然，不遵循，因为 (7 + 5) * 2 不等于 7 + 5 * 2 。由此可知：​ 加法和减法是一类，所以它们在一起组成的运算是左结合；乘法和除法是一类，所以他们在一起组成的运算是左结合。（即，左结合律只适用于同一类的操作符(operator)）优先级(precedence)那我们如何规定这种加减乘除（这两类操作符(operator)）同时出现时的运算规则呢？（实际上我们都知道，但是这里是为实现代码来做出一种运算规则）在 7 + 5 * 2中，如果操作符“”能先比操作符“+”到他的操作数5，就说，操作符“”有更高的优先级(higher precedence)。在实际中我们也在用，也知道。乘除的优先级要高于加减法。好了，现在我们开始用表格来表示操作符的结合律与优先级：由上表可知：+ and - 是优先级相同，都是左结合；* and / 优先级相同，也都是左结合；我们还可以根据上面的优先级表格来制定一个语法规则：优先级相同的每一级都定义一个非终端符(non-terminal)。其中每个产生式(production)的body中应该包含:算数运算符(arithmetic operators) &amp; 非终端符(这里的非终端又参与构成下一较高的优先级的规则(产生式)的一部分)创建一个表示 基本表达式的非终端符factor，本文中指integer。一般的规则是：如果你有N个优先级，那么你就需要N+1个非终端符（一类是每一层优先级的一个非终端符，一类是表示基本表达式单元）构建语法(grammars)现在根据上面的规则来构建语法：由规则1，我们将定义两个非终结符(non-terminal)，一个是leve1的non-terminal叫做expr，另一个是level2的non-terminal叫做term。然后根据规则2，我们需要定义一个叫做factor的non-terminal来作为一个基本的表达式单元，integers。这个语法的开始符号（start symbol ）叫做expr。它的产生式(production)的body含有：1️⃣表示level2的操作符(在这指的是+ and - )，2️⃣和一个非终端符term(这个term是下一层优先级（更高的）level1 的一个产生式)开始符号（S）：最大的语法单位 或 最重要的语法单位。（如上面的那个英文句子中的，最大的语法单位是：句子。）非终端符term的production(产生式)的body包含:1️⃣表示level1的操作符(在这指的是 * and /)。2️⃣还有一个非终端符factor来表示基本的表达式单元，integers非终端符factor包含：1️⃣一个integer上面的三幅图是语法、语法图的一部分，这在之前的文章中也出现过。但现在需要将上面的三幅图结合在一起来考虑结合律和优先级（ associativity and precedence ）下面是本文的语法对应的语法图：上面语法图的每一个小方框都是其他语法图的：函数调用（“method call”）。如果你以表达式 7 + 5 * 2 为例并从顶 层图 expr 开始逐步分解到最底层的图 factor, 你应该可以看到位于中间的图的高优 先级操作符*和/会比上面的图的操作符+和-先执行。为了解释清楚运算符的优先级，让我们看看使用上面语法和句法图来分解相同算术表达式 7 + 5 * 2 的过程。这只是另一种展示高优先级运算符 先于 低优先级运算符执行这个事实的 方式。语法转换成代码让我们使用part 4中的准则把该语法转化成代码，看看它怎么工作，先看一张上面放过的语法图：下面是能处理可以包含任意数量加减乘除操作符的算术表达式的计算器的完整代码。相比于part 4代码的主要变化有：Lexer 类现在可以把+,-,*和/都 token 化了（没什么新方法，我们只是把前面文章中 的代码合并到一个类中来支持所有这些 token）回想语法中的每条规则（产生式）R都要变成一个同名的方法，且对该规则的引用都要变 成一个方法调用 R() 这一点。现在 Interpreter 类有了三个方法来对应语法中的非 终结符： expr, term, factor.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182# Token types## EOF (end-of-file) token is used to indicate that# there is no more input left for lexical analysisINTEGER, PLUS, MINUS, MUL, DIV, EOF = ( 'INTEGER', 'PLUS', 'MINUS', 'MUL', 'DIV', 'EOF')class Token(object): def __init__(self, type, value): # token type: INTEGER, PLUS, MINUS, MUL, DIV, or EOF self.type = type # token value: non-negative integer value, '+', '-', '*', '/', or None self.value = value def __str__(self): \"\"\"String representation of the class instance. Examples: Token(INTEGER, 3) Token(PLUS, '+') Token(MUL, '*') \"\"\" return 'Token(&#123;type&#125;, &#123;value&#125;)'.format( type=self.type, value=repr(self.value) ) def __repr__(self): return self.__str__()class Lexer(object): def __init__(self, text): # client string input, e.g. \"3 * 5\", \"12 / 3 * 4\", etc self.text = text # self.pos is an index into self.text self.pos = 0 self.current_char = self.text[self.pos] def error(self): raise Exception('Invalid character') def advance(self): \"\"\"Advance the `pos` pointer and set the `current_char` variable.\"\"\" self.pos += 1 if self.pos &gt; len(self.text) - 1: self.current_char = None # Indicates end of input else: self.current_char = self.text[self.pos] def skip_whitespace(self): while self.current_char is not None and self.current_char.isspace(): self.advance() def integer(self): \"\"\"Return a (multidigit) integer consumed from the input.\"\"\" result = '' while self.current_char is not None and self.current_char.isdigit(): result += self.current_char self.advance() return int(result) def get_next_token(self): \"\"\"Lexical analyzer (also known as scanner or tokenizer) This method is responsible for breaking a sentence apart into tokens. One token at a time. \"\"\" while self.current_char is not None: if self.current_char.isspace(): self.skip_whitespace() continue if self.current_char.isdigit(): return Token(INTEGER, self.integer()) if self.current_char == '+': self.advance() return Token(PLUS, '+') if self.current_char == '-': self.advance() return Token(MINUS, '-') if self.current_char == '*': self.advance() return Token(MUL, '*') if self.current_char == '/': self.advance() return Token(DIV, '/') self.error() return Token(EOF, None)class Interpreter(object): def __init__(self, lexer): self.lexer = lexer # set current token to the first token taken from the input self.current_token = self.lexer.get_next_token() def error(self): raise Exception('Invalid syntax') def eat(self, token_type): # compare the current token type with the passed token # type and if they match then \"eat\" the current token # and assign the next token to the self.current_token, # otherwise raise an exception. if self.current_token.type == token_type: self.current_token = self.lexer.get_next_token() else: self.error() def factor(self): \"\"\"factor : INTEGER\"\"\" token = self.current_token self.eat(INTEGER) return token.value def term(self): \"\"\"term : factor ((MUL | DIV) factor)*\"\"\" result = self.factor() while self.current_token.type in (MUL, DIV): token = self.current_token if token.type == MUL: self.eat(MUL) result = result * self.factor() elif token.type == DIV: self.eat(DIV) result = result / self.factor() return result def expr(self): \"\"\"Arithmetic expression parser / interpreter. calc&gt; 14 + 2 * 3 - 6 / 2 17 expr : term ((PLUS | MINUS) term)* term : factor ((MUL | DIV) factor)* factor : INTEGER \"\"\" result = self.term() while self.current_token.type in (PLUS, MINUS): token = self.current_token if token.type == PLUS: self.eat(PLUS) result = result + self.term() elif token.type == MINUS: self.eat(MINUS) result = result - self.term() return resultdef main(): while True: try: # To run under Python3 replace 'raw_input' call # with 'input' text = raw_input('calc&gt; ') except EOFError: break if not text: continue lexer = Lexer(text) interpreter = Interpreter(lexer) result = interpreter.expr() print(result)if __name__ == '__main__': main()将以上代码保存到名为 calc5.py 中，或者直接从 GitHub 上下载。和以往一样，自己尝 试一下，确认解释器可以对包含不同优先级操作符的算术表达式进行求值。梳理代码中有三个类(class)，他们中的函数及作用：Token：__init__：初始化实例__str__：字符串形式__repr__：字符串形式在Python中，所有以“_”双下划线包起来的方法，都统称为“Magic Method”（魔术方法）,例如类的初始化方法 __init_repr(self)定义当被 repr() 调用时的行为str(self)定义当被 str() 调用时的行为Lexer用于词法分析：__init__：初始化实例error：错误提示advance：使pos前进一个位置skip_whitespace：略过空格integer：识别整数（可以识别多位数）get_next_token：获得一个token（其实我觉得叫做：get_token_and_to_next更合适）Interpreter用于语法分析：__init__：初始化实例error：错误提示eat：负责检测当前的token.type与传入的token_type是否相同。若相同，则将当前的token“吃了”，然后把当前token的下一个token分配给current_token。下面就是语法分析的核心了，由上面的分析直到，它由：expr、term、factor构成。梳理完毕。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let's Build A Simple Interpreter","slug":"Let-s-Build-A-Simple-Interpreter","permalink":"https://www.longlongqin.top/tags/Let-s-Build-A-Simple-Interpreter/"}]},{"title":"Let’s Build A Simple Interpreter 4","slug":"学习笔记/Let's Build A Simple Interpreter/LSBASI-4","date":"2020-03-10T09:27:30.000Z","updated":"2020-03-24T07:56:38.973Z","comments":true,"path":"archives/3b16.html","link":"","permalink":"https://www.longlongqin.top/archives/3b16.html","excerpt":"","text":"原文链接：https://ruslanspivak.com/lsbasi-part4/在前面的文章中你学会了怎样识别和解释包含任意数量的加减操作的算术表达式，例如“7 - 3 + 2 - 1”。还学会了句法图以及它们如何被用来表示一门编程语言的语法。今天你将会学习解析(parse)和解释(interpret)包含任意乘除操作的算术表达式，例如“7 * 4 / 2 * 3”。在这篇文章中使用的是整数除法，所以对于表达式“9 / 4”来说，结果是一个 整数：2。我今天会讲很多另一个表示编程语言句法的广泛使用的表示法，叫 上下文无关语法 (context-free grammars, 简记为 grammars)或 BNF (Backus-Naur Form)。为了这篇文章的目的，我不会使用纯 BNF 记法，而更像是一个修改过的 EBNF 记法。文法(语法)：描述语言的语法结构的形式规则。上下文无关语法就是说这个文法中所有的产生式左边只有一个非终结符，比如：S -&gt; aSbS -&gt; ab这个文法有两个产生式，每个产生式左边只有一个非终结符S，这就是上下文无关文法，因为你只要找到符合产生式右边的串，就可以把它归约为对应的非终结符。比如：aSb -&gt; aaSbbS -&gt; ab这就是上下文相关文法，因为它的第一个产生式左边有不止一个符号，所以你在匹配这个产生式中的S的时候必需确保这个S有正确的“上下文”，也就是左边的a和右边的b，所以叫上下文相关文法。作者：徐辰链接：https://www.zhihu.com/question/21833944/answer/40689967来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。以下是一些使用语法的原因：语法使用了一种简明的方式来描述一门编程语言的句法。不像语法图，语法非常紧凑。 在以后的文章中，你会看到我越来越多地使用语法。语法可以做为文档保存。即使对从头开始写解析器(parser)来说，语法也是一个好的入手点。很多时候通过遵循 一套简单的规则你就可以把语法转化成代码。有一套工具，叫解析器生成器(parser generator)，可以把语法做为输入并自动根据它为你生成一个解析器。我会以后在这个系列中谈到这些工具。语法机制现在，我们来聊聊语法的机制方面：下面的语法描述了算术表达式，像“7 * 4 / 2 * 3”这样的（这只是该语法可以生成的许多表达式之一）：语法是由一系列规则组成的，也被称为产生式(production)。我们的语法中有两条规则(产生式)：1、一条规则由：一个非终结符(叫做 head或生成式的左边) + 一个分号（:）+ 一系列终结符 和/或 非终结符(叫做 body 或 右边)：2、在上面展示的语法中，像 MUL, DIV, 或 INTEGER 这样的 token 被称为 终结符(terminals), expr factor 这样的变量被称为 非终结符(not-terminals).第一条规则左边的非终结符被叫做 开始符号(start symbol). 在我们的语法中，开始符号是 expr:你可以这么理解 expr 这条规则：“expr 是一个 factor 后面可选地跟一个乘或除运算符再跟 另一个 factor，后面也相应可选地跟一个乘或除运算符再跟另一个 factor，如此重复”。factor 是什么？对于本文来说 factor 就是一个整数。语法中的符号让我们快速地过一遍语法中的符号及它们的意义。|多选一。竖线表示“或”。所以 (MUL | DIV) 表示 MUL 或 DIV(...)被括号包围表示把终结符 和/或 非终结符组成一组，就像 (MUL | DIV)(...)*分组中的内容被匹配 0 或 多次。语法通过解释可以组成什么样的句子来定义一门语言。通过语法派生出算术表达式的方式为：首先从开始符号 expr 开始，然后反复地使用所包含的非终结符的规则替换该非终结符， 直到生成一个只包含终结符的句子。语法能组成的句子构成了一门语言。下面举例说明：例1，下面是语法如何派生出表达式 3:例2，下面是语法如何派生出表达式 3 * 7:例3，下面是语法如何派生出表达式 3 * 7 / 2:将语法变成代码下面是一些我们在把语法转化成源代码时会用到的==四个准则==。按照这些准则，你真的就可以把语法翻译成一个可工作的 parser:对于语法中定义的每个规则 R，将它做成一个有相同名字的方法，对该规则的引用就变成了一个方法调用：R()。该方法的方法体遵循该规则的步骤，过程中使用相同的准则。多选一 (a1|a2|aN) 变成 if-elif-else 语句可选组 (...)* 变成一个可以执行 0 或多次的 while 循环（can loop over zero or more times）每个 Token 记为 T 变成一个 eat 方法调用: eat(T). eat 方法的工作是 当它匹配到当前的向前看 (lookahead) token 就消耗掉它，然后从 lexer 中得到一个新 token 并将它赋值给内部变量 current_token.这些准则看上去像这样：让我们继续并遵循上述准则把我们的语法转化为代码。我们的语法中有两条规则： expr 和 factor. 我们从 factor 规则（生成式）开始。 根据准则，需要新建一个名为 factor 的方法（准则1)，它调用了一次 eat 方法来消耗INTEGER token （准则4)：12def factor(self): #factor就是指的integer型数值 self.eat(INTEGER)expr 规则变成了 expr 方法（还是准则1）。规则体(body)开始的 factor 引用 变成了对 factor() 方法的调用。可行组 (...)* 变成了一个 while 循环，多选一 (MUL|DIV) 变成了一个 if-elif-else 语句。把这些片段合并在一起就得到了下面的expr 方法：1234567891011def expr(self): self.factor() #语法准则中的第一个factor while self.current_token.type in (MUL, DIV): token = self.current_token if token.type == MUL: self.eat(MUL) self.factor() elif token.type == DIV: self.eat(DIV) self.factor()原作者将本文的代码放在了文件 parser.py 中，它包含了 lexer 和 parser 但没有interpreter。你可以直接从 GitHub下载并尝试一下。它包含有一个 interpreter 提示符，你可以输入表达式来查看它是否合法，即查看根据语法建立的 parser 是否可以识别出表达式。下面是在我笔记本上的一次尝试：123456789101112131415161718192021$ python parser.pycalc&gt; 3calc&gt; 3 * 7calc&gt; 3 * 7 / 2calc&gt; 3 *Traceback (most recent call last): File \"parser.py\", line 155, in &lt;module&gt; main() File \"parser.py\", line 151, in main parser.parse() File \"parser.py\", line 136, in parse self.expr() File \"parser.py\", line 130, in expr self.factor() File \"parser.py\", line 114, in factor self.eat(INTEGER) File \"parser.py\", line 107, in eat self.error() File \"parser.py\", line 97, in error raise Exception('Invalid syntax')Exception: Invalid syntax这里再次提起语法图。这是相同的 expr 规则（也叫，产生式(production)）对应的句法图：下面是原作者的关于本文的源码。下面是可以处理包含任意数量整数 乘除（整数除法）操作的合法的算术表达式的计算器代码。这里把词法分析器重构 到了一个单独的类 Lexer 中，并让 Interpreter 类使用 Lexer 实例做为参数：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156# Token types## EOF (end-of-file) token is used to indicate that# there is no more input left for lexical analysisINTEGER, MUL, DIV, EOF = 'INTEGER', 'MUL', 'DIV', 'EOF'class Token(object): def __init__(self, type, value): # token type: INTEGER, MUL, DIV, or EOF self.type = type # token value: non-negative integer value, '*', '/', or None self.value = value def __str__(self): \"\"\"String representation of the class instance. Examples: Token(INTEGER, 3) Token(MUL, '*') \"\"\" return 'Token(&#123;type&#125;, &#123;value&#125;)'.format( type=self.type, value=repr(self.value) ) def __repr__(self): return self.__str__()#词法分析class Lexer(object): def __init__(self, text): # client string input, e.g. \"3 * 5\", \"12 / 3 * 4\", etc self.text = text # self.pos is an index into self.text self.pos = 0 self.current_char = self.text[self.pos] def error(self): raise Exception('Invalid character') def advance(self): \"\"\"Advance the `pos` pointer and set the `current_char` variable.\"\"\" self.pos += 1 if self.pos &gt; len(self.text) - 1: self.current_char = None # Indicates end of input else: self.current_char = self.text[self.pos] def skip_whitespace(self): while self.current_char is not None and self.current_char.isspace(): self.advance() def integer(self): \"\"\"Return a (multidigit) integer consumed from the input.\"\"\" result = '' while self.current_char is not None and self.current_char.isdigit(): result += self.current_char self.advance() return int(result) #不如叫做：get_token_and_next def get_next_token(self): \"\"\"Lexical analyzer (also known as scanner or tokenizer) This method is responsible for breaking a sentence apart into tokens. One token at a time. \"\"\" while self.current_char is not None: if self.current_char.isspace(): self.skip_whitespace() continue if self.current_char.isdigit(): return Token(INTEGER, self.integer()) if self.current_char == '*': self.advance() return Token(MUL, '*') if self.current_char == '/': self.advance() return Token(DIV, '/') self.error() return Token(EOF, None)class Interpreter(object): def __init__(self, lexer): self.lexer = lexer # set current token to the first token taken from the input self.current_token = self.lexer.get_next_token() def error(self): raise Exception('Invalid syntax') def eat(self, token_type): # compare the current token type with the passed token # type and if they match then \"eat\" the current token # and assign the next token to the self.current_token, # otherwise raise an exception. if self.current_token.type == token_type: self.current_token = self.lexer.get_next_token() else: self.error() def factor(self): \"\"\"Return an INTEGER token value. factor : INTEGER \"\"\" token = self.current_token self.eat(INTEGER) return token.value def expr(self): \"\"\"Arithmetic expression parser / interpreter. expr : factor ((MUL | DIV) factor)* factor : INTEGER \"\"\" result = self.factor() while self.current_token.type in (MUL, DIV): token = self.current_token if token.type == MUL: self.eat(MUL) result = result * self.factor() elif token.type == DIV: self.eat(DIV) result = result / self.factor() return resultdef main(): while True: try: # To run under Python3 replace 'raw_input' call # with 'input' text = raw_input('calc&gt; ') except EOFError: break if not text: continue lexer = Lexer(text) interpreter = Interpreter(lexer) result = interpreter.expr() print(result)if __name__ == '__main__': main()将以上代码保存到名为 calc4.py 中，或者直接从 GitHub 上下载。和以往一样，自己尝 试一下，确认它能工作。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let's Build A Simple Interpreter","slug":"Let-s-Build-A-Simple-Interpreter","permalink":"https://www.longlongqin.top/tags/Let-s-Build-A-Simple-Interpreter/"}]},{"title":"Let’s Build A Simple Interpreter 3","slug":"学习笔记/Let's Build A Simple Interpreter/LSBASI-3","date":"2020-03-10T06:28:09.000Z","updated":"2020-03-24T05:48:57.917Z","comments":true,"path":"archives/f957.html","link":"","permalink":"https://www.longlongqin.top/archives/f957.html","excerpt":"","text":"原文链接：https://ruslanspivak.com/lsbasi-part3/目前为止，你已经学习了如何解释整数相加或相减的算术表达式如“7+3”或“12-9”。今天我 会聊一聊怎样解析（识别）并解释包含多位整数的加减法的算术表达式，如“7 - 3 + 2 - 1”。语法图本文中的算术表达式可以用如下的语法图(syntax diagram)表示：语法图(syntax diagram)：就是程序语言句法规则的图形表示。基本上，语法图从视觉上向你展示了在你的程序语言中哪些语句是允许的哪些是不允许的。句法图很容易阅读：只需跟随箭头所指示的路径即可。一些路径表示选择，一些路径表示循环。你可以这样阅读上面的句法图：一个 term 后面可以跟一个加号或减号，后面又跟另一个 term， 相应地它后面又可以跟一个加号或减号，后面又跟另一个 term，如此循环。你已经读懂了 这幅图片，真的。你可能会疑惑什么是“term”。在这篇文章中“term”就是一个整数。语法图的用途本文中的语法图主要有两个用途：从图形上表示一个编程语言的标准（语法）。用来帮助你编写parser(语法分析器)，你可以通过下面简单的规则将图映射到代码。语法分析器你已经学过了从 token 流中识别组合的过程叫 parsing. 且解释器或编译器中执行这部分任务的叫 parser. parsing也被称为 语法分析 (syntax analysis)，parser也相应地被称为语法分析器(syntax analyzer)，你应该也猜到这点了。根据上面的句法图，下面所有的算术表达式都是合法的：33 + 47 - 3 + 2 - 1因为在不同的程序语言中算术表达式的句法规则都相似，我们可以使用 Python shell 来 “测试”我们的句法图。启动 Python shell 自己试一下：123456&gt;&gt;&gt; 33&gt;&gt;&gt; 3 + 47&gt;&gt;&gt; 7 - 3 + 2 - 15一切正常。但表达式“3+”就不是合法的算术表达式，因为根据句法图加号后面必须跟一个 term（整数）， 否则就是句法错误。两次启动 Python shell 自己查看结果：12345&gt;&gt;&gt; 3 + File \"&lt;stdin&gt;\", line 1 3 + ^SyntaxError: invalid syntax使用 Python shell 来做测试是挺不错的，不过我们还是把上面的句法图映射到代码，用我 们自己的解释器来测试，是吧？从前面的文章（第一部分和第二部分）你知道了 parser 和 interpreter 都在 expr 方 法中。再重复一下，parser只是识别出结构并保证它符合某些规范，interpreter在parser成功识别后对表达式进行求值。下面的代码片段展示了与句语法图相对应的 parser 的代码。语法图中的矩形盒子变成了解析一个整数的 term 方法， expr 方法则只是跟随了语法图的指示：123456789101112131415def term(self): self.eat(INTEGER)def expr(self): # set current token to the first token taken from the input self.current_token = self.get_next_token() self.term() while self.current_token.type in (PLUS, MINUS): token = self.current_token if token.type == PLUS: self.eat(PLUS) self.term() elif token.type == MINUS: self.eat(MINUS) self.term()可以看到 expr 方法首先调用了 term 方法。然后是一个可能执行 0 或多次的循环。 在循环中，parser 根据 token （是加号还是减号）来做选择。Parser 本身并不解释任何事：如果识别到一个表达式它就沉默，否则就抛出一个句法错误。 让我们修改 expr 方法来添加 interpreter 代码：12345678910111213141516171819202122def term(self): \"\"\"Return an INTEGER token value\"\"\" token = self.current_token self.eat(INTEGER) return token.valuedef expr(self): \"\"\"Parser / Interpreter\"\"\" # set current token to the first token taken from the input self.current_token = self.get_next_token() result = self.term() while self.current_token.type in (PLUS, MINUS): token = self.current_token if token.type == PLUS: self.eat(PLUS) result = result += self.term() elif token.type == MINUS: self.eat(MINUS) result = result - self.term() return result因为 interpreter 需要对表达式进行求值，所以 term 方法被修改为返回一个整数值， expr 方法被修改为在适当的地方执行加减法并返回解释的结果。让我们继续前进，来看一下现在解释器的完整代码怎么样？下面是你新版计算器的源代码，它可以处理包含任意多个整数的加减操作的合法算术表达式：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128# Token的类型：'INTEGER', 'PLUS', 'MINUS', 'EOF'# Token的值(value)：整数，'+', '-', or NoneINTEGER, PLUS, MINUS, EOF = 'INTEGER', 'PLUS', 'MINUS', 'EOF'#定义Token类class Token(object): def __init__(self, type, value): self.type = type self.value = value def __str__(self): return 'Token( &#123;type&#125;, &#123;value&#125; ) ' .format( type = self.type , value = repr(self.value) #repr与下面的__repr__不一样，下面的是重构的。 ) def __repr__(self): return self.__str__()class Interpreter(object): def __init__(self, text): self.text = text self.pos = 0 self.currrent_token = None #此时还没有token实例所以是None self.current_char =self.text[self.pos] ########################################################## # Lexer code # ########################################################## def error(self): raise Exception('Invalid syntax') def advance(self): self.pos += 1 if self.pos &gt; len(self.text) -1 : self.current_char =None else: self.current_char = self.text[self.pos] def skip_whitespace(self): while self.current_char is not None and self.current_char.isspace(): self.advance() def integer(self): result = '' while self.current_char is not None and self.current_char.isdigit(): result += self.current_char self.advance() return int(result) #词法分析(分析之后形成一个个的token) def get_next_token(self): while self.current_char is not None: if self.current_char.isspace(): self.skip_whitespace() continue #识别整数 if self.current_char.isdigit(): return Token(INTEGER, self.integer() ) # 识别是否为+ - 运算符号 if self.current_char == '+': self.advance() return Token(PLUS, '+') if self.current_char == '-': self.advance() return Token(MINUS, '-') self.error() return Token(EOF, None) ########################################################## # Parser / Interpreter code # ########################################################## #比较当前的token的类型与传来的类型是否相同 def eat(self, token_type): if self.currrent_token.type == token_type: self.currrent_token = self.get_next_token() else: self.error() #返回一个整型的token的value def term(self): token = self.currrent_token self.eat(INTEGER) return token.value def expr(self): self.currrent_token = self.get_next_token() result = self.term() while self.currrent_token.type in (PLUS , MINUS): #循环是为了算不止一次的加or减法，从而达到混合运算的目的 token = self.currrent_token if token.type == PLUS: self.eat(PLUS) result = result + self.term() elif token.type == MINUS: self.eat(MINUS) result = result - self.term() return result def main(): while True: try: # To run under Python3 replace 'raw_input' call # with 'input' text = input('calc&gt; ') except EOFError: break if not text: continue interpreter = Interpreter(text) result = interpreter.expr() print(result)if __name__ == '__main__': main()将以上代码保存到名为 calc3.py 中，或者直接从 GitHub 上下载。试一试。亲眼看一下 它可以处理之前展示给你的句法图中包含的算术表达式规则。梳理输入字符串表达式（如“2+8-6+1”)，存入变量text中将text进行词法分析，执行此功能的是get_next_token()函数，词法分析会生成一个个的token然后对词法分析之后的token按照规定的语法，进行语法分析，相应函数为expr()最后输出结果","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let's Build A Simple Interpreter","slug":"Let-s-Build-A-Simple-Interpreter","permalink":"https://www.longlongqin.top/tags/Let-s-Build-A-Simple-Interpreter/"}]},{"title":"3、布尔逻辑和逻辑门","slug":"学习笔记/《计算机科学速成课》笔记/3、布尔逻辑和逻辑门","date":"2020-03-09T17:01:26.000Z","updated":"2020-03-17T08:46:49.337Z","comments":true,"path":"archives/87ef.html","link":"","permalink":"https://www.longlongqin.top/archives/87ef.html","excerpt":"计算机最早的是机电设备，一般使用十进制计数，比如用齿轮数来代表十进制。但是其实只用开/关两种状态已经足够表示信息了，将其称为二进制（Binary）。","text":"计算机最早的是机电设备，一般使用十进制计数，比如用齿轮数来代表十进制。但是其实只用开/关两种状态已经足够表示信息了，将其称为二进制（Binary）。在计算机中，当电流流过时，为闭合状态，表示true（1），当没有电流流过时，为断开状态，表示false（0）。但是其实晶体管可以不只是开/关状态，还可以让不同大小的电流通过，一些早期电子计算机，通过对不同电流大小进行划分，可以使用三进制、五进制等等。但问题是，状态越多就越难区分信号，如果存在电噪音，可能就会使状态十分混乱。所以为了让信号更加清晰，可以只使用“开”和“关”两种状态。另一个使用二进制的原因是，有一整个数学分支专门处理“真”和“假”，它已解决了所有法则和运算，即布尔代数（Boolean Algebra）。布尔代数（Boolean Algebra）与逻辑门在布尔代数中，变量的值是true和false，能够对其进行逻辑操作。布尔代数中有三个基本操作：NOT、AND和OR。NOT GATENOT：把输出端（就像水龙头左边部分送水，它送电）接在上面的电极，如果打开输出，电流就可以流过，然后“接地”，输出就没有电流，所以输出是off。当输入关闭时，电流没法接地，就流过了输出，所以输出是on。就像是水龙头一样：​​ NOT操作：把布尔值进行翻转，所以NOT操作的真值表为AND GATEAND：为了实现“AND 门”，我们需要2个晶体管连接在一起，这样有2个输入和1个输出。如果只打开A，不打开B，电流无法留到output，所以输出是false；如果只打开B，不打开A，也一样，电流无法留到output；只有当A、B都打开了，output才有电流。OR GATEOR：实现OR 门除了晶体管还需要额外的线将两个晶体管(transistor)并联起来，即得到OR GATE左侧电极为电源，下方两个电极分别表示两个输入，右侧电极为输出。只要任意一个输入开启，就能使得电源和输出电极接通，使得输出开启；当两个输入都关闭时，就使得电源和输出电极保持断开状态，使得输出保持关闭。由此通过上方的三个组件（NOT门、AND门和OR门）可以构建出更加复杂的组件。另一个常见的布尔操作叫做异或操作。XOR(异或)我们有两个输入，A和B，还有一个输出。先放一个OR门。因为OR和XOR的逻辑表很像，只有一个不同点就是：当两个输入都为true时，XOR输出false，而OR输出true。通过对AND操作真值表取反，再和OR操作真值表进行对比，可以发现，第二三行都为true，而第一四行结果不同，因此只要在这两个结果后面加个AND就能得到XOR的真值表。小结操作真值表：对应的罗基本表示：","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"计算机科学速成课","slug":"计算机科学速成课","permalink":"https://www.longlongqin.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE/"},{"name":"布尔逻辑和逻辑门","slug":"布尔逻辑和逻辑门","permalink":"https://www.longlongqin.top/tags/%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91%E5%92%8C%E9%80%BB%E8%BE%91%E9%97%A8/"}]},{"title":"Let’s Build A Simple Interpreter 2","slug":"学习笔记/Let's Build A Simple Interpreter/LSBASI-2","date":"2020-03-09T13:55:47.000Z","updated":"2020-03-23T09:50:36.594Z","comments":true,"path":"archives/d57d.html","link":"","permalink":"https://www.longlongqin.top/archives/d57d.html","excerpt":"If you learn only methods, you’ll be tied to your methods. But if you learnprinciples, you can devise your own methods.","text":"If you learn only methods, you’ll be tied to your methods. But if you learnprinciples, you can devise your own methods.原文地址：https://ruslanspivak.com/lsbasi-part2/这是第二个版本V2.0，第二个版本较第一个版V1.0，它可以做到：处理输入字符串中任何位置的空白符处理输入中的多位数两个整数相减（版本V1.0中只有加法）下面先给出V2.0的新版计算器的源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152# Token types# EOF (end-of-file) token is used to indicate that# there is no more input left for lexical analysisINTEGER, PLUS, MINUS, EOF = 'INTEGER', 'PLUS', 'MINUS', 'EOF'class Token(): def __init__(self, type, value): # token type: 'INTEGER', 'PLUS', 'MINUS', or 'EOF' self.type = type # token value: non-negative integer value, '+', '-', or None self.value = value def __str__(self): \"\"\"String representation of class instance Examples: Token(INTEGER, 3) Token(PLUS, '+') \"\"\" return f'Token(&#123;self.type&#125;, &#123;self.value&#125;)' def __repr__(self): return self.__str__()##__repr__() 与 __str__() 的主要区别在于，前者在交互式步骤中显示结果，后者在 print 函数中显示结果。 class Interpreter(): def __init__(self, text): # client string input, e.g. \"3 + 5\", \"12 - 5\", etc self.text = text # self.pos is an index into self.text self.pos = 0 # current token instance self.current_token = None self.current_char = self.text[self.pos] def error(self): raise Exception('Error parsing input') ########新增####### def advance(self): \"\"\"Advance the 'pos' pointer and set the 'current_char' variable.\"\"\" self.pos += 1 if self.pos &gt;= len(self.text): self.current_char = None # Indicates end of input else: self.current_char = self.text[self.pos] def skip_whitespace(self): while self.current_char is not None and self.current_char.isspace(): self.advance() def integer(self): \"\"\"Return a (multidigit) integer consumed from the input.\"\"\" result = '' while self.current_char is not None and self.current_char.isdigit(): result += self.current_char self.advance() return int(result) ##新增 完毕##### def get_next_token(self): \"\"\"Lexical analyzer (also known as scanner or tokenizer) This method is responsible for breaking a sentence apart into tokens. \"\"\" while self.current_char is not None: if self.current_char.isspace(): self.skip_whitespace() continue if self.current_char.isdigit(): return Token(INTEGER, self.integer()) if self.current_char == '+': self.advance() return Token(PLUS, '+') if self.current_char == '-': self.advance() return Token(MINUS, '-') self.error() return Token(EOF, None) def eat(self, token_type): # compare the current token type with the passed token # type and if they match then \"eat\" the current token # and assign the next token to the self.current_token, # otherwise raise an exception. if self.current_token.type == token_type: self.current_token = self.get_next_token() else: self.error() def expr(self): \"\"\"Parser / Interpreter expr -&gt; INTEGER PLUS INTEGER expr -&gt; INTEGER MINUS INTEGER \"\"\" # set current token to the first token from the input self.current_token = self.get_next_token() # we expect the current token to be an integer left = self.current_token self.eat(INTEGER) # we expect the current token to be either a '+' or '-' op = self.current_token if op.type == PLUS: self.eat(PLUS) elif op.type == MINUS: self.eat(MINUS) else: self.error() # we expect the current token to be an integer right = self.current_token self.eat(INTEGER) # after the above call the self.current_token is set to # EOF token # at this point either the INTEGER PLUS INTEGER or # the INTEGER MINUS INTEGER sequence of tokens # has been successfully found and the method can just # return the result of adding or subtracting two integers, # thus effectively interpreting client input if op.type == PLUS: result = left.value + right.value elif op.type == MINUS: result = left.value - right.value else: self.error() return resultdef main(): while True: try: # To run under Python3 replace 'raw_input' call with 'input' text = input('calc&gt; ') except EOFError: break if not text: continue interpreter = Interpreter(text) result = interpreter.expr() print(result)if __name__ == '__main__': main()把以上代码保存到名为 calc2.py 中，或者直接从 GitHub 上下载。试一试。亲眼看一下 它可以按预期运行：它可以处理输入中的任何位置的空白符；它接受多位整数，除了整数相 加还可以处理整数相减。下面可以再笔记本上次尝试：123456$ python calc2.pycalc&gt; 27 + 330calc&gt; 27 - 720calc&gt;与第一部分相比代码的主要变化有：get_next_token 方法做了一点重构。增加指针 pos 的逻辑被重构到了方法 advance 中。增加了两个方法： skip_whitespace 用来忽略空白符， integer 用来处理输入中的多位整数。expr 方法在修改后，除了可以识别 INTEGER -&gt; PLUS -&gt; INTEGER 这个组合(phrase) 之外，还可以识别INTEGER -&gt; MINUS -&gt; INTEGER。而且在成功识别相应的组合后，也可以进行相应的加减操作。在第一部分你尝到了两个重要的概念，即 token 和 词法分析器 。今天我想聊一聊 lexeme 、 parsing 和 parser 。你已经知道 token 了。但为了叙述方便，需要介绍一下 lexeme。什么是 lexeme？ lexeme 是组成 token 的一个字符序列。在下面的图片中是一些 token 和 lexeme 的例子， 希望它能把两者之间的关系表达清楚：现在还记得 expr 方法吗？我以前说过这是真正解释算术表达式的地方。但在解释一个表达式之前，你需要知道它是哪种组合，比如相加或相减。这是 expr 方法本质上做的事： 它从 get_next_token 方法得到的 token 流中找到结构，然后解释它识别出的组合，产 生算术表达式的结果。又到了做练习的时间了。扩展计算器以处理两个整数相乘扩展计算器以处理两个整数相除修改代码以使它可以解释包含任意个数字的加减操作，如“9 - 5 + 3 + 11”本节检测：什么是 lexeme？在 token 流中找到结构的过程叫什么？或者这么问，在 token 流中识别出特定组合的过程叫什么？解释器（编译器）做 parsing 工作的部分叫什么？梳理：首先输入一个表达式，如“3+9”，送给解释器Interpreter开始对这个表达式拆分成一个个的token，这一步叫做词法分析，由词法分析器(lexical analyzer)来完成。在本文中，函数get_next_token就相当于词法分析器。词法分析器get_next_token处理完之后的是一个个的token(type , value)然后开始进行语法分析（由于本文中只实现了加法、减法），所以这里的语法分析就是分析：加、减法的表达式。执行这个步骤的是expr函数，其中expr 方法使用了辅助方法eat来验证传给token的类型与当前类型是否相匹配。与现有语法规则（即，加法规则和减法规则）不匹配，eat就会抛出异常。语法分析完成之后，就直接得出算式的结果。（这也很符合解释器的特性嘛：边解释边执行，不会生成目标代码）其他的函数：Interpretererror(self)：当有错误的时候，就调用它advance(self)：增加指针pos的作用，即，将指向下一个tokenskip_whitespace(self)：跳过空格，V2.0新增加的功能integer(self)：为了可以算多位数的加减法。这里要注意：如3和233是两个整数类型的token，但是值得注意的是这篇文章中的token是按照输入的一串字符串（如“3+155”）每一个都当成一个token。也就是说本来155是一个token，但是从细节上看，在代码实现中155是被当成了三次“token”然后经过integer函数才形成了最终形体155这个token。在本系列的下一篇文章中你会扩展你的计算器来处理更复杂的算术表达式。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let’s Build A Simple Interpreter","slug":"Let’s-Build-A-Simple-Interpreter","permalink":"https://www.longlongqin.top/tags/Let%E2%80%99s-Build-A-Simple-Interpreter/"}]},{"title":"Let’s Build A Simple Interpreter 1","slug":"学习笔记/Let's Build A Simple Interpreter/LSBASI-1","date":"2020-03-08T09:26:27.000Z","updated":"2020-03-24T16:32:05.515Z","comments":true,"path":"archives/427485bf.html","link":"","permalink":"https://www.longlongqin.top/archives/427485bf.html","excerpt":"为什么要你学解释器和编译器？这里你三条理由。","text":"为什么要你学解释器和编译器？这里你三条理由。要写一个解释器或编译器，你必须同时用到很多技术。编写一个解释器或编译器会帮助 你提高这些技能并且成为一个更好的软件开发者。而且，你将学到的这些技能在开发任 何软件时都有可能用到，而不仅仅是解释器或编译器。你确实想要知道计算机如何工作。一般解释器和编译器看上去都像魔法一样。但你不应 该对这些魔法感到舒服。你想要揭开解释器和编译器的神秘面纱，理解它们如何工作并 控制所有一切。你想要创造自己的编程语言或者领域特定语言。如果是这样，你就需要为这个语言创建 一个解释器或编译器。最近，创建新语言再度兴起。你几乎每天都可以看到一门新语言 的诞生：Elixir, Go, Rust 等。原文链接：https://ruslanspivak.com/lsbasi-part1/好了，但什么是解释器和编译器呢？解释器与编译器解释器与编译器都是“高级语言与机器之间的翻译官”。都是将代码翻译成机器可以执行的二进制机器码，只不过在运行原理和翻译过程不同。那它们的区别在于：编译器：先整体编译完，然后一次性执行。比如：C语言代码被编译成二进制代码（exe程序），在windows平台上执行。解释器：解释一句后就提交计算机执行一句，即便捷式边执行。比如php，postscritp，javascript就是典型的解释性语言。用一个通俗的例子来讲：我们去饭馆吃饭，点了八菜一汤。编译器的方式就是厨师把所有的菜给你全做好了，一起给你端上来，至于你在哪吃，怎么吃，随便。解释器的方式就是厨师做好一个菜给你上一个菜，你就吃这个菜，而且必须在饭店里吃。编译器与解释器的工作流程的差别：编译器与解释器的各自的特点：构造解释器V1.0该系列文章的作者使用 Python 编写Pascal语言的解释器。第一版V1.0，构造的计算器有诸多限制。如：只输入一位的数字现阶段仅支持加法操作输入中不允许有空白符这些约束使得构建一个计算器很简单，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125# Token types：# EOF (end-of-file) token is used to indicate that# there is no more input left for lexical analysisINTEGER, PLUS, EOF = 'INTEGER', 'PLUS', 'EOF'class Token(object): def __init__(self, type, value): # token type: INTEGER, PLUS, or EOF self.type = type # token value: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, '+', or None self.value = value def __str__(self): \"\"\"String representation of the class instance. Examples: Token(INTEGER, 3) Token(PLUS, '+') \"\"\" return 'Token(&#123;type&#125;, &#123;value&#125;)'.format( type=self.type, value=repr(self.value) ) def __repr__(self): return self.__str__()class Interpreter(object): def __init__(self, text): # client string input, e.g. \"3+5\" self.text = text # self.pos is an index into self.text self.pos = 0 # current token instance self.current_token = None def error(self): raise Exception('Error parsing input') def get_next_token(self): \"\"\"Lexical analyzer (also known as scanner or tokenizer) This method is responsible for breaking a sentence apart into tokens. One token at a time. \"\"\" text = self.text # is self.pos index past the end of the self.text ? # if so, then return EOF token because there no more # input left to convert into tokens if self.pos &gt; len(text) - 1: return Token(EOF, None) # get a character at the position self.pos and decide # what token to create based on the single character current_char = text[self.pos] # if the character is a digit then convert it to # integer, create an INTEGER token, increment self.pos # index to point to the next character after the digit, # and return the INTEGER token if current_char.isdigit(): token = Token(INTEGER, int(current_char)) self.pos += 1 return token if current_char == '+': token = Token(PLUS, current_char) self.pos += 1 return token self.error() def eat(self, token_type): # compare the current token type with the passed token # type and if they match then \"eat\" the current token # and assign the next token to the self.current_token, # otherwise raise an exception. if self.current_token.type == token_type: self.current_token = self.get_next_token() else: self.error() def expr(self): \"\"\"expr -&gt; INTEGER PLUS INTEGER\"\"\" # set current token to the first token taken from the input self.current_token = self.get_next_token() # we expect the current token to be a single-digit integer left = self.current_token self.eat(INTEGER) # we expect the current token to be a '+' token op = self.current_token self.eat(PLUS) # we expect the current token to be a single-digit integer right = self.current_token self.eat(INTEGER) # after the above call the self.current_token is set to # EOF token # at this point INTEGER PLUS INTEGER sequence of tokens # has been successfully found and the method can just # return the result of adding two integers, thus # effectively interpreting client input result = left.value + right.value return resultdef main(): while True: try: # To run under Python3 replace 'raw_input' call with 'input' text = input('calc&gt; ') except EOFError: break if not text: continue interpreter = Interpreter(text) result = interpreter.expr() print(result)if __name__ == '__main__': main()把以上代码保存到名为 calc1.py 中，或者直接从 GitHub 上下载。在你开始仔细研究代 码之前，在命令行上运行这个计算器并看它实现运行。把玩一下！下面是在我笔记本上的一 次尝试（如果你想在 Python3 下运行，就需要把 raw_input 替换为 input）：12345678$ python calc1.pycalc&gt; 3+47calc&gt; 3+58calc&gt; 3+912calc&gt;代码分析假设我们在命令行输入一个表达式“3+5”。你的解释器得到一个字符串 “3+5”。为了使解释器真正理解如何处理这个字符串，需要先把输入的 “3+5” 拆分成被叫做 token 的部件。词法分析：（lexical analysis，简称lexer，亦称scanner 或 tokenizer）​ 词法分析也称为 分词 ，此阶段编译器从左向右扫描源文件，将其字符流分割成一个个的 词 （ token 、 记号 ，后文中将称为 token ）。Token：​ 所谓 token ，就是源文件中不可再进一步分割的一串字符，类似于英语中单词，或汉语中的词。这里的 token 就是一个有类型的值的对象（即，token还存着值的类型）。例如对于字符串“3”来说，token 类型为 INTEGER ， 相应的值是整数 3 。解释器Interpreter要做的第一步就是读取输入的字符串并把他转化成 token 流。解释器中做这个工作的部分被称为 词法分析器(lexical analyzer)，简称 lexer 。也可以称它为： scanner 或 tokenizer 。他们的含义是一样的：表示解释器或编译器中将输入的字符串转化为 token 流的部分。那是如何转化为token流呢？解释器 Interpreter中的 get_next_token 方法就是你的词法分析器。你每次调用它，就会从输入到解释器的字符流中得到下一个 token。让我们仔细看一下这个方法，看看它是怎么把字符转化 为 token 的。输入被存放在变量 text 中，它保存了输入的字符串， pos 是指向该字符串的一个索引（把字符串看作是一个字符数组）。 pos 的初值被设为 0, 指向字符‘3’。 该方法首先检查该字符是不是数字，若是数字，就递增 pos 并返回一个类型为 INTEGER 值 为整数 3 的 token：现在 pos 指向了 text 中的字符‘+’，下次你调用这个方法时，它会先测试 pos 位 置的字符是否是数字，然后再测试它是否是加号，此时它是加号。这样该方法就递增 pos 并返回一个类型为 PLUS 值为‘+’的 token：现在 pos 指向了字符‘5’。当你再次调用 get_next_token 时，它会检查 pos 位置 是否是一个数字，此时是的，因此它递增 pos 并返回一个类型为 INTEGER 值为‘5’的 token：现在索引 pos 越过了字符串“3+5”的末尾，接下来每次调用 get_next_token 方法都会 返回 EOF token：自己动手试试看看你的计算器的 lexer 组件怎么工作的：123456789101112131415&gt;&gt;&gt; from calc1 import Interpreter&gt;&gt;&gt;&gt;&gt;&gt; interpreter = Interpreter('3+5')&gt;&gt;&gt; interpreter.get_next_token()Token(INTEGER, 3)&gt;&gt;&gt;&gt;&gt;&gt; interpreter.get_next_token()Token(PLUS, '+')&gt;&gt;&gt;&gt;&gt;&gt; interpreter.get_next_token()Token(INTEGER, 5)&gt;&gt;&gt;&gt;&gt;&gt; interpreter.get_next_token()Token(EOF, None)&gt;&gt;&gt;此时你的解释器已经可以从输入的字符流中获得 token 流了，解释器需要对它做点什么： 它需要从使用 lexer get_next_token 得到的字符流中找到结构。你的解释器期望从 流中找到如下的结构： INTEGER -&gt; PLUS -&gt; INTEGER. 即，它试着找到这样一个 token 序 列：整数后跟一个加号再跟一个整数。负责查找和解释这个结构的方法是 expr. 这个方法验证一个 token 序列是否遵从期望的 token 序列，即 INTEGER -&gt; PLUS -&gt; INTEGER. 当确定遵从这个结构后，它就把 PLUS 左 边和右边 token 的值相加来生成结果，从而成功地解释了你传给解释器的算术表达式。expr 方法使用了辅助方法 eat 来验证传给 eat 的 token 类型与当前的 token 类 型相匹配。在匹配到传入的 token 类型后， eat 方法会取得下一个 token 并把它赋值 给变量 current_token, 这样实际上是“吃掉”了当前匹配的 token 并把想象中的 token 流中的指针向前移动了。如果 token 流中的结构不遵从期望的 INTEGER PLUS INTEGER 序 列， eat 方法就会抛出一个异常。小结回顾一下你的解释器为了对一个算术表达式求值都做了什么：解释器接Interpreter收一个输入字符串，假设为“3+5”解释器调用了 expr 方法来从词法解析器 get_next_token 返回的 token 流中寻找一个结构。这个结构就是一个 INTEGER PLUS INTEGER 的形式。当确认了这个结构以后，它就使用把两个 INTEGER token 相加的方式来解释这个输入，因为此时解释器已经清楚 地知道它要做的就是把 3 和 5 两个整数相加。祝贺你。你刚刚学会了怎么构造你的第一个解释器！现在是时候做此练习了。你不会觉得你刚刚读了这篇文章就足够了，是吧？好了，自己动手做下面的练习：修改代码使得允许输入多位整数，例如“12+3”增加一个跳过空白符的方法，使你的计算器可以处理包含空白符的输入如 “ 12 + 3”修改代码使得它可以处理‘-’而非‘+’的情况检查你的理解。什么是解释器？什么是编译器？解释器和编译器的区别是什么？什么是 token？将输入拆分成 token 的过程叫什么？解释器中做词法分析的部分叫什么？解释器或编译器的这个部分还有什么其他常见的名字？相关文章链接：编译器与解释器：https://www.liujiangblog.com/course/python/9Let’s Build A Simple Interpreter. Part 1：https://feng-qi.github.io/2018/01/23/lets-build-a-simple-interpreter-part-01/","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Let’s Build A Simple Interpreter","slug":"Let’s-Build-A-Simple-Interpreter","permalink":"https://www.longlongqin.top/tags/Let%E2%80%99s-Build-A-Simple-Interpreter/"}],"author":{"name":"longlongqin","avatar":"https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg","url":"https://www.longlongqin.top"}},{"title":"2、电子计算机","slug":"学习笔记/《计算机科学速成课》笔记/2、电子计算机","date":"2020-03-07T19:02:53.000Z","updated":"2020-03-17T09:03:42.618Z","comments":true,"path":"archives/d84f.html","link":"","permalink":"https://www.longlongqin.top/archives/d84f.html","excerpt":"这个系列的课程还是值得大家去看一看的。这个系列的视频叫《计算机科学速成课》。虽然叫速成课，我们也要做到心中有数，它肯定不是让你看了这些内容你就什么都知道了。这是科普性的视频。这个视频都是被翻译好的，再次感谢这些翻译者。","text":"这个系列的课程还是值得大家去看一看的。这个系列的视频叫《计算机科学速成课》。虽然叫速成课，我们也要做到心中有数，它肯定不是让你看了这些内容你就什么都知道了。这是科普性的视频。这个视频都是被翻译好的，再次感谢这些翻译者。前言视频在B站上都有全集的，传送门：https://www.bilibili.com/video/av21376839在GitHub上的地址：https://github.com/1c7/crash-course-computer-science-chinese这门课总共有40节，每节课的标题为：计算机早期历史电子计算布尔逻辑与逻辑电路二进制算术逻辑单元寄存器 &amp; 内存中央处理器指令和程序高级 CPU 设计编程史话编程语言编程原理：语句和函数算法初步数据结构阿兰·图灵软件工程集成电路、摩尔定律操作系统内存 &amp; 储存介质文件系统压缩命令行界面屏幕 &amp; 2D 图形显示冷战和消费主义个人计算机革命图形用户界面3D 图形计算机网络互联网万维网网络安全黑客与攻击加密机器学习与人工智能计算机视觉自然语言处理机器人计算机中的心理学教育型科技奇点，天网，计算机的未来计算机早期历史这一张图大致说明了计算机早期发展的历史。图片来源：请查看图片本身链接。后面的课会较详细的讲解。电子计算机继电器在1937年最大的机电计算机之一是哈佛的马克一号(Harvard Mark Ⅰ)，是IBM在1944年给二战的同盟国建造的。该机器的大脑(CPU的基础器件)是“继电器”。继电器：是用电控制的机械开关，继电器里有根“控制线路”控制着电路的开关，“控制线路”连着一个线圈，当线圈通电时，会产生感应磁场，由此由此能够吸引上方的金属臂，从而闭合电路，得到高电平。它的性能：1940年一个好的继电器1秒能翻转50次。哈佛马克一号1秒能做3次加减法运算，一次乘法需要6秒，除法需要15秒，三角函数需要一分钟以上。它的缺点：控制开关的金属臂是“有质量的”，因此无法快速开关。并且金属臂的反复移动就会存在磨损（任何会动的机械都会随时间磨损），哈佛马克一号平均每天需要更换一个故障继电器。真空管在1904年，英国物理学家John Ambrose Fleming开发了新的电子组件——热电子管（Thermionic valve）。热电子管：把两个电极装在一个气密的真空玻璃灯泡中。其中一个点击A可以加热，从而发射电子，称为热电子发射（Thermionic emission）；另一个电极B会吸引电子，来形成电流。但只有当电极B带正电时才能吸引电子，否则当电极B带负电荷或者中性电荷时，电子就无法跨越真空区。美国发明家Lee de Forest在此基础上加入了第三个控制电极。通过向控制电极施加正电荷，就能吸引电子，从而闭合电路；而通过施加负电荷，就能闭合电路。特点：每秒可开闭数千次。和继电器相同的是，可以通过一个控制线路来控制断开或闭合电路，并且真空管内没有会动的组件，因此存在更少的磨损。比较脆弱，会像灯泡一样烧坏，并且体积比较大。真空管的出现，标志着计算机从机电转向电子，电子数值积分计算机ENIAC，在1946年于宾夕法尼亚大学设计制造，这是世上第一个真正的通用可编程电子计算机，每秒可执行5000次十位加减法。但是由于存在大量的真空管，因此ENIAC运行半天左右就会出现一次故障。晶体管晶体管：类似于继电器和真空管，晶体管也是一个用于控制电路闭合断开的开关。晶体管有两个电极，这两个电极之间通过半导体材料隔开。控制线连接到一个“门”电极，通过改“门”的电荷，我们可以控制半导体的导电性，由此来控制电流是否流动。当控制线路通电时，两个电极接通，否则两个电极断开。特点：每秒可开关10000次。相比玻璃制成的真空管，晶体管是固体的，并且体积远小于继电器和真空管。第一个消费者可购买的，完全由晶体管构成的计算机是1957年发布的IBM 608，它有3000个晶体管，每秒执行4500次加减法，或80次左右的乘除法。如今，计算机里的晶体管小于50nm，并且每秒可切换上百万次，工作几十年。很多晶体管和半导体开发在圣克拉拉谷，位于旧金山和圣河西之间，由于制造半导体最常见的材料是硅，由此这个地方被称为“硅谷”。并且William Shockley搬过去创建了肖克利半导体，里面的员工后来成立了仙童半导体，而这里面的员工后来创立了英特尔。所以，计算机的大脑基础单元的发展路径，可概括为：继电器-&gt;电子管-&gt;晶体管","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"《计算机科学速成课》","slug":"《计算机科学速成课》","permalink":"https://www.longlongqin.top/tags/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE%E3%80%8B/"}]},{"title":"Hexo之 Yilia主题配置","slug":"Hexo博客搭建/hexo之Ylia主题配置","date":"2020-03-06T14:50:08.000Z","updated":"2020-03-18T08:51:47.606Z","comments":true,"path":"archives/460671de.html","link":"","permalink":"https://www.longlongqin.top/archives/460671de.html","excerpt":"Yilia主题配置","text":"Yilia主题配置在左侧显示总文章数将themes\\yilia\\layout_partial\\left-col.ejs文件的1234567&lt;nav class=\"header-menu\"&gt; &lt;ul&gt; &lt;% for (var i in theme.menu)&#123; %&gt; &lt;li&gt;&lt;a href=\"&lt;%- url_for(theme.menu[i]) %&gt;\"&gt;&lt;%= i %&gt;&lt;/a&gt;&lt;/li&gt; &lt;%&#125;%&gt; &lt;/ul&gt;&lt;/nav&gt;后面加上123&lt;nav&gt; 总文章数 &lt;%=site.posts.length%&gt;&lt;/nav&gt;字数、阅读时长添加首先安装 hexo-wordcount使用如下命令安装：1npm i --save hexo-wordcount #如果安装了cnpm，可换为cnpm安装Node 版本7.6.0之前,请安装 2.x 版本 (Node.js v7.6.0 and previous)1Copynpm install hexo-wordcount@2 --save然后在 themes\\yilia\\layout\\_partial\\left-col.ejs中添加：123Copy&lt;nav&gt; 总字数 &lt;span class&#x3D;&quot;post-count&quot;&gt;&lt;%&#x3D; totalcount(site, &#39;0,0.0a&#39;) %&gt;&lt;&#x2F;span&gt;&lt;&#x2F;nav&gt;添加位置在如下代码的下面：123Copy&lt;nav&gt; 总文章数 &lt;%&#x3D;site.posts.length%&gt;&lt;&#x2F;nav&gt;编辑 themes\\yilia\\layout\\_partial\\article.ejs在header下面加入：123&lt;div align&#x3D;&quot;left&quot; class&#x3D;&quot;post-count&quot;&gt; &lt;!--其中align可以在：right、center、left--&gt; 字数：&lt;%&#x3D; wordcount(post.content) %&gt;字 | 预计阅读时长：&lt;%&#x3D; min2read(post.content) %&gt;分钟&lt;&#x2F;div&gt;即可显示单篇字数和预计阅读时长。置顶文章安装插件12npm uninstall hexo-generator-index --savenpm install hexo-generator-index-pin-top --save配置置顶标准打开：/themes/*/layout（/_macro）/post.ejs 直接在最前面加入以下代码即可12345&lt;% if (page.top) &#123; %&gt; &lt;i class=\"fa fa-thumb-tack\"&gt;&lt;/i&gt; &lt;font color=7D26CD&gt;置顶&lt;/font&gt; &lt;span class=\"post-meta-divider\"&gt;|&lt;/span&gt;&lt;% &#125; %&gt;配置文章然后在需要置顶的文章的Front-matter中加上top选项即可 top后面的数字越大，优先级越高12345---title: 2019date: 2019-02-14 16:10:03top: 5---增加不蒜子统计利用这个统计，可以知道你博客的访问量。安装不蒜子脚本：在themes\\yilia\\layout\\ _partial\\after-footer.ejs最后添加：1&lt;script async src=\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt;单篇文章点击量：在themes/yilia/layout/_partial/article.ejs中 在1&lt;%- partial(&#39;post&#x2F;title&#39;, &#123;class_name: &#39;article-title&#39;&#125;) %&gt;后面插入如下代码1234567891011&lt;!--显示阅读次数--&gt;&lt;% if (!index &amp;&amp; post.comments)&#123; %&gt; &lt;br/&gt; &lt;a class=\"cloud-tie-join-count\" href=\"javascript:void(0);\" style=\"color:gray;font-size:14px;\"&gt; &lt;span class=\"icon-sort\"&gt;&lt;/span&gt; &lt;span id=\"busuanzi_container_page_pv\" style=\"color:#ef7522;font-size:14px;\"&gt; 阅读数: &lt;span id=\"busuanzi_value_page_pv\"&gt;&lt;/span&gt;次 &amp;nbsp;&amp;nbsp; &lt;/span&gt; &lt;/a&gt;&lt;% &#125; %&gt;&lt;!--显示阅读次数完毕--&gt;增加版权声明配置yilia：在themes/yilia/layout/_partial/article.ejs中，标注的位置添加代码：1234567891011121314&lt;div class=\"article-entry\" itemprop=\"articleBody\"&gt; &lt;% if (post.excerpt &amp;&amp; index)&#123; %&gt; &lt;%- post.excerpt %&gt; &lt;% if (theme.excerpt_link) &#123; %&gt; &lt;a class=\"article-more-a\" href=\"&lt;%- url_for(post.path) %&gt;#more\"&gt;&lt;%= theme.excerpt_link %&gt; &gt;&gt;&lt;/a&gt; &lt;% &#125; %&gt; &lt;% &#125; else &#123; %&gt; &lt;%- post.content %&gt; &lt;% &#125; %&gt; &lt;-- 在此处添加代码--&gt; &lt;-- 在此处添加代码--&gt; &lt;-- 在此处添加代码--&gt; &lt;-- 在此处添加代码--&gt; &lt;% if ((theme.reward_type === 2 || (theme.reward_type === 1 &amp;&amp; post.reward)) &amp;&amp; !index)&#123; %&gt; &lt;div class=\"page-reward\"&gt; &lt;a href=\"javascript:;\" class=\"page-reward-btn tooltip-top\"&gt; &lt;div class=\"tooltip tooltip-east\"&gt;在目录：themes/yilia/source-src/css中创建新文件：declare.scss，并添加如下CSS代码：123456.declare &#123; background-color: #eaeaea; margin-top: 2em; border-left: 3px solid #ff1700; padding: .5em 1em;&#125;然后，为themes/yilia/source-src/css/main.scss，添加如下代码：1@import \"./declare\";配置显示：现在该让其显示出来，在themes/yilia/_config.yml，中加入：123456789#版权基础设定：0-关闭声明； 1-文章对应的md文件里有declare: true属性，才有版权声明； 2-所有文章均有版权声明#当前应用的版权协议地址。#版权协议的名称#版权协议的Logodeclare_type: 1licensee_url: https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by-nc-sa&#x2F;4.0&#x2F;licensee_name: &#39;知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议&#39;licensee_img: https:&#x2F;&#x2F;i.creativecommons.org&#x2F;l&#x2F;by-nc-sa&#x2F;4.0&#x2F;88x31.png然后在需要进行版权声明的文章的md文件头部，设置属性1declare:true即可。在主页时文章显示摘要在你 MD 格式文章正文插入 &lt;!-- more --&gt; 即可，只会显示它之前的，此后的就不显示，点击文章标题，，或者点击下面的按钮，即可进入全文。如：文章显示目录增加文章目录 TOC ( table of content )，方便阅读文章，在 themes/yilia/_config.yml 中进行配置 toc: 2 即可，它会将你 Markdown 语法的标题，生成目录，目录查看在右下角。头像设置设置存放位置：头像/图标图片的存放位置是/themes/yilia/source/下任意位置，可以自己新建一个文件夹存放，我存放在assets文件夹下。（我之前放在img中，但是不知道为什么，它就显示不出来）配置修改：配置文件为/themes/yilia/_config.yml。设置头像为配置文件中avatar一项，设置图标为配置文件中favicon一项，设置路径的根目录为/themes/yilia/source/。例如，我的头像存放的地址是/themes/yilia/source/assets/me.png，设置则为avatar: /assets/me.png。（图标同理）提交网页sitemap方式提交网页在 Hexo 根目录打开命令行工具，执行以下命令：123npm install hexo-generator-sitemap --savehexo cleanhexo g查看1&#123;your_hexo_path&#125;&#x2F;public文件夹，可以看到文件：1sitemap.xmlsitemap 的初衷是给搜索引擎看的，为了提高搜索引擎对自己站点的收录效果，我们最好手动到 google 和百度等搜索引擎提交 sitemap.xml。baidu提交网址：https://ziyuan.baidu.com/?castk=LTE%3D百度自动推送方式提交网页在本机1&lt;博客根目录&gt;&#x2F;themes&#x2F;yilia&#x2F;layout&#x2F;_partial目录下打开article.ejs文件，定位到如下这段代码：1234&lt;% var sUrl &#x3D; url.replace(&#x2F;index\\.html$&#x2F;, &#39;&#39;); sUrl &#x3D; &#x2F;^(http:|https:)\\&#x2F;\\&#x2F;&#x2F;.test(sUrl) ? sUrl : &#39;https:&#39; + sUrl; %&gt;在它前面加上：123456789101112131415161718&lt;!- 百度自动推送方式提交 --&gt;&lt;% if (1)&#123; %&gt; &lt;script&gt; (function()&#123; var bp &#x3D; document.createElement(&#39;script&#39;); var curProtocol &#x3D; window.location.protocol.split(&#39;:&#39;)[0]; if (curProtocol &#x3D;&#x3D;&#x3D; &#39;https&#39;) &#123; bp.src &#x3D; &#39;https:&#x2F;&#x2F;zz.bdstatic.com&#x2F;linksubmit&#x2F;push.js&#39;; &#125; else &#123; bp.src &#x3D; &#39;http:&#x2F;&#x2F;push.zhanzhang.baidu.com&#x2F;push.js&#39;; &#125; var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(bp, s); &#125;)(); &lt;&#x2F;script&gt;&lt;% &#125; %&gt;&lt;!- 百度自动推送方式提交结束 --&gt;即完成了新增博客文章页面（不包括其他页面）的自动推送方式提交。链接提交百度站长平台的链接提交方式分为自动提交和手动提交两种，此处只讲自动提交，手动提交按照要求操作即可。主动推送设置主动推送最为快速的提交方式，是被百度收录最快的推送方式。主动推送可以通过安装插件实现：首先安装插件：1npm install hexo-baidu-url-submit --save修改站点根目录下的配置文件_config.yml，添加以下内容：12345baidu_url_submit: count: 20 ## 提交最新的20个链接 host: www.dongshuyan.com ## 百度站长平台中注册的域名 token: ## 16位准入秘钥 path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里准入秘钥获取:在如下图的网址中：下拉，找到这里：点击进去就是准入秘钥。检查:其次，记得查看根目录下的_config.yml文件中url的值， 必须包含是百度站长平台注册的域名， 比如:123456# URL## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;url: http:&#x2F;&#x2F;dongshuyan.comroot: &#x2F;permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;permalink_defaults:最后，加入新的deployer最后，加入新的deployer:12345deploy:- type: git ## 这是我原来的deployer repo: branch:- type: baidu_url_submitter ## 添加这里内容即可这里的”-“,必不可少！ 否则报错。使用其主动推送的实现原理如下：新链接的产生， hexo generate 会产生一个文本文件，里面包含最新的链接新链接的提交， hexo deploy 会从上述文件中读取链接，提交至百度搜索引擎自动推送装自动推送JS代码的网页，在页面被访问时，页面URL将立即被推送给百度。修改主题目录下的layout/post.ejs文件，末尾添加自动推送代码，代码如下：1234567891011121314&lt;script&gt;(function()&#123; var bp &#x3D; document.createElement(&#39;script&#39;); var curProtocol &#x3D; window.location.protocol.split(&#39;:&#39;)[0]; if (curProtocol &#x3D;&#x3D;&#x3D; &#39;https&#39;) &#123; bp.src &#x3D; &#39;https:&#x2F;&#x2F;zz.bdstatic.com&#x2F;linksubmit&#x2F;push.js&#39;; &#125; else &#123; bp.src &#x3D; &#39;http:&#x2F;&#x2F;push.zhanzhang.baidu.com&#x2F;push.js&#39;; &#125; var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(bp, s);&#125;)();&lt;&#x2F;script&gt;出处：(http://dongshuyan.com/2019/05/24/hexo博客注意事项/#14-Hexo添加百度统计)添加百度统计和谷歌统计代码百度统计首先打开百度站长平台，注册账户。然后登陆 百度统计》管理》新增站点。然后复制生成的代码：123456789&lt;script&gt;var _hmt = _hmt || [];(function() &#123; var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?这里是你的专属字符串\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s);&#125;)();&lt;/script&gt;这一段代码，最重要的就是你那段专属的字符串。开始配置：首先，打开1themes&#x2F;yilia&#x2F;_config.yml里面1baidu_analytics: ''改为1baidu_analytics: true然后，打开：1themes/yilia/layout/_partial/baidu-analytics.ejs你会看到：1234567891011&lt;% if (theme.baidu_analytics)&#123; %&gt;&lt;script&gt;var _hmt &#x3D; _hmt || [];(function() &#123; var hm &#x3D; document.createElement(&quot;script&quot;); hm.src &#x3D; &quot;https:&#x2F;&#x2F;hm.baidu.com&#x2F;hm.js?&lt;%&#x3D; theme.baidu_analytics %&gt;&quot;; var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(hm, s);&#125;)();&lt;&#x2F;script&gt;&lt;% &#125; %&gt;这里，我们直接用你的专属字符串去替换&lt;%= theme.baidu_analytics %&gt;就行了。替换后为：1234567891011&lt;% if (theme.baidu_analytics)&#123; %&gt;&lt;script&gt;var _hmt &#x3D; _hmt || [];(function() &#123; var hm &#x3D; document.createElement(&quot;script&quot;); hm.src &#x3D; &quot;https:&#x2F;&#x2F;hm.baidu.com&#x2F;hm.js?你的专属字符串&quot;; var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(hm, s);&#125;)();&lt;&#x2F;script&gt;&lt;% &#125; %&gt;谷歌统计参考：http://yansheng836.coding.me/article/eda67a25.html","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.longlongqin.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Yilia主题配置","slug":"Yilia主题配置","permalink":"https://www.longlongqin.top/tags/Yilia%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"}]},{"title":"Hexo之Matery主题配置","slug":"Hexo博客搭建/Hexo之Matery主题配置","date":"2020-03-05T09:29:38.000Z","updated":"2020-03-17T08:27:59.163Z","comments":true,"path":"archives/514b.html","link":"","permalink":"https://www.longlongqin.top/archives/514b.html","excerpt":"最近的三天一直在折腾hexo框架的博客，先是使用yilia主题，但是用来一天觉得我不适合这个主题，随即看到了matery主题。","text":"最近的三天一直在折腾hexo框架的博客，先是使用yilia主题，但是用来一天觉得我不适合这个主题，随即看到了matery主题。前言今天又折腾了白天一天时间，我这个是直接克隆的hongweiの博客，这是一个大佬呀，还要多多向他学习。然后，只把一些简单的配置弄好了。现在梳理一下：已完成的配置：404页面简历建站时间设置个人域名（已购买域名，单还需要审核，明天再去弄。）不蒜子设置 添加评论插件 网站SEO优化 百度收录站点 1.验证网站所有权 谷歌收录站点 优化你的URL 添加代码块复制功能 添加文章更新时间功能非必要配置（已经取消）：添加网易云音乐BGM添加鼠标点击烟花爆炸效果添加页面樱花飘落效果添加鼠标点击文字特效添加页面雪花飘落动效优化网站加载速度数学公式渲染和代码高亮其他搜索引擎收录你的站点添加动漫人物增加emoji支持添加博客动态标签添加博客天气插件GitHub&amp;coding pages双部署修复Valine评论的头像不显示问题配置代码高亮由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 hexo-prism-plugin 的 Hexo 插件来做代码高亮，安装命令如下：1npm i -S hexo-prism-plugin然后，修改 Hexo 根目录下 _config.yml 文件中 highlight.enable 的值为 false，并新增 prism 插件相关的配置，主要配置如下：12345678highlight: enable: falseprism_plugin: mode: 'preprocess' # realtime/preprocess theme: 'tomorrow' line_number: false # default false custom_css:遇到的问题1、Cannot set property &#39;lastIndex&#39; of undefined运行hexo g出现Cannot set property ‘lastIndex’ of undefined解决方法：修改配置文件的 _config.yml，注意不是主题里面的配置文件，把 auto_detect 设置为false 即可。2、代码显示异常解决方法：首先，修改 Hexo 根目录下 _config.yml 文件中 highlight.enable 的值为 false。然后hexo clean&amp; hexo g&amp; hexo s好了。注：作者给的解决方案比我这个要多一步，我在这里贴出来，供大家参考。3、目录定位内容有偏差我反复的去测试，后来发现，可能有两个原因会导致这个问题的出现：网页没有刷新完全的时候，点击目录他有可能不会跳转。解决方法：法一：等待网页刷新完全。法二：手动的去停止网页的刷新（这个来的比较快一点，哈哈）你的文章的标题格式有问题，比如，我用Typora软件来写文章，这个软件就是所写即所得。但是这样你就不容易发现格式细节处的错误。错误示范：我先写了一个一级标题，然后，我又点击引用，就变成这样了：这种写法在Typora中，是不会认为它是一级标题的。我们打开源码查看他的格式：&gt; # 配置。他的格式是这样的。就是这里出错了，在matery主题中这样写它仍然会识别成标题，然后就导致从这个标题开始后面的标题，在你点击这些标题的时候，它会定位错误。解决方法：我们一定要遵循Markdown格式的语法，一定要，一定要。","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.longlongqin.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"matery主题配置","slug":"matery主题配置","permalink":"https://www.longlongqin.top/tags/matery%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"}]},{"title":"Tsinghua_Online_Judge_练习","slug":"Tsinghua-Online-Judge-练习","date":"2020-03-04T09:23:29.000Z","updated":"2020-03-22T15:31:35.297Z","comments":true,"path":"archives/d4fa.html","link":"","permalink":"https://www.longlongqin.top/archives/d4fa.html","excerpt":"","text":"CG2017 PA1-1 Convex Hull (凸包)题目Description (描述)After learning Chapter 1, you must have mastered the convex hull very well. Yes, convex hull is at the kernel of computational geometry and serves as a fundamental geometric structure. That’s why you are asked to implement such an algorithm as your first programming assignments.Specifically, given a set of points in the plane, please construct the convex hull and output an encoded description of all the extreme points.经过了第一章的学习，想必你对于凸包的认识已经非常深刻。是的，凸包是计算几何的核心问题，也是一种基础性的几何结构。因此你的第一项编程任务，就是来实现这样的一个算法。具体地，对于平面上的任意一组点，请构造出对应的凸包，并在经过编码转换之后输出所有极点的信息。Input (输入)The first line is an integer n &gt; 0, i.e., the total number of input points.The k-th of the following n lines gives the k-th point:pk = (xk, yk), k = 1, 2, …, nBoth xk and yk here are integers and they are delimited by a space.第一行是一个正整数首行为一个正整数n &gt; 0，即输入点的总数。随后n行中的第k行给出第k个点：pk = (xk, yk), k = 1, 2, …, n这里，xk与yk均为整数，且二者之间以空格分隔。Output (输出)Let { s1, s2, …, sh } be the indices of all the extreme points, h ≤ n. Output the following integer as your solution:( s1 * s2 * s3 * … * sh * h ) mod (n + 1)若 { s1, s2, …, sh } 为所有极点的编号, h ≤ n，则作为你的解答，请输出以下整数：( s1 * s2 * s3 * … * sh * h ) mod (n + 1)Sample Input (输入样例)12345678910111213141516171819202122231234567891011107 9-8 -1-3 -11 4-3 96 -47 56 6-6 100 8Sample Output (输出样例)12317 &#x2F;&#x2F; ( 9 x 2 x 6 x 7 x 1 x 5 ) % (10 + 1)Limitation (限制)3 ≤ n ≤ 10^5Each coordinate of the points is an integer from (-10^5, 10^5). There are no duplicated points. Each point is selected uniformly randomly in (-10^5, 10^5) x (-10^5, 10^5).All points on extreme edges are regarded as extreme points and hence should be included in your solution.Time Limit: 2 secSpace Limit: 512 MB3 ≤ n ≤ 10^5所有点的坐标均为范围(-10^5, 10^5)内的整数，且没有重合点。每个点在(-10^5, 10^5) x (-10^5, 10^5)范围内均匀随机选取极边上的所有点均被视作极点，故在输出时亦不得遗漏时间限制：2 sec空间限制：512 MBHint (提示)Use the CH algorithms presented in the lectures.课程中讲解过的凸包算法解答：Graham Scan算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;struct point &#123; long long x, y, id; point() :x(0), y(0) &#123;&#125; point(long long x, long long y) :x(x), y(y) &#123;&#125; bool operator ==(const point&amp; p) const &#123; return x == p.x &amp;&amp; y == p.y; &#125;&#125;PP; //PP: Polar Pointvector&lt;point&gt; points;long long area2(point p, point q, point s) &#123; /* |p.x p.y 1| |q.x q.y 1| == 2*DirectedTriangleArea(p,q,s) |s.x s.y 1| */ return p.x * q.y - s.x * q.y + q.x * s.y - q.x * p.y + s.x * p.y - p.x * s.y;&#125;bool toLeftTest(point p, point q, point s) &#123; //When return value large than 0, S is on the left side of ray PQ return area2(p, q, s) &gt; 0;&#125;bool toLeftTest2(point p, point q, point s) &#123; //When return value large than 0, S is on the left side of ray PQ return area2(p, q, s) &gt;= 0;&#125;bool cmp(const point&amp; p1, const point&amp; p2) &#123; // Sort according to polar angle return PP == p1 || !(PP == p2) &amp;&amp; toLeftTest(PP, p1, p2);&#125;point LTL(vector&lt;point&gt;&amp; points) &#123; //Lowest then leftmost point ltl = points[0]; for (int i = 1; i &lt; points.size(); i++) &#123; if (points[i].y &lt; ltl.y || points[i].y == ltl.y &amp;&amp; points[i].x &lt; ltl.x) ltl = points[i]; &#125; return ltl;&#125;vector&lt;point&gt; grahamScan() &#123; PP = LTL(points); sort(points.begin(), points.end(), cmp); vector&lt;point&gt; S, T; S.push_back(points[0]); S.push_back(points[1]); for (int i = points.size() - 1; i &gt; 1; i--)T.push_back(points[i]); while (!T.empty()) &#123; if (toLeftTest2(S[S.size() - 2], S[S.size() - 1], T[T.size() - 1])) &#123; S.push_back(T[T.size() - 1]); T.pop_back(); &#125; else S.pop_back(); &#125; return S;&#125;int main() &#123; ios::sync_with_stdio(false); long long n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; point tmp; cin &gt;&gt; tmp.x &gt;&gt; tmp.y; tmp.id = i; points.push_back(tmp); &#125; vector&lt;point&gt; result; if (points.size() &gt; 2)result = grahamScan(); else result = points; long long res = 1; for (int i = 0; i &lt; result.size(); i++) &#123; //cout &lt;&lt; result[i].id &lt;&lt; endl;//debug res = ((res % (n + 1)) * (result[i].id % (n + 1))) % (n + 1); &#125; res = ((res % (n + 1)) * (result.size() % (n + 1))) % (n + 1); cout &lt;&lt; res; system(\"pause\"); return 0;&#125;分数：92.5使用Graham Scan算法。凸包板子题。","categories":[{"name":"OJ","slug":"OJ","permalink":"https://www.longlongqin.top/categories/OJ/"}],"tags":[{"name":"OJ","slug":"OJ","permalink":"https://www.longlongqin.top/tags/OJ/"}]},{"title":"32、黑客&攻击","slug":"学习笔记/《计算机科学速成课》笔记/32、黑客&攻击","date":"2020-03-04T08:59:43.000Z","updated":"2020-03-17T08:51:19.476Z","comments":true,"path":"archives/622.html","link":"","permalink":"https://www.longlongqin.top/archives/622.html","excerpt":"黑客入侵最常见的方式不是通过技术，而是欺骗别人，这个称为社会工程学（Social Engineering），通过欺骗别人来让人泄露秘密，或让人配置电脑系统来变得易于攻击。最常见的攻击是网络钓鱼（Phishing），其次还有假托（Pretexting），攻击者给某个公司打电话，假装是IT部门的人，攻击者的第一通电话一般会叫人转接，这样另一个接的时候，电话看起来就像内部的，然后让别人把电脑配置得易于入侵，或者让他们泄露机密信息，比如密码或网络配置。","text":"黑客入侵最常见的方式不是通过技术，而是欺骗别人，这个称为社会工程学（Social Engineering），通过欺骗别人来让人泄露秘密，或让人配置电脑系统来变得易于攻击。最常见的攻击是网络钓鱼（Phishing），其次还有假托（Pretexting），攻击者给某个公司打电话，假装是IT部门的人，攻击者的第一通电话一般会叫人转接，这样另一个接的时候，电话看起来就像内部的，然后让别人把电脑配置得易于入侵，或者让他们泄露机密信息，比如密码或网络配置。邮件里带木马（trojan horse）也是常见手段，木马通常会伪装成无害的东西，比如照片或发票，但实际上是恶意软件，有的会偷数据，有的会加密文件。如果攻击者无法用木马或电话欺骗，攻击者只能被迫使用其他手段，方法之一就是暴力破解，尝试所有可能的密码，直到进入系统，大多数现代系统会加长等待时间来抵御这种攻击，每次失败就加长等待时间，甚至超过一定次数后，完全封锁。现在出现了一种攻破方法称为NAND镜像，如果能物理接触到电脑，可以往内存上接几根线，复制整个内存，然后暴力尝试密码，直到设备让你等待。这时只要把复制的内容覆盖掉内存，本质上重置了内存，就不用等待，可以继续尝试密码。如果无法物理接触到设备，就需要远程攻击，比如通过互联网，这一般需要攻击者利用系统漏洞，来获得某些能力或访问权限，称为漏洞利用（Exploit）。一种常见的漏洞利用叫缓冲区溢出（Buffer Overflow），这里的缓冲区是指预留的一块内存空间，比如我们在系统登录界面输入用户名和密码，而系统是用缓冲区来存储输入值的，假设缓冲区大小为10，并且缓冲区前后肯定还有其他数据，当用户输入用户名和密码时，这些值就会被复制到缓冲区中来进行验证，而该方法会溢出缓冲区，比如输入超过10个字符的密码，会覆盖掉相邻的数据，有时会让程序或系统崩溃，因为重要值被垃圾数据覆盖掉了。这里只是让系统崩溃，但是攻击者可以输入有意义的新值到程序的内存中，比如把is_admin标志位的值改为true，有了任意修改内存的能力，黑客就可以绕过登录这类东西，甚至使用那个程序劫持整个系统。有许多方法阻止缓冲区溢出，最简单的方法就是复制到内存之前先检查长度，称为边界检查（Bounds checking），许多现代编程语言都自带边界检查，程序也会随机存放变量在内存中的位置，这样黑客就不知道应该覆盖内存的哪部分，使得更容易让程序崩溃，而不是获得访问权限。程序也可以在缓冲区后，预留一些不用的空间，然后跟踪里面的值，看是否发生变化，来判断是否有攻击，这些不用的内存空间称为金丝雀（Canaries）。另一种经典手段是代码注入（Code Injection），最常用于攻击用数据库的网站。假设网页上有登录提示，当用户点击“登录”，输入文本就会发送服务器，服务器就会运行代码，检查用户名是否存在，如果存在就看密码是否匹配。为此服务器会执行一段sql查询代码，比如1SELECT password FROM users WHERE username='___';这里语句就是要从users表中查找username为___的密码password。 这里的___就是用户输入的用户名。由此攻击者就能把sql命令输入到用户名中，比如whatever&#39;;DROP TABLE users;&#39;，这时上面的查询语句就会变成1SELECT password FROM users WHERE username='whatever';DROP TABLE users;';如果服务器存在用户名wharever，数据库就会返回密码， 当然我们无法得知密码是什么，所以服务器会拒绝我们；如果不存在用户名wharever，服务器会返回空密码或者直接错误，服务器也会拒绝我们。 但是我们关心的是后面的代码DROP TABLE users;这个是我们注入的命令，这个命令是删掉users这张表。如今几乎所有服务器都会防御这种手段。程序员需要认识到从外界输入的信息都是危险的，必须要好好检查，很多用户名和密码表单，不会让你直接输入特殊符号，比如分号或括号，来作为第一道防御。好的服务器也会清理输入，比如修改或删除特殊字符，然后才放到数据库查询语句中。当软件制造者不知道的新漏洞被发现时，称为0day漏洞（Zero Day Vulnerability），黑客就会抢在白帽程序员做出补丁之前尽可能利用漏洞。如果有足够多的电脑有漏洞，让恶意程序可以自动地在电脑之间互相传播，称为蠕虫（Worm）。如果黑客拿下大量电脑，这些电脑可以组成僵尸网络（Botnet），可以用于很多目的，比如发大量垃圾邮件等，用别人电脑的计算能力来挖比特币，或发起DDOS来攻击服务器。DDOS就是僵尸网络里的所有电脑发一大堆垃圾信息到服务器上，造成服务器的阻塞。完~~~","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.longlongqin.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"《计算机科学速成课》","slug":"《计算机科学速成课》","permalink":"https://www.longlongqin.top/tags/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE%E3%80%8B/"}]},{"title":"Hexo 博客框架搭建","slug":"Hexo博客搭建/Hexo博客框架搭建","date":"2020-03-01T13:27:52.000Z","updated":"2020-03-17T08:12:17.477Z","comments":true,"path":"archives/7f7e.html","link":"","permalink":"https://www.longlongqin.top/archives/7f7e.html","excerpt":"搭建这个博客起因是2020年的二月末的某一天晚上，无聊逛B站，然后就看到了一个博客搭建教程，随机就有了这一系列的文章了。","text":"搭建这个博客起因是2020年的二月末的某一天晚上，无聊逛B站，然后就看到了一个博客搭建教程，随机就有了这一系列的文章了。前言我的是在windows操作系统上面，在其他的系统上面大同小异。也参考了很多文章及视频教程。主要参考的是：程序羊的视频：https://www.bilibili.com/video/av44544186?from=search&amp;seid=12981624311298276946文章：https://ouwen666.gitee.io/2020/01/29/Hexo+Gitee搭建个人博客作者部署的是giteehttps://godweiyang.com/2018/04/13/hexo-blog/#toc-heading-6含有个性化配置注：文中的指令都是在cmd（Windows中的命令提示符）中完成的。如果在这之前电脑上就已经安装了Git bash，那么也可以在Git bash中运行指令。下面会用得到的命令npm install=npm i。在git clone项目的时候，项目文件中并没有 node_modules文件夹，项目的依赖文件可能很大。直接执行，npm会根据package.json配置文件中的依赖配置下载安装。-global=-g，全局安装，安装后的包位于系统预设目录下--save=-S，安装的包将写入package.json里面的dependencies，dependencies：生产环境需要依赖的库开始配置安装Node.js博客框架Hexo是基于Node.js制作的静态博客，我们待会要用到Node.js里面的npm(node package manager)包管理器来安装插件。可以点击这里进入其官网。进入之后，按照操作系统进行下载安装。如上图是Windows系统64位的版本，上面官方推荐下载的版本。安装选项就按默认的，一直点击Next。然后，检验是否安装成功：用Win+R命令打开命令提示符，输入node -v 和npm -v ，出现版本号，则说明安装成功。添加cnpm注：因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，如果npm的服务器在中国就好了，所以我们乐于分享的淘宝团队干了这事。来自官网：“这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。”所以我们可以利用npm安装cnpm，再cmd中输入：1npm install cnpm -g –registry=https://registry.npm.taobao.org再输入：cnpm -v来检验是否安装成功。此时，假设我们Node.js安装成功。安装Hexo框架我们要利用Hexo框架模型来搭建我们的博客。点击这里可以进入其官网。下载该框架也仍然是在cmd（Windows中的“命令提示符”）中输入指令完成的。在上一步我们安装了cnpm，现在我们要用它来安装hexo，用cnpm安装的速度更快一些，也可以用npm：1cnpm install -g hexo-cli检验是否安装成功，当运行之后出现版本号则安装成功：1hexo -v现在，我们的Hexo框架已经安装成功了。初始化Hexo想要看到博客运行起来，我们现在还需要对Hexo框架进行初始化。在你的电脑上找一个合适的位置，创建一个文件夹，名字可以随便取，可以用Blog等等的名字，随个人喜好取名。为了便于演示，假设你取的名字叫做：blog注意，初始化是在我们创建的这个blog文件夹中初始化的，所以，我们的命令提示符（cmd）左边的路径要在这个blog文件夹中。进入刚刚创建的文件夹中然后，在输入指令 ：1hexo init初始化完成后，我们的blog文件夹中，就会生成这些文件：node_modules: 依赖包public：存放生成的页面scaffolds：生成文章的一些模板source：用来存放你的文章themes：主题_config.yml: 博客的配置文件在安装一些必要的包：1npm install初始化完成，在打开hexo服务器：123$ hexo sINFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.我们，打开浏览器，输入：localhost:4000，就可以看到你的博客的雏形已经好了。更换主题加入你觉得这个主题你不喜欢，想要找一个其他的主题，你可以进入Hexo的官网的主题板块，来选择你喜欢的主题：假如，你想更换为3-hexo，那就点击它，会跳转到该主题的创作者的GitHub上：安装3-hexo主题，其中命令的themes/3-hexo指的是该主题的安装位置：1git clone https://github.com/yelog/hexo-theme-3-hexo.git themes/3-hexo安装完之后，我们需要运行：123$ hexo clean # 清除所有记录 $ hexo generate # 生成静态网页 简写：hexo g$ hexo server # 启动服务 简写：hexo s然后，我们就能在本地localhost:4000中，查看修改好的主题了。安装Git如果你不想只在本地上查看你的博客，也想有自己的博客网址链接，那我们可以下载Git，把博客内容部署到GitHub或者gitee上面。我们这里以GitHub为例。Git的官网点击这里。然后按照你的电脑的操作系统下载相应的版本。安装选项还是全部默认，只不过最后一步添加路径时选择Use Git from the Windows Command Prompt，这样我们就可以直接在命令提示符里打开git了。安装完成后在命令提示符中输入git --version验证是否安装成功。GitHub账号如果你没有GitHub账号，我们现在去创建一个吧。点击这里创建。创建完成之后，我们新建一个github仓库：注意你的仓库名字不要随便起，待会我们要用到。加入你GitHub名字叫“AAA”，那么仓库个名字就一定是：AAA.github.io：部署博客将博客部署在github中目前，还不能部署到GitHub上。还需要下载hexo-deployer-git插件：1cnpm install hexo-deployer-git --save #通过cpnm安装git插件如果，你是刚刚才下载的Git，则还需要设置你的姓名和邮箱：12git config --global user.name \"Firstname Lastname\" // 名字使用英文输入git config --global user.email \"your_email@example.com\"还有你的SSH Key，创建公开密钥：1ssh-keygen -t rsa -C &quot;your_email@example.com&quot;​ 把生成的密钥添加到GitHub中去：找到生成的密钥：如果一切顺利的话，可以在用户主目录里找到.ssh目录，我的在：C:\\Users\\xxxx\\.ssh（xxxx是我的一个目录）。里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便，把公钥复制进去。到这里，我们的git与远程的GitHub已经建立起关系了。我们还需要把blog文件夹中的设置文件，即：_config.yml，将最后一行进行修改,：1234deploy: type: git repository: https://github.com/longlongqin/longlongqin.github.io.git branch: master​ repository修改为你自己的github项目地址，在实际操作过程中，repository: git@github.com:longlongqin/longlongqin.github.io.git,也是可以的。修改之后，我们才能部署到GitHub上：12$ hexo deployer## 初次使用这个命令，需要输入github的用户名username和密码password​ 这里，就是利用刚下载的插件：hexo-deployer-git现在我们可以访问我们在github服务器上的博客网址，网址就是我们刚刚创建仓库的名字，比如我的仓库名是：longlongqin.github.io，我们复制粘贴它到浏览器，然后你就可以看到你的博客内容了。😊Git提交到多个仓库https://yuxiang.ren/2017/08/25/hexo%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%88%B0%E5%A4%9A%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/部署在gitee部署在gitee上的坑在gitee上面，和在GitHub上面部署差不多，但是有些地方我们还是要注意的。仓库命名问题在创建gitee仓库时，最好也是将仓库名字命名为你的账号的用户名，比如我的：​ 当然，你也可以命名为其他名字，但是换成其他名字之后，可能会带来一系列其他的问题，比如图片无法显示。其实我之前命名成其他名字，就出现了很大的问题：这种情况是因为，他找不到资源，加载错误：熬了一个晚上，终于发现了。在官方文档中有：网站在子目录的情况如果你的网站在一个子目录（例如http://example.org/blog） 设置url为http://example.org/blog并且设置root为/blog/说来也奇怪，在GitHub上面，和本地运行的时候都是好好的。就是在gitee上面出错了。o(︶︿︶)o 唉解决它的办法就是：​ 将root添加上缺少的那一级目录，即可1234567891011121314151617# URL## If your site is put in a subdirectory, set url as'http://yoursite.com/child' and root as '/child/'url: http://yoursite.com/childroot: /blog/permalink: :year/:month/:day/:post_title/permalink_defaults:pretty_urls: trailing_index: false # Set to false to remove trailing 'index.html' from permalinks trailing_html: true # Set to false to remove trailing '.html' from permalinks这一篇帖子里面也有人遇到了同样的问题，最后也是通过root的修改解决的。：https://gitee.com/oschina/git-osc/issues/IFVWV?from=project-issuegitee pages刷新除了仓库名字需要注意，我们还需要注意，gitee个人版似乎不能自动刷新，所以你每次hexo d之后，需要手动的刷新gitee pages，才能显示你新提交的内容。写文章编辑器推荐推荐使用Typora这款软件，点击这里进入官网，他可以写Markdown格式的内容，这个软件的方便之处在于直接将markdown语法呈现出其效果，并且已经集成了很多方便的功能，你无需记住插入代码的语法格式，无需记住插入图片的语法格式，这使得我可以专心写博客而无法关心学习markdown语法。有很多md编辑器，他们分成两个界面，一个界面是md源代码，另外一个界面实时更新显示其效果，而Typora是浑然一体的，真正所见即所得，就跟在使用word一样方便。不仅如此，它还可以导出PDF、Word、HTML、图片等格式。待续……图片问题http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/Hexo的操作指令我们刚开始，对于Hexo的指令不太熟悉，我们可以在他的官网上去查找相应的操作指令。文章的front-matterFront-matter 选项详解Front-matter 选项中的所有内容均为非必填的。但我仍然建议至少填写 title 和 date的值。配置选项默认值描述titleMarkdown 的文档标题文章标题，强烈建议填写此选项date文档创建时的日期时间发布时间，强烈建议填写此选项，且最好保证全局唯一author根 _config.yml中的 author文章作者imgfeatureImages中的某个值文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: http://xxx.com/xxx.jpgtoptrue（文章是否置顶），如果 top 值为 true，则会作为首页password无文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项toctrue是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项mathjaxfalse是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文档中也需要开启才行summary无文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则进程会自动截取文章的部分内容作为摘要categories无文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类tags无文章标签，一篇文章可以多个标签Front-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量，举例来说：1234---title: Hello Worlddate: 2013/7/13 20:46:25---分类和标签只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。12345categories:- Diarytags:- PS3- Games分类方法的分歧如果您有过使用 WordPress 的经验，就很容易误解 Hexo 的分类方式。WordPress 支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是 Hexo 不支持指定多个同级分类。下面的指定方法：123categories: - Diary - Life会使分类Life成为Diary的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。1234categories:- [Diary, PlayStation]- [Diary, Games]- [Life]此时这篇文章同时包括三个分类： PlayStation 和 Games 分别都是父分类 Diary 的子分类，同时 Life 是一个没有子分类的分类。JSON Front-matter除了 YAML 外，你也可以使用 JSON 来编写 Front-matter，只要将 --- 代换成 ;;; 即可。123&quot;title&quot;: &quot;Hello World&quot;,&quot;date&quot;: &quot;2013&#x2F;7&#x2F;13 20:46:25&quot;;;;配置过程遇到的问题Hexo博客中文章图片不显示的坑这个是真的坑，搞了好久，终于看到一篇博文，才解决了这个问题。放一下这篇文章的传送门。在coding中SSL证书申请失败的坑在搭建到coding中步骤其实和在github中比较相似，就是给仓库命名原则的时候需要注意，尽量让仓库名字与你的用户名相同，即和在github中命名规则相似。如果你之前都很顺利，那么在SSL证书申请时，需要注意了：你会遇到证书申请一直失败的情况。这是为什么呢？是这样的：第一次尝试，查资料说是如果之前你已经在github oages上部署了，你自己买的域名也已经解析过了。此时直接在coding pages中申请ssl的话，会失败。解决的办法就是：先把用于解析github pages的那两条暂停了，如下图所示：然后，我再试试，还是申请失败。出现类似于下面的错误：继续去查。嗯，找到了，申请失败是因为我的域名在国外无法解析，这是我的DNS设置导致的。解决办法：在解析的时候，需要将线路类型改成默认。去试一试，等待一小会哇，终于申请成功了。#Hexo博客备份有时候我们外出，自己的电脑没有带，这时候想写博客怎么办。这也是有办法的，就是我们要先备份我们的博客。这里我们可以备份到github或者gitee.拿github举例：首先，我们先要在GitHub上面建立一个仓库，仓库名字自取，仓库是public还是private，按照自己的心情来就好了。然后，我们要在本地关联远程仓库：我们进入你的本地博客所在的目录，比如我的在D:\\Blog，然后，打开你的Git bash，按顺序输入以下命令：12git init #初始化本地仓库git remote add origin &lt;你的远程仓库的SSH或HTTPS链接&gt; #关联远程仓库（ssh的链接比较快一点）关联完成，然后我们还需要，将本地的推送到远端，同样，按顺序输入一下命令：123git add . #这个‘.’表示将整个文件夹都一起添加到暂存区（不然还要一个个输入文件名）git commit -m \"输入你这次提交的说明\" git push origin master #推送到远程仓库好了，记得按时将本地的备份到远程仓库。至此，本地备份已经完成。如果你想同时备份到gitee和github上面，你可以参考这里。在另外一台电脑上写博客前提是我们把博客备份在github、gitee等上面。然后在新电脑上面：安装 Git、nodejs把你远程的博客备份，clone下来到一个指定的位置（位置自己定）在本地的博客仓库运行：npm install，来 安装依赖包好了，你可开始写博客了。优化技巧优化文章URLseo搜索引擎优化认为，网站的最佳结构是用户从首页点击三次就可以到达任何一个页面，但是我们使用hexo编译的站点打开文章的url是：sitename/year/mounth/day/title四层的结构，这样的url结构很不利于seo，爬虫就会经常爬不到我们的文章，于是，我们需要优化一下网站文章url方案一：我们可以将url直接改成sitename/title的形式，并且title最好是用英文，在根目录的配置文件下修改permalink如下：1234url: https://sunhwee.comroot: /permalink: :title.htmlpermalink_defaults:方案二：使用插件优化url插件hexo-abbrlink实现了这个功能，它将原来的URL地址重新进行了进制转换和再编码。安装hexo-abbrlink。1npm install hexo-abbrlink --save配置博客根目录下的_config.yml文件。12345# permalink: :title/permalink: archives/:abbrlink.htmlabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex运行hexo clean和hexo g命令来重新生成文件看看，可以清楚的看到，URL结构成功变为了3层。来源: 洪卫の博客作者: 洪卫文章链接: https://sunhwee.com/posts/6e8839eb.html#toc-heading-59本文章著作权归作者所有，任何形式的转载都请注明出处。其他参考文章列表：http://dongshuyan.com/2019/05/24/hexo%E5%8D%9A%E5%AE%A2%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/#14-Hexo添加百度统计网络编程系列 Hexo + Github搭建个人博客 · 花田半亩","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.longlongqin.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Hexo主题","slug":"Hexo主题","permalink":"https://www.longlongqin.top/tags/Hexo%E4%B8%BB%E9%A2%98/"}]}]}