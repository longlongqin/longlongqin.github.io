<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>龙龙‘S BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://longlongqin.github.io/"/>
  <updated>2020-04-28T10:26:50.435Z</updated>
  <id>https://longlongqin.github.io/</id>
  
  <author>
    <name>longlongqin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>test your code</title>
    <link href="https://longlongqin.github.io/archives/5937092e.html"/>
    <id>https://longlongqin.github.io/archives/5937092e.html</id>
    <published>2020-05-01T09:43:02.209Z</published>
    <updated>2020-04-28T10:26:50.435Z</updated>
    
    <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapterL</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;p center large&gt;&lt;red&gt;LearnCpp chapterL&lt;/red&gt;&lt;/p&gt;&lt;/center&gt;&lt;center&gt;&lt;red&gt;https://www.learncpp.com&lt;/red&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C/C++" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"/>
    
    
      <category term="C/C++" scheme="https://longlongqin.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>void 指针</title>
    <link href="https://longlongqin.github.io/archives/f482f5a8.html"/>
    <id>https://longlongqin.github.io/archives/f482f5a8.html</id>
    <published>2020-05-01T08:44:31.757Z</published>
    <updated>2020-05-01T09:39:36.238Z</updated>
    
    <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapterP</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h2 id="void指针的声明"><a href="#void指针的声明" class="headerlink" title="void指针的声明"></a>void指针的声明</h2><p><strong>void指针</strong>，也称为“<strong>泛型指针</strong>”。</p><p>是指针的一种特殊类型，<strong>它可以指向任何数据类型的对象</strong>!</p><p>void指针像普通指针一样声明，<strong>使用<code>void</code>关键字作为指针的类型</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *ptr;</span><br></pre></td></tr></table></figure><h2 id="void指针可以指向任何数据类型的对象"><a href="#void指针可以指向任何数据类型的对象" class="headerlink" title="void指针可以指向任何数据类型的对象:"></a>void指针可以指向任何数据类型的对象:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nValue;</span><br><span class="line"><span class="keyword">float</span> fValue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">something sValue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *ptr;</span><br><span class="line">ptr = &amp;nValue; <span class="comment">//✔</span></span><br><span class="line">ptr = &amp;fValue; <span class="comment">//✔</span></span><br><span class="line">ptr = &amp;sValue; <span class="comment">//✔</span></span><br></pre></td></tr></table></figure><h2 id="void指针不能被-解引用"><a href="#void指针不能被-解引用" class="headerlink" title="void指针不能被 解引用"></a>void指针不能被 解引用</h2><p><strong>但是，因为<code>void</code>指针不知道它所指向的对象的类型，所以不能直接解引用！</strong></p><p><strong>相反，<code>void</code>指针必须先显式地转换为另一种指针类型，然后才能解引用。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value &#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">void</span> *voidPtr &#123;&amp;value&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//⭐✖，void指针 不能 解引用</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *voidPtr &lt;&lt; <span class="string">'\n'</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//⭐✔，我们可以将void指针 类型转换为 其他指针类型(这里是 int型指针)，</span></span><br><span class="line"><span class="keyword">int</span> *intPtr &#123;<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(voidPtr)&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *intPtr; <span class="comment">////然后就可以 解引用 了</span></span><br></pre></td></tr></table></figure><h2 id="一个明显的问题"><a href="#一个明显的问题" class="headerlink" title="一个明显的问题"></a>一个明显的问题</h2><p>当void指针不知道指向什么，我们如何转换类型，<strong>这取决于程序猿的设定</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    INT,</span><br><span class="line">    FLOAT,</span><br><span class="line">    CSTRING</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printValue</span><span class="params">(<span class="keyword">void</span> *ptr, Type type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//转换为整型指针 并 解引用</span></span><br><span class="line">        <span class="keyword">case</span> Type::INT:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;* <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(ptr)&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">     <span class="comment">//转换为float指针 并 解引用</span></span><br><span class="line">        <span class="keyword">case</span> Type::FLOAT:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;* <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>*&gt;(ptr)&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//转换为char指针  但 没有解引用⭐</span></span><br><span class="line">        <span class="keyword">case</span> Type::CSTRING:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;  <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(ptr)&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">        <span class="comment">//std::cout知道将char*作为c风格的字符串</span></span><br><span class="line">        <span class="comment">//如果我们要解引用的话，那就只会打印ptr所指向的单个字符</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nValue&#123; <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">float</span> fValue&#123; <span class="number">7.5f</span> &#125;;</span><br><span class="line">    <span class="keyword">char</span> szValue[]&#123; <span class="string">"Mollie"</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    printValue(&amp;nValue, Type::INT);</span><br><span class="line">    printValue(&amp;fValue, Type::FLOAT);</span><br><span class="line">    printValue(&amp;szValue, Type::CSTRING);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://raw.githubusercontent.com/longlongqin/CDN-for-HEXO_BLOG/pig_bed/20200501172041.png" alt="image-20200501171859945"></p><blockquote><p>如果，我们将第26行改为：<code>std::cout &lt;&lt;* static_cast&lt;char*&gt;(ptr)&lt;&lt;&#39;\n&#39;;</code>（即，让它 解引用）。</p><p>结果：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://raw.githubusercontent.com/longlongqin/CDN-for-HEXO_BLOG/pig_bed/20200501172049.png" alt="image-20200501172026127"></p><p>可以看到：如果我们要解引用的话，那就只会打印<code>ptr</code>所指向的单个字符</p></blockquote><h2 id="void指针可以指向空值-nullptr"><a href="#void指针可以指向空值-nullptr" class="headerlink" title="void指针可以指向空值(nullptr)"></a>void指针可以指向空值(nullptr)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *ptr&#123;<span class="literal">nullptr</span>&#125;;</span><br></pre></td></tr></table></figure><h2 id="void指针不能做指针运算"><a href="#void指针不能做指针运算" class="headerlink" title="void指针不能做指针运算"></a>void指针不能做指针运算</h2><p><strong>因为指针运算需要知道 指针指向的对象的大小，但是void指针就不知道它指向的是什么。</strong>所以void指针不能做指针运算（如：++，–）</p><h2 id="不存在void引用"><a href="#不存在void引用" class="headerlink" title="不存在void引用"></a>不存在void引用</h2><p>因为一个“void reference”的类型是“<strong><code>void &amp;</code></strong>”,但是它不知道它引用的值的类型。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="1-除非必要，否则避免使用void指针"><a href="#1-除非必要，否则避免使用void指针" class="headerlink" title="1.除非必要，否则避免使用void指针"></a>1.除非必要，否则避免使用void指针</h3><p>通常，<strong>除非绝对必要，否则避免使用void指针是一个好主意</strong>，因为它们有效地允许您避免类型检查。这允许您在不经意间做一些毫无意义的事情，而编译器也不会抱怨。例如，以下内容是有效的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//承接上面那段函数</span></span><br><span class="line"><span class="keyword">int</span> nValue&#123; <span class="number">5</span> &#125;;</span><br><span class="line">printValue(&amp;nValue, Type::CSTRING);</span><br></pre></td></tr></table></figure><p>它的结果是未知的，在我的电脑上，结果为：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://raw.githubusercontent.com/longlongqin/CDN-for-HEXO_BLOG/pig_bed/20200501173336.png" alt="image-20200501173230056"></p><hr><h3 id="2-void指针与null指针的区别"><a href="#2-void指针与null指针的区别" class="headerlink" title="2.void指针与null指针的区别"></a>2.void指针与null指针的区别</h3><ul><li><p><strong>void指针</strong>：</p><ul><li><p>是一个指针，它可以指向任何类型的对象，但不知道它指向什么类型的对象。</p></li><li><p>空指针必须被显式地转换成另一种确切的类型的指针才能 解引用。</p></li></ul></li><li><p><strong>null指针</strong>：</p><ul><li>空指针是不指向地址的指针。</li></ul></li></ul><p><strong>void指针</strong>可以是一个<strong>null指针</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;p center large&gt;&lt;red&gt;LearnCpp chapterP&lt;/red&gt;&lt;/p&gt;&lt;/center&gt;&lt;center&gt;&lt;red&gt;https://www.learncpp.com&lt;/red&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C/C++" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"/>
    
    
      <category term="C/C++" scheme="https://longlongqin.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>通过指针或引用访问结构体成员</title>
    <link href="https://longlongqin.github.io/archives/7e63bcda.html"/>
    <id>https://longlongqin.github.io/archives/7e63bcda.html</id>
    <published>2020-05-01T03:09:36.861Z</published>
    <updated>2020-05-01T03:26:39.413Z</updated>
    
    <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapterP</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><p>众所周知，通常有一个<strong>指向结构(或类)的指针或引用</strong>。如前所述，您可以使用<strong>成员选择操作符(.)</strong>来选择结构体的成员:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line">Person person; <span class="comment">// define a person</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//person.age = 5;</span></span><br></pre></td></tr></table></figure><p>这个语法也适用于 引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line">Person person; <span class="comment">// define a person</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用对结构体的引用来选择成员</span></span><br><span class="line">Person &amp;ref = person;</span><br><span class="line">ref.age = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>但是，对于指针，您需要先解引用指针的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line">Person person; <span class="comment">// define a person</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用指向结构体的指针进行成员选择</span></span><br><span class="line">Person *ptr = &amp;person;</span><br><span class="line">(*ptr).age = <span class="number">5</span>; <span class="comment">//加小括号是必要的的，因为优先级的关系</span></span><br></pre></td></tr></table></figure><ul><li><p>c++提供了第二个成员选择操作符<strong>(-&gt;)</strong>，<strong>用于从指针进行成员选择</strong>。以下两行是相等的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*ptr).age = <span class="number">5</span>;</span><br><span class="line">ptr-&gt;age = <span class="number">5</span>;  <span class="comment">//当使用指针来访问其成员时，推荐这种语法</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;p center large&gt;&lt;red&gt;LearnCpp chapterP&lt;/red&gt;&lt;/p&gt;&lt;/center&gt;&lt;center&gt;&lt;red&gt;https://www.learncpp.com&lt;/red&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C/C++" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"/>
    
    
      <category term="C/C++" scheme="https://longlongqin.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>引用与const</title>
    <link href="https://longlongqin.github.io/archives/960f81eb.html"/>
    <id>https://longlongqin.github.io/archives/960f81eb.html</id>
    <published>2020-04-30T16:01:26.000Z</published>
    <updated>2020-05-01T03:01:57.610Z</updated>
    
    <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapterP</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h2 id="引用const值"><a href="#引用const值" class="headerlink" title="引用const值"></a>引用const值</h2><p>就像可以声明指向const值的指针一样，也可以声明对const值的引用。这是通过使用const关键字声明引用来实现的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ref = value; <span class="comment">//ref是对const值的引用</span></span><br></pre></td></tr></table></figure><p>对const值的引用通常被简称为<strong>const引用</strong>，尽管这确实导致了一些与指针不一致的命名法。</p><h2 id="初始化对const值的引用"><a href="#初始化对const值的引用" class="headerlink" title="初始化对const值的引用"></a>初始化对const值的引用</h2><p>对非const值的引用，只能用非const l-value 初始化；</p><p>⭐而对const值的引用，可以用 “<strong>非const l-value</strong>”、“<strong>constl-value</strong>”、“<strong>r-value</strong>”来初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ref1 = x; <span class="comment">//✔，x是一个  非const l-value</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> y =<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ref2 =y;  <span class="comment">//✔，y是一个const l-value</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ref3 = <span class="number">19</span>; <span class="comment">//✔，19是一个 r-value</span></span><br></pre></td></tr></table></figure><h2 id="对const值的引用可以引用非const变量"><a href="#对const值的引用可以引用非const变量" class="headerlink" title="对const值的引用可以引用非const变量"></a>对const值的引用可以引用非const变量</h2><p>就像指向 const值 的指针一样，<strong>对const值的引用可以引用非const变量</strong>。</p><blockquote><p>其实就是说：不管你这个值原来是const值，还是 非const值。只用看我这个“引用”（或者 “指针”）是不是 对const值的引用（或者：是不是指向const值），如果是，那么不管你原来的值是不是const值，在我引用（指针指向）之后，我都把它看成是const值。</p></blockquote><blockquote><p>关于如何判断一个引用是否引用的是const值，的方法类似于指针中的方法：</p><p><strong>就是看那个表示引用的符号“&amp;”的左边，如果左边带有关键字const，那么它就是引用的const值。</strong></p></blockquote><h2 id="对r-value的引用延长了引用值的生存期"><a href="#对r-value的引用延长了引用值的生存期" class="headerlink" title="对r-value的引用延长了引用值的生存期"></a>对r-value的引用延长了引用值的生存期</h2><p>通常r-value具有表达式作用域<strong>，这意味着在创建它们的表达式结束时销毁这些值。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="number">2</span>+<span class="number">3</span>;  <span class="comment">//2+3 的结果是 r-value 5，它会在该条语句结束时，被销毁</span></span><br></pre></td></tr></table></figure><p>但是，当使用r-value 初始化<strong>对const值的引用</strong>时，r-value的生存期将被延长为 <strong>引用的生存期。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dothing</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;ref = <span class="number">2</span>+<span class="number">3</span>; </span><br><span class="line"><span class="comment">//通常，2+3的结果具有表达式作用域，并在语句结束时销毁.</span></span><br><span class="line"><span class="comment">//但是因为 2+3的结果现在已经被绑定到一个 对const值的引用  上面了，</span></span><br><span class="line"><span class="comment">//所这个r-value的生命周期被延长了</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ref; <span class="comment">//我们在这还可以用它</span></span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">//当const引用终止时，r-value的生存期被延长到这里</span></span><br></pre></td></tr></table></figure><h2 id="const值的引用作为函数参数"><a href="#const值的引用作为函数参数" class="headerlink" title="const值的引用作为函数参数"></a>const值的引用作为函数参数</h2><p>用作函数参数的引用也可以是常量。这允许我们在<strong>不复制实参</strong>的情况下访问参数，同时保证函数不会改变被引用的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ref是传入参数的const引用，而不是副本</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changN</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;ref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ref = <span class="number">6</span>; <span class="comment">//✖，因为ref是 const</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>const值的引用作为函数参数很有用。因为const值的引用，可以是：</p><ul><li>non-const l-value</li><li>const l-value</li><li>a literal</li><li>表达式的结果</li></ul><p>所以，上面这四种可以通过 const值的引用 被传入函数参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printIt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a =<span class="number">1</span>;</span><br><span class="line">    printIt(a);  <span class="comment">//非const l-value</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    printIt(b);  <span class="comment">//const l-value</span></span><br><span class="line">    </span><br><span class="line">    printIt(<span class="number">3</span>);  <span class="comment">//字面常量 r-value</span></span><br><span class="line">    </span><br><span class="line">    printIt(<span class="number">2</span>+b);  <span class="comment">//表达式 r-value</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>1、为了避免不必要的、代价昂贵的复制，通常应该通过(const)引用传递</p><ul><li>非指针</li><li>非 基本数据类型(int、double等)的变量。（如structs等，可通过 引用 传入函数）</li></ul><p>2、基本数据类型应该通过<strong>值传递</strong>，当函数需要更改它们时，才使用 引用 传入函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;p center large&gt;&lt;red&gt;LearnCpp chapterP&lt;/red&gt;&lt;/p&gt;&lt;/center&gt;&lt;center&gt;&lt;red&gt;https://www.learncpp.com&lt;/red&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C/C++" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"/>
    
    
      <category term="C/C++" scheme="https://longlongqin.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>引用变量</title>
    <link href="https://longlongqin.github.io/archives/fa14c975.html"/>
    <id>https://longlongqin.github.io/archives/fa14c975.html</id>
    <published>2020-04-30T12:20:43.000Z</published>
    <updated>2020-04-30T15:56:49.548Z</updated>
    
    <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapterP</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><p>目前为止我们已经讲过两种基本变量类型：</p><ul><li>普通变量，直接保存值。</li><li>指针，它持有另一个值的地址(或null)，可以解引用以获取它们指向的地址的值。</li></ul><p>现在，我们就来讲一下C++中的第三种基本类型：<strong>引用(Reference)</strong></p><h2 id="引用的概念"><a href="#引用的概念" class="headerlink" title="引用的概念"></a>引用的概念</h2><p><strong>reference（引用）</strong>是C++变量的一个类型，<strong>它充当另一个对象或值的别名</strong>。</p><h3 id="C-支持三种种引用"><a href="#C-支持三种种引用" class="headerlink" title="C++支持三种种引用"></a>C++支持三种种引用</h3><ol><li><strong>引用 非const值</strong>（通常简称“<strong>reference</strong>”，或 <strong>non-const reference</strong>）</li><li><strong>引用 const值</strong>（通常叫做：<strong>const reference</strong>）</li><li>C++11增添了 <strong>r-value reference</strong></li></ol><h2 id="引用非const值"><a href="#引用非const值" class="headerlink" title="引用非const值"></a>引用非const值</h2><p>引用(对非const值的引用) 是<strong>通过引用 “类型” 和”变量名”之间的<code>&amp;</code>来声明的</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value &#123;<span class="number">5</span>&#125;; <span class="comment">//普通变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面写法都是一样的的效果</span></span><br><span class="line"><span class="keyword">int</span> &amp; ref&#123;value&#125;; <span class="comment">//引用变量值</span></span><br><span class="line"><span class="keyword">int</span>&amp; ref&#123;value&#125;;</span><br><span class="line"><span class="keyword">int</span> &amp;ref&#123;value&#125;;</span><br></pre></td></tr></table></figure><h3 id="引用作为别名"><a href="#引用作为别名" class="headerlink" title="引用作为别名"></a>引用作为别名</h3><p>引用的作用通常与它们所引用的值相同。在这个意义上，<strong>引用充当被引用对象的别名</strong>。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x&#123;<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;y&#123;x&#125;; <span class="comment">//y是x的引用</span></span><br><span class="line"><span class="keyword">int</span> &amp;z&#123;y&#125;; <span class="comment">//z也是x的引用</span></span><br></pre></td></tr></table></figure><p>上面的代码片段。设置或获取x、y或z的值将做相同的事情(那就是设置或获取<strong>x的值</strong>)。</p><p>看一看引用的实际应用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value &#123;<span class="number">5</span>&#125;; <span class="comment">//普通的int型变量</span></span><br><span class="line">    <span class="keyword">int</span> &amp;ref&#123;value&#125;; <span class="comment">//引用变量value</span></span><br><span class="line">    </span><br><span class="line">    value = <span class="number">6</span>; <span class="comment">//变量value 的值现在是6</span></span><br><span class="line">    ref = <span class="number">7</span>; <span class="comment">//变量value 的值现在是7</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;value&lt;&lt;<span class="string">'\n'</span>; <span class="comment">//结果为7</span></span><br><span class="line">    ++ref;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;value&lt;&lt;<span class="string">'\n'</span>; <span class="comment">//结果为8</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//看一看：value 和 ref的地址</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; &amp;value;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; &amp;ref;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">006F</span>FD30</span><br><span class="line"><span class="number">006F</span>FD30</span><br></pre></td></tr></table></figure><p>在上面的例子中，ref和value被视为是相同的。(可以看到ref和value的地址都是一样的)。</p><h2 id="l-values-and-r-values"><a href="#l-values-and-r-values" class="headerlink" title="l-values and r-values"></a>l-values and r-values</h2><blockquote><p>l-values and r-values：<strong>左值</strong> 与 <strong>右值</strong></p></blockquote><h3 id="左值"><a href="#左值" class="headerlink" title="左值"></a>左值</h3><p>在C++中，<strong>变量</strong>是<strong>l-value（左值）</strong>的一种类型；左值是一个<strong>有地址</strong>的值(在内存中)。</p><p>因为所有的<strong>变量</strong>都<strong>有地址</strong>，所以所有的变量都<strong>是左值</strong>。</p><p>之所以称为<strong>l-value</strong>，是因为<strong>l-value</strong>是<strong>赋值语句左边惟一的值</strong>。当我们赋值时，赋值操作符的左边必须是<strong>I-value</strong>。</p><blockquote><p>所以，像这种句子： <code>5 = 6;</code>将会造成编译错误，因为5不是I-value。字面值5是没有地址的（即，它不在内存中）。</p></blockquote><p>当一个<strong>I-value</strong>被赋值时，该内存地址的当前值将被覆盖。</p><h3 id="右值"><a href="#右值" class="headerlink" title="右值"></a>右值</h3><p>与<strong>l-value</strong>相反的是<strong>r-value</strong>。<strong>r-value</strong>是一个非<strong>l-value</strong>的表达式。</p><blockquote><p><strong>r-value</strong>的例子有字面值(比如<code>5</code>，结果是5)和非<strong>l-value</strong>的表达式(比如 <code>2 + x</code>)。</p></blockquote><p>下面是一些例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> y; <span class="comment">//将y定义为一个整型变量</span></span><br><span class="line">y=<span class="number">4</span>;<span class="comment">//4 的结果是4，然后赋值给y</span></span><br><span class="line">y=<span class="number">2</span>+<span class="number">5</span>;  <span class="comment">//2+5 的结果是7，然后赋值给y</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x; <span class="comment">//将x定义为一个整型变量</span></span><br><span class="line">x=y;<span class="comment">//y的值是7(之前的值)，然后赋值给x。</span></span><br><span class="line">x=x;<span class="comment">//x的结果是7，然后赋值给x(没用!)</span></span><br><span class="line">x=x+<span class="number">1</span>;  <span class="comment">//x + 1 的结果等于8，然后赋值给x。</span></span><br></pre></td></tr></table></figure><h4 id="分析：x-x-1"><a href="#分析：x-x-1" class="headerlink" title="分析：x=x+1"></a>分析：<code>x=x+1</code></h4><p><code>x=x+1;</code>这个语句看起来很迷糊。</p><ul><li><p>赋值操作符“=” 左边的“x”是一个I-value（有地址的变量）；</p></li><li><p>赋值操作符“=” 右边的“x”是一个r-value，它将被计算并生成一个值（这里生成的值为7）。</p></li></ul><p>当c++对上述语句求值时，它的计算结果为:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">7</span> + <span class="number">1</span>; <span class="comment">//这样就比较清晰了</span></span><br></pre></td></tr></table></figure><p>其实，可以分析为：</p><p>在赋值操作符“=”的<strong>左侧</strong>，<strong>必须有表示内存地址的内容(例如变量)。</strong></p><p>赋值操作符“=”的<strong>右侧 的所有内容都将被计算以生成一个值。</strong></p><h2 id="引用必须被初始化"><a href="#引用必须被初始化" class="headerlink" title="引用必须被初始化"></a>引用必须被初始化</h2><p>创建引用时必须初始化:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value &#123;<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;a &#123;value&#125;; <span class="comment">//有效的引用，初始化为变量value</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;b; <span class="comment">//无效，因为没有被初始化</span></span><br></pre></td></tr></table></figure><p><strong>不像指针可以持有空值，没有空引用这样的东西。</strong></p><h3 id="引用-非const值-只能被初始化为非const-的左值"><a href="#引用-非const值-只能被初始化为非const-的左值" class="headerlink" title="引用 非const值 只能被初始化为非const 的左值"></a>引用 非const值 只能被初始化为非const 的左值</h3><p>对非const值的引用<strong>只能用非const l-value 初始化</strong>。不能使用<strong>const l-value</strong>或<strong>r-value</strong>初始化它们。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x&#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;a&#123;x&#125;; <span class="comment">//✔，因为x是一个非常量的左值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;b&#123;x+<span class="number">1</span>&#125;; <span class="comment">//✖，因为"x+1"是一个右值（它没有地址的）⭐</span></span><br><span class="line"><span class="keyword">int</span> &amp;d&#123;<span class="number">6</span>&#125;;   <span class="comment">//✖，因为6是一个右值⭐</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> y&#123;<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> &amp;c&#123;y&#125;;    <span class="comment">//✖，因为y是一个 常量左值（**const l-value**）⭐</span></span><br></pre></td></tr></table></figure><h2 id="引用不能被重新分配"><a href="#引用不能被重新分配" class="headerlink" title="引用不能被重新分配"></a>引用不能被重新分配</h2><p><strong>初始化后，不能将引用更改为引用另一个变量</strong>。考虑以下片段:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value1&#123;<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> value2&#123;<span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;a&#123;value1&#125;; <span class="comment">//✔，ref现在是value1的别名</span></span><br><span class="line"></span><br><span class="line">ref = vlaue2; <span class="comment">//注意⭐：这里value2其实是一个右值。执行这个语句：就是将value2的值赋给value1。.  而不是将引用重新分配称为变量value2的别名呀~~~</span></span><br></pre></td></tr></table></figure><p>为了说明上面的那个语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; //std::sort</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123; <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> y&#123; <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x原来的值是："</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;a&#123; x &#125;;</span><br><span class="line">    a = y;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"引用a的值是："</span> &lt;&lt; a&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x现在的值为："</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"因为引用‘a’是x的别名，a的值改变，所以x的值也会被改变"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://raw.githubusercontent.com/longlongqin/CDN-for-HEXO_BLOG/pig_bed/20200430231138.png" alt="1"></p><h2 id="引用作为函数参数"><a href="#引用作为函数参数" class="headerlink" title="引用作为函数参数"></a>引用作为函数参数</h2><p>在<a href="http://www.learncpp.com/cpp-tutorial/6-8-pointers-and-arrays/" target="_blank" rel="noopener">6.8 – Pointers and arrays</a> 中，我们讨论了如何将指针参数传递给函数，使函数可以取消对指针的引用，<strong>从而直接修改参数的值。</strong></p><p>引用在这方面的工作类似。<strong>由于“引用”参数作为参数的别名，使用“引用”参数的函数可以修改传入的参数:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ref是传入参数的 引用，而不是副本</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeN</span> <span class="params">(<span class="keyword">int</span> &amp;ref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ref = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n&#123;<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    changeN(n); <span class="comment">//注意，这个参数不需要作为引用</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span>  ⭐这里n的值变了呀</span><br></pre></td></tr></table></figure><p>当实参n被传递给函数时，<strong>函数参数ref被设置为参数n的引用</strong>。</p><h2 id="使用引用将c风格的数组传递给函数"><a href="#使用引用将c风格的数组传递给函数" class="headerlink" title="使用引用将c风格的数组传递给函数"></a>使用引用将c风格的数组传递给函数</h2><p>c风格数组最恼人的问题之一是，在大多数情况下，当求值时，<strong>它们会退化为指针</strong>。</p><p>但是，如果通过引用传递c样式的数组，则不会发生这种退化。</p><blockquote><p>请注意，为了使其工作，<strong>您需要显式地在参数中定义数组大小</strong>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意:您需要在函数声明中指定数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printElements</span><span class="params">(<span class="keyword">int</span> (&amp;arr)[<span class="number">4</span>]  )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果不支持C++17时，请改下面的语句（https://www.yuque.com/longlongqin/pw9qpx/dhwiyd#31df8e7e）</span></span><br><span class="line">    <span class="keyword">int</span> length &#123;<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">std</span>::<span class="built_in">size</span>(arr))&#125;; <span class="comment">//我们可以这样做，因为数组不会退化为指针</span></span><br><span class="line"><span class="comment">//数组退化为指针可参考（https://www.yuque.com/longlongqin/pw9qpx/pmqm1f#Oaepi）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i&#123;<span class="number">0</span>&#125;; i&lt;length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;arr[i]&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[]&#123; <span class="number">99</span>, <span class="number">20</span>, <span class="number">14</span>, <span class="number">80</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    printElements(arr);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用和指针"><a href="#引用和指针" class="headerlink" title="引用和指针"></a>引用和指针</h2><p>引用和指针之间有一种有趣的关系——<strong>引用就像一个指针，在被访问时被隐式地解引用</strong>(引用通常由编译器使用指针在内部实现)。从而得出以下结论:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value &#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> ptr &#123;&amp;value&#125;;</span><br><span class="line"><span class="keyword">int</span> &amp;ref &#123;value&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以看到：下面两个语句是相同的：</span></span><br><span class="line">*ptr = <span class="number">5</span>;</span><br><span class="line">ref = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>由于必须将引用初始化为有效的对象(不能为空)，并且一旦设置就不能更改，因此使用引用通常比使用指针安全得多(因为没有取消引用空指针的风险)。</p><p>如果给定的任务可以通过引用或指针来解决，那么通常应该首选引用。指针应该只在引用不足的情况下使用(比如动态分配内存)。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>引用</strong>允许我们为其他对象或值定义<strong>别名</strong>。对<strong>非const值</strong>的引用只能用<strong>非const l-value</strong>初始化。<strong>引用初始化后不能重新分配（也就是它初始化之后，就一直是那个变量的别名）</strong>。</p><p><strong>当我们想要修改参数的值时</strong>，或者<strong>当我们想要避免对参数进行昂贵的复制时</strong>，引用通常被用作函数参数。</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;p center large&gt;&lt;red&gt;LearnCpp chapterP&lt;/red&gt;&lt;/p&gt;&lt;/center&gt;&lt;center&gt;&lt;red&gt;https://www.learncpp.com&lt;/red&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C/C++" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"/>
    
    
      <category term="C/C++" scheme="https://longlongqin.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>指针与const</title>
    <link href="https://longlongqin.github.io/archives/d0ade39e.html"/>
    <id>https://longlongqin.github.io/archives/d0ade39e.html</id>
    <published>2020-04-30T07:29:16.000Z</published>
    <updated>2020-04-30T10:34:31.406Z</updated>
    
    <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapterP</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><em>注：此文中的类型以int为例，当然也可以换成其他类型，如：double…..</em></p><h2 id="非const指针"><a href="#非const指针" class="headerlink" title="非const指针"></a>非const指针</h2><h3 id="1、int-ptr"><a href="#1、int-ptr" class="headerlink" title="1、int *ptr"></a>1、<code>int *ptr</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *ptr = &amp;value; <span class="comment">//类型转换错误。✖</span></span><br><span class="line"><span class="comment">//不能将“const int”类型（&amp;value）转换为“int *”（ptr）</span></span><br></pre></td></tr></table></figure><p>这很容易理解，假设上面片段可以编译成功。那也就是说，我们可以解引用这个非const的指针来改变这个值。这将会与const变量本质冲突（const的变量的值是不可以更改的）。</p><h3 id="2、const-int-ptr"><a href="#2、const-int-ptr" class="headerlink" title="2、const int *ptr"></a>2、<code>const int *ptr</code></h3><p>若要声明指向const值的指针，请在<strong>数据类型之前使用const</strong>关键字:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> value = <span class="number">5</span>; <span class="comment">//一个int类型的变量value（值为5），value是"const int"</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *ptr = &amp;value; <span class="comment">//✔，ptr是一个非const的指针，它指向一个“const int”</span></span><br><span class="line">*ptr = <span class="number">6</span>;  <span class="comment">//不允许，我们不能改变一个常量值</span></span><br></pre></td></tr></table></figure><p>在这里，不允许通过解引用指针 来改变value的值。<em>ptr是一个非const的指针，它指向一个“const int”</em> 就说明了，指针指向的是常量值，不能改变的奥</p><h4 id="指向const-int-的指针，也可以指向非常量变量"><a href="#指向const-int-的指针，也可以指向非常量变量" class="headerlink" title="指向const int 的指针，也可以指向非常量变量"></a>指向const int 的指针，也可以指向非常量变量</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = <span class="number">5</span>; <span class="comment">//value 不是常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *ptr = &amp;value; <span class="comment">//这样也是可以的</span></span><br></pre></td></tr></table></figure><p>我们可以这样想：</p><p><strong>一个指向const变量的指针</strong>在<strong>通过该指针访问</strong>该变量时将该变量<strong>视为常量</strong>，<strong>而不管变量最初是否定义为const(即，与变量最初是否为const无关)。</strong></p><blockquote><p>因为指向const值的<strong>指针</strong>不是const本身(<strong>它只是指向一个const值</strong>)，<strong>所以可以将指针重定向到指向其他值:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *ptr = &amp;value1; <span class="comment">// ptr points to a const int</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> value2 = <span class="number">6</span>;</span><br><span class="line">ptr = &amp;value2; <span class="comment">// ✔, ptr now points at some other const int</span></span><br></pre></td></tr></table></figure></blockquote><p>当指向const int 的指针，它指向非const变量时：</p><ul><li><strong>不可以</strong>通过 <strong>解引用该指针 来改变该非常量变量的值</strong>；</li><li><strong>但可以</strong>通过 <strong>直接对通过 变量的标识符 来改变该非常量变量的值</strong>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以</span></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *ptr = &amp;value;</span><br><span class="line">value = <span class="number">6</span>; <span class="comment">//✔。因为当通过非const标识符（value是非const的标识符）访问时，</span></span><br><span class="line"><span class="comment">//该值是非const的（所以我们可以直接通过变量的标识符来改变其值）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不可以</span></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *ptr = &amp;value; <span class="comment">// ptr points to a "const int"</span></span><br><span class="line">*ptr = <span class="number">6</span>; <span class="comment">// ✖。因为指针ptr将其值视为常量，因此通过ptr更改值是不合法的</span></span><br></pre></td></tr></table></figure><hr><h2 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a>const指针</h2><p>const指针是指<strong>初始化后</strong>其值（即，它指向的地址）不能改变的指针。</p><blockquote><p>也就是说，const指针：</p><ul><li>只不过是该指针的值（它的值就是一个地址）不能被改变。（即，它只能指向初始化时给定的变量）</li><li>但是，它指向变量的值是可以被修改的。</li></ul></blockquote><h3 id="声明const指针"><a href="#声明const指针" class="headerlink" title="声明const指针"></a>声明const指针</h3><p>要声明一个const指针，<strong>请在”星号”和”指针名称”之间使用const关键字</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> ptr = &amp;value;</span><br></pre></td></tr></table></figure><p><strong>与普通的const变量一样，const指针必须在声明时初始化为一个值</strong></p><p><strong>这意味着const指针总是指向相同的地址</strong>。</p><blockquote><p>在上述情况下，ptr将始终指向value的地址(直到ptr goes out of scope并被销毁)。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a =<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> b =<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> ptr = &amp;a; <span class="comment">//✔，这个const指针被初始化为变量a的地址；</span></span><br><span class="line"></span><br><span class="line">ptr = &amp;b;  <span class="comment">//✖，因为指针ptr是const。所以它一旦被初始化之后，该指针的值（它指向的地址）就不能被改变。</span></span><br></pre></td></tr></table></figure><p>但是，由于所指向的<strong>值</strong>仍然是非const的，所以可以通过解引用 const指针的来更改所指向的值:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> ptr = &amp;value; <span class="comment">// ptr will always point to value</span></span><br><span class="line">*ptr = <span class="number">6</span>; <span class="comment">// ✔，因为ptr指向的是一个非const的int型变量</span></span><br></pre></td></tr></table></figure><h3 id="指向Const值的const指针"><a href="#指向Const值的const指针" class="headerlink" title="指向Const值的const指针"></a>指向Const值的const指针</h3><p>我们可以把它差分成两部分：</p><ul><li>首先是一个 const指针（假如是int类型，变量标识符为a）：<code>int * const a;</code>(将这一部分看成大写字母A)</li><li>然后是一个const的值：<code>const A</code> —–&gt;<strong><code>const int * const a;</code></strong></li></ul><p>也就是在：类型（type）之前 和 变量名之前 使用关键字<code>const</code> 来声明一个指向Const值的const指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> ptr = &amp;value;</span><br></pre></td></tr></table></figure><p>注意：</p><p>指向const值的const指针<strong>不能设置为指向另一个地址</strong>，<strong>它所指向的值也不能通过指针进行更改。</strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>《请记住：const类型的变量（不管是指针还是正常变量）的<strong>声明与初始化是在一起完成的</strong>。》</p><p>总而言之，你只需要记住4条规则，它们都很符合逻辑:</p><ol><li><p><strong>一个非const指针可以被重定向到其他地址。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value1 =<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *ptr1 = &amp;value1; <span class="comment">//是 非const指针。（它指向的是非const变量的地址）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> value2 =<span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *ptr2 = &amp;value2;<span class="comment">//也是 非const指针。（不过它指向的是 const变量的地址）</span></span><br></pre></td></tr></table></figure></li><li><p><strong>一个const指针在初始化之后，它指向的地址就不能被改变了。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> ptr =&amp;value; <span class="comment">//是 const指针。（它指向的是非const变量的地址）</span></span><br></pre></td></tr></table></figure></li><li><p><strong>指向非const值的指针可以更改它所指向的值。但是这些指针不能指向一个常量(const)值。</strong></p></li><li><p><strong>指向const值的const指针将该值视为const(即使它不是)，因此不能更改它所指向的值。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1️⃣指向const值的指针将该值视为const(该值不是const)</span></span><br><span class="line"><span class="keyword">int</span> value1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> ptr1 = &amp;value; <span class="comment">//ptr是一个指向const值的const指针，</span></span><br><span class="line"><span class="comment">//所以，它指向的这个value1的值是不能被改变的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2️⃣指向const值的指针将该值视为const(该值是const)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> value2 = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> ptr2 = &amp;value2; <span class="comment">//同样指针ptr2指向的value2的值也不能被改变</span></span><br></pre></td></tr></table></figure></li></ol><hr><p>保持声明语法的正确性是很有挑战性的。只要记住<strong>指针指向的值的类型总是在最左边</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *ptr1 = &amp;value; <span class="comment">//ptr1指向“const int”,这是一个指向const值的指针。</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> ptr2 = &amp;value; <span class="comment">//ptr2指向“int”,这是一个指向非const值的const指针。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> ptr3 = &amp;value; <span class="comment">//ptr3指向“const int” ,这是一个指向const值的const指针</span></span><br></pre></td></tr></table></figure><h3 id="图示："><a href="#图示：" class="headerlink" title="图示："></a>图示：</h3><blockquote><p>突然想到：</p><p>1、若要声明指向const值的指针，请在<strong>数据类型之前使用const</strong>关键字。（如下图的①、③）</p><p>2、下面的①、②、③都可以<strong>指向 “非const 值”；</strong></p><p>3、<strong>是否可以通过指针的解引用来改变指针所指向的值</strong>。需要看该指针指向的值 是“const int” 还是 “int”？</p><ul><li>如果是“const int”，那就不能 解引用指针 去改变它所指向的值。</li><li>如果是“int”，那就可以。</li></ul><p>4、一个<strong>指向const变量的指针</strong>在通过该指针访问该变量时将该变量<strong>视为常量(const)</strong>，而不管变量最初是否定义为const (即，与变量最初是否为const无关)。</p><p>5、当<strong>指向“const int” 的指针</strong>，它指向非const变量时：</p><ul><li><strong>不可以</strong>通过 <strong>解引用该指针 来改变该非常量变量的值</strong>；</li><li><strong>但可以</strong>通过 <strong>直接对通过 变量的标识符 来改变该非常量变量的值</strong>。</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://raw.githubusercontent.com/longlongqin/CDN-for-HEXO_BLOG/pig_bed/20200430172652.jpg" alt="IMG_20200430_172308"></p><p><strong>再次提醒：本文只是以“int”类型来作为说明，我们可以换成其他类型，如：double等等</strong></p><h3 id="用一个程序来说明："><a href="#用一个程序来说明：" class="headerlink" title="用一个程序来说明："></a>用一个程序来说明：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/************非const的变量***************/</span></span><br><span class="line">    <span class="keyword">int</span> value1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> value2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> value3 = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> value4 = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">int</span> *ptr1 = &amp;value1;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *ptr2 = &amp;value2;</span><br><span class="line">    <span class="keyword">int</span> * <span class="keyword">const</span> ptr3 = &amp;value3;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> ptr4 = &amp;value4;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过指针的解引用，改变变量的值</span></span><br><span class="line">    *ptr1 = <span class="number">10</span>;</span><br><span class="line">    *ptr2 = <span class="number">20</span>;  <span class="comment">//✖，因为ptr2是非const指针（它指向“const int”，即，它指向的值不可以通过解引用指针被改变）</span></span><br><span class="line">    *ptr3 = <span class="number">30</span>;  </span><br><span class="line">    *ptr4 = <span class="number">40</span>;  <span class="comment">//✖，因为ptr4它指向“const int”（是const指针），但是value是“int”.类型不匹配</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/************const的变量***************/</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> value5 = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> value6 = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> value7 = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> value8 = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *ptr5 = &amp;value5; <span class="comment">//✖，非const指针（它指向“int”），所以不能指向“const int”的值value5</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *ptr6 = &amp;value6;</span><br><span class="line">    <span class="keyword">int</span> * <span class="keyword">const</span> ptr7 = &amp;value7; <span class="comment">//✖，const指针（它指向“int”）,但是value7 是“const int”。所以不匹配</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> ptr8 = &amp;value8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//防止在visual studio 软件中闪退</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;p center large&gt;&lt;red&gt;LearnCpp chapterP&lt;/red&gt;&lt;/p&gt;&lt;/center&gt;&lt;center&gt;&lt;red&gt;https://www.learncpp.com&lt;/red&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C/C++" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"/>
    
    
      <category term="C/C++" scheme="https://longlongqin.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>指针与数组</title>
    <link href="https://longlongqin.github.io/archives/13ba6384.html"/>
    <id>https://longlongqin.github.io/archives/13ba6384.html</id>
    <published>2020-04-29T00:42:27.000Z</published>
    <updated>2020-04-30T15:20:01.756Z</updated>
    
    <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapterL</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h2 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h2><p>误区：在c++中，一个常见的谬误是认为数组和指向数组的指针是相同的。</p><p>真实情况是：</p><p>在下面例子中，数组的类型为：<code>int[5]</code>；数组的“值”就是数组的元素。</p><p>指向数组的指针的类型为：<code>int*</code>；它的值是数组第一个元素的地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>]&#123; <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// print address of the array's first element</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Element 0 has address: "</span> &lt;&lt; &amp;<span class="built_in">array</span>[<span class="number">0</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// print the value of the pointer the array decays to</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The array decays to a pointer holding address: "</span> &lt;&lt; <span class="built_in">array</span> &lt;&lt; '\n';</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*结果*/</span><br><span class="line">Element 0 has address: 0042FD5C</span><br><span class="line">The <span class="built_in">array</span> decays to a pointer holding address: 0042FD5C</span><br></pre></td></tr></table></figure><blockquote><p>array decays to a pointer：数组在某些情况下将<strong>退化</strong>为<strong>指针</strong></p><p>注意：数组退化为指针时，它是指向第一个元素的指针。</p></blockquote><h2 id="解引用数组"><a href="#解引用数组" class="headerlink" title="解引用数组"></a>解引用数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>]&#123; <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// dereferencing an array returns the first element (element 0)</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *<span class="built_in">array</span>; <span class="comment">// will print 9!</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span> name[]&#123; <span class="string">"Jason"</span> &#125;; <span class="comment">// C-style string (also an array)</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *name &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// will print 'J'⭐</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，我们并不是真正的解引用数组本身。</p><p>真实情况是：数组(类型为<code>int[5]</code>)被隐式转换为指针(类型为<code>int *</code>)，<strong>我们其实是解引用这个指针来获得指针所在的内存地址的值(数组第一个元素的值)。</strong></p></blockquote><h2 id="指定一个指针指向数组"><a href="#指定一个指针指向数组" class="headerlink" title="指定一个指针指向数组"></a>指定一个指针指向数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>]&#123; <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *<span class="built_in">array</span> &lt;&lt; '\n'; // will <span class="built_in">print</span> 9</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> *ptr&#123; <span class="built_in">array</span> &#125;;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *ptr &lt;&lt; '\n'; // will <span class="built_in">print</span> 9</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组退化为一个指针(类型为<code>int*</code>)，我们的指针(类型也是<code>int*</code>)也有相同的类型。</p><h2 id="指针与定长数组的区别"><a href="#指针与定长数组的区别" class="headerlink" title="指针与定长数组的区别"></a>指针与定长数组的区别</h2><h3 id="使用sizeof-的区别"><a href="#使用sizeof-的区别" class="headerlink" title="使用sizeof()的区别"></a>使用<code>sizeof()</code>的区别</h3><p>当在固定数组上使用时，<strong>sizeof返回整个数组的大小(数组长度*元素大小)。</strong></p><p>在指针上使用时，<strong>sizeof返回内存地址的大小(以字节为单位)。</strong>下面的程序说明了这一点:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#Include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>] &#123; <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="keyword">sizeof</span>(<span class="built_in">array</span>) &lt;&lt;<span class="string">'\n'</span>; <span class="comment">//：打印sizeof(int) *数组大小</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> *ptr &#123;<span class="built_in">array</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="keyword">sizeof</span>(ptr)&lt;&lt;<span class="string">'\n'</span>; <span class="comment">// 将打印指针的大小</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="使用取地址操作符-amp-的区别"><a href="#使用取地址操作符-amp-的区别" class="headerlink" title="使用取地址操作符(&amp;)的区别"></a>使用取地址操作符(&amp;)的区别</h3><p><strong>获取指针的地址会得到指针变量的内存地址</strong>。</p><p><strong>获取数组地址将返回一个指向整个数组的指针</strong>。这个指针也指向数组的第一个元素，但是类型信息不同(在上面的例子中，是int(*)[5])。你不太可能需要用到这个。</p><h2 id="————————————–"><a href="#————————————–" class="headerlink" title="————————————–"></a>————————————–</h2><h2 id="指针的运算与数组的索引"><a href="#指针的运算与数组的索引" class="headerlink" title="指针的运算与数组的索引"></a>指针的运算与数组的索引</h2><h3 id="指针的-、"><a href="#指针的-、" class="headerlink" title="指针的+、-"></a>指针的+、-</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value&#123; <span class="number">7</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> *ptr&#123; &amp;value &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ptr &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ptr+<span class="number">1</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ptr+<span class="number">2</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ptr+<span class="number">3</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">0012F</span>F7C</span><br><span class="line"><span class="number">0012F</span>F80</span><br><span class="line"><span class="number">0012F</span>F84</span><br><span class="line"><span class="number">0012F</span>F88</span><br></pre></td></tr></table></figure><p>注意：注意，</p><p><code>ptr + 1</code>并不返回ptr之后的内存地址，而是ptr所指向类型的<strong>下一个对象的内存地址</strong>。</p><blockquote><p>如果ptr指向一个整数(假设为4个字节)，ptr + 3表示ptr之后有3个整数(12个字节)。</p><p>如果ptr指向一个1字节的字符，ptr + 3表示ptr之后有3个字符(3字节)。</p></blockquote><p>在计算指针算术表达式的结果时，<strong>编译器总是将整数操作数乘以所指向对象的大小</strong>。这叫做<strong>缩放</strong>。</p><blockquote><p>就像上面的例子一样。每个地址相差4 (7C + 4 = 80 in hexadecimal)。这是因为在作者的机器上一个整数是4字节。</p></blockquote><h3 id="数组在内存中按顺序排列"><a href="#数组在内存中按顺序排列" class="headerlink" title="数组在内存中按顺序排列"></a>数组在内存中按顺序排列</h3><p>通过取地址符(&amp;)我们可以看到数组在内存中是按顺序排列的。也就是说，元素0、1、2、…按顺序都是相邻的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostram&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] &#123;<span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Element 0 is at address: "</span> &lt;&lt; &amp;<span class="built_in">array</span>[<span class="number">0</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Element 1 is at address: "</span> &lt;&lt; &amp;<span class="built_in">array</span>[<span class="number">1</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Element 2 is at address: "</span> &lt;&lt; &amp;<span class="built_in">array</span>[<span class="number">2</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Element 3 is at address: "</span> &lt;&lt; &amp;<span class="built_in">array</span>[<span class="number">3</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Element <span class="number">0</span> is at address: <span class="number">0041F</span>E9C</span><br><span class="line">Element <span class="number">1</span> is at address: <span class="number">0041F</span>EA0</span><br><span class="line">Element <span class="number">2</span> is at address: <span class="number">0041F</span>EA4</span><br><span class="line">Element <span class="number">3</span> is at address: <span class="number">0041F</span>EA8</span><br><span class="line"><span class="comment">//注意，每个内存地址之间相隔4个字节，这是作者机器上的整数大小。</span></span><br></pre></td></tr></table></figure><h3 id="数组的"><a href="#数组的" class="headerlink" title="数组的+"></a>数组的+</h3><p>数组的+和指针的运算相似：</p><blockquote><p>向数组添加1应该指向数组的第二个元素(元素1)。如下所示：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> <span class="built_in">array</span> []&#123; <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line"> </span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; &amp;<span class="built_in">array</span>[<span class="number">1</span>] &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print memory address of array element 1</span></span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>+<span class="number">1</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print memory address of array pointer + 1 </span></span><br><span class="line"> </span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[<span class="number">1</span>] &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// prints 7</span></span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *(<span class="built_in">array</span>+<span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// prints 7 (note the 小括号 required here)</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子证明：</p><p>中括号操作符([ ]) ，就是<strong>先将其转化为指针的加法</strong>，<strong>然后对指针解引用(就是访问其指向内存的值)</strong>。</p><blockquote><p>如： <code>array[n]</code> 就等同于 <code>*(array+n)</code></p></blockquote><h3 id="使用指针遍历数组"><a href="#使用指针遍历数组" class="headerlink" title="使用指针遍历数组"></a>使用指针遍历数组</h3><p>我们可以使用指针和指针运算来遍历数组。（虽然这个不常用，但是这里只是告诉你可以这样用）</p><blockquote><p><strong>使用下标通常更容易阅读和更少的错误倾向</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;p center large&gt;&lt;red&gt;LearnCpp chapterL&lt;/red&gt;&lt;/p&gt;&lt;/center&gt;&lt;center&gt;&lt;red&gt;https://www.learncpp.com&lt;/red&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C/C++" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"/>
    
    
      <category term="C/C++" scheme="https://longlongqin.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>指针</title>
    <link href="https://longlongqin.github.io/archives/73608288.html"/>
    <id>https://longlongqin.github.io/archives/73608288.html</id>
    <published>2020-04-28T10:27:34.000Z</published>
    <updated>2020-04-28T15:49:02.095Z</updated>
    
    <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapterP</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h2 id="介绍指针"><a href="#介绍指针" class="headerlink" title="介绍指针"></a>介绍指针</h2><p>在<a href="http://www.learncpp.com/cpp-tutorial/13-a-first-look-at-variables/" target="_blank" rel="noopener">1.3 – a first look at variables</a>中，我们讲到：</p><p><strong>变量</strong>：是保存值的一段<strong>内存的</strong><u>名称</u>。当我们的程序实例化一个变量时，一个空闲内存地址被自动分配给这个变量。我们赋给该变量的任何值都存储在这个内存地址中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************/</span></span><br><span class="line"><span class="comment">/*当CPU执行这条语句时，会从RAM中留出一块内存。</span></span><br><span class="line"><span class="comment">为了便于举例，假设变量x被分配了内存位置140。</span></span><br><span class="line"><span class="comment">当程序在表达式或语句中看到变量x时，</span></span><br><span class="line"><span class="comment">它知道应该在内存位置140中查找该值。*/</span></span><br></pre></td></tr></table></figure><p>变量的好处是我们不需要担心分配了什么特定的内存地址。我们只是根据给定的标识符引用变量，编译器将这个名称转换为适当分配的内存地址。</p><h3 id="取地址操作符-amp"><a href="#取地址操作符-amp" class="headerlink" title="取地址操作符(&amp;)"></a>取地址操作符(&amp;)</h3><p>取地址操作符(&amp;)：允许我们查看分配给变量的内存地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print the value of variable x</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; &amp;x &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print the memory address of variable x</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">0027F</span>EA0</span><br></pre></td></tr></table></figure><h3 id="解引用操作符"><a href="#解引用操作符" class="headerlink" title="解引用操作符(*)"></a>解引用操作符(*)</h3><blockquote><p><strong>Dereferencing pointers</strong></p></blockquote><p>解引用操作符(*)：允许我们访问特定地址的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print the value of variable x</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; &amp;x &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print the memory address of variable x</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *(&amp;x) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">/// print the value at the memory address of variable x (parenthesis not required, but make it easier to read)</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">0027F</span>EA0</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><hr><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p><strong>指针是一个变量</strong>，<strong>它将一个内存地址作为其值</strong>。</p><h3 id="声明一个指针"><a href="#声明一个指针" class="headerlink" title="声明一个指针"></a>声明一个指针</h3><p>指针变量的声明与普通变量一样，只是数据类型和变量名之间有一个<strong>星号(*)</strong>。注意，这个星号不是间接寻址操作符。它是指针声明语法的一部分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1️⃣星号* 紧跟在变量名之前</span></span><br><span class="line"><span class="keyword">int</span> *iPtr; <span class="comment">// a pointer to an integer value</span></span><br><span class="line"><span class="keyword">double</span> *dPtr; <span class="comment">// a pointer to a double value</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//2️⃣ 星号* 紧跟在类型之后</span></span><br><span class="line"><span class="keyword">int</span>* iPtr2; <span class="comment">// also valid syntax (acceptable, but not favored)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3️⃣星号* 在类型与变量名之间</span></span><br><span class="line"><span class="keyword">int</span> * iPtr3; <span class="comment">// also valid syntax (but don't do this)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//注意，定义指针时，每个指针变量前面都需要有*</span></span><br><span class="line"><span class="keyword">int</span> *iPtr4, *iPtr5; <span class="comment">// declare two pointers to integer variables</span></span><br></pre></td></tr></table></figure><p>因此，在声明变量时，我们建议在变量名旁边加上星号（即，推荐1️⃣）。</p><hr><p>当从一个函数返回一个指针时，在返回类型旁边加上星号会更清楚:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//这表明函数返回的是int*类型的值，而不是int类型的值。</span></span><br></pre></td></tr></table></figure><hr><h4 id="声明时不初始化"><a href="#声明时不初始化" class="headerlink" title="声明时不初始化"></a>声明时不初始化</h4><p>就像普通的变量一样，指针在<strong>声明</strong>时是不初始化的。<strong>如果没有使用值初始化，它们将包含垃圾。</strong></p><hr><h3 id="为指针赋值"><a href="#为指针赋值" class="headerlink" title="为指针赋值"></a>为指针赋值</h3><p>由于指针只包含<strong>地址</strong>，当我们为指针赋值时，<strong>该值必须是地址</strong>。使用指针最常见的方法之一是让指针保存另一个变量的地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> v = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *ptr = &amp;v; <span class="comment">// initialize ptr with address of variable v</span></span><br></pre></td></tr></table></figure><p>上面代码片段，就像下面的图所显示的一样：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="http://www.learncpp.com/images/CppTutorial/Section6/6-Pointer.png" alt="img"></p><p>指针的名字就是从这里来的——ptr保存变量值的地址，所以我们说ptr“指向”v。</p><hr><h4 id="指针的类型必须与被指向的变量的类型相匹配"><a href="#指针的类型必须与被指向的变量的类型相匹配" class="headerlink" title="指针的类型必须与被指向的变量的类型相匹配:"></a>指针的类型必须与被指向的变量的类型相匹配:</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> iValue = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">double</span> dValue = <span class="number">7.0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> *iPtr = &amp;iValue; <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">double</span> *dPtr = &amp;dValue; <span class="comment">// ok</span></span><br><span class="line">iPtr = &amp;dValue; <span class="comment">// wrong -- int pointer cannot point to the address of a double variable</span></span><br><span class="line">dPtr = &amp;iValue; <span class="comment">// wrong -- double pointer cannot point to the address of an int variable</span></span><br></pre></td></tr></table></figure><h4 id="c-也不允许直接分配文字内存地址给指针"><a href="#c-也不允许直接分配文字内存地址给指针" class="headerlink" title="c++也不允许直接分配文字内存地址给指针:"></a>c++也不允许直接分配文字内存地址给指针:</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr = <span class="number">5</span>; <span class="comment">//这是因为指针只能保存地址，而整数literal 5没有内存地址。</span></span><br><span class="line"><span class="comment">//如果您尝试这样做，编译器将告诉您它不能将整数转换为整数指针。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> *dPtr = <span class="number">0x0012FF7C</span>; <span class="comment">//不可以，编译器将会视为赋值整数文字</span></span><br></pre></td></tr></table></figure><h3 id="取地址操作符-amp-返回指针"><a href="#取地址操作符-amp-返回指针" class="headerlink" title="取地址操作符(&amp;)返回指针"></a>取地址操作符(&amp;)返回指针</h3><p>值得注意的是取地址操作符(&amp;)并没有将其操作数的地址作为文字返回。相反，<strong>它返回一个包含操作数地址的<u>指针</u></strong>，该操作数的类型是从参数中派生出来的(例如，获取一个int类型的地址将返回它的地址到一个int型的指针中)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">x</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(&amp;x).name();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 结果（在vs2013中）*/</span></span><br><span class="line"><span class="keyword">int</span> *</span><br></pre></td></tr></table></figure><h3 id="指针的声明与解引用指针"><a href="#指针的声明与解引用指针" class="headerlink" title="指针的声明与解引用指针"></a>指针的声明与解引用指针</h3><blockquote><p>解引用指针：<strong>Dereferencing pointers</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;<span class="comment">//声明一个整型指针</span></span><br><span class="line">p= &amp;a;     <span class="comment">//p指向了a的地址 （&amp;取地址）</span></span><br><span class="line"><span class="comment">//上面两句=下面这一句：</span></span><br><span class="line"><span class="keyword">int</span> *p= &amp;a;     <span class="comment">//定义一个整型指针  p    并且p指向了a的地址     （&amp;取地址）</span></span><br><span class="line"></span><br><span class="line">*p=<span class="number">10</span>;        <span class="comment">//解引用， 即 给a赋值10；</span></span><br><span class="line"></span><br><span class="line">p=&amp;b;        <span class="comment">// p指向了 b的地址</span></span><br><span class="line"></span><br><span class="line">*p=<span class="number">200</span>;     <span class="comment">//解引用， 即 给b赋值200；</span></span><br></pre></td></tr></table></figure><p>解引用中的 “*”的作用是引用指针指向的变量值，引用其实就是引用该变量的地址，”解”就是把该地址对应的东西解开，解出来，就像打开一个包裹一样，那就是该变量的值了，所以称为”解引用”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; &amp;value; <span class="comment">// prints address of value</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value; <span class="comment">// prints contents of value</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> *ptr = &amp;value; <span class="comment">// ptr points to value</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ptr; <span class="comment">// prints address held in ptr, which is &amp;value</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *ptr; <span class="comment">// dereference ptr (get the value that ptr is pointing to)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">0012F</span>F7C</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">0012F</span>F7C</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>这就是指针必须有类型的原因</strong>。如果没有类型，指针就不知道在解引用时如何解释它所指向的内容。</p><p><strong>这也是为什么指针的类型和赋值给它的变量地址必须匹配的原因</strong>。如果他们不这样做，当指针被解引用时，它会将bits误读为另一种类型。</p><h3 id="指针的大小"><a href="#指针的大小" class="headerlink" title="指针的大小"></a>指针的大小</h3><p><strong>指针的大小取决于可执行文件的编译体系结构</strong>——32位可执行文件使用32位内存地址——因此，32位机器上的指针是32位(4字节)。对于64位的可执行文件，指针应该是64位(8字节)。<strong>请注意，这是固定的，与指针的类型无关。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *chPtr; <span class="comment">// chars are 1 byte</span></span><br><span class="line"><span class="keyword">int</span> *iPtr; <span class="comment">// ints are usually 4 bytes</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nX, nY, nZ;</span><br><span class="line">&#125;;</span><br><span class="line">Something *somethingPtr; <span class="comment">// Something is probably 12 bytes</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(chPtr) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// prints 4</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(iPtr) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// prints 4</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(somethingPtr) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// prints 4</span></span><br></pre></td></tr></table></figure><p>可以看到，指针的大小总是相同的。这是因为指针只是一个内存地址，而访问给定机器上的内存地址所需的比特数总是恒定的。</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;p center large&gt;&lt;red&gt;LearnCpp chapterP&lt;/red&gt;&lt;/p&gt;&lt;/center&gt;&lt;center&gt;&lt;red&gt;https://www.learncpp.com&lt;/red&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C/C++" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"/>
    
    
      <category term="C/C++" scheme="https://longlongqin.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>数组、字符串、指针和引用</title>
    <link href="https://longlongqin.github.io/archives/122ff534.html"/>
    <id>https://longlongqin.github.io/archives/122ff534.html</id>
    <published>2020-04-28T10:26:38.000Z</published>
    <updated>2020-04-28T10:26:39.677Z</updated>
    
    <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapterP</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h2 id="P6-1-定长数组（Ⅰ）"><a href="#P6-1-定长数组（Ⅰ）" class="headerlink" title="P6.1 定长数组（Ⅰ）"></a><a href="https://www.learncpp.com/cpp-tutorial/61-arrays-part-i/" target="_blank" rel="noopener">P6.1 定长数组（Ⅰ）</a></h2><p><strong>数组长度</strong>：</p><p>在数组变量声明中，我们使用方括号( <strong>[ ]</strong> )告诉编译器这是一个数组变量(而不是普通的变量)，以及要分配多少变量(称为<strong>数组长度</strong>)。</p><p><strong>固定长度的数组</strong>：</p><p><strong>固定数组</strong>(也称为<strong>固定长度数组</strong>或<strong>固定大小数组</strong>)是在<strong>编译时</strong>长度已知的数组。当testScore被实例化时，编译器将分配30个整数。</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> testScore[<span class="number">30</span>]; <span class="comment">// allocate 30 integer variables in a fixed array</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="数组元素和下标"><a href="#数组元素和下标" class="headerlink" title="数组元素和下标"></a>数组元素和下标</h3><p>数组中的每个变量都称为<strong>元素</strong>。元素没有自己单独的名称。</p><p>为了访问数组的各个元素，我们使用<strong>数组名</strong>、<strong>下标操作符([])</strong>和一个称为<strong>下标</strong>(或<strong>索引</strong>)的参数，它告诉编译器我们需要哪个元素。</p><p><em>重要提示:与我们通常从1开始计数的日常生活不同，*</em>在c++中，数组总是从0开始计数!***</p><hr><h3 id="由结构体构成的数组"><a href="#由结构体构成的数组" class="headerlink" title="由结构体构成的数组"></a>由结构体构成的数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">width</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Rectangle rects[<span class="number">5</span>]; <span class="comment">// declare an array of 5 Rectangle</span></span><br></pre></td></tr></table></figure><p>要访问数组元素的struct成员，<strong>首先</strong>选择你想要的数组元素，<strong>然后</strong>使用成员选择操作符( . )来选择你想要的struct成员：<code>rects[0].length = 24;</code></p><h3 id="数组下标（详细）"><a href="#数组下标（详细）" class="headerlink" title="数组下标（详细）"></a>数组下标（详细）</h3><p><strong>在c++中，数组下标必须始终是整数类型</strong>。这包括char、short、int、long、long long等等，奇怪的是，bool(其中false的索引为0,true的索引为1). 数组下标可以是一个文字值、一个变量(常量或非常量)，或者一个计算结果为整数类型的表达式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>]; <span class="comment">// declare an array of length 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// using a literal (constant) index:</span></span><br><span class="line"><span class="built_in">array</span>[<span class="number">1</span>] = <span class="number">7</span>; <span class="comment">// ok</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// using an enum (constant) index</span></span><br><span class="line"><span class="keyword">enum</span> Animals</span><br><span class="line">&#123;</span><br><span class="line">    ANIMAL_CAT = <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">array</span>[ANIMAL_CAT] = <span class="number">4</span>; <span class="comment">// ok</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// using a variable (non-constant) index:</span></span><br><span class="line">short index = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">array</span>[index] = <span class="number">7</span>; <span class="comment">// ok</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// using an expression that evaluates to an integer index:</span></span><br><span class="line"><span class="built_in">array</span>[<span class="number">1</span>+<span class="number">2</span>] = <span class="number">7</span>; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><h3 id="定长数组的声明"><a href="#定长数组的声明" class="headerlink" title="定长数组的声明"></a>定长数组的声明</h3><p>在<u>声明</u><strong>固定数组</strong>时，数组的长度(方括号之间)必须是<strong>编译时常量（compile-time）</strong>。这是因为在编译时必须知道固定数组的长度。这里有一些不同的方法来声明固定数组:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// using a literal constant</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>]; <span class="comment">// Ok</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// using a macro symbolic constant</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAY_LENGTH 5</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[ARRAY_LENGTH]; <span class="comment">// Syntactically okay, but don't do this</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// using a symbolic constant</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> arrayLength = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[arrayLength]; <span class="comment">// Ok</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// using an enumerator</span></span><br><span class="line"><span class="keyword">enum</span> ArrayElements</span><br><span class="line">&#123;</span><br><span class="line">    MAX_ARRAY_LENGTH = <span class="number">5</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[MAX_ARRAY_LENGTH]; <span class="comment">// Ok</span></span><br></pre></td></tr></table></figure><p>注意，<strong>非常量变量</strong>或<strong>运行时常量（runtime constants）</strong>不能使用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//using a non-const variable</span></span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;length;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[length]; <span class="comment">//不行，length 不是编译时常量!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// using a runtime const variable</span></span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> length =temp; <span class="comment">//length的值直到运行时才知道，所以这是一个运行时常量，而不是编译时常量!</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[length]; <span class="comment">//不可以</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，在最后两种情况下，应该会产生一个错误，因为长度不是编译时常数。一些编译器可能允许这些类型的数组(为了C99的兼容性)，但是根据c++标准，它们是无效的，不应该在c++程序中使用。</p></blockquote><h3 id="关于动态数组的说明"><a href="#关于动态数组的说明" class="headerlink" title="关于动态数组的说明"></a>关于动态数组的说明</h3><p>因为固定数组在编译时分配了内存，这就引入了两个限制:</p><ul><li>固定数组的长度不能基于用户输入或运行时计算的其他值。</li><li>固定数组的长度是固定的，不能改变。</li></ul><p>在许多情况下，这些限制是有问题的。幸运的是，c++支持第二种类型的数组，称为<strong>动态数组</strong>。动态数组的长度可以在运行时设置，也可以更改其长度。但是，动态数组的实例化要复杂一些，因此我们将在本章的后面部分介绍它们。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>固定数组</strong>提供了一种简单的方法来分配和使用相同类型的多个变量，只要在编译时知道数组的长度即可。</p><hr><h2 id="P6-2-定长数组（Ⅱ）"><a href="#P6-2-定长数组（Ⅱ）" class="headerlink" title="P6.2 定长数组（Ⅱ）"></a><a href="https://www.learncpp.com/cpp-tutorial/62-arrays-part-ii/" target="_blank" rel="noopener">P6.2 定长数组（Ⅱ）</a></h2><p>c++通过使用<strong>初始化器列表</strong>提供了一种更方便的方法来初始化整个数组。下面的例子是等价的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> prime[<span class="number">5</span>] = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span> &#125;; <span class="comment">// use initializer list to initialize the fixed array【推荐】</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> prime[<span class="number">5</span>]; <span class="comment">// hold the first 5 prime numbers【不推荐】</span></span><br><span class="line">    prime[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">    prime[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">    prime[<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line">    prime[<span class="number">3</span>] = <span class="number">7</span>;</span><br><span class="line">    prime[<span class="number">4</span>] = <span class="number">11</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="零值初始化"><a href="#零值初始化" class="headerlink" title="零值初始化"></a>零值初始化</h3><p>当列表中的初始化器比数组所能容纳的少，那么，其余的元素会被初始化为0。（或者将0转换为非整数基本类型的任何值——例如0.0转换为double）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>] = &#123; <span class="number">7</span>, <span class="number">4</span>, <span class="number">5</span> &#125;; <span class="comment">// only initialize first 3 elements</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[<span class="number">0</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[<span class="number">1</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[<span class="number">2</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[<span class="number">3</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[<span class="number">4</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize all elements to 0</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>] = &#123; &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Initialize all elements to 0.0</span></span><br><span class="line"><span class="keyword">double</span> <span class="built_in">array</span>[<span class="number">5</span>] = &#123; &#125;;</span><br></pre></td></tr></table></figure><p><strong>从c++ 11开始，应该使用统一的初始化语法:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> prime[<span class="number">5</span>] &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span> &#125;; <span class="comment">//使用统一初始化来初始化固定数组,</span></span><br><span class="line"><span class="comment">//注意这个语法中没有等号</span></span><br></pre></td></tr></table></figure><h3 id="省略长度"><a href="#省略长度" class="headerlink" title="省略长度"></a>省略长度</h3><p>如果使用初始化器列表初始化一个固定的元素数组，编译器可以为您计算出数组的长度，您可以省略显式声明数组的长度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;; <span class="comment">// 显式的 define length of the array</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;; <span class="comment">// let initializer list set length of the array</span></span><br></pre></td></tr></table></figure><h3 id="数组和枚举"><a href="#数组和枚举" class="headerlink" title="数组和枚举"></a>数组和枚举</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> StudentsNames&#123;</span><br><span class="line">    qin, <span class="comment">//0</span></span><br><span class="line">    zhi, <span class="comment">//1</span></span><br><span class="line">    Long,<span class="comment">//2</span></span><br><span class="line">    student_num, <span class="comment">//3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> testScores[student_num]; <span class="comment">//allocate 3 integers</span></span><br><span class="line">    testScores[qin] = <span class="number">76</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组和枚举类"><a href="#数组和枚举类" class="headerlink" title="数组和枚举类"></a>数组和枚举类</h3><p><strong>枚举类不会隐式的将枚举器转换为整数</strong>，所以如果你尝试以下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentNames</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    KENNY, <span class="comment">// 0</span></span><br><span class="line">    KYLE, <span class="comment">// 1</span></span><br><span class="line">    STAN, <span class="comment">// 2</span></span><br><span class="line">    BUTTERS, <span class="comment">// 3</span></span><br><span class="line">    CARTMAN, <span class="comment">// 4</span></span><br><span class="line">    WENDY, <span class="comment">// 5</span></span><br><span class="line">    MAX_STUDENTS <span class="comment">// 6</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> testScores[StudentNames::MAX_STUDENTS]; <span class="comment">// allocate 6 integers</span></span><br><span class="line">    testScores[StudentNames::STAN] = <span class="number">76</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>你会得到一个编译错误</strong>。</p><p><strong>解决：</strong></p><blockquote><p>这可以通过使用<code>static_cast</code>将枚举数转换为整数来解决:</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> testScores[<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(StudentNames::MAX_STUDENTS)]; <span class="comment">// allocate 6 integers</span></span><br><span class="line">    testScores[<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(StudentNames::STAN)] = <span class="number">76</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>改进：</strong></p><blockquote><p>在命名空间中使用标准的<code>enum</code>可能更好:</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">nmaespace studentName</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">enum</span> studentnames</span><br><span class="line">&#123;</span><br><span class="line">KENNY, <span class="comment">// 0</span></span><br><span class="line">        KYLE, <span class="comment">// 1</span></span><br><span class="line">        STAN, <span class="comment">// 2</span></span><br><span class="line">        BUTTERS, <span class="comment">// 3</span></span><br><span class="line">        CARTMAN, <span class="comment">// 4</span></span><br><span class="line">        WENDY, <span class="comment">// 5</span></span><br><span class="line">        MAX_STUDENTS <span class="comment">// 6</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> testScores[studentName::MAX_STUDENTS];</span><br><span class="line">    testScores[StudentNames::STAN] = <span class="number">76</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将数组传递给函数"><a href="#将数组传递给函数" class="headerlink" title="将数组传递给函数"></a>将数组传递给函数</h3><p><strong>传递数组给函数</strong> VS <strong>传递普通的变量给函数</strong> 的区别：</p><ul><li>传递数组给函数：当通过值传递一个普通变量时，c++将参数的值复制到函数参数中。<strong>因为参数是副本，所以更改参数的值并不会更改原始参数的值</strong>。</li><li>传递数组给函数：当一个数组被传递给一个函数时，c++不会复制一个数组。而是传递实际的数组。<strong>这样做的副作用是允许函数直接改变数组元素的值</strong>!</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//传递普通参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">passValue</span><span class="params">(<span class="keyword">int</span> value)</span> <span class="comment">// value is a copy of the argument</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    value = <span class="number">99</span>; <span class="comment">// so changing it here won't change the value of the argument</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//传递数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">passArray</span><span class="params">(<span class="keyword">int</span> prime[<span class="number">5</span>])</span> <span class="comment">// prime is the actual array</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    prime[<span class="number">0</span>] = <span class="number">11</span>; <span class="comment">// so changing it here will change the original argument!</span></span><br><span class="line">    prime[<span class="number">1</span>] = <span class="number">7</span>;</span><br><span class="line">    prime[<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line">    prime[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">    prime[<span class="number">4</span>] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"before passValue: "</span> &lt;&lt; value &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    passValue(value);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"after passValue: "</span> &lt;&lt; value &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> prime[<span class="number">5</span>] = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"before passArray: "</span> &lt;&lt; prime[<span class="number">0</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; prime[<span class="number">1</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; prime[<span class="number">2</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; prime[<span class="number">3</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; prime[<span class="number">4</span>] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    passArray(prime);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"after passArray: "</span> &lt;&lt; prime[<span class="number">0</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; prime[<span class="number">1</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; prime[<span class="number">2</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; prime[<span class="number">3</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; prime[<span class="number">4</span>] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">before passValue: <span class="number">1</span></span><br><span class="line">after passValue: <span class="number">1</span> （普通变量不会被修改）</span><br><span class="line">before passArray: <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">11</span></span><br><span class="line">after passArray: <span class="number">11</span> <span class="number">7</span> <span class="number">5</span> <span class="number">3</span> <span class="number">2</span>  （数组会被修改）</span><br></pre></td></tr></table></figure><p>注意<strong>：如果你想确保一个函数不修改数组元素传递给它，你可以对数组使用<code>const</code>:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// even though prime is the actual array, within this function it should be treated as a constant</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">passArray</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> prime[<span class="number">5</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// so each of these lines will cause a 编译错误!</span></span><br><span class="line">    prime[<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">    prime[<span class="number">1</span>] = <span class="number">7</span>;</span><br><span class="line">    prime[<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line">    prime[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">    prime[<span class="number">4</span>] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sizeof和数组"><a href="#sizeof和数组" class="headerlink" title="sizeof和数组"></a><code>sizeof</code>和数组</h3><p>可以对数组使用sizeof操作符，它将返回数组的总大小（<strong>数组长度乘以元素大小</strong>）</p><blockquote><p>注意，<strong>由于c++将数组传递给函数的方式，对于已传递给函数的数组，这将无法正常工作!</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSize</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="built_in">array</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// prints the size of a pointer, not the size of the array!(将数组传递给函数，它显示的大小只是数组的指针（我的vs2013中，指针大小为4byte）)</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="built_in">array</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// will print the size of the array（没有传递给函数，所以会正常显示数组的大小）</span></span><br><span class="line">    printSize(<span class="built_in">array</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="comment">//在我的vs2013中，int是4byte，int指针是4byte</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>指针大小与类型无关</strong></p><p><strong>数组大小≠数组长度</strong>；数组大小 = 数组长度*元素大小</p></blockquote><hr><h3 id="在c-17之前确定一个固定数组的长度"><a href="#在c-17之前确定一个固定数组的长度" class="headerlink" title="在c++ 17之前确定一个固定数组的长度"></a>在c++ 17之前确定一个固定数组的长度</h3><p>我们可以通过 整个数组的大小 除以 数组元素的大小 来确定一个固定数组的长度:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; //for std::cout</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"The array has: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]) &lt;&lt; <span class="string">" elements\n"</span>;</span><br><span class="line">    <span class="comment">//sizeof(array[0])是元素的大小</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">The <span class="built_in">array</span> has <span class="number">8</span> elements</span><br></pre></td></tr></table></figure><h3 id="在c-17-c-20中确定一个固定数组的长度"><a href="#在c-17-c-20中确定一个固定数组的长度" class="headerlink" title="在c++ 17/ c++ 20中确定一个固定数组的长度"></a>在c++ 17/ c++ 20中确定一个固定数组的长度</h3><p>在c++ 17中，更好的选择是<strong>使用<code>std::size()</code>函数，它是在头文件<code>&lt;iterator&gt;</code>中。</strong></p><blockquote><p>如果您试图在<strong>传递给函数</strong>的固定数组上使用它，则会导致编译器错误!注意，<strong>std::size返回一个无符号值。</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // for std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt; // for std::size</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The array has: "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">size</span>(<span class="built_in">array</span>) &lt;&lt; <span class="string">" elements\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">The <span class="built_in">array</span> has <span class="number">8</span> elements</span><br></pre></td></tr></table></figure><hr><p>在c++ 20中，<code>std::ssize</code>甚至更可取，因为它返回一个带符号的值。</p><hr><p>小结：</p><ul><li><strong>如果你的编译器是c++ 17/ c++ 20的能力，那么你可以使用<code>std::size</code> (c++ 17)或者<code>std::ssize</code>(c++ 20)来进行数组长度的确定。</strong></li></ul><h2 id="P6-4-使用选择排序对数组排序"><a href="#P6-4-使用选择排序对数组排序" class="headerlink" title="P6.4 使用选择排序对数组排序"></a>P6.4 使用选择排序对数组排序</h2><h3 id="数组元素交换"><a href="#数组元素交换" class="headerlink" title="数组元素交换"></a>数组元素交换</h3><p>在C++标准库中，提供了元素值的交换函数：<code>std::swap()</code>在头文件<code>algorithm</code>中（如果是C++11，则在头文件<code>utility</code>中）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // for std::swap, use &lt;utility&gt; instead if C++11</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123; <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> y&#123; <span class="number">4</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Before swap: x = "</span> &lt;&lt; x &lt;&lt; <span class="string">", y = "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::swap(x, y); <span class="comment">// swap the values of x and y</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"After swap:  x = "</span> &lt;&lt; x &lt;&lt; <span class="string">", y = "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Before swap: x = <span class="number">2</span>, y = <span class="number">4</span></span><br><span class="line">After swap:  x = <span class="number">4</span>, y = <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="在c-中的选择排序"><a href="#在c-中的选择排序" class="headerlink" title="在c++中的选择排序"></a>在c++中的选择排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // for std::swap, use &lt;utility&gt; instead if C++11</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> length&#123; <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[length]&#123; <span class="number">30</span>, <span class="number">50</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">40</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Step through each element of the array</span></span><br><span class="line"><span class="comment">// (except the last one, which will already be sorted by the time we get there)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> startIndex&#123; <span class="number">0</span> &#125;; startIndex &lt; length - <span class="number">1</span>; ++startIndex)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// smallestIndex is the index of the smallest element we’ve encountered this iteration</span></span><br><span class="line"><span class="comment">// Start by assuming the smallest element is the first element of this iteration</span></span><br><span class="line"><span class="keyword">int</span> smallestIndex&#123; startIndex &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Then look for a smaller element in the rest of the array</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> currentIndex&#123; startIndex + <span class="number">1</span> &#125;; currentIndex &lt; length; ++currentIndex)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// If we've found an element that is smaller than our previously found smallest</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[currentIndex] &lt; <span class="built_in">array</span>[smallestIndex])</span><br><span class="line"><span class="comment">// then keep track of it</span></span><br><span class="line">smallestIndex = currentIndex;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// smallestIndex is now the smallest element in the remaining array</span></span><br><span class="line">                <span class="comment">// swap our start element with our smallest element (this sorts it into the correct place)</span></span><br><span class="line"><span class="built_in">std</span>::swap(<span class="built_in">array</span>[startIndex], <span class="built_in">array</span>[smallestIndex]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Now that the whole array is sorted, print our sorted array as proof it works</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> index&#123; <span class="number">0</span> &#125;; index &lt; length; ++index)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[index] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="std-sort-C-中自带排序函数"><a href="#std-sort-C-中自带排序函数" class="headerlink" title="std::sort(C++中自带排序函数)"></a>std::sort(C++中自带排序函数)</h3><blockquote><p>默认情况下，<code>std::sort</code>按升序排序，使用操作符<code>&lt;</code>来比较元素对，并在必要时交换它们(很像上面的选择排序示例)。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // for std::sort</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt; // for std::size</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[]&#123; <span class="number">30</span>, <span class="number">50</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">40</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::sort(<span class="built_in">std</span>::<span class="built_in">begin</span>(<span class="built_in">array</span>), <span class="built_in">std</span>::<span class="built_in">end</span>(<span class="built_in">array</span>));</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i&#123; <span class="number">0</span> &#125;; i &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">std</span>::<span class="built_in">size</span>(<span class="built_in">array</span>)); ++i)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P6-5-多维数组"><a href="#P6-5-多维数组" class="headerlink" title="P6.5 多维数组"></a>P6.5 多维数组</h2><p>数组的元素可以是任何数据类型，包括数组。数组的数组称为<strong>多维数组</strong>。</p><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">3</span>][<span class="number">5</span>]; <span class="comment">// a 3-element array of 5-element arrays</span></span><br></pre></td></tr></table></figure><p>在二维数组中，可以方便地将第一个(左)下标视为<strong>行</strong>，第二个(右)下标视为<strong>列</strong>。这叫做行-主序。在概念上，上述二维数组的布局如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0][0]  [0][1]  [0][2]  [0][3]  [0][4] &#x2F;&#x2F; row 0</span><br><span class="line">[1][0]  [1][1]  [1][2]  [1][3]  [1][4] &#x2F;&#x2F; row 1</span><br><span class="line">[2][0]  [2][1]  [2][2]  [2][3]  [2][4] &#x2F;&#x2F; row 2</span><br></pre></td></tr></table></figure><h4 id="二维数组初始化"><a href="#二维数组初始化" class="headerlink" title="二维数组初始化"></a>二维数组初始化</h4><ul><li>要初始化一个二维数组，最简单的方法是使用嵌套大括号，每组数字代表一行:</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">3</span>][<span class="number">5</span>]</span><br><span class="line">&#123;</span><br><span class="line">  &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;, <span class="comment">// row 0</span></span><br><span class="line">  &#123; <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;, <span class="comment">// row 1</span></span><br><span class="line">  &#123; <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span> &#125; <span class="comment">// row 2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>当然你也可以省略左(行)下标。注意，如果想省略下标，<strong>你只能省略左(行)下标，而右(列)下标不允许省略。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[][<span class="number">5</span>]  <span class="comment">//只能省略左(行)下标  ✔</span></span><br><span class="line">&#123;</span><br><span class="line">  &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;,</span><br><span class="line">  &#123; <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;,</span><br><span class="line">  &#123; <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[][]   <span class="comment">//不能省略右(列)下标  ✖</span></span><br><span class="line">&#123;</span><br><span class="line">  &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;,</span><br><span class="line">  &#123; <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;,</span><br><span class="line">  &#123; <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="多维数组（大于2维）"><a href="#多维数组（大于2维）" class="headerlink" title="多维数组（大于2维）"></a>多维数组（大于2维）</h3><p>多维数组可以大于二维。这是一个三维数组的声明:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">1</span>][<span class="number">2</span>][<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>使用初始化器列表很难以任何直观的方式初始化三维数组，<strong>因此通常最好将数组初始化为0，并使用嵌套循环显式地分配值。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;p center large&gt;&lt;red&gt;LearnCpp chapterP&lt;/red&gt;&lt;/p&gt;&lt;/center&gt;&lt;center&gt;&lt;red&gt;https://www.learncpp.com&lt;/red&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C/C++" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"/>
    
    
      <category term="C/C++" scheme="https://longlongqin.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>C风格字符串</title>
    <link href="https://longlongqin.github.io/archives/21aba888.html"/>
    <id>https://longlongqin.github.io/archives/21aba888.html</id>
    <published>2020-04-28T07:04:46.000Z</published>
    <updated>2020-04-29T02:20:02.611Z</updated>
    
    <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapterL</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h2 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h2><p>在<a href="http://www.learncpp.com/cpp-tutorial/4-4b-an-introduction-to-stdstring/" target="_blank" rel="noopener">4.4b – An introduction to std::string</a>的介绍中，我们将字符串定义为连续字符的集合，比如“Hello, world!”字符串是我们在c++中处理文本的主要方式，而std::string使在c++中处理字符串变得很容易。</p><p>现代c++支持<strong>两种</strong>不同类型的字符串:</p><ul><li>std::string(作为标准库的一部分)和</li><li>C风格的字符串(从C语言继承而来)。原来std::string是使用c风格的字符串实现的。</li></ul><p>在这节课中，我们将进一步了解c风格的字符串。</p><p>c风格的字符串只是一个使用<strong>空终止符(null terminator)</strong>的<strong>字符数组</strong>。</p><blockquote><p><strong>空终止符</strong>是一个特殊字符(<code>&#39; \0 &#39;</code>， ascii码为 0)</p></blockquote><hr><p>C风格字符串，<strong>只需声明一个<code>char</code>数组，并初始化它的字符串文字:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> myString[]&#123; <span class="string">"string"</span> &#125;;</span><br><span class="line"><span class="comment">//虽然“string”只有6个字母，但c++会自动为我们在字符串的末尾添加一个空终止符</span></span><br><span class="line"><span class="comment">//(我们自己不需要包含它)。因此，myString实际上是一个长度为7的数组!</span></span><br></pre></td></tr></table></figure><p>下面我们来证明它的实际长度：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt; // for std::size(如果不支持C++17，就不用加该头文件)</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> myString[]&#123; <span class="string">"string"</span> &#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> length&#123; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">std</span>::<span class="built_in">size</span>(myString)) &#125;;</span><br><span class="line"><span class="comment">// 如果你的编译器不支持C++17，请使用下面语句来替换</span></span><br><span class="line"><span class="comment">//  const int length&#123; sizeof(myString) / sizeof(myString[0]) &#125;; </span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; myString&lt;&lt; <span class="string">" has "</span> &lt;&lt; length &lt;&lt; <span class="string">" characters.\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index&#123; <span class="number">0</span> &#125;; index &lt; length; ++index)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(myString[index]) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="built_in">string</span> has <span class="number">7</span> characters.</span><br><span class="line"><span class="number">115</span> <span class="number">116</span> <span class="number">114</span> <span class="number">105</span> <span class="number">110</span> <span class="number">103</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p>该0是已附加到字符串末尾的空终止符的ASCII代码。</p></blockquote><p><strong>需要注意的重要一点是，C风格的字符串遵循与数组相同的所有规则。这意味着您可以在创建时初始化字符串，但不能在此之后使用赋值操作符为其赋值!</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> myString[]&#123; <span class="string">"string"</span> &#125;; <span class="comment">// ok</span></span><br><span class="line">myString = <span class="string">"rope"</span>; <span class="comment">// not ok!</span></span><br></pre></td></tr></table></figure><p><strong>但是你可以改变它字符串数组中的单个字符：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> myString[]&#123; <span class="string">"string"</span> &#125;; </span><br><span class="line">myString[<span class="number">0</span>] = <span class="string">'q'</span>;   <span class="comment">//这样是可以的</span></span><br></pre></td></tr></table></figure><h3 id="覆盖字符串的空终止符"><a href="#覆盖字符串的空终止符" class="headerlink" title="覆盖字符串的空终止符"></a>覆盖字符串的空终止符</h3><p>在打印c风格的字符串时，<code>std::cout</code>将打印字符，<strong>直到遇到空终止符为止</strong>。</p><p>如果您意外地覆盖了一个字符串中的null结束符(例如，通过向<code>myString[6]</code>分配一些内容)，您不仅会获得字符串中的所有字符，而且std::cout将继续打印相邻内存插槽中的所有内容，<strong>直到它刚好碰到一个0!</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>]&#123; <span class="string">"Alex"</span> &#125;; <span class="comment">// only use 5 characters (4 letters + null terminator)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"My name is: "</span> &lt;&lt; name &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在本例中，将打印字符串“Alex”，std::cout将在null结束符处停止。数组中的其余字符将被忽略。</span></span><br></pre></td></tr></table></figure><h3 id="C-style与std-cin"><a href="#C-style与std-cin" class="headerlink" title="C-style与std::cin"></a>C-style与<code>std::cin</code></h3><p>当我们不知道一个字符串将会有多长。在这种情况下，我们可以声明一个大于我们需要的数组:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">255</span>]; <span class="comment">// declare array large enough to hold 255 characters</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter your name: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"You entered: "</span> &lt;&lt; name &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种输入字符串的方法，不好。因为，我们不能阻止用户输入字符串的长度，即使它输入超过255，我们也不能阻止用户。</p><blockquote><p>比如：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="D:%5CBLOG_QZL%5CBlog3%5Csource_posts%5CC&C++%5Cupload%5Cimage-20200428153347057.png" alt="image-20200428153347057"></p><p>我故意输入超过3个字符，结果会是怎样的呢？</p><blockquote><p>结果就是即使超过了原本字符串数组的长度，还是会全部打印出来：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="D:%5CBLOG_QZL%5CBlog3%5Csource_posts%5CC&C++%5Cupload%5Cimage-20200428153501507.png" alt="image-20200428153501507"></p></blockquote><h4 id="改进：std-cin-getline"><a href="#改进：std-cin-getline" class="headerlink" title="改进：std::cin.getline"></a><strong>改进</strong>：<code>std::cin.getline</code></h4><p>推荐使用：<code>std::cin.getline( 字符串数组名字, 字符串数组长度)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">255</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"enter your name:"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.getline(name, <span class="built_in">std</span>::<span class="built_in">size</span>(name)); <span class="comment">//这里还是需要支持C++17才能这样用的</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"You entered: "</span> &lt;&lt; name &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个对cingetline()的调用将把最多254个字符读入<code>name</code>(为 空结束符 留出空间!) 任何多余的字符都将被丢弃。这样，我们保证不会溢出数组!</p><h3 id="操纵c风格的字符串-include-lt-cstring-gt"><a href="#操纵c风格的字符串-include-lt-cstring-gt" class="headerlink" title="操纵c风格的字符串(#include &lt;cstring&gt;)"></a>操纵c风格的字符串(#include &lt;cstring&gt;)</h3><p>在<code>cstring</code>头文件中，c++提供了许多函数来操作C风格的字符串：</p><h4 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy()"></a>strcpy()</h4><p>strcpy()允许将一个字符串复制到另一个字符串：<code>std::strcpy(dest, source)</code></p><blockquote><p>注意，如果目的字符串<code>dest</code>长度小于将要复制的字符串的长度，会发生溢出。</p></blockquote><p>许多程序员建议使用<code>strncpy()</code>，它允许您指定缓冲区的大小，并确保不会发生溢出。不幸的是，strncpy()不能确保字符串以null结尾，这仍然为数组溢出留下了大量空间。</p><h4 id="strcpy-s-【改进】"><a href="#strcpy-s-【改进】" class="headerlink" title="strcpy_s() 【改进】"></a>strcpy_s() 【改进】</h4><p>在C++中，使用<code>strcp_s()</code>更安全。它添加了一个参数来确定目标字符串的大小。<code>strcpy_s(dest, number, source);</code></p><p>但是，并不是所有的编译器都支持这个函数，要使用它，您必须使用整数值1定义<code>__STDC_WANT_LIB_EXT1__</code>。</p><blockquote><p>即：<code>#define __STDC_WANT_LIB_EXT1__ 1</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __STDC_WANT_LIB_EXT1__ 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; // for strcpy_s</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> source[]&#123; <span class="string">"Copy this!"</span> &#125;;</span><br><span class="line">    <span class="keyword">char</span> dest[<span class="number">5</span>]; <span class="comment">// note that the length of dest is only 5 chars!</span></span><br><span class="line">    strcpy_s(dest, <span class="number">5</span>, source); <span class="comment">// A runtime error will occur in debug mode</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; dest &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="strlcpy-【再改进】"><a href="#strlcpy-【再改进】" class="headerlink" title="strlcpy() 【再改进】"></a>strlcpy() 【再改进】</h4><p>因为<code>strcpy_s()</code>不是所有编译器都支持。所以，<code>strlcpy()</code> 是一个更好的选择。</p><blockquote><p>因为它是非标准的，所以没有包含在许多编译器中。它也有自己的一套问题。简而言之，<strong>如果您需要复制c风格的字符串，这里没有普遍推荐的解决方案</strong>。</p></blockquote><hr><h4 id="strlen-：返回字符串长度"><a href="#strlen-：返回字符串长度" class="headerlink" title="strlen()：返回字符串长度"></a>strlen()：返回字符串长度</h4><p>此函数返回c样式字符串的<strong>长度</strong>(<strong>不包含空终止符</strong>)：（不是返回该字符串数组全部的长度，而是只返回已存入字符的长度）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>] &#123;<span class="string">"Alex"</span>&#125;; <span class="comment">//// only use 5 characters (4 letters + null terminator)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"My name is: "</span> &lt;&lt; name &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">" has "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">strlen</span>(name) &lt;&lt; <span class="string">" letters.\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">" has "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">size</span>(name) &lt;&lt; <span class="string">" characters in the array.\n"</span>; <span class="comment">// use sizeof(name) / sizeof(name[0]) if not C++17 capable</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">My name is: Alex</span><br><span class="line">Alex has <span class="number">4</span> letters. (不包含终止符)</span><br><span class="line">Alex has <span class="number">20</span> characters in the <span class="built_in">array</span>.</span><br></pre></td></tr></table></figure><hr><p>注意：<code>strlen()</code>、<code>std::size()</code>的区别：</p><ul><li><p>strlen()打印<strong>null结束符之前的字符数</strong>，</p></li><li><p>size() C++17 . sizeof(name) / sizeof(name[0]) 不支持C++17的写法</p><p><strong>返回整个数组的大小</strong>，不管里面是什么。</p></li></ul><hr><h4 id="其他函数："><a href="#其他函数：" class="headerlink" title="其他函数："></a>其他函数：</h4><p><code>strcat()</code>——将一个字符串追加到另一个字符串(危险)</p><p><code>strncat()</code>——将一个字符串追加到另一个字符串(使用缓冲区检查长度)</p><p><code>strcmp()</code>——比较两个字符串(如果相等则返回0)</p><p><code>strncmp()</code>——比较两个字符串到特定数目的字符(如果相等，则返回0)</p><hr><h3 id="Don’t-use-C-style-strings"><a href="#Don’t-use-C-style-strings" class="headerlink" title="Don’t use C-style strings"></a>Don’t use C-style strings</h3><p>了解c风格的字符串很重要，因为它们在很多代码中都有使用。然而，现在我们已经解释了它们的工作原理，<strong>我们将建议您尽可能地避免使用它们</strong>! 除非您有特定的、令人信服的理由来使用c样式的字符串，<strong>否则应该使用std::string(在头文件 &lt;string&gt; 中定义)。<code>std::string</code></strong>更容易，更安全，更灵活。</p><p>在极少数情况下，您确实需要使用固定的缓冲区大小和c风格的字符串(例如，对于内存有限的设备)。<strong>我们建议使用经过良好测试的第三方字符串库</strong>，即<strong>std::string_view</strong>，这将在下一课中介绍。</p><h4 id="用std-string-view替代C-style-字符串"><a href="#用std-string-view替代C-style-字符串" class="headerlink" title="用std::string_view替代C-style 字符串"></a>用<code>std::string_view</code>替代C-style 字符串</h4><hr><h2 id="std-string-view"><a href="#std-string-view" class="headerlink" title="std::string_view"></a>std::string_view</h2><p>之前，讲的<a href="##C风格字符串">C风格字符串</a>（<a href="https://www.learncpp.com/cpp-tutorial/66-c-style-strings/" target="_blank" rel="noopener">原文链接</a>），以及使用它们的危险。c风格的字符串速度很快，但是它们不像<code>std::string</code>那样容易使用和安全。</p><p>但是<code>std::string</code>(我们在 <a href="https://www.learncpp.com/cpp-tutorial/4-4b-an-introduction-to-stdstring/" target="_blank" rel="noopener">S.4.4b – An introduction to std::string</a>（也就是本文开头的<a href="https://www.yuque.com/longlongqin/pw9qpx/fmzy0d#acbe9355" target="_blank" rel="noopener">介绍<code>std::string</code></a>）的介绍中已经介绍过了)也有它自己的缺点，尤其是涉及到const字符串时。</p><h3 id="std-string会修改const的字符串"><a href="#std-string会修改const的字符串" class="headerlink" title="std::string会修改const的字符串"></a>std::string会修改const的字符串</h3><p>看下面一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> <span class="built_in">text</span>[]&#123; <span class="string">"hello"</span> &#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> str&#123; <span class="built_in">text</span> &#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> more&#123; str &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">text</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; str &lt;&lt; <span class="string">' '</span> &lt;&lt; more &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">hello hello hello</span><br></pre></td></tr></table></figure><p>在内部，main将字符串“hello”复制3次，结果得到4个副本。首先是字符串文字“hello”，它在编译时已知，并存储在二进制文件中。当我们创建char[]时，会创建一个副本。接下来的两个std::string对象分别创建该字符串的一个副本。</p><p><strong>因为std::string被设计为可修改的</strong>，<strong>所以每个std::string必须包含其自身的字符串副本，以便可以修改给定的std::string而不影响任何其他std::string对象。</strong></p><p><strong>所以，即使，是 const std::string，也是会被修改的。</strong></p><hr><h3 id="std-string-view-1"><a href="#std-string-view-1" class="headerlink" title="std::string_view"></a>std::string_view</h3><p>想象一下你房子里的一扇窗户，看着停在街上的一辆车。你可以透过窗户看到那辆车，但你不能触摸或移动那辆车。你的窗口只是提供了一个汽车的视图，这是一个完全独立的对象。</p><p><strong>c++ 17引入了另一种使用字符串的方法，<code>std::string_view</code>，它位于头文件<code>&lt;string_view&gt;</code>中。</strong></p><blockquote><p>与<code>std::string</code>不同的是，<code>std::string_view</code>保存了自己的字符串副本，它提供了在其他地方定义的字符串的视图。</p></blockquote><p>修改上面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::string_view <span class="built_in">text</span>&#123;<span class="string">"hello"</span>&#125;; <span class="comment">// view the text "hello", which is stored in the binary</span></span><br><span class="line">    <span class="built_in">std</span>::string_view str&#123; <span class="built_in">text</span> &#125;; <span class="comment">// view of the same "hello"</span></span><br><span class="line">    <span class="built_in">std</span>::string_view more&#123; str &#125;; <span class="comment">// view of the same "hello"</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">text</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; str &lt;&lt; <span class="string">' '</span> &lt;&lt; more &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">hello hello hello</span><br></pre></td></tr></table></figure><p>这两个例子结果相同。但是此例子不再创建字符串“hello”的副本。当我们复制<code>std::string_view</code>时，新的<code>std::string_view</code>观察到的字符串与复制自<code>std::string_view</code>的字符串相同。</p><hr><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p><code>string_view</code>不仅速度快，而且有许多我们从std::string中了解到的函数。</p><hr><h4 id="string-view没有创建字符串的副本"><a href="#string-view没有创建字符串的副本" class="headerlink" title="string_view没有创建字符串的副本"></a><code>string_view</code>没有创建字符串的副本</h4><p>因为<code>std::string_view</code>并不创建字符串的副本，如果我们更改所查看的字符串，则更改将反映在<code>std::string_view</code>中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> arr[]&#123; <span class="string">"Gold"</span> &#125;;</span><br><span class="line">  <span class="built_in">std</span>::string_view str&#123; arr &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// Gold</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Change 'd' to 'f' in arr </span></span><br><span class="line">  arr[<span class="number">3</span>] = <span class="string">'f'</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// Golf</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们修改了arr，但是str似乎也在改变。这是因为：<strong>这是因为arr和str共享它们的字符串。</strong></p><hr><h4 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h4><ul><li><p>尽量使用<code>std::string_view</code> 来替代C风格字符串。</p></li><li><p>对于<strong>只读字符串</strong>，最好使用<code>std::string_view</code>而不是std::string，除非您已经使用了std::string。</p></li></ul><h3 id="std-string-view的修改函数"><a href="#std-string-view的修改函数" class="headerlink" title="std::string_view的修改函数"></a>std::string_view的修改函数</h3><p>回到我们的窗户类比，考虑一个有窗帘的窗户。我们可以关闭左边或右边的窗帘来减少我们能看到的东西。我们不改变外面的东西，我们只是减少可见的面积。</p><p>类似地，std::string_view包含一些函数，这些函数允许我们操作字符串的视图。这允许我们在不修改所查看的字符串的情况下更改视图。</p><p>这函数就是：</p><ul><li><code>remove_prefix</code>：从视图<strong>左</strong>侧删除字符</li><li><code>remove_suffix</code>：从视图<strong>右</strong>侧删除字符。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; //for std::strlen</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::string_view str&#123;<span class="string">"peach"</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Ignore the first characters.</span></span><br><span class="line">    str.remove_prefix(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Ignore the last 2 characters.</span></span><br><span class="line">    str.remove_suffix(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Peach</span><br><span class="line">each</span><br><span class="line">ea</span><br></pre></td></tr></table></figure><p><strong>与真正的窗帘不同，std::string_view不能打开备份。一旦你改变了可见区域，你就回不去了</strong>(有些技巧我们不会去做)。</p><h3 id="std-string-view与非空终止的字符串"><a href="#std-string-view与非空终止的字符串" class="headerlink" title="std::string_view与非空终止的字符串"></a>std::string_view与非空终止的字符串</h3><p>与C-style字符串和std::string 不同，<strong><code>std::string_view</code>的字符串是不使用空终止符来标记字符串的结束。相反，它知道字符串的结束位置，因为它跟踪字符串的长度。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt; // For std::size</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// No null-terminator.</span></span><br><span class="line">  <span class="keyword">char</span> vowels[]&#123; <span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>, <span class="string">'o'</span>, <span class="string">'u'</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// vowels isn't null-terminated. We need to pass the length manually.</span></span><br><span class="line">  <span class="comment">// Because vowels is an array, we can use std::size to get its length.</span></span><br><span class="line">  <span class="built_in">std</span>::string_view str&#123; vowels, <span class="built_in">std</span>::<span class="built_in">size</span>(vowels) &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// This is safe. std::cout knows how to print std::string_views.</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">aeiou</span><br></pre></td></tr></table></figure><h3 id="所有制的问题"><a href="#所有制的问题" class="headerlink" title="所有制的问题"></a>所有制的问题</h3><p>作为一个视图，std::string_view的生存期独立于它所查看的字符串的生存期。如果所查看的字符串超出其生命周期范围，那么std::string_view没有什么要观察的，访问它会导致未定义的行为。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::string_view <span class="title">askForName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"what's your name?\n"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用std::string，因为std::cin需要修改它。</span></span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> str&#123;&#125;;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 我们将切换到std::string_view，仅用于演示目的。</span></span><br><span class="line"><span class="comment">// 如果你已经有一个std::string，没有理由切换到std:: string_view。</span></span><br><span class="line"><span class="built_in">std</span>::string_view view&#123;str&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello "</span> &lt;&lt; view &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> view; </span><br><span class="line">&#125; <span class="comment">// str消失了，str创建的字符串也消失了。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">std</span>::string_view view&#123; askForName() &#125;;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// view is observing a string that already died.</span></span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Your name is "</span> &lt;&lt; view &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// Undefined behavior</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">What<span class="number">'</span>s your name?</span><br><span class="line">nascardriver</span><br><span class="line">Hello nascardriver</span><br><span class="line">Your name is �P@�P@ （因为这里访问的时候，view已经“死了”）</span><br></pre></td></tr></table></figure><h3 id="将std-string-view转换为std-string"><a href="#将std-string-view转换为std-string" class="headerlink" title="将std::string_view转换为std::string"></a>将std::string_view转换为std::string</h3><p>string_view不会隐式地转换为std::string，但是可以显式地转换为:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::string_view sv&#123; <span class="string">"balloon"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  sv.remove_suffix(<span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// print(sv); // compile error: won't implicitly convert</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> str&#123; sv &#125;; <span class="comment">// explicit conversion</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">print</span>(str); <span class="comment">// okay</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">print</span>(<span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(sv)); <span class="comment">// okay</span></span><br><span class="line">   </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">ball</span><br><span class="line">ball</span><br></pre></td></tr></table></figure><h3 id="将std-string-view转换为c风格的字符串"><a href="#将std-string-view转换为c风格的字符串" class="headerlink" title="将std::string_view转换为c风格的字符串"></a>将std::string_view转换为c风格的字符串</h3><p>一些旧的函数(如旧的strlen函数)仍然期望c风格的字符串。要将std::string_view转换为c风格的字符串，我们可以首先将其转换为std::string:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::string_view sv&#123; <span class="string">"balloon"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  sv.remove_suffix(<span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Create a std::string from the std::string_view</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> str&#123; sv &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Get the null-terminated C-style string.</span></span><br><span class="line">  <span class="keyword">auto</span> szNullTerminated&#123; str.c_str() &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Pass the null-terminated string to the function that we want to use.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">" has "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">strlen</span>(szNullTerminated) &lt;&lt; <span class="string">" letter(s)\n"</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">ball has <span class="number">4</span> letter(s)</span><br></pre></td></tr></table></figure><p>但是，每次我们希望将std::string_view作为c风格的字符串传递时，创建一个std::string是非常消耗资源的，因此应该尽可能避免这种情况。</p><h3 id="data-函数"><a href="#data-函数" class="headerlink" title="data()函数"></a>data()函数</h3><p><strong>可以使用data()函数访问std::string_view所查看的字符串，该函数返回一个c风格的字符串。</strong>这提供了对正在查看的字符串(作为c字符串)的快速访问。</p><blockquote><p><strong>但是它也应该只在std::string_view的视图没有被修改</strong>(例如通过remove_prefix或remove_suffix)<strong>并且被查看的字符串以null结尾的情况下使用</strong>。</p></blockquote><p>在下面的例子中，std::strlen不知道std::string_view是什么，所以我们需要传递它str.data():</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; // For std::strlen</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::string_view str&#123; <span class="string">"balloon"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// We use std::strlen because it's simple, this could be any other function</span></span><br><span class="line">  <span class="comment">// that needs a null-terminated string.</span></span><br><span class="line">  <span class="comment">// It's okay to use data() because we haven't modified the view, and the</span></span><br><span class="line">  <span class="comment">// string is null-terminated.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">strlen</span>(str.data()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">balloon</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><p>当修改了std::string_view之后，data()并不总是做我们希望它做的事情。下面的例子演示了在修改视图后访问data()时会发生什么:【所以，此时不建议使用data()函数】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::string_view str&#123; <span class="string">"balloon"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Remove the "b"</span></span><br><span class="line">  str.remove_prefix(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// remove the "oon"</span></span><br><span class="line">  str.remove_suffix(<span class="number">3</span>);</span><br><span class="line">  <span class="comment">// Remember that the above doesn't modify the string, it only changes</span></span><br><span class="line">  <span class="comment">// the region that str is observing.</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">" has "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">strlen</span>(str.data()) &lt;&lt; <span class="string">" letter(s)\n"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"str.data() is "</span> &lt;&lt; str.data() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"str is "</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，这不是我们想要的，这是试图访问已修改的std::string_view的数据()的结果。在访问data()时，有关字符串的长度信息将丢失。std::strlen和std::cout不断地从底层字符串中读取字符，直到它们找到空终止符，也就是“balloon”的结尾。</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;p center large&gt;&lt;red&gt;LearnCpp chapterL&lt;/red&gt;&lt;/p&gt;&lt;/center&gt;&lt;center&gt;&lt;red&gt;https://www.learncpp.com&lt;/red&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C/C++" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"/>
    
    
      <category term="C/C++" scheme="https://longlongqin.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>std::cin（输入）</title>
    <link href="https://longlongqin.github.io/archives/a4b39f57.html"/>
    <id>https://longlongqin.github.io/archives/a4b39f57.html</id>
    <published>2020-04-26T08:36:52.000Z</published>
    <updated>2020-04-26T08:36:53.321Z</updated>
    
    <content type="html"><![CDATA[<center><p center large><red>std::cin（输入）</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><p>我们可以使用<code>std::cin</code>来输入文本；因为文本输入是自由格式的(用户可以输入任何内容)，所以用户很容易输入不需要的内容。</p><p>在编写程序时，您应该始终考虑用户将如何(无意中或以其他方式)滥用您的程序。一个编写良好的程序可以预测用户将如何滥用它，并优雅地处理这些情况，或者在一开始就防止它们发生(如果可能的话)。一个能很好地处理错误情况的程序是<strong>robust(健壮的)</strong>。</p><p>在本节课中，我们将专门研究用户通过<code>std::cin</code>输入无效文本的方法，并向您展示处理这些情况的一些不同方法。</p><h2 id="std-cin-buffers-and-extraction"><a href="#std-cin-buffers-and-extraction" class="headerlink" title="std::cin, buffers, and extraction"></a>std::cin, buffers, and extraction</h2><p>为了讨论<code>std::cin</code>和操作符<code>&gt;&gt;</code>是如何失败的，首先需要了解一下它们是如何工作的。</p><p>当我们使用操作符<code>&gt;&gt;</code>来获取用户的输入，然后将该输入放进一个变量中，这个过程叫做：<strong>extraction(提取)</strong>。此时操作符<code>&gt;&gt;</code>也就叫做 <strong>提取操作符</strong>。</p><hr><h3 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h3><p>当用户响应提取操作输入数据时，该数据被放置在<code>std::cin</code>中的<strong>buffer（缓冲区)</strong>中。</p><blockquote><p>一个<strong>buffer</strong>(也称：<strong>data buffer</strong>)：<u>就是</u>在数据从一个地方移动到另一个地方时用来临时存储数据的<u>一块内存</u>。</p></blockquote><p>所以，在这里的缓冲区就<u>用来</u> 当用户输入的内容还没有被提取到变量中时 <u>保存它</u>。</p><p>当你使用提取操作符时，会发生以下过程：</p><ul><li>如果在输入缓冲区中已经有数据，那么这个数据是准备被提取的；</li><li>如果输入缓冲区中没有数据，那么要求用户输入数据以进行提取(大多数情况下都是这样)。当用户回车时，一个’ \n ‘字符将被放入输入缓冲区。</li><li>操作符<code>&gt;&gt;</code> 会从输入缓冲区提取尽可能多的数据到变量中(会忽略的空白字符，如空格、制表符或’ \n ‘。)</li><li>不能提取缓冲区中留给下一次提取的数据。</li></ul><hr><ol><li><p><strong>提取数据成功</strong></p><p><strong>只要在输入缓冲区中提取到一个字符就算成功</strong>。那些剩下的不符合本次提取的数据会留着下一次提取。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比如用户输入：5a 给变量x;</span></span><br><span class="line"><span class="comment">//将提取5，并将其转换为整数，赋值给变量x，“a\n”将留在输入流中进行下一次提取。</span></span><br></pre></td></tr></table></figure></li><li><p><strong>提取数据失败</strong></p><p>如果输入数据与要提取的变量的类型不匹配，则提取失败。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果用户输入“b”，提取将失败，因为“b”不能提取为整数变量。</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="输入验证"><a href="#输入验证" class="headerlink" title="输入验证"></a>输入验证</h3><p>检查用户输入是否符合程序期望的过程称为<strong>input validation(输入验证)</strong>。</p><p>进行输入验证有三种基本方法:</p><ul><li>内联(作为用户类型)<ul><li>首先防止用户输入无效的输入。</li></ul></li><li>输入后(在用户输入之后)<ul><li>让用户在字符串中输入他们想要的任何内容，然后验证该字符串是否正确，如果正确，则将该字符串转换为最终的变量类型。</li><li>让用户输入他们想要的任何东西，让std::cin和操作符&gt;&gt;尝试提取它，并处理错误情况。</li></ul></li></ul><p>一些图形用户界面和高级文本界面将允许您在用户输入时验证输入(逐个字符)。一般来说，程序员提供一个验证函数，该函数接受用户目前输入的输入，如果输入有效则返回true，否则返回false。每当用户按下一个键时，都会调用这个函数。如果验证函数返回true，则接受用户刚刚按下的键。如果验证函数返回false，则丢弃用户刚刚输入的字符(并且不显示在屏幕上)。<strong>不幸的是，std::cin不支持这种类型的验证。</strong></p><p>由于字符串对可以输入什么字符没有任何限制，所以提取一定会成功(但是请记住，std::cin在第一个非前导空格字符处停止提取)。一旦输入了一个字符串，程序就可以解析该字符串，看看它是否有效。<strong>然而，解析字符串并将字符串输入转换为其他类型(例如数字)可能会很困难，所以这只在极少数情况下才会完成。</strong></p><p><strong>大多数情况下，我们让std::cin和提取操作符<code>&gt;&gt;</code>来做这个工作。在这种方法下，我们让用户输入他们想要的任何东西，让std::cin和操作符&gt;&gt;尝试提取它，如果它失败了，就编写程序处理它们。</strong></p><h4 id="一个例子："><a href="#一个例子：" class="headerlink" title="一个例子："></a>一个例子：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getDouble</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a double value: "</span>;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getOperator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter one of the following: +, -, *, or /: "</span>;</span><br><span class="line">    <span class="keyword">char</span> op;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">    <span class="keyword">return</span> op;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printResult</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">char</span> op, <span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="string">'+'</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" + "</span> &lt;&lt; y &lt;&lt; <span class="string">" is "</span> &lt;&lt; x + y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'-'</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" - "</span> &lt;&lt; y &lt;&lt; <span class="string">" is "</span> &lt;&lt; x - y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'*'</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" * "</span> &lt;&lt; y &lt;&lt; <span class="string">" is "</span> &lt;&lt; x * y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'/'</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" / "</span> &lt;&lt; y &lt;&lt; <span class="string">" is "</span> &lt;&lt; x / y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = getDouble();</span><br><span class="line">    <span class="keyword">char</span> op = getOperator();</span><br><span class="line">    <span class="keyword">double</span> y = getDouble();</span><br><span class="line"> </span><br><span class="line">    printResult(x, op, y);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>用户正常输入</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Enter a double value: 5</span><br><span class="line">Enter one of the following: +, -, *, or &#x2F;: *</span><br><span class="line">Enter a double value: 7</span><br><span class="line">5 * 7 is 35</span><br></pre></td></tr></table></figure></li><li><p><strong>用户输入无效文本</strong></p><ul><li><p><strong>1. 输入提取成功，但输入对程序没有意义</strong>(例如，输入“k”作为你的数学运算符)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Enter a double value: 5</span><br><span class="line">Enter one of the following: +, -, *, or &#x2F;: k</span><br><span class="line">Enter a double value: 7</span><br></pre></td></tr></table></figure><p><strong>解决办法</strong>：增加判断用户输入是否符合预期值的代码，当不符合时，重新输入：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getOperator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) <span class="comment">// Loop until user enters a valid input</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter one of the following: +, -, *, or /: "</span>;</span><br><span class="line">        <span class="keyword">char</span> op;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Check whether the user entered meaningful input</span></span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">'+'</span> || op == <span class="string">'-'</span> || op == <span class="string">'*'</span> || op == <span class="string">'/'</span>)    </span><br><span class="line">            <span class="keyword">return</span> op; <span class="comment">// return it to the caller</span></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// otherwise tell the user what went wrong</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Oops, that input is invalid.  Please try again.\n"</span>;</span><br><span class="line">    &#125; <span class="comment">// and try again</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>2. 提取成功，但是有额外的输入</strong></p><p>如：<code>Enter a double value: 5*7</code></p><p>运行结果是：(程序打印正确的答案，但格式却一团糟。这是为什么呢？)</p><blockquote><p>当用户输入“5*7”作为输入时，该输入将进入缓冲区。然后操作符&gt;&gt;将5提取到变量x中，在缓冲区中留下“*7\n”。接下来，程序输出“<code>Enter one of the following: +, -, *, or /:</code>”。但是，当调用提取操作符时，它会看到“*7\n”在缓冲区中等待提取，因此它使用该操作符而不是询问用户更多的输入。因此，它提取“*”字符，在缓冲区中留下“7\n”。</p><p>在要求用户输入另一个双精度值之后，缓冲区中的“7”被提取出来，而不需要询问用户。<strong>由于用户从未有机会输入其他数据并按下回车键(导致换行)</strong>，所以输出提示将一起运行在同一行上，即使输出是正确的。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter a double value: 5*7</span><br><span class="line">Enter one of the following: +, -, *, or &#x2F;: Enter a double value: 5 * 7 is 35</span><br></pre></td></tr></table></figure><p><strong>解决办法：</strong>使用<code>std::cin.ignore(32767, &#39;\n&#39;);</code></p><p>关于<code>cin.jgnore(32767 , &#39;\n&#39;);</code>的详细解释：<a href="https://www.yuque.com/longlongqin/pw9qpx/uap4n0#km6jq" target="_blank" rel="noopener">https://www.yuque.com/longlongqin/pw9qpx/uap4n0#km6jq</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getDouble</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a double value: "</span>;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="number">32767</span>, <span class="string">'\n'</span>); <span class="comment">// clear (up to 32767) characters out of the buffer until a '\n' character is removed</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>3. 提取失败</strong></p><p>如：<code>Enter a double value: a</code></p><p>运行结果：</p><blockquote><p>当用户输入“a”时，该字符被放置在缓冲区中。然后，操作符&gt;&gt;尝试将’ a ‘提取到变量x中，该变量的类型为double。由于’ a ‘不能被转换成double，所以操作符&gt;&gt;不能进行提取。此时会发生两件事:’ a ‘留在缓冲区中，std::cin进入“failure mode(故障模式)”。</p><p>一旦进入“故障模式”，未来的输入提取请求将以静悄悄的失败。因此，在我们的计算器程序中，输出提示仍然打印，但是任何进一步提取的请求都会被忽略。程序简单地运行到最后，然后终止(不打印结果，因为我们从来没有读过有效的数学运算)。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter a double value: a</span><br><span class="line">Enter one of the following: +, -, *, or &#x2F;: Enter a double value:</span><br></pre></td></tr></table></figure><p>解决方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">cin</span>.fail()) <span class="comment">// has a previous extraction failed? ⭐</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// yep, so let's handle the failure</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">clear</span>(); <span class="comment">// put us back in 'normal' operation mode ⭐</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="number">32767</span>,<span class="string">'\n'</span>); <span class="comment">// and remove the bad input</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>现在将这三种错误的解决办法结合起来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getDouble</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) <span class="comment">// Loop until user enters a valid input</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a double value: "</span>;</span><br><span class="line">        <span class="keyword">double</span> x;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">cin</span>.fail()) <span class="comment">// has a previous extraction failed? ⭐3</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// yep, so let's handle the failure</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">clear</span>(); <span class="comment">// put us back in 'normal' operation mode ⭐3</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="number">32767</span>,<span class="string">'\n'</span>); <span class="comment">// and remove the bad input ⭐2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// else our extraction succeeded</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="number">32767</span>, <span class="string">'\n'</span>); <span class="comment">// clear (up to 32767) characters out of the buffer until a '\n' character is removed ⭐2</span></span><br><span class="line">            <span class="keyword">return</span> x; <span class="comment">// so return the value we extracted</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：</em></p><blockquote><p>在C++11之前，如果这个变量已经被初始化过，那么失败的提取不会修改被提取到的变量的初始值。</p><p>在C++11及之后，由<strong>输入无效</strong>而导致提取失败将导致变量初始化为零。(0初始化意味着变量被设置为0, 0.0，” “，或者0转换为该类型的任何值。)</p></blockquote><ul><li><p><strong>4. 提取成功，但是提取的值溢出</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">int16_t</span> x &#123; <span class="number">0</span> &#125;; <span class="comment">// x is 16 bits, holds from -32768 to 32767</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number between -32768 and 32767: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">int16_t</span> y &#123; <span class="number">0</span> &#125;; <span class="comment">// y is 16 bits, holds from -32768 to 32767</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter another number between -32768 and 32767: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; y;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum is: "</span> &lt;&lt; x + y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果输入的数过大，会发生什么呢？（比如输入40000）*/</span></span><br><span class="line">Enter a number between <span class="number">-32768</span> <span class="keyword">and</span> <span class="number">32767</span>: <span class="number">40000</span></span><br><span class="line">Enter another number between <span class="number">-32768</span> <span class="keyword">and</span> <span class="number">32767</span>: The sum is: <span class="number">32767</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>std::cin</code>会立即进入“故障模式”，但也会将最接近的范围内值赋给变量。因此，x的赋值为32767。跳过其他输入，让y的初始值为0。我们可以使用与<strong>提取失败</strong>相同的方法来处理这种错误。</p><blockquote><p><em>注</em></p><p>在c++ 11之前，失败的提取不会修改被提取到的变量。这意味着如果一个变量没有初始化，那么在失败的提取情况下，它将保持未初始化状态。(比如y，这里它会保持初始值0)</p><p>从c++ 11开始，<strong>超过范围(out-of-range)</strong>时失败的提取将导致变量被设置为最接近的范围内值。</p></blockquote></li></ul></li></ul><hr><p>在我的vs2013中，测试上面的代码，得到的结果是：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://raw.githubusercontent.com/longlongqin/CDN-for-HEXO_BLOG/pig_bed/20200426155848.png" alt="image-20200426155834334"></p><p>这说明我的“故障模式”下，变量将会被初始化为0</p><h4 id="修改后的例子："><a href="#修改后的例子：" class="headerlink" title="修改后的例子："></a>修改后的例子：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getDouble</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) <span class="comment">// Loop until user enters a valid input</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a double value: "</span>;</span><br><span class="line">        <span class="keyword">double</span> x;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Check for failed extraction</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">cin</span>.fail()) <span class="comment">// has a previous extraction failed?</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// yep, so let's handle the failure</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">clear</span>(); <span class="comment">// put us back in 'normal' operation mode</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="number">32767</span>,<span class="string">'\n'</span>); <span class="comment">// and remove the bad input</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Oops, that input is invalid.  Please try again.\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="number">32767</span>,<span class="string">'\n'</span>); <span class="comment">// remove any extraneous input</span></span><br><span class="line"> </span><br><span class="line">            <span class="comment">// the user can't enter a meaningless double value, so we don't need to worry about validating that</span></span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getOperator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) <span class="comment">// Loop until user enters a valid input</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter one of the following: +, -, *, or /: "</span>;</span><br><span class="line">        <span class="keyword">char</span> op;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Chars can accept any single input character, so no need to check for an invalid extraction here</span></span><br><span class="line"> </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="number">32767</span>,<span class="string">'\n'</span>); <span class="comment">// remove any extraneous input</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Check whether the user entered meaningful input</span></span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">'+'</span> || op == <span class="string">'-'</span> || op == <span class="string">'*'</span> || op == <span class="string">'/'</span>)    </span><br><span class="line">            <span class="keyword">return</span> op; <span class="comment">// return it to the caller</span></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// otherwise tell the user what went wrong</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Oops, that input is invalid.  Please try again.\n"</span>;</span><br><span class="line">    &#125; <span class="comment">// and try again</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printResult</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">char</span> op, <span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="string">'+'</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" + "</span> &lt;&lt; y &lt;&lt; <span class="string">" is "</span> &lt;&lt; x + y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'-'</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" - "</span> &lt;&lt; y &lt;&lt; <span class="string">" is "</span> &lt;&lt; x - y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'*'</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" * "</span> &lt;&lt; y &lt;&lt; <span class="string">" is "</span> &lt;&lt; x * y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'/'</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" / "</span> &lt;&lt; y &lt;&lt; <span class="string">" is "</span> &lt;&lt; x / y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// Being robust means handling unexpected parameters as well, even though getOperator() guarantees op is valid in this particular program</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Something went wrong: printResult() got an invalid operator."</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = getDouble();</span><br><span class="line">    <span class="keyword">char</span> op = getOperator();</span><br><span class="line">    <span class="keyword">double</span> y = getDouble();</span><br><span class="line"> </span><br><span class="line">    printResult(x, op, y);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在编写程序时，要考虑用户如何误用程序，特别是在文本输入方面。对于文本输入的每个点，请考虑:</p><ul><li>提取是否失败？</li><li>用户是否会输入比预期更多的文本？</li><li>用户是否会输入没有意义的文本？</li><li>用户是否会输出溢出的值？</li></ul><p>您可以使用<strong>if语句和布尔逻辑</strong>来测试输入是否是预期的和有意义的。</p><h3 id="修复提取失败-amp-溢出"><a href="#修复提取失败-amp-溢出" class="headerlink" title="修复提取失败&amp;溢出"></a>修复提取失败&amp;溢出</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">cin</span>.fail()) <span class="comment">// has a previous extraction failed or overflowed?</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// yep, so let's handle the failure</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">clear</span>(); <span class="comment">// put us back in 'normal' operation mode</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="number">32767</span>,<span class="string">'\n'</span>); <span class="comment">// and remove the bad input</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="清除额外的输入"><a href="#清除额外的输入" class="headerlink" title="清除额外的输入"></a>清除额外的输入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="number">32767</span>,<span class="string">'\n'</span>); <span class="comment">// and remove the bad input</span></span><br></pre></td></tr></table></figure><hr><p>最后，如果原始输入无效，使用循环要求用户重新输入输入。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;p center large&gt;&lt;red&gt;std::cin（输入）&lt;/red&gt;&lt;/p&gt;&lt;/center&gt;&lt;center&gt;&lt;red&gt;https://www.learncpp.com&lt;/red&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C/C++" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"/>
    
    
      <category term="C/C++" scheme="https://longlongqin.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>test your code</title>
    <link href="https://longlongqin.github.io/archives/5937092e.html"/>
    <id>https://longlongqin.github.io/archives/5937092e.html</id>
    <published>2020-04-26T08:36:13.397Z</published>
    <updated>2020-04-28T10:26:50.435Z</updated>
    
    <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapterL</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;p center large&gt;&lt;red&gt;LearnCpp chapterL&lt;/red&gt;&lt;/p&gt;&lt;/center&gt;&lt;center&gt;&lt;red&gt;https://www.learncpp.com&lt;/red&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C/C++" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"/>
    
    
      <category term="C/C++" scheme="https://longlongqin.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>LearnCpp chapter8</title>
    <link href="https://longlongqin.github.io/archives/c812a74c.html"/>
    <id>https://longlongqin.github.io/archives/c812a74c.html</id>
    <published>2020-04-19T08:54:17.000Z</published>
    <updated>2020-04-22T07:17:55.695Z</updated>
    
    <content type="html"><![CDATA[<center><p center large><red>LearnCpp-chapter8</red></p></center><center><red>https://www.learncpp.com</red></center><p>未完待续~~</p><a id="more"></a><h2 id="8-1-介绍面向对象编程"><a href="#8-1-介绍面向对象编程" class="headerlink" title="8.1 介绍面向对象编程"></a>8.1 介绍面向对象编程</h2><center><red>Object-oriented programming (OOP)</red></center><p>在 <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-variables/" target="_blank" rel="noopener">1.3 – Introduction to variables</a>中，我们在c++中将<strong>一个对象定义为“一段可用来存储值的内存”。</strong>具<strong>有名称的对象称为变量。</strong></p><p>在传统编程中(我们在此之前一直在做的工作)，程序基本上是计算机的指令列表，这些指令定义数据(通过对象)，然后处理数据(通过语句和函数)。数据和处理该数据的函数是独立的实体，它们组合在一起以产生所需的结果。由于这种分离，传统的编程通常不能提供对现实的非常直观的表示。</p><p>由程序员以适当的方式管理和连接 <strong>属性(变量)</strong>和<strong>行为(函数)</strong>，这就致使代码变成这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driveTo(you, work);</span><br></pre></td></tr></table></figure><h3 id="什么是面向对象编程？"><a href="#什么是面向对象编程？" class="headerlink" title="什么是面向对象编程？"></a>什么是面向对象编程？</h3><p>和许多事物一样，它可能最容易通过类比来理解。看看你的周围–你看到的每一个地方都是<strong>object</strong>：书籍、建筑物、食物，甚至你自己。</p><p><strong>object</strong>有两个主要的部分：</p><ol><li>（<strong>properties</strong>）<strong>相关属性的列表</strong>（e.g. weight, color, size, solidity, shape, etc…）</li><li>（<strong>behavior</strong>）<strong>这些属性能表现出的一些行为</strong>（e.g. being opened, making something else hot, etc…）</li></ol><p>这些<strong>属性</strong>和<strong>行为</strong>是不可分割的。</p><hr><p>Object-oriented programming (OOP) 为我们提供了创建对象的能力，这些对象将属性和行为绑定到一个自包含的、可重用的包中。这导致代码看起来更像这样:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you.driveto(work);</span><br></pre></td></tr></table></figure><blockquote><p>这不仅读起来更清晰，还使主语(您)和被调用的行为(在某处驾驶)更清晰。</p><p><strong>不是专注于编写函数，而是专注于定义具有定义良好的行为集的对象</strong>。<strong>这就是为什么这个范例被称为“面向对象”。</strong></p></blockquote><hr><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>这允许以更模块化的方式编写程序，这使它们更容易编写和理解，还提供了更高程度的<strong>代码可重用性</strong>。</p><p>这些对象还提供了一种 <strong>通过允许我们定义如何与对象交互以及如何与其他对象交互，来更直观的方式来处理数据。</strong></p><blockquote><p>请注意，OOP并没有取代传统的编程方法。相反，它在编程工具带中为您提供了额外的工具，以便在需要时管理复杂性。</p></blockquote><h4 id="object"><a href="#object" class="headerlink" title="object"></a>object</h4><p>请注意，<strong>术语“object”被稍微重载了一些</strong>，这导致了一些混淆。<strong>在传统编程中，对象是用来存储值的一块内存</strong>。<strong>在面向对象编程中，“对象”意味着它包含 传统编程意义上的对象，又是属性和行为的组合。</strong>从现在开始，当我们使用“对象”这个术语时，我们将在面向对象的意义上引用“对象”。</p><h2 id="8-2-类-amp-类成员"><a href="#8-2-类-amp-类成员" class="headerlink" title="8.2 类&amp;类成员"></a>8.2 类&amp;类成员</h2><p>虽然C++提供一些基本的数据类型（e.g. char, int, long, float, double, etc…），它们可以解决一些简单的问题。</p><p>但是在解决复杂问题的时候这些基本数据类型就不够用了。</p><blockquote><p>C++也提供：<strong>允许用户自定义数据类型</strong>，如之前学的： <strong><a href="http://www.learncpp.com/cpp-tutorial/45-enumerated-types/" target="_blank" rel="noopener">enumerated types</a></strong>、<a href="http://www.learncpp.com/cpp-tutorial/47-structs/" target="_blank" rel="noopener"><strong>structs</strong></a></p></blockquote><p>在C++，中<code>class</code>与 <code>struct</code>本质上相同。如下面的两个是等价的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DateStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_year;</span><br><span class="line">    <span class="keyword">int</span> m_month;</span><br><span class="line">    <span class="keyword">int</span> m_day;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>注意，惟一显著的区别是<code>public:</code>关键字在类中</p></blockquote><p><strong>类(和结构)定义就像一个蓝图——它们描述结果对象的样子，但是它们实际上并不创建对象</strong>。<u>要实际创建类的对象，必须定义该类类型的变量:</u></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DateClass today &#123; <span class="number">2020</span>, <span class="number">10</span>, <span class="number">14</span> &#125;; <span class="comment">// declare a variable of class DateClass</span></span><br></pre></td></tr></table></figure><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p>除了保存数据，类(和结构)还可以包含函数!在类内部定义的函数称为<strong>成员函数</strong> (有时也称为<strong>方法</strong>)。</p><h4 id="成员函数-amp-非成员函数"><a href="#成员函数-amp-非成员函数" class="headerlink" title="成员函数&amp;非成员函数"></a>成员函数&amp;非成员函数</h4><p>eg：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非成员函数：函数不能调用定义在它下面的函数(没有前向声明):</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// You can't call y() from here unless the compiler has already seen a forward declaration for y()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数：成员函数没有这个限制</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">x</span><span class="params">()</span> </span>&#123;y()&#125; ;<span class="comment">// okay to call y() here, even though y() isn't defined until later in this class</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">y</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成员类型"><a href="#成员类型" class="headerlink" title="成员类型"></a>成员类型</h3><p>除了成员变量和成员函数外，类还可以具有<strong>成员类型</strong>或<strong>嵌套类型</strong>(包括<strong>类型别名</strong>)。在下面的例子中，我们创建了一个计算器，如果需要，我们可以快速地更改它所使用的数字类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vertor&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">number_t</span> = <span class="keyword">int</span>; <span class="comment">//这是一个嵌套类型的别名</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">number_t</span>&gt; m_result&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">number_t</span> <span class="title">add</span> <span class="params">(<span class="keyword">number_t</span> a, <span class="keyword">number_t</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//auto的原理就是根据后面的值，来自己推测前面的类型是什么。</span></span><br><span class="line">        <span class="keyword">auto</span> result &#123;a+b&#125;;</span><br><span class="line">        m_result.push_back (result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Calculator calculator &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; calculator.add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这样的上下文中，<strong>类名</strong>实际上充当嵌套类型的<strong>名称空间</strong>。在类内部，我们只需要引用number_t。在类之外，我们可以通过Calculator::number_t访问类型。</p><hr><h3 id="关于C-中的struct的说明"><a href="#关于C-中的struct的说明" class="headerlink" title="关于C++中的struct的说明"></a>关于C++中的struct的说明</h3><p>在C语言中，<strong>结构体只能保存数据</strong>，<strong>没有成员函数</strong>。但是咋C++中，两者都可以有。</p><p>经过考虑，他决定他们应该有一个统一的规则集。因此，<strong>虽然我们使用class关键字编写了上述程序，但我们可以使用struct关键字。</strong></p><p>所以，建议：</p><blockquote><p><strong>对只包含数据的结构使用struct关键字</strong>。<strong>对同时具有数据和函数的对象使用class关键字。</strong></p></blockquote><h2 id="8-3-访问说明符-piblicVS-private"><a href="#8-3-访问说明符-piblicVS-private" class="headerlink" title="8.3 访问说明符 piblicVS private"></a>8.3 访问说明符 <code>piblic</code>VS <code>private</code></h2><p><strong>public</strong>：<code>class</code>和<code>struct</code>的public member 可以在 它们的外部访问；</p><blockquote><p><strong>由关键字<code>struct</code>构成的数据类型，默认是public。</strong></p></blockquote><p><strong>private</strong>：只能被类的其他成员访问；</p><blockquote><p><strong>由<code>class</code>构成的数据类型，默认是private。</strong></p></blockquote><hr><p><strong>通常，成员变量通常是<code>private</code>的，而成员函数通常是<code>public</code>的。</strong></p><p>eg：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DateStruct</span> // <span class="title">members</span> <span class="title">are</span> <span class="title">public</span> <span class="title">by</span> <span class="title">default</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> month; <span class="comment">// public by default, can be accessed by anyone</span></span><br><span class="line">    <span class="keyword">int</span> day; <span class="comment">// public by default, can be accessed by anyone</span></span><br><span class="line">    <span class="keyword">int</span> year; <span class="comment">// public by default, can be accessed by anyone</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DateStruct date;</span><br><span class="line">    date.month = <span class="number">10</span>;</span><br><span class="line">    date.day = <span class="number">14</span>;</span><br><span class="line">    date.year= <span class="number">2020</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateClass</span> // <span class="title">members</span> <span class="title">are</span> <span class="title">private</span> <span class="title">by</span> <span class="title">default</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m_month; <span class="comment">// private by default, can only be accessed by other members</span></span><br><span class="line">    <span class="keyword">int</span> m_day; <span class="comment">// private by default, can only be accessed by other members</span></span><br><span class="line">    <span class="keyword">int</span> m_year; <span class="comment">// private by default, can only be accessed by other members</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DateClass date;</span><br><span class="line">    date.m_month = <span class="number">10</span>; <span class="comment">// error</span></span><br><span class="line">    date.m_day = <span class="number">14</span>; <span class="comment">// error</span></span><br><span class="line">    date.m_year = <span class="number">2020</span>; <span class="comment">// error</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类的<strong>public member</strong>通常被看作 <strong>public interface（公共接口）</strong>：因为只有public mebmber才可以在类外部被访问，但是public member可以直接访问类中的private和protected的成员。<strong>所以利用public member 可以间接访问类的private和protected的成员。</strong></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;p center large&gt;&lt;red&gt;LearnCpp-chapter8&lt;/red&gt;&lt;/p&gt;&lt;/center&gt;&lt;center&gt;&lt;red&gt;https://www.learncpp.com&lt;/red&gt;&lt;/center&gt;&lt;p&gt;未完待续~~&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C/C++" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"/>
    
    
      <category term="C/C++" scheme="https://longlongqin.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>LearnCpp chapterL</title>
    <link href="https://longlongqin.github.io/archives/9f7a1269.html"/>
    <id>https://longlongqin.github.io/archives/9f7a1269.html</id>
    <published>2020-04-18T02:13:00.000Z</published>
    <updated>2020-04-23T08:14:32.228Z</updated>
    
    <content type="html"><![CDATA[<center><p center large><red>LearnCpp-chapterL</red></p></center><center><red>https://www.learncpp.com</red></center><p>未完待续~~</p><a id="more"></a><h2 id="L5-1-控制流"><a href="#L5-1-控制流" class="headerlink" title="L5.1 控制流"></a>L5.1 控制流</h2><p>当程序运行时，CPU开始从<code>mian()</code>函数执行，然后执行它里面的语句，最后结束于<code>main()</code>函数结尾。</p><p>CPU执行语句的顺序叫做：<strong>程序执行路径(execution path)</strong>。</p><h3 id="停止-halt"><a href="#停止-halt" class="headerlink" title="停止(halt)"></a>停止(halt)</h3><p>但程序运行并不总是将<code>main()</code>函数中的语句全部执行。它可以被停止。在C++中，可以使用<strong>头文件<code>cstdlib</code>中的<code>std::exit()</code>函数</strong>，来终止程序。</p><blockquote><p><code>exit</code>函数接受一个整数参数，该参数作为std::exit代码返回给操作系统，这与main()的返回值非常相似。</p></blockquote><p>eg:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; //for std::exit()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//code here to do any kind of cleanup required</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    cleanup();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">//程序在此结束，并且向操作系统返回0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//所以下面的语句将不会执行</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="number">2</span>&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>，<code>std::exit()</code>无论从哪个函数调用(甚至是<code>main</code>以外的函数)都可以工作。还要注意，<code>std::exit()</code>使用最少的清理立即终止程序。所以，在使用<code>std::exit()</code>之前，您应该考虑是否需要进行任何手动清理(例如将用户的游戏保存到磁盘)。</p><blockquote><p>通常，<code>std::exit()</code>用于在发生灾难性的、不可恢复的错误时立即终止程序。</p></blockquote><h2 id="L5-1-if语句"><a href="#L5-1-if语句" class="headerlink" title="L5.1 if语句"></a>L5.1 if语句</h2><p>最基本的条件分支就是 <strong>if 语句</strong>。</p><h3 id="隐式的块"><a href="#隐式的块" class="headerlink" title="隐式的块"></a>隐式的块</h3><p>我们需要注意，隐式的块中的一些陷阱，</p><h4 id="陷阱1："><a href="#陷阱1：" class="headerlink" title="陷阱1："></a>陷阱1：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">6</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为上面的x是在一个块中被定义的(这个块没有显式的写出来，但它确实是一个块)</span></span><br></pre></td></tr></table></figure><p>上面这个程序会出错，原因：（这将无法编译，编译器将生成标识符<code>x</code>未定义的错误）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面的程序和这个程序相等。这个程序将块显式的表示出来了</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">    &#125; <span class="comment">// x destroyed here</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">6</span>;</span><br><span class="line">    &#125; <span class="comment">// x destroyed here</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x; <span class="comment">// x isn't defined here</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="陷阱2："><a href="#陷阱2：" class="headerlink" title="陷阱2："></a>陷阱2：</h4><p>程序1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= <span class="number">20</span>)</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">"is between 10 and 20\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// attached to outer if statement</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">"is less than 10\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序2：（去掉大括号）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">10</span>)</span><br><span class="line">    <span class="comment">//删除大括号</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt;= <span class="number">20</span>)</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">"is between 10 and 20\n"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// attached to outer if statement</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">"is less than 10\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序1和2是否一样呢？</p><p>答：不一样。程序1中的最后的else语句是与第一个if语句匹配；程序2中的最后的else语句是与它最近的if语句匹配。</p><h3 id="if中的初始化语句"><a href="#if中的初始化语句" class="headerlink" title="if中的初始化语句"></a>if中的初始化语句</h3><p>如果需要在If语句中使用变量，而不是在If语句之外，<strong>那么可以在条件之前使用init语句</strong>(在C++17中添加的）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> firstname&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> lastname&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"First name: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; firstName;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Last name: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; lastName;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">std</span>::<span class="built_in">string</span> fullname &#123;firsstname + <span class="string">' '</span> + lastname&#125;; fullname.length()&gt;<span class="number">20</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; '"'&lt;&lt;fullname &lt;&lt;'\" is to long \n';</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"your name is: "</span> &lt;&lt;fullname;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量<code>fullname</code>在整个if语句中是可以访问的。</p><h2 id="L5-2-switch语句"><a href="#L5-2-switch语句" class="headerlink" title="L5.2 switch语句"></a>L5.2 switch语句</h2><p>C++ 中 <strong>switch</strong> 语句的语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> constant-expression  :</span><br><span class="line">       statement(s);</span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">// 可选的</span></span><br><span class="line">    <span class="keyword">case</span> constant-expression  :</span><br><span class="line">       statement(s);</span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">// 可选的</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 您可以有任意数量的 case 语句</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">// 可选的</span></span><br><span class="line">       statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>switch</strong> 语句必须遵循下面的规则：</p><ul><li><p><strong>switch</strong> 语句中的 <strong>expression</strong> 必须是一个<strong>integral type(整数类型)或浮点类型</strong>，或者是一个 class 类型，其中 class 有一个单一的转换函数将其转换为整型或枚举类型。</p><blockquote><p><strong>整数类型</strong>有：<code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>long long</code>, or <code>enum</code></p><p>注意，<strong>在C/C++中，char是属于整数类型的</strong>。</p></blockquote></li><li><p>在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。</p></li><li><p>case 的 <strong>constant-expression</strong> 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。</p></li><li><p>当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 <strong>break</strong> 语句为止。</p></li><li><p>当遇到 <strong>break</strong> 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。</p></li><li><p>不是每一个 case 都需要包含 <strong>break</strong>。如果 case 语句不包含 <strong>break</strong>，控制流将会 <em>继续</em> 后续的 case，直到遇到 break 为止。</p></li><li><p>一个 <strong>switch</strong> 语句可以有一个可选的 <strong>default</strong> case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 <strong>break</strong> 语句不是必需的。</p></li></ul><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><h4 id="在case语句中有、无-break-的效果"><a href="#在case语句中有、无-break-的效果" class="headerlink" title="在case语句中有、无 break 的效果"></a>在case语句中有、无 break 的效果</h4><p>在 switch 语句中，每个 case 语句的结尾不要忘记添加 break 语句，否则将导致多个分支重叠。当然，除非有意使多个分支重叠，这样可以免去 break 语句。下面我们来看一个实际示例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有break</span></span><br><span class="line"><span class="keyword">switch</span> (<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// Does not match</span></span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// skipped</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// Match!</span></span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// Execution begins here</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// This is also executed</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">4</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// This is also executed</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">5</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// This is also executed</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**结果******/</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line"><span class="comment">//无break</span></span><br><span class="line"><span class="keyword">switch</span> (<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// Does not match</span></span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// skipped</span></span><br><span class="line">   <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// Match!</span></span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// Execution begins here</span></span><br><span class="line">   <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// This is also executed</span></span><br><span class="line">   <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">4</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// This is also executed</span></span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">5</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// This is also executed</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******结果***********/</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="case语句中变量的声明-amp-定义"><a href="#case语句中变量的声明-amp-定义" class="headerlink" title="case语句中变量的声明&amp;定义"></a>case语句中变量的声明&amp;定义</h3><p><strong>你可以在switch语句中声明变量(但不能够初始化)</strong>。在case之前或之后均可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a; <span class="comment">// okay, declaration is allowed before the case labels</span></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">5</span>; <span class="comment">// illegal, initialization is not allowed before the case labels</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">int</span> y; <span class="comment">// okay, declaration is allowed within a case</span></span><br><span class="line">        y = <span class="number">4</span>; <span class="comment">// okay, 这个是赋值(不是初始化)</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        y = <span class="number">5</span>; <span class="comment">// okay, y was declared above, so we can use it here too</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">int</span> z = <span class="number">4</span>; <span class="comment">// illegal, 不能再这里面对变量初始化</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"default case"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为在switch语句中，不存在隐式的块。所以，在switch语句内，所有语句的范围都一样(存在于switch的内部)。所以，在case 1：声明的变量y，可以在case 2：中被访问</p></blockquote><blockquote><p>但是，不允许直接在case标签下面初始化变量，这会导致编译错误。这是因为<strong>初始化变量需要执行（声明语句不会执行）</strong>，而包含初始化的case语句可能不会执行!</p><hr><p><strong>但是我们可以在case块中，初始化变量：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    &#123; <span class="comment">// note addition of block here</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">4</span>; <span class="comment">// okay, variables can be initialized inside a block inside a case</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"default case"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><hr><h2 id="L5-4-goto-语句"><a href="#L5-4-goto-语句" class="headerlink" title="L5.4 goto 语句"></a>L5.4 goto 语句</h2><p>goto语句是一个控制流语句，它使CPU跳到代码中的另一个位置。这个位置是通过使用<strong>statement label（语句标签）</strong>来标识的。</p><p>eg:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; // for sqrt() function</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">tryAgain: <span class="comment">// this is a statement label</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a non-negative number"</span>; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0.0</span>)</span><br><span class="line">        <span class="keyword">goto</span> tryAgain; <span class="comment">// this is the goto statement</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sqrt of "</span> &lt;&lt; x &lt;&lt; <span class="string">" is "</span> &lt;&lt; <span class="built_in">sqrt</span>(x) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果用户输入的数是负数，那它会一直<code>goto</code>到这个语句标签，直到你输入一个合格的非负数。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LearnCpp-chapterL/image-20200423100210785.png" alt="image-20200423100210785"></p></blockquote><hr><h3 id="陷阱："><a href="#陷阱：" class="headerlink" title="陷阱："></a>陷阱：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">goto</span> skip; <span class="comment">// invalid forward jump</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">skip:</span><br><span class="line">    x += <span class="number">3</span>; <span class="comment">// what would this even evaluate to?</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们不能这样使用 语句标签。因为我们跳转到标签语句<code>skip</code>中时，程序还没执行到<code>int x = 5;</code>这个语句。所以，会报错：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LearnCpp-chapterL/image-20200423101450792.png" alt="image-20200423101450792"></p><p>如何改正：</p><p>我们可以让<code>int x=5;</code>这个语句放在 <code>goto skip;</code>语句之前，就可以了。</p><hr><h3 id="不建议使用goto语句"><a href="#不建议使用goto语句" class="headerlink" title="不建议使用goto语句"></a>不建议使用goto语句</h3><p>goto的主要问题是，它允许程序员任意地在执行点上跳转。因此很难理解这种代码的逻辑。</p><h2 id="L5-7-for语句"><a href="#L5-7-for语句" class="headerlink" title="L5.7 for语句"></a>L5.7 for语句</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形式</span></span><br><span class="line"><span class="keyword">for</span> (init-statement; condition-expression; <span class="built_in">end</span>-expression)</span><br><span class="line">   statement</span><br></pre></td></tr></table></figure><h3 id="多重声明"><a href="#多重声明" class="headerlink" title="多重声明"></a>多重声明</h3><p>有时for循环需要多个变量。当这种情况发生时，程序员可以使用<strong>逗号操作符</strong>来分配(在init-statement中)或更改(在end-statement中)多个变量的值:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> iii&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> jjj&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (iii = <span class="number">0</span>, jjj = <span class="number">9</span>; iii &lt; <span class="number">10</span>; ++iii, --jjj)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iii &lt;&lt; <span class="string">' '</span> &lt;&lt; jjj &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更常用的写法是：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> iii&#123;<span class="number">0</span>&#125;, jjj&#123;<span class="number">9</span>&#125;; iii&lt;<span class="number">10</span>; ++iii, --jjj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;iii &lt;&lt;<span class="string">' '</span> &lt;&lt;jjj &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="L5-8-break-和-continue"><a href="#L5-8-break-和-continue" class="headerlink" title="L5.8 break 和 continue"></a>L5.8 break 和 continue</h2><h3 id="break与return"><a href="#break与return" class="headerlink" title="break与return"></a>break与return</h3><ul><li>break语句是终止<code>switch</code>语句 或者 其他循环语句，然后继续执行该语句下面的语句。</li><li>return语句终止循环所在的整个函数，并在调用函数的地方继续执行。</li></ul><p>请看下面例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">breakOrReturn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) <span class="comment">// infinite loop</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter 'b' to break or 'r' to return: "</span>;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'b'</span>)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// execution will continue at the first statement beyond the loop</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'r'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// return will cause the function to immediately return to the caller (in this case, main())</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// breaking the loop causes execution to resume here</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"We broke out of the loop\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> returnValue&#123; breakOrReturn() &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Function breakOrReturn returned "</span> &lt;&lt; returnValue &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p><code>continue</code>语句提供了一种方便的方法来跳转到当前迭代（当前这一层循环）的循环体的末尾。当我们想要提前终止当前的迭代时，这是很有用的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> count&#123; <span class="number">0</span> &#125;; count  &lt; <span class="number">20</span>; ++count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// if the number is divisible by 4, skip this iteration</span></span><br><span class="line">    <span class="keyword">if</span> ((count % <span class="number">4</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">// jump to end of loop body</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// If the number is not divisible by 4, keep going</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">------------------------------------------------------ </span><br><span class="line"><span class="comment">// The continue statement jumps to here</span></span><br><span class="line">------------------------------------------------------</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;p center large&gt;&lt;red&gt;LearnCpp-chapterL&lt;/red&gt;&lt;/p&gt;&lt;/center&gt;&lt;center&gt;&lt;red&gt;https://www.learncpp.com&lt;/red&gt;&lt;/center&gt;&lt;p&gt;未完待续~~&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C/C++" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"/>
    
    
      <category term="C/C++" scheme="https://longlongqin.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>LearnCpp chapterP</title>
    <link href="https://longlongqin.github.io/archives/67343d3.html"/>
    <id>https://longlongqin.github.io/archives/67343d3.html</id>
    <published>2020-04-14T08:48:27.000Z</published>
    <updated>2020-04-28T06:53:21.411Z</updated>
    
    <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapterP</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h2 id="S-4-4b-介绍std-string"><a href="#S-4-4b-介绍std-string" class="headerlink" title="S.4.4b 介绍std::string"></a>S.4.4b 介绍<code>std::string</code></h2><p>字符串在程序中很常见，大部分现代编程语言都包括一个内置的字符串数据类型。C++包括一个，不是作为核心语言的一部分，而是作为标准库的一部分。</p><h3 id="std-string"><a href="#std-string" class="headerlink" title="std::string"></a>std::string</h3><p>如果想在C++中使用string类型。需要加入头文件<code>#include &lt;string&gt;</code>来声明std::string。只要有这个头文件，我们就可以在程序中使用string类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> myName;</span><br></pre></td></tr></table></figure><p>就像其他类型一样，你可以为字符串类型的变量进行初始化 或者 复制：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> myName&#123; <span class="string">"Alex"</span> &#125;; <span class="comment">// initialize myName with string literal "Alex"</span></span><br><span class="line">myName = <span class="string">"John"</span>; <span class="comment">// assign variable myName the string literal "John"</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>字符串也可以保存数字</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> myID&#123; <span class="string">"45"</span> &#125;; <span class="comment">// "45" is not the same as integer 45!</span></span><br></pre></td></tr></table></figure><p><strong>字符串格式的 数字，其实是文本形式，而不是 数字形式。</strong></p></blockquote><h3 id="输入输出字符串"><a href="#输入输出字符串" class="headerlink" title="输入输出字符串"></a>输入输出字符串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> myName&#123; <span class="string">"Alex"</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"My name is: "</span> &lt;&lt; myName &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************打印***********/</span></span><br><span class="line">My name is: Alex</span><br></pre></td></tr></table></figure><p>但是，使用<code>std::cin</code>来输入字符串，可能会产生异常：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter your full name: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; name; <span class="comment">// this won't work as expected since std::cin breaks on whitespace</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter your age: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> age;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; age;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Your name is "</span> &lt;&lt; name &lt;&lt; <span class="string">" and your age is "</span> &lt;&lt; age &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://raw.githubusercontent.com/longlongqin/CDN-for-HEXO_BLOG/pig_bed/20200428145311.png" alt="image-20200414171736561"></p><p>可以看到，<code>大 魔头</code>中间有空格。然后就会被自动截断，前一部分赋值给变量name；第二半段赋值给age。</p><blockquote><p>也就是说：那是不对的!发生了什么事?结果表明，当使用操作符&gt;&gt;从cin提取字符串时，操作符&gt;&gt;只返回它遇到的第一个空格之前的字符。其他字符留在cin中，等待下一次提取。</p></blockquote><h3 id="用std-getline-输入文本"><a href="#用std-getline-输入文本" class="headerlink" title="用std::getline()输入文本"></a>用<code>std::getline()</code>输入文本</h3><p>要将<strong>整行</strong>输入读入字符串，<strong>我们最好需要使用<code>std::getline()</code></strong>函数。</p><blockquote><p><code>std::getline()</code>含有两个形参：<strong>第一个是<code>std::cin</code></strong>；<strong>第二个是我们输入的字符串的变量</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter your full name: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, name); <span class="comment">// read a full line of text into name</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter your age: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> age&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, age); <span class="comment">// read a full line of text into age</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Your name is "</span> &lt;&lt; name &lt;&lt; <span class="string">" and your age is "</span> &lt;&lt; age &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果**************/</span></span><br><span class="line">Enter your full name: John Doe</span><br><span class="line">Enter your age: <span class="number">23</span></span><br><span class="line">Your name is John Doe <span class="keyword">and</span> your age is <span class="number">23</span></span><br></pre></td></tr></table></figure><h3 id="混合使用std-cin、std-getline"><a href="#混合使用std-cin、std-getline" class="headerlink" title="混合使用std::cin、std::getline()"></a>混合使用<code>std::cin</code>、<code>std::getline()</code></h3><p>混合使用他俩，可能会产生异常：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Pick 1 or 2: "</span>;</span><br><span class="line">    <span class="keyword">int</span> choice&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; choice;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Now enter your name: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, name);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, "</span> &lt;&lt; name &lt;&lt; <span class="string">", you picked "</span> &lt;&lt; choice &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序首先要求您输入1或2，然后等待您这样做。到目前为止一切顺利。然后它会要求你输入你的名字。然而，它实际上不会等待您输入您的名字！相反，它打印“Hello”行，然后退出。发生了什么事?</p><blockquote><p>结果是，当您使用cin输入一个值时，<strong>cin不仅捕获值，还捕获换行符</strong>。当我们输入2时，cin实际上会得到字符串“2\n”。然后提取2到变量选择，使换行留在输入流中。然后，当std::getline()去读取名称时，它会看到“\n”已经在流中，并且认为我们必须输入一个空字符串!绝对不是我们想要的。</p></blockquote><hr><p>一个好方法：<strong>使用<code>std::cin</code>读取完值 之后，将换行 从输入流中删除</strong>：</p><blockquote><p><code>std::cin.ignore(32767, &#39;\n&#39;);</code> //忽略不超过32767个字符，直到删除一个\n.</p><p>关于<code>32767</code>请看下一节</p></blockquote><p>如下，在main函数中，增加一句<code>std::cin.ignore(32767, &#39;\n&#39;);</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Pick 1 or 2: "</span>;</span><br><span class="line"><span class="keyword">int</span> choice&#123;&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; choice;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//新加</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="number">32767</span>, <span class="string">'\n'</span>); <span class="comment">// ignore up to 32767 characters until a \n is removed</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Now enter your name: "</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line"><span class="built_in">std</span>::getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, name);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, "</span> &lt;&lt; name &lt;&lt; <span class="string">", you picked "</span> &lt;&lt; choice &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>规则:<strong>如果使用<code>std::cin</code>读取值</strong>，<strong>最好使用<code>std:: cin .ignore()</code>来删除多余的换行符。</strong></p></blockquote><hr><h3 id="32767代表什么"><a href="#32767代表什么" class="headerlink" title="32767代表什么"></a><code>32767</code>代表什么</h3><p>这告诉<code>std::cin.ignore()</code>要忽略多少字符。我们选择<code>32767</code>是因为它是保证在所有平台上都适合(2字节)整数的最大有符号值。</p><blockquote><p>从技术上讲，忽略无限量输入的正确方法如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>); <span class="comment">// ignore unlimited characters until a \n is removed</span></span><br></pre></td></tr></table></figure><p>但是，相比之下，这样的方式太复杂了。而且还需要加上头文件<code>limits</code></p></blockquote><h3 id="字符串的“加法”"><a href="#字符串的“加法”" class="headerlink" title="字符串的“加法”"></a>字符串的“加法”</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> a&#123; <span class="string">"45"</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> b&#123; <span class="string">"11"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a + b &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// a and b will be concatenated</span></span><br><span class="line">    a += <span class="string">"volts"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*****结果********/</span></span><br><span class="line"><span class="number">4511</span></span><br><span class="line"><span class="number">45</span>volts</span><br></pre></td></tr></table></figure><blockquote><p>注意，如果你想对<strong>字符串减法，是不可以的熬</strong></p></blockquote><h3 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> myName&#123; <span class="string">"Alex"</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; myName &lt;&lt; <span class="string">" has "</span> &lt;&lt; myName.length() &lt;&lt; <span class="string">" characters\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; myName &lt;&lt; <span class="string">" has "</span> &lt;&lt; length(myName) &lt;&lt; <span class="string">" characters\n"</span>;<span class="comment">//error:未定义标识符 length</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，我们不是将字符串长度作为length(myName)，而是使用myName.length()。</p><blockquote><p>length函数不是我们目前使用的一个普通的独立函数，它是属于std::string的一种特殊类型的函数，称为成员函数。</p></blockquote><h2 id="S-4-4c-使用语言参考"><a href="#S-4-4c-使用语言参考" class="headerlink" title="S.4.4c 使用语言参考"></a>S.4.4c 使用语言参考</h2><p>本节原文地址：<a href="https://www.learncpp.com/cpp-tutorial/using-a-language-reference/" target="_blank" rel="noopener"><strong>S.4.4c — Using a language reference</strong></a></p><blockquote><p>其中一个资源是<a href="https://stackoverflow.com/" target="_blank" rel="noopener"><strong>Stack Overflow</strong></a>，你可以在这里提问；</p><p>另一个就是语言参考文档： <strong><a href="https://cppreference.com/" target="_blank" rel="noopener">cppreference</a></strong>；</p></blockquote><h2 id="S-4-5-枚举类型"><a href="#S-4-5-枚举类型" class="headerlink" title="S.4.5 枚举类型"></a>S.4.5 枚举类型</h2><p>c++包含允许程序员创建自己的数据类型的功能。这些数据类型称为<strong>用户定义的数据类型</strong>。</p><p><strong>枚举类型</strong>(也称为<strong>enumeration</strong>或<strong>enum</strong>)是一种数据类型，其中每个可能的值都被定义为<strong>符号常量</strong>(称为<strong>enumerator(枚举器)</strong>)。枚举是通过enum关键字定义的。让我们来看一个例子:</p><blockquote><p>注意，每个枚举数由<strong>逗号</strong>分隔，整个枚举以<strong>分号</strong>结束。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Define a new enumeration named Color</span></span><br><span class="line"><span class="keyword">enum</span> Color</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Here are the enumerators</span></span><br><span class="line">    <span class="comment">// These define all the possible values this type can hold</span></span><br><span class="line">    <span class="comment">// Each enumerator is separated by a comma, not a semicolon</span></span><br><span class="line">    COLOR_BLACK,</span><br><span class="line">    COLOR_RED,</span><br><span class="line">    COLOR_BLUE,</span><br><span class="line">    COLOR_GREEN,</span><br><span class="line">    COLOR_WHITE,</span><br><span class="line">    COLOR_CYAN,</span><br><span class="line">    COLOR_YELLOW,</span><br><span class="line">    COLOR_MAGENTA, <span class="comment">// see note about trailing comma on the last enumerator below</span></span><br><span class="line">&#125;; <span class="comment">// however the enum itself must end with a semicolon</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Define a few variables of enumerated type Color</span></span><br><span class="line">Color paint = COLOR_WHITE;</span><br><span class="line"><span class="function">Color <span class="title">house</span><span class="params">(COLOR_BLUE)</span></span>;</span><br><span class="line">Color apple &#123; COLOR_RED &#125;;</span><br></pre></td></tr></table></figure><p><strong>定义一个枚举类型(也可以说，定义一个用户自定义类型)时，是不会给它分配内存的</strong>；只有当<strong>定义了枚举类型的变量</strong>(如上面示例中的变量paint)时，才会为<strong>该变量</strong>分配内存。</p><blockquote><p>在c++ 11之前，不允许在最后一个枚举数之后使用逗号(例如，在COLOR_MAGENTA之后)(尽管许多编译器都接受了逗号)。但是，从c++ 11开始，允许使用逗号结尾。现在c++ 11编译器更加流行了，一般认为在最后一个元素后面使用逗号是可以接受的。</p></blockquote><h3 id="枚举的命名和枚举器"><a href="#枚举的命名和枚举器" class="headerlink" title="枚举的命名和枚举器"></a>枚举的命名和枚举器</h3><p><strong>枚举的命名是可选的</strong>，通常，没有名字的枚举有时被称为<strong>匿名枚举</strong>。枚举的名字通常以大写字母开头。</p><p><strong>枚举器(枚举常量)</strong>是必须要给出名字的。它的名字通常是大写字母(如，COLOR_WHITE)，或者以大写字母K为前缀(如， kColorWhite)</p><h3 id="枚举常量的范围"><a href="#枚举常量的范围" class="headerlink" title="枚举常量的范围"></a>枚举常量的范围</h3><p>因为枚举常量被放在与枚举相同的命名空间中，所以，枚举常量名字不能用于同一命名空间内的多个枚举:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color</span><br><span class="line">&#123;</span><br><span class="line">RED,</span><br><span class="line">BLUE, <span class="comment">// BLUE is put into the global namespace</span></span><br><span class="line">GREEN</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">enum</span> Feeling</span><br><span class="line">&#123;</span><br><span class="line">HAPPY,</span><br><span class="line">TIRED,</span><br><span class="line">BLUE <span class="comment">// error, BLUE was already used in enum Color in the global namespace</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="枚举常量的值"><a href="#枚举常量的值" class="headerlink" title="枚举常量的值"></a>枚举常量的值</h3><p>每个枚举器根据其在枚举列表中的位置自动分配一个整数值。<strong>默认情况下，第一个枚举数被赋值为整数值0，随后的每个枚举数的值都比前一个枚举数大1:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color</span><br><span class="line">&#123;</span><br><span class="line">    COLOR_BLACK, <span class="comment">// assigned 0</span></span><br><span class="line">    COLOR_RED, <span class="comment">// assigned 1</span></span><br><span class="line">    COLOR_BLUE, <span class="comment">// assigned 2</span></span><br><span class="line">    COLOR_GREEN, <span class="comment">// assigned 3</span></span><br><span class="line">    COLOR_WHITE, <span class="comment">// assigned 4</span></span><br><span class="line">    COLOR_CYAN, <span class="comment">// assigned 5</span></span><br><span class="line">    COLOR_YELLOW, <span class="comment">// assigned 6</span></span><br><span class="line">    COLOR_MAGENTA <span class="comment">// assigned 7</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">Color <span class="title">paint</span><span class="params">(COLOR_WHITE)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; paint;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********结果*********/</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><hr><p><strong>你也可以显式定义枚举数的值</strong>。</p><blockquote><p>这些整数值可以是正的，也可以是负的，并且可以与其他枚举数共享相同的值。任何未定义的枚举数都被赋予一个比前一个枚举数大1的值。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define a new enum named Animal</span></span><br><span class="line"><span class="keyword">enum</span> Animal</span><br><span class="line">&#123;</span><br><span class="line">    ANIMAL_CAT = <span class="number">-3</span>,</span><br><span class="line">    ANIMAL_DOG, <span class="comment">// assigned -2</span></span><br><span class="line">    ANIMAL_PIG, <span class="comment">// assigned -1</span></span><br><span class="line">    ANIMAL_HORSE = <span class="number">5</span>,</span><br><span class="line">    ANIMAL_GIRAFFE = <span class="number">5</span>, <span class="comment">// shares same value as ANIMAL_HORSE</span></span><br><span class="line">    ANIMAL_CHICKEN <span class="comment">// assigned 6</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>注意到：<code>ANIMAL_HORSE</code>和<code>ANIMAL_GIRAFFE</code>的值相同。这表示他们两个可以互换。即，它俩没区别。</p><p>虽然，C++允许这样，但是不建议将枚举常量赋值位相同的值。</p></blockquote><h3 id="枚举类型的input-output"><a href="#枚举类型的input-output" class="headerlink" title="枚举类型的input/output"></a>枚举类型的input/output</h3><p>因为枚举值是整数类型的，所以它们可以被赋值给整型变量。这意味着它们可以 以integers形式被output，因为<code>std::cout</code>知道如何输出整数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mypet = ANIMAL_PIG;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ANIMAL_PIG;<span class="comment">//evaluates to integer before being passed to std::cout</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******结果*****/</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><hr><ul><li><p><strong>编译器不会隐式的将整型转变为枚举类型值。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="number">5</span>; <span class="comment">// will cause compiler error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但是我们可以使用 static_cast 来强制转换</span></span><br><span class="line">Color color = <span class="keyword">static_cast</span>&lt;Color&gt;(<span class="number">5</span>); <span class="comment">// ugly</span></span><br></pre></td></tr></table></figure></li><li><p><strong>编译器也不会让你输入一个枚举类型：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color</span><br><span class="line">&#123;</span><br><span class="line">    COLOR_BLACK, <span class="comment">// assigned 0</span></span><br><span class="line">    COLOR_RED, <span class="comment">// assigned 1</span></span><br><span class="line">    COLOR_BLUE, <span class="comment">// assigned 2</span></span><br><span class="line">    COLOR_GREEN, <span class="comment">// assigned 3</span></span><br><span class="line">    COLOR_WHITE, <span class="comment">// assigned 4</span></span><br><span class="line">    COLOR_CYAN, <span class="comment">// assigned 5</span></span><br><span class="line">    COLOR_YELLOW, <span class="comment">// assigned 6</span></span><br><span class="line">    COLOR_MAGENTA <span class="comment">// assigned 7</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Color color;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; color; <span class="comment">// will cause compiler error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但是，我们可以通过读取一个整型，并使用static_cast来强制编译器将整型值放入枚举类型中：</span></span><br><span class="line"><span class="keyword">int</span> inputColor;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt; inpitColor;</span><br><span class="line"></span><br><span class="line">Color color&#123; <span class="keyword">static_cast</span>&lt;Color&gt;(inputColor) &#125;;</span><br></pre></td></tr></table></figure></li><li><p>每个枚举类型都被认为是不同的类型。因此，试图将枚举数从一个枚举类型分配到另一个枚举类型将导致编译错误:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal animal&#123; COLOR_BLUE &#125;; <span class="comment">// will cause compiler error</span></span><br></pre></td></tr></table></figure></li><li><p><strong>如果您想为枚举器使用不同的整数类型</strong>，你可以您可以在enum声明中指定它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use an 8 bit unsigned integer as the enum base.</span></span><br><span class="line"><span class="keyword">enum</span> Color : <span class="built_in">std</span>::<span class="keyword">uint_least8_t</span></span><br><span class="line">&#123;</span><br><span class="line">    COLOR_BLACK,</span><br><span class="line">    COLOR_RED,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>枚举类型的提前声明</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color; <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">enum</span> Color : <span class="keyword">int</span>; <span class="comment">// Okay</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Because Color was forward declared with a fixed base, we</span></span><br><span class="line"><span class="comment">// need to specify the base again at the definition.</span></span><br><span class="line"><span class="keyword">enum</span> Color : <span class="keyword">int</span></span><br><span class="line">&#123;</span><br><span class="line">    COLOR_BLACK,</span><br><span class="line">    COLOR_RED,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Enum分配和提前声明"><a href="#Enum分配和提前声明" class="headerlink" title="Enum分配和提前声明"></a>Enum分配和提前声明</h3><p>Enum类型被认为是整数类型家族的一部分，它由编译器决定为Enum变量分配多少内存。c++标准要求枚举的大小必须足够大，以表示所有枚举值。通常，它会使<strong>enum变量的大小与标准int相同</strong>。</p><hr><p>因为编译器知道给枚举类型分配多少内存，<strong>所以您只能在指定固定基数时，才可以提前声明它们</strong>。</p><h3 id="枚举器有什么用"><a href="#枚举器有什么用" class="headerlink" title="枚举器有什么用?"></a>枚举器有什么用?</h3><p>当需要表示特定的预定义状态集时，枚举类型对于代码文档和可读性非常有用。</p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readFileContents</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!openFile())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!readFile())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">if</span> (!parseFile())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// success</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>负数用来表示不同的可能的错误代码</strong>。如上面：<code>-1</code> <code>-2</code> <code>-3</code></p></blockquote><p>然而，使用像这样的神奇数字并不是很有描述性。<strong>另一种方法是使用枚举类型</strong>：</p><blockquote><p>这种方法可读性更强。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> ParseResult</span><br><span class="line">&#123;</span><br><span class="line">    SUCCESS = <span class="number">0</span>,</span><br><span class="line">    ERROR_OPENING_FILE = <span class="number">-1</span>,</span><br><span class="line">    ERROR_READING_FILE = <span class="number">-2</span>,</span><br><span class="line">    ERROR_PARSING_FILE = <span class="number">-3</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">ParseResult <span class="title">readFileContents</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!openFile())</span><br><span class="line">        <span class="keyword">return</span> ERROR_OPENING_FILE;</span><br><span class="line">    <span class="keyword">if</span> (!readFile())</span><br><span class="line">        <span class="keyword">return</span> ERROR_READING_FILE;</span><br><span class="line">    <span class="keyword">if</span> (!parsefile())</span><br><span class="line">        <span class="keyword">return</span> ERROR_PARSING_FILE;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用者可以根据适当的枚举器测试函数的返回值，这比测试特定整数值的返回结果更容易理解。</p><p>如：</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (readFileContents() == SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// print error message</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></blockquote><hr><p>许多语言使用枚举定义布尔值。布尔值本质上就是一个有两个枚举器的枚举:false和true!然而，在c++中，true和false被定义为关键字，而不是枚举数。</p><h2 id="S-4-6-枚举类"><a href="#S-4-6-枚举类" class="headerlink" title="S.4.6 枚举类"></a>S.4.6 枚举类</h2><p>C++11定义了一个新概念，<strong>enum class(枚举类)</strong>，也称 <strong>scoped enumeration（作用域枚举）</strong>。我们在enum之后使用<strong>关键字 <code>class</code></strong>来构造枚举类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> // "<span class="title">enum</span> <span class="title">class</span>" <span class="title">defines</span> <span class="title">this</span> <span class="title">as</span> <span class="title">a</span> <span class="title">scoped</span> <span class="title">enumeration</span> <span class="title">instead</span> <span class="title">of</span> <span class="title">a</span> <span class="title">standard</span> <span class="title">enumeration</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        red, <span class="comment">// red is inside the scope of Color</span></span><br><span class="line">        blue</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        banana, <span class="comment">// banana is inside the scope of Fruit</span></span><br><span class="line">        apple</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    Color color&#123; Color::red &#125;; <span class="comment">// note: red is not directly accessible any more, we have to use Color::red</span></span><br><span class="line">    Fruit fruit&#123; Fruit::banana &#125;; <span class="comment">// note: banana is not directly accessible any more, we have to use Fruit::banana</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (color == fruit) <span class="comment">// compile error here, as the compiler doesn't know how to compare different types Color and Fruit</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"color and fruit are equal\n"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"color and fruit are not equal\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>对于正常的枚举，枚举器被放置在与枚举本身相同的范围内</strong>。所以，我们可以直接访问枚举器(枚举常量). (e.g. red).</p><blockquote><p>因为枚举器是enum类的一部分，所以不需要在枚举器名称前面加上前缀(例如，可以使用red而不是COLOR_red，因为Color::COLOR_red是多余的)。</p></blockquote></li><li><p>但是，<strong>在枚举类中，严格的范围规则意味着所有的枚举器(枚举常量)是枚举的一部分。</strong>所以，我们必须使用必须使用范围限定符来访问枚举器(例如，Color::red)。</p><blockquote><p>这有助于降低名称污染和名称冲突的可能性。</p></blockquote><blockquote><p>强类型规则意味着每个enum类都被认为是唯一的类型。这意味着编译器不会隐式地比较来自不同枚举的枚举数。如果尝试这样做，编译器将抛出一个错误，如上面的示例所示。</p></blockquote></li></ul><hr><p>然而，你仍然可以<strong>在同一枚举类 内部进行 枚举常量的比较</strong>(因为让门属于同一类型)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        red,</span><br><span class="line">        blue</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    Color color&#123; Color::red &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (color == Color::red) <span class="comment">// this is okay(这样是可以的)</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The color is red!\n"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (color == Color::blue)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The color is blue!\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用enum类，编译器将不再隐式地将枚举数值转换为整数。</strong>这基本上是一件好事。但是，在某些情况下，这样做是有用的。在这些情况下，<strong>可以使用static_cast将enum类枚举数显式转换为整数:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        red,</span><br><span class="line">        blue</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    Color color&#123; Color::blue &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; color; <span class="comment">// won't work, because there's no implicit conversion to int</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(color); <span class="comment">// will print 1</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【note】万一你遇到它，“<strong>enum struct</strong>”相当于“<strong>enum class</strong>”。但这种用法不推荐，也不常用。</p><h2 id="S-4-7-struct"><a href="#S-4-7-struct" class="headerlink" title="S.4.7 struct"></a>S.4.7 <code>struct</code></h2><p>c++允许我们创建自己的用户定义的<strong>aggregate data types(聚集数据类型)</strong>。</p><blockquote><p><strong>聚集数据类型：是将多个单独变量分组在一起的数据类型</strong></p></blockquote><p><strong><code>struct</code></strong>就是聚集数据类型的最简单之一。</p><h3 id="struct的定义-amp-声明"><a href="#struct的定义-amp-声明" class="headerlink" title="struct的定义&amp;声明"></a>struct的定义&amp;声明</h3><p>因为structs是用户自定义的，所以我们首先要在使用它之前，必须要告诉编译器我们的struct是什么样的。</p><blockquote><p>我们使用<code>struct</code>关键字声明结构体。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//告诉编译器我们定义了一个结构体，名为Employee</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    short id;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> wage;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//这些结构中的变量称为  **成员(或字段)**。</span></span><br></pre></td></tr></table></figure><blockquote><p>记住，<strong>上面的<code>Employee</code>只是一个声明</strong>。<strong>尽管我们告诉编译器结构体将有成员变量，但此时没有分配内存</strong>。按照惯例，结构名以大写字母开头，以便与变量名区分开来。</p></blockquote><hr><ul><li><p>为了使用Employee结构，我们只需声明一个类型为Employee的变量:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employee joe; <span class="comment">// struct Employee is capitalized, variable joe is not</span></span><br></pre></td></tr></table></figure><blockquote><p>这<strong>定义</strong>了一个名为joe的Employee类型的变量。与普通变量一样，定义结构变量为该变量分配内存。</p></blockquote></li></ul><h3 id="访问结构体成员"><a href="#访问结构体成员" class="headerlink" title="访问结构体成员"></a>访问结构体成员</h3><p>当我们定义一个变量如<code>Employee joe</code>时，joe引用整个结构(包含成员变量)。为了访问各个成员，我们使用<strong>member selection operator(成员选择操作符)</strong>。下面是一个使用成员选择操作符初始化每个成员变量的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Employee joe; <span class="comment">// create an Employee struct for Joe</span></span><br><span class="line">joe.id = <span class="number">14</span>; <span class="comment">// assign a value to member id within struct joe</span></span><br><span class="line">joe.age = <span class="number">32</span>; <span class="comment">// assign a value to member age within struct joe</span></span><br><span class="line">joe.wage = <span class="number">24.15</span>; <span class="comment">// assign a value to member wage within struct joe</span></span><br><span class="line"> </span><br><span class="line">Employee frank; <span class="comment">// create an Employee struct for Frank</span></span><br><span class="line">frank.id = <span class="number">15</span>; <span class="comment">// assign a value to member id within struct frank</span></span><br><span class="line">frank.age = <span class="number">28</span>; <span class="comment">// assign a value to member age within struct frank</span></span><br><span class="line">frank.wage = <span class="number">18.27</span>; <span class="comment">// assign a value to member wage within struct frank</span></span><br></pre></td></tr></table></figure><blockquote><p>与普通变量一样，结构成员变量没有初始化，通常会包含垃圾。我们必须手动初始化它们。</p></blockquote><ul><li><p>Struct成员变量的作用就像普通变量一样，所以可以对它们进行普通操作:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> totalAge&#123; joe.age + frank.age &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (joe.wage &gt; frank.wage)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Joe makes more than Frank\n"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (joe.wage &lt; frank.wage)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Joe makes less than Frank\n"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Joe and Frank make the same amount\n"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Frank got a promotion</span></span><br><span class="line">frank.wage += <span class="number">2.50</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Today is Joe's birthday</span></span><br><span class="line">++joe.age; <span class="comment">// use pre-increment to increment Joe's age by 1</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="初始化结构体"><a href="#初始化结构体" class="headerlink" title="初始化结构体"></a>初始化结构体</h3><p>通过逐个成员分配值来初始化结构有点麻烦，因此，c++支持使用<strong>initializer list(初始化列表)</strong>来初始化结构体的更快方法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    short id;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> wage;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Employee joe&#123; <span class="number">1</span>, <span class="number">32</span>, <span class="number">60000.0</span> &#125;; <span class="comment">// joe.id = 1, joe.age = 32, joe.wage = 60000.0</span></span><br><span class="line">Employee frank&#123; <span class="number">2</span>, <span class="number">28</span> &#125;; <span class="comment">// frank.id = 2, frank.age = 28, frank.wage = 0.0 (default initialization)</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>在C++11/14中: Non-static member initialization</strong></p><p>从c++ 11开始，可以给非静态(普通)结构成员一个默认值:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> length&#123; <span class="number">1.0</span> &#125;;</span><br><span class="line">    <span class="keyword">double</span> <span class="built_in">width</span>&#123; <span class="number">1.0</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rectangle x; <span class="comment">// length = 1.0, width = 1.0</span></span><br><span class="line"> </span><br><span class="line">    x.length = <span class="number">2.0</span>; <span class="comment">// you can assign other values like normal</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不幸的是，在c++ 11中，<strong>非静态成员初始化语法</strong>与<strong>初始化列表</strong>和<strong>统一的初始化语法</strong>不兼容。例如，在c++ 11中，以下程序无法编译:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">double</span> length&#123; <span class="number">1.0</span> &#125;; <span class="comment">// non-static member initialization</span></span><br><span class="line"><span class="keyword">double</span> <span class="built_in">width</span>&#123; <span class="number">1.0</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Rectangle x&#123; <span class="number">2.0</span>, <span class="number">2.0</span> &#125;; <span class="comment">// uniform initialization/initializer list【推荐】</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>因此，<strong>在c++ 11中</strong>，您必须决定是使用非静态成员初始化还是使用统一初始化。<strong>统一初始化更加灵活，因此我们建议坚持使用这种方法</strong>。</p><p>然而，<strong>在c++ 14中</strong>，这个限制被取消了，两者都可以使用。如果两者都提供了，则优先使用<strong>初始化列表/统一初始化语法（即：initializer list）</strong>。</p><blockquote><p>在上面的例子中，矩形x的length和width将用2.0进行初始化。</p><p><em>在c++ 14中，两者都使用应该是首选的，因为它允许您声明具有或不具有初始化参数的结构，并确保成员已初始化</em></p></blockquote></li></ul><h3 id="对结构体赋值"><a href="#对结构体赋值" class="headerlink" title="对结构体赋值"></a>对结构体赋值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    short id;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> wage;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Employee joe;</span><br><span class="line">joe = &#123; <span class="number">1</span>, <span class="number">32</span>, <span class="number">60000.0</span> &#125;; <span class="comment">// C++11 only(只在C++11中可以使用)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在C++11之前</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    short id;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> wage;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Employee joe;</span><br><span class="line">joe.id = <span class="number">1</span>;</span><br><span class="line">joe.age = <span class="number">32</span>;</span><br><span class="line">joe.wage = <span class="number">60000.0</span>;</span><br></pre></td></tr></table></figure><h3 id="结构体与函数"><a href="#结构体与函数" class="headerlink" title="结构体与函数"></a>结构体与函数</h3><p>与单个变量相比，使用struct的一大好处是，我们可以将整个struct传递给一个需要与成员协同工作的函数:</p><blockquote><p>这避免了我们必须单独传递每个变量。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    short id;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> wage;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printInformation</span><span class="params">(Employee employee)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ID:   "</span> &lt;&lt; employee.id &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Age:  "</span> &lt;&lt; employee.age &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Wage: "</span> &lt;&lt; employee.wage &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Employee joe &#123; <span class="number">14</span>, <span class="number">32</span>, <span class="number">24.15</span> &#125;;</span><br><span class="line">    Employee frank &#123; <span class="number">15</span>, <span class="number">28</span>, <span class="number">18.27</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Print Joe's information</span></span><br><span class="line">    printInformation(joe);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Print Frank's information</span></span><br><span class="line">    printInformation(frank);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******结果*********/</span></span><br><span class="line">ID:   <span class="number">14</span></span><br><span class="line">Age:  <span class="number">32</span></span><br><span class="line">Wage: <span class="number">24.15</span></span><br><span class="line"></span><br><span class="line">ID:   <span class="number">15</span></span><br><span class="line">Age:  <span class="number">28</span></span><br><span class="line">Wage: <span class="number">18.27</span></span><br></pre></td></tr></table></figure><blockquote><p>我们将整个Employee结构传递给<code>printInformation()</code> (通过值传递，这意味着实参<u>被复制</u>到形参中)。</p></blockquote><ul><li><p><strong>函数的返回可以是一个结构体：</strong></p><blockquote><p>一个函数也可以返回一个结构体，<strong>这是使一个函数返回多个变量的几种方法之一</strong>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point3d</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    <span class="keyword">double</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">Point3d <span class="title">getZeroPoint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// We can create a variable and return the variable.</span></span><br><span class="line">    Point3d temp &#123; <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Point3d <span class="title">getZeroPoint2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// We can return directly. We already specified the type</span></span><br><span class="line">    <span class="comment">// at the function declaration (Point3d), so we don't need</span></span><br><span class="line">    <span class="comment">// it again here.</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Point3d <span class="title">getZeroPoint3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// We can use empty curly braces to zero-initialize all</span></span><br><span class="line">    <span class="comment">// members of `Point3d`.</span></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point3d zero&#123; getZeroPoint() &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (zero.x == <span class="number">0.0</span> &amp;&amp; zero.y == <span class="number">0.0</span> &amp;&amp; zero.z == <span class="number">0.0</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The point is zero\n"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The point is not zero\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="结构体嵌套"><a href="#结构体嵌套" class="headerlink" title="结构体嵌套"></a>结构体嵌套</h3><p>结构体可以包含其他结构体。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    short id;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> wage;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Company</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Employee CEO; <span class="comment">// Employee is a struct within the Company struct</span></span><br><span class="line">    <span class="keyword">int</span> numberOfEmployees;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Company myCompany;</span><br><span class="line"><span class="comment">//我们可以使用初始化列表初始化它们：</span></span><br><span class="line"><span class="comment">//Company myCompany&#123;&#123; 1, 42, 60000.0 &#125;, 5 &#125;;</span></span><br></pre></td></tr></table></figure><h3 id="结构体的大小"><a href="#结构体的大小" class="headerlink" title="结构体的大小"></a>结构体的大小</h3><ul><li><p>结构体的大小是所有成员大小的总和，但这不是一定的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    short id;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> wage;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The size of Employee is "</span> &lt;&lt; <span class="keyword">sizeof</span>(Employee) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******结果*************/</span></span><br><span class="line">The <span class="built_in">size</span> of Employee is <span class="number">16</span></span><br></pre></td></tr></table></figure><blockquote><p>结果是，<strong>我们只能说结构体的大小至少与它所包含的所有变量的大小一样大</strong>。<strong>但它可以更大!</strong> <u>出于性能原因，编译器有时会在结构中添加空白(这称为<strong>padding(填充)</strong>)。</u></p></blockquote><p>事实上，上面程序中的<code>Employee</code>结构体中，编译器在成员<code>id</code>的后面添加了2个字节的填充(这是不可见的)。所以才导结构的大小为16字节，而不是14字节。</p></li></ul><p>本课介绍的结构有时被称为<strong>plain old data structs(普通旧数据结构)</strong>(或<strong>POD结构</strong>)，因为成员都是数据(变量)成员。将来(当我们讨论类时)，我们将讨论其他类型的成员</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;p center large&gt;&lt;red&gt;LearnCpp chapterP&lt;/red&gt;&lt;/p&gt;&lt;/center&gt;&lt;center&gt;&lt;red&gt;https://www.learncpp.com&lt;/red&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C/C++" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"/>
    
    
      <category term="C/C++" scheme="https://longlongqin.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>【转】Github下载提速</title>
    <link href="https://longlongqin.github.io/archives/260c7660.html"/>
    <id>https://longlongqin.github.io/archives/260c7660.html</id>
    <published>2020-04-13T15:21:08.000Z</published>
    <updated>2020-04-19T14:38:29.546Z</updated>
    
    <content type="html"><![CDATA[<center><p center large><red>Github克隆&下载提速</red></p></center><p>以上内容转载于：<a href="https://mp.weixin.qq.com/s/SYR4zvjhAH1mX9fxdp8cbA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/SYR4zvjhAH1mX9fxdp8cbA</a></p><p>原作者：codesheep</p><a id="more"></a><h1 id="一个痛点"><a href="#一个痛点" class="headerlink" title="一个痛点"></a>一个痛点</h1><p>众所周知，GitHub是一个巨大的开源宝库，以及程序员和编程爱好者的聚集地，包括我之前推荐的诸多优秀的开源项目全部都是位于GitHub上。</p><p>但是每当我们看到优秀的开源项目，准备去<strong>下（bai）载（piao）</strong>时，会发现 <code>git clone</code>的速度异常之慢！就我个人而言，在我家里200M移动宽带的环境下，我克隆开源项目就没发现速度大于过 <code>20.00KiB/s</code>的时候，这简直太难受了。</p><p>小项目倒还好，我等几分钟无所谓；一旦项目庞大起来，或者项目文件数目一多， <code>git clone</code> 大概率会失败！</p><p>当然网上常见的诸如修改hosts、代理等方式实际使用效果并不一定好，而且也不稳定。</p><hr><h1 id="“码云”是个好东西"><a href="#“码云”是个好东西" class="headerlink" title="“码云”是个好东西"></a>“码云”是个好东西</h1><p>接下来就介绍一种GitHub下载的加速方法：通过国内<strong>码云平台</strong>的转接，来完成GitHub上项目的下载加速。</p><blockquote><p>感谢公众号小伙伴ioc提供思路</p></blockquote><p><strong>（1）首先确保码云上有账户，可以正常使用，没有的可以自行注册一下。</strong></p><p><strong>（2）点击右上角新建仓库的加号 <code>+</code>，选择“从 <code>GitHub/GitLab</code>导入仓库”菜单</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LearnCpp-chapter3/640-1584014932491.jpg" alt="640-1584014932491"></p><p><strong>（3）然后填写位于 <code>GitHub</code>上你想 <code>clone</code>的仓库地址并导入</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/githubaddress.jpg" alt="img"></p><p>这一步<strong>交给码云来做</strong>速度是非常快的，一会儿功夫，码云就克隆出了一份和GitHub上一模一样的项目！</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/1640.jpg" alt="1640"></p><p><strong>（4）接下来我们通过码云上的项目地址，将项目 <code>clone</code>到本地，这时候的clone速度就很快了，几 <code>MB/s</code>的速度是没问题的，很快项目就下载下来了。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/640-1583735421332.jpg" alt="640-1583735421332"></p><p>按道理讲这时候我们的目的已经达到了，不过不要忘了，还有一件事没做。</p><hr><h1 id="重新关联远端地址"><a href="#重新关联远端地址" class="headerlink" title="重新关联远端地址"></a>重新关联远端地址</h1><p>要知道，这时候克隆到本地的项目关联的是码云Gitee的地址，已经和原来的GitHub项目<strong>完全脱离了</strong>，是另外一个<strong>副本</strong>。</p><p>在必要情况下（比如我们就是要给GitHub上的某个项目提 <code>PR</code>），我们还需要重新将我们本地的项目关联到原来的GitHub项目上去，做法如下：</p><p><strong>（1）首先找到位于本地仓库目录下的隐藏文件夹 <code>.git</code></strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/640-1583735421410.jpg" alt="640-1583735421410"></p><p><strong>（2）用文本编辑器打开 <code>.git</code>文件夹中的 <code>config</code>配置文件</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/640-1583735421407.jpg" alt="640-1583735421407"></p><p>将配置文件中的 <code>[remote&quot;origin&quot;].url</code>字段重新关联到原来位于GitHub上的GitHub项目地址</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200317025816112.png" alt="image-20200317025816112"></p><blockquote><p>当然你也可以通过命令行来修改远端地址，效果一样的</p></blockquote><p>至此大功告成，本地项目就相当于是 <code>clone</code>自GitHub，后续提代码，提 <code>PR</code>到GitHub上都没有问题。</p><p>以上内容转载于：<a href="https://mp.weixin.qq.com/s/SYR4zvjhAH1mX9fxdp8cbA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/SYR4zvjhAH1mX9fxdp8cbA</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;p center large&gt;&lt;red&gt;Github克隆&amp;下载提速&lt;/red&gt;&lt;/p&gt;&lt;/center&gt;&lt;p&gt;以上内容转载于：&lt;a href=&quot;https://mp.weixin.qq.com/s/SYR4zvjhAH1mX9fxdp8cbA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/SYR4zvjhAH1mX9fxdp8cbA&lt;/a&gt;&lt;/p&gt;&lt;p&gt;原作者：codesheep&lt;/p&gt;
    
    </summary>
    
    
      <category term="实用技巧" scheme="https://longlongqin.github.io/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="github" scheme="https://longlongqin.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>【转】配置方法集合</title>
    <link href="https://longlongqin.github.io/archives/6de95ae.html"/>
    <id>https://longlongqin.github.io/archives/6de95ae.html</id>
    <published>2020-04-13T15:21:08.000Z</published>
    <updated>2020-04-19T14:38:29.546Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><ol><li><strong>WSL 使用指南</strong>：<a href="https://zhuanlan.zhihu.com/p/36482795" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/36482795</a></li><li><strong>OpenCV安装配置</strong>： <a href="http://blog.csdn.net/poem_qianmo/article/details/19809337" target="_blank" rel="noopener">http://blog.csdn.net/poem_qianmo/article/details/19809337</a></li><li><strong>onedrive无法启动</strong>：<a href="https://blog.ooolg.com/index.php/20190121/568=568.html" target="_blank" rel="noopener">https://blog.ooolg.com/index.php/20190121/568=568.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;WSL 使用指南&lt;/strong&gt;：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/36482795&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zh
      
    
    </summary>
    
    
      <category term="配置" scheme="https://longlongqin.github.io/categories/%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="配置" scheme="https://longlongqin.github.io/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>C&amp;C++/LearnCpp-chapter6</title>
    <link href="https://longlongqin.github.io/archives/2faa8a4b.html"/>
    <id>https://longlongqin.github.io/archives/2faa8a4b.html</id>
    <published>2020-04-06T05:59:00.000Z</published>
    <updated>2020-04-19T14:38:29.547Z</updated>
    
    <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapter6</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h2 id="6-2-用户自定义namespace"><a href="#6-2-用户自定义namespace" class="headerlink" title="6.2 用户自定义namespace"></a>6.2 用户自定义namespace</h2><p>在<a href="https://www.learncpp.com/cpp-tutorial/2-9-naming-collisions-and-an-introduction-to-namespaces/" target="_blank" rel="noopener">2.9 – Naming collisions and an introduction to namespaces</a>中讲解了命名冲突和命名空间的内容。现在再次看一下<strong>命名冲突</strong>。</p><blockquote><p>下面的<code>foo.cpp</code>和<code>goo.cpp</code>两个源文件，中的函数有着不同的功能，但是它们的名字却是一样的：</p></blockquote><p><code>foo.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this dosomething() adds the value of its parameters</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dosomething</span><span class="params">(intx, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>goo.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this dosomething() subtracts the value of its parameters</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dosomething</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="comment">//forward declaration for dosomething</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; dosometing(<span class="number">4</span>, <span class="number">3</span>) &lt;&lt;<span class="string">'\n'</span>; <span class="comment">//which dosometing will we get?</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，编译器会将<code>foo.cpp</code>和<code>goo.cpp</code>都编译在同一个程序中。因为它们俩里面中的函数的名字、参数都一样，而且又在同一个范围中(global scope)，这将会造成“命名冲突”。结果就是，链接器工作时，将会发生错误：</p><p><code>goo.cpp:3: multiple definition of &quot;doSomething(int, int)&quot;; foo.cpp:3: first defined here</code></p><hr><p>一个较好的解决办法就是，将你的函数放在你自己定义的“<em><em>命名空间</em>namespace</em> **”中。</p><hr><ul><li><p><strong>定义自己的namespace</strong></p><p>C++允许我们使用关键字<em>namespace</em>来定义自己的命名空间。由用户自定义的命名空间，叫：<strong>user-defined namespaces</strong>。而 由C++提供的命名空间，如 <code>global namespace</code>；或者由库提供的，如<code>namespace std</code>；它们就不是user-defined namespaces。</p><blockquote><p><strong>命名空间的标识符</strong>通常 <strong>不大写</strong>。</p></blockquote><p>下面是对上面命名冲突的函数的改写：</p><p><code>foo.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> foo <span class="comment">//定义一个命名空间，名字为：foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//this dosomething() belongs to namespace foo</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dosomething</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>goo.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> goo  <span class="comment">//定义一个命名空间，名字为：goo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//this dosomething() belongs namespace goo</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dosomething</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dosomething</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">//提前对函数dosomething()进行声明</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;dosomething(<span class="number">4</span>, <span class="number">3</span>)&lt;&lt;<span class="string">'\n'</span>; <span class="comment">//which dosomething will we get?</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这个两个<code>dosomething()</code>函数都分别属于不同的命名空间了。让我们来运行一下。</p><p>😂，新问题又出现了：</p><blockquote><p><code>ConsoleApplication1.obj : error LNK2019: unresolved external symbol &quot;int __cdecl doSomething(int,int)&quot; (?doSomething@@YAHHH@Z) referenced in function _main</code></p></blockquote><p>在这个改版中，其实编译器是满意的(因为我们已经进行提前声明)。但是链接器找不到一个在<em>global namespace</em>中的<code>dosomething</code>的定义。</p><blockquote><p>这是因为我们虽然为两个<code>dosomething</code>分别声明在不同的命名空间，可惜的是这两个命名空间都不属于 全局命名空间 中。</p></blockquote><hr><p><strong>这里有两个解决方案：1.使用<em>scope resolution operator<em>；2.通过</em>using statements</em></strong></p><hr></li><li><p>*<em>使用范围解析操作符(::)访问名称空间 *</em></p><blockquote><p>【<strong>范围解析操作符：<em>scope resolution operator(::)</em></strong>】</p></blockquote><p>告诉编译器在特定名称空间中查找标识符的最佳方法是使用<em>scope resolution operator(::)</em></p><blockquote><p>“::”，它告诉编译器：应该在该操作符的 左操作数表示的范围中查找 操作符右边的操作数(也就是要找的标识符)</p></blockquote><p>下面是一个例子：</p><p><em>对于后面的示例，为了便于阅读，我们将把示例压缩为一个文件解决方案。</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> foo <span class="comment">// define a namespace named foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This doSomething() belongs to namespace foo</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> goo <span class="comment">// define a namespace named goo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This doSomething() belongs to namespace goo</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x - y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; foo::doSomething(<span class="number">4</span>, <span class="number">3</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// use the doSomething() that exists in namespace foo</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以注意到main函数中的这个语句：<code>std::cout &lt;&lt; foo::doSomething(4, 3) &lt;&lt; &#39;\n&#39;;</code>，就是用了“范围解析符 :: ”。</p><p>该标识符的左操作数：foo，表示命名空间的名字。右操作数表示标识符。</p><p><strong>所以，<code>foo::dosomething(4,3)</code>，就表示：调用的函数<code>dosomething()</code>是来源于命名空间foo中的。</strong></p></blockquote></li></ul><hr><center><p center large>小结</p></center><p>解决命名冲突的步骤为：</p><ol><li>为这些同名的函数，均设置自己的命名空间；</li><li>在使用这个同名函数的时候，还需要加上“范围解析符 :: ”</li></ol><hr><ul><li><p><strong>没有前缀的范围解析符</strong></p><blockquote><p><strong>格式：<code>:: 标识符</code></strong></p><p><strong>没有前缀的范围解析符，<u>就相当于它的范围是全局命名空间</u></strong>。</p></blockquote><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="comment">//this print lives in the global namespace</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"there"</span>&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> foo</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="comment">// this print lives in the foo namespace</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">foo::<span class="built_in">print</span>(); <span class="comment">// call foo::print()</span></span><br><span class="line">::<span class="built_in">print</span>(); <span class="comment">// call print() in global namespace (same as just calling print() in this case)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>允许多个命名空间块：Multiple namespace blocks allowed</strong></p><blockquote><p>在多个位置(跨多个文件，或同一文件中的多个位置)声明名称空间块是合法的。<strong><u>命名空间内的所有声明都被认为是命名空间的一部分</u>。</strong></p></blockquote><hr></li></ul><p>例子1（多文件中）：</p><p><code>circle.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(CIRCLE_H)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CIRCLE_H</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> basicMath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> pi&#123; <span class="number">3.14</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>growth.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(GROWTH_H)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GROWTH_H</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> basicMath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// the constant e is also part of namespace basicMath</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> e&#123; <span class="number">2.7</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"circle.h"</span> <span class="comment">// for basicMath::pi</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"growth.h"</span> <span class="comment">// for basicMath::e</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; basicMath::pi &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; basicMath::e &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p>3.14</p><p>2.7</p><blockquote><p>标准库充就分利用了这个特性，因为每个标准库头文件都将其声明包含在该头文件中包含的 命名空间std 块中。否则，整个标准库必须在一个头文件中定义!</p></blockquote><p><em>【note】：尽管你可以利用这个功能，将你写的函数添加到<code>std namespace</code>中，但是<code>std namespace</code>有一个规则，那就是禁止用户将自己的函数扩展到它的里面。</em></p><hr><ul><li><p>例子2</p><p>如果你将你的代码分离再多个文件中，你就必须在头文件和原文件中使用命名空间。</p><p><code>add.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(ADD_H)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD_H</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> basicMath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// function add() is part of namespace basicMath</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>add.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"add.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> basicMath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// define the function add()</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"add.h"</span> <span class="comment">// for basicMath::add()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; basicMath::add(<span class="number">4</span>, <span class="number">3</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li><p>如果在<code>add.cpp</code>中省略了<em>namespace</em>，将会导致链接器找不到<code>basicMath::add</code>。</p><p><em>因为这个源文件在缺少namespace时，对add的定义是在全局命名空间中的。</em></p></li><li><p>如果在<code>add.h</code>中省略<em>namespace</em>，将会导致在“main.cpp”中不能使用<code>basicMath::add</code></p><p><em>因为这个头文件在缺少namespace时，对add的声明是在全局命名空间中的。</em></p></li></ol></blockquote></li></ul><hr><ul><li><p><strong>嵌套命名空间</strong></p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> foo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> goo <span class="comment">// goo is a namespace inside the foo namespace</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; foo::goo::add() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>所以，当我们要调用函数<code>add</code>的时候，<strong>我们使用格式为：<code>foo::goo::add</code></strong></p></blockquote><hr><p>在C++17中，嵌套的命名空间也可以这样声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> foo::goo <span class="comment">// goo is a namespace inside the foo namespace (C++17 style)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; foo::goo::add() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>给命名空间设置别名：namespace aliases</strong></p><p>在使用嵌套的命名空间的函数或变量时，我们需要将命名空间层级都全部写完整，这样会很麻烦，如果我们给这个嵌套的命名空间起一个别名就省事多了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> foo</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">namespace</span> goo</span><br><span class="line">&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">namespace</span> boo = foo::goo; <span class="comment">// boo now refers to foo::goo</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; boo::add() &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// This is really foo::goo::add()</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// The boo alias ends here</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="6-3-局部变量"><a href="#6-3-局部变量" class="headerlink" title="6.3 局部变量"></a>6.3 局部变量</h2><p>在 <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-local-scope/" target="_blank" rel="noopener">2.4 – Introduction to local scope</a>,介绍了局部变量，它是在函数中的形参。</p><h3 id="局部变量的块范围"><a href="#局部变量的块范围" class="headerlink" title="局部变量的块范围"></a>局部变量的块范围</h3><p>标识符的范围决定了标识符在源码中可获得的区域。范围是一个“编译时间”的属性。</p><blockquote><p>局部变量的 <strong>块范围(block scope)</strong>，中的范围就是：从他们定义开始，到这个块结束 的这个范围。</p></blockquote><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i &#123;<span class="number">5</span>&#125;; <span class="comment">//i enters scope here</span></span><br><span class="line">    <span class="keyword">double</span> d &#123;<span class="number">4.0</span>&#125;; <span class="comment">// d enters scope here</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">// i and d go out of scope here</span></span><br></pre></td></tr></table></figure><p>虽然函数的形参没有被定义在函数体的内部，但是对于典型函数而言，形参可以被看成，是属于函数体块的范围内。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">//x and y enter scope here</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将x、y中较大者分配给max</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span>&#123;(x&gt;y) ? x : y&#125;; <span class="comment">//max enters scope here</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;<span class="comment">// x, y and max leave scope here</span></span><br></pre></td></tr></table></figure><hr><h3 id="同一范围内的变量名不相同"><a href="#同一范围内的变量名不相同" class="headerlink" title="同一范围内的变量名不相同"></a>同一范围内的变量名不相同</h3><p>下面的函数在编译时会出错，因为该范围内的变量名相同了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunction</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123;&#125;; <span class="comment">//编译时会出错，因为这里的x和形参x之间命名冲突了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="局部变量的自动存储期"><a href="#局部变量的自动存储期" class="headerlink" title="局部变量的自动存储期"></a>局部变量的自动存储期</h3><blockquote><p>变量的<strong>存储期(storage duration),也叫持续时长(duration)</strong>决定了什么时间以及如何创造和销毁它。通常，变量的存储器直接决定了它的<strong>“生命周期(lifetime)”</strong></p></blockquote><p>例如，局部变量的存储器，意味着它在被定义时就被创建，然后在他被定义的范围块的尾部被销毁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i &#123;<span class="number">5</span>&#125;; <span class="comment">//i created and initialized here</span></span><br><span class="line">    <span class="keyword">double</span> d &#123;<span class="number">4.0</span>&#125;; <span class="comment">//d created and initialized here</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// i and d are destoryed here</span></span><br></pre></td></tr></table></figure><p>由于这个原因，局部变量 有时也被称为：<strong>自动变量</strong></p><hr><h3 id="嵌套快中的局部变量"><a href="#嵌套快中的局部变量" class="headerlink" title="嵌套快中的局部变量"></a>嵌套快中的局部变量</h3><p>局部变量可以被定义在嵌套块中，这和在函数体块中的局部变量工作流程相同：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> <span class="comment">//外部块</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123;<span class="number">5</span>&#125;; <span class="comment">//x enters scope and is created here</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//嵌套块</span></span><br><span class="line">        <span class="keyword">int</span> y &#123;<span class="number">7</span>&#125;; <span class="comment">//y enters scope and is created here</span></span><br><span class="line">    &#125; <span class="comment">// y goes out of scope and is destroyed here</span></span><br><span class="line">    <span class="comment">//此时，y就不能再被用了，因为它不属于现在所在的范围</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// x goes out of scope and is destoryed here</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：<strong>变量x的范围是整个mian函数块中，自然，在嵌套块中，变量x也是有效的</strong>，即也可以访问它。</p></blockquote><hr><h3 id="局部变量的无连接"><a href="#局部变量的无连接" class="headerlink" title="局部变量的无连接"></a>局部变量的无连接</h3><p>标识符的另一个属性就是：<strong>“连接(linkage)”</strong>。一个标识符的<em>linkage</em>决定了该标识符的其他声明是否引用的是相同的对象。</p><blockquote><p><strong>局部变量没有<em>关联性</em>，也就是说对一个标识符的每一个声明都代表不同的对象</strong></p></blockquote><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x &#123;<span class="number">2</span>&#125;; <span class="comment">// local variable, no linkage</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x &#123;<span class="number">3</span>&#125;; <span class="comment">//这个标识符x与上面的标识符x，表示的是不同对象(尽管他们名字相同)</span></span><br><span class="line">        <span class="comment">//但是现在嵌套外部的变量x被隐藏起来了(在6.5节会讲到变量隐藏)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="变量定义的范围"><a href="#变量定义的范围" class="headerlink" title="变量定义的范围"></a>变量定义的范围</h3><p>如果一个变量仅在嵌套块中使用，那它就应该旨在嵌套块中被定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//don't define y here</span></span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//y只在这个块中被使用，所以在这里定义它</span></span><br><span class="line">        <span class="keyword">int</span> y&#123;<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;y&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>所以，我们尽量把变量定义在，使用它的范围内部</strong>。</p></blockquote><hr><h2 id="6-4-全局变量"><a href="#6-4-全局变量" class="headerlink" title="6.4 全局变量"></a>6.4 全局变量</h2><h3 id="全局变量的声明"><a href="#全局变量的声明" class="headerlink" title="全局变量的声明"></a>全局变量的声明</h3><p>通常，全局变量声明是在：<strong>头文件的下面，在其他代码的上面</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在函数外面声明的变量是全局变量</span></span><br><span class="line"><span class="keyword">int</span> g_x &#123;&#125;; <span class="comment">// global variable g_x</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// global variables can be seen and used everywhere in the file</span></span><br><span class="line">    g_x = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// global variables can be seen and used everywhere in the file</span></span><br><span class="line">    g_x = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// g_x goes out of scope here</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果*****/</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><blockquote><p>按照惯例， 在全局变量名字加上前缀“g”或者“g_”，来便于是显示的说明它是 全局变量</p></blockquote><hr><h3 id="全局变量的file-scope-amp-静态持续时间"><a href="#全局变量的file-scope-amp-静态持续时间" class="headerlink" title="全局变量的file scope&amp;静态持续时间"></a>全局变量的file scope&amp;静态持续时间</h3><blockquote><p>file scope也叫：<strong>全局范围(global scope)</strong>或者<strong>全局命名空间范围(global namespace scope)</strong></p><blockquote><p>因为全局变量是在函数外部定义的，所以也被视为“全局命名空间(global namespace)”的一部分。所以，才有<em>global namespace scope</em>这个叫法。</p></blockquote></blockquote><p>也就是说，它们从被定义开始，到所在文件的结束期间 都是有效的。</p><hr><p>全局变量在程序开始被创建，在程序结束时被销毁。这成为“<strong>静态持续时间(static duration)</strong>”</p><blockquote><p>有着‘static duration’的变量，也被称为：“<strong>静态变量(static variable)</strong>”</p></blockquote><hr><p><u><strong>局部变量默认是不被初始化的，全局变量默认是被初始化为0的</strong></u></p><ul><li><p><strong>全局变量的初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g_x; <span class="comment">//没有显示的初始化变量(所以默认初始化为0)</span></span><br><span class="line"><span class="keyword">int</span> g_y&#123;&#125;; <span class="comment">//初始化为0</span></span><br><span class="line"><span class="keyword">int</span> g_z&#123;<span class="number">3</span>&#125;; <span class="comment">//显示的初始化为3</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="常量局部变量"><a href="#常量局部变量" class="headerlink" title="常量局部变量"></a>常量局部变量</h3><p>与局部变量一样，全局变量也可以是常量。只要是常量，那它就必须被初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_x; <span class="comment">//error:常量型的变量必须要被初始化</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> g_w; <span class="comment">//error:常量型的变量必须要被初始化（constexpr，表示它是 编译时常量）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_y &#123;<span class="number">1</span>&#125;; <span class="comment">//正确，初始化了</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> g_z &#123;<span class="number">2</span>&#125;; <span class="comment">//正确，初始化了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dosomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//全局变量在这个文件中的每一个地方都是有效的(可以被看见和使用)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_z &lt;&lt; <span class="string">'\n'</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dosomething();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//全局变量在这个文件中的每一个地方都是有效的(可以被看见和使用)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_z &lt;&lt; <span class="string">'\n'</span>;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// g_y and g_z goes out of scope here</span></span><br></pre></td></tr></table></figure><hr><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Non-constant global variables(非常量的全局变量)</span></span><br><span class="line"><span class="keyword">int</span> g_x;                 <span class="comment">// defines non-initialized global variable (zero initialized by default)</span></span><br><span class="line"><span class="keyword">int</span> g_x &#123;&#125;;              <span class="comment">// defines explicitly zero-initialized global variable</span></span><br><span class="line"><span class="keyword">int</span> g_x &#123; <span class="number">1</span> &#125;;           <span class="comment">// defines explicitly initialized global variable</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Const global variables</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_y;           <span class="comment">// error: const variables must be initialized</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_y &#123; <span class="number">2</span> &#125;;     <span class="comment">// defines initialized global constant</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Constexpr global variables</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> g_y;       <span class="comment">// error: constexpr variables must be initialized</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> g_y &#123; <span class="number">3</span> &#125;; <span class="comment">// defines initialized global const</span></span><br></pre></td></tr></table></figure><hr><h2 id="6-5-变量被隐藏"><a href="#6-5-变量被隐藏" class="headerlink" title="6.5 变量被隐藏"></a>6.5 变量被隐藏</h2><h3 id="局部变量被隐藏"><a href="#局部变量被隐藏" class="headerlink" title="局部变量被隐藏"></a>局部变量被隐藏</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// outer block</span></span><br><span class="line"><span class="keyword">int</span> apples &#123; <span class="number">5</span> &#125;; <span class="comment">// 嵌套外部的apples</span></span><br><span class="line">    </span><br><span class="line">    &#123;<span class="comment">// nested block</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;apples&lt;&lt;<span class="string">'\n'</span>; <span class="comment">//这里的apples是嵌套外部的</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> apples &#123;<span class="number">0</span>&#125;; <span class="comment">//在嵌套内部定义变量apples</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//现在的apples指的是嵌套内部 的apples.嵌套外部的apples现在被隐藏起来了</span></span><br><span class="line">        apples = <span class="number">10</span>; <span class="comment">//现在被赋值的apples指的是嵌套内部的apples</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; apples &lt;&lt;<span class="string">'\n'</span>'</span><br><span class="line">    &#125; <span class="comment">//嵌套块内部的apples被销毁</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;apples&lt;&lt;<span class="string">'\n'</span>; <span class="comment">//这个apples指的是嵌套外部的apples(因为现在，嵌套内部的apples已经被销毁)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125; <span class="comment">//嵌套外部的apples被销毁</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">10</span><br><span class="line">5</span><br></pre></td></tr></table></figure><hr><h3 id="全局变量被隐藏"><a href="#全局变量被隐藏" class="headerlink" title="全局变量被隐藏"></a>全局变量被隐藏</h3><p>就像局部变量中的，嵌套块中的变量可以将嵌套外部的同名变量以藏起来 一样。<strong>局部变量可以将全局中的同名变量隐藏起来:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a &#123;<span class="number">5</span>&#125;; <span class="comment">//全局变量</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"global variable a："</span>&lt;&lt;a&lt;&lt;<span class="string">'\n'</span>;<span class="comment">//此时，全局变量a还没有被隐藏。即，这里的变量a，指的是全局变量</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a &#123;<span class="number">7</span>&#125;; <span class="comment">//此时，全局变量a就被这里的局部变量a 隐藏起来了</span></span><br><span class="line">    </span><br><span class="line">    ++a; <span class="comment">//局部变量a加1，而不是全局变量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"local variable a: "</span> &lt;&lt; a &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    foo();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// 局部变量a被销毁</span></span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local variable a: 8</span><br><span class="line">global variable a: 5</span><br></pre></td></tr></table></figure><hr><p>然而啊，全局变量是属于全局的命名空间。所以，我们可以使用 <em>范围解析符(::)</em>（不带前缀的，即默认是在全局命名空间）来告诉编译器我们使用的是全局变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a &#123;<span class="number">5</span>&#125;; <span class="comment">//全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a &#123;<span class="number">7</span>&#125;; <span class="comment">//此时，将全局变量a隐藏起来了</span></span><br><span class="line">    ++a； <span class="comment">//局部变量a加1，而不是全局变量</span></span><br><span class="line">        </span><br><span class="line">    --(::a); <span class="comment">//此时是对于全局变量，减一</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"local variable a: "</span> &lt;&lt; a &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"global variable a: "</span> &lt;&lt; ::a &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;       </span><br><span class="line">&#125;<span class="comment">//local a 被销毁</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local variable a: 8</span><br><span class="line">global variable a: 4</span><br></pre></td></tr></table></figure><hr><h3 id="避免变量被隐藏"><a href="#避免变量被隐藏" class="headerlink" title="避免变量被隐藏"></a>避免变量被隐藏</h3><p>通常应该避免局部变量的隐藏，因为它会在使用或修改错误的变量时导致无意的错误。一些编译器会在变量被隐藏时发出警告。</p><hr><h2 id="6-6-内部连接"><a href="#6-6-内部连接" class="headerlink" title="6.6 内部连接"></a>6.6 内部连接</h2><p>在 <a href="https://www.learncpp.com/cpp-tutorial/local-variables/" target="_blank" rel="noopener">6.3 – Local variables</a>中，讲到：“一个标识符的连接决定了该名称的其他声明是否引用同一对象”和“局部变量的无连接”</p><p>全局变量和函数标识符有：<strong>内部链接(internal linkage)</strong>和<strong>外部链接(external linkage)</strong>。本节主要讲内部链接。</p><hr><p>一个标识若是内部连接，那它就只能在这一个文件中有效(可以被看到和使用)；而不可以在其他文件中看到和使用【<strong>也就是说，它没有暴露给链接器</strong>】。也就是说，如果有两个文件，它们分别含有一个相同名字的标识符(而且这这个同名的标识符是 内部连接)，那么这个同名的标识符就被看待成相互独立的。</p><hr><h3 id="全局变量内部连接"><a href="#全局变量内部连接" class="headerlink" title="全局变量内部连接"></a>全局变量内部连接</h3><p>全局变量是内部链接时，也被称为：<strong>内部变量(<em>internal variables</em>)</strong>。</p><blockquote><p>让 非常量的全局变量 成为内部变量，需要使用<strong>关键字<code>static</code></strong>；（因为非常量的全局变量默认是 外部链接 的）</p><p>而 常量的全局变量 <strong>默认</strong>的就是 内部变量。</p></blockquote><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> g_x; <span class="comment">//非常量的全局变量默认是 外部链接。但是加上关键字static后，就变成内部连接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_y &#123;<span class="number">1</span>&#125;; <span class="comment">//const 的全局变量默认是 内部连接</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> g_z &#123;<span class="number">2</span>&#125;; <span class="comment">//constexpr 的全局变量默认是 内部连接</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>const</code>和<code>constexpr</code>的全局变量默认是 内部连接(所以，不需要加 关键字<code>static</code>)</p></blockquote><hr><h3 id="一个定义规则和内部连接"><a href="#一个定义规则和内部连接" class="headerlink" title="一个定义规则和内部连接"></a>一个定义规则和内部连接</h3><p>还记得在 <a href="https://www.learncpp.com/cpp-tutorial/forward-declarations/" target="_blank" rel="noopener">2.7 – Forward declarations and definitions</a>,中讲到一个定义的规则：<em>在文件或程序中，*</em>一个*<em>对象或者函数只能有一个定义</em>。</p><p>然而，这一个我们却在一个程序中对一个对象或函数进行了“多次定义”，这是否违背了上面的规则呢？</p><blockquote><p>答：不违背。因为本节中我们将它们设置为内部连接，此时虽然它们的名字相同，但是相互独立（即，它们相当于不同的对象或函数，只是名字相同。就好像两个同名的人一样）。所以不违背上面的定义规则。</p></blockquote><hr><h3 id="函数内部连接"><a href="#函数内部连接" class="headerlink" title="函数内部连接"></a>函数内部连接</h3><p>因为“连接(linkage)”是标识符的属性(标识符不仅仅只代表变量(☄⊙ω⊙)☄，因为函数的名字也是标识符)。所以，函数标识符也具有 内部连接 的属性。</p><p>如：</p><p><code>add.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个函数前使用关键字static，表示它现在只在这个文件中有效</span></span><br><span class="line"><span class="comment">//如果，企图通过函数提前声明从，从另一个文件访问它，将失败</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="comment">//对函数add，提前声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序，在链接器连接时，将会出错。因为函数add在<code>main.cpp</code>中不可访问</p><hr><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Internal global variables definitions:</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> g_x;          <span class="comment">// defines non-initialized internal global variable (zero initialized by default)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> g_x&#123; <span class="number">1</span> &#125;;     <span class="comment">// defines initialized internal global variable</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_y &#123; <span class="number">2</span> &#125;;     <span class="comment">// defines initialized internal global const variable</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> g_y &#123; <span class="number">3</span> &#125;; <span class="comment">// defines initialized internal global constexpr variable</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Internal function definitions:</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;;     <span class="comment">// defines internal function</span></span><br></pre></td></tr></table></figure><hr><h2 id="6-7-外部连接"><a href="#6-7-外部连接" class="headerlink" title="6.7 外部连接"></a>6.7 外部连接</h2><p>一个标识符具有 <strong>外部连接(external linkage)</strong>的属性，那么它就可以在整个程序中(不仅仅只在一个文件中)被看见和访问。（在其他文件中，可以通过<em>提前声明</em>来访问它）</p><blockquote><p>所以，具有外部连接属性的表示符，才是真正的“全局”变量</p></blockquote><hr><h3 id="函数默认是外部链接"><a href="#函数默认是外部链接" class="headerlink" title="函数默认是外部链接"></a>函数默认是外部链接</h3><p>在 <a href="https://www.learncpp.com/cpp-tutorial/programs-with-multiple-code-files/" target="_blank" rel="noopener">2.8 – Programs with multiple code files</a>中，讲到我们可以从其他文件中调用函数，这是因为这个函数默认是“外部链接”的。</p><p>在从其他文件中调用函数时，我们必须要对这个函数进行 <strong>提前声明(forward declaration)</strong></p><blockquote><p>因为，<strong>提前声明</strong>可以告诉编译器这个函数的存在；而链接器则是将函数调用连接到实际的函数定义</p></blockquote><p>如：</p><p><code>a.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> <span class="comment">//这个函数默认是 外部连接，所以他可以在整个程序(包括其他文件)中被看见</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hi"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span></span>; <span class="comment">//对函数进行提前声明，使得该函数在这个文件中可以被访问</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sayHi(); <span class="comment">//这里是从其他文件中调用此函数，链接器将把这个调用连接到函数定义</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hi</span><br></pre></td></tr></table></figure><hr><h3 id="全局变量外部连接"><a href="#全局变量外部连接" class="headerlink" title="全局变量外部连接"></a>全局变量外部连接</h3><p>全局变量具有外部连接属性时，也称为：<strong>外部变量(external variables)</strong></p><blockquote><p>非常量的全局变量默认是 外部变量；</p><p>常量的全局变量 要想成为外部变量，需要使用<strong>关键字<code>extern</code></strong></p></blockquote><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g_x &#123;<span class="number">2</span>&#125;; <span class="comment">//非常量的全局变量默认是 外部变量；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> g_y &#123;<span class="number">3</span>&#125;;<span class="comment">//const 的全局变量可以被定义成 外部变量，需要加关键字extern</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> g_z &#123;<span class="number">3</span>&#125;; <span class="comment">//constexpr 的全局变量可以被定义成 外部变量,需要加关键字extern</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>默认情况下，非const全局变量是外部变量(如果使用，extern关键字将被忽略)。</p></blockquote><hr><h3 id="extern提前声明变量"><a href="#extern提前声明变量" class="headerlink" title="extern提前声明变量"></a><code>extern</code>提前声明变量</h3><p>要实际使用在另一个文件中定义的外部全局变量，我们需要在使用它的文件中对全局变量进行<em>提前声明</em>。对于变量，在创建一个<strong>提前声明时，也是需要使用关键字<code>extern</code>的(</strong>没有初始化值)：</p><p>如：</p><p><code>a.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量的定义</span></span><br><span class="line"><span class="keyword">int</span> g_x &#123;<span class="number">2</span>&#125;; <span class="comment">//非常量的全局变量默认是 外部链接</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> g_y &#123;<span class="number">3</span>&#125;; <span class="comment">//常量的全局变量是内部连接，但使用关键字extern后，变为 外部链接</span></span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> g_x; <span class="comment">//对变量g_x的提前声明。它的定义在其他文件中</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> g_y; <span class="comment">//对常量变量g_y的提前声明。它的定义在其他文件中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>&lt;&lt; g_x; <span class="comment">//结果为2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="函数提前声明不用extern"><a href="#函数提前声明不用extern" class="headerlink" title="函数提前声明不用extern"></a>函数提前声明不用<code>extern</code></h3><p><strong>函数的提前声明不需要关键字<code>extern</code></strong></p><blockquote><p>编译器能搞告诉你这个函数在哪定义，也可以根据是否提供函数体来进行提前声明。</p></blockquote><p><strong>变量的提前声明必须要用关键字<code>extern</code></strong>，</p><blockquote><p>来帮助区分 <strong>变量定义</strong> 和 <strong>变量提前声明</strong>(它们看起来是一样的):</p></blockquote><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非常量</span></span><br><span class="line"><span class="keyword">int</span> g_x; <span class="comment">//变量的定义(如果需要，可进行初始化)</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> g_x; <span class="comment">//变量的提前声明(提前声明  不带初始化)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> g_y &#123;<span class="number">1</span>&#125;;<span class="comment">//定义变量(常量的定义必须要进行初始化)</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> g_y; <span class="comment">//提前声明(提前声明  不带初始化)</span></span><br></pre></td></tr></table></figure><hr><h3 id="file范围VS-global范围"><a href="#file范围VS-global范围" class="headerlink" title="file范围VS.global范围"></a>file范围VS.global范围</h3><p>看下面的例子：</p><p><code>global.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g_x &#123;<span class="number">2</span>&#125;; <span class="comment">//（非常量的变量）默认是外部连接</span></span><br><span class="line"><span class="comment">//g_x goes out scope here</span></span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> g_x; <span class="comment">//对变量g_x的提前声明。可以在此文件中使用g_x</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_x; <span class="comment">//应该输出 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//g_x的提前声明 goes out of scope here</span></span><br></pre></td></tr></table></figure><blockquote><p>变量g_x的<strong>文件范围(file scope)</strong>是在<code>global.cpp</code>中。它在该文件中定义之后，就可以被使用。</p><p>但是它<strong>不能<u>直接</u>在其他文件中使用</strong>。如果要在其他文件中使用g_x，我们要在其他文件中对它进行提前声明(记得要使用关键字<code>extern</code>)</p></blockquote><hr><p>也就是说，“文件范围”通常用于具有<em>内部连接</em>属性的全局变量；“全局范围”更多用于具有<em>外部连接</em>属性的全局变量(因为，它被提前声明之后，就可以在其他地方使用)</p><hr><h3 id="全局变量初始化顺序问题"><a href="#全局变量初始化顺序问题" class="headerlink" title="全局变量初始化顺序问题"></a>全局变量初始化顺序问题</h3><p>全局变量的初始化是程序启动的一部分，在执行<code>mian</code>函数之前，这个过程分为两部分：</p><ul><li><p>第一部分，称为 <strong><em>static initialization</em>静态初始化</strong>。</p><blockquote><p>在静态初始化中，带有constexpr初始化器(包括字面值(literal))的全局变量被初始化为给定的值[因为，constexpr和字面值常量定义时自带有初始值]；</p><blockquote><p>eg,</p><p><code>const a {1};</code>那么a就被初始化为1</p><p><code>constexpr a{1};</code>那么a就被初始化为1</p></blockquote><p>定义时没有给定初始值的全局变量<strong>(也使常量的全局变量，但没有显示初始化为0)</strong>被默认初始化为0。</p><blockquote><p><code>const a {};</code>那么a就默认被初始化为0</p><p><code>constexpr a{};</code>那么a就默认被初始化为0</p></blockquote></blockquote></li><li><p>第二部分，称为 <strong><em>dynamic initialization</em>动态初始化</strong>。</p><blockquote><p>这部分，比较复杂，它的要点是：初始化那些“不带有constexpr初始化器的全局变量”(即，就是 非常量的全局变量)。</p></blockquote></li></ul><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_something &#123;init()&#125;; <span class="comment">//非常量的变量初始化</span></span><br></pre></td></tr></table></figure><blockquote><p>在单位件的程序中，全局变量按照定义的顺序被初始化</p></blockquote><p>这个规则有几个例外。考虑到这一点，<strong>您需要小心不要让变量依赖于其他变量的初始化值，这些变量要到稍后才会初始化</strong>。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initx</span><span class="params">()</span></span>;  <span class="comment">// forward declaration</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inity</span><span class="params">()</span></span>;  <span class="comment">// forward declaration</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> g_x&#123; initx() &#125;; <span class="comment">// g_x is initialized first</span></span><br><span class="line"><span class="keyword">int</span> g_y&#123; inity() &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initx</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g_y; <span class="comment">// g_y isn't initialized when this is called</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_x &lt;&lt; <span class="string">' '</span> &lt;&lt; g_y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******结果*******/</span></span><br><span class="line"><span class="number">0</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><hr><p>再多文件程序中，<strong>不同文件之间的初始化顺序是没有规定的</strong>。</p><blockquote><p>例如，有两个文件<code>a.cpp</code>和<code>b.cpp</code>，它们两个文件谁先被初始化是不确定的。</p></blockquote><p>所以，如果在<code>a.cpp</code>中有一个变量的值是依赖于<code>b.cpp</code>。那么就有50%的可能这些变量还没有被初始化。</p><hr><p>注意：C++中，全局变量的动态初始化会造成很多问题。所以避免使用。</p><hr><p>小结：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// External global variable definitions:</span></span><br><span class="line"><span class="keyword">int</span> g_x;                       <span class="comment">// defines non-initialized external global variable (zero initialized by default)</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> g_x&#123; <span class="number">1</span> &#125;;     <span class="comment">// defines initialized const external global variable</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> g_x&#123; <span class="number">2</span> &#125;; <span class="comment">// defines initialized constexpr external global variable</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Forward declarations</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> g_y;                <span class="comment">// forward declaration for non-constant global variable</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> g_y;          <span class="comment">// forward declaration for const global variable</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> g_y;      <span class="comment">// not allowed: constexpr variables can't be forward declared</span></span><br></pre></td></tr></table></figure><hr><h2 id="6-8-全局常量-amp-内联变量"><a href="#6-8-全局常量-amp-内联变量" class="headerlink" title="6.8 全局常量&amp;内联变量"></a>6.8 全局常量&amp;内联变量</h2><blockquote><p><strong>Global constants and inline variables</strong></p></blockquote><p>一些符号常量需(如，阿伏伽德罗常数，重力系数…)要在整个程序中使用。比较好的方法是在一个地方对他们进行声明，而不是在每个需要它们的文件中重新定义这些常量。</p><h3 id="全局常量作为内部变量"><a href="#全局常量作为内部变量" class="headerlink" title="全局常量作为内部变量"></a>全局常量作为内部变量</h3><p>在c++中有多种方法可以促进这一点。在c++ 17之前，以下可能是最简单和最常见的方法:</p><ol><li><p>首先，创建一个头文件来存放这些常量；</p></li><li><p>在这个头文件中，定义一个命名空间（在 <a href="https://www.learncpp.com/cpp-tutorial/user-defined-namespaces/" target="_blank" rel="noopener">6.2 – User-defined namespaces</a>讲解过命名空间）；</p></li><li><p>然后，将常量加入这个命名空间中（请确保它们的类型是<code>constexpr</code>）；</p></li><li><p>在你要用这些变量的文件中，加上这个头文件<code>#include &quot;xxx&quot;</code></p></li></ol><hr><p>eg:</p><p><code>constants.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONSTANTS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONSTANTS_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义你自己的命名空间(用来存储常量)</span></span><br><span class="line"><span class="keyword">namespace</span> constants</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//默认情况下，常量有 内部连接</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">double</span> pi &#123;<span class="number">3.14159</span>&#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">double</span> my_gravity &#123;<span class="number">9.2</span>&#125;;</span><br><span class="line">    <span class="comment">//....常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"constants.h"</span> <span class="comment">//：在这个文件中包含每个常量的副本</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"enter a radius: "</span>;</span><br><span class="line">    <span class="keyword">int</span> radius&#123;&#125;; <span class="comment">//radius：半径</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt;radius;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"the circumference is: "</span> &lt;&lt;<span class="number">2</span>* radius* constants::pi;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：在<code>main.cpp</code>文件中，要想访问<code>constants</code>中的常量，我们需要使用 <strong>范围解析符(::)</strong>。</p><p><code>a::b</code> 范围解析操作符的 左操作数a,表示命名空间名称；右操作符b表示命名空间a中的变量或者函数名字。</p><p><code>::b</code> 这种形式表示 <strong>其命名空间是全局命名空间</strong>。</p></blockquote><hr><h3 id="全局常量作为外部变量"><a href="#全局常量作为外部变量" class="headerlink" title="全局常量作为外部变量"></a>全局常量作为外部变量</h3><p>当作为内部变量时，可能会出现以下问题：</p><p>虽然这很简单(对于较小的程序也很好)，但是每当constants.h被包含到不同的代码文件中时，每个变量都会被复制到包含代码文件中。因此，如果将constants.h包含到20个不同的代码文件中，那么每个变量都会重复20次。头文件保护不会阻止这种情况的发生，因为它们只会阻止头文件不止一次被包含到一个包含文件中，而不会阻止头文件一次被包含到多个不同的代码文件中。这带来了两个挑战:</p><blockquote><p><strong>头文件保护符(header guards)</strong>只能确保在单个文件中包含的头文件只包含一次；</p></blockquote><ul><li>当修改一个常量值时，就可能需要重新编译那些包含这个常量的文件，这可能导致大型项目的重建时间很长。</li><li>如果常量的size很大，并且不能进行优化。这将花费很多内存。</li></ul><hr><p>一个解决上面的办法就是，将这些常量设为<strong>“外部变量(external variables)”</strong>。</p><blockquote><p>因此，我们可以将变量只初始化一次就可以在整个程序中使用。</p></blockquote><p><code>constants.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> constants</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//actual global variables</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">double</span> pi &#123;<span class="number">3.14159</span>&#125;;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">const</span> my_gravity &#123;<span class="number">9.2</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在<code>constants.cpp</code>文件中定义这些常量，来确保它们只被定义一次；</p></blockquote><p><code>constants.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONSTANTS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONSTANTS_H</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> constants</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// since the actual variables are inside a namespace, the forward declarations need to be inside a namespace as well</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">double</span> pi;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">double</span> avogadro;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">double</span> my_gravity;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><blockquote><p>需要在头文件<code>constants.h</code>中对这些常量进行 提前声明</p></blockquote><p><code>main.cpp</code></p><blockquote><p>使用的方法不变</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"constants.h"</span> <span class="comment">// include all the forward declarations</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a radius: "</span>;</span><br><span class="line">    <span class="keyword">int</span> radius&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; radius;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The circumference is: "</span> &lt;&lt; <span class="number">2</span> * radius * constants::pi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>因为全局符号常量在命名空间中(为了避免与全局命名空间中的标识符发生 命名冲突)，所以，就不需要在它名字中使用<code>g_</code>前缀</p></blockquote><p>现在，这些符号常量只用在<code>constants.cpp</code>中实例化一次(而不是每次constants.h被<code>#include</code>中都被实例化一次)，所以，对constants.cpp所做的任何修改都只需要重新编译constants.cpp即可。</p><p>然而，这种方法也有几个缺点。</p><ul><li><strong>首先，这些常量现在只在实际定义它们的文件(constants.cpp)中被认为是 编译时常量</strong>，<strong>而不是在其他地方使用它们</strong>。这意味着在constants.cpp之外的地方，它们不能在任何需要编译时常量的地方使用。</li><li>其次，编译器可能无法对它们进行尽可能多的优化。</li></ul><hr><h3 id="全局常量作为内联变量"><a href="#全局常量作为内联变量" class="headerlink" title="全局常量作为内联变量"></a>全局常量作为内联变量</h3><p>在C++17中，有一个新概念叫做：<strong><em>inline variable</em>(内联变量)</strong></p><blockquote><p><strong>inline</strong>意为：允许多个定义。</p></blockquote><p>所以，一个内联变量就可以在多个文件中被多次定义。(这并不违背 <strong>单定义规则</strong>)</p><blockquote><p><strong>内联全局变量</strong> 默认是 <strong>外部连接</strong></p></blockquote><hr><p>内联变量有两个重要的限制，必须遵守：</p><ul><li>内联变量的所有定义必须相同（否则，将产生未定义的行为）；</li><li>内敛变量的定义(不是提前声明)必须出现在每一个使用这些变量的文件中。</li></ul><blockquote><p>编译器将会把内联变量的所有定义合并为一个变量的定义。这就允许我们在头文件中定义变量，并将它们当作<code>a.cpp</code>文件中只有一个定义。</p><p>这些变量在它们被包含的文件中，依然保持这 constexpr 的性质</p></blockquote><p>这样，我们就可以在头文件中定义全局变量，而不用担心重复变量:</p><p><code>constants.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONSTANTS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONSTANTS_H</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// define your own namespace to hold constants</span></span><br><span class="line"><span class="keyword">namespace</span> constants</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> pi &#123; <span class="number">3.14159</span> &#125;; <span class="comment">// note: now inline constexpr</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> avogadro &#123; <span class="number">6.0221413e23</span> &#125;;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> my_gravity &#123; <span class="number">9.2</span> &#125;; <span class="comment">// m/s^2 -- gravity is light on this planet</span></span><br><span class="line">    <span class="comment">// ... other related constants</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"constants.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a radius: "</span>;</span><br><span class="line">    <span class="keyword">int</span> radius&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; radius;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The circumference is: "</span> &lt;&lt; <span class="number">2</span> * radius * constants::pi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们可以在尽可能多的代码文件中包含<code>constants.h</code>，但是这些变量只会被实例化一次，并在所有代码文件中共享。</p></blockquote><hr><p>如果你需要全局常量，并且你的编译器支持C++17，那建议最好使用 <strong>内联变量</strong></p><hr><h2 id="6-9-非常量的全局变量evil"><a href="#6-9-非常量的全局变量evil" class="headerlink" title="6.9 非常量的全局变量evil"></a>6.9 非常量的全局变量evil</h2><p>最大的问题就是：<strong>当你使用全局变量(not-const)时，它可能在任何地方就被修改，但是你却不能轻松的直到在哪被改的。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g_mode; <span class="comment">//声明全局变量(将默认被初始化为0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dosomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_mode = <span class="number">2</span>; <span class="comment">//这里修改全局变量g_mode为2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_mode =<span class="number">1</span>; <span class="comment">//note:这将全局g_mode变量设置为1。而不是声明一个本地g_mode变量!</span></span><br><span class="line">    dosomething();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//程序猿希望这里输出的g_mode的值是1，但是实际上它的值是2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(g_mode == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"no threat detected.\n"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"lanunching nuclear missiles...\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>局部变量要安全得多，因为其他函数不能直接影响它们。</strong></p></blockquote><hr><h3 id="保护你的全局变量"><a href="#保护你的全局变量" class="headerlink" title="保护你的全局变量"></a>保护你的全局变量</h3><p>如果你非要使用全局变量：</p><ul><li><strong>那我们可以对变量名使用前缀”g_”或“g”，来帮助我们识别它是全局变量。</strong></li><li>最好也将其<strong>放在你自己创建的命名空间，从而避免一些命名冲突。</strong></li></ul><hr><h2 id="6-10-静态局部变量"><a href="#6-10-静态局部变量" class="headerlink" title="6.10 静态局部变量"></a>6.10 静态局部变量</h2><p>术语<code>static</code>是c++语言中最容易混淆的术语之一，这在很大程度上是因为静态在不同的上下文中有不同的含义。</p><p>在之前的课程中，我们讨论了<strong>全局变量具有静态持续时间</strong>，<strong>这意味着它们在程序启动时创建，在程序结束时销毁。</strong></p><p>我们还讨论了<strong><code>static</code>关键字如何提供全局标识符内部链接</strong>，<strong>这意味着标识符只能在定义它的文件中使用。</strong></p><hr><p>我们将探讨<strong>应用于局部变量时静态关键字的用法</strong>。</p><p>在 <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-local-scope/" target="_blank" rel="noopener">2.4 – Introduction to local scope</a>, 您了解到，默认情况下 局部变量具有 <em>自动持续时间</em>，<strong>这意味着它们是在定义时创建的，并在块退出时销毁。</strong></p><blockquote><p>但<strong>关键字<code>static</code></strong>，可以将<strong><em>自动持续时间(attomatic duration)</em></strong>转变成 <strong><em>静态持续时间(static duration)</em></strong> 。从而，静态变量即使已经超出它所在的范围时，他依然没有被销毁。</p><blockquote><p>这意味着变量现在在程序开始时创建，并在程序结束时销毁(就像全局变量一样)。</p></blockquote></blockquote><p>例如：</p><p><em>默认是 automatic duration</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrementAndPrint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value&#123; <span class="number">1</span> &#125;; <span class="comment">// 默认是 automatic duration</span></span><br><span class="line">    ++value;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125; <span class="comment">// value is destroyed here</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    incrementAndPrint();</span><br><span class="line">    incrementAndPrint();</span><br><span class="line">    incrementAndPrint();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果**********/</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>每次</strong>调用函数<code>incrementAndPrint()</code>时，都将穿件一个叫value的变量，它被初始化为1</p></blockquote><hr><p>现在使用<code>static</code>关键字，将默认的 <em>atuomatic duration</em> 转变为 <em>static duration</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrementAndPrint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_value&#123; <span class="number">1</span> &#125;; <span class="comment">// 由于使用关键字 static,所以现在是 static duration。  所以这个变量将只会被初始化一次（不会像上面那个例子，每次调用都会被除初始化）</span></span><br><span class="line">    ++s_value;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s_value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125; <span class="comment">// s_value is not destroyed here, but becomes inaccessible because it goes out of scope</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    incrementAndPrint();</span><br><span class="line">    incrementAndPrint();</span><br><span class="line">    incrementAndPrint();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****结果****/</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><blockquote><p>在这个程序中，<strong>因为s_value被声明为静态的</strong>，<u><strong>所以s_value只创建一次(在程序启动时)(并且初始化为零)。</strong></u>然后在第一次遇到变量定义时使用我们提供的初始化值(1)初始化变量(但在后续调用时不会重新初始化)。</p></blockquote><blockquote><p>就像我们使用“g_” 作为全局变量的前缀一样，使用 “ s_”作为静态(静态持续时间)局部变量的前缀也是很常见的。</p></blockquote><hr><p><strong>静态变量提供了全局变量的一些好处(它们直到程序结束时才被销毁)</strong>，同时，限制为它们只在它自己的块中才能被看见，这使得即使您经常更改它们的值，这也使它们可以安全使用。</p><hr><h3 id="全局、局部变量使用static"><a href="#全局、局部变量使用static" class="headerlink" title="全局、局部变量使用static"></a>全局、局部变量使用<code>static</code></h3><p>全局变量使用关键字<code>static</code>：这会使得全局变量变为 <strong><em>internal linkage(内部连接)</em></strong>，即，使得该变量不能再其他文件中使用。</p><p>局部变量使用关键字<code>statci</code>：这使得局部变量变为 <strong><em>static duration(静态持续时间)</em></strong>,即，使得该变量将 只被创建一次，而且直到程序结束才会被销毁。</p><hr><h2 id="6-11-总结scope-duration-linkage"><a href="#6-11-总结scope-duration-linkage" class="headerlink" title="6.11 总结scope/duration/linkage"></a>6.11 总结scope/duration/linkage</h2><h3 id="总结scope"><a href="#总结scope" class="headerlink" title="总结scope"></a>总结scope</h3><p>标识符的范围决定了它能够被访问的区间：</p><ul><li>具有 <strong>block scope(块范围)</strong> / <strong>local scope(局部范围)</strong> 的变量 只能在它们被声明的块中(包括嵌套块)被访问，这些有：<ul><li>局部变量；</li><li>函数的形参；</li><li>在块中声明的用户定义类型定义（如，枚举(enum)、类(class)）;</li></ul></li><li>具有 <strong>global scope(全局范围)</strong> / <strong>file scope(文件范围)</strong>的变量 可以再文件中的任何地方被访问，这些有：<ul><li>全局变量；</li><li>函数；</li><li>在命 名空间内 或 全局范围 内声明的用户定义类型定义(如枚举(enum)、类(class))</li></ul></li></ul><hr><h3 id="总结duration"><a href="#总结duration" class="headerlink" title="总结duration"></a>总结duration</h3><p>变量的持续时间决定了它们何时被创建与销毁：</p><ul><li>具有 <strong>automatic duration(自动持续时间)</strong>的变量 在定义时被创建，在离开它所在的块时被销毁，这些有：<ul><li>局部变量；</li><li>函数的形参；</li></ul></li><li>具有 <strong>static duration(静态持续时间)</strong>的变量 在程序开始时被创建， 在程序结束时被销毁。这些有：<ul><li>全局变量；</li><li>静态局部变量；</li></ul></li><li>具有 <strong>dynamic duration(动态持续时间)</strong>的变量 由程序员请求创建和销毁。这些有：<ul><li>动态分配的变量；</li></ul></li></ul><hr><h3 id="总结linkage"><a href="#总结linkage" class="headerlink" title="总结linkage"></a>总结linkage</h3><p>标识符的 <strong><em>linkage</em>(连接)</strong> 决定了 一个标识符的多个实例是否引用同一个标识符。</p><ul><li>标识符 没有 连接 时，意味着这个标识符仅指其自身。这些有：<ul><li>局部变量；</li><li>在块中声明的用户定义类型定义(如枚举和类)；</li></ul></li><li>具有 <strong><em>intrnal linkage</em>(内部连接)</strong> 的标识符 只能在它所声明的文件中 被访问。这些有：<ul><li>静态全局变量(static global variables) [初始化 或 未初始化 ]；</li><li>静态函数（static functions）;</li><li>在未命名的命名空间中声明的函数；</li><li>在未命名的命名空间中声明的用户定义类型定义(如枚举和类)；</li></ul></li><li>具有 <strong><em>external linkage(外部连接)</em></strong> 的标识符 可以在 在声明的文件内的任何地方访问，也可以其他文件(通过提前声明)进行访问。这包括:<ul><li>函数；</li><li>非常量的全局变量(初始化 或 未初始化)；</li><li>外部常量全局变量；</li><li>内联常量全局变量；</li><li>在 命名空间内 或 全局范围内声明的用户定义类型定义(如枚举和类)；</li></ul></li></ul><hr><blockquote><p>NOTE:</p><p>默认情况下， 函数是 外部连接；它可通过使用关键字<code>static</code>变成 内部连接。</p></blockquote><hr><h3 id="变量的-scope-duratio-linkage"><a href="#变量的-scope-duratio-linkage" class="headerlink" title="变量的 scope/duratio /linkage"></a>变量的 scope/duratio /linkage</h3><table><thead><tr><th align="left">Type</th><th align="left">Example</th><th align="left">Scope</th><th align="left">Duration</th><th align="left">Linkage</th><th align="left">Notes</th></tr></thead><tbody><tr><td align="left">Local variable</td><td align="left">int x;</td><td align="left">Block</td><td align="left">Automatic</td><td align="left">None</td><td align="left"></td></tr><tr><td align="left">Static local variable</td><td align="left">static int s_x;</td><td align="left">Block</td><td align="left">Static</td><td align="left">None</td><td align="left"></td></tr><tr><td align="left">Dynamic variable</td><td align="left">int *x { new int };</td><td align="left">Block</td><td align="left">Dynamic</td><td align="left">None</td><td align="left"></td></tr><tr><td align="left">Function parameter</td><td align="left">void foo(int x)</td><td align="left">Block</td><td align="left">Automatic</td><td align="left">None</td><td align="left"></td></tr><tr><td align="left">External non-constant global variable</td><td align="left">int g_x;</td><td align="left">File</td><td align="left">Static</td><td align="left">External</td><td align="left">Initialized or uninitialized</td></tr><tr><td align="left">Internal non-constant global variable</td><td align="left">static int g_x;</td><td align="left">File</td><td align="left">Static</td><td align="left">Internal</td><td align="left">Initialized or uninitialized</td></tr><tr><td align="left">Internal constant global variable</td><td align="left">constexpr int g_x { 1 };</td><td align="left">File</td><td align="left">Static</td><td align="left">Internal</td><td align="left">Const or constexpr, Must be initialized</td></tr><tr><td align="left">External constant global variable</td><td align="left">extern constexpr int g_x { 1 };</td><td align="left">File</td><td align="left">Static</td><td align="left">External</td><td align="left">Const or constexpr, Must be initialized</td></tr><tr><td align="left">Inline constant global variable</td><td align="left">inline constexpr int g_x { 1 };</td><td align="left">File</td><td align="left">Static</td><td align="left">External</td><td align="left">Const or constexpr, Must be initialized</td></tr></tbody></table><hr><h3 id="总结提前声明"><a href="#总结提前声明" class="headerlink" title="总结提前声明"></a>总结提前声明</h3><p>你可以在其他文件中对一个 函数/变量 进行提前声明：</p><table><thead><tr><th align="left">Type</th><th align="left">Example</th><th align="left">Notes</th></tr></thead><tbody><tr><td align="left">Function forward declaration</td><td align="left">void foo(int x);</td><td align="left">Prototype only, no function body</td></tr><tr><td align="left">Non-constant global variable forward declaration</td><td align="left">extern int g_x;</td><td align="left">Must be uninitialized</td></tr><tr><td align="left">Const global variable forward declaration</td><td align="left">extern const int g_x;</td><td align="left">Must be uninitialized</td></tr><tr><td align="left">Constexpr global variable forward declaration</td><td align="left">extern constexpr int g_x;</td><td align="left"><u>Not allowed, constexpr cannot be forward declared</u></td></tr></tbody></table><hr><h3 id="什么是存储类说明符"><a href="#什么是存储类说明符" class="headerlink" title="什么是存储类说明符?"></a>什么是存储类说明符?</h3><p>当关键字<code>static</code> 、<code>extern</code>用作标识符声明的一部分时,它们就被称为：<strong>storage class specifier（存储类说明符）</strong>。它们设置标识符的存储的 <em>duration</em> 和 <em>linkage</em></p><p>C++支持4中存储类说明符：</p><table><thead><tr><th align="left">Specifier</th><th align="left">Meaning</th><th align="left">Note</th></tr></thead><tbody><tr><td align="left">extern</td><td align="left">static (or thread_local) storage duration and external linkage</td><td align="left"></td></tr><tr><td align="left">static</td><td align="left">static (or thread_local) storage duration and internal linkage</td><td align="left"></td></tr><tr><td align="left">thread_local</td><td align="left">thread storage duration</td><td align="left">Introduced in C++11</td></tr><tr><td align="left">mutable</td><td align="left">object allowed to be modified even if containing class is const</td><td align="left"></td></tr><tr><td align="left">auto</td><td align="left">automatic storage duration</td><td align="left">Deprecated in C++11</td></tr><tr><td align="left">register</td><td align="left">automatic storage duration and hint to the compiler to place in a register</td><td align="left">Deprecated in C++17</td></tr></tbody></table><blockquote><p>术语 <em>storage class specifier</em> 通常只在正式文档中使用。</p></blockquote><hr><h2 id="6-12-using-语句"><a href="#6-12-using-语句" class="headerlink" title="6.12 using 语句"></a>6.12 using 语句</h2><p>如果你经常使用标准库，那么在使用标准库中的所有内容之前输入std::会变得重复。C++提供了一种可选择的办法，叫做：<strong><em>using statements</em></strong></p><h3 id="using的声明"><a href="#using的声明" class="headerlink" title="using的声明"></a>using的声明</h3><p>一种简化的方法是使用using声明语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="comment">// this using declaration tells the compiler that cout should resolve to std::cout</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!"</span>; <span class="comment">// so no std:: prefix is needed here!</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// the using declaration expires here</span></span><br></pre></td></tr></table></figure><blockquote><p>using 的声明：<code>using std::cout</code>告诉编译器我们将要使用 命名空间std 中的<code>cout</code>。所以当编译器看到cout时，它会假设我们指的是std::cout。</p><p>如果std::cout与cout的其他一些使用之间存在命名冲突，则首选std::cout。</p></blockquote><p>上面的例子，看起来似乎没有简化多少。但如果我们要多次使用<code>cout</code>时，使用 <code>using statements</code>就可以简化很多。</p><blockquote><p>注意，如果你多次使用<code>std::cout</code>和<code>std::cin</code>的话，你需要对他们两个分别使用<code>using statements</code></p></blockquote><hr><h3 id="using-指令"><a href="#using-指令" class="headerlink" title="using 指令"></a>using 指令</h3><p>另一种方法就是使用：<code>using directive</code>语句。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">//这个using指令 告诉编译器我们可以使用 命名空间std 中的任何东西</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world!"</span>; <span class="comment">// 所以，前缀 std:: 就可以省略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个using 指令 ：<code>using namespace std</code>告诉编译器我们想使用 命名空间std 中的任何东西。所以当编译器发现了一个名字它不认识时，它就会检查 命名空间std。</p><p>结果就是，当编译器遇到<code>cout</code>(编译器不认识cout)，编译器就会查看 命名空间std 然后找到cout。</p><hr><p>如果std::cout与cout的其他一些使用之间存在命名冲突，编译器将把它<strong>标记为错误</strong>(而不是选择其中之一)。</p></blockquote><p>下面来看一下 using 指令 造成的歧义：</p><ul><li><p>eg1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> a</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x&#123; <span class="number">10</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> b</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x&#123; <span class="number">20</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> a;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> b;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面例子中，编译器无法在mian函数中决定使用<code>a::x</code>还是<code>b::x</code>。然后就会出现“不明确的符号”错误。</p><p>要想解决这个冲突，我们可以加上前缀使用。即显示标明使用的是哪一个命名空间中的x。</p></blockquote></li><li><p>eg2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // imports the declaration of std::cout</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cout</span><span class="params">()</span> <span class="comment">// declares our own "cout" function</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">// makes std::cout accessible as "cout"</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, world!"</span>; <span class="comment">// uh oh!  Which cout do we want here?  The one in the std namespace or the one we defined above?</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>eg2中，编译器无法判断我们使用的<code>cout</code>是引用的 <code>std::cout</code>还是 cout函数。并出现“不明确的符号”错误。</p><hr><p>解决方法：</p><ol><li><p>使用<code>using declaration</code> 来替代 <code>using directive</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="comment">//告诉编译器， cout 指的是 std::cout</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, world!"</span>; <span class="comment">//所以cout表示的是 std::cout</span></span><br></pre></td></tr></table></figure></li><li><p>显示的使用前缀：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, world!"</span>; <span class="comment">//告诉编译器使用的是std::cout</span></span><br></pre></td></tr></table></figure></li></ol></blockquote></li></ul><hr><h3 id="取消or替换-using语句"><a href="#取消or替换-using语句" class="headerlink" title="取消or替换 using语句"></a>取消or替换 using语句</h3><p>一旦，using语句被声明，那就没有办法在声明它的范围内使用另一个using语句替换或取消它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Foo;</span><br><span class="line">    <span class="comment">//此时无法使用一个其他的 using语句来 取消或替换 “using namespace Foo;”</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//using namespace Foo ends here</span></span><br></pre></td></tr></table></figure><p>对应它的最好办法就是，显示的限制 using语句 的范围：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> Foo; <span class="comment">//在这里调用Foo::中的东西</span></span><br><span class="line">    &#125; <span class="comment">//using namespace Foo 过期</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span><span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，<strong>可以显式地使用范围解析操作符(::)来避免所有这些麻烦。</strong></p><hr><h2 id="6-13-typedef与类型别名"><a href="#6-13-typedef与类型别名" class="headerlink" title="6.13 typedef与类型别名"></a>6.13 typedef与类型别名</h2><center>**优先使用类型别名，而不是typedefs，并大量使用它们来记录类型的含义**</center><p><code>typedef</code>允许程序猿去创建一个数据类型的别名。然后可以使用别名来替换这个类型真正的名字。</p><blockquote><p>Typedef的字面意思是“<strong>类型定义”</strong></p></blockquote><p>我们可以使用关键字<code>typedef</code>，来进行 类型定义：</p><blockquote><p><code>typedef a b</code> ：其中<code>a</code>表示类型的名字，<code>b</code>表示类型被替换成的别名.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> <span class="keyword">distance_t</span>; <span class="comment">//定义distance_t 作为 double类型 的别名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面两个语句是等价的:</span></span><br><span class="line"><span class="keyword">double</span> howFar;</span><br><span class="line"><span class="keyword">distance_t</span> howFar;</span><br></pre></td></tr></table></figure><blockquote><p>按照惯例，typedef名称是使用“_t”后缀声明的。这有助于指示标识符代表的是类型，而不是变量或函数，还有助于防止与其他标识符的命名冲突。</p></blockquote><hr><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>为了帮助解决这些问题，我们引入了一种改进的typedefs语法，它模仿了变量的声明方式。这种语法称为 <strong>type alias(类型别名)</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> <span class="keyword">distance_t</span>; <span class="comment">//定义distance_t 作为 double类型的 别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">distance_t</span> = <span class="keyword">double</span>; <span class="comment">//定义distance_t 作为 double类型的 别名【推荐】</span></span><br></pre></td></tr></table></figure><blockquote><p>上面两个语句在功能上等价。</p><p>【NOTE】虽然使用了关键字<code>using</code>（在这里是重载的意义），但这和 与命名空间相关的 using语句 没有关系。</p></blockquote><hr><h4 id="为易读性使用类型别名"><a href="#为易读性使用类型别名" class="headerlink" title="为易读性使用类型别名"></a>为易读性使用类型别名</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GradeTest</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>我们可以看到返回值是一个整数，但是这个整数是什么意思呢?一个字母等级?遗漏了多少问题?学生的身份证号码?一个错误代码?谁知道!Int不能告诉我们任何东西。写成下面形式，便于理解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> testScore_t = <span class="keyword">int</span>;</span><br><span class="line"><span class="function">testScore_t <span class="title">GradeTest</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="使用类型别名编写与平台无关的代码"><a href="#使用类型别名编写与平台无关的代码" class="headerlink" title="使用类型别名编写与平台无关的代码"></a>使用类型别名编写与平台无关的代码</h4><p>比如，在一些平台中，<code>int</code>类型占2个字节；但在其他平台中，可能占4个字节。所以，在4字节平台中写的代码在2字节平台中可能会出错。</p><p>所以，使用类型别名可以帮助我们避免出错，也更清楚地说明了对变量大小的假设。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> INT_2_BYTES</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">int8_t</span> = <span class="keyword">char</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">int16_t</span> = <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">int32_t</span> = <span class="keyword">long</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">int8_t</span> = <span class="keyword">char</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">int16_t</span> = short;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">int32_t</span> = <span class="keyword">int</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><blockquote><p>如果，在一个机器中，整数是2个字节。那么<code>INT_2_BYTES</code>将被定义。此时，就使用的是上部定义的这几个。</p><p>如果，在一个机器中，整数是4个字节。那么<code>INT_2_BYTES</code>将不被定义。此时，就使用的是下部定义的这几个。</p><hr><p>这种情况下：通过使用char、short、int和long的组合，这对于正在编译程序的机器是合适的</p><p><code>int_8</code>将处理 1字节的整数；</p><p><code>int16_t</code>将处理 2字节的整数；</p><p><code>int32_t</code>将处理 4字节的整数。</p></blockquote><hr><h2 id="6-14-关键字auto"><a href="#6-14-关键字auto" class="headerlink" title="6.14 关键字auto"></a>6.14 关键字<code>auto</code></h2><p>看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d &#123;<span class="number">5.0</span>&#125;;</span><br></pre></td></tr></table></figure><p>如果C++早就知道<code>5.0</code>是double类型的数字，那为什么我们还要显示的指定<code>d</code>是double类型的呢？如果我们可以让一个变量根据我们初始化它的值来设想它的类型，这不是很好吗?</p><h3 id="初始化变量的类型推断"><a href="#初始化变量的类型推断" class="headerlink" title="初始化变量的类型推断"></a>初始化变量的类型推断</h3><p>当初始化一个变量，关键字<code>auto</code>可以用来代替类型，以告诉编译器从初始化器的类型推断变量的类型。这种就叫作：<strong><em>type inference</em>(类型推断)</strong>, 英文中也可以叫作：<strong><em>type deduction</em></strong></p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> d &#123;<span class="number">5.0</span>&#125;; <span class="comment">//因为5.0是一个double类型的数字，所以它的类型将被推断为double</span></span><br><span class="line"><span class="keyword">auto</span> i &#123;<span class="number">1</span>+<span class="number">2</span>&#125;; <span class="comment">//因为1+2的结果是int类型，所以，i 将被推断为int类型</span></span><br></pre></td></tr></table></figure><p>也可以用在函数返回值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sum&#123;add(<span class="number">5</span>,<span class="number">6</span>)&#125;; <span class="comment">//add() 返回一个int, 所以sum的类型将被推断为int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="在C-14中函数的类型推断"><a href="#在C-14中函数的类型推断" class="headerlink" title="在C++14中函数的类型推断"></a>在C++14中函数的类型推断</h3><p>在C++14中，关键字<code>auto</code>被扩展到可以从函数体中的返回语句推断出函数的返回类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为<code>x+y</code>的值是int类型，编译器将会推断这个函数应该返回一个int类型。当使用<code>auto</code>返回类型时，所有的返回语句就必须返回相同的类型，否则将会出错。</p></blockquote><p>但是不推荐对函数的返回类型使用关键字<code>auto</code>。</p><blockquote><p>因为没有上下文来帮助指示函数返回的类型。用户实际上必须深入函数体本身来确定函数返回的类型。它不那么直观，因此更容易出错。</p></blockquote><hr><h3 id="后置返回类型语法"><a href="#后置返回类型语法" class="headerlink" title="后置返回类型语法"></a>后置返回类型语法</h3><p>关键字<code>auto</code>也可以被用来<strong>后置返回类型(trailing return syntax)</strong>。即，在函数原型之后指定返回的类型。</p><blockquote><p>这是C++11新增的<strong>一种函数声明</strong>的方法。</p></blockquote><p>下面的两个对函数声明的语句是等价的：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">auto add(int x, int y) -&gt; int;//在这种情况下，auto不执行类型推断——使用后置返回类型只是语法的一部分。</span><br></pre></td></tr></table></figure><hr><p>那为什么要用后置类型返回语句呢？其中的好处之一就是：可以让函数的声明时的名字对齐😊，如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto add(int x, int y) -&gt; int;</span><br><span class="line">auto divide(double x, double y) -&gt; double;</span><br><span class="line">auto printSomething() -&gt; void;</span><br><span class="line">auto generateSubstring(const std::string &amp;s, int start, int len) -&gt; std::string;</span><br></pre></td></tr></table></figure><hr><h3 id="函数形参的类型推断"><a href="#函数形参的类型推断" class="headerlink" title="函数形参的类型推断"></a>函数形参的类型推断</h3><blockquote><p><strong>在C++20时引入的</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">auto</span> x, <span class="keyword">auto</span> y)</span> <span class="comment">//only valid in C++20</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    add(<span class="number">2</span>, <span class="number">3</span>);    <span class="comment">//int</span></span><br><span class="line">    add(<span class="number">1.1</span>, <span class="number">2.2</span>); <span class="comment">//double</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在C++20之前</strong>，这种形式是无效的。因为编译器在 编译时(complie time) 不能推断函数形参的类型。</p><blockquote><p>在C++20之前，如果你想要创建一个使用各种不同类型的泛型函数，你需要使用<code>function templates</code>，而不是现在用的<code>type inference</code></p></blockquote><hr><h3 id="6-15-强制类型转换-隐式"><a href="#6-15-强制类型转换-隐式" class="headerlink" title="6.15 强制类型转换(隐式)"></a>6.15 强制类型转换(隐式)</h3><blockquote><p>类型转换有两种形式：</p><ul><li><strong>implicit type conversion</strong>（隐式类型转换）：编译器会自动将一种数据类型转换为另一种数据类型</li><li><strong>explicit type conversion</strong>（显示类型转换）：开发人员使用转换操作符来指导转换。</li></ul></blockquote><p>将值从一种数据类型转换为另一种数据类型的过程称为<strong><em>type conversion</em>(类型转换)</strong>。类型转换可以在许多不同的情况下发生:</p><ul><li><p>当用不同数据类型的值 分配 或 初始 化一个变量时:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d&#123;<span class="number">3</span>&#125;;  <span class="comment">// initialize double variable with integer value 3</span></span><br><span class="line">d = <span class="number">6</span>;    <span class="comment">// assign double variable the integer value 6</span></span><br></pre></td></tr></table></figure></li><li><p>当传递一个值给一个函数时，但函数参数是不同的数据类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">long</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">doSomething(<span class="number">3</span>); <span class="comment">// pass integer value 3 to a function expecting a long parameter</span></span><br></pre></td></tr></table></figure></li><li><p>当从一个函数返回一个值时，该函数的返回类型是不同的数据类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3.0</span>; <span class="comment">// Return double value 3.0 back to caller through float return type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用不同类型的操作数的 二元操作符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> division&#123; <span class="number">4.0</span> / <span class="number">3</span> &#125;; <span class="comment">// division with a double and an integer</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p><strong>隐式类型转换</strong>(也称为<strong>自动类型转换</strong>或<strong>强制转换</strong>)在希望是这种数据类型，但提供了另一种数据类型。乳沟编译器能够辨认出类型转换中的两种类型，挠他就转换。否则，报错。</p><blockquote><p>隐式类型转换有两种基本类型：<strong>提升</strong>和<strong>转换</strong>。</p></blockquote><ul><li><p><strong><em>Numeric promotion</em>数值提升</strong></p><p>每当将一个基本数据类型的值转换为来自同一族的更大的基本数据类型的值时，这称为<strong>数值提升</strong>(或<strong>加宽</strong>，尽管这个术语通常用于整数)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//an int can be widened into a long, or a float promoted into a double:</span></span><br><span class="line"><span class="keyword">long</span> l&#123; <span class="number">64</span> &#125;; <span class="comment">// widen the integer 64 into a long</span></span><br><span class="line"><span class="keyword">double</span> d&#123; <span class="number">0.12f</span> &#125;; <span class="comment">// promote the float 0.12 into a double</span></span><br></pre></td></tr></table></figure><p>虽然术语数值推广涵盖了任何类型的提升，但在c++中还有两个具有特定含义的术语:</p><ul><li><strong>Integral promotion(整型提升)</strong>：可以将[ <code>bool</code> , <code>char</code>, <code>unsigned char</code>, <code>signed char</code>, <code>unsigned short</code>, and <code>signed short</code> ]这些类型转换为 <code>int</code>或者是<code>unsigned int</code></li><li><strong>Floating point promotion(浮点型提升)</strong>：可以将<code>float</code>类型转换为<code>double</code></li></ul><p>整型提升 和 浮点型提升 通常是将 较小的数据类型转换为<code>int</code>/<code>unsigned int</code>或<code>double</code>。</p><hr></li><li><p><strong>Numeric conversions(数值转换)</strong></p><p>当我们将一个值从较大的类型转换为类似的较小类型时，或者在不同类型之间转换时，这称为数值转换。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d&#123; <span class="number">3</span> &#125;; <span class="comment">// convert integer 3 to a double (between different types)</span></span><br><span class="line">short s&#123; <span class="number">2</span> &#125;; <span class="comment">// convert integer 2 to a short (from larger to smaller type within same type family)</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>数值提升</strong>是安全的；但是<strong>数值转换</strong>可能会丢失数据。</p><blockquote><p>因此，导致执行隐式转换的代码通常会导致编译器发出警告。</p></blockquote></blockquote><p>eg,将一个值转换为的类型没有足够大的范围来支持这个值，就会出现意想不到的结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i&#123; <span class="number">30000</span> &#125;;</span><br><span class="line">    <span class="keyword">char</span> c = i; <span class="comment">// chars have range -128 to 127</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(c);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果**********/</span></span><br><span class="line"><span class="number">48</span></span><br></pre></td></tr></table></figure><blockquote><p>在本例中，我们将一个大整数分配给一个char(其范围为-128到127)。这会导致char溢出，并产生一个意外的结果: 48</p></blockquote><p>但是，只要值符合较小类型的范围，从较大的整数或浮点类型转换为较小的类似类型通常就可以工作。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> i&#123; <span class="number">2</span> &#125;;</span><br><span class="line">    short s = i; <span class="comment">// convert from int to short</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">double</span> d&#123; <span class="number">0.1234</span> &#125;;</span><br><span class="line">    <span class="keyword">float</span> f = d;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********结果**************/</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">0.1234</span></span><br></pre></td></tr></table></figure><p>对于浮点值，由于较小类型的精度损失，可能会出现一些舍入。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">0.123456789</span>; <span class="comment">// double value 0.123456789 has 9 significant digits, but float can only support about 7</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">9</span>) &lt;&lt; f &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// std::setprecision defined in 头文件“iomanip”中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************结果************/</span></span><br><span class="line"><span class="number">0.123456791</span></span><br></pre></td></tr></table></figure><p>只要值符合浮点类型的范围，就可以将整数转换为浮点数。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> i&#123; <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">float</span> f = i;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************结果**************/</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>只要值符合整数的范围，就可以将浮点数转换为整数，但是任何小数值都会丢失。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> i = <span class="number">3.5</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***在本例中，丢失了分数值(.5)，结果如下:****/</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>计算算术表达式</strong></p><p>当计算表达式时，编译器将每个表达式分解成单独的子表达式。算术运算符要求它们的<strong>操作数必须是相同的类型</strong>。为了确保这一点，编译器使用以下规则:</p><ul><li><p>如果一个操作数是一个比<code>int</code>更窄的整数，它将经历整数提升(如上所述)到<code>int</code>或<code>usigned int</code>。</p></li><li><p>如果操作数仍然不匹配，那么编译器会找到优先级最高的操作数，并隐式地将另一个操作数转换为匹配的操作数。</p><blockquote><p>操作数的优先级如下:</p><ul><li>long double (highest)</li><li>double</li><li>float</li><li>unsigned long long</li><li>long long</li><li>unsigned long</li><li>long</li><li>unsigned int</li><li>int (lowest)</li></ul></blockquote></li></ul><p>我们可以通过使用typeid操作符(包含在头中)看到通常的算术转换，该操作符可用于显示表达式的结果类型。</p><p>eg1:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt; // for typeid()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    short a&#123; <span class="number">4</span> &#125;;</span><br><span class="line">    short b&#123; <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(a + b).name() &lt;&lt; <span class="string">" "</span> &lt;&lt; a + b &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// show us the type of a + b</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*因为short是整数，所以它们在被添加之前要经过整数提升到int。添加两个int的结果是一个int，正如您所期望的:*/</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><blockquote><p>注意:编译器可能会显示一些稍微不同的内容，因为typeid.name()的格式由编译器决定。</p></blockquote><p>eg2:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt; // for typeid()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d&#123; <span class="number">4.0</span> &#125;;</span><br><span class="line">    short s&#123; <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(d + s).name() &lt;&lt; <span class="string">' '</span> &lt;&lt; d + s &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// show us the type of d + s</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****结果*************/</span></span><br><span class="line"><span class="keyword">double</span> <span class="number">6.0</span></span><br></pre></td></tr></table></figure><p>在这种情况下，<code>short</code>将被 <em>数值提升</em> 为<code>int</code>。但是，<code>int</code>与<code>double</code>还是不匹配。又因为<code>double</code>在类型的层次结构中更高。所以，整型的2将被转换为double 类型的 2.0 。然后就相当于是两个double类型的相加，结果还是double类型.</p></li></ul><hr><h2 id="强制类型转换-显式-amp-static-cast"><a href="#强制类型转换-显式-amp-static-cast" class="headerlink" title="强制类型转换(显式) &amp; static_cast"></a>强制类型转换(显式) &amp; <code>static_cast</code></h2><p>显式的类型转换是使用 <strong>type casting operator(类型转换操作符)</strong>。（通常是程序员来做的一个显式的的类型转换）</p><p>在C++中，类型转换大致分为5种： <code>C-style casts</code>, <code>static casts</code>, <code>const casts</code>, <code>dynamic casts</code>, and <code>reinterpret casts</code>. 后四个有时被称为<strong>命名类型转换(named casts)</strong>。</p><p>在本节课中，我们将介绍c风格的类型转换和静态类型转换。我们将在以后的课程中讨论指针和继承时再保存动态类型转换。</p><blockquote><p>通常应该避免使用<code>Const casts</code>和<code>reinterpret casts</code>，因为它们只在极少数情况下有用，如果使用不当可能会有害。</p></blockquote><hr><h3 id="C-style-casts"><a href="#C-style-casts" class="headerlink" title="C-style casts"></a>C-style casts</h3><p>在标准的C语言中，类型转换是通过 <strong>操作符<code>()</code></strong>来完成的。括号内是将要转换的目标类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i1 &#123; <span class="number">10</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> i2 &#123; <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">float</span> f &#123; (<span class="keyword">float</span>)i1 / i2 &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>在上面的程序中，我们使用浮点c风格的强制转换来告诉编译器将<code>i1</code>转换为浮点值。</p><p>因为运算符<code>/</code>的左操作数现在变为浮点值，右操作符也将被转换为浮点值。并且除法将使用浮点除法而不是整数除法!</p></blockquote><hr><p><strong>使用强制类型转换来清除隐式类型转换</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i &#123; <span class="number">48</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// explicit conversion from int to char, so that a char is assigned to variable ch</span></span><br><span class="line"><span class="keyword">char</span> ch = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(i);</span><br></pre></td></tr></table></figure><blockquote><p>当我们这样做时，我们显式地告诉编译器这个转换是有意的，并且我们接受对结果的责任。因为这个<code>static_cast</code>的输出类型是char，所以对变量ch的赋值不会产生任何类型不匹配，因此没有警告。</p></blockquote><p>下面的程序，编译器将会抱怨将double转换成int可能会导致数据丢失:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i &#123; <span class="number">100</span> &#125;;</span><br><span class="line">i = i / <span class="number">2.5</span>;</span><br></pre></td></tr></table></figure><p>告诉编译器，我们明确的意思是这样做:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i &#123; <span class="number">100</span> &#125;;</span><br><span class="line">i = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(i / <span class="number">2.5</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="6-17-未命名-内联-命名空间"><a href="#6-17-未命名-内联-命名空间" class="headerlink" title="6.17 未命名/内联 命名空间"></a>6.17 未命名/内联 命名空间</h2><h3 id="未命名-匿名-命名空间"><a href="#未命名-匿名-命名空间" class="headerlink" title="未命名(匿名) 命名空间"></a>未命名(匿名) 命名空间</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> <span class="comment">// unnamed namespace</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="comment">// can only be accessed in this file</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    doSomething(); <span class="comment">// we can call doSomething() without a namespace prefix</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果**********/</span></span><br><span class="line">v1</span><br></pre></td></tr></table></figure><blockquote><p>在未命名的命名空间中声明的所有内容都被视为父命名空间的一部分。因此，尽管<code>doSomething</code>函数是在未命名的命名空间中定义的，但函数本身可以从父命名空间(在本例中是<code>global namespace</code>)访问，这就是为什么我们可以从main调用doSomething而不需要任何限定符。</p></blockquote><p>这可能使未命名的命名空间看起来毫无用处。但未命名名称空间的另一个影响是：未命名命名空间内的所有标识符都被视为具有<strong>内部链接</strong>，<u>这意味着未命名命名空间的内容就不能在其他文件中看到</u>。</p><hr><p><strong>对于函数</strong>，<u>这实际上等同于将未命名的命名空间中的所有函数定义为<strong>静态函数</strong></u>。下面的程序与上面的程序实际上是相同的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="comment">// can only be accessed in this file</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    doSomething(); <span class="comment">// we can call doSomething() without a namespace prefix</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong><code>unnamed namespace</code></strong>通常用于 当你有很多内容想要确保在给定文件中保持局部时，使用<code>unnamed namespace</code>要比单独将所有声明标记为<code>static</code>更容易。</p><hr><h3 id="内联-命名空间"><a href="#内联-命名空间" class="headerlink" title="内联 命名空间"></a>内联 命名空间</h3><blockquote><p><strong>Inline namespaces</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    doSomething();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是假设你对doSomething不满意，你想通过改变它的行为方式来改进它。但如果这样做，就有可能破坏使用旧版本的现有程序。你是怎么处理的?</p><ul><li><p>一种方法是用不同的名称创建函数的新版本。但是经过许多更改之后，您可能会得到一组名称几乎相同的函数(doSomething、doSomething_v2、doSomething_v3等)。</p></li><li><p>【推荐】另一种方法是使用<strong>内联命名空间</strong>。<u>内联命名空间是通常用于版本化内容的名称空间</u>。与未命名的命名空间非常相似，<u>在内联命名空间中声明的任何内容都被认为是父名称空间的一部分</u>。<u>然而，内联命名空间并不是 内部链接。</u></p><blockquote><p>使用关键字<code>inline</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">namespace</span> v1 <span class="comment">// declare an inline namespace named v1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> v2 <span class="comment">// declare a normal namespace named v2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v2\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    v1::doSomething(); <span class="comment">// calls the v1 version of doSomething()</span></span><br><span class="line">    v2::doSomething(); <span class="comment">// calls the v2 version of doSomething()</span></span><br><span class="line"> </span><br><span class="line">    doSomething(); <span class="comment">// calls the inline version of doSomething() (which is v1)</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********结果********/</span></span><br><span class="line">v1</span><br><span class="line">v2</span><br><span class="line">v1</span><br></pre></td></tr></table></figure><blockquote><p>可以看出，当有 <strong>内联函数</strong>存在时，<u>如果不加前缀，<strong>则默认调用的是 内联函数版本</strong></u></p></blockquote><p>在上面的例子中，调用<code>doSomething</code>将得到<code>doSomething</code>的v1(内联版本)。希望使用新版本的调用者可以<strong>显式</strong>地调用<code>v2::dosomething()</code>。</p><blockquote><p>这保留了现有程序的功能，同时允许更新的程序利用更新的/更好的变体。</p></blockquote><hr></li></ul><h2 id="6-x-Chapter-6-summary-and-quiz"><a href="#6-x-Chapter-6-summary-and-quiz" class="headerlink" title="6.x Chapter 6 summary and quiz"></a>6.x Chapter 6 summary and quiz</h2><p><a href="https://www.learncpp.com/cpp-tutorial/chapter-6-summary-and-quiz/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/chapter-6-summary-and-quiz/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;p center large&gt;&lt;red&gt;LearnCpp chapter6&lt;/red&gt;&lt;/p&gt;&lt;/center&gt;&lt;center&gt;&lt;red&gt;https://www.learncpp.com&lt;/red&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C/C++" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"/>
    
    
      <category term="C/C++" scheme="https://longlongqin.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>GIT 学习</title>
    <link href="https://longlongqin.github.io/archives/18085cf9.html"/>
    <id>https://longlongqin.github.io/archives/18085cf9.html</id>
    <published>2020-04-05T06:08:23.000Z</published>
    <updated>2020-04-05T06:10:19.408Z</updated>
    
    <content type="html"><![CDATA[<center><p center large><red></red>Git学习笔记</p></center><a id="more"></a><p>Git的三种状态：</p><blockquote><p>committed（已提交）：数据已经安全的保存在本地数据库（仓库）；</p><p>modified（已修改）：修改了文件，<strong>但还没有保存到数据库</strong>；</p><p>staged（已暂存）：对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</p></blockquote><p>Git项目的三个工作区域概念：</p><blockquote><p><strong>Git仓库（Git directory 或 repository）：</strong>是Git用来保存项目的元数据和对象数据库的地方。是Git最重要部分，从其他计算机克隆仓库时，拷贝的就是这里的数据。</p><p><strong>工作目录（working directory）：</strong>对项目的某个版本独立提取出来的内容。这些从Git仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</p><p><strong>暂存区域（staging area）：</strong>是一个文件，保存了下一次将提交的文件列表信息，一般在Git仓库目录中，有时也被称作“索引”。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/1576831394522.png" alt="1576831394522"></p><p>基本的 Git 工作流程如下：</p><blockquote><p>1.在工作目录中修改文件；</p><p>2.暂存文件，将文件的快照放入暂存区域；</p><p>3.提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目。</p></blockquote><h1 id="初始设置："><a href="#初始设置：" class="headerlink" title="初始设置："></a>初始设置：</h1><h2 id="设置姓名和邮箱："><a href="#设置姓名和邮箱：" class="headerlink" title="设置姓名和邮箱："></a>设置姓名和邮箱：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Firstname Lastname&quot; &#x2F;&#x2F; 名字使用英文输入</span><br><span class="line">git config --global user.email &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><p>这个命令，会在“<code>~/.gitconfig</code>”中以如下形式输出设置文件。我的电脑上，这个文件夹的位置在<code>C:\Users\ACER</code></p><h2 id="设置SSH-key"><a href="#设置SSH-key" class="headerlink" title="设置SSH key:"></a>设置<code>SSH key</code>:</h2><p>创建公开密钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，我的在：<code>C:\Users\ACER\.ssh</code></p><p>里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是<strong>私钥</strong>，不能泄露出去，<code>id_rsa.pub</code>是<strong>公钥</strong>，可以放心地告诉任何人。</p><h2 id="初始化Git仓库："><a href="#初始化Git仓库：" class="headerlink" title="初始化Git仓库："></a>初始化Git仓库：</h2><p>在该仓库中，打开Git bash，然后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><h2 id="关联远程仓库："><a href="#关联远程仓库：" class="headerlink" title="关联远程仓库："></a>关联远程仓库：</h2><p>在远程仓库（如：<code>github、gitee</code>）中有一个新仓库什么都没有，我们可以：</p><p>克隆一份到本地；也可以把一个已有的本地仓库与之关联。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git remote add &lt;远程仓库名字&gt; &lt;远程仓库的SSH或HTTPS&gt;</span><br><span class="line"></span><br><span class="line">如：git remote add origin git@github.com:michaelliao&#x2F;learngit.git</span><br><span class="line">其中：</span><br><span class="line">远程仓库名字：origin（是git的默认叫法，也可以写成其他的）</span><br><span class="line">远程仓库的SSH：git@github.com:longlongqin&#x2F;learngit.git</span><br></pre></td></tr></table></figure><ul><li><input checked disabled type="checkbox"> <strong>当需要将<u>一个仓库</u>同时在<code>github 和 gitee</code>上关联时：</strong></li></ul><ol><li><p>假如在<code>gitee</code>上关联之前，已经在<code>GitHub</code>上关联过了。</p><p>比如事先在GitHub上：<code>git remote add origin git@github.com:longlongqin/LearnGit.git</code>，关联了一个叫<code>origin</code>的远程仓库。</p><p>然后，我现在要在gitee上关联一个仓库：</p><p><code>git remote add origin git@gitee.com:longlongqin/LearnGit.git</code></p><p>出现<u>报错</u>：fatal: remote origin already exists.说明，本地库已经关联了一个叫做<code>origin</code>的远程仓库了，所以才会报错。</p></li><li><p>所以，我们知道，不能将github和gitee上的仓库名字都叫一样的名字。他们之间的名字要区分。</p></li></ol><blockquote><ul><li><p>先，删除关联的已有的GitHub远程库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure></li><li><p>再开始重新关联github和gitee的仓库，这次要将他们的仓库名字区分开：</p><p>/*gitee中的LearnGit仓库起名：<code>gitee</code>；</p><p>/*github中的LearnGit仓库起名：<code>github</code>；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote gitee origin git@gitee.com:longlongqin&#x2F;LearnGit.git</span><br><span class="line">git remote github origin git@github.com:longlongqin&#x2F;LearnGit.git</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>检查一下，是否成功：</p><p>​ 我们用<code>git remote -v</code>查看远程库信息，可以看到两个远程库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">giteegit@gitee.com:longlongqin&#x2F;LearnGit.git (fetch)</span><br><span class="line">giteegit@gitee.com:longlongqin&#x2F;LearnGit.git (push)</span><br><span class="line">githubgit@github.com:longlongqin&#x2F;LearnGit.git (fetch)</span><br><span class="line">githubgit@github.com:longlongqin&#x2F;LearnGit.git (push)</span><br></pre></td></tr></table></figure><p>成功。</p><h2 id="取消关联远程仓库："><a href="#取消关联远程仓库：" class="headerlink" title="取消关联远程仓库："></a>取消关联远程仓库：</h2><p>在<strong><em>关联远程仓库</em></strong>一节中，关联远程仓库，我们也可以取消以经关联的远程仓库，让他们取消关联：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm &lt;要取消关联的远程仓库的名字&gt;</span><br></pre></td></tr></table></figure><h1 id="时光穿梭机"><a href="#时光穿梭机" class="headerlink" title="时光穿梭机"></a>时光穿梭机</h1><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><blockquote><p>1、<strong>没有<code>git add</code>时</strong>（即，对文件做了修改，但是没添加到暂存区）：==用<code>git checkout -- &lt;file&gt;</code> (==file前面有一个<strong>空格</strong>)</p><p>2、<strong>已经<code>git add</code>时</strong>（即，对文件做了修改，并且添加到暂存区）：</p><ul><li>先<code>git reset HEAD &lt;file&gt;</code>把暂存区的修改撤销掉，即：回退到没有git add时的状态</li><li>然后，再<code>git checkout -- &lt;file&gt;</code>。</li></ul><p>3、<strong>已经<code>git commit</code>时</strong>（即，对文件做了修改，不仅添加到暂存区，而且还提交到本地仓库中了）：进行==<strong>版本回退</strong>==</p></blockquote><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>版本之间的切换，<strong>版本</strong>指的是<code>git commit</code>之后带有哈希值的状态。</p><p><strong>版本回退</strong>：</p><ul><li><p><code>git reset --hard commit_id</code> 可以回退到版本号为commit_id的那个版本。</p></li><li><p><code>git reset --hard head^</code> 回退到当前版本的上一个版本。</p></li></ul><p><strong>转回到新版本</strong>：</p><p>因为<code>git log</code>显示的是从此刻<code>head指针</code>所在的状态到之前的状态的提交日志。而<code>git reflog</code>用来记录你的每一次命令。</p><p>所以转回到比当前所在的状态要新的状态需要：</p><ol><li><code>git reflog</code>,找到你想要回去的那个较新的状态的commit 的id</li><li><code>git reset --hard &lt;commit_id&gt;</code> 回到想要回器的那个版本。</li></ol><h1 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h1><ul><li><code>rm &lt;file&gt;</code>从工作区中删除文件（和手动删除文件效果一样。）</li></ul><p><code>git rm &lt;file&gt;</code>将文件从工作区删除，并且还添加到了暂存区（即，把删除的这个状态同步到暂存区了）。</p><p>[^小提示]: 先手动删除文件，然后使用git rm<file>和git add<file>效果是一样的。</file></file></p><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><h2 id="添加远程仓库："><a href="#添加远程仓库：" class="headerlink" title="添加远程仓库："></a>添加远程仓库：</h2><blockquote><p>关联一个远程仓库：<code>git remote add origin git@github.com:path/repo-name.git</code></p><p>关联后，<strong>第一次</strong>推送master分支的所有内容：<code>git push origin master</code></p></blockquote><h2 id="远程仓库克隆："><a href="#远程仓库克隆：" class="headerlink" title="远程仓库克隆："></a>远程仓库克隆：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;你想要克隆内容的公开密钥的密码&gt;</span><br></pre></td></tr></table></figure><p>公开的密钥密码，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200218130632774.png" alt="image-20200218130632774"></p><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><h2 id="创建与合并分支："><a href="#创建与合并分支：" class="headerlink" title="创建与合并分支："></a>创建与合并分支：</h2><ul><li><p><strong>查看分支</strong>：<code>git branch</code></p></li><li><p><strong>新建分支</strong>：<code>git branch &lt;name&gt;</code></p></li><li><p><strong>创建并切换分支</strong>：<code>git checkout -b &lt;name&gt;</code> or <code>git switch -c &lt;name&gt;</code></p></li><li><p><strong>切换分支</strong>：<code>git checkout &lt;name&gt;</code> or <code>git switch &lt;name&gt;</code></p></li><li><p><strong>删除分支</strong>：<code>git branch -d &lt;name&gt;</code><em>不能删除当前所在的分支</em></p></li><li><p><strong>合并分支</strong>：<code>git merge &lt;name&gt;</code> <em>用于合并分支到<strong>当前</strong>分支</em></p></li></ul><blockquote><p><code>git merge --no-ff &lt;name&gt;</code> 其中参数–no-ff：表示在历史记录中明确记录下本次分支合并。</p><p><strong>注意</strong>：输入此命令之后，会启动编辑器，用于录入合并提交的信息。</p></blockquote><h2 id="解决冲突："><a href="#解决冲突：" class="headerlink" title="解决冲突："></a>解决冲突：</h2><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p><p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p><p>用<code>git log --graph</code>命令可以看到分支合并图。</p><h2 id="分支管理策略："><a href="#分支管理策略：" class="headerlink" title="分支管理策略："></a>分支管理策略：</h2><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p><p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p><p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p><p>所以，团队合作的分支看起来就像这样：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/0.png" alt="0"></p><p>小结：</p><p>Git分支十分强大，在团队开发中应该充分应用。</p><p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p><h2 id="合并分支的两种方式："><a href="#合并分支的两种方式：" class="headerlink" title="合并分支的两种方式："></a>合并分支的两种方式：</h2><p><strong>git 的 <code>merge</code> 与 <code>merge no-ff</code> 的不同之处</strong>： <code>no-ff merge</code>可以看到合并历史。</p><blockquote><ol><li><p>新建分支<code>dev1</code>，修改<code>readme.txt</code>，然后在<code>dev1</code>分支下<code>git add readme.txt</code> <code>git commit -m &quot;dev1 branch commit&quot;</code></p></li><li><p>回到<code>master</code>分支，执行merge即<code>git merge dev1</code></p></li><li><p>删除分支</p></li><li><p>查看日志即<code>git log --graph --pretty=oneline --abbrev-commit</code></p></li><li><p>新建分支<code>dev2</code>，修改<code>readme.txt</code>，然后在<code>dev2</code>分支下<code>git add readme.txt</code> <code>git commit -m &quot;dev2 branch commit&quot;</code></p></li><li><p>回到<code>master</code>分支，执行merge即<code>git merge --no-ff -m &quot;dev2 merged with mo-ff&quot; dev2</code></p></li><li><p>删除分支</p></li><li><p>查看日志即<code>git log --graph --pretty=oneline --abbrev-commit</code></p></li><li><p>比较两次合并，可以看出不同之处，<code>no-ff</code>的模式会记录分支历史、</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://app.yinxiang.com/FileSharing.action?hash=1/792dd8c14a3b3fed2cf0044d82d01671-16494" alt="img"></p></li></ol></blockquote><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查 Git 的某一项配置：</span></span><br><span class="line">git <span class="built_in">config</span>  &lt;key&gt; </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/1576832423904.png" alt="1576832423904"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//列出所有 Git 当时能找到的配置：</span></span><br><span class="line"> git <span class="built_in">config</span> --<span class="built_in">list</span> </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/1576832563424.png" alt="1576832563424"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取帮助：3种方法</span></span><br><span class="line">$ git help &lt;verb&gt;</span><br><span class="line">$ git &lt;verb&gt; --help</span><br><span class="line">$ man git-&lt;verb&gt;</span><br></pre></td></tr></table></figure></blockquote><h1><a href="#" class="headerlink" title="###############################################"></a>###############################################</h1><h1 id="Git-其他指令："><a href="#Git-其他指令：" class="headerlink" title="Git 其他指令："></a>Git 其他指令：</h1><h2 id="查看工作区状态status："><a href="#查看工作区状态status：" class="headerlink" title="查看工作区状态status："></a>查看<code>工作区</code>状态<code>status</code>：</h2><p><code>git status</code>查看的是工作区的状态。</p><blockquote><p><code>git diff</code> 查看工作区与暂存区的区别。</p><p><code>git diff head</code>查看工作区与本地仓库的区别。</p></blockquote><h2 id="查看文件内容："><a href="#查看文件内容：" class="headerlink" title="查看文件内容："></a>查看文件内容：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;name&gt;</span><br></pre></td></tr></table></figure><h2 id="提交："><a href="#提交：" class="headerlink" title="提交："></a>提交：</h2><h3 id="工作区提交到暂存区："><a href="#工作区提交到暂存区：" class="headerlink" title="工作区提交到暂存区："></a>工作区提交到暂存区：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &quot;filename&quot;</span><br></pre></td></tr></table></figure><h3 id="暂存区提交到本地仓库："><a href="#暂存区提交到本地仓库：" class="headerlink" title="暂存区提交到本地仓库："></a>暂存区提交到本地仓库：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;message&quot; &#x2F;&#x2F;message是对此次提交的一个说明语句</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br><span class="line">&#x2F;&#x2F;此命令可以更加详细的记述提交信息（运行此命令后，会自动打开Git设置好的编辑器）</span><br></pre></td></tr></table></figure><blockquote><p>执行此命令后，编辑器就会启动，显示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with &#39;#&#39; will be ignored, and an empty message aborts the commit.</span><br><span class="line">#</span><br><span class="line"># On branch dev</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#modified:   readme.txt</span><br><span class="line">#</span><br></pre></td></tr></table></figure><p>在编辑器中记述提交信息的格式如下：</p><p>● 第一行：用一行文字简述提交的更改内容</p><p>● 第二行：空行</p><p>● 第三行以后：记述更改的原因和详细内容</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200218142052540.png" alt="image-20200218142052540"></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend :修改上一条提交时写的信息</span><br></pre></td></tr></table></figure><h3 id="本地仓库提交-推送-到远程仓库："><a href="#本地仓库提交-推送-到远程仓库：" class="headerlink" title="本地仓库提交(推送)到远程仓库："></a>本地仓库提交(推送)到远程仓库：</h3><center>git push</center><p><strong>情况一：</strong></p><p>注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以git pull是&lt;远程分支&gt;:&lt;本地分支&gt;，而git push是&lt;本地分支&gt;:&lt;远程分支&gt;。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程仓库名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure><p><strong>情况二：（推荐）</strong></p><p>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程仓库名字&gt; &lt;将本地的分支推送到远程仓库的分支（本地分支和远程分支的名字一样）&gt;</span><br><span class="line"></span><br><span class="line">如：git push origin master</span><br><span class="line">上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。</span><br></pre></td></tr></table></figure><p><strong>情况三：</strong></p><p>下面命令将本地的<code>master</code>分支推送到<code>origin</code>远程仓库，同时指定<code>origin</code>为默认仓库，后面就可以不加任何参数使用<code>git push</code>了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u &lt;远程仓库名字&gt; &lt;将本地的分支推送到远程仓库的分支（本地分支和远程分支的名字一样）&gt;</span><br></pre></td></tr></table></figure><p><strong>情况四：</strong></p><p>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push origin :&lt;远程分支&gt;</span><br><span class="line"></span><br><span class="line"># 等同于:git push origin --<span class="keyword">delete</span> master</span><br></pre></td></tr></table></figure><h2 id="获取最新的远程仓库的分支："><a href="#获取最新的远程仓库的分支：" class="headerlink" title="获取最新的远程仓库的分支："></a>获取最新的远程仓库的分支：</h2><p>加入在远程仓库中的一个分支中的内容更新了，而本地的这个分支（和远程的这个分支名字相同）不是最新的，可以用<code>git pull</code>来同步。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;远程仓库名&gt; &lt;需要更新的分支（这个分支名：本地的和远程的名字一样）&gt;</span><br></pre></td></tr></table></figure><p>如：</p><p><code>git pull origin feature-D</code>，表示：从远程仓库<code>origin</code>中的“<code>feature-D</code>”分支进行对本地的分支“<code>feature-D</code>”更新。</p><h2 id="查看提交历史："><a href="#查看提交历史：" class="headerlink" title="查看提交历史："></a>查看提交历史：</h2><ul><li><p><code>git log</code> 查看提交（commit）历史（以便确定要回退到哪个版本）。</p><p>​ 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数，即：<code>git log --pretty=oneline</code></p></li></ul><blockquote><ul><li><p><code>git log &lt;filename&gt;</code> ：显示特定文件(filename)的提交历史</p></li><li><p><code>git log -p</code> ：文件的前后差别就会显示在提交信息之后</p></li><li><p><code>git log -p &lt;filename&gt;</code> ：只查看 “filename”文件的提交日 志以及提交前后的差别。</p></li><li><p><code>git log --graph</code>：以图表形式查看分支，例如下图：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200222002143874.png" alt="image-20200222002143874"></p></blockquote><ul><li><code>git reflog</code> 查看历史的每一次的命令（以便确定要回到未来的哪个版本）。</li></ul><h2 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git:"></a>自定义Git:</h2><h3 id="修改GIT默认编辑器："><a href="#修改GIT默认编辑器：" class="headerlink" title="修改GIT默认编辑器："></a>修改GIT默认编辑器：</h3><p>GIT默认编辑器为Vi，假如我想用<code>Notepad++</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitconfig--globalcore.editor&quot;Notepad++&quot;&#x2F;&#x2F;设置Editor使用Notepad++</span><br></pre></td></tr></table></figure><h3 id="Git显示颜色："><a href="#Git显示颜色：" class="headerlink" title="Git显示颜色："></a>Git显示颜色：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global color.ui true</span><br></pre></td></tr></table></figure><h1 id="-1"><a href="#-1" class="headerlink" title="##################################################"></a>##################################################</h1><h1 id="学习廖雪峰教学中的问题："><a href="#学习廖雪峰教学中的问题：" class="headerlink" title="学习廖雪峰教学中的问题："></a>学习廖雪峰教学中的问题：</h1><p>1、与教学步骤中的命令区别于：“–”</p><p>（1）<code>git diff head --readme.txt</code>：</p><p>问题：在我自己电脑上面运行没反应？</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200112221142249.png" alt="image-20200112221142249"></p><p><strong>解决：</strong></p><p>运行<code>：git diff head readme.txt</code>,即去掉那个“–”。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200112221407621.png" alt="image-20200112221407621"></p><p>（2）<code>git checkout --readme.txt</code></p><p>问题：在于我的电脑上多了“–”会运行失败。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200112222013881.png" alt="image-20200112222013881"></p><p>解决：去掉“–”：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200112222046360.png" alt="image-20200112222046360"></p><hr><h1 id="GitHub使用技巧"><a href="#GitHub使用技巧" class="headerlink" title="GitHub使用技巧"></a><a href="https://www.zhihu.com/question/20084458" target="_blank" rel="noopener">GitHub使用技巧</a></h1><h2 id="搜索："><a href="#搜索：" class="headerlink" title="搜索："></a>搜索：</h2><h3 id="1）、在不同地方搜索"><a href="#1）、在不同地方搜索" class="headerlink" title="1）、在不同地方搜索"></a>1）、在不同地方搜索</h3><h4 id="1、按照name搜索"><a href="#1、按照name搜索" class="headerlink" title="1、按照name搜索"></a>1、<strong>按照<code>name</code>搜索</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in:name &lt;something&gt;    &#x2F;&#x2F;假设想搜索的东西叫：something</span><br></pre></td></tr></table></figure><h4 id="2、按照readme搜索"><a href="#2、按照readme搜索" class="headerlink" title="2、按照readme搜索"></a>2、按照<code>readme</code>搜索</h4><p>也可以按照<code>readme.md</code>中包含<something>的查找项目：</something></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in:readme &lt;something&gt;   &#x2F;&#x2F;假设想搜索的东西叫：something</span><br></pre></td></tr></table></figure><h4 id="3、按照descriptin搜索"><a href="#3、按照descriptin搜索" class="headerlink" title="3、按照descriptin搜索"></a>3、按照<code>descriptin</code>搜索</h4><p>假设我们现在要学习<something>的项目，我们搜索项目描述(description)里面包含<something>的项目:</something></something></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in:description &lt;something&gt;   &#x2F;&#x2F;假设想搜索的东西叫：something</span><br></pre></td></tr></table></figure><h4 id="4、直接搜索"><a href="#4、直接搜索" class="headerlink" title="4、直接搜索"></a>4、直接搜索</h4><p>直接在搜索栏中搜索：加入想搜索与<code>CJSON</code>有关的内容：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200219151224327.png" alt="image-20200219151224327"></p><h3 id="2）、添加约束条件"><a href="#2）、添加约束条件" class="headerlink" title="2）、添加约束条件"></a>2）、添加约束条件</h3><h4 id="star数量"><a href="#star数量" class="headerlink" title="star数量"></a><strong><code>star</code>数量</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stars: &gt; 500     &#x2F;&#x2F; star 数量大于500的项目</span><br><span class="line">stars: 10..20    &#x2F;&#x2F; star 数量在10-20之间的仓库</span><br></pre></td></tr></table></figure><h4 id="fork数量"><a href="#fork数量" class="headerlink" title="fork数量"></a><code>fork</code>数量</h4><p>同理，我们也可以按照fork的数量来进行搜索:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in:name React  forks:&gt;3000</span><br></pre></td></tr></table></figure><hr><h4 id="language编程语言"><a href="#language编程语言" class="headerlink" title="language编程语言"></a><code>language</code>编程语言</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">language:python   &#x2F;&#x2F;比如，把语言限制为Python</span><br></pre></td></tr></table></figure><h4 id="仓库push的时间"><a href="#仓库push的时间" class="headerlink" title="仓库push的时间"></a>仓库<code>push</code>的时间</h4><p>假如在这些项目里面，我们想要找到最近才更新的项目，意思是更新时间就在最近，我们可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pushed:&gt;2020-01-01  &#x2F;&#x2F;项目的最近一次更新时间限制到2020-01-01之后</span><br></pre></td></tr></table></figure><hr><h4 id="仓库持有者"><a href="#仓库持有者" class="headerlink" title="仓库持有者"></a>仓库持有者</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user：&lt;username&gt;</span><br></pre></td></tr></table></figure><h4 id="仓库大小"><a href="#仓库大小" class="headerlink" title="仓库大小"></a>仓库大小</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size:&gt;&#x3D;5000 &#x2F;&#x2F; 仓库大于5000KB的仓库</span><br></pre></td></tr></table></figure><h4 id="仓库create时间"><a href="#仓库create时间" class="headerlink" title="仓库create时间"></a>仓库<code>create</code>时间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">created:&gt;2019-01-01     &#x2F;&#x2F; 2019年以后创建的仓库</span><br></pre></td></tr></table></figure><h4 id="license协议"><a href="#license协议" class="headerlink" title="license协议"></a><code>license</code>协议</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">license:apache-2.0  &#x2F;&#x2F; 使用 apache-2.0 协议的仓库</span><br></pre></td></tr></table></figure><h4 id="组织机构代码"><a href="#组织机构代码" class="headerlink" title="组织机构代码"></a>组织机构代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org:spring-cloud  &#x2F;&#x2F; 列出org 的 spring-cloud  仓库</span><br></pre></td></tr></table></figure><h3 id="3）、组合搜索"><a href="#3）、组合搜索" class="headerlink" title="3）、组合搜索"></a>3）、组合搜索</h3><p>将1）和2）中可以随机组合进行精确搜索,比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in:description &lt;something&gt; language:python  &#x2F;&#x2F;将编程语言限制为python</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in:readme &lt;something&gt; stars:&gt;3000 forks:&gt;3000</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in:description 微服务 language:python pushed:&gt;2020-01-01</span><br><span class="line">&#x2F;*pushed:&gt;2020-01-01的意思是我们把项目的最后更新时间限制到2020-01-01*&#x2F;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in:name React  forks:&gt;3000</span><br></pre></td></tr></table></figure><p>等等</p><h2 id="奇特搜索："><a href="#奇特搜索：" class="headerlink" title="奇特搜索："></a>奇特搜索：</h2><h3 id="awesome搜索"><a href="#awesome搜索" class="headerlink" title="awesome搜索"></a><code>awesome</code>搜索</h3><p><strong>1、awesome-awesome搜索</strong></p><p>直接使用<code>awesome-awesome</code>可以搜索出很多优质项目。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awesome-awesome</span><br></pre></td></tr></table></figure><p><strong>2、<code>awesome name</code>搜索</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awesome &lt;name&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;p center large&gt;&lt;red&gt;&lt;/red&gt;Git学习笔记&lt;/p&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Git" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git/"/>
    
    
      <category term="Git" scheme="https://longlongqin.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>LearnCpp chapterO</title>
    <link href="https://longlongqin.github.io/archives/67343d3.html"/>
    <id>https://longlongqin.github.io/archives/67343d3.html</id>
    <published>2020-04-04T02:21:31.000Z</published>
    <updated>2020-04-19T14:38:29.546Z</updated>
    
    <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapterO</red></p></center><center><red>https://www.learncpp.com</red></center><p>未完待续~~</p><a id="more"></a><h2 id="O-1-Bit-flags-and-bit-manipulation-via-std-bitset"><a href="#O-1-Bit-flags-and-bit-manipulation-via-std-bitset" class="headerlink" title="O.1 Bit flags and bit manipulation via std::bitset"></a>O.1 Bit flags and bit manipulation via std::bitset</h2><p>在现代计算机体系结构中，最小的可寻址内存单元是<strong>字节</strong>。由于所有对象都需要有唯一的内存地址，这意味着对象的大小必须至少为一个字节。对于大多数变量类型，这是可以的。<strong>然而，对于布尔值，这有点浪费</strong>。布尔类型只有两种状态:真(1)，或假(0)。这一组状态只需要存储一位。然而，如果一个变量必须至少是一个字节，而一个字节是8位，这意味着一个布尔值使用1位，而其他7位不使用。</p><hr><ul><li><p><strong>位操作：bit manipulation</strong></p><p>在对象内部，修改单个bit的过程，叫位操作。</p><blockquote><p>位操作在加密和压缩算法中也很有用。</p></blockquote></li><li><p>但是，我们可以将对象视为单个位的集合，而不是将其视为持有单个值的对象。当对象的个别位用作布尔值时，这些位称为<strong>位标志：bit flag</strong>。</p><blockquote><p>在计算中，标志是作为某个函数或进程的信号的值。类似地，在现实生活中，邮箱标志用于指示邮箱中有内容，因此不必打开邮箱进行检查。</p></blockquote><p>为了定义一组位标志，我们通常使用适当大小的无符号整数(8位、16位、32位等等，这取决于我们有多少个标志)，或者std::bitset。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt; //for std::bitset</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;8&gt; mybitset &#123;&#125;; <span class="comment">//8 bits in size means room for 8 flags</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>位操作</strong>是少数几种<strong>应该明确使用无符号整数(或std::bitset)的操作</strong>之一。</p></blockquote></li></ul><hr><ul><li><p><strong>位编号和位的位置：Bit numbering and bit positions</strong></p><p>给定一个bits 序列，通常从右到左开始进行编号(编号的开头是0，不是1)。每一个数字表示一个<strong><em>bit positon</em>：位的位置</strong>。eg：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">76543210  Bit position</span><br><span class="line">00000101  Bit sequence</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>通过<code>std::bitset</code>操作位</strong></p><p>在 <a href="https://www.learncpp.com/cpp-tutorial/literals/" target="_blank" rel="noopener">4.12 – Literals</a>，我们介绍了如何使用<code>std::bitset</code>来输出二进制形式的结果。现在我们来介绍<code>std::bitset</code>的其他功能：</p><p><code>std::bitset</code>提供了4个关键的功能，对做位操作很有用:</p><ul><li><p><code>text()</code>：允许我们查询一个位是0还是1；</p></li><li><p><code>set()</code>：允许我们将一个 位(bit)设置成 on，即将其设置为1；</p></li><li><p><code>reset()</code>：允许我们将一个 位(bit)设置成 off，即将其设置为 0；</p></li><li><p><code>flip()</code>：允许我们将一个 位(bit) 由0设置为1，或者由1设置为0；</p><blockquote><p>这些函数中的每一个都带有一个位位置参数，该参数指示我们将要操作的位 的位置。</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;8&gt; bits&#123;<span class="number">0b0000'0101</span>&#125;; <span class="comment">//we need 8 bits, start with bit pattern 0000 0101</span></span><br><span class="line">    <span class="built_in">bit</span>.<span class="built_in">set</span>(<span class="number">3</span>); <span class="comment">//set bit position 3 to 1 (now we have 0000 1101)</span></span><br><span class="line">    <span class="built_in">bit</span>.flip(<span class="number">4</span>); <span class="comment">//flip bit 4(now we have 0001 1101)</span></span><br><span class="line">    <span class="built_in">bit</span>.reset(<span class="number">4</span>); <span class="comment">//set bit 4 back to 0 (now we have 0000 1101)</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"All the bits: "</span>&lt;&lt;bits&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"bit 3 has valude: "</span> &lt;&lt;<span class="built_in">bit</span>.test(<span class="number">3</span>) &lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>:;<span class="built_in">cout</span> &lt;&lt;<span class="string">"bit 4 has valud: "</span>&lt;&lt;<span class="built_in">bit</span>.test(<span class="number">4</span>) &lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********输出结果********/</span></span><br><span class="line">All the bits: <span class="number">00001101</span></span><br><span class="line"><span class="built_in">bit</span> <span class="number">3</span> has valude: <span class="number">1</span></span><br><span class="line"><span class="built_in">bit</span> <span class="number">4</span> has valude: <span class="number">0</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="O-2-位操作符"><a href="#O-2-位操作符" class="headerlink" title="O.2 位操作符"></a>O.2 位操作符</h2><p>C++提供了<strong>“位操作符(bitwise operator)”</strong>：</p><table><thead><tr><th align="left">Operator</th><th align="left">Symbol</th><th align="left">Form</th><th align="left">Operation</th></tr></thead><tbody><tr><td align="left">left shift</td><td align="left">&lt;&lt;</td><td align="left">x &lt;&lt; y</td><td align="left">all bits in x shifted left y bits</td></tr><tr><td align="left">right shift</td><td align="left">&gt;&gt;</td><td align="left">x &gt;&gt; y</td><td align="left">all bits in x shifted right y bits</td></tr><tr><td align="left">bitwise NOT</td><td align="left">~</td><td align="left">~x</td><td align="left">all bits in x flipped</td></tr><tr><td align="left">bitwise AND</td><td align="left">&amp;</td><td align="left">x &amp; y</td><td align="left">each bit in x AND each bit in y</td></tr><tr><td align="left">bitwise OR</td><td align="left">|</td><td align="left">x | y</td><td align="left">each bit in x OR each bit in y</td></tr><tr><td align="left">bitwise XOR</td><td align="left">^</td><td align="left">x ^ y</td><td align="left">each bit in x XOR each bit in y</td></tr></tbody></table><blockquote><p>在下面的例子中，我们将主要使用4位二进制值。这是为了方便和保持例子简单。在实际的程序中，使用的位的数量是基于对象的大小(例如，一个2字节的对象将存储16位)。</p><p>为了可读性，我们还将在代码示例之外省略0b前缀(例如，我们将使用0101而不是0b0101)。</p></blockquote><hr><ul><li><p><strong>位操作符：<code>&lt;&lt;</code>左移、<code>&gt;&gt;</code>右移</strong></p><p>按位左移(&lt;&lt;)操作符将位移到左边。左操作数是要移位的位的表达式，而右操作数是要左移的位的整数。</p><blockquote><p>如：<code>x&lt;&lt;1</code>表示，将变量x左移一个位置。从右边移进来的新位接受一个 值0。</p><p>eg，</p><p><code>0011&lt;&lt;1</code> 是 0110</p><p><code>0011&lt;&lt;2</code> 是 1100</p><p><code>0011&lt;&lt;3</code> 是 1000</p></blockquote><p>同理，按位右移(&gt;&gt;)操作符原理也一样：</p><blockquote><p><code>1100&gt;&gt;1</code> 是 0110</p><p><code>1100&gt;&gt;2</code> 是 0011</p><p><code>1100&gt;&gt;3</code> 是 0001</p></blockquote><hr><p>下面是一个示例程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;4&gt; x&#123;<span class="number">0b1100</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;x&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (x&gt;&gt;<span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//右移一个位置，结果是0110</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (x&lt;&lt;<span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//左移一个位置，结果是1000</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******结果******/</span></span><br><span class="line"><span class="number">1100</span></span><br><span class="line"><span class="number">0110</span></span><br><span class="line"><span class="number">1000</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>位操作：NOT <code>~</code></strong></p><p>这个操作符功能就是将每个位的数由0变为1，或由1变为0：</p><blockquote><p>如：<code>~0100</code> 是 1011；<code>~0000 0100</code> 是 1111 1011</p></blockquote><p>上面例子中，虽然：0100 和000 0100是一样的，就像十进制的7和07一样；但是经过<code>~</code>操作符之后，它们位数不一样，就会产生不一样的结果。</p></li></ul><hr><ul><li><p><strong>位操作：OR <code>|</code></strong></p><p>它的形式是对两个表达式进行每个位上的或运算，如：<code>0b0101 | 0b0110</code>。更加直观的形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 1 0 1 OR</span><br><span class="line">0 1 1 0</span><br><span class="line">---------   &#x2F;&#x2F;结果为</span><br><span class="line">0 1 1 1</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (<span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;&#123;<span class="number">0b0101</span>&#125; | <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;&#123;<span class="number">0b0110</span>&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********结果********/</span></span><br><span class="line"><span class="number">0111</span></span><br></pre></td></tr></table></figure><blockquote><p>也可进行多个表达式的运算，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0 1 1 1 OR</span><br><span class="line">0 0 1 1 OR</span><br><span class="line">0 0 0 1</span><br><span class="line">--------</span><br><span class="line">0 1 1 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;只要对应的列有1，它的结果中对应的那一列就是1</span><br></pre></td></tr></table></figure><p>它写成程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (<span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;&#123; <span class="number">0b0111</span> &#125; | <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;&#123; <span class="number">0b0011</span> &#125; | <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;&#123; <span class="number">0b0001</span> &#125;);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********结果*********/</span></span><br><span class="line"><span class="number">0111</span></span><br></pre></td></tr></table></figure></blockquote></li></ul><hr><ul><li><p><strong>位操作：AND <code>&amp;</code></strong></p><p>它的形式为：<code>0b0101 &amp; 0b0110</code>,更加直观的形式（也可以有多个表达式一起运算）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 1 0 1 AND</span><br><span class="line">0 1 1 0</span><br><span class="line">--------</span><br><span class="line">0 1 0 0</span><br></pre></td></tr></table></figure><blockquote><p>每一列中只有全部为1时，结果中对应的列才是1.</p></blockquote><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (<span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;&#123; <span class="number">0b0001</span> &#125; &amp; <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;&#123; <span class="number">0b0011</span> &#125; &amp; <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;&#123; <span class="number">0b0111</span> &#125;);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直观的表示为：</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> AND</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> AND</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">--------  <span class="comment">//结果为</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>位操作：XOR <code>^</code></strong></p><p>它的形式为：<code>0b0001 ^ 0b0011 ^ 0b0111</code></p><p>更加直观的看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 1 XOR</span><br><span class="line">0 0 1 1 XOR</span><br><span class="line">0 1 1 1</span><br><span class="line">--------</span><br><span class="line">0 1 0 1</span><br></pre></td></tr></table></figure><blockquote><p>每一列如果有<strong>奇数个1</strong>，则结果中对应的列就是1；否则就是0.</p></blockquote></li></ul><hr><ul><li><p><strong>位的赋值操作符</strong></p><p>与算术赋值运算符相似，C++提供位的赋值操作符，为了方便修改变量：</p><table><thead><tr><th align="left">Operator</th><th align="left">Symbol</th><th align="left">Form</th><th align="left">Operation</th></tr></thead><tbody><tr><td align="left">Left shift assignment</td><td align="left">&lt;&lt;=</td><td align="left">x &lt;&lt;= y</td><td align="left">Shift x left by y bits</td></tr><tr><td align="left">Right shift assignment</td><td align="left">&gt;&gt;=</td><td align="left">x &gt;&gt;= y</td><td align="left">Shift x right by y bits</td></tr><tr><td align="left">Bitwise OR assignment</td><td align="left">|=</td><td align="left">x |= y</td><td align="left">Assign x | y to x</td></tr><tr><td align="left">Bitwise AND assignment</td><td align="left">&amp;=</td><td align="left">x &amp;= y</td><td align="left">Assign x &amp; y to x</td></tr><tr><td align="left">Bitwise XOR assignment</td><td align="left">^=</td><td align="left">x ^= y</td><td align="left">Assign x ^ y to x</td></tr></tbody></table><p>比如，<code>x= x&gt;&gt;1</code>，可以写成：<code>x&gt;&gt;=1</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;4&gt; bits&#123;<span class="number">0b0100</span>&#125;;</span><br><span class="line">    bits &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; bits;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果*********/</span></span><br><span class="line"><span class="number">0010</span></span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>总结：</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;p center large&gt;&lt;red&gt;LearnCpp chapterO&lt;/red&gt;&lt;/p&gt;&lt;/center&gt;&lt;center&gt;&lt;red&gt;https://www.learncpp.com&lt;/red&gt;&lt;/center&gt;&lt;p&gt;未完待续~~&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C/C++" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"/>
    
    
      <category term="C/C++" scheme="https://longlongqin.github.io/tags/C-C/"/>
    
  </entry>
  
</feed>
