<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>龙龙‘S BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://longlongqin.github.io/"/>
  <updated>2020-04-22T07:17:55.695Z</updated>
  <id>https://longlongqin.github.io/</id>
  
  <author>
    <name>longlongqin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LearnCpp chapter8</title>
    <link href="https://longlongqin.github.io/archives/c812a74c.html"/>
    <id>https://longlongqin.github.io/archives/c812a74c.html</id>
    <published>2020-04-19T08:54:17.000Z</published>
    <updated>2020-04-22T07:17:55.695Z</updated>
    
    <content type="html"><![CDATA[<center><p center large><red>LearnCpp-chapter8</red></p></center><center><red>https://www.learncpp.com</red></center><p>未完待续~~</p><a id="more"></a><h2 id="8-1-介绍面向对象编程"><a href="#8-1-介绍面向对象编程" class="headerlink" title="8.1 介绍面向对象编程"></a>8.1 介绍面向对象编程</h2><center><red>Object-oriented programming (OOP)</red></center><p>在 <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-variables/" target="_blank" rel="noopener">1.3 – Introduction to variables</a>中，我们在c++中将<strong>一个对象定义为“一段可用来存储值的内存”。</strong>具<strong>有名称的对象称为变量。</strong></p><p>在传统编程中(我们在此之前一直在做的工作)，程序基本上是计算机的指令列表，这些指令定义数据(通过对象)，然后处理数据(通过语句和函数)。数据和处理该数据的函数是独立的实体，它们组合在一起以产生所需的结果。由于这种分离，传统的编程通常不能提供对现实的非常直观的表示。</p><p>由程序员以适当的方式管理和连接 <strong>属性(变量)</strong>和<strong>行为(函数)</strong>，这就致使代码变成这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driveTo(you, work);</span><br></pre></td></tr></table></figure><h3 id="什么是面向对象编程？"><a href="#什么是面向对象编程？" class="headerlink" title="什么是面向对象编程？"></a>什么是面向对象编程？</h3><p>和许多事物一样，它可能最容易通过类比来理解。看看你的周围–你看到的每一个地方都是<strong>object</strong>：书籍、建筑物、食物，甚至你自己。</p><p><strong>object</strong>有两个主要的部分：</p><ol><li>（<strong>properties</strong>）<strong>相关属性的列表</strong>（e.g. weight, color, size, solidity, shape, etc…）</li><li>（<strong>behavior</strong>）<strong>这些属性能表现出的一些行为</strong>（e.g. being opened, making something else hot, etc…）</li></ol><p>这些<strong>属性</strong>和<strong>行为</strong>是不可分割的。</p><hr><p>Object-oriented programming (OOP) 为我们提供了创建对象的能力，这些对象将属性和行为绑定到一个自包含的、可重用的包中。这导致代码看起来更像这样:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you.driveto(work);</span><br></pre></td></tr></table></figure><blockquote><p>这不仅读起来更清晰，还使主语(您)和被调用的行为(在某处驾驶)更清晰。</p><p><strong>不是专注于编写函数，而是专注于定义具有定义良好的行为集的对象</strong>。<strong>这就是为什么这个范例被称为“面向对象”。</strong></p></blockquote><hr><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>这允许以更模块化的方式编写程序，这使它们更容易编写和理解，还提供了更高程度的<strong>代码可重用性</strong>。</p><p>这些对象还提供了一种 <strong>通过允许我们定义如何与对象交互以及如何与其他对象交互，来更直观的方式来处理数据。</strong></p><blockquote><p>请注意，OOP并没有取代传统的编程方法。相反，它在编程工具带中为您提供了额外的工具，以便在需要时管理复杂性。</p></blockquote><h4 id="object"><a href="#object" class="headerlink" title="object"></a>object</h4><p>请注意，<strong>术语“object”被稍微重载了一些</strong>，这导致了一些混淆。<strong>在传统编程中，对象是用来存储值的一块内存</strong>。<strong>在面向对象编程中，“对象”意味着它包含 传统编程意义上的对象，又是属性和行为的组合。</strong>从现在开始，当我们使用“对象”这个术语时，我们将在面向对象的意义上引用“对象”。</p><h2 id="8-2-类-amp-类成员"><a href="#8-2-类-amp-类成员" class="headerlink" title="8.2 类&amp;类成员"></a>8.2 类&amp;类成员</h2><p>虽然C++提供一些基本的数据类型（e.g. char, int, long, float, double, etc…），它们可以解决一些简单的问题。</p><p>但是在解决复杂问题的时候这些基本数据类型就不够用了。</p><blockquote><p>C++也提供：<strong>允许用户自定义数据类型</strong>，如之前学的： <strong><a href="http://www.learncpp.com/cpp-tutorial/45-enumerated-types/" target="_blank" rel="noopener">enumerated types</a></strong>、<a href="http://www.learncpp.com/cpp-tutorial/47-structs/" target="_blank" rel="noopener"><strong>structs</strong></a></p></blockquote><p>在C++，中<code>class</code>与 <code>struct</code>本质上相同。如下面的两个是等价的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DateStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_year;</span><br><span class="line">    <span class="keyword">int</span> m_month;</span><br><span class="line">    <span class="keyword">int</span> m_day;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>注意，惟一显著的区别是<code>public:</code>关键字在类中</p></blockquote><p><strong>类(和结构)定义就像一个蓝图——它们描述结果对象的样子，但是它们实际上并不创建对象</strong>。<u>要实际创建类的对象，必须定义该类类型的变量:</u></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DateClass today &#123; <span class="number">2020</span>, <span class="number">10</span>, <span class="number">14</span> &#125;; <span class="comment">// declare a variable of class DateClass</span></span><br></pre></td></tr></table></figure><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p>除了保存数据，类(和结构)还可以包含函数!在类内部定义的函数称为<strong>成员函数</strong> (有时也称为<strong>方法</strong>)。</p><h4 id="成员函数-amp-非成员函数"><a href="#成员函数-amp-非成员函数" class="headerlink" title="成员函数&amp;非成员函数"></a>成员函数&amp;非成员函数</h4><p>eg：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非成员函数：函数不能调用定义在它下面的函数(没有前向声明):</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// You can't call y() from here unless the compiler has already seen a forward declaration for y()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数：成员函数没有这个限制</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">x</span><span class="params">()</span> </span>&#123;y()&#125; ;<span class="comment">// okay to call y() here, even though y() isn't defined until later in this class</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">y</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成员类型"><a href="#成员类型" class="headerlink" title="成员类型"></a>成员类型</h3><p>除了成员变量和成员函数外，类还可以具有<strong>成员类型</strong>或<strong>嵌套类型</strong>(包括<strong>类型别名</strong>)。在下面的例子中，我们创建了一个计算器，如果需要，我们可以快速地更改它所使用的数字类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vertor&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">number_t</span> = <span class="keyword">int</span>; <span class="comment">//这是一个嵌套类型的别名</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">number_t</span>&gt; m_result&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">number_t</span> <span class="title">add</span> <span class="params">(<span class="keyword">number_t</span> a, <span class="keyword">number_t</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//auto的原理就是根据后面的值，来自己推测前面的类型是什么。</span></span><br><span class="line">        <span class="keyword">auto</span> result &#123;a+b&#125;;</span><br><span class="line">        m_result.push_back (result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Calculator calculator &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; calculator.add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这样的上下文中，<strong>类名</strong>实际上充当嵌套类型的<strong>名称空间</strong>。在类内部，我们只需要引用number_t。在类之外，我们可以通过Calculator::number_t访问类型。</p><hr><h3 id="关于C-中的struct的说明"><a href="#关于C-中的struct的说明" class="headerlink" title="关于C++中的struct的说明"></a>关于C++中的struct的说明</h3><p>在C语言中，<strong>结构体只能保存数据</strong>，<strong>没有成员函数</strong>。但是咋C++中，两者都可以有。</p><p>经过考虑，他决定他们应该有一个统一的规则集。因此，<strong>虽然我们使用class关键字编写了上述程序，但我们可以使用struct关键字。</strong></p><p>所以，建议：</p><blockquote><p><strong>对只包含数据的结构使用struct关键字</strong>。<strong>对同时具有数据和函数的对象使用class关键字。</strong></p></blockquote><h2 id="8-3-访问说明符-piblicVS-private"><a href="#8-3-访问说明符-piblicVS-private" class="headerlink" title="8.3 访问说明符 piblicVS private"></a>8.3 访问说明符 <code>piblic</code>VS <code>private</code></h2><p><strong>public</strong>：<code>class</code>和<code>struct</code>的public member 可以在 它们的外部访问；</p><blockquote><p><strong>由关键字<code>struct</code>构成的数据类型，默认是public。</strong></p></blockquote><p><strong>private</strong>：只能被类的其他成员访问；</p><blockquote><p><strong>由<code>class</code>构成的数据类型，默认是private。</strong></p></blockquote><hr><p><strong>通常，成员变量通常是<code>private</code>的，而成员函数通常是<code>public</code>的。</strong></p><p>eg：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DateStruct</span> // <span class="title">members</span> <span class="title">are</span> <span class="title">public</span> <span class="title">by</span> <span class="title">default</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> month; <span class="comment">// public by default, can be accessed by anyone</span></span><br><span class="line">    <span class="keyword">int</span> day; <span class="comment">// public by default, can be accessed by anyone</span></span><br><span class="line">    <span class="keyword">int</span> year; <span class="comment">// public by default, can be accessed by anyone</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DateStruct date;</span><br><span class="line">    date.month = <span class="number">10</span>;</span><br><span class="line">    date.day = <span class="number">14</span>;</span><br><span class="line">    date.year= <span class="number">2020</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateClass</span> // <span class="title">members</span> <span class="title">are</span> <span class="title">private</span> <span class="title">by</span> <span class="title">default</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m_month; <span class="comment">// private by default, can only be accessed by other members</span></span><br><span class="line">    <span class="keyword">int</span> m_day; <span class="comment">// private by default, can only be accessed by other members</span></span><br><span class="line">    <span class="keyword">int</span> m_year; <span class="comment">// private by default, can only be accessed by other members</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DateClass date;</span><br><span class="line">    date.m_month = <span class="number">10</span>; <span class="comment">// error</span></span><br><span class="line">    date.m_day = <span class="number">14</span>; <span class="comment">// error</span></span><br><span class="line">    date.m_year = <span class="number">2020</span>; <span class="comment">// error</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类的<strong>public member</strong>通常被看作 <strong>public interface（公共接口）</strong>：因为只有public mebmber才可以在类外部被访问，但是public member可以直接访问类中的private和protected的成员。<strong>所以利用public member 可以间接访问类的private和protected的成员。</strong></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;p center large&gt;&lt;red&gt;LearnCpp-chapter8&lt;/red&gt;&lt;/p&gt;&lt;/center&gt;&lt;center&gt;&lt;red&gt;https://www.learncpp.com&lt;/red&gt;&lt;/center&gt;&lt;p&gt;未完待续~~&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C/C++" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"/>
    
    
      <category term="C/C++" scheme="https://longlongqin.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>LearnCpp chapterL</title>
    <link href="https://longlongqin.github.io/archives/9f7a1269.html"/>
    <id>https://longlongqin.github.io/archives/9f7a1269.html</id>
    <published>2020-04-18T02:13:00.000Z</published>
    <updated>2020-04-23T08:14:32.228Z</updated>
    
    <content type="html"><![CDATA[<center><p center large><red>LearnCpp-chapterL</red></p></center><center><red>https://www.learncpp.com</red></center><p>未完待续~~</p><a id="more"></a><h2 id="L5-1-控制流"><a href="#L5-1-控制流" class="headerlink" title="L5.1 控制流"></a>L5.1 控制流</h2><p>当程序运行时，CPU开始从<code>mian()</code>函数执行，然后执行它里面的语句，最后结束于<code>main()</code>函数结尾。</p><p>CPU执行语句的顺序叫做：<strong>程序执行路径(execution path)</strong>。</p><h3 id="停止-halt"><a href="#停止-halt" class="headerlink" title="停止(halt)"></a>停止(halt)</h3><p>但程序运行并不总是将<code>main()</code>函数中的语句全部执行。它可以被停止。在C++中，可以使用<strong>头文件<code>cstdlib</code>中的<code>std::exit()</code>函数</strong>，来终止程序。</p><blockquote><p><code>exit</code>函数接受一个整数参数，该参数作为std::exit代码返回给操作系统，这与main()的返回值非常相似。</p></blockquote><p>eg:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; //for std::exit()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//code here to do any kind of cleanup required</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    cleanup();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">//程序在此结束，并且向操作系统返回0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//所以下面的语句将不会执行</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="number">2</span>&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>，<code>std::exit()</code>无论从哪个函数调用(甚至是<code>main</code>以外的函数)都可以工作。还要注意，<code>std::exit()</code>使用最少的清理立即终止程序。所以，在使用<code>std::exit()</code>之前，您应该考虑是否需要进行任何手动清理(例如将用户的游戏保存到磁盘)。</p><blockquote><p>通常，<code>std::exit()</code>用于在发生灾难性的、不可恢复的错误时立即终止程序。</p></blockquote><h2 id="L5-1-if语句"><a href="#L5-1-if语句" class="headerlink" title="L5.1 if语句"></a>L5.1 if语句</h2><p>最基本的条件分支就是 <strong>if 语句</strong>。</p><h3 id="隐式的块"><a href="#隐式的块" class="headerlink" title="隐式的块"></a>隐式的块</h3><p>我们需要注意，隐式的块中的一些陷阱，</p><h4 id="陷阱1："><a href="#陷阱1：" class="headerlink" title="陷阱1："></a>陷阱1：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">6</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为上面的x是在一个块中被定义的(这个块没有显式的写出来，但它确实是一个块)</span></span><br></pre></td></tr></table></figure><p>上面这个程序会出错，原因：（这将无法编译，编译器将生成标识符<code>x</code>未定义的错误）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面的程序和这个程序相等。这个程序将块显式的表示出来了</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">    &#125; <span class="comment">// x destroyed here</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">6</span>;</span><br><span class="line">    &#125; <span class="comment">// x destroyed here</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x; <span class="comment">// x isn't defined here</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="陷阱2："><a href="#陷阱2：" class="headerlink" title="陷阱2："></a>陷阱2：</h4><p>程序1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= <span class="number">20</span>)</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">"is between 10 and 20\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// attached to outer if statement</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">"is less than 10\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序2：（去掉大括号）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">10</span>)</span><br><span class="line">    <span class="comment">//删除大括号</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt;= <span class="number">20</span>)</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">"is between 10 and 20\n"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// attached to outer if statement</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">"is less than 10\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序1和2是否一样呢？</p><p>答：不一样。程序1中的最后的else语句是与第一个if语句匹配；程序2中的最后的else语句是与它最近的if语句匹配。</p><h3 id="if中的初始化语句"><a href="#if中的初始化语句" class="headerlink" title="if中的初始化语句"></a>if中的初始化语句</h3><p>如果需要在If语句中使用变量，而不是在If语句之外，<strong>那么可以在条件之前使用init语句</strong>(在C++17中添加的）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> firstname&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> lastname&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"First name: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; firstName;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Last name: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; lastName;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">std</span>::<span class="built_in">string</span> fullname &#123;firsstname + <span class="string">' '</span> + lastname&#125;; fullname.length()&gt;<span class="number">20</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; '"'&lt;&lt;fullname &lt;&lt;'\" is to long \n';</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"your name is: "</span> &lt;&lt;fullname;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量<code>fullname</code>在整个if语句中是可以访问的。</p><h2 id="L5-2-switch语句"><a href="#L5-2-switch语句" class="headerlink" title="L5.2 switch语句"></a>L5.2 switch语句</h2><p>C++ 中 <strong>switch</strong> 语句的语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> constant-expression  :</span><br><span class="line">       statement(s);</span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">// 可选的</span></span><br><span class="line">    <span class="keyword">case</span> constant-expression  :</span><br><span class="line">       statement(s);</span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">// 可选的</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 您可以有任意数量的 case 语句</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">// 可选的</span></span><br><span class="line">       statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>switch</strong> 语句必须遵循下面的规则：</p><ul><li><p><strong>switch</strong> 语句中的 <strong>expression</strong> 必须是一个<strong>integral type(整数类型)或浮点类型</strong>，或者是一个 class 类型，其中 class 有一个单一的转换函数将其转换为整型或枚举类型。</p><blockquote><p><strong>整数类型</strong>有：<code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>long long</code>, or <code>enum</code></p><p>注意，<strong>在C/C++中，char是属于整数类型的</strong>。</p></blockquote></li><li><p>在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。</p></li><li><p>case 的 <strong>constant-expression</strong> 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。</p></li><li><p>当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 <strong>break</strong> 语句为止。</p></li><li><p>当遇到 <strong>break</strong> 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。</p></li><li><p>不是每一个 case 都需要包含 <strong>break</strong>。如果 case 语句不包含 <strong>break</strong>，控制流将会 <em>继续</em> 后续的 case，直到遇到 break 为止。</p></li><li><p>一个 <strong>switch</strong> 语句可以有一个可选的 <strong>default</strong> case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 <strong>break</strong> 语句不是必需的。</p></li></ul><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><h4 id="在case语句中有、无-break-的效果"><a href="#在case语句中有、无-break-的效果" class="headerlink" title="在case语句中有、无 break 的效果"></a>在case语句中有、无 break 的效果</h4><p>在 switch 语句中，每个 case 语句的结尾不要忘记添加 break 语句，否则将导致多个分支重叠。当然，除非有意使多个分支重叠，这样可以免去 break 语句。下面我们来看一个实际示例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有break</span></span><br><span class="line"><span class="keyword">switch</span> (<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// Does not match</span></span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// skipped</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// Match!</span></span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// Execution begins here</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// This is also executed</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">4</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// This is also executed</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">5</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// This is also executed</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**结果******/</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line"><span class="comment">//无break</span></span><br><span class="line"><span class="keyword">switch</span> (<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// Does not match</span></span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// skipped</span></span><br><span class="line">   <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// Match!</span></span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// Execution begins here</span></span><br><span class="line">   <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// This is also executed</span></span><br><span class="line">   <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">4</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// This is also executed</span></span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">5</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// This is also executed</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******结果***********/</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="case语句中变量的声明-amp-定义"><a href="#case语句中变量的声明-amp-定义" class="headerlink" title="case语句中变量的声明&amp;定义"></a>case语句中变量的声明&amp;定义</h3><p><strong>你可以在switch语句中声明变量(但不能够初始化)</strong>。在case之前或之后均可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a; <span class="comment">// okay, declaration is allowed before the case labels</span></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">5</span>; <span class="comment">// illegal, initialization is not allowed before the case labels</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">int</span> y; <span class="comment">// okay, declaration is allowed within a case</span></span><br><span class="line">        y = <span class="number">4</span>; <span class="comment">// okay, 这个是赋值(不是初始化)</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        y = <span class="number">5</span>; <span class="comment">// okay, y was declared above, so we can use it here too</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">int</span> z = <span class="number">4</span>; <span class="comment">// illegal, 不能再这里面对变量初始化</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"default case"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为在switch语句中，不存在隐式的块。所以，在switch语句内，所有语句的范围都一样(存在于switch的内部)。所以，在case 1：声明的变量y，可以在case 2：中被访问</p></blockquote><blockquote><p>但是，不允许直接在case标签下面初始化变量，这会导致编译错误。这是因为<strong>初始化变量需要执行（声明语句不会执行）</strong>，而包含初始化的case语句可能不会执行!</p><hr><p><strong>但是我们可以在case块中，初始化变量：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    &#123; <span class="comment">// note addition of block here</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">4</span>; <span class="comment">// okay, variables can be initialized inside a block inside a case</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"default case"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><hr><h2 id="L5-4-goto-语句"><a href="#L5-4-goto-语句" class="headerlink" title="L5.4 goto 语句"></a>L5.4 goto 语句</h2><p>goto语句是一个控制流语句，它使CPU跳到代码中的另一个位置。这个位置是通过使用<strong>statement label（语句标签）</strong>来标识的。</p><p>eg:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; // for sqrt() function</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">tryAgain: <span class="comment">// this is a statement label</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a non-negative number"</span>; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0.0</span>)</span><br><span class="line">        <span class="keyword">goto</span> tryAgain; <span class="comment">// this is the goto statement</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sqrt of "</span> &lt;&lt; x &lt;&lt; <span class="string">" is "</span> &lt;&lt; <span class="built_in">sqrt</span>(x) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果用户输入的数是负数，那它会一直<code>goto</code>到这个语句标签，直到你输入一个合格的非负数。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LearnCpp-chapterL/image-20200423100210785.png" alt="image-20200423100210785"></p></blockquote><hr><h3 id="陷阱："><a href="#陷阱：" class="headerlink" title="陷阱："></a>陷阱：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">goto</span> skip; <span class="comment">// invalid forward jump</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">skip:</span><br><span class="line">    x += <span class="number">3</span>; <span class="comment">// what would this even evaluate to?</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们不能这样使用 语句标签。因为我们跳转到标签语句<code>skip</code>中时，程序还没执行到<code>int x = 5;</code>这个语句。所以，会报错：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LearnCpp-chapterL/image-20200423101450792.png" alt="image-20200423101450792"></p><p>如何改正：</p><p>我们可以让<code>int x=5;</code>这个语句放在 <code>goto skip;</code>语句之前，就可以了。</p><hr><h3 id="不建议使用goto语句"><a href="#不建议使用goto语句" class="headerlink" title="不建议使用goto语句"></a>不建议使用goto语句</h3><p>goto的主要问题是，它允许程序员任意地在执行点上跳转。因此很难理解这种代码的逻辑。</p><h2 id="L5-7-for语句"><a href="#L5-7-for语句" class="headerlink" title="L5.7 for语句"></a>L5.7 for语句</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形式</span></span><br><span class="line"><span class="keyword">for</span> (init-statement; condition-expression; <span class="built_in">end</span>-expression)</span><br><span class="line">   statement</span><br></pre></td></tr></table></figure><h3 id="多重声明"><a href="#多重声明" class="headerlink" title="多重声明"></a>多重声明</h3><p>有时for循环需要多个变量。当这种情况发生时，程序员可以使用<strong>逗号操作符</strong>来分配(在init-statement中)或更改(在end-statement中)多个变量的值:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> iii&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> jjj&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (iii = <span class="number">0</span>, jjj = <span class="number">9</span>; iii &lt; <span class="number">10</span>; ++iii, --jjj)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iii &lt;&lt; <span class="string">' '</span> &lt;&lt; jjj &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更常用的写法是：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> iii&#123;<span class="number">0</span>&#125;, jjj&#123;<span class="number">9</span>&#125;; iii&lt;<span class="number">10</span>; ++iii, --jjj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;iii &lt;&lt;<span class="string">' '</span> &lt;&lt;jjj &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="L5-8-break-和-continue"><a href="#L5-8-break-和-continue" class="headerlink" title="L5.8 break 和 continue"></a>L5.8 break 和 continue</h2><h3 id="break与return"><a href="#break与return" class="headerlink" title="break与return"></a>break与return</h3><ul><li>break语句是终止<code>switch</code>语句 或者 其他循环语句，然后继续执行该语句下面的语句。</li><li>return语句终止循环所在的整个函数，并在调用函数的地方继续执行。</li></ul><p>请看下面例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">breakOrReturn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) <span class="comment">// infinite loop</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter 'b' to break or 'r' to return: "</span>;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'b'</span>)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// execution will continue at the first statement beyond the loop</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'r'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// return will cause the function to immediately return to the caller (in this case, main())</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// breaking the loop causes execution to resume here</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"We broke out of the loop\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> returnValue&#123; breakOrReturn() &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Function breakOrReturn returned "</span> &lt;&lt; returnValue &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p><code>continue</code>语句提供了一种方便的方法来跳转到当前迭代（当前这一层循环）的循环体的末尾。当我们想要提前终止当前的迭代时，这是很有用的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> count&#123; <span class="number">0</span> &#125;; count  &lt; <span class="number">20</span>; ++count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// if the number is divisible by 4, skip this iteration</span></span><br><span class="line">    <span class="keyword">if</span> ((count % <span class="number">4</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">// jump to end of loop body</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// If the number is not divisible by 4, keep going</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">------------------------------------------------------ </span><br><span class="line"><span class="comment">// The continue statement jumps to here</span></span><br><span class="line">------------------------------------------------------</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;p center large&gt;&lt;red&gt;LearnCpp-chapterL&lt;/red&gt;&lt;/p&gt;&lt;/center&gt;&lt;center&gt;&lt;red&gt;https://www.learncpp.com&lt;/red&gt;&lt;/center&gt;&lt;p&gt;未完待续~~&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C/C++" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"/>
    
    
      <category term="C/C++" scheme="https://longlongqin.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>【六】Linux 档案与目录管理</title>
    <link href="https://longlongqin.github.io/archives/426514b1.html"/>
    <id>https://longlongqin.github.io/archives/426514b1.html</id>
    <published>2020-04-14T18:30:36.000Z</published>
    <updated>2020-04-19T14:38:29.546Z</updated>
    
    <content type="html"><![CDATA[<center><p center large><red>鸟哥私房菜【六】</red></p></center><center><red>http://linux.vbird.org/linux_basic/</red></center><a id="more"></a><h2 id="目录相关操作"><a href="#目录相关操作" class="headerlink" title="目录相关操作"></a>目录相关操作</h2><p>变换目录：<code>cd</code> (Change Directory)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.  代表此层目录</span><br><span class="line">.. 代表上一层目录</span><br><span class="line">- 代表前一个工作目录</span><br><span class="line">~ 代表『目前使用者身份』所在的家目录</span><br><span class="line">~account 代表account 这个使用者的家目录(account是个帐号名称)</span><br></pre></td></tr></table></figure><hr><p>常见的处理目录的指令:</p><ul><li>cd：变换目录</li><li>pwd：显示目前的目录</li><li>mkdir：建立一个新的目录</li><li>rmdir：删除一个空的目录</li></ul><hr><h3 id="cd-change-directory-变换目录"><a href="#cd-change-directory-变换目录" class="headerlink" title="cd (change directory, 变换目录)"></a><strong>cd (change directory, 变换目录)</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">先切换身份成为root看看！</span></span><br><span class="line">[dmtsai@study ~]$ su -   </span><br><span class="line">[root@study ~]# cd [相对路径或绝对路径] </span><br><span class="line"><span class="meta">#</span><span class="bash">最重要的就是目录的绝对路径与相对路径，还有一些特殊目录的符号啰！</span></span><br><span class="line">[root@study ~]# cd ~dmtsai </span><br><span class="line"><span class="meta">#</span><span class="bash">代表去到dmtsai这个使用者的家目录，亦即/home/dmtsai </span></span><br><span class="line">[root@study dmtsai]# cd ~ </span><br><span class="line"><span class="meta">#</span><span class="bash">表示回到自己的家目录，亦即是/ root这个目录 </span></span><br><span class="line">[root@study ~]# cd </span><br><span class="line"><span class="meta">#</span><span class="bash">没有加上任何路径，也还是代表回到自己家目录的意思喔！</span></span><br><span class="line">[root@study ~]# cd .. </span><br><span class="line"><span class="meta">#</span><span class="bash">表示去到目前的上层目录，亦即是/root的上层目录的意思； </span></span><br><span class="line">[root@study /]# cd - </span><br><span class="line"><span class="meta">#</span><span class="bash">表示回到刚刚的那个目录，也就是/root啰～ </span></span><br><span class="line">[root@study ~]# cd /var/spool/mail </span><br><span class="line"><span class="meta">#</span><span class="bash">这个就是绝对路径的写法！直接指定要去的完整路径名称！</span></span><br><span class="line">[root@study mail]# cd ../postfix</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个是相对路径的写法，我们由/var/spool/mail 去到/var/spool/postfix 就这样写！</span></span><br></pre></td></tr></table></figure><hr><h3 id="pwd-显示目前所在的目录"><a href="#pwd-显示目前所在的目录" class="headerlink" title="pwd (显示目前所在的目录)"></a><strong>pwd (显示目前所在的目录)</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwd [-P]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">-P ：显示出真实的路径，而非使用连结(link) 路径。</span><br></pre></td></tr></table></figure><blockquote><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">范例：单纯显示出目前的工作目录： </span><br><span class="line">[root@study ~]# pwd </span><br><span class="line">/root    &lt;==显示出目录啦～</span><br><span class="line"></span><br><span class="line">范例：显示出实际的工作目录，而非连结档本身的目录名而已 </span><br><span class="line">[root@study ~]# cd /var/mail    &lt;==注意，/var/mail是一个连结档 </span><br><span class="line">[root@study mail]# pwd </span><br><span class="line">/var/mail          &lt;==列出目前的工作目录 </span><br><span class="line">[root@study mail]# pwd -P </span><br><span class="line">/var/spool/mail    &lt;==怎么回事？有没有加-P差很多～ </span><br><span class="line">[root@study mail]# ls -ld /var/mail </span><br><span class="line">lrwxrwxrwx. 1 root root 10 May 4 17:51 /var/mail -&gt; spool/mail</span><br><span class="line"><span class="meta"> #</span><span class="bash">看到这里应该知道为啥了吧？因为/var/mail是连结档，连结到/var/spool/mail</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 所以，加上<span class="built_in">pwd</span> -P 的选项后，会不以连结档的资料显示，而是显示正确的完整路径啊！</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="mkdir-建立新目录"><a href="#mkdir-建立新目录" class="headerlink" title="mkdir (建立新目录)"></a>mkdir (建立新目录)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir [-m、p] 目录名称</span><br></pre></td></tr></table></figure><blockquote><p>eg:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# mkdir [-mp]目录名称</span><br><span class="line">选项与参数：</span><br><span class="line">-m ：设定档案的权限喔！直接设定，不需要看预设权限(umask) 的脸色～</span><br><span class="line">-p ：帮助你直接将所需要的目录(包含上层目录)递回建立起来！</span><br><span class="line"></span><br><span class="line">范例：请到/tmp底下尝试建立数个新目录看看： </span><br><span class="line">[root@study ~]# cd /tmp </span><br><span class="line">[root@study tmp]# mkdir test     &lt;==建立一名为test的新目录 </span><br><span class="line">[root@study tmp]# mkdir test1/test2/test3/test4</span><br><span class="line">mkdir: cannot create directory 'test1/test2/test3/test4': No such file or directory</span><br><span class="line"><span class="meta">#</span><span class="bash">话说，系统告诉我们，没可能建立这个目录啊！就是没有目录才要建立的！见鬼嘛？</span></span><br><span class="line">[root@study tmp]# mkdir -p test1/test2/test3/test4 </span><br><span class="line"><span class="meta">#</span><span class="bash">原来是要建test4上层没先建test3之故！加了这个-p的选项，可以自行帮你建立多层目录！</span></span><br><span class="line"></span><br><span class="line">范例：建立权限为rwx--x--x的目录 </span><br><span class="line">[root@study tmp]# mkdir -m 711 test2 </span><br><span class="line">[root@study tmp]# ls -ld test*</span><br><span class="line">drwxr-xr-x. 2 root root 6 Jun 4 19:03 test</span><br><span class="line">drwxr-xr-x. 3 root root 18 Jun 4 19:04 test1</span><br><span class="line">drwx--x--x . 2 root root 6 Jun 4 19:05 test2</span><br><span class="line"><span class="meta"> #</span><span class="bash">仔细看上面的权限部分，如果没有加上-m来强制设定属性，系统会使用预设属性。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">那么你的预设属性为何？这要透过底下介绍的<span class="built_in">umask</span>才能了解喔！^_^</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="rmdir-删除『空』的目录"><a href="#rmdir-删除『空』的目录" class="headerlink" title="rmdir (删除『空』的目录)"></a>rmdir (删除『空』的目录)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir [-p] 目录名称</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# rmdir [-p]目录名称</span><br><span class="line">选项与参数：</span><br><span class="line">-p ：连同『上层』『空的』目录也一起删除</span><br><span class="line"></span><br><span class="line">范例：将于mkdir范例中建立的目录(&#x2F;tmp底下)删除掉！</span><br><span class="line">[root@study tmp]# ls -ld test*    &lt;&#x3D;&#x3D;看看有多少目录存在？</span><br><span class="line">drwxr-xr-x. 2 root root 6 Jun 4 19:03 test</span><br><span class="line">drwxr-xr-x. 3 root root 18 Jun 4 19:04 test1</span><br><span class="line">drwx--x--x. 2 root root 6 Jun 4 19:05 test2</span><br><span class="line">[root@study tmp]# rmdir test   &lt;&#x3D;&#x3D;可直接删除掉，没问题 </span><br><span class="line">[root@study tmp]# rmdir test1   &lt;&#x3D;&#x3D;因为尚有内容，所以无法删除！</span><br><span class="line">rmdir: failed to remove &#39;test1&#39;: Directory not empty</span><br><span class="line">[root@study tmp]# rmdir -p test1&#x2F;test2&#x2F;test3&#x2F;test4 </span><br><span class="line">[root@study tmp]# ls -ld test*     &lt;&#x3D;&#x3D;您看看，底下的输出中test与test1不见了！</span><br><span class="line">drwx--x--x. 2 root root 6 Jun 4 19:05 test2</span><br><span class="line"># 瞧！利用-p 这个选项，立刻就可以将test1&#x2F;test2&#x2F;test3&#x2F;test4 一次删除～</span><br><span class="line"># 不过要注意的是，这个rmdir 仅能『删除空的目录』喔！</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;p center large&gt;&lt;red&gt;鸟哥私房菜【六】&lt;/red&gt;&lt;/p&gt;&lt;/center&gt;&lt;center&gt;&lt;red&gt;http://linux.vbird.org/linux_basic/&lt;/red&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="linux" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux/"/>
    
    
      <category term="linux" scheme="https://longlongqin.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>LearnCpp chapterP</title>
    <link href="https://longlongqin.github.io/archives/67343d3.html"/>
    <id>https://longlongqin.github.io/archives/67343d3.html</id>
    <published>2020-04-14T08:48:27.000Z</published>
    <updated>2020-04-19T14:38:29.546Z</updated>
    
    <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapterP</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h2 id="S-4-4b-介绍std-string"><a href="#S-4-4b-介绍std-string" class="headerlink" title="S.4.4b 介绍std::string"></a>S.4.4b 介绍<code>std::string</code></h2><p>字符串在程序中很常见，大部分现代编程语言都包括一个内置的字符串数据类型。C++包括一个，不是作为核心语言的一部分，而是作为标准库的一部分。</p><h3 id="std-string"><a href="#std-string" class="headerlink" title="std::string"></a>std::string</h3><p>如果想在C++中使用string类型。需要加入头文件<code>#include &lt;string&gt;</code>来声明std::string。只要有这个头文件，我们就可以在程序中使用string类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> myName;</span><br></pre></td></tr></table></figure><p>就像其他类型一样，你可以为字符串类型的变量进行初始化 或者 复制：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> myName&#123; <span class="string">"Alex"</span> &#125;; <span class="comment">// initialize myName with string literal "Alex"</span></span><br><span class="line">myName = <span class="string">"John"</span>; <span class="comment">// assign variable myName the string literal "John"</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>字符串也可以保存数字</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> myID&#123; <span class="string">"45"</span> &#125;; <span class="comment">// "45" is not the same as integer 45!</span></span><br></pre></td></tr></table></figure><p><strong>字符串格式的 数字，其实是文本形式，而不是 数字形式。</strong></p></blockquote><h3 id="输入输出字符串"><a href="#输入输出字符串" class="headerlink" title="输入输出字符串"></a>输入输出字符串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> myName&#123; <span class="string">"Alex"</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"My name is: "</span> &lt;&lt; myName &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************打印***********/</span></span><br><span class="line">My name is: Alex</span><br></pre></td></tr></table></figure><p>但是，使用<code>std::cin</code>来输入字符串，可能会产生异常：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter your full name: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; name; <span class="comment">// this won't work as expected since std::cin breaks on whitespace</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter your age: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> age;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; age;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Your name is "</span> &lt;&lt; name &lt;&lt; <span class="string">" and your age is "</span> &lt;&lt; age &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LearnCpp-chapterS/image-20200414171736561.png" alt="image-20200414171736561"></p><p>可以看到，<code>大 魔头</code>中间有空格。然后就会被自动截断，前一部分赋值给变量name；第二半段赋值给age。</p><blockquote><p>也就是说：那是不对的!发生了什么事?结果表明，当使用操作符&gt;&gt;从cin提取字符串时，操作符&gt;&gt;只返回它遇到的第一个空格之前的字符。其他字符留在cin中，等待下一次提取。</p></blockquote><h3 id="用std-getline-输入文本"><a href="#用std-getline-输入文本" class="headerlink" title="用std::getline()输入文本"></a>用<code>std::getline()</code>输入文本</h3><p>要将<strong>整行</strong>输入读入字符串，<strong>我们最好需要使用<code>std::getline()</code></strong>函数。</p><blockquote><p><code>std::getline()</code>含有两个形参：<strong>第一个是<code>std::cin</code></strong>；<strong>第二个是我们输入的字符串的变量</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter your full name: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, name); <span class="comment">// read a full line of text into name</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter your age: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> age&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, age); <span class="comment">// read a full line of text into age</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Your name is "</span> &lt;&lt; name &lt;&lt; <span class="string">" and your age is "</span> &lt;&lt; age &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果**************/</span></span><br><span class="line">Enter your full name: John Doe</span><br><span class="line">Enter your age: <span class="number">23</span></span><br><span class="line">Your name is John Doe <span class="keyword">and</span> your age is <span class="number">23</span></span><br></pre></td></tr></table></figure><h3 id="混合使用std-cin、std-getline"><a href="#混合使用std-cin、std-getline" class="headerlink" title="混合使用std::cin、std::getline()"></a>混合使用<code>std::cin</code>、<code>std::getline()</code></h3><p>混合使用他俩，可能会产生异常：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Pick 1 or 2: "</span>;</span><br><span class="line">    <span class="keyword">int</span> choice&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; choice;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Now enter your name: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, name);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, "</span> &lt;&lt; name &lt;&lt; <span class="string">", you picked "</span> &lt;&lt; choice &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序首先要求您输入1或2，然后等待您这样做。到目前为止一切顺利。然后它会要求你输入你的名字。然而，它实际上不会等待您输入您的名字！相反，它打印“Hello”行，然后退出。发生了什么事?</p><blockquote><p>结果是，当您使用cin输入一个值时，<strong>cin不仅捕获值，还捕获换行符</strong>。当我们输入2时，cin实际上会得到字符串“2\n”。然后提取2到变量选择，使换行留在输入流中。然后，当std::getline()去读取名称时，它会看到“\n”已经在流中，并且认为我们必须输入一个空字符串!绝对不是我们想要的。</p></blockquote><hr><p>一个好方法：<strong>使用<code>std::cin</code>读取完值 之后，将换行 从输入流中删除</strong>：</p><blockquote><p><code>std::cin.ignore(32767, &#39;\n&#39;);</code> //忽略不超过32767个字符，直到删除一个\n.</p><p>关于<code>32767</code>请看下一节</p></blockquote><p>如下，在main函数中，增加一句<code>std::cin.ignore(32767, &#39;\n&#39;);</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Pick 1 or 2: "</span>;</span><br><span class="line"><span class="keyword">int</span> choice&#123;&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; choice;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//新加</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="number">32767</span>, <span class="string">'\n'</span>); <span class="comment">// ignore up to 32767 characters until a \n is removed</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Now enter your name: "</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line"><span class="built_in">std</span>::getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, name);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, "</span> &lt;&lt; name &lt;&lt; <span class="string">", you picked "</span> &lt;&lt; choice &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>规则:<strong>如果使用<code>std::cin</code>读取值</strong>，<strong>最好使用<code>std:: cin .ignore()</code>来删除多余的换行符。</strong></p></blockquote><hr><h3 id="32767代表什么"><a href="#32767代表什么" class="headerlink" title="32767代表什么"></a><code>32767</code>代表什么</h3><p>这告诉<code>std::cin.ignore()</code>要忽略多少字符。我们选择<code>32767</code>是因为它是保证在所有平台上都适合(2字节)整数的最大带符号值。</p><blockquote><p>从技术上讲，忽略无限量输入的正确方法如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>); <span class="comment">// ignore unlimited characters until a \n is removed</span></span><br></pre></td></tr></table></figure><p>但是，相比之下，这样的方式太复杂了。而且还需要加上头文件<code>limits</code></p></blockquote><h3 id="字符串的“加法”"><a href="#字符串的“加法”" class="headerlink" title="字符串的“加法”"></a>字符串的“加法”</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> a&#123; <span class="string">"45"</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> b&#123; <span class="string">"11"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a + b &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// a and b will be concatenated</span></span><br><span class="line">    a += <span class="string">"volts"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*****结果********/</span></span><br><span class="line"><span class="number">4511</span></span><br><span class="line"><span class="number">45</span>volts</span><br></pre></td></tr></table></figure><blockquote><p>注意，如果你想对<strong>字符串减法，是不可以的熬</strong></p></blockquote><h3 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> myName&#123; <span class="string">"Alex"</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; myName &lt;&lt; <span class="string">" has "</span> &lt;&lt; myName.length() &lt;&lt; <span class="string">" characters\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; myName &lt;&lt; <span class="string">" has "</span> &lt;&lt; length(myName) &lt;&lt; <span class="string">" characters\n"</span>;<span class="comment">//error:未定义标识符 length</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，我们不是将字符串长度作为length(myName)，而是使用myName.length()。</p><blockquote><p>length函数不是我们目前使用的一个普通的独立函数，它是属于std::string的一种特殊类型的函数，称为成员函数。</p></blockquote><h2 id="S-4-4c-使用语言参考"><a href="#S-4-4c-使用语言参考" class="headerlink" title="S.4.4c 使用语言参考"></a>S.4.4c 使用语言参考</h2><p>本节原文地址：<a href="https://www.learncpp.com/cpp-tutorial/using-a-language-reference/" target="_blank" rel="noopener"><strong>S.4.4c — Using a language reference</strong></a></p><blockquote><p>其中一个资源是<a href="https://stackoverflow.com/" target="_blank" rel="noopener"><strong>Stack Overflow</strong></a>，你可以在这里提问；</p><p>另一个就是语言参考文档： <strong><a href="https://cppreference.com/" target="_blank" rel="noopener">cppreference</a></strong>；</p></blockquote><h2 id="S-4-5-枚举类型"><a href="#S-4-5-枚举类型" class="headerlink" title="S.4.5 枚举类型"></a>S.4.5 枚举类型</h2><p>c++包含允许程序员创建自己的数据类型的功能。这些数据类型称为<strong>用户定义的数据类型</strong>。</p><p><strong>枚举类型</strong>(也称为<strong>enumeration</strong>或<strong>enum</strong>)是一种数据类型，其中每个可能的值都被定义为<strong>符号常量</strong>(称为<strong>enumerator(枚举器)</strong>)。枚举是通过enum关键字定义的。让我们来看一个例子:</p><blockquote><p>注意，每个枚举数由<strong>逗号</strong>分隔，整个枚举以<strong>分号</strong>结束。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Define a new enumeration named Color</span></span><br><span class="line"><span class="keyword">enum</span> Color</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Here are the enumerators</span></span><br><span class="line">    <span class="comment">// These define all the possible values this type can hold</span></span><br><span class="line">    <span class="comment">// Each enumerator is separated by a comma, not a semicolon</span></span><br><span class="line">    COLOR_BLACK,</span><br><span class="line">    COLOR_RED,</span><br><span class="line">    COLOR_BLUE,</span><br><span class="line">    COLOR_GREEN,</span><br><span class="line">    COLOR_WHITE,</span><br><span class="line">    COLOR_CYAN,</span><br><span class="line">    COLOR_YELLOW,</span><br><span class="line">    COLOR_MAGENTA, <span class="comment">// see note about trailing comma on the last enumerator below</span></span><br><span class="line">&#125;; <span class="comment">// however the enum itself must end with a semicolon</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Define a few variables of enumerated type Color</span></span><br><span class="line">Color paint = COLOR_WHITE;</span><br><span class="line"><span class="function">Color <span class="title">house</span><span class="params">(COLOR_BLUE)</span></span>;</span><br><span class="line">Color apple &#123; COLOR_RED &#125;;</span><br></pre></td></tr></table></figure><p><strong>定义一个枚举类型(也可以说，定义一个用户自定义类型)时，是不会给它分配内存的</strong>；只有当<strong>定义了枚举类型的变量</strong>(如上面示例中的变量paint)时，才会为<strong>该变量</strong>分配内存。</p><blockquote><p>在c++ 11之前，不允许在最后一个枚举数之后使用逗号(例如，在COLOR_MAGENTA之后)(尽管许多编译器都接受了逗号)。但是，从c++ 11开始，允许使用逗号结尾。现在c++ 11编译器更加流行了，一般认为在最后一个元素后面使用逗号是可以接受的。</p></blockquote><h3 id="枚举的命名和枚举器"><a href="#枚举的命名和枚举器" class="headerlink" title="枚举的命名和枚举器"></a>枚举的命名和枚举器</h3><p><strong>枚举的命名是可选的</strong>，通常，没有名字的枚举有时被称为<strong>匿名枚举</strong>。枚举的名字通常以大写字母开头。</p><p><strong>枚举器(枚举常量)</strong>是必须要给出名字的。它的名字通常是大写字母(如，COLOR_WHITE)，或者以大写字母K为前缀(如， kColorWhite)</p><h3 id="枚举常量的范围"><a href="#枚举常量的范围" class="headerlink" title="枚举常量的范围"></a>枚举常量的范围</h3><p>因为枚举常量被放在与枚举相同的命名空间中，所以，枚举常量名字不能用于同一命名空间内的多个枚举:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color</span><br><span class="line">&#123;</span><br><span class="line">RED,</span><br><span class="line">BLUE, <span class="comment">// BLUE is put into the global namespace</span></span><br><span class="line">GREEN</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">enum</span> Feeling</span><br><span class="line">&#123;</span><br><span class="line">HAPPY,</span><br><span class="line">TIRED,</span><br><span class="line">BLUE <span class="comment">// error, BLUE was already used in enum Color in the global namespace</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="枚举常量的值"><a href="#枚举常量的值" class="headerlink" title="枚举常量的值"></a>枚举常量的值</h3><p>每个枚举器根据其在枚举列表中的位置自动分配一个整数值。<strong>默认情况下，第一个枚举数被赋值为整数值0，随后的每个枚举数的值都比前一个枚举数大1:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color</span><br><span class="line">&#123;</span><br><span class="line">    COLOR_BLACK, <span class="comment">// assigned 0</span></span><br><span class="line">    COLOR_RED, <span class="comment">// assigned 1</span></span><br><span class="line">    COLOR_BLUE, <span class="comment">// assigned 2</span></span><br><span class="line">    COLOR_GREEN, <span class="comment">// assigned 3</span></span><br><span class="line">    COLOR_WHITE, <span class="comment">// assigned 4</span></span><br><span class="line">    COLOR_CYAN, <span class="comment">// assigned 5</span></span><br><span class="line">    COLOR_YELLOW, <span class="comment">// assigned 6</span></span><br><span class="line">    COLOR_MAGENTA <span class="comment">// assigned 7</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">Color <span class="title">paint</span><span class="params">(COLOR_WHITE)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; paint;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********结果*********/</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><hr><p><strong>你也可以显式定义枚举数的值</strong>。</p><blockquote><p>这些整数值可以是正的，也可以是负的，并且可以与其他枚举数共享相同的值。任何未定义的枚举数都被赋予一个比前一个枚举数大1的值。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define a new enum named Animal</span></span><br><span class="line"><span class="keyword">enum</span> Animal</span><br><span class="line">&#123;</span><br><span class="line">    ANIMAL_CAT = <span class="number">-3</span>,</span><br><span class="line">    ANIMAL_DOG, <span class="comment">// assigned -2</span></span><br><span class="line">    ANIMAL_PIG, <span class="comment">// assigned -1</span></span><br><span class="line">    ANIMAL_HORSE = <span class="number">5</span>,</span><br><span class="line">    ANIMAL_GIRAFFE = <span class="number">5</span>, <span class="comment">// shares same value as ANIMAL_HORSE</span></span><br><span class="line">    ANIMAL_CHICKEN <span class="comment">// assigned 6</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>注意到：<code>ANIMAL_HORSE</code>和<code>ANIMAL_GIRAFFE</code>的值相同。这表示他们两个可以互换。即，它俩没区别。</p><p>虽然，C++允许这样，但是不建议将枚举常量赋值位相同的值。</p></blockquote><h3 id="枚举类型的input-output"><a href="#枚举类型的input-output" class="headerlink" title="枚举类型的input/output"></a>枚举类型的input/output</h3><p>因为枚举值是整数类型的，所以它们可以被赋值给整型变量。这意味着它们可以 以integers形式被output，因为<code>std::cout</code>知道如何输出整数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mypet = ANIMAL_PIG;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ANIMAL_PIG;<span class="comment">//evaluates to integer before being passed to std::cout</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******结果*****/</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><hr><ul><li><p><strong>编译器不会隐式的将整型转变为枚举类型值。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="number">5</span>; <span class="comment">// will cause compiler error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但是我们可以使用 static_cast 来强制转换</span></span><br><span class="line">Color color = <span class="keyword">static_cast</span>&lt;Color&gt;(<span class="number">5</span>); <span class="comment">// ugly</span></span><br></pre></td></tr></table></figure></li><li><p><strong>编译器也不会让你输入一个枚举类型：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color</span><br><span class="line">&#123;</span><br><span class="line">    COLOR_BLACK, <span class="comment">// assigned 0</span></span><br><span class="line">    COLOR_RED, <span class="comment">// assigned 1</span></span><br><span class="line">    COLOR_BLUE, <span class="comment">// assigned 2</span></span><br><span class="line">    COLOR_GREEN, <span class="comment">// assigned 3</span></span><br><span class="line">    COLOR_WHITE, <span class="comment">// assigned 4</span></span><br><span class="line">    COLOR_CYAN, <span class="comment">// assigned 5</span></span><br><span class="line">    COLOR_YELLOW, <span class="comment">// assigned 6</span></span><br><span class="line">    COLOR_MAGENTA <span class="comment">// assigned 7</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Color color;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; color; <span class="comment">// will cause compiler error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但是，我们可以通过读取一个整型，并使用static_cast来强制编译器将整型值放入枚举类型中：</span></span><br><span class="line"><span class="keyword">int</span> inputColor;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt; inpitColor;</span><br><span class="line"></span><br><span class="line">Color color&#123; <span class="keyword">static_cast</span>&lt;Color&gt;(inputColor) &#125;;</span><br></pre></td></tr></table></figure></li><li><p>每个枚举类型都被认为是不同的类型。因此，试图将枚举数从一个枚举类型分配到另一个枚举类型将导致编译错误:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal animal&#123; COLOR_BLUE &#125;; <span class="comment">// will cause compiler error</span></span><br></pre></td></tr></table></figure></li><li><p><strong>如果您想为枚举器使用不同的整数类型</strong>，你可以您可以在enum声明中指定它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use an 8 bit unsigned integer as the enum base.</span></span><br><span class="line"><span class="keyword">enum</span> Color : <span class="built_in">std</span>::<span class="keyword">uint_least8_t</span></span><br><span class="line">&#123;</span><br><span class="line">    COLOR_BLACK,</span><br><span class="line">    COLOR_RED,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>枚举类型的提前声明</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color; <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">enum</span> Color : <span class="keyword">int</span>; <span class="comment">// Okay</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Because Color was forward declared with a fixed base, we</span></span><br><span class="line"><span class="comment">// need to specify the base again at the definition.</span></span><br><span class="line"><span class="keyword">enum</span> Color : <span class="keyword">int</span></span><br><span class="line">&#123;</span><br><span class="line">    COLOR_BLACK,</span><br><span class="line">    COLOR_RED,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Enum分配和提前声明"><a href="#Enum分配和提前声明" class="headerlink" title="Enum分配和提前声明"></a>Enum分配和提前声明</h3><p>Enum类型被认为是整数类型家族的一部分，它由编译器决定为Enum变量分配多少内存。c++标准要求枚举的大小必须足够大，以表示所有枚举值。通常，它会使<strong>enum变量的大小与标准int相同</strong>。</p><hr><p>因为编译器知道给枚举类型分配多少内存，<strong>所以您只能在指定固定基数时，才可以提前声明它们</strong>。</p><h3 id="枚举器有什么用"><a href="#枚举器有什么用" class="headerlink" title="枚举器有什么用?"></a>枚举器有什么用?</h3><p>当需要表示特定的预定义状态集时，枚举类型对于代码文档和可读性非常有用。</p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readFileContents</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!openFile())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!readFile())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">if</span> (!parseFile())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// success</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>负数用来表示不同的可能的错误代码</strong>。如上面：<code>-1</code> <code>-2</code> <code>-3</code></p></blockquote><p>然而，使用像这样的神奇数字并不是很有描述性。<strong>另一种方法是使用枚举类型</strong>：</p><blockquote><p>这种方法可读性更强。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> ParseResult</span><br><span class="line">&#123;</span><br><span class="line">    SUCCESS = <span class="number">0</span>,</span><br><span class="line">    ERROR_OPENING_FILE = <span class="number">-1</span>,</span><br><span class="line">    ERROR_READING_FILE = <span class="number">-2</span>,</span><br><span class="line">    ERROR_PARSING_FILE = <span class="number">-3</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">ParseResult <span class="title">readFileContents</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!openFile())</span><br><span class="line">        <span class="keyword">return</span> ERROR_OPENING_FILE;</span><br><span class="line">    <span class="keyword">if</span> (!readFile())</span><br><span class="line">        <span class="keyword">return</span> ERROR_READING_FILE;</span><br><span class="line">    <span class="keyword">if</span> (!parsefile())</span><br><span class="line">        <span class="keyword">return</span> ERROR_PARSING_FILE;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用者可以根据适当的枚举器测试函数的返回值，这比测试特定整数值的返回结果更容易理解。</p><p>如：</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (readFileContents() == SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// print error message</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></blockquote><hr><p>许多语言使用枚举定义布尔值。布尔值本质上就是一个有两个枚举器的枚举:false和true!然而，在c++中，true和false被定义为关键字，而不是枚举数。</p><h2 id="S-4-6-枚举类"><a href="#S-4-6-枚举类" class="headerlink" title="S.4.6 枚举类"></a>S.4.6 枚举类</h2><p>C++11定义了一个新概念，<strong>enum class(枚举类)</strong>，也称 <strong>scoped enumeration（作用域枚举）</strong>。我们在enum之后使用<strong>关键字 <code>class</code></strong>来构造枚举类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> // "<span class="title">enum</span> <span class="title">class</span>" <span class="title">defines</span> <span class="title">this</span> <span class="title">as</span> <span class="title">a</span> <span class="title">scoped</span> <span class="title">enumeration</span> <span class="title">instead</span> <span class="title">of</span> <span class="title">a</span> <span class="title">standard</span> <span class="title">enumeration</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        red, <span class="comment">// red is inside the scope of Color</span></span><br><span class="line">        blue</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        banana, <span class="comment">// banana is inside the scope of Fruit</span></span><br><span class="line">        apple</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    Color color&#123; Color::red &#125;; <span class="comment">// note: red is not directly accessible any more, we have to use Color::red</span></span><br><span class="line">    Fruit fruit&#123; Fruit::banana &#125;; <span class="comment">// note: banana is not directly accessible any more, we have to use Fruit::banana</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (color == fruit) <span class="comment">// compile error here, as the compiler doesn't know how to compare different types Color and Fruit</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"color and fruit are equal\n"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"color and fruit are not equal\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>对于正常的枚举，枚举器被放置在与枚举本身相同的范围内</strong>。所以，我们可以直接访问枚举器(枚举常量). (e.g. red).</p><blockquote><p>因为枚举器是enum类的一部分，所以不需要在枚举器名称前面加上前缀(例如，可以使用red而不是COLOR_red，因为Color::COLOR_red是多余的)。</p></blockquote></li><li><p>但是，<strong>在枚举类中，严格的范围规则意味着所有的枚举器(枚举常量)是枚举的一部分。</strong>所以，我们必须使用必须使用范围限定符来访问枚举器(例如，Color::red)。</p><blockquote><p>这有助于降低名称污染和名称冲突的可能性。</p></blockquote><blockquote><p>强类型规则意味着每个enum类都被认为是唯一的类型。这意味着编译器不会隐式地比较来自不同枚举的枚举数。如果尝试这样做，编译器将抛出一个错误，如上面的示例所示。</p></blockquote></li></ul><hr><p>然而，你仍然可以<strong>在同一枚举类 内部进行 枚举常量的比较</strong>(因为让门属于同一类型)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        red,</span><br><span class="line">        blue</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    Color color&#123; Color::red &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (color == Color::red) <span class="comment">// this is okay(这样是可以的)</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The color is red!\n"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (color == Color::blue)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The color is blue!\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用enum类，编译器将不再隐式地将枚举数值转换为整数。</strong>这基本上是一件好事。但是，在某些情况下，这样做是有用的。在这些情况下，<strong>可以使用static_cast将enum类枚举数显式转换为整数:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        red,</span><br><span class="line">        blue</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    Color color&#123; Color::blue &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; color; <span class="comment">// won't work, because there's no implicit conversion to int</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(color); <span class="comment">// will print 1</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【note】万一你遇到它，“<strong>enum struct</strong>”相当于“<strong>enum class</strong>”。但这种用法不推荐，也不常用。</p><h2 id="S-4-7-struct"><a href="#S-4-7-struct" class="headerlink" title="S.4.7 struct"></a>S.4.7 <code>struct</code></h2><p>c++允许我们创建自己的用户定义的<strong>aggregate data types(聚集数据类型)</strong>。</p><blockquote><p><strong>聚集数据类型：是将多个单独变量分组在一起的数据类型</strong></p></blockquote><p><strong><code>struct</code></strong>就是聚集数据类型的最简单之一。</p><h3 id="struct的定义-amp-声明"><a href="#struct的定义-amp-声明" class="headerlink" title="struct的定义&amp;声明"></a>struct的定义&amp;声明</h3><p>因为structs是用户自定义的，所以我们首先要在使用它之前，必须要告诉编译器我们的struct是什么样的。</p><blockquote><p>我们使用<code>struct</code>关键字声明结构体。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//告诉编译器我们定义了一个结构体，名为Employee</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    short id;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> wage;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//这些结构中的变量称为  **成员(或字段)**。</span></span><br></pre></td></tr></table></figure><blockquote><p>记住，<strong>上面的<code>Employee</code>只是一个声明</strong>。<strong>尽管我们告诉编译器结构体将有成员变量，但此时没有分配内存</strong>。按照惯例，结构名以大写字母开头，以便与变量名区分开来。</p></blockquote><hr><ul><li><p>为了使用Employee结构，我们只需声明一个类型为Employee的变量:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employee joe; <span class="comment">// struct Employee is capitalized, variable joe is not</span></span><br></pre></td></tr></table></figure><blockquote><p>这<strong>定义</strong>了一个名为joe的Employee类型的变量。与普通变量一样，定义结构变量为该变量分配内存。</p></blockquote></li></ul><h3 id="访问结构体成员"><a href="#访问结构体成员" class="headerlink" title="访问结构体成员"></a>访问结构体成员</h3><p>当我们定义一个变量如<code>Employee joe</code>时，joe引用整个结构(包含成员变量)。为了访问各个成员，我们使用<strong>member selection operator(成员选择操作符)</strong>。下面是一个使用成员选择操作符初始化每个成员变量的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Employee joe; <span class="comment">// create an Employee struct for Joe</span></span><br><span class="line">joe.id = <span class="number">14</span>; <span class="comment">// assign a value to member id within struct joe</span></span><br><span class="line">joe.age = <span class="number">32</span>; <span class="comment">// assign a value to member age within struct joe</span></span><br><span class="line">joe.wage = <span class="number">24.15</span>; <span class="comment">// assign a value to member wage within struct joe</span></span><br><span class="line"> </span><br><span class="line">Employee frank; <span class="comment">// create an Employee struct for Frank</span></span><br><span class="line">frank.id = <span class="number">15</span>; <span class="comment">// assign a value to member id within struct frank</span></span><br><span class="line">frank.age = <span class="number">28</span>; <span class="comment">// assign a value to member age within struct frank</span></span><br><span class="line">frank.wage = <span class="number">18.27</span>; <span class="comment">// assign a value to member wage within struct frank</span></span><br></pre></td></tr></table></figure><blockquote><p>与普通变量一样，结构成员变量没有初始化，通常会包含垃圾。我们必须手动初始化它们。</p></blockquote><ul><li><p>Struct成员变量的作用就像普通变量一样，所以可以对它们进行普通操作:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> totalAge&#123; joe.age + frank.age &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (joe.wage &gt; frank.wage)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Joe makes more than Frank\n"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (joe.wage &lt; frank.wage)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Joe makes less than Frank\n"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Joe and Frank make the same amount\n"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Frank got a promotion</span></span><br><span class="line">frank.wage += <span class="number">2.50</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Today is Joe's birthday</span></span><br><span class="line">++joe.age; <span class="comment">// use pre-increment to increment Joe's age by 1</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="初始化结构体"><a href="#初始化结构体" class="headerlink" title="初始化结构体"></a>初始化结构体</h3><p>通过逐个成员分配值来初始化结构有点麻烦，因此，c++支持使用<strong>initializer list(初始化列表)</strong>来初始化结构体的更快方法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    short id;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> wage;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Employee joe&#123; <span class="number">1</span>, <span class="number">32</span>, <span class="number">60000.0</span> &#125;; <span class="comment">// joe.id = 1, joe.age = 32, joe.wage = 60000.0</span></span><br><span class="line">Employee frank&#123; <span class="number">2</span>, <span class="number">28</span> &#125;; <span class="comment">// frank.id = 2, frank.age = 28, frank.wage = 0.0 (default initialization)</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>在C++11/14中: Non-static member initialization</strong></p><p>从c++ 11开始，可以给非静态(普通)结构成员一个默认值:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> length&#123; <span class="number">1.0</span> &#125;;</span><br><span class="line">    <span class="keyword">double</span> <span class="built_in">width</span>&#123; <span class="number">1.0</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rectangle x; <span class="comment">// length = 1.0, width = 1.0</span></span><br><span class="line"> </span><br><span class="line">    x.length = <span class="number">2.0</span>; <span class="comment">// you can assign other values like normal</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不幸的是，在c++ 11中，<strong>非静态成员初始化语法</strong>与<strong>初始化列表</strong>和<strong>统一的初始化语法</strong>不兼容。例如，在c++ 11中，以下程序无法编译:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">double</span> length&#123; <span class="number">1.0</span> &#125;; <span class="comment">// non-static member initialization</span></span><br><span class="line"><span class="keyword">double</span> <span class="built_in">width</span>&#123; <span class="number">1.0</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Rectangle x&#123; <span class="number">2.0</span>, <span class="number">2.0</span> &#125;; <span class="comment">// uniform initialization/initializer list【推荐】</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>因此，<strong>在c++ 11中</strong>，您必须决定是使用非静态成员初始化还是使用统一初始化。<strong>统一初始化更加灵活，因此我们建议坚持使用这种方法</strong>。</p><p>然而，<strong>在c++ 14中</strong>，这个限制被取消了，两者都可以使用。如果两者都提供了，则优先使用<strong>初始化列表/统一初始化语法（即：initializer list）</strong>。</p><blockquote><p>在上面的例子中，矩形x的length和width将用2.0进行初始化。</p><p><em>在c++ 14中，两者都使用应该是首选的，因为它允许您声明具有或不具有初始化参数的结构，并确保成员已初始化</em></p></blockquote></li></ul><h3 id="对结构体赋值"><a href="#对结构体赋值" class="headerlink" title="对结构体赋值"></a>对结构体赋值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    short id;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> wage;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Employee joe;</span><br><span class="line">joe = &#123; <span class="number">1</span>, <span class="number">32</span>, <span class="number">60000.0</span> &#125;; <span class="comment">// C++11 only(只在C++11中可以使用)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在C++11之前</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    short id;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> wage;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Employee joe;</span><br><span class="line">joe.id = <span class="number">1</span>;</span><br><span class="line">joe.age = <span class="number">32</span>;</span><br><span class="line">joe.wage = <span class="number">60000.0</span>;</span><br></pre></td></tr></table></figure><h3 id="结构体与函数"><a href="#结构体与函数" class="headerlink" title="结构体与函数"></a>结构体与函数</h3><p>与单个变量相比，使用struct的一大好处是，我们可以将整个struct传递给一个需要与成员协同工作的函数:</p><blockquote><p>这避免了我们必须单独传递每个变量。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    short id;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> wage;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printInformation</span><span class="params">(Employee employee)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ID:   "</span> &lt;&lt; employee.id &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Age:  "</span> &lt;&lt; employee.age &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Wage: "</span> &lt;&lt; employee.wage &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Employee joe &#123; <span class="number">14</span>, <span class="number">32</span>, <span class="number">24.15</span> &#125;;</span><br><span class="line">    Employee frank &#123; <span class="number">15</span>, <span class="number">28</span>, <span class="number">18.27</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Print Joe's information</span></span><br><span class="line">    printInformation(joe);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Print Frank's information</span></span><br><span class="line">    printInformation(frank);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******结果*********/</span></span><br><span class="line">ID:   <span class="number">14</span></span><br><span class="line">Age:  <span class="number">32</span></span><br><span class="line">Wage: <span class="number">24.15</span></span><br><span class="line"></span><br><span class="line">ID:   <span class="number">15</span></span><br><span class="line">Age:  <span class="number">28</span></span><br><span class="line">Wage: <span class="number">18.27</span></span><br></pre></td></tr></table></figure><blockquote><p>我们将整个Employee结构传递给<code>printInformation()</code> (通过值传递，这意味着实参<u>被复制</u>到形参中)。</p></blockquote><ul><li><p><strong>函数的返回可以是一个结构体：</strong></p><blockquote><p>一个函数也可以返回一个结构体，<strong>这是使一个函数返回多个变量的几种方法之一</strong>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point3d</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    <span class="keyword">double</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">Point3d <span class="title">getZeroPoint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// We can create a variable and return the variable.</span></span><br><span class="line">    Point3d temp &#123; <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Point3d <span class="title">getZeroPoint2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// We can return directly. We already specified the type</span></span><br><span class="line">    <span class="comment">// at the function declaration (Point3d), so we don't need</span></span><br><span class="line">    <span class="comment">// it again here.</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Point3d <span class="title">getZeroPoint3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// We can use empty curly braces to zero-initialize all</span></span><br><span class="line">    <span class="comment">// members of `Point3d`.</span></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point3d zero&#123; getZeroPoint() &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (zero.x == <span class="number">0.0</span> &amp;&amp; zero.y == <span class="number">0.0</span> &amp;&amp; zero.z == <span class="number">0.0</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The point is zero\n"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The point is not zero\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="结构体嵌套"><a href="#结构体嵌套" class="headerlink" title="结构体嵌套"></a>结构体嵌套</h3><p>结构体可以包含其他结构体。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    short id;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> wage;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Company</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Employee CEO; <span class="comment">// Employee is a struct within the Company struct</span></span><br><span class="line">    <span class="keyword">int</span> numberOfEmployees;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Company myCompany;</span><br><span class="line"><span class="comment">//我们可以使用初始化列表初始化它们：</span></span><br><span class="line"><span class="comment">//Company myCompany&#123;&#123; 1, 42, 60000.0 &#125;, 5 &#125;;</span></span><br></pre></td></tr></table></figure><h3 id="结构体的大小"><a href="#结构体的大小" class="headerlink" title="结构体的大小"></a>结构体的大小</h3><ul><li><p>结构体的大小是所有成员大小的总和，但这不是一定的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    short id;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> wage;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The size of Employee is "</span> &lt;&lt; <span class="keyword">sizeof</span>(Employee) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******结果*************/</span></span><br><span class="line">The <span class="built_in">size</span> of Employee is <span class="number">16</span></span><br></pre></td></tr></table></figure><blockquote><p>结果是，<strong>我们只能说结构体的大小至少与它所包含的所有变量的大小一样大</strong>。<strong>但它可以更大!</strong> <u>出于性能原因，编译器有时会在结构中添加空白(这称为<strong>padding(填充)</strong>)。</u></p></blockquote><p>事实上，上面程序中的<code>Employee</code>结构体中，编译器在成员<code>id</code>的后面添加了2个字节的填充(这是不可见的)。所以才导结构的大小为16字节，而不是14字节。</p></li></ul><p>本课介绍的结构有时被称为<strong>plain old data structs(普通旧数据结构)</strong>(或<strong>POD结构</strong>)，因为成员都是数据(变量)成员。将来(当我们讨论类时)，我们将讨论其他类型的成员</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;p center large&gt;&lt;red&gt;LearnCpp chapterP&lt;/red&gt;&lt;/p&gt;&lt;/center&gt;&lt;center&gt;&lt;red&gt;https://www.learncpp.com&lt;/red&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C/C++" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"/>
    
    
      <category term="C/C++" scheme="https://longlongqin.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>LearnCpp chapterP</title>
    <link href="https://longlongqin.github.io/archives/67343d3.html"/>
    <id>https://longlongqin.github.io/archives/67343d3.html</id>
    <published>2020-04-14T08:42:47.783Z</published>
    <updated>2020-04-19T14:38:29.545Z</updated>
    
    <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapterP</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;p center large&gt;&lt;red&gt;LearnCpp chapterP&lt;/red&gt;&lt;/p&gt;&lt;/center&gt;&lt;center&gt;&lt;red&gt;https://www.learncpp.com&lt;/red&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C/C++" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"/>
    
    
      <category term="C/C++" scheme="https://longlongqin.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>【转】Github下载提速</title>
    <link href="https://longlongqin.github.io/archives/260c7660.html"/>
    <id>https://longlongqin.github.io/archives/260c7660.html</id>
    <published>2020-04-13T15:21:08.000Z</published>
    <updated>2020-04-19T14:38:29.546Z</updated>
    
    <content type="html"><![CDATA[<center><p center large><red>Github克隆&下载提速</red></p></center><p>以上内容转载于：<a href="https://mp.weixin.qq.com/s/SYR4zvjhAH1mX9fxdp8cbA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/SYR4zvjhAH1mX9fxdp8cbA</a></p><p>原作者：codesheep</p><a id="more"></a><h1 id="一个痛点"><a href="#一个痛点" class="headerlink" title="一个痛点"></a>一个痛点</h1><p>众所周知，GitHub是一个巨大的开源宝库，以及程序员和编程爱好者的聚集地，包括我之前推荐的诸多优秀的开源项目全部都是位于GitHub上。</p><p>但是每当我们看到优秀的开源项目，准备去<strong>下（bai）载（piao）</strong>时，会发现 <code>git clone</code>的速度异常之慢！就我个人而言，在我家里200M移动宽带的环境下，我克隆开源项目就没发现速度大于过 <code>20.00KiB/s</code>的时候，这简直太难受了。</p><p>小项目倒还好，我等几分钟无所谓；一旦项目庞大起来，或者项目文件数目一多， <code>git clone</code> 大概率会失败！</p><p>当然网上常见的诸如修改hosts、代理等方式实际使用效果并不一定好，而且也不稳定。</p><hr><h1 id="“码云”是个好东西"><a href="#“码云”是个好东西" class="headerlink" title="“码云”是个好东西"></a>“码云”是个好东西</h1><p>接下来就介绍一种GitHub下载的加速方法：通过国内<strong>码云平台</strong>的转接，来完成GitHub上项目的下载加速。</p><blockquote><p>感谢公众号小伙伴ioc提供思路</p></blockquote><p><strong>（1）首先确保码云上有账户，可以正常使用，没有的可以自行注册一下。</strong></p><p><strong>（2）点击右上角新建仓库的加号 <code>+</code>，选择“从 <code>GitHub/GitLab</code>导入仓库”菜单</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LearnCpp-chapter3/640-1584014932491.jpg" alt="640-1584014932491"></p><p><strong>（3）然后填写位于 <code>GitHub</code>上你想 <code>clone</code>的仓库地址并导入</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/githubaddress.jpg" alt="img"></p><p>这一步<strong>交给码云来做</strong>速度是非常快的，一会儿功夫，码云就克隆出了一份和GitHub上一模一样的项目！</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/1640.jpg" alt="1640"></p><p><strong>（4）接下来我们通过码云上的项目地址，将项目 <code>clone</code>到本地，这时候的clone速度就很快了，几 <code>MB/s</code>的速度是没问题的，很快项目就下载下来了。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/640-1583735421332.jpg" alt="640-1583735421332"></p><p>按道理讲这时候我们的目的已经达到了，不过不要忘了，还有一件事没做。</p><hr><h1 id="重新关联远端地址"><a href="#重新关联远端地址" class="headerlink" title="重新关联远端地址"></a>重新关联远端地址</h1><p>要知道，这时候克隆到本地的项目关联的是码云Gitee的地址，已经和原来的GitHub项目<strong>完全脱离了</strong>，是另外一个<strong>副本</strong>。</p><p>在必要情况下（比如我们就是要给GitHub上的某个项目提 <code>PR</code>），我们还需要重新将我们本地的项目关联到原来的GitHub项目上去，做法如下：</p><p><strong>（1）首先找到位于本地仓库目录下的隐藏文件夹 <code>.git</code></strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/640-1583735421410.jpg" alt="640-1583735421410"></p><p><strong>（2）用文本编辑器打开 <code>.git</code>文件夹中的 <code>config</code>配置文件</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/640-1583735421407.jpg" alt="640-1583735421407"></p><p>将配置文件中的 <code>[remote&quot;origin&quot;].url</code>字段重新关联到原来位于GitHub上的GitHub项目地址</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200317025816112.png" alt="image-20200317025816112"></p><blockquote><p>当然你也可以通过命令行来修改远端地址，效果一样的</p></blockquote><p>至此大功告成，本地项目就相当于是 <code>clone</code>自GitHub，后续提代码，提 <code>PR</code>到GitHub上都没有问题。</p><p>以上内容转载于：<a href="https://mp.weixin.qq.com/s/SYR4zvjhAH1mX9fxdp8cbA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/SYR4zvjhAH1mX9fxdp8cbA</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;p center large&gt;&lt;red&gt;Github克隆&amp;下载提速&lt;/red&gt;&lt;/p&gt;&lt;/center&gt;&lt;p&gt;以上内容转载于：&lt;a href=&quot;https://mp.weixin.qq.com/s/SYR4zvjhAH1mX9fxdp8cbA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/SYR4zvjhAH1mX9fxdp8cbA&lt;/a&gt;&lt;/p&gt;&lt;p&gt;原作者：codesheep&lt;/p&gt;
    
    </summary>
    
    
      <category term="实用技巧" scheme="https://longlongqin.github.io/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="github" scheme="https://longlongqin.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>【转】配置方法集合</title>
    <link href="https://longlongqin.github.io/archives/6de95ae.html"/>
    <id>https://longlongqin.github.io/archives/6de95ae.html</id>
    <published>2020-04-13T15:21:08.000Z</published>
    <updated>2020-04-19T14:38:29.546Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><ol><li><strong>WSL 使用指南</strong>：<a href="https://zhuanlan.zhihu.com/p/36482795" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/36482795</a></li><li><strong>OpenCV安装配置</strong>： <a href="http://blog.csdn.net/poem_qianmo/article/details/19809337" target="_blank" rel="noopener">http://blog.csdn.net/poem_qianmo/article/details/19809337</a></li><li><strong>onedrive无法启动</strong>：<a href="https://blog.ooolg.com/index.php/20190121/568=568.html" target="_blank" rel="noopener">https://blog.ooolg.com/index.php/20190121/568=568.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;WSL 使用指南&lt;/strong&gt;：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/36482795&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zh
      
    
    </summary>
    
    
      <category term="配置" scheme="https://longlongqin.github.io/categories/%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="配置" scheme="https://longlongqin.github.io/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>鸟哥私房菜linux</title>
    <link href="https://longlongqin.github.io/archives/7a585be8.html"/>
    <id>https://longlongqin.github.io/archives/7a585be8.html</id>
    <published>2020-04-08T18:01:59.000Z</published>
    <updated>2020-04-19T14:38:29.546Z</updated>
    
    <content type="html"><![CDATA[<center><p center large><red>鸟哥私房菜</red></p></center><center><red>http://linux.vbird.org/linux_basic/</red></center><a id="more"></a><h1 id="5️⃣Linux的档案权限与目录配置"><a href="#5️⃣Linux的档案权限与目录配置" class="headerlink" title="5️⃣Linux的档案权限与目录配置"></a>5️⃣Linux的档案权限与目录配置</h1><table><thead><tr><th>元件</th><th>内容</th><th>叠代物件</th><th>r</th><th>w</th><th>x</th></tr></thead><tbody><tr><td>档案</td><td>详细资料data</td><td>文件资料夹</td><td>读到文件内容</td><td>修改文件内容</td><td>执行文件内容</td></tr><tr><td>目录</td><td>档名</td><td>可分类抽屉</td><td>读到档名</td><td>修改档名</td><td>进入该目录的权限(key)</td></tr></tbody></table><hr><ul><li><p>由一般用户切换为“root”身份：<code>su -</code>；返回一般用户身份：<code>exit</code></p></li><li><p>查看文件<code>ls</code>;</p></li><li><p>复制：<code>cp</code></p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp 源档案名字 目的档案(档案副本的名称)</span><br></pre></td></tr></table></figure></blockquote></li></ul><h2 id="改变档案属性与权限"><a href="#改变档案属性与权限" class="headerlink" title="改变档案属性与权限"></a>改变档案属性与权限</h2><p>1、必须要进入档案所在目录中；2、所修改成的群组、所属者必须存在；3、只有root才有权限</p><p><strong>改变所属群组：chgrp</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp [-R] dirname/filename ...</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">选项与参数：</span><br><span class="line">-R : 进行递回(recursive)的持续变更，亦即连同级目录下的所有档案、目录</span><br><span class="line">     都更新成为这个群组之意。常常用在变更某一目录内所有的档案之情况。</span><br></pre></td></tr></table></figure></blockquote><hr><p><strong>改变档案拥有者：chown</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown [-R] 帐号名称 档案或目录</span><br><span class="line">chown [-R] 帐号名称:群组名称  档案或目录  <span class="comment">//:可以换为. 但是推荐使用:</span></span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">选项与参数：</span><br><span class="line">-R : 进行递回(recursive)的持续变更，亦即连同次目录下的所有档案都变更</span><br></pre></td></tr></table></figure></blockquote><hr><p><strong>改变权限：chmod</strong></p><ul><li><p><strong>使用数字改编权限</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chmod [-R] xyz 档案或目录</span><br><span class="line">-----------------------</span><br><span class="line">选项与参数：</span><br><span class="line">xyz : 就是刚刚提到的数字类型的权限属性，为rwx 属性数值的相加。</span><br><span class="line">-R : 进行递回(recursive)的持续变更，亦即连同次目录下的所有档案都会变更</span><br></pre></td></tr></table></figure><blockquote><p>Linux档案的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限，先复习一下刚刚上面提到的资料：档案的权限字元为：『-rwxrwxrwx』，这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p><blockquote><p>r:4<br>w:2<br>x:1</p></blockquote><p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是：</p><blockquote><p>owner = rwx = 4+2+1 = 7</p><p>group = rwx = 4+2+1 = 7</p><p>others= — = 0+0+0 = 0</p></blockquote></blockquote></li><li><p><strong>符号类型改变档案权限</strong></p><p>因为有三种身份：(1)user (2)group (3)others。那么我们就可以由<strong>u, g, o</strong>来代表三种身份的权限。</p><blockquote><p>此外，<strong>a</strong>则代表all亦即全部的身份！</p></blockquote><p>也就是可以使用底下的方式来看：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="%E9%B8%9F%E5%93%A5%E7%A7%81%E6%88%BF%E8%8F%9C/image-20200412180918390.png" alt="image-20200412180918390"></p><p>eg：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="%E9%B8%9F%E5%93%A5%E7%A7%81%E6%88%BF%E8%8F%9C/image-20200412181035669.png" alt="image-20200412181035669"></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;p center large&gt;&lt;red&gt;鸟哥私房菜&lt;/red&gt;&lt;/p&gt;&lt;/center&gt;&lt;center&gt;&lt;red&gt;http://linux.vbird.org/linux_basic/&lt;/red&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="linux" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux/"/>
    
    
      <category term="linux" scheme="https://longlongqin.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>C&amp;C++/LearnCpp-chapter6</title>
    <link href="https://longlongqin.github.io/archives/2faa8a4b.html"/>
    <id>https://longlongqin.github.io/archives/2faa8a4b.html</id>
    <published>2020-04-06T05:59:00.000Z</published>
    <updated>2020-04-19T14:38:29.547Z</updated>
    
    <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapter6</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h2 id="6-2-用户自定义namespace"><a href="#6-2-用户自定义namespace" class="headerlink" title="6.2 用户自定义namespace"></a>6.2 用户自定义namespace</h2><p>在<a href="https://www.learncpp.com/cpp-tutorial/2-9-naming-collisions-and-an-introduction-to-namespaces/" target="_blank" rel="noopener">2.9 – Naming collisions and an introduction to namespaces</a>中讲解了命名冲突和命名空间的内容。现在再次看一下<strong>命名冲突</strong>。</p><blockquote><p>下面的<code>foo.cpp</code>和<code>goo.cpp</code>两个源文件，中的函数有着不同的功能，但是它们的名字却是一样的：</p></blockquote><p><code>foo.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this dosomething() adds the value of its parameters</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dosomething</span><span class="params">(intx, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>goo.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this dosomething() subtracts the value of its parameters</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dosomething</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="comment">//forward declaration for dosomething</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; dosometing(<span class="number">4</span>, <span class="number">3</span>) &lt;&lt;<span class="string">'\n'</span>; <span class="comment">//which dosometing will we get?</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，编译器会将<code>foo.cpp</code>和<code>goo.cpp</code>都编译在同一个程序中。因为它们俩里面中的函数的名字、参数都一样，而且又在同一个范围中(global scope)，这将会造成“命名冲突”。结果就是，链接器工作时，将会发生错误：</p><p><code>goo.cpp:3: multiple definition of &quot;doSomething(int, int)&quot;; foo.cpp:3: first defined here</code></p><hr><p>一个较好的解决办法就是，将你的函数放在你自己定义的“<em><em>命名空间</em>namespace</em> **”中。</p><hr><ul><li><p><strong>定义自己的namespace</strong></p><p>C++允许我们使用关键字<em>namespace</em>来定义自己的命名空间。由用户自定义的命名空间，叫：<strong>user-defined namespaces</strong>。而 由C++提供的命名空间，如 <code>global namespace</code>；或者由库提供的，如<code>namespace std</code>；它们就不是user-defined namespaces。</p><blockquote><p><strong>命名空间的标识符</strong>通常 <strong>不大写</strong>。</p></blockquote><p>下面是对上面命名冲突的函数的改写：</p><p><code>foo.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> foo <span class="comment">//定义一个命名空间，名字为：foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//this dosomething() belongs to namespace foo</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dosomething</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>goo.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> goo  <span class="comment">//定义一个命名空间，名字为：goo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//this dosomething() belongs namespace goo</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dosomething</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dosomething</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">//提前对函数dosomething()进行声明</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;dosomething(<span class="number">4</span>, <span class="number">3</span>)&lt;&lt;<span class="string">'\n'</span>; <span class="comment">//which dosomething will we get?</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这个两个<code>dosomething()</code>函数都分别属于不同的命名空间了。让我们来运行一下。</p><p>😂，新问题又出现了：</p><blockquote><p><code>ConsoleApplication1.obj : error LNK2019: unresolved external symbol &quot;int __cdecl doSomething(int,int)&quot; (?doSomething@@YAHHH@Z) referenced in function _main</code></p></blockquote><p>在这个改版中，其实编译器是满意的(因为我们已经进行提前声明)。但是链接器找不到一个在<em>global namespace</em>中的<code>dosomething</code>的定义。</p><blockquote><p>这是因为我们虽然为两个<code>dosomething</code>分别声明在不同的命名空间，可惜的是这两个命名空间都不属于 全局命名空间 中。</p></blockquote><hr><p><strong>这里有两个解决方案：1.使用<em>scope resolution operator<em>；2.通过</em>using statements</em></strong></p><hr></li><li><p>*<em>使用范围解析操作符(::)访问名称空间 *</em></p><blockquote><p>【<strong>范围解析操作符：<em>scope resolution operator(::)</em></strong>】</p></blockquote><p>告诉编译器在特定名称空间中查找标识符的最佳方法是使用<em>scope resolution operator(::)</em></p><blockquote><p>“::”，它告诉编译器：应该在该操作符的 左操作数表示的范围中查找 操作符右边的操作数(也就是要找的标识符)</p></blockquote><p>下面是一个例子：</p><p><em>对于后面的示例，为了便于阅读，我们将把示例压缩为一个文件解决方案。</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> foo <span class="comment">// define a namespace named foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This doSomething() belongs to namespace foo</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> goo <span class="comment">// define a namespace named goo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This doSomething() belongs to namespace goo</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x - y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; foo::doSomething(<span class="number">4</span>, <span class="number">3</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// use the doSomething() that exists in namespace foo</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以注意到main函数中的这个语句：<code>std::cout &lt;&lt; foo::doSomething(4, 3) &lt;&lt; &#39;\n&#39;;</code>，就是用了“范围解析符 :: ”。</p><p>该标识符的左操作数：foo，表示命名空间的名字。右操作数表示标识符。</p><p><strong>所以，<code>foo::dosomething(4,3)</code>，就表示：调用的函数<code>dosomething()</code>是来源于命名空间foo中的。</strong></p></blockquote></li></ul><hr><center><p center large>小结</p></center><p>解决命名冲突的步骤为：</p><ol><li>为这些同名的函数，均设置自己的命名空间；</li><li>在使用这个同名函数的时候，还需要加上“范围解析符 :: ”</li></ol><hr><ul><li><p><strong>没有前缀的范围解析符</strong></p><blockquote><p><strong>格式：<code>:: 标识符</code></strong></p><p><strong>没有前缀的范围解析符，<u>就相当于它的范围是全局命名空间</u></strong>。</p></blockquote><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="comment">//this print lives in the global namespace</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"there"</span>&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> foo</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="comment">// this print lives in the foo namespace</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">foo::<span class="built_in">print</span>(); <span class="comment">// call foo::print()</span></span><br><span class="line">::<span class="built_in">print</span>(); <span class="comment">// call print() in global namespace (same as just calling print() in this case)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>允许多个命名空间块：Multiple namespace blocks allowed</strong></p><blockquote><p>在多个位置(跨多个文件，或同一文件中的多个位置)声明名称空间块是合法的。<strong><u>命名空间内的所有声明都被认为是命名空间的一部分</u>。</strong></p></blockquote><hr></li></ul><p>例子1（多文件中）：</p><p><code>circle.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(CIRCLE_H)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CIRCLE_H</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> basicMath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> pi&#123; <span class="number">3.14</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>growth.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(GROWTH_H)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GROWTH_H</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> basicMath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// the constant e is also part of namespace basicMath</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> e&#123; <span class="number">2.7</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"circle.h"</span> <span class="comment">// for basicMath::pi</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"growth.h"</span> <span class="comment">// for basicMath::e</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; basicMath::pi &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; basicMath::e &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p>3.14</p><p>2.7</p><blockquote><p>标准库充就分利用了这个特性，因为每个标准库头文件都将其声明包含在该头文件中包含的 命名空间std 块中。否则，整个标准库必须在一个头文件中定义!</p></blockquote><p><em>【note】：尽管你可以利用这个功能，将你写的函数添加到<code>std namespace</code>中，但是<code>std namespace</code>有一个规则，那就是禁止用户将自己的函数扩展到它的里面。</em></p><hr><ul><li><p>例子2</p><p>如果你将你的代码分离再多个文件中，你就必须在头文件和原文件中使用命名空间。</p><p><code>add.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(ADD_H)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD_H</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> basicMath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// function add() is part of namespace basicMath</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>add.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"add.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> basicMath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// define the function add()</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"add.h"</span> <span class="comment">// for basicMath::add()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; basicMath::add(<span class="number">4</span>, <span class="number">3</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li><p>如果在<code>add.cpp</code>中省略了<em>namespace</em>，将会导致链接器找不到<code>basicMath::add</code>。</p><p><em>因为这个源文件在缺少namespace时，对add的定义是在全局命名空间中的。</em></p></li><li><p>如果在<code>add.h</code>中省略<em>namespace</em>，将会导致在“main.cpp”中不能使用<code>basicMath::add</code></p><p><em>因为这个头文件在缺少namespace时，对add的声明是在全局命名空间中的。</em></p></li></ol></blockquote></li></ul><hr><ul><li><p><strong>嵌套命名空间</strong></p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> foo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> goo <span class="comment">// goo is a namespace inside the foo namespace</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; foo::goo::add() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>所以，当我们要调用函数<code>add</code>的时候，<strong>我们使用格式为：<code>foo::goo::add</code></strong></p></blockquote><hr><p>在C++17中，嵌套的命名空间也可以这样声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> foo::goo <span class="comment">// goo is a namespace inside the foo namespace (C++17 style)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; foo::goo::add() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>给命名空间设置别名：namespace aliases</strong></p><p>在使用嵌套的命名空间的函数或变量时，我们需要将命名空间层级都全部写完整，这样会很麻烦，如果我们给这个嵌套的命名空间起一个别名就省事多了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> foo</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">namespace</span> goo</span><br><span class="line">&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">namespace</span> boo = foo::goo; <span class="comment">// boo now refers to foo::goo</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; boo::add() &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// This is really foo::goo::add()</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// The boo alias ends here</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="6-3-局部变量"><a href="#6-3-局部变量" class="headerlink" title="6.3 局部变量"></a>6.3 局部变量</h2><p>在 <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-local-scope/" target="_blank" rel="noopener">2.4 – Introduction to local scope</a>,介绍了局部变量，它是在函数中的形参。</p><h3 id="局部变量的块范围"><a href="#局部变量的块范围" class="headerlink" title="局部变量的块范围"></a>局部变量的块范围</h3><p>标识符的范围决定了标识符在源码中可获得的区域。范围是一个“编译时间”的属性。</p><blockquote><p>局部变量的 <strong>块范围(block scope)</strong>，中的范围就是：从他们定义开始，到这个块结束 的这个范围。</p></blockquote><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i &#123;<span class="number">5</span>&#125;; <span class="comment">//i enters scope here</span></span><br><span class="line">    <span class="keyword">double</span> d &#123;<span class="number">4.0</span>&#125;; <span class="comment">// d enters scope here</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">// i and d go out of scope here</span></span><br></pre></td></tr></table></figure><p>虽然函数的形参没有被定义在函数体的内部，但是对于典型函数而言，形参可以被看成，是属于函数体块的范围内。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">//x and y enter scope here</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将x、y中较大者分配给max</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span>&#123;(x&gt;y) ? x : y&#125;; <span class="comment">//max enters scope here</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;<span class="comment">// x, y and max leave scope here</span></span><br></pre></td></tr></table></figure><hr><h3 id="同一范围内的变量名不相同"><a href="#同一范围内的变量名不相同" class="headerlink" title="同一范围内的变量名不相同"></a>同一范围内的变量名不相同</h3><p>下面的函数在编译时会出错，因为该范围内的变量名相同了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunction</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123;&#125;; <span class="comment">//编译时会出错，因为这里的x和形参x之间命名冲突了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="局部变量的自动存储期"><a href="#局部变量的自动存储期" class="headerlink" title="局部变量的自动存储期"></a>局部变量的自动存储期</h3><blockquote><p>变量的<strong>存储期(storage duration),也叫持续时长(duration)</strong>决定了什么时间以及如何创造和销毁它。通常，变量的存储器直接决定了它的<strong>“生命周期(lifetime)”</strong></p></blockquote><p>例如，局部变量的存储器，意味着它在被定义时就被创建，然后在他被定义的范围块的尾部被销毁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i &#123;<span class="number">5</span>&#125;; <span class="comment">//i created and initialized here</span></span><br><span class="line">    <span class="keyword">double</span> d &#123;<span class="number">4.0</span>&#125;; <span class="comment">//d created and initialized here</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// i and d are destoryed here</span></span><br></pre></td></tr></table></figure><p>由于这个原因，局部变量 有时也被称为：<strong>自动变量</strong></p><hr><h3 id="嵌套快中的局部变量"><a href="#嵌套快中的局部变量" class="headerlink" title="嵌套快中的局部变量"></a>嵌套快中的局部变量</h3><p>局部变量可以被定义在嵌套块中，这和在函数体块中的局部变量工作流程相同：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> <span class="comment">//外部块</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123;<span class="number">5</span>&#125;; <span class="comment">//x enters scope and is created here</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//嵌套块</span></span><br><span class="line">        <span class="keyword">int</span> y &#123;<span class="number">7</span>&#125;; <span class="comment">//y enters scope and is created here</span></span><br><span class="line">    &#125; <span class="comment">// y goes out of scope and is destroyed here</span></span><br><span class="line">    <span class="comment">//此时，y就不能再被用了，因为它不属于现在所在的范围</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// x goes out of scope and is destoryed here</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：<strong>变量x的范围是整个mian函数块中，自然，在嵌套块中，变量x也是有效的</strong>，即也可以访问它。</p></blockquote><hr><h3 id="局部变量的无连接"><a href="#局部变量的无连接" class="headerlink" title="局部变量的无连接"></a>局部变量的无连接</h3><p>标识符的另一个属性就是：<strong>“连接(linkage)”</strong>。一个标识符的<em>linkage</em>决定了该标识符的其他声明是否引用的是相同的对象。</p><blockquote><p><strong>局部变量没有<em>关联性</em>，也就是说对一个标识符的每一个声明都代表不同的对象</strong></p></blockquote><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x &#123;<span class="number">2</span>&#125;; <span class="comment">// local variable, no linkage</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x &#123;<span class="number">3</span>&#125;; <span class="comment">//这个标识符x与上面的标识符x，表示的是不同对象(尽管他们名字相同)</span></span><br><span class="line">        <span class="comment">//但是现在嵌套外部的变量x被隐藏起来了(在6.5节会讲到变量隐藏)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="变量定义的范围"><a href="#变量定义的范围" class="headerlink" title="变量定义的范围"></a>变量定义的范围</h3><p>如果一个变量仅在嵌套块中使用，那它就应该旨在嵌套块中被定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//don't define y here</span></span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//y只在这个块中被使用，所以在这里定义它</span></span><br><span class="line">        <span class="keyword">int</span> y&#123;<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;y&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>所以，我们尽量把变量定义在，使用它的范围内部</strong>。</p></blockquote><hr><h2 id="6-4-全局变量"><a href="#6-4-全局变量" class="headerlink" title="6.4 全局变量"></a>6.4 全局变量</h2><h3 id="全局变量的声明"><a href="#全局变量的声明" class="headerlink" title="全局变量的声明"></a>全局变量的声明</h3><p>通常，全局变量声明是在：<strong>头文件的下面，在其他代码的上面</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在函数外面声明的变量是全局变量</span></span><br><span class="line"><span class="keyword">int</span> g_x &#123;&#125;; <span class="comment">// global variable g_x</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// global variables can be seen and used everywhere in the file</span></span><br><span class="line">    g_x = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// global variables can be seen and used everywhere in the file</span></span><br><span class="line">    g_x = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// g_x goes out of scope here</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果*****/</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><blockquote><p>按照惯例， 在全局变量名字加上前缀“g”或者“g_”，来便于是显示的说明它是 全局变量</p></blockquote><hr><h3 id="全局变量的file-scope-amp-静态持续时间"><a href="#全局变量的file-scope-amp-静态持续时间" class="headerlink" title="全局变量的file scope&amp;静态持续时间"></a>全局变量的file scope&amp;静态持续时间</h3><blockquote><p>file scope也叫：<strong>全局范围(global scope)</strong>或者<strong>全局命名空间范围(global namespace scope)</strong></p><blockquote><p>因为全局变量是在函数外部定义的，所以也被视为“全局命名空间(global namespace)”的一部分。所以，才有<em>global namespace scope</em>这个叫法。</p></blockquote></blockquote><p>也就是说，它们从被定义开始，到所在文件的结束期间 都是有效的。</p><hr><p>全局变量在程序开始被创建，在程序结束时被销毁。这成为“<strong>静态持续时间(static duration)</strong>”</p><blockquote><p>有着‘static duration’的变量，也被称为：“<strong>静态变量(static variable)</strong>”</p></blockquote><hr><p><u><strong>局部变量默认是不被初始化的，全局变量默认是被初始化为0的</strong></u></p><ul><li><p><strong>全局变量的初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g_x; <span class="comment">//没有显示的初始化变量(所以默认初始化为0)</span></span><br><span class="line"><span class="keyword">int</span> g_y&#123;&#125;; <span class="comment">//初始化为0</span></span><br><span class="line"><span class="keyword">int</span> g_z&#123;<span class="number">3</span>&#125;; <span class="comment">//显示的初始化为3</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="常量局部变量"><a href="#常量局部变量" class="headerlink" title="常量局部变量"></a>常量局部变量</h3><p>与局部变量一样，全局变量也可以是常量。只要是常量，那它就必须被初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_x; <span class="comment">//error:常量型的变量必须要被初始化</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> g_w; <span class="comment">//error:常量型的变量必须要被初始化（constexpr，表示它是 编译时常量）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_y &#123;<span class="number">1</span>&#125;; <span class="comment">//正确，初始化了</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> g_z &#123;<span class="number">2</span>&#125;; <span class="comment">//正确，初始化了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dosomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//全局变量在这个文件中的每一个地方都是有效的(可以被看见和使用)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_z &lt;&lt; <span class="string">'\n'</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dosomething();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//全局变量在这个文件中的每一个地方都是有效的(可以被看见和使用)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_z &lt;&lt; <span class="string">'\n'</span>;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// g_y and g_z goes out of scope here</span></span><br></pre></td></tr></table></figure><hr><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Non-constant global variables(非常量的全局变量)</span></span><br><span class="line"><span class="keyword">int</span> g_x;                 <span class="comment">// defines non-initialized global variable (zero initialized by default)</span></span><br><span class="line"><span class="keyword">int</span> g_x &#123;&#125;;              <span class="comment">// defines explicitly zero-initialized global variable</span></span><br><span class="line"><span class="keyword">int</span> g_x &#123; <span class="number">1</span> &#125;;           <span class="comment">// defines explicitly initialized global variable</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Const global variables</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_y;           <span class="comment">// error: const variables must be initialized</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_y &#123; <span class="number">2</span> &#125;;     <span class="comment">// defines initialized global constant</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Constexpr global variables</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> g_y;       <span class="comment">// error: constexpr variables must be initialized</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> g_y &#123; <span class="number">3</span> &#125;; <span class="comment">// defines initialized global const</span></span><br></pre></td></tr></table></figure><hr><h2 id="6-5-变量被隐藏"><a href="#6-5-变量被隐藏" class="headerlink" title="6.5 变量被隐藏"></a>6.5 变量被隐藏</h2><h3 id="局部变量被隐藏"><a href="#局部变量被隐藏" class="headerlink" title="局部变量被隐藏"></a>局部变量被隐藏</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// outer block</span></span><br><span class="line"><span class="keyword">int</span> apples &#123; <span class="number">5</span> &#125;; <span class="comment">// 嵌套外部的apples</span></span><br><span class="line">    </span><br><span class="line">    &#123;<span class="comment">// nested block</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;apples&lt;&lt;<span class="string">'\n'</span>; <span class="comment">//这里的apples是嵌套外部的</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> apples &#123;<span class="number">0</span>&#125;; <span class="comment">//在嵌套内部定义变量apples</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//现在的apples指的是嵌套内部 的apples.嵌套外部的apples现在被隐藏起来了</span></span><br><span class="line">        apples = <span class="number">10</span>; <span class="comment">//现在被赋值的apples指的是嵌套内部的apples</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; apples &lt;&lt;<span class="string">'\n'</span>'</span><br><span class="line">    &#125; <span class="comment">//嵌套块内部的apples被销毁</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;apples&lt;&lt;<span class="string">'\n'</span>; <span class="comment">//这个apples指的是嵌套外部的apples(因为现在，嵌套内部的apples已经被销毁)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125; <span class="comment">//嵌套外部的apples被销毁</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">10</span><br><span class="line">5</span><br></pre></td></tr></table></figure><hr><h3 id="全局变量被隐藏"><a href="#全局变量被隐藏" class="headerlink" title="全局变量被隐藏"></a>全局变量被隐藏</h3><p>就像局部变量中的，嵌套块中的变量可以将嵌套外部的同名变量以藏起来 一样。<strong>局部变量可以将全局中的同名变量隐藏起来:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a &#123;<span class="number">5</span>&#125;; <span class="comment">//全局变量</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"global variable a："</span>&lt;&lt;a&lt;&lt;<span class="string">'\n'</span>;<span class="comment">//此时，全局变量a还没有被隐藏。即，这里的变量a，指的是全局变量</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a &#123;<span class="number">7</span>&#125;; <span class="comment">//此时，全局变量a就被这里的局部变量a 隐藏起来了</span></span><br><span class="line">    </span><br><span class="line">    ++a; <span class="comment">//局部变量a加1，而不是全局变量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"local variable a: "</span> &lt;&lt; a &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    foo();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// 局部变量a被销毁</span></span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local variable a: 8</span><br><span class="line">global variable a: 5</span><br></pre></td></tr></table></figure><hr><p>然而啊，全局变量是属于全局的命名空间。所以，我们可以使用 <em>范围解析符(::)</em>（不带前缀的，即默认是在全局命名空间）来告诉编译器我们使用的是全局变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a &#123;<span class="number">5</span>&#125;; <span class="comment">//全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a &#123;<span class="number">7</span>&#125;; <span class="comment">//此时，将全局变量a隐藏起来了</span></span><br><span class="line">    ++a； <span class="comment">//局部变量a加1，而不是全局变量</span></span><br><span class="line">        </span><br><span class="line">    --(::a); <span class="comment">//此时是对于全局变量，减一</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"local variable a: "</span> &lt;&lt; a &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"global variable a: "</span> &lt;&lt; ::a &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;       </span><br><span class="line">&#125;<span class="comment">//local a 被销毁</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local variable a: 8</span><br><span class="line">global variable a: 4</span><br></pre></td></tr></table></figure><hr><h3 id="避免变量被隐藏"><a href="#避免变量被隐藏" class="headerlink" title="避免变量被隐藏"></a>避免变量被隐藏</h3><p>通常应该避免局部变量的隐藏，因为它会在使用或修改错误的变量时导致无意的错误。一些编译器会在变量被隐藏时发出警告。</p><hr><h2 id="6-6-内部连接"><a href="#6-6-内部连接" class="headerlink" title="6.6 内部连接"></a>6.6 内部连接</h2><p>在 <a href="https://www.learncpp.com/cpp-tutorial/local-variables/" target="_blank" rel="noopener">6.3 – Local variables</a>中，讲到：“一个标识符的连接决定了该名称的其他声明是否引用同一对象”和“局部变量的无连接”</p><p>全局变量和函数标识符有：<strong>内部链接(internal linkage)</strong>和<strong>外部链接(external linkage)</strong>。本节主要讲内部链接。</p><hr><p>一个标识若是内部连接，那它就只能在这一个文件中有效(可以被看到和使用)；而不可以在其他文件中看到和使用【<strong>也就是说，它没有暴露给链接器</strong>】。也就是说，如果有两个文件，它们分别含有一个相同名字的标识符(而且这这个同名的标识符是 内部连接)，那么这个同名的标识符就被看待成相互独立的。</p><hr><h3 id="全局变量内部连接"><a href="#全局变量内部连接" class="headerlink" title="全局变量内部连接"></a>全局变量内部连接</h3><p>全局变量是内部链接时，也被称为：<strong>内部变量(<em>internal variables</em>)</strong>。</p><blockquote><p>让 非常量的全局变量 成为内部变量，需要使用<strong>关键字<code>static</code></strong>；（因为非常量的全局变量默认是 外部链接 的）</p><p>而 常量的全局变量 <strong>默认</strong>的就是 内部变量。</p></blockquote><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> g_x; <span class="comment">//非常量的全局变量默认是 外部链接。但是加上关键字static后，就变成内部连接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_y &#123;<span class="number">1</span>&#125;; <span class="comment">//const 的全局变量默认是 内部连接</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> g_z &#123;<span class="number">2</span>&#125;; <span class="comment">//constexpr 的全局变量默认是 内部连接</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>const</code>和<code>constexpr</code>的全局变量默认是 内部连接(所以，不需要加 关键字<code>static</code>)</p></blockquote><hr><h3 id="一个定义规则和内部连接"><a href="#一个定义规则和内部连接" class="headerlink" title="一个定义规则和内部连接"></a>一个定义规则和内部连接</h3><p>还记得在 <a href="https://www.learncpp.com/cpp-tutorial/forward-declarations/" target="_blank" rel="noopener">2.7 – Forward declarations and definitions</a>,中讲到一个定义的规则：<em>在文件或程序中，*</em>一个*<em>对象或者函数只能有一个定义</em>。</p><p>然而，这一个我们却在一个程序中对一个对象或函数进行了“多次定义”，这是否违背了上面的规则呢？</p><blockquote><p>答：不违背。因为本节中我们将它们设置为内部连接，此时虽然它们的名字相同，但是相互独立（即，它们相当于不同的对象或函数，只是名字相同。就好像两个同名的人一样）。所以不违背上面的定义规则。</p></blockquote><hr><h3 id="函数内部连接"><a href="#函数内部连接" class="headerlink" title="函数内部连接"></a>函数内部连接</h3><p>因为“连接(linkage)”是标识符的属性(标识符不仅仅只代表变量(☄⊙ω⊙)☄，因为函数的名字也是标识符)。所以，函数标识符也具有 内部连接 的属性。</p><p>如：</p><p><code>add.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个函数前使用关键字static，表示它现在只在这个文件中有效</span></span><br><span class="line"><span class="comment">//如果，企图通过函数提前声明从，从另一个文件访问它，将失败</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="comment">//对函数add，提前声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序，在链接器连接时，将会出错。因为函数add在<code>main.cpp</code>中不可访问</p><hr><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Internal global variables definitions:</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> g_x;          <span class="comment">// defines non-initialized internal global variable (zero initialized by default)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> g_x&#123; <span class="number">1</span> &#125;;     <span class="comment">// defines initialized internal global variable</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_y &#123; <span class="number">2</span> &#125;;     <span class="comment">// defines initialized internal global const variable</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> g_y &#123; <span class="number">3</span> &#125;; <span class="comment">// defines initialized internal global constexpr variable</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Internal function definitions:</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;;     <span class="comment">// defines internal function</span></span><br></pre></td></tr></table></figure><hr><h2 id="6-7-外部连接"><a href="#6-7-外部连接" class="headerlink" title="6.7 外部连接"></a>6.7 外部连接</h2><p>一个标识符具有 <strong>外部连接(external linkage)</strong>的属性，那么它就可以在整个程序中(不仅仅只在一个文件中)被看见和访问。（在其他文件中，可以通过<em>提前声明</em>来访问它）</p><blockquote><p>所以，具有外部连接属性的表示符，才是真正的“全局”变量</p></blockquote><hr><h3 id="函数默认是外部链接"><a href="#函数默认是外部链接" class="headerlink" title="函数默认是外部链接"></a>函数默认是外部链接</h3><p>在 <a href="https://www.learncpp.com/cpp-tutorial/programs-with-multiple-code-files/" target="_blank" rel="noopener">2.8 – Programs with multiple code files</a>中，讲到我们可以从其他文件中调用函数，这是因为这个函数默认是“外部链接”的。</p><p>在从其他文件中调用函数时，我们必须要对这个函数进行 <strong>提前声明(forward declaration)</strong></p><blockquote><p>因为，<strong>提前声明</strong>可以告诉编译器这个函数的存在；而链接器则是将函数调用连接到实际的函数定义</p></blockquote><p>如：</p><p><code>a.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> <span class="comment">//这个函数默认是 外部连接，所以他可以在整个程序(包括其他文件)中被看见</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hi"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span></span>; <span class="comment">//对函数进行提前声明，使得该函数在这个文件中可以被访问</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sayHi(); <span class="comment">//这里是从其他文件中调用此函数，链接器将把这个调用连接到函数定义</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hi</span><br></pre></td></tr></table></figure><hr><h3 id="全局变量外部连接"><a href="#全局变量外部连接" class="headerlink" title="全局变量外部连接"></a>全局变量外部连接</h3><p>全局变量具有外部连接属性时，也称为：<strong>外部变量(external variables)</strong></p><blockquote><p>非常量的全局变量默认是 外部变量；</p><p>常量的全局变量 要想成为外部变量，需要使用<strong>关键字<code>extern</code></strong></p></blockquote><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g_x &#123;<span class="number">2</span>&#125;; <span class="comment">//非常量的全局变量默认是 外部变量；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> g_y &#123;<span class="number">3</span>&#125;;<span class="comment">//const 的全局变量可以被定义成 外部变量，需要加关键字extern</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> g_z &#123;<span class="number">3</span>&#125;; <span class="comment">//constexpr 的全局变量可以被定义成 外部变量,需要加关键字extern</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>默认情况下，非const全局变量是外部变量(如果使用，extern关键字将被忽略)。</p></blockquote><hr><h3 id="extern提前声明变量"><a href="#extern提前声明变量" class="headerlink" title="extern提前声明变量"></a><code>extern</code>提前声明变量</h3><p>要实际使用在另一个文件中定义的外部全局变量，我们需要在使用它的文件中对全局变量进行<em>提前声明</em>。对于变量，在创建一个<strong>提前声明时，也是需要使用关键字<code>extern</code>的(</strong>没有初始化值)：</p><p>如：</p><p><code>a.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量的定义</span></span><br><span class="line"><span class="keyword">int</span> g_x &#123;<span class="number">2</span>&#125;; <span class="comment">//非常量的全局变量默认是 外部链接</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> g_y &#123;<span class="number">3</span>&#125;; <span class="comment">//常量的全局变量是内部连接，但使用关键字extern后，变为 外部链接</span></span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> g_x; <span class="comment">//对变量g_x的提前声明。它的定义在其他文件中</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> g_y; <span class="comment">//对常量变量g_y的提前声明。它的定义在其他文件中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>&lt;&lt; g_x; <span class="comment">//结果为2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="函数提前声明不用extern"><a href="#函数提前声明不用extern" class="headerlink" title="函数提前声明不用extern"></a>函数提前声明不用<code>extern</code></h3><p><strong>函数的提前声明不需要关键字<code>extern</code></strong></p><blockquote><p>编译器能搞告诉你这个函数在哪定义，也可以根据是否提供函数体来进行提前声明。</p></blockquote><p><strong>变量的提前声明必须要用关键字<code>extern</code></strong>，</p><blockquote><p>来帮助区分 <strong>变量定义</strong> 和 <strong>变量提前声明</strong>(它们看起来是一样的):</p></blockquote><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非常量</span></span><br><span class="line"><span class="keyword">int</span> g_x; <span class="comment">//变量的定义(如果需要，可进行初始化)</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> g_x; <span class="comment">//变量的提前声明(提前声明  不带初始化)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> g_y &#123;<span class="number">1</span>&#125;;<span class="comment">//定义变量(常量的定义必须要进行初始化)</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> g_y; <span class="comment">//提前声明(提前声明  不带初始化)</span></span><br></pre></td></tr></table></figure><hr><h3 id="file范围VS-global范围"><a href="#file范围VS-global范围" class="headerlink" title="file范围VS.global范围"></a>file范围VS.global范围</h3><p>看下面的例子：</p><p><code>global.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g_x &#123;<span class="number">2</span>&#125;; <span class="comment">//（非常量的变量）默认是外部连接</span></span><br><span class="line"><span class="comment">//g_x goes out scope here</span></span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> g_x; <span class="comment">//对变量g_x的提前声明。可以在此文件中使用g_x</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_x; <span class="comment">//应该输出 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//g_x的提前声明 goes out of scope here</span></span><br></pre></td></tr></table></figure><blockquote><p>变量g_x的<strong>文件范围(file scope)</strong>是在<code>global.cpp</code>中。它在该文件中定义之后，就可以被使用。</p><p>但是它<strong>不能<u>直接</u>在其他文件中使用</strong>。如果要在其他文件中使用g_x，我们要在其他文件中对它进行提前声明(记得要使用关键字<code>extern</code>)</p></blockquote><hr><p>也就是说，“文件范围”通常用于具有<em>内部连接</em>属性的全局变量；“全局范围”更多用于具有<em>外部连接</em>属性的全局变量(因为，它被提前声明之后，就可以在其他地方使用)</p><hr><h3 id="全局变量初始化顺序问题"><a href="#全局变量初始化顺序问题" class="headerlink" title="全局变量初始化顺序问题"></a>全局变量初始化顺序问题</h3><p>全局变量的初始化是程序启动的一部分，在执行<code>mian</code>函数之前，这个过程分为两部分：</p><ul><li><p>第一部分，称为 <strong><em>static initialization</em>静态初始化</strong>。</p><blockquote><p>在静态初始化中，带有constexpr初始化器(包括字面值(literal))的全局变量被初始化为给定的值[因为，constexpr和字面值常量定义时自带有初始值]；</p><blockquote><p>eg,</p><p><code>const a {1};</code>那么a就被初始化为1</p><p><code>constexpr a{1};</code>那么a就被初始化为1</p></blockquote><p>定义时没有给定初始值的全局变量<strong>(也使常量的全局变量，但没有显示初始化为0)</strong>被默认初始化为0。</p><blockquote><p><code>const a {};</code>那么a就默认被初始化为0</p><p><code>constexpr a{};</code>那么a就默认被初始化为0</p></blockquote></blockquote></li><li><p>第二部分，称为 <strong><em>dynamic initialization</em>动态初始化</strong>。</p><blockquote><p>这部分，比较复杂，它的要点是：初始化那些“不带有constexpr初始化器的全局变量”(即，就是 非常量的全局变量)。</p></blockquote></li></ul><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_something &#123;init()&#125;; <span class="comment">//非常量的变量初始化</span></span><br></pre></td></tr></table></figure><blockquote><p>在单位件的程序中，全局变量按照定义的顺序被初始化</p></blockquote><p>这个规则有几个例外。考虑到这一点，<strong>您需要小心不要让变量依赖于其他变量的初始化值，这些变量要到稍后才会初始化</strong>。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initx</span><span class="params">()</span></span>;  <span class="comment">// forward declaration</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inity</span><span class="params">()</span></span>;  <span class="comment">// forward declaration</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> g_x&#123; initx() &#125;; <span class="comment">// g_x is initialized first</span></span><br><span class="line"><span class="keyword">int</span> g_y&#123; inity() &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initx</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g_y; <span class="comment">// g_y isn't initialized when this is called</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_x &lt;&lt; <span class="string">' '</span> &lt;&lt; g_y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******结果*******/</span></span><br><span class="line"><span class="number">0</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><hr><p>再多文件程序中，<strong>不同文件之间的初始化顺序是没有规定的</strong>。</p><blockquote><p>例如，有两个文件<code>a.cpp</code>和<code>b.cpp</code>，它们两个文件谁先被初始化是不确定的。</p></blockquote><p>所以，如果在<code>a.cpp</code>中有一个变量的值是依赖于<code>b.cpp</code>。那么就有50%的可能这些变量还没有被初始化。</p><hr><p>注意：C++中，全局变量的动态初始化会造成很多问题。所以避免使用。</p><hr><p>小结：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// External global variable definitions:</span></span><br><span class="line"><span class="keyword">int</span> g_x;                       <span class="comment">// defines non-initialized external global variable (zero initialized by default)</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> g_x&#123; <span class="number">1</span> &#125;;     <span class="comment">// defines initialized const external global variable</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> g_x&#123; <span class="number">2</span> &#125;; <span class="comment">// defines initialized constexpr external global variable</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Forward declarations</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> g_y;                <span class="comment">// forward declaration for non-constant global variable</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> g_y;          <span class="comment">// forward declaration for const global variable</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> g_y;      <span class="comment">// not allowed: constexpr variables can't be forward declared</span></span><br></pre></td></tr></table></figure><hr><h2 id="6-8-全局常量-amp-内联变量"><a href="#6-8-全局常量-amp-内联变量" class="headerlink" title="6.8 全局常量&amp;内联变量"></a>6.8 全局常量&amp;内联变量</h2><blockquote><p><strong>Global constants and inline variables</strong></p></blockquote><p>一些符号常量需(如，阿伏伽德罗常数，重力系数…)要在整个程序中使用。比较好的方法是在一个地方对他们进行声明，而不是在每个需要它们的文件中重新定义这些常量。</p><h3 id="全局常量作为内部变量"><a href="#全局常量作为内部变量" class="headerlink" title="全局常量作为内部变量"></a>全局常量作为内部变量</h3><p>在c++中有多种方法可以促进这一点。在c++ 17之前，以下可能是最简单和最常见的方法:</p><ol><li><p>首先，创建一个头文件来存放这些常量；</p></li><li><p>在这个头文件中，定义一个命名空间（在 <a href="https://www.learncpp.com/cpp-tutorial/user-defined-namespaces/" target="_blank" rel="noopener">6.2 – User-defined namespaces</a>讲解过命名空间）；</p></li><li><p>然后，将常量加入这个命名空间中（请确保它们的类型是<code>constexpr</code>）；</p></li><li><p>在你要用这些变量的文件中，加上这个头文件<code>#include &quot;xxx&quot;</code></p></li></ol><hr><p>eg:</p><p><code>constants.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONSTANTS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONSTANTS_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义你自己的命名空间(用来存储常量)</span></span><br><span class="line"><span class="keyword">namespace</span> constants</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//默认情况下，常量有 内部连接</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">double</span> pi &#123;<span class="number">3.14159</span>&#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">double</span> my_gravity &#123;<span class="number">9.2</span>&#125;;</span><br><span class="line">    <span class="comment">//....常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"constants.h"</span> <span class="comment">//：在这个文件中包含每个常量的副本</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"enter a radius: "</span>;</span><br><span class="line">    <span class="keyword">int</span> radius&#123;&#125;; <span class="comment">//radius：半径</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt;radius;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"the circumference is: "</span> &lt;&lt;<span class="number">2</span>* radius* constants::pi;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：在<code>main.cpp</code>文件中，要想访问<code>constants</code>中的常量，我们需要使用 <strong>范围解析符(::)</strong>。</p><p><code>a::b</code> 范围解析操作符的 左操作数a,表示命名空间名称；右操作符b表示命名空间a中的变量或者函数名字。</p><p><code>::b</code> 这种形式表示 <strong>其命名空间是全局命名空间</strong>。</p></blockquote><hr><h3 id="全局常量作为外部变量"><a href="#全局常量作为外部变量" class="headerlink" title="全局常量作为外部变量"></a>全局常量作为外部变量</h3><p>当作为内部变量时，可能会出现以下问题：</p><p>虽然这很简单(对于较小的程序也很好)，但是每当constants.h被包含到不同的代码文件中时，每个变量都会被复制到包含代码文件中。因此，如果将constants.h包含到20个不同的代码文件中，那么每个变量都会重复20次。头文件保护不会阻止这种情况的发生，因为它们只会阻止头文件不止一次被包含到一个包含文件中，而不会阻止头文件一次被包含到多个不同的代码文件中。这带来了两个挑战:</p><blockquote><p><strong>头文件保护符(header guards)</strong>只能确保在单个文件中包含的头文件只包含一次；</p></blockquote><ul><li>当修改一个常量值时，就可能需要重新编译那些包含这个常量的文件，这可能导致大型项目的重建时间很长。</li><li>如果常量的size很大，并且不能进行优化。这将花费很多内存。</li></ul><hr><p>一个解决上面的办法就是，将这些常量设为<strong>“外部变量(external variables)”</strong>。</p><blockquote><p>因此，我们可以将变量只初始化一次就可以在整个程序中使用。</p></blockquote><p><code>constants.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> constants</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//actual global variables</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">double</span> pi &#123;<span class="number">3.14159</span>&#125;;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">const</span> my_gravity &#123;<span class="number">9.2</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在<code>constants.cpp</code>文件中定义这些常量，来确保它们只被定义一次；</p></blockquote><p><code>constants.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONSTANTS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONSTANTS_H</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> constants</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// since the actual variables are inside a namespace, the forward declarations need to be inside a namespace as well</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">double</span> pi;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">double</span> avogadro;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">double</span> my_gravity;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><blockquote><p>需要在头文件<code>constants.h</code>中对这些常量进行 提前声明</p></blockquote><p><code>main.cpp</code></p><blockquote><p>使用的方法不变</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"constants.h"</span> <span class="comment">// include all the forward declarations</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a radius: "</span>;</span><br><span class="line">    <span class="keyword">int</span> radius&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; radius;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The circumference is: "</span> &lt;&lt; <span class="number">2</span> * radius * constants::pi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>因为全局符号常量在命名空间中(为了避免与全局命名空间中的标识符发生 命名冲突)，所以，就不需要在它名字中使用<code>g_</code>前缀</p></blockquote><p>现在，这些符号常量只用在<code>constants.cpp</code>中实例化一次(而不是每次constants.h被<code>#include</code>中都被实例化一次)，所以，对constants.cpp所做的任何修改都只需要重新编译constants.cpp即可。</p><p>然而，这种方法也有几个缺点。</p><ul><li><strong>首先，这些常量现在只在实际定义它们的文件(constants.cpp)中被认为是 编译时常量</strong>，<strong>而不是在其他地方使用它们</strong>。这意味着在constants.cpp之外的地方，它们不能在任何需要编译时常量的地方使用。</li><li>其次，编译器可能无法对它们进行尽可能多的优化。</li></ul><hr><h3 id="全局常量作为内联变量"><a href="#全局常量作为内联变量" class="headerlink" title="全局常量作为内联变量"></a>全局常量作为内联变量</h3><p>在C++17中，有一个新概念叫做：<strong><em>inline variable</em>(内联变量)</strong></p><blockquote><p><strong>inline</strong>意为：允许多个定义。</p></blockquote><p>所以，一个内联变量就可以在多个文件中被多次定义。(这并不违背 <strong>单定义规则</strong>)</p><blockquote><p><strong>内联全局变量</strong> 默认是 <strong>外部连接</strong></p></blockquote><hr><p>内联变量有两个重要的限制，必须遵守：</p><ul><li>内联变量的所有定义必须相同（否则，将产生未定义的行为）；</li><li>内敛变量的定义(不是提前声明)必须出现在每一个使用这些变量的文件中。</li></ul><blockquote><p>编译器将会把内联变量的所有定义合并为一个变量的定义。这就允许我们在头文件中定义变量，并将它们当作<code>a.cpp</code>文件中只有一个定义。</p><p>这些变量在它们被包含的文件中，依然保持这 constexpr 的性质</p></blockquote><p>这样，我们就可以在头文件中定义全局变量，而不用担心重复变量:</p><p><code>constants.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONSTANTS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONSTANTS_H</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// define your own namespace to hold constants</span></span><br><span class="line"><span class="keyword">namespace</span> constants</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> pi &#123; <span class="number">3.14159</span> &#125;; <span class="comment">// note: now inline constexpr</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> avogadro &#123; <span class="number">6.0221413e23</span> &#125;;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> my_gravity &#123; <span class="number">9.2</span> &#125;; <span class="comment">// m/s^2 -- gravity is light on this planet</span></span><br><span class="line">    <span class="comment">// ... other related constants</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"constants.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a radius: "</span>;</span><br><span class="line">    <span class="keyword">int</span> radius&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; radius;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The circumference is: "</span> &lt;&lt; <span class="number">2</span> * radius * constants::pi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们可以在尽可能多的代码文件中包含<code>constants.h</code>，但是这些变量只会被实例化一次，并在所有代码文件中共享。</p></blockquote><hr><p>如果你需要全局常量，并且你的编译器支持C++17，那建议最好使用 <strong>内联变量</strong></p><hr><h2 id="6-9-非常量的全局变量evil"><a href="#6-9-非常量的全局变量evil" class="headerlink" title="6.9 非常量的全局变量evil"></a>6.9 非常量的全局变量evil</h2><p>最大的问题就是：<strong>当你使用全局变量(not-const)时，它可能在任何地方就被修改，但是你却不能轻松的直到在哪被改的。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g_mode; <span class="comment">//声明全局变量(将默认被初始化为0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dosomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_mode = <span class="number">2</span>; <span class="comment">//这里修改全局变量g_mode为2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_mode =<span class="number">1</span>; <span class="comment">//note:这将全局g_mode变量设置为1。而不是声明一个本地g_mode变量!</span></span><br><span class="line">    dosomething();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//程序猿希望这里输出的g_mode的值是1，但是实际上它的值是2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(g_mode == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"no threat detected.\n"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"lanunching nuclear missiles...\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>局部变量要安全得多，因为其他函数不能直接影响它们。</strong></p></blockquote><hr><h3 id="保护你的全局变量"><a href="#保护你的全局变量" class="headerlink" title="保护你的全局变量"></a>保护你的全局变量</h3><p>如果你非要使用全局变量：</p><ul><li><strong>那我们可以对变量名使用前缀”g_”或“g”，来帮助我们识别它是全局变量。</strong></li><li>最好也将其<strong>放在你自己创建的命名空间，从而避免一些命名冲突。</strong></li></ul><hr><h2 id="6-10-静态局部变量"><a href="#6-10-静态局部变量" class="headerlink" title="6.10 静态局部变量"></a>6.10 静态局部变量</h2><p>术语<code>static</code>是c++语言中最容易混淆的术语之一，这在很大程度上是因为静态在不同的上下文中有不同的含义。</p><p>在之前的课程中，我们讨论了<strong>全局变量具有静态持续时间</strong>，<strong>这意味着它们在程序启动时创建，在程序结束时销毁。</strong></p><p>我们还讨论了<strong><code>static</code>关键字如何提供全局标识符内部链接</strong>，<strong>这意味着标识符只能在定义它的文件中使用。</strong></p><hr><p>我们将探讨<strong>应用于局部变量时静态关键字的用法</strong>。</p><p>在 <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-local-scope/" target="_blank" rel="noopener">2.4 – Introduction to local scope</a>, 您了解到，默认情况下 局部变量具有 <em>自动持续时间</em>，<strong>这意味着它们是在定义时创建的，并在块退出时销毁。</strong></p><blockquote><p>但<strong>关键字<code>static</code></strong>，可以将<strong><em>自动持续时间(attomatic duration)</em></strong>转变成 <strong><em>静态持续时间(static duration)</em></strong> 。从而，静态变量即使已经超出它所在的范围时，他依然没有被销毁。</p><blockquote><p>这意味着变量现在在程序开始时创建，并在程序结束时销毁(就像全局变量一样)。</p></blockquote></blockquote><p>例如：</p><p><em>默认是 automatic duration</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrementAndPrint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value&#123; <span class="number">1</span> &#125;; <span class="comment">// 默认是 automatic duration</span></span><br><span class="line">    ++value;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125; <span class="comment">// value is destroyed here</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    incrementAndPrint();</span><br><span class="line">    incrementAndPrint();</span><br><span class="line">    incrementAndPrint();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果**********/</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>每次</strong>调用函数<code>incrementAndPrint()</code>时，都将穿件一个叫value的变量，它被初始化为1</p></blockquote><hr><p>现在使用<code>static</code>关键字，将默认的 <em>atuomatic duration</em> 转变为 <em>static duration</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrementAndPrint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_value&#123; <span class="number">1</span> &#125;; <span class="comment">// 由于使用关键字 static,所以现在是 static duration。  所以这个变量将只会被初始化一次（不会像上面那个例子，每次调用都会被除初始化）</span></span><br><span class="line">    ++s_value;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s_value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125; <span class="comment">// s_value is not destroyed here, but becomes inaccessible because it goes out of scope</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    incrementAndPrint();</span><br><span class="line">    incrementAndPrint();</span><br><span class="line">    incrementAndPrint();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****结果****/</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><blockquote><p>在这个程序中，<strong>因为s_value被声明为静态的</strong>，<u><strong>所以s_value只创建一次(在程序启动时)(并且初始化为零)。</strong></u>然后在第一次遇到变量定义时使用我们提供的初始化值(1)初始化变量(但在后续调用时不会重新初始化)。</p></blockquote><blockquote><p>就像我们使用“g_” 作为全局变量的前缀一样，使用 “ s_”作为静态(静态持续时间)局部变量的前缀也是很常见的。</p></blockquote><hr><p><strong>静态变量提供了全局变量的一些好处(它们直到程序结束时才被销毁)</strong>，同时，限制为它们只在它自己的块中才能被看见，这使得即使您经常更改它们的值，这也使它们可以安全使用。</p><hr><h3 id="全局、局部变量使用static"><a href="#全局、局部变量使用static" class="headerlink" title="全局、局部变量使用static"></a>全局、局部变量使用<code>static</code></h3><p>全局变量使用关键字<code>static</code>：这会使得全局变量变为 <strong><em>internal linkage(内部连接)</em></strong>，即，使得该变量不能再其他文件中使用。</p><p>局部变量使用关键字<code>statci</code>：这使得局部变量变为 <strong><em>static duration(静态持续时间)</em></strong>,即，使得该变量将 只被创建一次，而且直到程序结束才会被销毁。</p><hr><h2 id="6-11-总结scope-duration-linkage"><a href="#6-11-总结scope-duration-linkage" class="headerlink" title="6.11 总结scope/duration/linkage"></a>6.11 总结scope/duration/linkage</h2><h3 id="总结scope"><a href="#总结scope" class="headerlink" title="总结scope"></a>总结scope</h3><p>标识符的范围决定了它能够被访问的区间：</p><ul><li>具有 <strong>block scope(块范围)</strong> / <strong>local scope(局部范围)</strong> 的变量 只能在它们被声明的块中(包括嵌套块)被访问，这些有：<ul><li>局部变量；</li><li>函数的形参；</li><li>在块中声明的用户定义类型定义（如，枚举(enum)、类(class)）;</li></ul></li><li>具有 <strong>global scope(全局范围)</strong> / <strong>file scope(文件范围)</strong>的变量 可以再文件中的任何地方被访问，这些有：<ul><li>全局变量；</li><li>函数；</li><li>在命 名空间内 或 全局范围 内声明的用户定义类型定义(如枚举(enum)、类(class))</li></ul></li></ul><hr><h3 id="总结duration"><a href="#总结duration" class="headerlink" title="总结duration"></a>总结duration</h3><p>变量的持续时间决定了它们何时被创建与销毁：</p><ul><li>具有 <strong>automatic duration(自动持续时间)</strong>的变量 在定义时被创建，在离开它所在的块时被销毁，这些有：<ul><li>局部变量；</li><li>函数的形参；</li></ul></li><li>具有 <strong>static duration(静态持续时间)</strong>的变量 在程序开始时被创建， 在程序结束时被销毁。这些有：<ul><li>全局变量；</li><li>静态局部变量；</li></ul></li><li>具有 <strong>dynamic duration(动态持续时间)</strong>的变量 由程序员请求创建和销毁。这些有：<ul><li>动态分配的变量；</li></ul></li></ul><hr><h3 id="总结linkage"><a href="#总结linkage" class="headerlink" title="总结linkage"></a>总结linkage</h3><p>标识符的 <strong><em>linkage</em>(连接)</strong> 决定了 一个标识符的多个实例是否引用同一个标识符。</p><ul><li>标识符 没有 连接 时，意味着这个标识符仅指其自身。这些有：<ul><li>局部变量；</li><li>在块中声明的用户定义类型定义(如枚举和类)；</li></ul></li><li>具有 <strong><em>intrnal linkage</em>(内部连接)</strong> 的标识符 只能在它所声明的文件中 被访问。这些有：<ul><li>静态全局变量(static global variables) [初始化 或 未初始化 ]；</li><li>静态函数（static functions）;</li><li>在未命名的命名空间中声明的函数；</li><li>在未命名的命名空间中声明的用户定义类型定义(如枚举和类)；</li></ul></li><li>具有 <strong><em>external linkage(外部连接)</em></strong> 的标识符 可以在 在声明的文件内的任何地方访问，也可以其他文件(通过提前声明)进行访问。这包括:<ul><li>函数；</li><li>非常量的全局变量(初始化 或 未初始化)；</li><li>外部常量全局变量；</li><li>内联常量全局变量；</li><li>在 命名空间内 或 全局范围内声明的用户定义类型定义(如枚举和类)；</li></ul></li></ul><hr><blockquote><p>NOTE:</p><p>默认情况下， 函数是 外部连接；它可通过使用关键字<code>static</code>变成 内部连接。</p></blockquote><hr><h3 id="变量的-scope-duratio-linkage"><a href="#变量的-scope-duratio-linkage" class="headerlink" title="变量的 scope/duratio /linkage"></a>变量的 scope/duratio /linkage</h3><table><thead><tr><th align="left">Type</th><th align="left">Example</th><th align="left">Scope</th><th align="left">Duration</th><th align="left">Linkage</th><th align="left">Notes</th></tr></thead><tbody><tr><td align="left">Local variable</td><td align="left">int x;</td><td align="left">Block</td><td align="left">Automatic</td><td align="left">None</td><td align="left"></td></tr><tr><td align="left">Static local variable</td><td align="left">static int s_x;</td><td align="left">Block</td><td align="left">Static</td><td align="left">None</td><td align="left"></td></tr><tr><td align="left">Dynamic variable</td><td align="left">int *x { new int };</td><td align="left">Block</td><td align="left">Dynamic</td><td align="left">None</td><td align="left"></td></tr><tr><td align="left">Function parameter</td><td align="left">void foo(int x)</td><td align="left">Block</td><td align="left">Automatic</td><td align="left">None</td><td align="left"></td></tr><tr><td align="left">External non-constant global variable</td><td align="left">int g_x;</td><td align="left">File</td><td align="left">Static</td><td align="left">External</td><td align="left">Initialized or uninitialized</td></tr><tr><td align="left">Internal non-constant global variable</td><td align="left">static int g_x;</td><td align="left">File</td><td align="left">Static</td><td align="left">Internal</td><td align="left">Initialized or uninitialized</td></tr><tr><td align="left">Internal constant global variable</td><td align="left">constexpr int g_x { 1 };</td><td align="left">File</td><td align="left">Static</td><td align="left">Internal</td><td align="left">Const or constexpr, Must be initialized</td></tr><tr><td align="left">External constant global variable</td><td align="left">extern constexpr int g_x { 1 };</td><td align="left">File</td><td align="left">Static</td><td align="left">External</td><td align="left">Const or constexpr, Must be initialized</td></tr><tr><td align="left">Inline constant global variable</td><td align="left">inline constexpr int g_x { 1 };</td><td align="left">File</td><td align="left">Static</td><td align="left">External</td><td align="left">Const or constexpr, Must be initialized</td></tr></tbody></table><hr><h3 id="总结提前声明"><a href="#总结提前声明" class="headerlink" title="总结提前声明"></a>总结提前声明</h3><p>你可以在其他文件中对一个 函数/变量 进行提前声明：</p><table><thead><tr><th align="left">Type</th><th align="left">Example</th><th align="left">Notes</th></tr></thead><tbody><tr><td align="left">Function forward declaration</td><td align="left">void foo(int x);</td><td align="left">Prototype only, no function body</td></tr><tr><td align="left">Non-constant global variable forward declaration</td><td align="left">extern int g_x;</td><td align="left">Must be uninitialized</td></tr><tr><td align="left">Const global variable forward declaration</td><td align="left">extern const int g_x;</td><td align="left">Must be uninitialized</td></tr><tr><td align="left">Constexpr global variable forward declaration</td><td align="left">extern constexpr int g_x;</td><td align="left"><u>Not allowed, constexpr cannot be forward declared</u></td></tr></tbody></table><hr><h3 id="什么是存储类说明符"><a href="#什么是存储类说明符" class="headerlink" title="什么是存储类说明符?"></a>什么是存储类说明符?</h3><p>当关键字<code>static</code> 、<code>extern</code>用作标识符声明的一部分时,它们就被称为：<strong>storage class specifier（存储类说明符）</strong>。它们设置标识符的存储的 <em>duration</em> 和 <em>linkage</em></p><p>C++支持4中存储类说明符：</p><table><thead><tr><th align="left">Specifier</th><th align="left">Meaning</th><th align="left">Note</th></tr></thead><tbody><tr><td align="left">extern</td><td align="left">static (or thread_local) storage duration and external linkage</td><td align="left"></td></tr><tr><td align="left">static</td><td align="left">static (or thread_local) storage duration and internal linkage</td><td align="left"></td></tr><tr><td align="left">thread_local</td><td align="left">thread storage duration</td><td align="left">Introduced in C++11</td></tr><tr><td align="left">mutable</td><td align="left">object allowed to be modified even if containing class is const</td><td align="left"></td></tr><tr><td align="left">auto</td><td align="left">automatic storage duration</td><td align="left">Deprecated in C++11</td></tr><tr><td align="left">register</td><td align="left">automatic storage duration and hint to the compiler to place in a register</td><td align="left">Deprecated in C++17</td></tr></tbody></table><blockquote><p>术语 <em>storage class specifier</em> 通常只在正式文档中使用。</p></blockquote><hr><h2 id="6-12-using-语句"><a href="#6-12-using-语句" class="headerlink" title="6.12 using 语句"></a>6.12 using 语句</h2><p>如果你经常使用标准库，那么在使用标准库中的所有内容之前输入std::会变得重复。C++提供了一种可选择的办法，叫做：<strong><em>using statements</em></strong></p><h3 id="using的声明"><a href="#using的声明" class="headerlink" title="using的声明"></a>using的声明</h3><p>一种简化的方法是使用using声明语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="comment">// this using declaration tells the compiler that cout should resolve to std::cout</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!"</span>; <span class="comment">// so no std:: prefix is needed here!</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// the using declaration expires here</span></span><br></pre></td></tr></table></figure><blockquote><p>using 的声明：<code>using std::cout</code>告诉编译器我们将要使用 命名空间std 中的<code>cout</code>。所以当编译器看到cout时，它会假设我们指的是std::cout。</p><p>如果std::cout与cout的其他一些使用之间存在命名冲突，则首选std::cout。</p></blockquote><p>上面的例子，看起来似乎没有简化多少。但如果我们要多次使用<code>cout</code>时，使用 <code>using statements</code>就可以简化很多。</p><blockquote><p>注意，如果你多次使用<code>std::cout</code>和<code>std::cin</code>的话，你需要对他们两个分别使用<code>using statements</code></p></blockquote><hr><h3 id="using-指令"><a href="#using-指令" class="headerlink" title="using 指令"></a>using 指令</h3><p>另一种方法就是使用：<code>using directive</code>语句。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">//这个using指令 告诉编译器我们可以使用 命名空间std 中的任何东西</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world!"</span>; <span class="comment">// 所以，前缀 std:: 就可以省略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个using 指令 ：<code>using namespace std</code>告诉编译器我们想使用 命名空间std 中的任何东西。所以当编译器发现了一个名字它不认识时，它就会检查 命名空间std。</p><p>结果就是，当编译器遇到<code>cout</code>(编译器不认识cout)，编译器就会查看 命名空间std 然后找到cout。</p><hr><p>如果std::cout与cout的其他一些使用之间存在命名冲突，编译器将把它<strong>标记为错误</strong>(而不是选择其中之一)。</p></blockquote><p>下面来看一下 using 指令 造成的歧义：</p><ul><li><p>eg1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> a</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x&#123; <span class="number">10</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> b</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x&#123; <span class="number">20</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> a;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> b;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面例子中，编译器无法在mian函数中决定使用<code>a::x</code>还是<code>b::x</code>。然后就会出现“不明确的符号”错误。</p><p>要想解决这个冲突，我们可以加上前缀使用。即显示标明使用的是哪一个命名空间中的x。</p></blockquote></li><li><p>eg2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // imports the declaration of std::cout</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cout</span><span class="params">()</span> <span class="comment">// declares our own "cout" function</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">// makes std::cout accessible as "cout"</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, world!"</span>; <span class="comment">// uh oh!  Which cout do we want here?  The one in the std namespace or the one we defined above?</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>eg2中，编译器无法判断我们使用的<code>cout</code>是引用的 <code>std::cout</code>还是 cout函数。并出现“不明确的符号”错误。</p><hr><p>解决方法：</p><ol><li><p>使用<code>using declaration</code> 来替代 <code>using directive</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="comment">//告诉编译器， cout 指的是 std::cout</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, world!"</span>; <span class="comment">//所以cout表示的是 std::cout</span></span><br></pre></td></tr></table></figure></li><li><p>显示的使用前缀：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, world!"</span>; <span class="comment">//告诉编译器使用的是std::cout</span></span><br></pre></td></tr></table></figure></li></ol></blockquote></li></ul><hr><h3 id="取消or替换-using语句"><a href="#取消or替换-using语句" class="headerlink" title="取消or替换 using语句"></a>取消or替换 using语句</h3><p>一旦，using语句被声明，那就没有办法在声明它的范围内使用另一个using语句替换或取消它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Foo;</span><br><span class="line">    <span class="comment">//此时无法使用一个其他的 using语句来 取消或替换 “using namespace Foo;”</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//using namespace Foo ends here</span></span><br></pre></td></tr></table></figure><p>对应它的最好办法就是，显示的限制 using语句 的范围：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> Foo; <span class="comment">//在这里调用Foo::中的东西</span></span><br><span class="line">    &#125; <span class="comment">//using namespace Foo 过期</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span><span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，<strong>可以显式地使用范围解析操作符(::)来避免所有这些麻烦。</strong></p><hr><h2 id="6-13-typedef与类型别名"><a href="#6-13-typedef与类型别名" class="headerlink" title="6.13 typedef与类型别名"></a>6.13 typedef与类型别名</h2><center>**优先使用类型别名，而不是typedefs，并大量使用它们来记录类型的含义**</center><p><code>typedef</code>允许程序猿去创建一个数据类型的别名。然后可以使用别名来替换这个类型真正的名字。</p><blockquote><p>Typedef的字面意思是“<strong>类型定义”</strong></p></blockquote><p>我们可以使用关键字<code>typedef</code>，来进行 类型定义：</p><blockquote><p><code>typedef a b</code> ：其中<code>a</code>表示类型的名字，<code>b</code>表示类型被替换成的别名.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> <span class="keyword">distance_t</span>; <span class="comment">//定义distance_t 作为 double类型 的别名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面两个语句是等价的:</span></span><br><span class="line"><span class="keyword">double</span> howFar;</span><br><span class="line"><span class="keyword">distance_t</span> howFar;</span><br></pre></td></tr></table></figure><blockquote><p>按照惯例，typedef名称是使用“_t”后缀声明的。这有助于指示标识符代表的是类型，而不是变量或函数，还有助于防止与其他标识符的命名冲突。</p></blockquote><hr><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>为了帮助解决这些问题，我们引入了一种改进的typedefs语法，它模仿了变量的声明方式。这种语法称为 <strong>type alias(类型别名)</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> <span class="keyword">distance_t</span>; <span class="comment">//定义distance_t 作为 double类型的 别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">distance_t</span> = <span class="keyword">double</span>; <span class="comment">//定义distance_t 作为 double类型的 别名【推荐】</span></span><br></pre></td></tr></table></figure><blockquote><p>上面两个语句在功能上等价。</p><p>【NOTE】虽然使用了关键字<code>using</code>（在这里是重载的意义），但这和 与命名空间相关的 using语句 没有关系。</p></blockquote><hr><h4 id="为易读性使用类型别名"><a href="#为易读性使用类型别名" class="headerlink" title="为易读性使用类型别名"></a>为易读性使用类型别名</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GradeTest</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>我们可以看到返回值是一个整数，但是这个整数是什么意思呢?一个字母等级?遗漏了多少问题?学生的身份证号码?一个错误代码?谁知道!Int不能告诉我们任何东西。写成下面形式，便于理解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> testScore_t = <span class="keyword">int</span>;</span><br><span class="line"><span class="function">testScore_t <span class="title">GradeTest</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="使用类型别名编写与平台无关的代码"><a href="#使用类型别名编写与平台无关的代码" class="headerlink" title="使用类型别名编写与平台无关的代码"></a>使用类型别名编写与平台无关的代码</h4><p>比如，在一些平台中，<code>int</code>类型占2个字节；但在其他平台中，可能占4个字节。所以，在4字节平台中写的代码在2字节平台中可能会出错。</p><p>所以，使用类型别名可以帮助我们避免出错，也更清楚地说明了对变量大小的假设。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> INT_2_BYTES</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">int8_t</span> = <span class="keyword">char</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">int16_t</span> = <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">int32_t</span> = <span class="keyword">long</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">int8_t</span> = <span class="keyword">char</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">int16_t</span> = short;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">int32_t</span> = <span class="keyword">int</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><blockquote><p>如果，在一个机器中，整数是2个字节。那么<code>INT_2_BYTES</code>将被定义。此时，就使用的是上部定义的这几个。</p><p>如果，在一个机器中，整数是4个字节。那么<code>INT_2_BYTES</code>将不被定义。此时，就使用的是下部定义的这几个。</p><hr><p>这种情况下：通过使用char、short、int和long的组合，这对于正在编译程序的机器是合适的</p><p><code>int_8</code>将处理 1字节的整数；</p><p><code>int16_t</code>将处理 2字节的整数；</p><p><code>int32_t</code>将处理 4字节的整数。</p></blockquote><hr><h2 id="6-14-关键字auto"><a href="#6-14-关键字auto" class="headerlink" title="6.14 关键字auto"></a>6.14 关键字<code>auto</code></h2><p>看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d &#123;<span class="number">5.0</span>&#125;;</span><br></pre></td></tr></table></figure><p>如果C++早就知道<code>5.0</code>是double类型的数字，那为什么我们还要显示的指定<code>d</code>是double类型的呢？如果我们可以让一个变量根据我们初始化它的值来设想它的类型，这不是很好吗?</p><h3 id="初始化变量的类型推断"><a href="#初始化变量的类型推断" class="headerlink" title="初始化变量的类型推断"></a>初始化变量的类型推断</h3><p>当初始化一个变量，关键字<code>auto</code>可以用来代替类型，以告诉编译器从初始化器的类型推断变量的类型。这种就叫作：<strong><em>type inference</em>(类型推断)</strong>, 英文中也可以叫作：<strong><em>type deduction</em></strong></p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> d &#123;<span class="number">5.0</span>&#125;; <span class="comment">//因为5.0是一个double类型的数字，所以它的类型将被推断为double</span></span><br><span class="line"><span class="keyword">auto</span> i &#123;<span class="number">1</span>+<span class="number">2</span>&#125;; <span class="comment">//因为1+2的结果是int类型，所以，i 将被推断为int类型</span></span><br></pre></td></tr></table></figure><p>也可以用在函数返回值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sum&#123;add(<span class="number">5</span>,<span class="number">6</span>)&#125;; <span class="comment">//add() 返回一个int, 所以sum的类型将被推断为int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="在C-14中函数的类型推断"><a href="#在C-14中函数的类型推断" class="headerlink" title="在C++14中函数的类型推断"></a>在C++14中函数的类型推断</h3><p>在C++14中，关键字<code>auto</code>被扩展到可以从函数体中的返回语句推断出函数的返回类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为<code>x+y</code>的值是int类型，编译器将会推断这个函数应该返回一个int类型。当使用<code>auto</code>返回类型时，所有的返回语句就必须返回相同的类型，否则将会出错。</p></blockquote><p>但是不推荐对函数的返回类型使用关键字<code>auto</code>。</p><blockquote><p>因为没有上下文来帮助指示函数返回的类型。用户实际上必须深入函数体本身来确定函数返回的类型。它不那么直观，因此更容易出错。</p></blockquote><hr><h3 id="后置返回类型语法"><a href="#后置返回类型语法" class="headerlink" title="后置返回类型语法"></a>后置返回类型语法</h3><p>关键字<code>auto</code>也可以被用来<strong>后置返回类型(trailing return syntax)</strong>。即，在函数原型之后指定返回的类型。</p><blockquote><p>这是C++11新增的<strong>一种函数声明</strong>的方法。</p></blockquote><p>下面的两个对函数声明的语句是等价的：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">auto add(int x, int y) -&gt; int;//在这种情况下，auto不执行类型推断——使用后置返回类型只是语法的一部分。</span><br></pre></td></tr></table></figure><hr><p>那为什么要用后置类型返回语句呢？其中的好处之一就是：可以让函数的声明时的名字对齐😊，如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto add(int x, int y) -&gt; int;</span><br><span class="line">auto divide(double x, double y) -&gt; double;</span><br><span class="line">auto printSomething() -&gt; void;</span><br><span class="line">auto generateSubstring(const std::string &amp;s, int start, int len) -&gt; std::string;</span><br></pre></td></tr></table></figure><hr><h3 id="函数形参的类型推断"><a href="#函数形参的类型推断" class="headerlink" title="函数形参的类型推断"></a>函数形参的类型推断</h3><blockquote><p><strong>在C++20时引入的</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">auto</span> x, <span class="keyword">auto</span> y)</span> <span class="comment">//only valid in C++20</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    add(<span class="number">2</span>, <span class="number">3</span>);    <span class="comment">//int</span></span><br><span class="line">    add(<span class="number">1.1</span>, <span class="number">2.2</span>); <span class="comment">//double</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在C++20之前</strong>，这种形式是无效的。因为编译器在 编译时(complie time) 不能推断函数形参的类型。</p><blockquote><p>在C++20之前，如果你想要创建一个使用各种不同类型的泛型函数，你需要使用<code>function templates</code>，而不是现在用的<code>type inference</code></p></blockquote><hr><h3 id="6-15-强制类型转换-隐式"><a href="#6-15-强制类型转换-隐式" class="headerlink" title="6.15 强制类型转换(隐式)"></a>6.15 强制类型转换(隐式)</h3><blockquote><p>类型转换有两种形式：</p><ul><li><strong>implicit type conversion</strong>（隐式类型转换）：编译器会自动将一种数据类型转换为另一种数据类型</li><li><strong>explicit type conversion</strong>（显示类型转换）：开发人员使用转换操作符来指导转换。</li></ul></blockquote><p>将值从一种数据类型转换为另一种数据类型的过程称为<strong><em>type conversion</em>(类型转换)</strong>。类型转换可以在许多不同的情况下发生:</p><ul><li><p>当用不同数据类型的值 分配 或 初始 化一个变量时:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d&#123;<span class="number">3</span>&#125;;  <span class="comment">// initialize double variable with integer value 3</span></span><br><span class="line">d = <span class="number">6</span>;    <span class="comment">// assign double variable the integer value 6</span></span><br></pre></td></tr></table></figure></li><li><p>当传递一个值给一个函数时，但函数参数是不同的数据类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">long</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">doSomething(<span class="number">3</span>); <span class="comment">// pass integer value 3 to a function expecting a long parameter</span></span><br></pre></td></tr></table></figure></li><li><p>当从一个函数返回一个值时，该函数的返回类型是不同的数据类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3.0</span>; <span class="comment">// Return double value 3.0 back to caller through float return type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用不同类型的操作数的 二元操作符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> division&#123; <span class="number">4.0</span> / <span class="number">3</span> &#125;; <span class="comment">// division with a double and an integer</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p><strong>隐式类型转换</strong>(也称为<strong>自动类型转换</strong>或<strong>强制转换</strong>)在希望是这种数据类型，但提供了另一种数据类型。乳沟编译器能够辨认出类型转换中的两种类型，挠他就转换。否则，报错。</p><blockquote><p>隐式类型转换有两种基本类型：<strong>提升</strong>和<strong>转换</strong>。</p></blockquote><ul><li><p><strong><em>Numeric promotion</em>数值提升</strong></p><p>每当将一个基本数据类型的值转换为来自同一族的更大的基本数据类型的值时，这称为<strong>数值提升</strong>(或<strong>加宽</strong>，尽管这个术语通常用于整数)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//an int can be widened into a long, or a float promoted into a double:</span></span><br><span class="line"><span class="keyword">long</span> l&#123; <span class="number">64</span> &#125;; <span class="comment">// widen the integer 64 into a long</span></span><br><span class="line"><span class="keyword">double</span> d&#123; <span class="number">0.12f</span> &#125;; <span class="comment">// promote the float 0.12 into a double</span></span><br></pre></td></tr></table></figure><p>虽然术语数值推广涵盖了任何类型的提升，但在c++中还有两个具有特定含义的术语:</p><ul><li><strong>Integral promotion(整型提升)</strong>：可以将[ <code>bool</code> , <code>char</code>, <code>unsigned char</code>, <code>signed char</code>, <code>unsigned short</code>, and <code>signed short</code> ]这些类型转换为 <code>int</code>或者是<code>unsigned int</code></li><li><strong>Floating point promotion(浮点型提升)</strong>：可以将<code>float</code>类型转换为<code>double</code></li></ul><p>整型提升 和 浮点型提升 通常是将 较小的数据类型转换为<code>int</code>/<code>unsigned int</code>或<code>double</code>。</p><hr></li><li><p><strong>Numeric conversions(数值转换)</strong></p><p>当我们将一个值从较大的类型转换为类似的较小类型时，或者在不同类型之间转换时，这称为数值转换。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d&#123; <span class="number">3</span> &#125;; <span class="comment">// convert integer 3 to a double (between different types)</span></span><br><span class="line">short s&#123; <span class="number">2</span> &#125;; <span class="comment">// convert integer 2 to a short (from larger to smaller type within same type family)</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>数值提升</strong>是安全的；但是<strong>数值转换</strong>可能会丢失数据。</p><blockquote><p>因此，导致执行隐式转换的代码通常会导致编译器发出警告。</p></blockquote></blockquote><p>eg,将一个值转换为的类型没有足够大的范围来支持这个值，就会出现意想不到的结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i&#123; <span class="number">30000</span> &#125;;</span><br><span class="line">    <span class="keyword">char</span> c = i; <span class="comment">// chars have range -128 to 127</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(c);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果**********/</span></span><br><span class="line"><span class="number">48</span></span><br></pre></td></tr></table></figure><blockquote><p>在本例中，我们将一个大整数分配给一个char(其范围为-128到127)。这会导致char溢出，并产生一个意外的结果: 48</p></blockquote><p>但是，只要值符合较小类型的范围，从较大的整数或浮点类型转换为较小的类似类型通常就可以工作。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> i&#123; <span class="number">2</span> &#125;;</span><br><span class="line">    short s = i; <span class="comment">// convert from int to short</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">double</span> d&#123; <span class="number">0.1234</span> &#125;;</span><br><span class="line">    <span class="keyword">float</span> f = d;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********结果**************/</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">0.1234</span></span><br></pre></td></tr></table></figure><p>对于浮点值，由于较小类型的精度损失，可能会出现一些舍入。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">0.123456789</span>; <span class="comment">// double value 0.123456789 has 9 significant digits, but float can only support about 7</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">9</span>) &lt;&lt; f &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// std::setprecision defined in 头文件“iomanip”中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************结果************/</span></span><br><span class="line"><span class="number">0.123456791</span></span><br></pre></td></tr></table></figure><p>只要值符合浮点类型的范围，就可以将整数转换为浮点数。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> i&#123; <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">float</span> f = i;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************结果**************/</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>只要值符合整数的范围，就可以将浮点数转换为整数，但是任何小数值都会丢失。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> i = <span class="number">3.5</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***在本例中，丢失了分数值(.5)，结果如下:****/</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>计算算术表达式</strong></p><p>当计算表达式时，编译器将每个表达式分解成单独的子表达式。算术运算符要求它们的<strong>操作数必须是相同的类型</strong>。为了确保这一点，编译器使用以下规则:</p><ul><li><p>如果一个操作数是一个比<code>int</code>更窄的整数，它将经历整数提升(如上所述)到<code>int</code>或<code>usigned int</code>。</p></li><li><p>如果操作数仍然不匹配，那么编译器会找到优先级最高的操作数，并隐式地将另一个操作数转换为匹配的操作数。</p><blockquote><p>操作数的优先级如下:</p><ul><li>long double (highest)</li><li>double</li><li>float</li><li>unsigned long long</li><li>long long</li><li>unsigned long</li><li>long</li><li>unsigned int</li><li>int (lowest)</li></ul></blockquote></li></ul><p>我们可以通过使用typeid操作符(包含在头中)看到通常的算术转换，该操作符可用于显示表达式的结果类型。</p><p>eg1:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt; // for typeid()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    short a&#123; <span class="number">4</span> &#125;;</span><br><span class="line">    short b&#123; <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(a + b).name() &lt;&lt; <span class="string">" "</span> &lt;&lt; a + b &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// show us the type of a + b</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*因为short是整数，所以它们在被添加之前要经过整数提升到int。添加两个int的结果是一个int，正如您所期望的:*/</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><blockquote><p>注意:编译器可能会显示一些稍微不同的内容，因为typeid.name()的格式由编译器决定。</p></blockquote><p>eg2:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt; // for typeid()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d&#123; <span class="number">4.0</span> &#125;;</span><br><span class="line">    short s&#123; <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(d + s).name() &lt;&lt; <span class="string">' '</span> &lt;&lt; d + s &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// show us the type of d + s</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****结果*************/</span></span><br><span class="line"><span class="keyword">double</span> <span class="number">6.0</span></span><br></pre></td></tr></table></figure><p>在这种情况下，<code>short</code>将被 <em>数值提升</em> 为<code>int</code>。但是，<code>int</code>与<code>double</code>还是不匹配。又因为<code>double</code>在类型的层次结构中更高。所以，整型的2将被转换为double 类型的 2.0 。然后就相当于是两个double类型的相加，结果还是double类型.</p></li></ul><hr><h2 id="强制类型转换-显式-amp-static-cast"><a href="#强制类型转换-显式-amp-static-cast" class="headerlink" title="强制类型转换(显式) &amp; static_cast"></a>强制类型转换(显式) &amp; <code>static_cast</code></h2><p>显式的类型转换是使用 <strong>type casting operator(类型转换操作符)</strong>。（通常是程序员来做的一个显式的的类型转换）</p><p>在C++中，类型转换大致分为5种： <code>C-style casts</code>, <code>static casts</code>, <code>const casts</code>, <code>dynamic casts</code>, and <code>reinterpret casts</code>. 后四个有时被称为<strong>命名类型转换(named casts)</strong>。</p><p>在本节课中，我们将介绍c风格的类型转换和静态类型转换。我们将在以后的课程中讨论指针和继承时再保存动态类型转换。</p><blockquote><p>通常应该避免使用<code>Const casts</code>和<code>reinterpret casts</code>，因为它们只在极少数情况下有用，如果使用不当可能会有害。</p></blockquote><hr><h3 id="C-style-casts"><a href="#C-style-casts" class="headerlink" title="C-style casts"></a>C-style casts</h3><p>在标准的C语言中，类型转换是通过 <strong>操作符<code>()</code></strong>来完成的。括号内是将要转换的目标类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i1 &#123; <span class="number">10</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> i2 &#123; <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">float</span> f &#123; (<span class="keyword">float</span>)i1 / i2 &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>在上面的程序中，我们使用浮点c风格的强制转换来告诉编译器将<code>i1</code>转换为浮点值。</p><p>因为运算符<code>/</code>的左操作数现在变为浮点值，右操作符也将被转换为浮点值。并且除法将使用浮点除法而不是整数除法!</p></blockquote><hr><p><strong>使用强制类型转换来清除隐式类型转换</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i &#123; <span class="number">48</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// explicit conversion from int to char, so that a char is assigned to variable ch</span></span><br><span class="line"><span class="keyword">char</span> ch = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(i);</span><br></pre></td></tr></table></figure><blockquote><p>当我们这样做时，我们显式地告诉编译器这个转换是有意的，并且我们接受对结果的责任。因为这个<code>static_cast</code>的输出类型是char，所以对变量ch的赋值不会产生任何类型不匹配，因此没有警告。</p></blockquote><p>下面的程序，编译器将会抱怨将double转换成int可能会导致数据丢失:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i &#123; <span class="number">100</span> &#125;;</span><br><span class="line">i = i / <span class="number">2.5</span>;</span><br></pre></td></tr></table></figure><p>告诉编译器，我们明确的意思是这样做:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i &#123; <span class="number">100</span> &#125;;</span><br><span class="line">i = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(i / <span class="number">2.5</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="6-17-未命名-内联-命名空间"><a href="#6-17-未命名-内联-命名空间" class="headerlink" title="6.17 未命名/内联 命名空间"></a>6.17 未命名/内联 命名空间</h2><h3 id="未命名-匿名-命名空间"><a href="#未命名-匿名-命名空间" class="headerlink" title="未命名(匿名) 命名空间"></a>未命名(匿名) 命名空间</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> <span class="comment">// unnamed namespace</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="comment">// can only be accessed in this file</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    doSomething(); <span class="comment">// we can call doSomething() without a namespace prefix</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果**********/</span></span><br><span class="line">v1</span><br></pre></td></tr></table></figure><blockquote><p>在未命名的命名空间中声明的所有内容都被视为父命名空间的一部分。因此，尽管<code>doSomething</code>函数是在未命名的命名空间中定义的，但函数本身可以从父命名空间(在本例中是<code>global namespace</code>)访问，这就是为什么我们可以从main调用doSomething而不需要任何限定符。</p></blockquote><p>这可能使未命名的命名空间看起来毫无用处。但未命名名称空间的另一个影响是：未命名命名空间内的所有标识符都被视为具有<strong>内部链接</strong>，<u>这意味着未命名命名空间的内容就不能在其他文件中看到</u>。</p><hr><p><strong>对于函数</strong>，<u>这实际上等同于将未命名的命名空间中的所有函数定义为<strong>静态函数</strong></u>。下面的程序与上面的程序实际上是相同的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="comment">// can only be accessed in this file</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    doSomething(); <span class="comment">// we can call doSomething() without a namespace prefix</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong><code>unnamed namespace</code></strong>通常用于 当你有很多内容想要确保在给定文件中保持局部时，使用<code>unnamed namespace</code>要比单独将所有声明标记为<code>static</code>更容易。</p><hr><h3 id="内联-命名空间"><a href="#内联-命名空间" class="headerlink" title="内联 命名空间"></a>内联 命名空间</h3><blockquote><p><strong>Inline namespaces</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    doSomething();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是假设你对doSomething不满意，你想通过改变它的行为方式来改进它。但如果这样做，就有可能破坏使用旧版本的现有程序。你是怎么处理的?</p><ul><li><p>一种方法是用不同的名称创建函数的新版本。但是经过许多更改之后，您可能会得到一组名称几乎相同的函数(doSomething、doSomething_v2、doSomething_v3等)。</p></li><li><p>【推荐】另一种方法是使用<strong>内联命名空间</strong>。<u>内联命名空间是通常用于版本化内容的名称空间</u>。与未命名的命名空间非常相似，<u>在内联命名空间中声明的任何内容都被认为是父名称空间的一部分</u>。<u>然而，内联命名空间并不是 内部链接。</u></p><blockquote><p>使用关键字<code>inline</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">namespace</span> v1 <span class="comment">// declare an inline namespace named v1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> v2 <span class="comment">// declare a normal namespace named v2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v2\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    v1::doSomething(); <span class="comment">// calls the v1 version of doSomething()</span></span><br><span class="line">    v2::doSomething(); <span class="comment">// calls the v2 version of doSomething()</span></span><br><span class="line"> </span><br><span class="line">    doSomething(); <span class="comment">// calls the inline version of doSomething() (which is v1)</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********结果********/</span></span><br><span class="line">v1</span><br><span class="line">v2</span><br><span class="line">v1</span><br></pre></td></tr></table></figure><blockquote><p>可以看出，当有 <strong>内联函数</strong>存在时，<u>如果不加前缀，<strong>则默认调用的是 内联函数版本</strong></u></p></blockquote><p>在上面的例子中，调用<code>doSomething</code>将得到<code>doSomething</code>的v1(内联版本)。希望使用新版本的调用者可以<strong>显式</strong>地调用<code>v2::dosomething()</code>。</p><blockquote><p>这保留了现有程序的功能，同时允许更新的程序利用更新的/更好的变体。</p></blockquote><hr></li></ul><h2 id="6-x-Chapter-6-summary-and-quiz"><a href="#6-x-Chapter-6-summary-and-quiz" class="headerlink" title="6.x Chapter 6 summary and quiz"></a>6.x Chapter 6 summary and quiz</h2><p><a href="https://www.learncpp.com/cpp-tutorial/chapter-6-summary-and-quiz/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/chapter-6-summary-and-quiz/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;p center large&gt;&lt;red&gt;LearnCpp chapter6&lt;/red&gt;&lt;/p&gt;&lt;/center&gt;&lt;center&gt;&lt;red&gt;https://www.learncpp.com&lt;/red&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C/C++" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"/>
    
    
      <category term="C/C++" scheme="https://longlongqin.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>GIT 学习</title>
    <link href="https://longlongqin.github.io/archives/18085cf9.html"/>
    <id>https://longlongqin.github.io/archives/18085cf9.html</id>
    <published>2020-04-05T06:08:23.000Z</published>
    <updated>2020-04-05T06:10:19.408Z</updated>
    
    <content type="html"><![CDATA[<center><p center large><red></red>Git学习笔记</p></center><a id="more"></a><p>Git的三种状态：</p><blockquote><p>committed（已提交）：数据已经安全的保存在本地数据库（仓库）；</p><p>modified（已修改）：修改了文件，<strong>但还没有保存到数据库</strong>；</p><p>staged（已暂存）：对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</p></blockquote><p>Git项目的三个工作区域概念：</p><blockquote><p><strong>Git仓库（Git directory 或 repository）：</strong>是Git用来保存项目的元数据和对象数据库的地方。是Git最重要部分，从其他计算机克隆仓库时，拷贝的就是这里的数据。</p><p><strong>工作目录（working directory）：</strong>对项目的某个版本独立提取出来的内容。这些从Git仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</p><p><strong>暂存区域（staging area）：</strong>是一个文件，保存了下一次将提交的文件列表信息，一般在Git仓库目录中，有时也被称作“索引”。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/1576831394522.png" alt="1576831394522"></p><p>基本的 Git 工作流程如下：</p><blockquote><p>1.在工作目录中修改文件；</p><p>2.暂存文件，将文件的快照放入暂存区域；</p><p>3.提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目。</p></blockquote><h1 id="初始设置："><a href="#初始设置：" class="headerlink" title="初始设置："></a>初始设置：</h1><h2 id="设置姓名和邮箱："><a href="#设置姓名和邮箱：" class="headerlink" title="设置姓名和邮箱："></a>设置姓名和邮箱：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Firstname Lastname&quot; &#x2F;&#x2F; 名字使用英文输入</span><br><span class="line">git config --global user.email &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><p>这个命令，会在“<code>~/.gitconfig</code>”中以如下形式输出设置文件。我的电脑上，这个文件夹的位置在<code>C:\Users\ACER</code></p><h2 id="设置SSH-key"><a href="#设置SSH-key" class="headerlink" title="设置SSH key:"></a>设置<code>SSH key</code>:</h2><p>创建公开密钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，我的在：<code>C:\Users\ACER\.ssh</code></p><p>里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是<strong>私钥</strong>，不能泄露出去，<code>id_rsa.pub</code>是<strong>公钥</strong>，可以放心地告诉任何人。</p><h2 id="初始化Git仓库："><a href="#初始化Git仓库：" class="headerlink" title="初始化Git仓库："></a>初始化Git仓库：</h2><p>在该仓库中，打开Git bash，然后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><h2 id="关联远程仓库："><a href="#关联远程仓库：" class="headerlink" title="关联远程仓库："></a>关联远程仓库：</h2><p>在远程仓库（如：<code>github、gitee</code>）中有一个新仓库什么都没有，我们可以：</p><p>克隆一份到本地；也可以把一个已有的本地仓库与之关联。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git remote add &lt;远程仓库名字&gt; &lt;远程仓库的SSH或HTTPS&gt;</span><br><span class="line"></span><br><span class="line">如：git remote add origin git@github.com:michaelliao&#x2F;learngit.git</span><br><span class="line">其中：</span><br><span class="line">远程仓库名字：origin（是git的默认叫法，也可以写成其他的）</span><br><span class="line">远程仓库的SSH：git@github.com:longlongqin&#x2F;learngit.git</span><br></pre></td></tr></table></figure><ul><li><input checked disabled type="checkbox"> <strong>当需要将<u>一个仓库</u>同时在<code>github 和 gitee</code>上关联时：</strong></li></ul><ol><li><p>假如在<code>gitee</code>上关联之前，已经在<code>GitHub</code>上关联过了。</p><p>比如事先在GitHub上：<code>git remote add origin git@github.com:longlongqin/LearnGit.git</code>，关联了一个叫<code>origin</code>的远程仓库。</p><p>然后，我现在要在gitee上关联一个仓库：</p><p><code>git remote add origin git@gitee.com:longlongqin/LearnGit.git</code></p><p>出现<u>报错</u>：fatal: remote origin already exists.说明，本地库已经关联了一个叫做<code>origin</code>的远程仓库了，所以才会报错。</p></li><li><p>所以，我们知道，不能将github和gitee上的仓库名字都叫一样的名字。他们之间的名字要区分。</p></li></ol><blockquote><ul><li><p>先，删除关联的已有的GitHub远程库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure></li><li><p>再开始重新关联github和gitee的仓库，这次要将他们的仓库名字区分开：</p><p>/*gitee中的LearnGit仓库起名：<code>gitee</code>；</p><p>/*github中的LearnGit仓库起名：<code>github</code>；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote gitee origin git@gitee.com:longlongqin&#x2F;LearnGit.git</span><br><span class="line">git remote github origin git@github.com:longlongqin&#x2F;LearnGit.git</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>检查一下，是否成功：</p><p>​ 我们用<code>git remote -v</code>查看远程库信息，可以看到两个远程库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">giteegit@gitee.com:longlongqin&#x2F;LearnGit.git (fetch)</span><br><span class="line">giteegit@gitee.com:longlongqin&#x2F;LearnGit.git (push)</span><br><span class="line">githubgit@github.com:longlongqin&#x2F;LearnGit.git (fetch)</span><br><span class="line">githubgit@github.com:longlongqin&#x2F;LearnGit.git (push)</span><br></pre></td></tr></table></figure><p>成功。</p><h2 id="取消关联远程仓库："><a href="#取消关联远程仓库：" class="headerlink" title="取消关联远程仓库："></a>取消关联远程仓库：</h2><p>在<strong><em>关联远程仓库</em></strong>一节中，关联远程仓库，我们也可以取消以经关联的远程仓库，让他们取消关联：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm &lt;要取消关联的远程仓库的名字&gt;</span><br></pre></td></tr></table></figure><h1 id="时光穿梭机"><a href="#时光穿梭机" class="headerlink" title="时光穿梭机"></a>时光穿梭机</h1><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><blockquote><p>1、<strong>没有<code>git add</code>时</strong>（即，对文件做了修改，但是没添加到暂存区）：==用<code>git checkout -- &lt;file&gt;</code> (==file前面有一个<strong>空格</strong>)</p><p>2、<strong>已经<code>git add</code>时</strong>（即，对文件做了修改，并且添加到暂存区）：</p><ul><li>先<code>git reset HEAD &lt;file&gt;</code>把暂存区的修改撤销掉，即：回退到没有git add时的状态</li><li>然后，再<code>git checkout -- &lt;file&gt;</code>。</li></ul><p>3、<strong>已经<code>git commit</code>时</strong>（即，对文件做了修改，不仅添加到暂存区，而且还提交到本地仓库中了）：进行==<strong>版本回退</strong>==</p></blockquote><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>版本之间的切换，<strong>版本</strong>指的是<code>git commit</code>之后带有哈希值的状态。</p><p><strong>版本回退</strong>：</p><ul><li><p><code>git reset --hard commit_id</code> 可以回退到版本号为commit_id的那个版本。</p></li><li><p><code>git reset --hard head^</code> 回退到当前版本的上一个版本。</p></li></ul><p><strong>转回到新版本</strong>：</p><p>因为<code>git log</code>显示的是从此刻<code>head指针</code>所在的状态到之前的状态的提交日志。而<code>git reflog</code>用来记录你的每一次命令。</p><p>所以转回到比当前所在的状态要新的状态需要：</p><ol><li><code>git reflog</code>,找到你想要回去的那个较新的状态的commit 的id</li><li><code>git reset --hard &lt;commit_id&gt;</code> 回到想要回器的那个版本。</li></ol><h1 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h1><ul><li><code>rm &lt;file&gt;</code>从工作区中删除文件（和手动删除文件效果一样。）</li></ul><p><code>git rm &lt;file&gt;</code>将文件从工作区删除，并且还添加到了暂存区（即，把删除的这个状态同步到暂存区了）。</p><p>[^小提示]: 先手动删除文件，然后使用git rm<file>和git add<file>效果是一样的。</file></file></p><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><h2 id="添加远程仓库："><a href="#添加远程仓库：" class="headerlink" title="添加远程仓库："></a>添加远程仓库：</h2><blockquote><p>关联一个远程仓库：<code>git remote add origin git@github.com:path/repo-name.git</code></p><p>关联后，<strong>第一次</strong>推送master分支的所有内容：<code>git push origin master</code></p></blockquote><h2 id="远程仓库克隆："><a href="#远程仓库克隆：" class="headerlink" title="远程仓库克隆："></a>远程仓库克隆：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;你想要克隆内容的公开密钥的密码&gt;</span><br></pre></td></tr></table></figure><p>公开的密钥密码，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200218130632774.png" alt="image-20200218130632774"></p><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><h2 id="创建与合并分支："><a href="#创建与合并分支：" class="headerlink" title="创建与合并分支："></a>创建与合并分支：</h2><ul><li><p><strong>查看分支</strong>：<code>git branch</code></p></li><li><p><strong>新建分支</strong>：<code>git branch &lt;name&gt;</code></p></li><li><p><strong>创建并切换分支</strong>：<code>git checkout -b &lt;name&gt;</code> or <code>git switch -c &lt;name&gt;</code></p></li><li><p><strong>切换分支</strong>：<code>git checkout &lt;name&gt;</code> or <code>git switch &lt;name&gt;</code></p></li><li><p><strong>删除分支</strong>：<code>git branch -d &lt;name&gt;</code><em>不能删除当前所在的分支</em></p></li><li><p><strong>合并分支</strong>：<code>git merge &lt;name&gt;</code> <em>用于合并分支到<strong>当前</strong>分支</em></p></li></ul><blockquote><p><code>git merge --no-ff &lt;name&gt;</code> 其中参数–no-ff：表示在历史记录中明确记录下本次分支合并。</p><p><strong>注意</strong>：输入此命令之后，会启动编辑器，用于录入合并提交的信息。</p></blockquote><h2 id="解决冲突："><a href="#解决冲突：" class="headerlink" title="解决冲突："></a>解决冲突：</h2><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p><p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p><p>用<code>git log --graph</code>命令可以看到分支合并图。</p><h2 id="分支管理策略："><a href="#分支管理策略：" class="headerlink" title="分支管理策略："></a>分支管理策略：</h2><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p><p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p><p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p><p>所以，团队合作的分支看起来就像这样：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/0.png" alt="0"></p><p>小结：</p><p>Git分支十分强大，在团队开发中应该充分应用。</p><p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p><h2 id="合并分支的两种方式："><a href="#合并分支的两种方式：" class="headerlink" title="合并分支的两种方式："></a>合并分支的两种方式：</h2><p><strong>git 的 <code>merge</code> 与 <code>merge no-ff</code> 的不同之处</strong>： <code>no-ff merge</code>可以看到合并历史。</p><blockquote><ol><li><p>新建分支<code>dev1</code>，修改<code>readme.txt</code>，然后在<code>dev1</code>分支下<code>git add readme.txt</code> <code>git commit -m &quot;dev1 branch commit&quot;</code></p></li><li><p>回到<code>master</code>分支，执行merge即<code>git merge dev1</code></p></li><li><p>删除分支</p></li><li><p>查看日志即<code>git log --graph --pretty=oneline --abbrev-commit</code></p></li><li><p>新建分支<code>dev2</code>，修改<code>readme.txt</code>，然后在<code>dev2</code>分支下<code>git add readme.txt</code> <code>git commit -m &quot;dev2 branch commit&quot;</code></p></li><li><p>回到<code>master</code>分支，执行merge即<code>git merge --no-ff -m &quot;dev2 merged with mo-ff&quot; dev2</code></p></li><li><p>删除分支</p></li><li><p>查看日志即<code>git log --graph --pretty=oneline --abbrev-commit</code></p></li><li><p>比较两次合并，可以看出不同之处，<code>no-ff</code>的模式会记录分支历史、</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://app.yinxiang.com/FileSharing.action?hash=1/792dd8c14a3b3fed2cf0044d82d01671-16494" alt="img"></p></li></ol></blockquote><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查 Git 的某一项配置：</span></span><br><span class="line">git <span class="built_in">config</span>  &lt;key&gt; </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/1576832423904.png" alt="1576832423904"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//列出所有 Git 当时能找到的配置：</span></span><br><span class="line"> git <span class="built_in">config</span> --<span class="built_in">list</span> </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/1576832563424.png" alt="1576832563424"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取帮助：3种方法</span></span><br><span class="line">$ git help &lt;verb&gt;</span><br><span class="line">$ git &lt;verb&gt; --help</span><br><span class="line">$ man git-&lt;verb&gt;</span><br></pre></td></tr></table></figure></blockquote><h1><a href="#" class="headerlink" title="###############################################"></a>###############################################</h1><h1 id="Git-其他指令："><a href="#Git-其他指令：" class="headerlink" title="Git 其他指令："></a>Git 其他指令：</h1><h2 id="查看工作区状态status："><a href="#查看工作区状态status：" class="headerlink" title="查看工作区状态status："></a>查看<code>工作区</code>状态<code>status</code>：</h2><p><code>git status</code>查看的是工作区的状态。</p><blockquote><p><code>git diff</code> 查看工作区与暂存区的区别。</p><p><code>git diff head</code>查看工作区与本地仓库的区别。</p></blockquote><h2 id="查看文件内容："><a href="#查看文件内容：" class="headerlink" title="查看文件内容："></a>查看文件内容：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;name&gt;</span><br></pre></td></tr></table></figure><h2 id="提交："><a href="#提交：" class="headerlink" title="提交："></a>提交：</h2><h3 id="工作区提交到暂存区："><a href="#工作区提交到暂存区：" class="headerlink" title="工作区提交到暂存区："></a>工作区提交到暂存区：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &quot;filename&quot;</span><br></pre></td></tr></table></figure><h3 id="暂存区提交到本地仓库："><a href="#暂存区提交到本地仓库：" class="headerlink" title="暂存区提交到本地仓库："></a>暂存区提交到本地仓库：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;message&quot; &#x2F;&#x2F;message是对此次提交的一个说明语句</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br><span class="line">&#x2F;&#x2F;此命令可以更加详细的记述提交信息（运行此命令后，会自动打开Git设置好的编辑器）</span><br></pre></td></tr></table></figure><blockquote><p>执行此命令后，编辑器就会启动，显示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with &#39;#&#39; will be ignored, and an empty message aborts the commit.</span><br><span class="line">#</span><br><span class="line"># On branch dev</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#modified:   readme.txt</span><br><span class="line">#</span><br></pre></td></tr></table></figure><p>在编辑器中记述提交信息的格式如下：</p><p>● 第一行：用一行文字简述提交的更改内容</p><p>● 第二行：空行</p><p>● 第三行以后：记述更改的原因和详细内容</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200218142052540.png" alt="image-20200218142052540"></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend :修改上一条提交时写的信息</span><br></pre></td></tr></table></figure><h3 id="本地仓库提交-推送-到远程仓库："><a href="#本地仓库提交-推送-到远程仓库：" class="headerlink" title="本地仓库提交(推送)到远程仓库："></a>本地仓库提交(推送)到远程仓库：</h3><center>git push</center><p><strong>情况一：</strong></p><p>注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以git pull是&lt;远程分支&gt;:&lt;本地分支&gt;，而git push是&lt;本地分支&gt;:&lt;远程分支&gt;。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程仓库名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure><p><strong>情况二：（推荐）</strong></p><p>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程仓库名字&gt; &lt;将本地的分支推送到远程仓库的分支（本地分支和远程分支的名字一样）&gt;</span><br><span class="line"></span><br><span class="line">如：git push origin master</span><br><span class="line">上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。</span><br></pre></td></tr></table></figure><p><strong>情况三：</strong></p><p>下面命令将本地的<code>master</code>分支推送到<code>origin</code>远程仓库，同时指定<code>origin</code>为默认仓库，后面就可以不加任何参数使用<code>git push</code>了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u &lt;远程仓库名字&gt; &lt;将本地的分支推送到远程仓库的分支（本地分支和远程分支的名字一样）&gt;</span><br></pre></td></tr></table></figure><p><strong>情况四：</strong></p><p>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push origin :&lt;远程分支&gt;</span><br><span class="line"></span><br><span class="line"># 等同于:git push origin --<span class="keyword">delete</span> master</span><br></pre></td></tr></table></figure><h2 id="获取最新的远程仓库的分支："><a href="#获取最新的远程仓库的分支：" class="headerlink" title="获取最新的远程仓库的分支："></a>获取最新的远程仓库的分支：</h2><p>加入在远程仓库中的一个分支中的内容更新了，而本地的这个分支（和远程的这个分支名字相同）不是最新的，可以用<code>git pull</code>来同步。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;远程仓库名&gt; &lt;需要更新的分支（这个分支名：本地的和远程的名字一样）&gt;</span><br></pre></td></tr></table></figure><p>如：</p><p><code>git pull origin feature-D</code>，表示：从远程仓库<code>origin</code>中的“<code>feature-D</code>”分支进行对本地的分支“<code>feature-D</code>”更新。</p><h2 id="查看提交历史："><a href="#查看提交历史：" class="headerlink" title="查看提交历史："></a>查看提交历史：</h2><ul><li><p><code>git log</code> 查看提交（commit）历史（以便确定要回退到哪个版本）。</p><p>​ 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数，即：<code>git log --pretty=oneline</code></p></li></ul><blockquote><ul><li><p><code>git log &lt;filename&gt;</code> ：显示特定文件(filename)的提交历史</p></li><li><p><code>git log -p</code> ：文件的前后差别就会显示在提交信息之后</p></li><li><p><code>git log -p &lt;filename&gt;</code> ：只查看 “filename”文件的提交日 志以及提交前后的差别。</p></li><li><p><code>git log --graph</code>：以图表形式查看分支，例如下图：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200222002143874.png" alt="image-20200222002143874"></p></blockquote><ul><li><code>git reflog</code> 查看历史的每一次的命令（以便确定要回到未来的哪个版本）。</li></ul><h2 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git:"></a>自定义Git:</h2><h3 id="修改GIT默认编辑器："><a href="#修改GIT默认编辑器：" class="headerlink" title="修改GIT默认编辑器："></a>修改GIT默认编辑器：</h3><p>GIT默认编辑器为Vi，假如我想用<code>Notepad++</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitconfig--globalcore.editor&quot;Notepad++&quot;&#x2F;&#x2F;设置Editor使用Notepad++</span><br></pre></td></tr></table></figure><h3 id="Git显示颜色："><a href="#Git显示颜色：" class="headerlink" title="Git显示颜色："></a>Git显示颜色：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global color.ui true</span><br></pre></td></tr></table></figure><h1 id="-1"><a href="#-1" class="headerlink" title="##################################################"></a>##################################################</h1><h1 id="学习廖雪峰教学中的问题："><a href="#学习廖雪峰教学中的问题：" class="headerlink" title="学习廖雪峰教学中的问题："></a>学习廖雪峰教学中的问题：</h1><p>1、与教学步骤中的命令区别于：“–”</p><p>（1）<code>git diff head --readme.txt</code>：</p><p>问题：在我自己电脑上面运行没反应？</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200112221142249.png" alt="image-20200112221142249"></p><p><strong>解决：</strong></p><p>运行<code>：git diff head readme.txt</code>,即去掉那个“–”。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200112221407621.png" alt="image-20200112221407621"></p><p>（2）<code>git checkout --readme.txt</code></p><p>问题：在于我的电脑上多了“–”会运行失败。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200112222013881.png" alt="image-20200112222013881"></p><p>解决：去掉“–”：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200112222046360.png" alt="image-20200112222046360"></p><hr><h1 id="GitHub使用技巧"><a href="#GitHub使用技巧" class="headerlink" title="GitHub使用技巧"></a><a href="https://www.zhihu.com/question/20084458" target="_blank" rel="noopener">GitHub使用技巧</a></h1><h2 id="搜索："><a href="#搜索：" class="headerlink" title="搜索："></a>搜索：</h2><h3 id="1）、在不同地方搜索"><a href="#1）、在不同地方搜索" class="headerlink" title="1）、在不同地方搜索"></a>1）、在不同地方搜索</h3><h4 id="1、按照name搜索"><a href="#1、按照name搜索" class="headerlink" title="1、按照name搜索"></a>1、<strong>按照<code>name</code>搜索</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in:name &lt;something&gt;    &#x2F;&#x2F;假设想搜索的东西叫：something</span><br></pre></td></tr></table></figure><h4 id="2、按照readme搜索"><a href="#2、按照readme搜索" class="headerlink" title="2、按照readme搜索"></a>2、按照<code>readme</code>搜索</h4><p>也可以按照<code>readme.md</code>中包含<something>的查找项目：</something></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in:readme &lt;something&gt;   &#x2F;&#x2F;假设想搜索的东西叫：something</span><br></pre></td></tr></table></figure><h4 id="3、按照descriptin搜索"><a href="#3、按照descriptin搜索" class="headerlink" title="3、按照descriptin搜索"></a>3、按照<code>descriptin</code>搜索</h4><p>假设我们现在要学习<something>的项目，我们搜索项目描述(description)里面包含<something>的项目:</something></something></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in:description &lt;something&gt;   &#x2F;&#x2F;假设想搜索的东西叫：something</span><br></pre></td></tr></table></figure><h4 id="4、直接搜索"><a href="#4、直接搜索" class="headerlink" title="4、直接搜索"></a>4、直接搜索</h4><p>直接在搜索栏中搜索：加入想搜索与<code>CJSON</code>有关的内容：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200219151224327.png" alt="image-20200219151224327"></p><h3 id="2）、添加约束条件"><a href="#2）、添加约束条件" class="headerlink" title="2）、添加约束条件"></a>2）、添加约束条件</h3><h4 id="star数量"><a href="#star数量" class="headerlink" title="star数量"></a><strong><code>star</code>数量</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stars: &gt; 500     &#x2F;&#x2F; star 数量大于500的项目</span><br><span class="line">stars: 10..20    &#x2F;&#x2F; star 数量在10-20之间的仓库</span><br></pre></td></tr></table></figure><h4 id="fork数量"><a href="#fork数量" class="headerlink" title="fork数量"></a><code>fork</code>数量</h4><p>同理，我们也可以按照fork的数量来进行搜索:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in:name React  forks:&gt;3000</span><br></pre></td></tr></table></figure><hr><h4 id="language编程语言"><a href="#language编程语言" class="headerlink" title="language编程语言"></a><code>language</code>编程语言</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">language:python   &#x2F;&#x2F;比如，把语言限制为Python</span><br></pre></td></tr></table></figure><h4 id="仓库push的时间"><a href="#仓库push的时间" class="headerlink" title="仓库push的时间"></a>仓库<code>push</code>的时间</h4><p>假如在这些项目里面，我们想要找到最近才更新的项目，意思是更新时间就在最近，我们可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pushed:&gt;2020-01-01  &#x2F;&#x2F;项目的最近一次更新时间限制到2020-01-01之后</span><br></pre></td></tr></table></figure><hr><h4 id="仓库持有者"><a href="#仓库持有者" class="headerlink" title="仓库持有者"></a>仓库持有者</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user：&lt;username&gt;</span><br></pre></td></tr></table></figure><h4 id="仓库大小"><a href="#仓库大小" class="headerlink" title="仓库大小"></a>仓库大小</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size:&gt;&#x3D;5000 &#x2F;&#x2F; 仓库大于5000KB的仓库</span><br></pre></td></tr></table></figure><h4 id="仓库create时间"><a href="#仓库create时间" class="headerlink" title="仓库create时间"></a>仓库<code>create</code>时间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">created:&gt;2019-01-01     &#x2F;&#x2F; 2019年以后创建的仓库</span><br></pre></td></tr></table></figure><h4 id="license协议"><a href="#license协议" class="headerlink" title="license协议"></a><code>license</code>协议</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">license:apache-2.0  &#x2F;&#x2F; 使用 apache-2.0 协议的仓库</span><br></pre></td></tr></table></figure><h4 id="组织机构代码"><a href="#组织机构代码" class="headerlink" title="组织机构代码"></a>组织机构代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org:spring-cloud  &#x2F;&#x2F; 列出org 的 spring-cloud  仓库</span><br></pre></td></tr></table></figure><h3 id="3）、组合搜索"><a href="#3）、组合搜索" class="headerlink" title="3）、组合搜索"></a>3）、组合搜索</h3><p>将1）和2）中可以随机组合进行精确搜索,比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in:description &lt;something&gt; language:python  &#x2F;&#x2F;将编程语言限制为python</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in:readme &lt;something&gt; stars:&gt;3000 forks:&gt;3000</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in:description 微服务 language:python pushed:&gt;2020-01-01</span><br><span class="line">&#x2F;*pushed:&gt;2020-01-01的意思是我们把项目的最后更新时间限制到2020-01-01*&#x2F;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in:name React  forks:&gt;3000</span><br></pre></td></tr></table></figure><p>等等</p><h2 id="奇特搜索："><a href="#奇特搜索：" class="headerlink" title="奇特搜索："></a>奇特搜索：</h2><h3 id="awesome搜索"><a href="#awesome搜索" class="headerlink" title="awesome搜索"></a><code>awesome</code>搜索</h3><p><strong>1、awesome-awesome搜索</strong></p><p>直接使用<code>awesome-awesome</code>可以搜索出很多优质项目。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awesome-awesome</span><br></pre></td></tr></table></figure><p><strong>2、<code>awesome name</code>搜索</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awesome &lt;name&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;p center large&gt;&lt;red&gt;&lt;/red&gt;Git学习笔记&lt;/p&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Git" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git/"/>
    
    
      <category term="Git" scheme="https://longlongqin.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>LearnCpp chapterO</title>
    <link href="https://longlongqin.github.io/archives/67343d3.html"/>
    <id>https://longlongqin.github.io/archives/67343d3.html</id>
    <published>2020-04-04T02:21:31.000Z</published>
    <updated>2020-04-19T14:38:29.546Z</updated>
    
    <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapterO</red></p></center><center><red>https://www.learncpp.com</red></center><p>未完待续~~</p><a id="more"></a><h2 id="O-1-Bit-flags-and-bit-manipulation-via-std-bitset"><a href="#O-1-Bit-flags-and-bit-manipulation-via-std-bitset" class="headerlink" title="O.1 Bit flags and bit manipulation via std::bitset"></a>O.1 Bit flags and bit manipulation via std::bitset</h2><p>在现代计算机体系结构中，最小的可寻址内存单元是<strong>字节</strong>。由于所有对象都需要有唯一的内存地址，这意味着对象的大小必须至少为一个字节。对于大多数变量类型，这是可以的。<strong>然而，对于布尔值，这有点浪费</strong>。布尔类型只有两种状态:真(1)，或假(0)。这一组状态只需要存储一位。然而，如果一个变量必须至少是一个字节，而一个字节是8位，这意味着一个布尔值使用1位，而其他7位不使用。</p><hr><ul><li><p><strong>位操作：bit manipulation</strong></p><p>在对象内部，修改单个bit的过程，叫位操作。</p><blockquote><p>位操作在加密和压缩算法中也很有用。</p></blockquote></li><li><p>但是，我们可以将对象视为单个位的集合，而不是将其视为持有单个值的对象。当对象的个别位用作布尔值时，这些位称为<strong>位标志：bit flag</strong>。</p><blockquote><p>在计算中，标志是作为某个函数或进程的信号的值。类似地，在现实生活中，邮箱标志用于指示邮箱中有内容，因此不必打开邮箱进行检查。</p></blockquote><p>为了定义一组位标志，我们通常使用适当大小的无符号整数(8位、16位、32位等等，这取决于我们有多少个标志)，或者std::bitset。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt; //for std::bitset</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;8&gt; mybitset &#123;&#125;; <span class="comment">//8 bits in size means room for 8 flags</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>位操作</strong>是少数几种<strong>应该明确使用无符号整数(或std::bitset)的操作</strong>之一。</p></blockquote></li></ul><hr><ul><li><p><strong>位编号和位的位置：Bit numbering and bit positions</strong></p><p>给定一个bits 序列，通常从右到左开始进行编号(编号的开头是0，不是1)。每一个数字表示一个<strong><em>bit positon</em>：位的位置</strong>。eg：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">76543210  Bit position</span><br><span class="line">00000101  Bit sequence</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>通过<code>std::bitset</code>操作位</strong></p><p>在 <a href="https://www.learncpp.com/cpp-tutorial/literals/" target="_blank" rel="noopener">4.12 – Literals</a>，我们介绍了如何使用<code>std::bitset</code>来输出二进制形式的结果。现在我们来介绍<code>std::bitset</code>的其他功能：</p><p><code>std::bitset</code>提供了4个关键的功能，对做位操作很有用:</p><ul><li><p><code>text()</code>：允许我们查询一个位是0还是1；</p></li><li><p><code>set()</code>：允许我们将一个 位(bit)设置成 on，即将其设置为1；</p></li><li><p><code>reset()</code>：允许我们将一个 位(bit)设置成 off，即将其设置为 0；</p></li><li><p><code>flip()</code>：允许我们将一个 位(bit) 由0设置为1，或者由1设置为0；</p><blockquote><p>这些函数中的每一个都带有一个位位置参数，该参数指示我们将要操作的位 的位置。</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;8&gt; bits&#123;<span class="number">0b0000'0101</span>&#125;; <span class="comment">//we need 8 bits, start with bit pattern 0000 0101</span></span><br><span class="line">    <span class="built_in">bit</span>.<span class="built_in">set</span>(<span class="number">3</span>); <span class="comment">//set bit position 3 to 1 (now we have 0000 1101)</span></span><br><span class="line">    <span class="built_in">bit</span>.flip(<span class="number">4</span>); <span class="comment">//flip bit 4(now we have 0001 1101)</span></span><br><span class="line">    <span class="built_in">bit</span>.reset(<span class="number">4</span>); <span class="comment">//set bit 4 back to 0 (now we have 0000 1101)</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"All the bits: "</span>&lt;&lt;bits&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"bit 3 has valude: "</span> &lt;&lt;<span class="built_in">bit</span>.test(<span class="number">3</span>) &lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>:;<span class="built_in">cout</span> &lt;&lt;<span class="string">"bit 4 has valud: "</span>&lt;&lt;<span class="built_in">bit</span>.test(<span class="number">4</span>) &lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********输出结果********/</span></span><br><span class="line">All the bits: <span class="number">00001101</span></span><br><span class="line"><span class="built_in">bit</span> <span class="number">3</span> has valude: <span class="number">1</span></span><br><span class="line"><span class="built_in">bit</span> <span class="number">4</span> has valude: <span class="number">0</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="O-2-位操作符"><a href="#O-2-位操作符" class="headerlink" title="O.2 位操作符"></a>O.2 位操作符</h2><p>C++提供了<strong>“位操作符(bitwise operator)”</strong>：</p><table><thead><tr><th align="left">Operator</th><th align="left">Symbol</th><th align="left">Form</th><th align="left">Operation</th></tr></thead><tbody><tr><td align="left">left shift</td><td align="left">&lt;&lt;</td><td align="left">x &lt;&lt; y</td><td align="left">all bits in x shifted left y bits</td></tr><tr><td align="left">right shift</td><td align="left">&gt;&gt;</td><td align="left">x &gt;&gt; y</td><td align="left">all bits in x shifted right y bits</td></tr><tr><td align="left">bitwise NOT</td><td align="left">~</td><td align="left">~x</td><td align="left">all bits in x flipped</td></tr><tr><td align="left">bitwise AND</td><td align="left">&amp;</td><td align="left">x &amp; y</td><td align="left">each bit in x AND each bit in y</td></tr><tr><td align="left">bitwise OR</td><td align="left">|</td><td align="left">x | y</td><td align="left">each bit in x OR each bit in y</td></tr><tr><td align="left">bitwise XOR</td><td align="left">^</td><td align="left">x ^ y</td><td align="left">each bit in x XOR each bit in y</td></tr></tbody></table><blockquote><p>在下面的例子中，我们将主要使用4位二进制值。这是为了方便和保持例子简单。在实际的程序中，使用的位的数量是基于对象的大小(例如，一个2字节的对象将存储16位)。</p><p>为了可读性，我们还将在代码示例之外省略0b前缀(例如，我们将使用0101而不是0b0101)。</p></blockquote><hr><ul><li><p><strong>位操作符：<code>&lt;&lt;</code>左移、<code>&gt;&gt;</code>右移</strong></p><p>按位左移(&lt;&lt;)操作符将位移到左边。左操作数是要移位的位的表达式，而右操作数是要左移的位的整数。</p><blockquote><p>如：<code>x&lt;&lt;1</code>表示，将变量x左移一个位置。从右边移进来的新位接受一个 值0。</p><p>eg，</p><p><code>0011&lt;&lt;1</code> 是 0110</p><p><code>0011&lt;&lt;2</code> 是 1100</p><p><code>0011&lt;&lt;3</code> 是 1000</p></blockquote><p>同理，按位右移(&gt;&gt;)操作符原理也一样：</p><blockquote><p><code>1100&gt;&gt;1</code> 是 0110</p><p><code>1100&gt;&gt;2</code> 是 0011</p><p><code>1100&gt;&gt;3</code> 是 0001</p></blockquote><hr><p>下面是一个示例程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;4&gt; x&#123;<span class="number">0b1100</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;x&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (x&gt;&gt;<span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//右移一个位置，结果是0110</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (x&lt;&lt;<span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//左移一个位置，结果是1000</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******结果******/</span></span><br><span class="line"><span class="number">1100</span></span><br><span class="line"><span class="number">0110</span></span><br><span class="line"><span class="number">1000</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>位操作：NOT <code>~</code></strong></p><p>这个操作符功能就是将每个位的数由0变为1，或由1变为0：</p><blockquote><p>如：<code>~0100</code> 是 1011；<code>~0000 0100</code> 是 1111 1011</p></blockquote><p>上面例子中，虽然：0100 和000 0100是一样的，就像十进制的7和07一样；但是经过<code>~</code>操作符之后，它们位数不一样，就会产生不一样的结果。</p></li></ul><hr><ul><li><p><strong>位操作：OR <code>|</code></strong></p><p>它的形式是对两个表达式进行每个位上的或运算，如：<code>0b0101 | 0b0110</code>。更加直观的形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 1 0 1 OR</span><br><span class="line">0 1 1 0</span><br><span class="line">---------   &#x2F;&#x2F;结果为</span><br><span class="line">0 1 1 1</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (<span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;&#123;<span class="number">0b0101</span>&#125; | <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;&#123;<span class="number">0b0110</span>&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********结果********/</span></span><br><span class="line"><span class="number">0111</span></span><br></pre></td></tr></table></figure><blockquote><p>也可进行多个表达式的运算，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0 1 1 1 OR</span><br><span class="line">0 0 1 1 OR</span><br><span class="line">0 0 0 1</span><br><span class="line">--------</span><br><span class="line">0 1 1 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;只要对应的列有1，它的结果中对应的那一列就是1</span><br></pre></td></tr></table></figure><p>它写成程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (<span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;&#123; <span class="number">0b0111</span> &#125; | <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;&#123; <span class="number">0b0011</span> &#125; | <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;&#123; <span class="number">0b0001</span> &#125;);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********结果*********/</span></span><br><span class="line"><span class="number">0111</span></span><br></pre></td></tr></table></figure></blockquote></li></ul><hr><ul><li><p><strong>位操作：AND <code>&amp;</code></strong></p><p>它的形式为：<code>0b0101 &amp; 0b0110</code>,更加直观的形式（也可以有多个表达式一起运算）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 1 0 1 AND</span><br><span class="line">0 1 1 0</span><br><span class="line">--------</span><br><span class="line">0 1 0 0</span><br></pre></td></tr></table></figure><blockquote><p>每一列中只有全部为1时，结果中对应的列才是1.</p></blockquote><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (<span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;&#123; <span class="number">0b0001</span> &#125; &amp; <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;&#123; <span class="number">0b0011</span> &#125; &amp; <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;&#123; <span class="number">0b0111</span> &#125;);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直观的表示为：</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> AND</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> AND</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">--------  <span class="comment">//结果为</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>位操作：XOR <code>^</code></strong></p><p>它的形式为：<code>0b0001 ^ 0b0011 ^ 0b0111</code></p><p>更加直观的看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 1 XOR</span><br><span class="line">0 0 1 1 XOR</span><br><span class="line">0 1 1 1</span><br><span class="line">--------</span><br><span class="line">0 1 0 1</span><br></pre></td></tr></table></figure><blockquote><p>每一列如果有<strong>奇数个1</strong>，则结果中对应的列就是1；否则就是0.</p></blockquote></li></ul><hr><ul><li><p><strong>位的赋值操作符</strong></p><p>与算术赋值运算符相似，C++提供位的赋值操作符，为了方便修改变量：</p><table><thead><tr><th align="left">Operator</th><th align="left">Symbol</th><th align="left">Form</th><th align="left">Operation</th></tr></thead><tbody><tr><td align="left">Left shift assignment</td><td align="left">&lt;&lt;=</td><td align="left">x &lt;&lt;= y</td><td align="left">Shift x left by y bits</td></tr><tr><td align="left">Right shift assignment</td><td align="left">&gt;&gt;=</td><td align="left">x &gt;&gt;= y</td><td align="left">Shift x right by y bits</td></tr><tr><td align="left">Bitwise OR assignment</td><td align="left">|=</td><td align="left">x |= y</td><td align="left">Assign x | y to x</td></tr><tr><td align="left">Bitwise AND assignment</td><td align="left">&amp;=</td><td align="left">x &amp;= y</td><td align="left">Assign x &amp; y to x</td></tr><tr><td align="left">Bitwise XOR assignment</td><td align="left">^=</td><td align="left">x ^= y</td><td align="left">Assign x ^ y to x</td></tr></tbody></table><p>比如，<code>x= x&gt;&gt;1</code>，可以写成：<code>x&gt;&gt;=1</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;4&gt; bits&#123;<span class="number">0b0100</span>&#125;;</span><br><span class="line">    bits &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; bits;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果*********/</span></span><br><span class="line"><span class="number">0010</span></span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>总结：</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;p center large&gt;&lt;red&gt;LearnCpp chapterO&lt;/red&gt;&lt;/p&gt;&lt;/center&gt;&lt;center&gt;&lt;red&gt;https://www.learncpp.com&lt;/red&gt;&lt;/center&gt;&lt;p&gt;未完待续~~&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C/C++" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"/>
    
    
      <category term="C/C++" scheme="https://longlongqin.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>LearnCpp chapter5</title>
    <link href="https://longlongqin.github.io/archives/b6a3dbf1.html"/>
    <id>https://longlongqin.github.io/archives/b6a3dbf1.html</id>
    <published>2020-04-03T02:21:47.000Z</published>
    <updated>2020-04-19T14:38:29.545Z</updated>
    
    <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapter5</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h2 id="5-1-操作符优先级-amp-结合律"><a href="#5-1-操作符优先级-amp-结合律" class="headerlink" title="5.1 操作符优先级 &amp; 结合律"></a>5.1 操作符优先级 &amp; 结合律</h2><center>Operator precedence and associativity</center><p>下面是<strong>操作符的优先级 及 结合律</strong></p><blockquote><p>【note】</p><ol><li>下面表格的操作符优先级：<strong>level 1是最高优先级；level 17 优先级最低</strong></li><li>结合律：<ul><li><strong>L-&gt;R</strong>：即，从左向右结合</li><li><strong>R-&gt;L</strong> ：即。从右向左结合</li></ul></li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter5/image-20200403103620634.png" alt="1~8 level"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter5/image-20200403103654067.png" alt="9~17 level"></p><hr><p>注意一个<strong>连等号到表达式</strong>：</p><p><strong><code>x=y=z;</code>由上表可知，该表达式其实是这样的：<code>x=(y=z);</code></strong></p><hr><h2 id="5-2-算数运算符"><a href="#5-2-算数运算符" class="headerlink" title="5.2 算数运算符"></a>5.2 算数运算符</h2><center>Arithmetic operators</center><ul><li><p><strong>一元操作符(<em>Unary arithmetic operators</em></strong>)：<strong><code>+</code>、<code>-</code>：</strong></p><blockquote><p><strong>unary minus</strong>：返回 操作数乘以-1 之后的值。</p><p><strong>unary plus</strong>：返回 操作数本身。</p><p>这两个操作符都应该放在操作数的前面(e.g. -x , 而不是 - x)</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter5/image-20200403130245848.png" alt="一元操作符 + -"></p><p>eg: <code>x=5 - -3;</code>.第一个减号表示二元操作符，减法；第二个减号表示一元操作符。</p></li></ul><hr><ul><li><p><strong>二元运算符：<em>Binary arithmetic operators</em></strong></p><p>二元操作符有左、右 两个<strong>操作数(operand)</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter5/image-20200403130913816.png" alt="二元操作符"></p></li></ul><hr><ul><li><p><strong>整数与浮点数 的除法</strong></p><ol><li><p>左右两个操作数<strong>至少有一个是 浮点型值</strong>，它们的运算结果依然是一个浮点型的值。</p><blockquote><p>For example, <code>7.0 / 4 = 1.75</code>, <code>7 / 4.0 = 1.75</code>、<code>7.0 / 4.0 = 1.75</code></p></blockquote></li><li><p>做有<strong>两个操作数均为 整型值</strong>，它的运算结果依然是 整型值。</p><blockquote><p>For example, <code>7 / 4 = 1</code></p></blockquote></li></ol></li></ul><hr><ul><li><p><strong>用<code>static_cast&lt;&gt;</code>对整数进行浮点除法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123;<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> y&#123;<span class="number">4</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"int/int="</span>&lt;&lt;x/y&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"double / int = "</span>&lt;&lt;<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(x)/y&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"int / double = "</span>&lt;&lt;x/ <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(y)&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"double / double = "</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(x) / <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(y)&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****结果*****/</span></span><br><span class="line"><span class="keyword">int</span> / <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">double</span> / <span class="keyword">int</span> = <span class="number">1.75</span></span><br><span class="line"><span class="keyword">int</span> / <span class="keyword">double</span> = <span class="number">1.75</span></span><br><span class="line"><span class="keyword">double</span> / <span class="keyword">double</span> = <span class="number">1.75</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>除以<code>0</code></strong></p><p>如果除以0(或者 0.0)将会使程序崩溃。因为这个结果在数学中是没有定义的。</p></li></ul><hr><ul><li><p><strong>赋值操作符</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter5/image-20200403133616428.png" alt="赋值操作符"></p></li></ul><hr><h2 id="5-3-取模-amp-幂运算"><a href="#5-3-取模-amp-幂运算" class="headerlink" title="5.3 取模 &amp; 幂运算"></a>5.3 取模 &amp; 幂运算</h2><ul><li><p><strong>取模操作符：The modulus operator</strong></p><p><strong><em>取模操作符*，又称 *取余操作符</em></strong>。</p><blockquote><p>【note】：<u><strong>取余运算结果的符号，只和第一个操作数相一致。</strong></u></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123; <span class="number">6</span> &#125;, y&#123; <span class="number">-4</span> &#125;; <span class="comment">//第一个操作数符号为 正</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x%y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> z&#123; <span class="number">-6</span> &#125;, w&#123; <span class="number">4</span> &#125;; <span class="comment">//第一个操作数符号为 负</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; z%w ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="built_in">std</span>::numeric_limits &lt;<span class="built_in">std</span>::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span> );</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter5/image-20200403134914381.png" alt="取余结果的符号与“被除数”的符号相同"></p></blockquote></li></ul><hr><ul><li><p><strong>幂运算符<code>^</code></strong></p><p>您将注意到<code>^</code>运算符(在数学中通常用于表示求幂)是c++中的位<strong>XOR操作</strong>。在C++中不包含“幂运算操作符”。如果要用，就需要加上<strong>头文件<code>cmath</code></strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">double</span> x&#123; <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">3.0</span>, <span class="number">4.0</span>)&#125;; <span class="comment">//3 to the 4th power(3的4次方)</span></span><br></pre></td></tr></table></figure><blockquote><p>【Note】注意，<strong>pow()函数的参数(和返回值)是double类型的</strong>。所以，就算传入的是整数类型的，它的计算还是会有误差的(因为浮点数计算本身就会有误差)</p></blockquote><hr><p>所以，如果你想对整数进行幂运算，可以自己设计函数，使其结果比较精确：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt; //for std::int_fast64_t</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//note: exp(幂数) 不能是负数[因为用的是while循环]</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="keyword">int_fast64_t</span> <span class="title">powint</span> <span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> <span class="built_in">exp</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">int_fast64_t</span> result &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">exp</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">exp</span> &amp; <span class="number">1</span>)</span><br><span class="line">            result *= base;</span><br><span class="line">        <span class="built_in">exp</span> &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        base *= base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;powint(<span class="number">7</span>,<span class="number">12</span>); <span class="comment">//7的12次幂</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="5-4-递增-递减操作符"><a href="#5-4-递增-递减操作符" class="headerlink" title="5.4 递增/递减操作符"></a>5.4 递增/递减操作符</h2><table><thead><tr><th align="left">Operator</th><th align="left">Symbol</th><th align="left">Form</th><th align="left">Operation</th></tr></thead><tbody><tr><td align="left">Prefix increment (pre-increment)</td><td align="left">++</td><td align="left">++x</td><td align="left">Increment x, then return x</td></tr><tr><td align="left">Prefix decrement (pre-decrement)</td><td align="left">––</td><td align="left">––x</td><td align="left">Decrement x, then return x</td></tr><tr><td align="left">Postfix increment (post-increment)</td><td align="left">++</td><td align="left">x++</td><td align="left">Copy x, then increment x, then return the copy</td></tr><tr><td align="left">Postfix decrement (post-decrement)</td><td align="left">––</td><td align="left">x––</td><td align="left">Copy x, then decrement x, then return the copy</td></tr></tbody></table><hr><ul><li><p><strong>副作用：side effects</strong></p><center>c++不定义函数参数或操作符操作数的求值顺序。</center><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> x+y;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123;<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> valude = add(x, ++x); <span class="comment">//结果是5+6,还是6+6?</span></span><br><span class="line">    <span class="comment">//这取决于编译器计算函数参数的顺序</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;value; <span class="comment">// value could be 11 or 12, depending on how the above line evaluates!</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>【副作用】：<strong>c++没有定义函数参数求值的顺序。</strong></p><p>这种就会产生不确定性，因为还要<strong>取决于编译器对函数的参数计算的顺序</strong>。所以，不同的编译器可能会产生不同的结果。</p><p>所以，结果可能为：11 或者 12</p></blockquote></li></ul><hr><h2 id="5-5-逗号“-”-amp-条件-运算符"><a href="#5-5-逗号“-”-amp-条件-运算符" class="headerlink" title="5.5 逗号“,” &amp; 条件 运算符"></a>5.5 逗号“<code>,</code>” &amp; 条件 运算符</h2><h3 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h3><center>逗号操作符适用于for循环，其他情况不推荐用</center><table><thead><tr><th align="left">Operator</th><th align="left">Symbol</th><th align="left">Form</th><th align="left">Operation</th></tr></thead><tbody><tr><td align="left">Comma</td><td align="left">,</td><td align="left">x, y</td><td align="left">Evaluate x then y, returns value of y</td></tr></tbody></table><p><strong>comma operator (,)</strong>：允许您在允许单个表达式的情况下计算多个表达式的值。<strong>逗号运算符对左操作数求值，然后对右操作数求值，<u>然后返回右操作数的结果</u></strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> y&#123;<span class="number">2</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; (++x, ++y); <span class="comment">//先计算左操作符，在计算右操作符，但是返回右操作符的结果</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******结果**********/</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><hr><ul><li><p><strong>逗号操作符是所有操作符中最低的</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">z = (a,b); <span class="comment">//计算(a,b)，然后将返回的结果赋值给z</span></span><br><span class="line">z = a , b; <span class="comment">//由于“=”操作符优先于“,”操作符，所以，先计算“z=a”;然后在计算b，计算完之后，b没用就被抛弃了</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>逗号用作分隔符时，它此时代表的不是操作符</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// Comma used to separate parameters in function definition</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    add(x, y); <span class="comment">// Comma used to separate arguments in function call</span></span><br><span class="line">    int z(3), w(5); // Comma used to separate multiple variables being defined on the same line (don't do this)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h3><p>条件操作符是一个 <strong>三元操作符</strong></p><table><thead><tr><th align="left">Operator</th><th align="left">Symbol</th><th align="left">Form</th><th align="left">Operation</th></tr></thead><tbody><tr><td align="left">Conditional</td><td align="left">? :</td><td align="left">c ? x : y</td><td align="left">If c is nonzero (true) then evaluate x, otherwise evaluate y</td></tr></tbody></table><p>形式：<code>(condition) ? expression1 : expression2;</code></p><blockquote><p>当<code>condition</code>的结果是正确的(或者非零数字)，就执行<code>expression1</code>，否则，执行<code>expression2</code></p></blockquote><hr><ul><li><p><strong>由于条件操作符优先级较低，有时需要括号</strong></p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (x&gt;y) ? x : y;</span><br><span class="line"><span class="comment">//由于“&lt;&lt;”的优先级高于“条件操作符”,所以，等同于以下形式：</span></span><br><span class="line">(<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (x&gt;y)) ? x : y;</span><br><span class="line"><span class="comment">//想要按照我们设计的正确执行，则需要适当加上括号</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;((x&gt;y) ? x : y);</span><br></pre></td></tr></table></figure></li></ul><hr><p>【注意】与在函数内部定义的变量在函数结束时死亡非常相似，在if或else语句中定义的变量在if或else语句结束时死亡。因此，在我们试图打印它时，类大小已经被破坏了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> inBigClassroom &#123; <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (inBigClassroom)</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> classSize &#123; <span class="number">30</span> &#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> classSize &#123; <span class="number">20</span> &#125;;</span><br><span class="line">    <span class="comment">//此时，if/else已经执行结束，所以，其内部定义的变量classSize也已经被销毁</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The class size is: "</span> &lt;&lt; classSize; <span class="comment">//因为classSize被销毁，所以会编译出错</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li><p><strong>条件编译的两个表达式的类型</strong></p><p>条件编译的两个表达式，<strong>要么具有相同的类型</strong>；<strong>要么第二个表达式的类型可以转化为第一个表达式的类型</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (x != <span class="number">5</span> ? x : <span class="string">"x is 5"</span>); <span class="comment">// won't compile</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为，表达式1：x 是integer 类型；表达式2："x is 5"是string类型。所以表达式2要转换为表达式1的类型，但是转换失败。所以编译就不成功</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="5-6-关系运算符-amp-浮点数的比较"><a href="#5-6-关系运算符-amp-浮点数的比较" class="headerlink" title="5.6 关系运算符 &amp; 浮点数的比较"></a>5.6 关系运算符 &amp; 浮点数的比较</h2><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><table><thead><tr><th align="left">Operator</th><th align="left">Symbol</th><th align="left">Form</th><th align="left">Operation</th></tr></thead><tbody><tr><td align="left">Greater than</td><td align="left">&gt;</td><td align="left">x &gt; y</td><td align="left">true if x is greater than y, false otherwise</td></tr><tr><td align="left">Less than</td><td align="left">&lt;</td><td align="left">x &lt; y</td><td align="left">true if x is less than y, false otherwise</td></tr><tr><td align="left">Greater than or equals</td><td align="left">&gt;=</td><td align="left">x &gt;= y</td><td align="left">true if x is greater than or equal to y, false otherwise</td></tr><tr><td align="left">Less than or equals</td><td align="left">&lt;=</td><td align="left">x &lt;= y</td><td align="left">true if x is less than or equal to y, false otherwise</td></tr><tr><td align="left">Equality</td><td align="left">==</td><td align="left">x == y</td><td align="left">true if x equals y, false otherwise</td></tr><tr><td align="left">Inequality</td><td align="left">!=</td><td align="left">x != y</td><td align="left">true if x does not equal y, false otherwise</td></tr></tbody></table><blockquote><p>这些操作符的值分别为布尔值true(1)和false(0)。</p></blockquote><hr><h3 id="浮点数的比较"><a href="#浮点数的比较" class="headerlink" title="浮点数的比较"></a>浮点数的比较</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d1&#123; <span class="number">100.0</span> - <span class="number">99.99</span> &#125;; <span class="comment">// should equal 0.01 ?</span></span><br><span class="line">    <span class="keyword">double</span> d2&#123; <span class="number">10.0</span> - <span class="number">9.99</span> &#125;; <span class="comment">// should equal 0.01 ?</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (d1 == d2)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"d1 == d2"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (d1 &gt; d2)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"d1 &gt; d2"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (d1 &lt; d2)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"d1 &lt; d2"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****结果*****/</span></span><br><span class="line">d1 &gt; d2</span><br></pre></td></tr></table></figure><p>我们可以看到，在我们的调试模式下，d1 = 0.0100000000000005116 而 d2 = 0.0099999999999997868.</p><blockquote><p>【Note】：在两个浮点数非常接近时，如果使用<code>==</code>和<code>!=</code>对浮点数之间比较，结果会不太准确。</p></blockquote><hr><ul><li><p><strong>使用<code>epsilon</code>准确比较浮点数</strong></p><p>我们可以使用<code>epsilon</code>来相对准确的比较两个 足够接近的 浮点型数值。</p><blockquote><p><code>epsilon</code>：通常被定义为一个小的正数(如，0.00000001，即1e-8)</p></blockquote><p>现在，我们来比较两个”close enough”的浮点数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; //for std::abs()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//epsilon is an absolute value</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isAlmostEqual</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> epsilon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//if the distance between a and b is less than epsilon, then a and b are "close enough"</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">abs</span>(a-b) &lt;= epsilon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这个函数可以工作，但它不是很好。0.00001的epsilon值对于1.0左右的输入是合适的，对于0.0000001左右的输入是太大了，对于10,000这样的输入是太小了。这意味着每次我们调用这个函数时，我们必须选择一个适合我们输入的。如果我们知道我们要根据输入的比例来缩放，我们也可以修改函数来做到这一点。</p><p><strong>改进1：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; //std::abs</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; //std::max</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//return true if the difference between a and b is within epsilon</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">approximatelyEqual</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b, <span class="keyword">double</span> epsilon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(a-b) &lt;= ( <span class="built_in">std</span>::<span class="built_in">max</span>( <span class="built_in">std</span>::<span class="built_in">abs</span>(a),<span class="built_in">std</span>::<span class="built_in">abs</span>(b) ) * epsilon ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这种情况下，<code>epsilon</code>不再是一个绝对值，<strong>现在是相对于a或b大小的量级</strong>。</p></blockquote><p><strong>再改进2【推荐】</strong>：</p><p><strong>当浮点数足够接近于0时</strong>，上面的方法还是不太行的。</p><blockquote><p>改进方法就是：<strong>同时使用相对值和绝对值</strong>：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return true if the difference between a and b is less than absEpsilon, or within relEpsilon percent of the larger of a and b</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">approximatelyEqualAbsRel</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> absEpsilon, <span class="keyword">double</span> relEpsilon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Check if the numbers are really close -- needed when comparing numbers near zero.</span></span><br><span class="line">    <span class="keyword">double</span> diff&#123; <span class="built_in">std</span>::<span class="built_in">abs</span>(a - b) &#125;;</span><br><span class="line">    <span class="keyword">if</span> (diff &lt;= absEpsilon)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Otherwise fall back to Knuth's algorithm(相对值方法，即“改进1”的方法)</span></span><br><span class="line">    <span class="keyword">return</span> (diff &lt;= (<span class="built_in">std</span>::<span class="built_in">max</span>(<span class="built_in">std</span>::<span class="built_in">abs</span>(a), <span class="built_in">std</span>::<span class="built_in">abs</span>(b)) * relEpsilon));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这个算法中，我们首先检查a和b在绝对值上是否接近，这处理了a和b都接近于零的情况。<strong>absEpsilon参数应该设置为非常小的值(例如1e-12)</strong>。如果失败了，我们就回到Knuth的算法，即，使用相对的epsilon。</p></blockquote></li></ul><p>完整的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; //std::max</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;     //std::abs</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果a和b之间的差值在a和b之间较大值的百分之几内，则返回true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">approximatelyEqual</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b,<span class="keyword">double</span> epsilon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(a-b) &lt;= (<span class="built_in">std</span>::<span class="built_in">max</span>(<span class="built_in">std</span>::<span class="built_in">abs</span>(a), <span class="built_in">std</span>::<span class="built_in">abs</span>(b)) * epsilon ));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//针对于接近于0 的浮点数的比较</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">approximatelyEqualAbsRel</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b,<span class="keyword">double</span> absEpsilon, <span class="keyword">double</span> relEspilon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//check if the numbers are really close -- need when comparing numbers near zero.</span></span><br><span class="line">    <span class="keyword">double</span> diff &#123;<span class="built_in">std</span>::<span class="built_in">abs</span>(a-b)&#125;;</span><br><span class="line">    <span class="keyword">if</span> (diff &lt;= absEpsilon)</span><br><span class="line">        <span class="keyword">return</span> ture;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//otherwise fall back to 相对值法</span></span><br><span class="line">    <span class="keyword">return</span> (diff &lt;= (<span class="built_in">std</span>::<span class="built_in">max</span>(<span class="built_in">std</span>::<span class="built_in">abs</span>(a), <span class="built_in">std</span>::<span class="built_in">abs</span>(b)) * relEspilon));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//a is really close to 1.0, but has rounding errors</span></span><br><span class="line">    <span class="keyword">double</span> a&#123;<span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; approximatelyEqual(a, <span class="number">1.0</span>, <span class="number">1e-8</span>);<span class="comment">//compare "almost 1.0" to 1.0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; approximatelyEqual(a<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">1e-8</span>); <span class="comment">//compare "almost 0.0" to 0.0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; approximatelyEqualAbsRel(a<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">1e-12</span>, <span class="number">1e-8</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// compare "almost 0.0" to 0.0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********结果*********/</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>可以看出，<strong>在对于接近于0的浮点数，与 0.0比较时。<code>approximatelyEqualAbsRel</code>要更加准确。</strong></p></blockquote><p><strong>使用<code>approximatelyEqualAbsRel</code>方法，就可以解决大多数情况</strong>。它也涵盖了<code>approximatelyEqual</code>函数的功能。</p><hr><h2 id="5-7-逻辑操作符"><a href="#5-7-逻辑操作符" class="headerlink" title="5.7 逻辑操作符"></a>5.7 逻辑操作符</h2><table><thead><tr><th align="left">Operator</th><th align="left">Symbol</th><th align="left">Form</th><th align="left">Operation</th></tr></thead><tbody><tr><td align="left">Logical NOT</td><td align="left">!</td><td align="left">!x</td><td align="left">true if x is false, or false if x is true</td></tr><tr><td align="left">Logical AND</td><td align="left">&amp;&amp;</td><td align="left">x &amp;&amp; y</td><td align="left">true if both x and y are true, false otherwise</td></tr><tr><td align="left">Logical OR</td><td align="left">||</td><td align="left">x || y</td><td align="left">true if either x or y are true, false otherwise</td></tr></tbody></table><hr><ul><li><p><strong>NOT：！</strong></p><p>需要注意的是，<strong>NOT 操作符的优先级很高，在level 3</strong>。所以，你很有可能会犯这种错误：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123;<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> y&#123;<span class="number">7</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!x&gt;y) <span class="comment">//正确写法：if (!(x&gt;y))</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x is not greater than y\n"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x is equal to or greater than y\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果************/</span></span><br><span class="line">x is equal to <span class="keyword">or</span> greater than y</span><br></pre></td></tr></table></figure><p>可以看出，结果不正确。在这里就是因为，<code>if(!x&gt;y)</code>中，由于<code>!</code>优先级高于<code>&gt;</code>。所以，先计算“!x”，其实，就相当于：<code>if ( (!x) &gt; y )</code></p></li></ul><hr><ul><li><p><strong>AND： &amp;&amp;</strong></p><ul><li><p>如果逻辑操作符<code>&amp;&amp;</code>要返回“true”，那么所有的操作数都必须是‘true’；</p></li><li><p>但如果<code>&amp;&amp;</code>返回是“false”，只要有一个操作数是‘false’即可。</p><blockquote><p>特殊的，如果第一个操作数是‘false’的话，就不会再继续看后面操作符是‘false’还是‘true’，即图签终止了。这种情况叫做：“<strong>short circuit evaluation</strong>”</p></blockquote></li></ul><p>相似的，逻辑操作符 或<code>||</code>，如果要返回“true”的话，也是只要有一个操作数是‘true’即可。</p></li></ul><hr><blockquote><p><strong>逻辑操作符<code>&amp;&amp;</code>的优先级高于<code>||</code></strong>，所以，在使用如：<code>value1 || value2 &amp;&amp; value3</code>时，要更加小心，<strong>使用括号才会更加安全</strong>。</p></blockquote><hr><ul><li><p><strong>德摩根定律：De Morgan’s law</strong></p><p>德摩根定律告诉我们，可以这样使用逻辑操作符<code>!</code>：</p><p><code>!(x &amp;&amp; y)</code> 等同于 <code>!x || !y</code></p><p><code>!(x || y)</code>等同于 <code>!x &amp;&amp; !y</code></p><blockquote><p>换句话说，当您分发逻辑NOT时，您还需要转换为逻辑AND逻辑OR，反之亦然!</p></blockquote></li></ul><hr><ul><li><p><strong>逻辑操作符，异或<code>XOR</code></strong></p><table><thead><tr><th align="left">Left operand</th><th align="left">Right operand</th><th align="left">Result</th></tr></thead><tbody><tr><td align="left">false</td><td align="left">false</td><td align="left">false</td></tr><tr><td align="left">false</td><td align="left">true</td><td align="left">true</td></tr><tr><td align="left">true</td><td align="left">false</td><td align="left">true</td></tr><tr><td align="left">true</td><td align="left">true</td><td align="left">false</td></tr></tbody></table></li></ul><blockquote><p>即，<strong>真假 为 真</strong>，<strong>其他结果都是 假</strong></p></blockquote><p>C++没有提供专门提供 异或操作符，但是我们可以使用：</p><ol><li><p><strong>当操作数是布尔型</strong>的，即true，false，而不是integer，可以使用<code>!=</code>来实现异或：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a != b) <span class="comment">//a XOR b ,假定a、b是booleans</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="comment">//多个操作数</span></span><br><span class="line"><span class="keyword">if</span> (a != b != c != d)  <span class="comment">// a XOR b XOR c XOR d, assuming a, b, c, and d are Booleans</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li><li><p><strong>当操作数不是布尔型</strong>时，<strong>使用<code>static_cast</code>转化为bool</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(a) != <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(b) != <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(c)) <span class="comment">// a XOR b XOR c XOR d, for any type that can be converted to bool</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;p center large&gt;&lt;red&gt;LearnCpp chapter5&lt;/red&gt;&lt;/p&gt;&lt;/center&gt;&lt;center&gt;&lt;red&gt;https://www.learncpp.com&lt;/red&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C/C++" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"/>
    
    
      <category term="C/C++" scheme="https://longlongqin.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>计算机科学速成课(总)</title>
    <link href="https://longlongqin.github.io/archives/3ae1bc73.html"/>
    <id>https://longlongqin.github.io/archives/3ae1bc73.html</id>
    <published>2020-04-01T02:29:42.000Z</published>
    <updated>2020-04-01T02:49:13.858Z</updated>
    
    <content type="html"><![CDATA[<center><red>计算机科学速成课</red></center><a id="more"></a><h1 id="参考文章-："><a href="#参考文章-：" class="headerlink" title="###参考文章###："></a>###参考文章###：</h1><p>*<em>计算机科学速成课 *</em>：</p><p>笔记：<a href="https://www.cnblogs.com/livil/p/10155073.html" target="_blank" rel="noopener">https://www.cnblogs.com/livil/p/10155073.html</a> 和<a href="https://zhuanlan.zhihu.com/p/103505933" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/103505933</a> 或 <a href="https://www.imooc.com/article/271502" target="_blank" rel="noopener">https://www.imooc.com/article/271502</a></p><p>字幕：<a href="https://github.com/1c7/Crash-Course-Computer-Science-Chinese/blob/master/(字幕)全40集中英字幕文本" target="_blank" rel="noopener">https://github.com/1c7/Crash-Course-Computer-Science-Chinese/blob/master/(字幕)全40集中英字幕文本</a></p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/5c2dbf8e0001443913279329.jpg" alt="5c2dbf8e0001443913279329" style="zoom:150%"><h1 id="2、电子计算机"><a href="#2、电子计算机" class="headerlink" title="2、电子计算机"></a>2、电子计算机</h1><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/1528749-20181221121908992-643367848.png" alt="img" style="zoom:200%"><h1 id="3、布尔逻辑和逻辑门"><a href="#3、布尔逻辑和逻辑门" class="headerlink" title="3、布尔逻辑和逻辑门"></a>3、布尔逻辑和逻辑门</h1><p>计算机最早是机电设备，一般用十进制计数。也有一些是三进制、五进制的。【也就是x进制表示有x种状态。】</p><p>二进制中的 1或0 叫做：位（bit）；1字节（byte）=8位(bits)</p><h1 id="5、算数逻辑单元（ALU）"><a href="#5、算数逻辑单元（ALU）" class="headerlink" title="5、算数逻辑单元（ALU）"></a>5、算数逻辑单元（ALU）</h1><p>：是计算机的数学大脑，是计算机里负责运算的组件。</p><blockquote><p>ALU有2个单元：1个<strong>算数单元</strong>和1个<strong>逻辑单元</strong>。</p><p>算数单元：负责计算机里的所有数字操作。如加减法。</p></blockquote><h2 id="1）算数单元"><a href="#1）算数单元" class="headerlink" title="1）算数单元"></a>1）算数单元</h2><h3 id="半加器-A-half-adder"><a href="#半加器-A-half-adder" class="headerlink" title="(半加器)A half adder:"></a>(半加器)A half adder:</h3><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200220151049446.png" alt="image-20200220151049446" style="zoom:150%"><p>半加器如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200211204327584.png" alt="image-20200211204327584"></p><p>将其抽象化，把“把假期”封装成一个单独组件：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200211204510442.png" alt="image-20200211204510442"></p><h3 id="全加器（Full-Adder）"><a href="#全加器（Full-Adder）" class="headerlink" title="全加器（Full Adder）:"></a>全加器（Full Adder）:</h3><p>如果想要处理多位二进制数加法时，就需要<strong>全加器（Full Adder）</strong>，因为半加器计算完当前位的结果后，会输出进位，意味着计算下一位的结果时，要将两个输入以及前一位的进位相加。我们可以得到<strong>全加器</strong>的真值表：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-f41514f0f20020dd462462f3d58bbcc4_r.jpg" alt="preview"></p><center>全加器真值表</center>![image-20200211205005097](https://longlongqin.gitee.io/image_save/images/assets/image-20200211205005097.png)<p>我们这里可以使用半加器来实现全加器。我们可以将一个半加器结果当做是INPUT A 和INPUT B相加后的结果，然后将SUM当做是新的INPUT A，而PRE CARRY当做是新的INPUT B输入到新的半加器中，可以发现其SUM结果和全加器SUM结果相同。而全加器的CARRY只要对这两个半加器的CARRY进行OR运算就可以了。（<strong>注意：</strong>这两个半加器不会同时出现进位）</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-cd2bf02b43475d66ab37e88a47df4eb2_hd.jpg" alt="img"></p><p>同样我们也可以对全加器进行抽象，得到一个包含三个输入和两个输出的独立部件。</p><p>由此我们可以进行两个8位数字相加，表示为A和B:</p><ol><li>对A和B的第一位进行相加时，由于不存在进位，所以值使用一个半加器就能实现，这个半加器的SUM就为该位的结果，CARRY就为进位。</li><li>后续的7位二进制相加，由于每一个都涉及了上一位的进位，所以后续需要7个全加器，并且每个全加器的CARRY要连接到下一个全加器的输入，而每个全加器的SUM就为该位的结果。</li><li>最后一个全加器有CARRY的输出，如果该CARRY为1，就表示相加结果太大了，超出了8位，所以出现了<strong>溢出（overflow）</strong>【<strong>溢出：</strong>一般来说 “溢出” 的意思是, 两个数字的和太大了，超过了用来表示的位数，这会导致错误和不可预期的结果。】。</li></ol><p>由此，我们就构建出了一个<strong>8位加法器（8-bit adder）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-232e40f98a8adcf998b256bfe5c52bae_hd.jpg" alt="img"></p><p>通过连接1个半加器和n-1个全加器，就能构建n位加法器。通过叠加更多的加法器，能够避免溢出的出现，但是会出现更多的逻辑门，而且每次进位都要一些时间，而计算是串行的，所以消耗的时间也越长，到如今的每秒几十亿次运算时就会造成影响，所以现代计算机用的加法电路有所不同，称为<strong>超前进位加法器（Carry-Look-Ahead Adder）。</strong></p><p><strong>ALU通常支持以下操作：</strong>加法、带进位的加法、减法、带借位的减法、取反、增1、减1、数字无改变通过。这些操作也是由逻辑门构成的。<strong>注意：</strong>简单的ALU并==不==支持乘法，而是把乘法用多次加法来实现，而更好的处理器有专门做乘法的算数单元。</p><h2 id="2）逻辑单元"><a href="#2）逻辑单元" class="headerlink" title="2）逻辑单元"></a>2）逻辑单元</h2><p><strong>逻辑单元：</strong>执行逻辑操作，比如AND、OR和NOT操作，也能做简单的数值测试，比如数字是不是负数。</p><p>对整个8位ALU进行抽象，用一个特殊的V形符号进行表示。其中有两个<strong>8位输入</strong>，并且有一个4位<strong>操作码（Operation Code）</strong>来告诉ALU对输入执行什么操作，比如1000表示加法命令，1100表示减法命令，然后有一个<strong>8位输出</strong>。同时ALU会输出一系列1位<strong>标志（FLAG）</strong>，来表示特定状态，比如我们可以计算A-B，然后通过ZERO来判断结果是否为零来判断A与B是否相等，通过NEGATIVE来判断A是否小于B；然后OVERFLOW连接到加法器的进位，来判断是否出现溢出。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-324be370be80687e69aeb12d8173dccd_hd.jpg" alt="img"></p><hr><h1 id="6、寄存器-amp-内存"><a href="#6、寄存器-amp-内存" class="headerlink" title="6、寄存器&amp;内存"></a>6、寄存器&amp;内存</h1><p>上节中介绍的ALU进行计算后得到的结果需要对其进行存储，可能还要进行多个连续操作，这就需要用到计算机内存了。计算机使用的是<strong>随机存取存储器（Random Access Memory, RAM）</strong>，其只能在<u>有电</u>的情况下存储东西。另一种存储称为<strong>持久存储（Persistent Memory）</strong>，电源关闭时数据也不会丢失，它用来存其他东西。</p><blockquote><p>随机存取存储器(RAM)：只能在有电的时候存储东西。【 <strong>内存</strong>的一个重要特性：可以随时访问任何位置。所以叫“<strong>随机存取存储器(RAM)</strong>”】</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213205406365.png" alt="image-20200213205406365"></p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212233032303.png" alt="image-20200212233032303">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212233049692.png" alt="image-20200212233049692">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212233107576.png" alt="image-20200212233107576"></p></blockquote><p>放入数据的动作叫“<strong>写入</strong>”，拿出数据的动作叫“<strong>读取</strong>”。</p><p>这一节中首先构建能够存储1位的存储器，然后对其扩展来得到内存模块。</p><p>之前构建的都是单向电路，我们同样可以构建回向电路，把输出连回输入。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-81c6dd82241ba3a7de60809922f4e8f7_hd.jpg" alt="img"></p><blockquote><p>1、当将OR门构建成回向电路时，可以分析其电路特性：</p><ul><li>A和B初始为0时，输出结果为0</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://pic1.zhimg.com/80/v2-3dd54ae2c78016bfd6eba69be1f34e98_hd.jpg" alt="img"></p><center>存储0的电路</center>- 将A修改为1时，输出结果为1，此时B的输入就变为了1。随后输出始终保持为1，不论A如何变化。<p>所以这个电路能够永久记录1，并且无法将1变回0。</p><p>2、同理可以分析下AND门构建成回向电路时的特点</p><ul><li><p>A和B初始化为1，则输出结果为1</p></li><li><p>将A修改为0时，输出结果为0，此时B的输入就变成了0。随后输入始终保持为0，无论A如何变化。</p></li></ul><p>所以这个电路能够永久记录0，并且无法将0变回1。</p></blockquote><p>所以我们就得到了能够存储1和0的电路，为了得到有用的Memory，需要将两个电路结合起来，可以得到<strong>AND-OR锁存器（AND-OR Latch）</strong>，上方的是SET输入，下方的是RESET输入，当SET=1、RESET=0，就能将输出设置为1，当RESET=1，就能将输出设置为0，当SET=0、RESET=0，则输出最后放入的内容。由此能够存储1位的信息（该信息存储在OR门上方的输入电极中）！</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200220160959766.png" alt="image-20200220160959766"></p><p>这叫”锁存”, 因为它”锁定”了一个值，放入数据的动作叫 “写入” ，拿出数据的动作叫 “读取”。</p><p>对其进行SET和RESET进行合并，并添加其他门控单元，可以得到一个<strong>门锁（GATE LATCH）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212230438229.png" alt="image-20200212230438229"></p><center>门锁</center>其中DATE INPUT表示数据输入，WRITE ENABLE表示允许写入线，用来控制是否保存当前输入的数据。对这个电路进行分析。<p>可以将门锁进行<u>抽象</u>，得到一个能够存储<strong>一个bit</strong>的部件。当允许写入线为0时，输出保持不变，当允许写入线为1时，输出就是数据输入，并且能够将数据输入进行存储。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212230837936.png" alt="image-20200212230837936"></p><center>门锁的抽象</center>如果我们并排8个锁存器，就能存储8位信息。一组这样的锁存器称为**寄存器（Register）**，寄存器能够存一个数字，这个数字的位数称为寄存器的**位宽（Width）**。<p>写入寄存器之前，要先启动里面所有的锁存器，可以将所有锁存器的允许写入线都连接在一起，把它设为1，然后用8条数据线发送数据，然后将允许写入线设回0，就能将8位数据存储在寄存器中。</p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212231015481.png" alt="image-20200212231015481"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212231043071.png" alt="image-20200212231043071"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212231125590.png" alt="image-20200212231125590"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212231159981.png" alt="image-20200212231159981"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212231218808.png" alt="image-20200212231218808">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212231232434.png" alt="image-20200212231232434"></p></blockquote><h2 id="寄存器："><a href="#寄存器：" class="headerlink" title="寄存器："></a>寄存器：</h2><p>上面是只能存储1bit的“<strong>锁存器</strong>”，如果我们并排放8个锁存器，就可以存8位(bits)信息。</p><p>一组这样的锁存器叫做“<strong>寄存器</strong>”。</p><p>1、<strong>位宽</strong></p><p>寄存器能存一个数字，这个数字有多少位，叫做“<strong>位宽</strong>”。</p><p>$早期电脑用8位寄存器，然后是16位、32位。如今都有64位宽的寄存器。$</p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213201814518.png" alt="image-20200213201814518">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213201940951.png" alt="image-20200213201940951">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213202116937.png" alt="image-20200213202116937">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213202136340.png" alt="image-20200213202136340"></p><p>所以，如64位的寄存器只需要129条线就可以了。【64条是“数据输入线”、“64条数据输出线”、“一条启用写入线”】。</p><p>如果要存256位，就需要513条线。减少线数的方法就是：<strong>矩阵</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213202534237.png" alt="image-20200213202534237">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213202641868.png" alt="image-20200213202641868"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213202711027.png" alt="image-20200213202711027"></p><p>所以，对于一个256位的存储：只需要35条。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213202942105.png" alt="image-20200213202942105">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213203005839.png" alt="image-20200213203005839"></p><p>如果想要访问特定的锁存器（即寻找其地址），（由于行数和列数均只有16，所以均可以用4个二进制位来表示。）就有行号和列号来对应。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213203515940.png" alt="image-20200213203515940">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213203551017.png" alt="image-20200213203551017">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213203634252.png" alt="image-20200213203634252">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213203648070.png" alt="image-20200213203648070"></p><blockquote><p><strong>多路复用器</strong>：有不同大小。通常包含一定数目的数据输入，有一个单独的输出。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213203948627.png" alt="image-20200213203948627"></p></blockquote><p>把256位内存当成一个整体，抽象化一下：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204207689.png" alt="image-20200213204207689">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204308742.png" alt="image-20200213204308742">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204324322.png" alt="image-20200213204324322"></p><p>一个256位内存也不能做什么大事，所以继续扩大：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204433307.png" alt="image-20200213204433307">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204508271.png" alt="image-20200213204508271">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204556045.png" alt="image-20200213204556045">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204731314.png" alt="image-20200213204731314">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204837880.png" alt="image-20200213204837880"></p><p>再次，看成一个整体：</p><p>下图中：我们有256个地址，每个地址能读或写一个8位(bit)的值。<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204931499.png" alt="image-20200213204931499">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213205132085.png" alt="image-20200213205132085">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213205150693.png" alt="image-20200213205150693">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213205208450.png" alt="image-20200213205208450">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213205234980.png" alt="image-20200213205234980">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213205253990.png" alt="image-20200213205253990"></p></blockquote><p>这一节用锁存器做了一块<strong>静态随机存取存储器（Static Random-Access Memory，SRAM）</strong>，还有很多其他类型的RAM，比如DRAM、闪存和NVRAM，它们的功能和SRAM相似，但是使用不同的电路存放单个位。但是根本上，这些技术都是矩阵层层嵌套来存储大量信息。</p><h1 id="7、中央处理器-CPU"><a href="#7、中央处理器-CPU" class="headerlink" title="7、中央处理器(CPU)"></a>7、中央处理器(CPU)</h1><p>CPU负责执行程序，程序由一个个操作组成，这些操作叫“指令(instruction)”。</p><p>如果是<strong>数学指令</strong>，比如加减，CPU会让ALU进行数学运算。如果是<strong>内存指令</strong>，CPU会和内存通信，然后读写值。</p><h1 id="9、高级CPU设计"><a href="#9、高级CPU设计" class="headerlink" title="9、高级CPU设计"></a>9、高级CPU设计</h1><p>RAM是CPU之外的独立组件，意味着数据要用线来传递，这个线叫做“<strong>总线（BUS）</strong>”。</p><p>$总线可能只有几厘米，虽然电信号传输速度接近光速，但是CPU每秒可以处理上亿条指令，很小的延迟也会造成问题。$</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214194800104.png" alt="image-20200214194800104">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214195130456.png" alt="image-20200214195130456"></p><h2 id="提升性能方法一：缓存"><a href="#提升性能方法一：缓存" class="headerlink" title="提升性能方法一：缓存"></a>提升性能方法一：缓存</h2><p>一条“从内存读数据”的指令可能需要多个时钟周期，而此时CPU空等数据。解决延迟的方法之一是给CPU加一点RAM,叫：“<strong>缓存(Cache)</strong>”。因为处理器的空间不大，所以缓存一般只有KB或MB，而RAM都是GB起步。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214195534052.png" alt="image-20200214195534052"></p><p>缓存提高了速度：当CPU从RAM拿数据时，RAM不用传一个，可以传一批。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214195800275.png" alt="image-20200214195800275"></p><p>虽然花的时间多一点，但数据可以存在缓存。这很实用，因为数据常常是一个个按顺序处理。比如：算餐厅的当日收入时，先取RAM地址为100 的交易额，RAM与其只给一个值，不如直接给一批值，把地址为100~200的数据都复制到缓存中。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214200104046.png" alt="image-20200214200104046"></p><p>当处理器要下一个交易额（地址为101的）时，缓存就会告诉处理器：“我已经有这个数据了，现在就给你”。就不用再去RAM取数据了。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214200354398.png" alt="image-20200214200354398">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214200419065.png" alt="image-20200214200419065"></p><p>当想要的数据已经在缓存中时，这种状态叫“<strong>缓存命中</strong>（Cache Hit）”；如果不在，则叫“<strong>缓存未命中（Cache Miss）</strong>”。</p><p>缓存也可以当临时空间，存一些中间值，适合长的或者复杂的运算。继续餐馆的例子：假设CPU算完了一天的销售额，想把结果存到地址为150的地方。就像之前，数据不是直接存到RAM中，而是存在缓存中。这样不但存起来快一些、如果还要接着计算，取值也会快一些。</p><p>但是这会导致：缓存和RAM中的数据不一致。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214201154364.png" alt="image-20200214201154364"></p><p>因此缓存里每块空间有一个特殊标记，叫：“<strong>脏位（Dirty Bit）</strong>”。</p><p>同步一般发生在：当缓存满了而CPU又需要缓存的时候。在清理缓存腾出空间之前，会先检查“脏位”，如果是“脏”的话，在加载新内容之前，会把数据写回RAM。</p><p>![演示 (3)](<a href="https://longlongqin.gitee.io/image_save/images/assets/演示" target="_blank" rel="noopener">https://longlongqin.gitee.io/image_save/images/assets/演示</a> (3).gif)</p><h2 id="提升性能方法二：“指令流水线”"><a href="#提升性能方法二：“指令流水线”" class="headerlink" title="提升性能方法二：“指令流水线”"></a>提升性能方法二：“指令流水线”</h2><blockquote><p>指令流水线：instruction pipelining</p></blockquote><p>例如：如果你想要洗一整个的床单，但只有一个洗衣机和一个烘干机。</p><blockquote><p>选择一：按顺序，先放洗衣机洗30分钟，然后在烘干机30分钟。共计1小时。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214203334316.png" alt="image-20200214203334316"></p><p>选择二：像一中一样，先放一批床单到洗衣机30分钟，然后把它放到烘干机中。但是这时候要等30分钟才能烘干。此时，可以放另一批床单到 洗衣机（此时，洗衣机，烘干机在同时工作），依次，直到洗完所有床单。效率是一的2倍。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214203636909.png" alt="image-20200214203636909"></p></blockquote><p>处理器也可以这样设计，CPU是按顺序处理的：<strong>(读)取指(令)——&gt;解码——&gt;执行</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214203831692.png" alt="image-20200214203831692"></p><p>不断重复：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214203857837.png" alt="image-20200214203857837"></p><p>但是每个阶段都是用的CPU的不同部分，意味着可以并行处理：“执行”一个指令时，同时“解码”下一个指令，同时，“读取”下下条指令。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214204249010.png" alt="image-20200214204249010"></p><p>这样的流水线，每一个时钟周期执行1个指令，吞吐量乘3.</p><p>但是，和缓存一样，这也会带来一些问题：</p><blockquote><p>问题1：指令之间的依赖关系。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214204538900.png" alt="image-20200214204538900">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214204559995.png" alt="image-20200214204559995"></p><p>因此流水线处理器，要先弄清楚<em>数据依赖性</em>。必要时停止流水线，避免出问题。高端的CPU，会最小化流水线的停工时间，这叫“<strong>乱序执行</strong>”。</p><p>问题二：“条件跳转”，比如之前的JUMP NEGATIVE（类似循环跳转）。这些指令会改变程序的执行流。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205017629.png" alt="image-20200214205017629">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205037500.png" alt="image-20200214205037500"></p><p>空等会造成延迟。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205050629.png" alt="image-20200214205050629"></p><p>​ 技巧：“<strong>推测执行</strong>”</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205158772.png" alt="image-20200214205158772">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205214800.png" alt="image-20200214205214800">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205239401.png" alt="image-20200214205239401"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205303755.png" alt="image-20200214205303755">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205314350.png" alt="image-20200214205314350">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205323242.png" alt="image-20200214205323242">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205340699.png" alt="image-20200214205340699"></p><p>为了尽可能减少清空流水线的次数，CPU厂商开发复杂的方法：“<strong>分支预测</strong>”。现在这种猜测的正确率超过90%。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205504704.png" alt="image-20200214205504704"></p><p>在理想情况下，CPU在一个时钟周期完成一个指令。但是“<strong>超标量处理器</strong>”的出现，一个时钟周期可以完成多个指令。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205918942.png" alt="image-20200214205918942"></p><p>用“<strong>多核处理器</strong>”【双核、四核处理器：意思是一个CPU芯片里，有多个独立的处理单元，”看起来就像有多个独立的CPU”。但因为他们整合紧密，可以共享一些资源如，缓存，使得多核可以合作运算。】。当多核不够时，可以用多个CPU。</p></blockquote><h1 id="10、早期的计算机编程"><a href="#10、早期的计算机编程" class="headerlink" title="10、早期的计算机编程"></a>10、早期的计算机编程</h1><p>​ 之前的程序是用<strong>插线板</strong>编程，到后来（1940年代晚期到1950年代初）<strong>内存</strong>的价格下降，容量上升，使得程序存入内存变得可行。程序存入内存中易于修改、方便CPU快速读取，这类机器叫做：“<strong>存储程序计算机（Stored-program Computers）</strong>”。内存足够时，还可以存储程序需要的数据（包括运行时产生的数据）。这种将程序和数据存储在一起的存储结构，叫“<strong>冯诺依曼结构</strong>”。</p><p>​ 冯诺依曼计算机的标志是，一个处理器（有算数逻辑单元）+数据寄存器+指令寄存器+指令地址寄存器+内存（负责存数据和指令）。</p><h1 id="11、编程语言发展史"><a href="#11、编程语言发展史" class="headerlink" title="11、编程语言发展史"></a>11、编程语言发展史</h1><p>​ 计算机只能处理二进制，其实，“<strong>机器语言（Machine Language）</strong>”或“<strong>机器码（Machine Code）</strong>”。在计算机早起，还必须要用机器码 些好吃呢供需，一般会先对程序进行高层次的功能描述，称为“<strong>伪代码（Pseudo-code）</strong>”，只是助于程序员理解无法让计算机运行，然后根据指令表将伪代码转换成二进制机器码，然后将机器码送入计算机中运行。</p><p>​ 在1940-1950年，程序员开发出一种新语言，更可读、更高层次，每个操作码分配一个简单名字，称为<strong>助记符（Mnemonics）</strong>，助记符后跟数据，形成完整的指令。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200215202238984.png" alt="image-20200215202238984"></p><p>所以与其写0和1的机器码，程序员可以直接写“LOAD_A 14”，这个语言称为<strong>汇编语言（Assembly Language）</strong>。当然计算机无法理解“LOAD_A 14”，所以程序员们写了一个程序来将文字指令自动转换成二进制指令，这个程序称为<strong>汇编器（Assembler）</strong>，$汇编器读取汇编语言写的程序，然后转换成机器码$。</p><p>随着发展，汇编器有越来越多的功能使得编程更加容易，其中一个功能就是自动分析JUMP地址。如下图，JUMP后面跟的是内存中的真实地址，如果我们在上方对程序进行修改，则后面的所有地址都会改变。所以<u>汇编器不用固定跳转地址</u>，而是让你插入可跳转的标签，当程序传入汇编器，汇编器就会自己推算出跳转地址，这样就程序员就无序过分关注细节。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-c044bd0bbaf2c1bc95398ca38ea36153_hd.jpg" alt="img"></p><p>​ $汇编代码例子$</p><p>汇编只是修饰了一下机器码，一般来说，<u>一条汇编指令对应一条机器指令</u>，所以汇编码和底层硬件连接很密切，程序员仍需要思考使用什么寄存器和内存地址。为了释放电脑的潜力，霍普设计了一个高级编程语言，叫做Arithmetic Language Version 0，简称A0。一行高级编程语言，可能会转换成几十条二进制指令。为此做到这种复杂转换，霍普在1952年创造了第一个<strong>编译器（Compiler）</strong>，编译器专门把高级语言转换成低级语言（比如汇编 或 机器码）。由此，高级编程语言就不用管寄存器或内存位置，编译器会解决这些细节。</p><p>在1950年，大多数编程语言和编译器只能运行在一种计算机中，如果更换计算机，就要重写所有代码，因此1959年开发一种通用编程语言，可以在不同机器上通用，最后诞生了一门高级、易于使用的语言<strong>普通面向商业语言（Common Business-Oriented Language，COBOL）</strong>。为了兼容不同底层硬件，每个计算机架构需要一个COBOL编译器，由此无论运行的计算机是什么，这些编译器可以接收相同的COBOL代码。如今大多数编程语言都是如此，不必接触CPU特有的汇编码和机器码。</p><h1 id="12、编程原理-语句和函数"><a href="#12、编程原理-语句和函数" class="headerlink" title="12、编程原理-语句和函数"></a>12、编程原理-语句和函数</h1><p><code>a=5;</code>是一个编程语言的<strong>语句</strong>。</p><p>程序由一个个指令组成。</p><h1 id="13、算法入门"><a href="#13、算法入门" class="headerlink" title="13、算法入门"></a>13、算法入门</h1><p><strong>算法</strong>：<strong>解决问题的具体步骤。</strong></p><h1 id="14、数据结构"><a href="#14、数据结构" class="headerlink" title="14、数据结构"></a>14、数据结构</h1><p>数据是以什么形式存在内存里呢？<strong>我们希望数据是结构化的，方便读取</strong>，由此发明了数据结构。</p><h2 id="14-1-数组Array"><a href="#14-1-数组Array" class="headerlink" title="14.1 数组Array"></a>14.1 数组Array</h2><p>一个变量只能存储一个值，而一个数组变量能够保存多个同类型值，并且数组的值是一个个连续存在内存中的。</p><p>为了取出数组中的某个值，我们需要指定一个<strong>下标（Index）</strong>。大多数编程语言中，数组的下标都从0开始。下图是数组保存在内存中的形式，为了简单，假设编译器从内存地址1000开始保存数组，数组中的内容就像图中那样顺序保存在内存中。定义该数组变量为<code>j</code>，则<code>j[0]</code>会取内存地址1000的数据来获得第一个元素的值， <code>j[5]</code> 则会去内存地址1000加5个偏移量得到内存地址1005中保存的数据。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-05e5d5a5004692369a9475bf3d6f886a_hd.jpg" alt="img"></p><p><strong>缺点：</strong>创建数组时就要固定大小，不能动态增加大小，并且数组在内存中是按顺序存储的，在中间插入一个值很困难。</p><h3 id="14-2-字符串String"><a href="#14-2-字符串String" class="headerlink" title="14.2 字符串String"></a>14.2 字符串String</h3><p>类似于数组，其实就是字母、数字、标点符号等构成的数组。我们在第4节中有讨论了计算机怎么存储字符的，通过ASCII或者Unicode编码，将字符转换为对应的二进制数。</p><p>写代码时，可以直接用引号括起来构建字符串<code>j=&quot;Hello World&quot;</code>， 其在内存中的存储形式如下图。<strong>注意：</strong>字符串在内存中以<strong>二进制0</strong>结尾，表示字符串结尾，用来给别的函数指示什么时候字符串结束了。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-b8b2ba66353be16cf7a7c96f744c9879_hd.jpg" alt="img"></p><h3 id="14-3-矩阵Matrix"><a href="#14-3-矩阵Matrix" class="headerlink" title="14.3 矩阵Matrix"></a>14.3 矩阵Matrix</h3><p>之前保存的都是一维数组，但是像电子表格或屏幕像素，都需要保存二维信息，所以这里就需要用到矩阵。</p><p>可以将矩阵看成是数组的数组，比如一个3x3矩阵， 相当于就是一个长度为3的数组，而这个数组中的每个元素又是一个长度为3的数组。矩阵保存在内存中的形式如下图所示，这里使用的是<u>行优先存储</u>，即优先将矩阵的每一行保存在内存的相邻位置，当一行保存完后，再保存下一行。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-45786350b76ab13bf59f20d2d2a0f432_hd.jpg" alt="img"></p><center>矩阵例子</center>![img](https://longlongqin.gitee.io/image_save/images/assets/v2-f4e8c5b992abea5477f71fcf39702a68_hd.jpg)<center>内存中的矩阵</center>为了获取一个值，需要两个小标，比如`j[2][1]`表示从内存地址1000偏移`2*3+1=7`位置，得到元素12。这里偏移量的计算方法是`行索引*列元素个数+列索引`。<p>我们不仅能构建二维矩阵，我们可以构建任意维度的矩阵。</p><h3 id="14-4-结构体Struct"><a href="#14-4-结构体Struct" class="headerlink" title="14.4 结构体Struct"></a>14.4 结构体Struct</h3><p>目前我们只将单个数字或字符存在数组或矩阵中，在数组中保存的都是相同类型的元素。<u>如果我们想把几个有关系的变量存储在一起，并且这些变量都是不同类型的</u>，我们就需要用到结构体。</p><p>…..</p><h1 id="16、软件工程"><a href="#16、软件工程" class="headerlink" title="16、软件工程"></a>16、软件工程</h1><p>为了写大型程序，程序员用各种工具和方法，所有这些形成了软件工程学科。</p><p>将大项目分解成小<strong>函数</strong>可以让很多人同时工作，由此他们无需关心整个项目，只要关心自己的函数就好了。</p><p>但是这种抽象程度还是不够，大型项目中可能还是会存在大量的函数，因此需要将函数打包成层级，将相关代码放在一起，打包成<strong>对象（Object）</strong>。比如汽车软件中，可能有几个和定速巡航有关的函数，因此我们可以包装一个“定速巡航对象”来打包这些函数，我们还可以更进一步，“定速巡航”只是引擎软件的一部分，可能还有“火花塞点火”、“燃油泵”和“散热器”等等，因此我们可以做一个“引擎对象”来打包所有子对象，并且除了子对象，引擎对象还会包含自己的函数，比如“开关引擎”，也会有自己的变量，比如汽车行驶里程数。总的来说，对象可以包含其他对象、函数和变量。然后当你想调用一个比较底层对象的函数时，只需要层层向下调用就行，比如<code>Car.Engine.CruiseControl.setCruiseSpeed(55)</code>。这种将函数打包成对象的思想称为<strong>面向对象编程（Object Oriented Programming）</strong>。相同的想法都是通过封装组件来隐藏复杂度。</p><p>把大型软件拆成一个个更小单元，会更适合团队合作。但是各个团队之间的代码是相互交织的，比如团队A实现的某个函数需要团队B的代码支持，因此团队需要<strong>文档（Documentation）</strong>来帮助理解代码都做什么，以及定义好的<strong>程序编程接口（Application Programming Interface，API）</strong>。这样，即使程序员不知道具体的实现细节，也能直接使用API调用相应的函数。并且API能控制哪些函数和数据是对外开放的，哪些是仅供对象内部使用的，面向对象的编程语言可以指定函数时<code>public</code>或<code>private</code>来设置权限，避免用户调用错了函数造成bug。如果标志为private，表示只有同一个对象内的其他函数能调用它， 所以在这个例子中，只有内部函数比如<code>setRPM</code>能够调用 <code>fireSparkPlug</code>函数，并且由于<code>setRPM</code>函数是public的，所以其他对象可以调用它。</p><blockquote><p><strong>面向对象编程的核心：</strong>隐藏复杂度，选择性的公布功能。</p></blockquote><p>现代软件开发者会使用专门的工具来写代码，工具里集成了很多功能帮助写代码、整理、编译和测试，这些软件称为<strong>集成开发环境（Integrated Development Environments，IDE）</strong>。</p><p>程序员一个重要的工作部分是给代码写文档，一般放在一个叫<code>README</code>的文件中， 文档也能直接写成注释放在源代码中。</p><p>除了IDE，还有一个重要软件帮助团队协作，称为<strong>源代码管理（Source Control）</strong>。比较大型的公司会将代码放在一个中心服务器上，称为<strong>代码仓库（Code Repository）</strong>。当程序员想改一段代码时，可以check out获得代码，然后开发者在自己电脑上编辑代码，当代码没有问题，所有测试都通过时，就能将代码放回代码仓库了，称为<strong>提交（Commit）</strong>。当代码被check out，并且可能被改过了，其他开发者就不会动这段代码，避免代码冲突和重复劳动。代码的主版本（master）应该总是编译正常，尽可能少bug。并且源代码管理可以跟踪所有变化，当出现bug时，全部或部分代码可以<strong>回滚（Rolled Back）</strong>到之前的稳定版本，并且也能记录下代码修改者。</p><p>测试代码一般由个人或小团队完成，测试可统称为<strong>质量保证测试（Quality Assurance Testing，QA）</strong>。<strong>“alpha version”</strong>软件一般很粗糙，错误很多，经常只在公司内部操作，而<strong>“beta version”</strong>软件指的是软件接近完成，但不是完全测试通过，公司有时会向公众发布beta版，以帮助发现问题，用户就像免费的QA团队。</p><h1 id="17、集成电路-amp-摩尔定律"><a href="#17、集成电路-amp-摩尔定律" class="headerlink" title="17、集成电路&amp;摩尔定律"></a>17、集成电路&amp;摩尔定律</h1><p>过去计算机的飞速发展，强烈依赖于硬件的发展。</p><p>大约1940年代-1960年代中期，计算机都由独立部件组成，称为<strong>分立元件（Discrete Components）</strong>，然后不同组件再用线连在一起。比如ENIAC有1万7千多个真空管，7万个电阻，1万个电容，7千个二极管，5百万个手工焊点。如果想要提升性能，就要加更多部件，这就导致了更多更复杂的电线，这个称为<strong>数字暴政（Tyranny of Numbers）</strong>问题。</p><p>到1950年代中期，晶体管开始商业化，开始用于计算机中，晶体管比电子管更小更快更可靠，但晶体管依然是分立元件。1959年，IBM把709计算机从原本的电子管全部换成晶体管，诞生了IBM 7090，速度快6倍，价格只有一半。晶体管标志着计算机2.0时代的到来，但是晶体管的出现还是没有解决数字暴政的问题，有十几万个独立元件的计算机不但难设计，而且难生产。</p><h2 id="集成电路（Integrated-Circuits，IC）："><a href="#集成电路（Integrated-Circuits，IC）：" class="headerlink" title="集成电路（Integrated Circuits，IC）："></a>集成电路（Integrated Circuits，IC）：</h2><p>到1960年代，这个问题的严重性达到顶点，解决方法就是引入一层新抽象，封装复杂性。突破性进展在1958年，与其把多个独立部件用电线连起来，拼装出计算机，我们把多个组件包在一起，变成一个新的独立组件，这个称为<strong>集成电路（Integrated Circuits，IC）</strong>。几个月后，仙童半导体就让集成电路变成现实，之前使用锗来做集成电路，但是锗很稀少且不稳定，仙童半导体使用<strong>硅</strong>，因为硅的蕴藏量丰富，也更稳定可靠。</p><p>起初，一个IC只有几个晶体管，但是也足以将逻辑门封装成独立组件，可以组合出无数种设计，但是最终还是要连起来，创造出更大更复杂的电路，比如计算机。所以创造出了<strong>印刷电路板（Printed Circuit Boards，PCB）</strong>，可以大规模生产，无需焊接或用一堆线，它通过蚀刻金属线的方式将零件连接到一起。把PCB和IC结合使用，可以大幅减少独立组件和电线，但做到相同的功能，而且更小更便宜更可靠。</p><p>不过即使组件再小，塞5个以上的晶体管还是很困难，为了实现更复杂设计，出现了全新的制作工艺——<strong>光刻（Photolithography）</strong>。简单来说，就是用光把复杂图案印到材料上，比如半导体。它只有几个基础操作，但是可以制作出复杂电路。</p><blockquote><ul><li>首先，我们从一片硅开始，称为<strong>晶圆（Wafer）</strong>，长得和薄饼干一样。并且硅是半导体，有时导电有时不导电，我们就可以控制导电时机，所以硅是做晶体管的绝佳材料。我们可以用晶圆做基础，把复杂金属电路放上去，来集成所有东西。</li><li>在硅片顶部加一层薄薄的<strong>氧化层（Oxide Layer）</strong>作为保护层，然后加一层特殊化学品称为<strong>光刻胶（Photoresist）</strong>，光刻胶被光照射后，就变得可溶，可以用一种特殊化学药剂洗掉。然后我们会在光刻胶上加一层<strong>光掩膜（Photomask）</strong>，当用强光照射时，挡住光的部分光刻胶就不会变化，而光照射到的地方，光刻胶就会发生化学变化，洗掉变化的光刻胶后，就会暴露出部分氧化层。然后通常用酸能洗掉氧化层暴露出的部分，就能蚀刻到硅层。然后再用另一种化学试剂清洗掉剩余的光刻胶，这样只剩下氧化层和晶圆了。我们想修改硅暴露出来的区域，让它们导电性更好，所以我们使用<strong>掺杂（Doping）</strong>，通过将磷渗透进暴露的硅，来改变电学性质。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-43b8796ff46c3bf12da90361caf3a74b_hd.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-b19ae3a9f85fb157495ee4a2a986c4b1_hd.jpg" alt="img"></p><ul><li>我们还需要几轮光刻法来做晶体管。还是叠加上氧化层、光刻胶和新的光掩膜，这样就能在掺杂区域上方开缺口，然后进行清洗蚀刻，再用另一种元素进行掺杂，把硅转换成另一种形式。为了控制深度，时机很重要，不要超过之前掺杂的区域，这样所有需要的组件都有了。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-0261b1e130471a85ebaea8f5df038bab_hd.jpg" alt="img"></p><ul><li>最后，在氧化层上做通道，这样可以用细小金属导线连接不同晶体管。首先用光刻胶和光掩膜，在氧化层上蚀刻出小通道。然后用新的处理方法称为<strong>金属化（Metalization）</strong>，在氧化层上放一层薄薄的金属，比如铝或铜，再加上光刻胶和光掩膜，然后融掉暴露的光刻胶，暴露出金属。最终清洗，只保留晶圆、氧化层和金属化，这样就做出了一个晶体管。它有三根线分别连接着硅的三个不同区域，每个区域的掺杂方式不同，这个叫<strong>双极型晶体管（Bipolar Junction Transistor）</strong>。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-b2d6dce62f3352d950dc12e238fc0099_hd.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-f099fd3eea9861f0ef822f76299e616c_hd.jpg" alt="img"></p><center>晶体管</center></blockquote><p>相同方法，光刻可以在一片硅上制作其他电子元件，比如电阻电容，而且相互连接的电路也做好了。</p><p><strong>并且通过调节光掩膜和光源之间的距离</strong>，光可以投射成任意角度，我们可以把光掩膜聚焦到极小的区域，制作出非常精细的细节，这样一片晶圆就能做出很多IC，整块都做完后，就可以切割然后包进微型芯片中，芯片的核心都是一小片IC。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-77dbe69c1ca5bcacd2c735dccfe11c7a_hd.jpg" alt="img"></p><p>随着光刻技术发展，晶体管变小，密度变高。1960年初，IC很少能超过5个晶体管，但到了1960年中期，市场上已经开始出现超过100个晶体管的IC。</p><h2 id="摩尔定律（Moore’s-Law）"><a href="#摩尔定律（Moore’s-Law）" class="headerlink" title="摩尔定律（Moore’s Law）:"></a>摩尔定律（Moore’s Law）:</h2><p>1965年，戈登·摩尔看到了发展趋势，提出<strong>摩尔定律（Moore’s Law）</strong>：<strong>每两年左右，得益于材料和制造技术的发展，同样大小的空间，能塞进两倍量的晶体管。</strong></p><p>晶体管更小密度更高，要移动的电荷量就越少，能快速切换状态，耗电更少。并且电路更紧凑，意味着信号延迟更低，导致时钟速度更快。</p><p>集成电路的出现，尤其是用来做微处理器，开启了<strong>计算机3.0时代</strong>。</p><p>到了2010年，一个IC中有10亿个晶体管。为了达到这种密度，光刻的分辨率从大约一万纳米，发展到如今的14纳米。</p><p>现代工程师设计电路时，不是手工一个个设计晶体管的，从1970年代开始，<strong>超大规模集成（Very-large-scale Integration，VLSI）</strong>软件用来自动生成芯片设计。用比如<strong>逻辑综合（Logic Synthesis）</strong>可以放一整个高级组件，比如内存缓存，软件会自动生成电路，做到尽可能高效，许多人认为这是<strong>计算机4.0时代</strong>的开始。</p><p><u>但是摩尔定律现在迎来了终结，进一步做小，会迎来两个问题：</u></p><ol><li>用光掩膜把图案弄到晶圆上，因为光的波长，精度已经到达极限。所以科学家在研制波长更短的光源，投射更小的形状。</li><li>当晶体管非常小，电极之间可能只距离几个原子，电子就会跳过间隙，称为<strong>量子隧道贯穿（Quantum Tunneling）</strong>，由此晶体管就不能正常工作了。</li></ol><h1 id="18、操作系统"><a href="#18、操作系统" class="headerlink" title="18、操作系统"></a>18、操作系统</h1><p>40 50年代的电脑，每次只能运行一个程序，程序员在打孔纸上写程序，然后再放入计算机中进行计算，一开始计算机速度比较慢，通常一个程序需要运行几天时间，所以放程序的时间还能忍受。但是随着计算机运算速度的告诉发展后，放程序的时间比程序运行时间还要长，我们就需要一种方式，让计算机自动运行，于是诞生了<strong>操作系统（Operation Systems，OS）</strong>。</p><p><strong>操作系统其实也是程序</strong>，<u>但它有操作硬件的特殊权限，可以运行和管理其他程序</u>。操作系统一般是开机第一个启动的程序，然后其他所有程序都由操作系统启动。从1950年代开始有操作系统，那时计算机开始变得更加强大， 第一个操作系统主要加强了程序加载方式，取代了手工加载程序的过程。</p><p>之前只能一次给一个程序，现在可以一次多个程序，当计算机运行完一个程序后，就会自动运行下一个程序，这样就不用浪费时间找下一个程序的纸卡，这称为<strong>批处理（Batch Processing）</strong>。</p><p>随着计算机的发展，计算机出现在大学和政府办公室，人们开始分享软件，但是有个问题。在哈佛1号和ENIAC那个时代，计算都是一次性的，程序员只需要给特定一台机器写代码，其中处理器、读卡器和打印机都是已知并且不会改变的。但是随着计算机越来越普遍，计算机配置并不总是相同的，比如计算机可能有相同的CPU但是不同的打印机等等，这样程序员不仅要担心程序，还要担心程序怎么和不同型号的打印机进行交互，以及计算机连着的其他设备，统称为<strong>外部设备（Peripherals）</strong>。和早期的外部设备交互是非常底层的，程序员需要了解设备的硬件细节，但是程序员又很少能拿到所有型号的设备来测试代码。所以一般是阅读手册然后尽可能编写代码。</p><p>所以为了能够更好地写软件，<em>操作系统就充当软件和硬件之间的媒介</em>。更具体的，操作系统提供API来抽象硬件，叫<strong>设备驱动程序（Device Drivers）</strong>。这样程序员可以通过标准化机制和<strong>输入输出硬件（Input &amp; Output，I/O）</strong>进行交互，而无需关注硬件型号以及具体硬件细节。</p><p>到1950年代末尾，电脑已经运行非常快了，处理器经常需要等待较慢的机械设备（比如打印机和读卡器），程序就阻塞在I/O上，而处理器什么都没有进行处理。英国曼彻斯特大学开始研发世界上第一台超级计算机Atlas，由于机器运算非常快，所以需要一种方式来尽可能利用更多的算力。他们于1962年年设计了一个程序叫Atlas Supervisor，<u>使得操作系统不仅能进行批处理，并且通过<strong>调度（Scheduling）</strong>还能在单个CPU上同时运行几个程序。</u></p><blockquote><p>比如我们需要调用print函数让Atlas打印一个变量值，由于打印机比CPU慢很多，所以print函数需要运行比较长的时间。与其等待打印机完成打印，Atlas会将该程序进行休眠，然后运行其他等待的并且可运行的程序。最终当打印机打印完后，会报告给Atlas，则Atlas会将之前的程序标记为“可运行”状态，然后在某个时刻会安排给CPU继续运行print函数下一行代码。由此，Atlas能够在CPU上运行一个程序，同时另一个程序在打印数据（这里是让打印机自己在打印，所以无需CPU进行参与），同时另一个程序读数据（这里只需要使用读卡器，不需要CPU）。</p></blockquote><p>Atlas配有4台读取器、4台打印机和8个磁带驱动器。使多个程序可以同时运行，在单个CPU上共享时间。操作系统的这种能力称为<strong>多任务处理（Multitasking）</strong>。但是同时运行多个程序存在一个<strong>问题</strong>，每个程序都会占用一些内存，当切换到另一个程序后，我们不能丢失这些内存中的数据。<strong>所以我们给每个程序分配专属内存块</strong>，比如我们计算机一共有10000个内存地址，然后程序A分配到了0-999的内存地址，程序B分配到1000到1999，以此类推。如果一个程序请求更多内存，操作系统就会决定是否同意，如果同意，就要决定分配哪些内存块，这就使得程序A可能会分配到非连续的内存块，使得程序员能难进行跟踪。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-352e87bdb554469c2ed3a5c8a26956bf_hd.jpg" alt="img"></p><center>内存中程序分配</center>**处理分配的内存不连续的情况--动态内存分配**<p>$如果同意，就要决定分配哪些内存块，这就使得程序A可能会分配到非连续的内存块，使得程序员能难进行跟踪。$</p><p>为了隐藏这种复杂性，操作系统会把内存地址进行虚拟化，称为<strong>虚拟内存（Virtual Memory）</strong>。程序可以假定内存总是从地址0开始，而实际的物理位置，被操作系统隐藏和抽象了。以程序B为例，它分配了内存地址1000到1999，但是对于程序B而言，它能看到的地址是0到999，操作系统会自动处理虚拟内存和物理内存之间的映射，所以程序B要地址42，实际需要物理地址1042。对于程序A，它被分配了分散的物理内存块，但是程序A并不知道，它所能看到的是连续的从0到1999的地址，当程序A读内存地址999时，会被映射到物理地址999，而当程序A读内存地址1000，则会被映射到物理地址2000。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-ab782154333eb8168c2a4d3da20a9895_hd.jpg" alt="img"></p><center>虚拟内存例子</center>这种机制使得程序的内存大小可以灵活增减，称为**动态内存分配（Dynamic Memory Allocation）**。对程序而言，内存看起来是连续的，为操作系统同时运行多个程序提供了极大的灵活性，程序员只需要根据连续的虚拟内存地址进行编程，无需考虑程序在实际物理内存中不连续的物理内存块。<p>同时给每个程序分配一个专用的内存块，可以使得隔离起来更方便。如果一个程序出错了，在内存中胡乱写数据，它只能在自己分配的内存块中进行操作，不会影响到其他程序的数据，这个称为<strong>内存保护（Memory Protection）</strong>。这对于防止恶意软件是否有效。Atlas是第一台提供虚拟内存和内存保护功能的操作系统。</p><p>到1970年代，大学会购买电脑给学生使用，此时计算机不仅能同时运行多个程序，还能让多个用户同时访问。多个用户使用<strong>终端（Terminal）</strong>来访问计算机（这里的终端只有键盘和屏幕，然后连接到计算机），终端本身并不具有处理能力。这样计算机不仅要能处理多个程序，还要处理多个用户，为了确保其中一人不会占满计算机资源，开发了<strong>分时操作系统（Time-Sharing）</strong>，指的是每个用户只能用一小部分处理器、内存等，因为计算机很快，所以即使只有一小部分资源，也足以完成很多任务。</p><p>早期分时操作系统中，最有影响力的是1969年发布的Multics，它是第一个从设计时就考虑到安全性的操作系统。开发人员不希望恶意用户访问不该访问的数据，这使得操作系统的复杂度远超当时的平均水平，通常内存的一半都要用来运行操作系统，这种过度设计使得Multics未能获得商业成功。所以研究员们重新打造了一个操作系统Unix，他们想把操作系统分成两部分：</p><blockquote><ol><li>操作系统的核心功能，比如内存管理，多任务和输入输出处理，这个称为<strong>内核（Kernel）</strong>。</li><li>一些有用的工具，但是他们不是内核的一部分，比如程序和运行库。</li></ol></blockquote><p>紧凑的内核意味着功能没有之前那么全面。当内核出现崩溃时，Multics有很多操作来进行恢复，但是Unix是没有办法恢复的，会直接调用一个panic函数，最初只能无限循环打印panic。这种简单性意味着Unix可以再更便宜的硬件上运行。1971年发布之后，就有人写了不同编程语言的编译器，甚至文字处理器，使得Unix迅速成为1970-80年代最流行的操作系统之一。</p><p>到1980年代早期，个人电脑逐渐出现，这些电脑比大型主机简单很多，主机一般在大学、公司和政府，因此操作系统也要变得简单。于1981年微软发布的磁盘操作系统MS-DOS只有160kb，虽然缺少多任务和保护内存这样的功能，意味着程序经常使系统崩溃，用户可以直接重启。即使在1985年发布的早期windos，也一样缺少内存保护功能，当程序错误时，就会出现蓝屏。</p><p>现代的操作系统包含了<strong>多任务</strong>、<strong>虚拟内存</strong>和<strong>内存保护机制</strong>，因此可以同时运行多个程序。</p><h1 id="19、内存-amp-存储介质"><a href="#19、内存-amp-存储介质" class="headerlink" title="19、内存&amp;存储介质"></a>19、内存&amp;存储介质</h1><p>一般来说，电脑<strong>内存</strong>是<strong>非永久性的（Non-Permanent）</strong>，如果电脑关机，则内存中的所有数据都会丢弃，所以内存叫<strong>易失性存储器（Volatile Memory）</strong>，还存在另一种<strong>存储器（Storage）</strong>，存储器（storage）和内存（memory）存在一定的不同。任何写入storage的数据，就会一直保存，直到被覆盖或删除，断点也不会丢失，称为<strong>非易失性（Non-volatile）</strong>。过去是易失性的速度快，非易失性的速度慢，但随着技术发展，两者的差异越来越小。</p><p>最早的存储介质是打孔纸卡以及打孔纸带，到1940年代，纸卡标准是80列x12行，能够存储960位数据。纸卡用了十几年，因为不用电而且便宜耐用，但是读取速度较慢，只能写入一次，对于存临时值，纸卡不好用，我们需要更大更灵活的存储方式。</p><h2 id="延迟线存储器："><a href="#延迟线存储器：" class="headerlink" title="延迟线存储器："></a>延迟线存储器：</h2><p>1944年时，出现了<strong>延迟线存储器（Delay Line Memory）</strong>。<strong>原理</strong>：假设你有一个装满液体（如水银）的管子，管子一端放着扬声器，另一端放着麦克风，当扬声器发出脉冲时，就会在管子内产生压力波，经过一段时间后压力波会传递到麦克风，然后麦克风将压力波转换为电信号，通过在麦克风后面接一个<strong>放大器（AMPLIFIER）</strong>，然后连回扬声器，我们就能用压力波的传播延迟来存储数据。假设有压力波代表1，没有代表0，扬声器发出一系列压力波，因为传播延时的原因，这些压力波会存在管子内，当撞击到麦克风后，又会通过扬声器重新回到管子，所以就能将数据保存在管子内。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200222172929235.png" alt="image-20200222172929235"></p><p>在1949年的EDVAC计算机中使用了延迟线存储器，总共有128条延迟线，每条能存352位，一共能保存45000位。这使得EDVAC成为最早的<strong>存储程序计算机</strong>之一。</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>但延迟线存储器的<strong>缺点</strong>是，每个时刻只能读一位数据，如果想访问一个特定的位，就要等待它从循环中出现，所以又被称为<strong>顺序存储器Sequential Memory）</strong>或者<strong>循环存储器（Cyclic-Access Memory）</strong>。而我们想要<strong>随机存取存储器（Random Access Memory）</strong>，可以随时访问任何位置。并且增加内存密度也是一个挑战，如果要将压力波变得更紧密，就会使其混在一起，所以出现了其他类型的延迟线存储器，比如<strong>磁致伸缩延迟存储器（Magnetostrictive Delay Lines）</strong>，它通过金属线的振动来代表数据。</p><h2 id="磁芯存储器："><a href="#磁芯存储器：" class="headerlink" title="磁芯存储器："></a>磁芯存储器：</h2><p>但是延迟线存储器在1950年代中期就过时了。因为出现了新技术，于是出现了，<strong>磁芯存储器（Magnetic Core Memory）</strong>，它用了环状磁圈，如果给磁芯绕上电线并施加电流，就能将其磁化在一个方向，如果关掉电流，磁芯还会保持磁化，如果施加了相反方向的电流，则磁化方向会翻转。这样我们就能通过磁化方向来存储0和1，就能用来存储1位。通过将磁芯排列成网格状，有线路负责选择行和列，也有电线贯穿每个磁芯，用于读写1位。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-c8e58ebec8d54b77be564e81463cd7de_hd.jpg" alt="img"></p><center>磁芯存储器</center>如果要存的数据超过1bit，就需要把磁芯存储器排列成网格：<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200222173626986.png" alt="image-20200222173626986"></p><p>1953年麻省理工的Whirlwind1计算机第一次大规模使用磁芯内存，磁芯排列使用32x32，用了16块板子，大约能存储16000位。不像延迟线存储器，磁芯存储器能随时访问任何一位，因此从1950年代中期成为主流，流行了20多年，将存储成本从1美元1位降低到了1美分左右。</p><h2 id="磁带："><a href="#磁带：" class="headerlink" title="磁带："></a>磁带：</h2><p>到1951年，UNIVAC电脑推出了一种新存储——<strong>磁带（Magnetic Tape）</strong>。磁带是纤薄柔软的一长条卷在轴上的磁性带子，磁带可以在<strong>磁带驱动器</strong>内前后移动，里面有一个缠绕了电线的<strong>写头（Write Head）</strong>，通过电流来产生磁场，导致磁带的一小部分被磁化，电流方向决定了极性，代表1和0。同样还有一个读头（Read Head），可以非破坏地检测极性来确定数据。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-1d9ac11988c8c3e7e54dc2c032bc21a4_hd.jpg" alt="img"></p><h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><p>磁带的主要缺点是访问速度，磁带是连续的，必须倒带或快进到特定位置。</p><p>50 60年代出现了类似的技术<strong>磁鼓存储器（Magnetic Drum Memory）</strong>,有一个金属圆管，盖满了磁性材料来记录数据，圆管会持续旋转，周围有数十个读写头，等圆管转到了正确的位置，读写头就会读或写数据。</p><p>但到了1970年代磁鼓存储器就不再生产了，但是磁鼓导致了<strong>硬盘（Hard Disk Drives）</strong>的发展，磁盘的好处是薄，可以叠在一起来提供更多表面积来存储数据。要访问某个特定位，一个读写磁头会上下移动，找到正确的磁盘，然后磁头会滑进去，就和磁鼓存储器一样，磁盘也会高速旋转，所以读写头要等到正确的部分旋转过来，这个称为<strong>寻道时间（Seek Time）</strong>。</p><p>以下是<strong>内存层次结构（Memory Hierarchy）</strong>，有一小部分高速且昂贵的内存，一部分稍慢且相对便宜的内存，还有更慢且更便宜的内存，这种混合可以在成本和速度之间取得平衡。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200222174311987.png" alt="image-20200222174311987"></p><p>其次还有<strong>软盘（Floppy Disk）</strong>，除了磁盘是软的，其他都一样。</p><p>后面出现的<strong>光盘（Compact Disk，CD）</strong>以及DVD，它们不使用磁性来保存数据，而是使用表面的小坑来造成光的不同反射，通过光学传感器捕获并解码为1和0。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200222174429795.png" alt="image-20200222174429795"></p><center>光盘表面</center>如今成本下降了更多的存储技术在朝**固态（Solid State）**前进，**机械硬盘（hard disk drive，HDD）**被**固态硬盘（Solid State Drive，SSD）**逐渐代替。由于SSD没有机械活动部件，里面都是集成电路。因为不存在机械活动，所以磁头不用等磁盘旋转，所以固态速度快很多，但是仍然比RAM慢很多，<u>所以现代计算机仍然使用存储层次结构</u>。<h1 id="20、文件系统"><a href="#20、文件系统" class="headerlink" title="20、文件系统"></a>20、文件系统</h1><p>上一节中介绍的数据存储。存储器可以在断电状态下长时间存上万亿位，所以非常适合用来存一整块有关系的<u>数据</u>（或者称为<strong>文件（Files）</strong>），比如文本文件、音乐文件、照片和视频。这一节将讨论文件是什么以及计算机是怎么管理文件的。</p><p>随意排列文件的数据是没有问题的，但按格式排列会更好，这个称为<strong>文件格式（File Format）</strong>。</p><p>首先看一个最简单的文件格式——<strong>文本文件（Txt File，txt）</strong>。就像其他文件一样，文本文件只是一长串二进制数，可以通过ASCII编码将其解码成对应文本。</p><h2 id="波形文件："><a href="#波形文件：" class="headerlink" title="波形文件："></a>波形文件：</h2><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200223201711965.png" alt="image-20200223201711965"></p><center>波形文件（WAV）</center>**波形文件（Wave File，WAV）**用于存音频数据。在正确读取数据之前，我们需要知道一些信息比如码率，以及是单声道还是立体声，这种描述数据的数据称为**元数据（Meta Data）**。元数据保存在文件开头，在实际数据之前，因此也叫**文件头（Header）**。以下是WAV文件的前44个字节，有些部分会根据数据进行变化。<p>[^元数据]: <strong>元数据</strong>（<strong>Metadata</strong>），又称<strong>中介数据</strong>、<strong>中继数据</strong>，为描述<a href="https://baike.baidu.com/item/数据/5947370" target="_blank" rel="noopener">数据</a>的数据（data about data），主要是描述数据<a href="https://baike.baidu.com/item/属性/1405051" target="_blank" rel="noopener">属性</a>（property）的<a href="https://baike.baidu.com/item/信息/111163" target="_blank" rel="noopener">信息</a>，用来支持如指示存储位置、<a href="https://baike.baidu.com/item/历史/360" target="_blank" rel="noopener">历史</a>数据、<a href="https://baike.baidu.com/item/资源/9089683" target="_blank" rel="noopener">资源</a>查找、文件记录等功能。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200223201307602.png" alt="image-20200223201307602"></p><center>WAV格式的数据的元数据</center>而音频数据就紧跟在元数据之后，也是一长串二进制数，这些数字代表每秒捕获多次的声音幅度。麦克风首先会对声音进行每秒上千次采样，每次采样可以用一个数字表示，声压越高数字越大，称为**振幅(Amplitude)**，这就是WAV文件中存储的数据。播放声音时，扬声器就会产生相同的波形。<h2 id="位图-Bitmap"><a href="#位图-Bitmap" class="headerlink" title="位图(Bitmap)"></a>位图(Bitmap)</h2><p>再来谈谈<strong>位图</strong>，其后缀为bmp，用于保存图片。。计算机中，图片由多个<strong>像素(Pixel)</strong>方块组成，每个像素由三种颜色组成：红、绿、蓝，叫<strong>“加色三原色”</strong>，混合在一起能产生其他颜色。类似于WAV文件，BMP文件开头也是元数据，有图片宽度、图片高度和颜色深度等等。现在假设图片宽高均为4个像素，颜色深度为24，也就是8位(bit)红色、8位绿色和9位蓝色，则每个颜色有0-255程度，然后依次保存每个位置的三原色数值。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200223202632500.png" alt="image-20200223202632500"></p><center>位图的元数据</center>![image-20200223203327886](https://longlongqin.gitee.io/image_save/images/assets/image-20200223203327886.png)<center>位图的数据</center>通过以上例子，可以知道，文件底层都是二进制数，为了知道文件是什么，文件格式就十分重要。<h2 id="计算机如何存储文件："><a href="#计算机如何存储文件：" class="headerlink" title="计算机如何存储文件："></a>计算机如何存储文件：</h2><p>最简单存储多个文件的方法是将文件<strong>连续存储</strong>，但是这样怎么知道文件开头和结尾在哪呢？存储器并没有文件的概念，它只是用来存储大量二进制数。所以我们需要特殊文件来记录其他文件的位置，这里称为<strong>目录文件（Directory File）</strong>，它通常保存在存储器最开头，方便寻找。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-46682a86deaa95c83bba62ae802f8120_hd.png" alt="img"></p><center>storage</center>在目录文件中，存有其它所有文件的名字，格式为`文件名+点+扩展名`， 扩展名有助于得知文件类型。目录文件还保存了文件的元数据，比如创建时间、最后修改时间、文件所有者、是否能读写，最重要的是记录了文件起始位置和长度。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200223203721221.png" alt="image-20200223203721221"></p><center>目录文件</center>如果要添加、删除文件或者更改文件名，必须更新整个目录文件。<p>目录文件以及对目录文件的管理，是最基本的<strong>文件系统（File System）</strong>的例子，文件系统专门负责管理文件。刚刚的例子叫<strong>平面文件系统（Flat File System）</strong>，因为所有文件都在同一层次。存在一个<strong>缺点</strong>：当我们想要对中间文件增加数据时，就会覆盖后续文件的数据。所以现代文件系统会做两个处理：</p><ol><li>将空间划分成一块块，会出现一些<strong>预留空间（Slack Space）</strong>，可以方便改动。同时文件数据都对齐到了相同大小，可以方便管理。使用这种方案，目录文件就要记录文件在哪些块中。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200223204243036.png" alt="image-20200223204243036"></p><ol start="2"><li>拆分文件保存在多个块中。假设todo.txt文件中加了一些数据，使得文件太大无法存在一个块中，则文件系统会分配一个没使用的块来容纳额外的数据，<u>则目录文件对每个文件就会记录不止一个块，而是多个块</u>。通过分配块，文件就可以轻松增加减小。如果想要删除carrie.bmp，只要在目录文件中删除对应记录就行，让这一块空间变成可用的，这样就不需要进行擦除，只需要直接删除记录就行。<strong>在那一块被新数据覆盖之前，数据还是保存在原处的。所以恢复删除数据是有可能的。</strong></li></ol><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200223204550449.png" alt="image-20200223204550449"></p><p>当文件过大，保存在若干个块中，这个称为<strong>碎片（Fragmentation）</strong>，碎片是增删改文件导致的，无法避免，但是会造成性能下降。解决方法是通过<strong>碎片整理（Defragmentation）</strong>，计算机会将数据来回一定，排列成正确的顺序，就能很方便地进行读写。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200223204701481.png" alt="image-20200223204701481"></p><center>碎片整理前</center>![image-20200223204733889](https://longlongqin.gitee.io/image_save/images/assets/image-20200223204733889.png)<center>碎片整理后</center>随着容量爆炸式增长，文件数量飞速增加，平面文件系统逐渐应付不来，所以出现了**分层文件系统（Hirerarchical File System）**，这里最大的变化就是每个文件夹中都有一个目录文件，并且目录文件不仅要指向文件，还要指向目录，还需要增加额外的元数据来区分文件和目录。<p><strong>优点</strong>：这种文件系统不仅可以做出无限深的文件夹，也可以让我们很轻松地移动文件，我们不需要移动任何数据块，只需要在两个目录文件中删增记录就行。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200223204831349.png" alt="image-20200223204831349"></p><center>分层文件</center>文件系统使我们不必关心文件在磁盘中的具体位置。<h1 id="21、压缩"><a href="#21、压缩" class="headerlink" title="21、压缩"></a>21、压缩</h1><p>之前介绍了文件格式，如何编码文字、声音和图片，但是它们的效率并不高，我们希望文件能小一点，这样就能保存大量文件，同时传输也会快一些，解决方法就是<strong>压缩（Compression）</strong>，把数据占用的空间压得更小，为此我们需要用更少的bit来表示数据。</p><p>以压缩图片为例，图片一般存成一长串像素值，为了知道一行在哪里结束，图像要有元数据，写明尺寸等属性。每个像素的颜色是三原色的组合，每个颜色用一个字节保存，数字范围是0~255（一个字节=8 bits，2^8^=256），由此一张<code>4*4</code>（16个像素）大小的图像，其中每个像素3个字节。则这个图片需要<code>4*4*3=</code>48字节。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200226140325517.png" alt="image-20200226140325517"></p><p>—》存成一长串像素值：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200226151330368.png" alt="image-20200226151330368"></p><center>图片一般存成一长串像素值</center>![img](https://longlongqin.gitee.io/image_save/images/assets/v2-202fff7eae740ec4451258a92c96eda0_720w.jpg)<center>前五个像素的表示</center>## 无损压缩：<p>一种压缩方法是减少重复信息，最简单的方法叫<strong>游程编码（Run-Length Encoding）</strong>，适合经常出现相同值的文件。比如上图中有7个连续相同的黄色像素块，我们可以插入一个额外字节来表示7个连续黄色像素，然后删掉后面重复的数据。为了让计算机分辨哪些字节时长度，那些字节是颜色，格式需要保持一致，所以我们需要给所有像素前面都标上长度。在这个例子中现在只需要24个字节，并且不损失任何信息。这个方法称为<strong>无损压缩（Lossless Compression）</strong>，没有丢失任何数据。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-315b1a99dd4902cb5d8a9c9d7a81cde1_720w.png" alt="img"></p><center>游程编码</center>另一种无损压缩方法叫做**DFTBA**，它用更紧凑的方式来表示数据块。首先我们需要一个字典，来保存代码和数据之间的对应关系。我们可以将图像看成一块一块，而不是一个个像素，为了简单，我们将2个像素当成一个块，由此我们可以得到下图的4个像素对，我们会对些像素对生成**紧凑代码（Compact Codes）**。这些块出现频率不同，我们通过霍夫曼树的方法对每一种情况进行编码，使得频率最高的块代码最短。然后我们就能通过code代替块来对图像进行压缩。这个例子中将48字节的数据压缩成了14位，但是同样也要把字典保存下来，所以还需要将字典加到数据前面，所以总共有30字节。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-e40dfa25fd9f55ddb49ac3c558b2415f_720w.jpg" alt="img"></p><center>使用霍夫曼树生成的块的编码</center>![img](https://longlongqin.gitee.io/image_save/images/assets/v2-557e83d3f9b5d120457fb8fe3fc9df87_720w.png)<center>压缩结果</center>![img](https://longlongqin.gitee.io/image_save/images/assets/v2-e688a0f2a014255ed2e3c9ba38855ed5_720w.png)<center>加上字典后的压缩结果</center>## 有损压缩：<p>“消除冗余”和“使用更紧凑表示方法”通常会组合起来一起使用，几乎所有无损压缩格式都用到它们。</p><p>无损压缩对于文本数据十分重要，但是有其他一些数据即使丢失了一部分也不会造成很大影响，通常会丢失人们无法注意到的信息，大部分<strong>有损压缩技术（Lossy Compression）</strong>都用到了这点。</p><p>以声音为例，人类听力并不是完美的，有些频率我们可以捕获，但是类似于超声波这类的频率我们根本听不见，所以录制音乐时，超声波数据是可以丢弃的，其次人类对人声十分敏感，所以应该尽可能保持原样。<strong>有损音频压缩（Lossy Audio Compressors）</strong>通过不同精度编码不同频段，这样人类听不出什么区别，也不会明显影响体验。比如电话中也用到了这个技术，这就使得在电话中的声音和现实中有所差别，用过这个技术才使得更多人同时打电话。如果网速变慢，压缩算法就会删掉更多的数据。压缩音频文件MP3和没压缩音频文件WAV或FLAC大小可以相差10倍。</p><p>这种删除人类无法感知的数据的方法称为<strong>感知编码（Perceptual Coding）</strong>。这也是各种有损压缩图像格式的基础，比如JPEG，人类的视觉系统也不是完美的，我们比较善于看到尖锐的对比，比如物体的边缘，但我们无法看出颜色的细微变化。JPEG由此将图像分解成8x8大小的像素块，然后删掉大量高频空间数据。比如以下这张图片，其中一个8x8像素，由于每个像素都有细微差异，所以无损压缩技术很难对其压缩，但是人眼很难看出这些细微差别，所以我们可以删除很多像素值，这样只占10%的原始数据，并且图像看起来没有什么区别。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-0dcede4590c5d2552a8fe9e4d5a45c95_720w.jpg" alt="img"></p><center>原图；8x8原始像素块；8x8压缩像素块；压缩图像</center>视频只是一长串连续图片，所以图片的很多方面也适用于视频，但视频也可以做一些小技巧，因为帧与帧之间有很多相同的像素，称为**时间冗余（Temporal Redundancy）**。我们不需每一帧都保存这些像素，可以只保存变化了的部分。更高级的视频压缩格式会更进一步，他们找出帧和帧之间相似的补丁，然后对他们应用简单变换，比如移动、旋转、变亮和变暗，这样就不用重复保存这些相似的补丁，直接对其进行变换就行。MPEG-4视频是常见的标准，可以比原文件小20倍到200倍。但是当压缩太严重时，没有足够空间更新补丁内的像素，就会出现以下问题。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-759970de261a610b53e2e652fc6f572c_720w.jpg" alt="img"></p><center>过度压缩造成的错误</center># 23、屏幕&2D图像显示<p>早期的文本任务通过打印机显示，因为屏幕分辨率较低，无法显示清晰的文字，而将计算结果的文字打印在纸上，有更高的对比度和分辨率，屏幕一般只用于跟踪程序的运行情况，比如寄存器的值，可以节约纸，并且屏幕更新很快，对临时值很匹配。</p><p>最早最有影响力的是<strong>阴极射线管（Cathode Ray Tube，CRT）</strong>，原理是将电子发射到有磷光体涂层的屏幕上，当电子撞击涂层时，会发光几分之一秒。并且因为电子是带电粒子，所以路径可以通过磁场进行控制。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-739424da713eed4b346efb1dc7543358_720w.jpg" alt="img"></p><center>CRT</center>这样就有两种方法来绘制图形：<ol><li>引导电子束描绘出形状，称为<strong>矢量扫描（Vector Scanning）</strong>。因为发光只持续一小会儿，如果重复速度足够快，就能得到清晰的图像。</li><li>第二种方法是按照固定路径，一行行从上到下、从左到右不断重复，只在特定的点打开电子束来绘制图形。这种方法称为<strong>光栅扫描（Raster Scanning）</strong>。用这种方法可以用很多小线段绘制图形，甚至文字。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-ec5217cfd4e2ebb1de1126112a830c20_720w.jpg" alt="img"></p><center>矢量扫描和光栅扫描</center>随着屏幕的发展，我们终于可以在屏幕上显示清晰的点，称为**像素（Pixel）**。**液晶显示器（Liquid Crystal Display，LCD）**也使用光栅扫描，每秒更新多次像素里红绿蓝的颜色。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-818d25d7f9bfa6d121e602a746837223_720w.jpg" alt="img"></p><center>LCD</center>但是早期计算机不使用像素，因为内存中需要保存像素对应的值，使其占用太多内存，所以需要一些特殊技巧来渲染图形，知道内存发展到足够用的地步。<p>所以早期计算机不保存大量像素值，而是直接保存符号，其中80x25个符号是最经典的，若干每个字符用8个字节表示，一共也才16000位。为此，需要特殊的硬件来从内存读取字符，转换成光栅图形，这样才能显示到屏幕上，这个称为<strong>字符生成器（Character Generator）</strong>，基本算是第一代显卡。</p><p>显卡内部有一小块<strong>只读存储器（Read Only Memory，ROM）</strong>存着每个字符的图形，称为<strong>点阵图案（Dot Matrix Patter）</strong>。如果显卡看到某个字符对应的二进制代码，它就会把该字符的点阵图案通过光栅扫描的方式显示在屏幕的适当位置。为了显示，字符生成器会访问内存中一块特殊区域，这块区域专为图形保留，称为<strong>屏幕缓冲区（Screen Buffer）</strong>，程序想显示文字时，就直接修改保存在这个区域的值就行。字符生成器这种方案用的内存很少，但只能画字符到屏幕上，无法绘制任意形状。</p><p>传统的ASCII编码的字符集太小，做不了很复杂的事情，因此对ASCII进行扩展增加更多的新字符，比如用于DOS的IBM CP437字符集，有些系统还会用额外的bit来定义字体颜色和背景颜色。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-9d82eef96cc809355690e396d46873bf_720w.jpg" alt="img"></p><center>IBM CP437字符集</center>为了绘制任意形状，同时不会占用太多内存，就要使用CRT上的**矢量模式**。所有东西都是由一系列线条组成的，完全不需要有文本的概念，如果要显示文字，直接用画线的形式进行显示。我们使用一个早期适量显示系统Vectrex的命令为例<ol><li>首先使用RESET命令来清空屏幕， 同时将电子枪的绘图点移动到坐标(0,0)，也就是屏幕左上角，并将线的亮度设为0。</li><li>调用MOVE_TO 50 50，就会将绘图点移动到坐标(50,50)。然后使用INTENSITY 100将强度设为100， 然后反复调用以上命令就会绘制出对应图形。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-4820ddaa8ce054742f05ea0afbbabab9_720w.jpg" alt="img"></p><p>这些命令也就占160位，比直接保存一个像素矩阵好很多。</p><p>类似于之前的字符生成器把内存里的字符转换成图形一样，这些矢量指令也保存在内存中，通过<strong>矢量图形卡（Vector Graphics Card）</strong>画在屏幕上。然后通过数百个命令按序保存在屏幕缓冲区中，就能绘制出十分复杂的图形。并且因为这些矢量都在内存中，程序就可以更新这些值，让图形随时间进行变化，就出现了动画。</p><p>1962年诞生的Sketchpad是一个巨大的里程碑，它是一个交互式图形界面，用于计算机辅助设计（CAD），它被认为是第一个完整的图形程序。为了与图形界面进行交互，Sketchpad使用了输入设备——<strong>光笔</strong>，就是一个有线连着电脑的触控笔，笔尖用光线传感器，可以检测到显示器的刷新，并且通过判断刷新时间，电脑也可以知道笔所在的位置。使用光笔和各种按钮，用户可以画线和其他各种简单图案。</p><p><u>最早真正使用像素的计算机和显示器出</u>现于1960年代末。内存中的位对应屏幕上的像素，称为<strong>位图显示（Bitmapped Display）</strong>，通过对像素的控制，我们能够完全绘制任意的图形。可以将图形想象成是一个巨大像素值矩阵，之前计算机将像素数据保存在内存中一个特殊区域，称为<strong>帧缓冲区（Frame Buffer）</strong>，但是后来保存在特殊的高速<strong>视频内存（Video RAM，VRAM）</strong>中，这个VRAM是在显卡上，这样访问速度更快。</p><p>在一个分辨率是60x35的8位灰度屏幕上，我们可用的颜色范围是0到255。如果我们想把(10,10)处的像素设为白色，可以使用frambuffer [10] [10]=255， 如果我们想要从(30,0)到(30,35)画一条直线，可以使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FOR y&#x3D;0 TO 35</span><br><span class="line">    framebuffer[30][y]&#x3D;255</span><br><span class="line">NEXT</span><br></pre></td></tr></table></figure><p>使用相同方法，通过修改像素值就可以绘制任意图像。并且程序可以操纵帧缓冲区内的像素数据，来实现交互式图形。</p><h1 id="28、计算机网络"><a href="#28、计算机网络" class="headerlink" title="28、计算机网络"></a>28、计算机网络</h1><p>第一个计算机网络出现在1950-1960年代，通常在公司或研究室内部使用，方便信息交换，称为<strong>球鞋网络（Sneakernet）</strong>，第二个好处在于共享物理资源，比如，与其每台电脑配一台打印机，不如大家共享一台联网的打印机。并且早期网络也会共享存储空间，因为为每台计算机都配存储器太过昂贵。</p><p>计算机近距离构成的小型网络称为<strong>局域网（Local Area Network，LAN）</strong>，局域网能小到是同一间房间内的两台计算机，或者大到校园内的上千台电脑。</p><p>尽管开发和部署了很多不同的LAN技术，其中最著名的是<strong>“以太网（Ethernet）”</strong>，以太网的最简单形式是：一条以太网电线连接数台计算机，当一台计算机要传数据给另一台计算机时它以<strong>电信号</strong>形式，将数据传入电缆中，由于电缆是共享的，所以连接在同一个网络里的其他计算机都能看到数据，但是所有计算机都不知道这些数据是给自己的还是给别人的。<u>为了解决这个问题</u>，以太网需要每台计算机有唯一的<strong>媒体访问控制地址（Media Access Control Address，MAC Address）</strong>，然后将MAC地址作为数据的前缀发送到网络中，所以计算机只需要监听以太网电缆，只要看到自己的MAC地址，才去接收处理数据。现在制造的每台计算机都自带唯一的MAC地址，用于以太网和无线网络。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://pic4.zhimg.com/80/v2-bd0dfa011a483016ac431b355610fefb_720w.jpg" alt="img"></p><center>以太网</center>但是共享载体有个很大的**弊端**：当网络流量比较小时，计算机可以等待载体清空，然后再传输他们的数据。但随着网络流量上升，两台计算机想同时写入数据的概率也会上升，这称为**冲突（Collision）**，就会使得传输的数据混乱。幸好计算机能够监听电线里的信号来检测冲突，最简单的解决方案就是看到冲突就停止传输，等待网络空闲后再试一次，问题是其他计算机也是这样打算的，其他等待的计算机可能在任何停顿间隙就闯入开始传输数据，这就导致了越来越多的冲突。<p>以太网的<strong>解决方法</strong>是：当计算机检测到冲突后，就会在重传之前等待一小段时间（因为要举例，假设是 1 秒好了），当然 如果所有计算机用同样的等待时间 是不行的，它们会在一秒后再次冲突。所以加入一个随机时间 一台计算机可能等1.3秒，另一台计算机等待1.5秒 。要是运气好 等1.3秒的计算机会醒来发现载体是空闲的 然后开始传输 ，当1.5秒的计算机醒来后 会发现载体被占用会等待其他计算机完成 ，来相互避开。当然这个并不能完全解决问题，还需要用到<strong>另一个技巧</strong>。如果一台计算机在传输数据期间检测到冲突，就等待“1秒+随机时间”，但是如果再次发生冲突，就表明有网络拥塞，这次不等1秒，而是等2秒 ，如果再次发生冲突 等4秒 然后8秒 16秒等等，直到成功传输。因为计算机的退避，冲突次数会大幅减少，使得数据能够再次流动起来，网络就变得顺畅了。<u>这种指数级增加等待时间的方法</u>称为<strong>指数退避（Exponential Backoff）</strong>，很多以太网和WiFi都用到这个技术。</p><p>但是即使有了以上的技术，想用一根网线连接整个大学的计算机还是不可能的，为了减少冲突同时提高效率，我们<u>需要减少同一载体中设备的数量</u>，载体和其中的设备总称为<strong>冲突域（Collision Domain）</strong>。以之前以太网为例，一根电缆连接了6台计算机，这个称为一个冲突域。为了减少冲突，我们可以用<strong>交换机（Switch）</strong>将它拆成两个冲突域。交换机位于两个更小的网络之间，在必要时才在两个网络之间传输数据，并且交换机会记录一个<strong>列表</strong>，写着哪个MAC地址位于哪边网络，所以当MAC A想要传数据给MAC C，交换机就不会将数据传到另一边的网络，同理如果MAC E传输数据给MAC F，交换机也不会将数据传到上面的网络，这使得两边的传输能同时进行。但是如果MAC F想传数据给A，数据就会通过交换机，使得两个网络都会被短暂占用。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/v2-059e0333f1ad801bb826f3f89afeb0a7_720w.jpg" alt="img"></p><center>一个以太网中加入一个交换机</center>即使最大型的网络——**互联网（Internet）**也是这样构建起来的，本质还是多个连在一起的稍小一点的网络，使得不同网络间可以传递数据。而大型网络有一个特点，从一台主机到另一台主机通常有多条线路（**解决的主要问题**），这就引出了另一个话题——**路由（Routing）（用来选择合适路线的方法）**。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/v2-618cd9d33b6ca884945143c2d8e3810e_720w.jpg" alt="img"></p><center>大型网络，两台主机之间存在多条线路</center>连接两台相隔遥远的计算机或网络，最简单的方法是分配一条专门的<u>通信线路</u>，早期的电话系统就是这样运作的，这种方法称为**电路交换（Circuit Switching）**，因为是对整个电路进行修改，来连接到正确目的地，所以这种方法不灵活且价格昂贵，并且总有闲置的路线。但是好处是你可以最大限度随意使用，无需共享。因此军队、银行和其他一些机构依然会购买专门线路来连接数据中心。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229164213580.png" alt="image-20200229164213580"></p><center>电路交换</center>传输数据的另一种方法是**报文交换（Message Switching）**，就像邮政系统一样。不像之前A和B之间有一条专有线路，这里消息会经过好几个站点，就类似于邮寄信封，信封会通过一个个中转站最终到达收件人手中，每个站点都知道下一站要发往哪里，因为站点都有自己一个**表格**，用来记录到达各个目的地，信件要如何传递。报文交换的**好处**是你可以用不同的路由，使得通信更可靠。比如如果其中一个城市由于降雪无法接收邮件时，就能换到另一个城市继续传递数据。这里，城市就相当于网络中的路由器一样。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229163941432.png" alt="image-20200229163941432"></p><center>报文交换</center>> 交换机是连接若干个主机的机器，用来解决冲突域问题。 > > 路由器是连接主机、路由器、交换机的机器，用来构建数据传输的线路。<p>信息沿着路由跳转的次数称为<strong>跳数（Hop Count）</strong>，通过记录跳数，可以分辨出路由问题。比如当路由A认为到达目的地最快的下一个路由是B，就将信息传递给路由B，而路由B则认为到达目的地最快的下一个路由是A，又将信息传递回给了路由A，这就使得信息在路由A和B之间踢皮球，但是这种错误可以通过在信息中实时记录的跳数来解决，如果某条信息的跳数很大，就说明路由有出问题，这个称为<strong>跳数限制（Hop Limit）</strong>。</p><p>而报文交换的<strong>缺点</strong>之一就是当报文较大时，会堵塞网络，因为这里要求将<u>整个报文</u>从一个路由传到下一个路由后，才能继续传递其他报文，当传输大报文时，其他报文要么等待它传递完，要么选择另一条效率较低的路线。<u><strong>解决</strong></u>方法就是将大报文分成很多小块，称为<strong>数据包（Packet）</strong>。和报文交换一样，每个数据包都有网络中的目的地址，因此路由器知道要发送到哪里，这个地址的具体格式由<strong>互联网协议（Internet Protocol，IP）</strong>定义。每个联网的计算机都需要一个<strong>IP地址（IP Address）</strong>，例如<code>172.217.7.238</code>。</p><blockquote><p>MAC地址用来标识每条计算机，而IP地址是对数据包而言的。</p></blockquote><p>路由器会平衡与其他路由器之间的负载，来确保传输可以快速可靠，称为<strong>拥塞控制 （Congestion Control）</strong>。有时候一个报文的多个数据包会经过不同线路，使得到达顺序也可能不相同，这对一些软件来说是存在问题的。幸运的是，在IP之上还有其他协议，<u>比如TCP/IP可以解决乱序问题</u>。</p><p>将数据拆分成多个小数据包，然后通过灵活的路由传递，非常高效且容错率高，这种方法称为<strong>分组交换（Packet Switching）</strong>。它的好处是可以去中心化，就没有单点失败问题。</p><p>如今全球的路由器协同工作，找出最高效的线路，用各种标准协议传输数据，比如<strong>因特网控制信息协议（Internet Control Message Protocol，ICMP）</strong>和<strong>边界网关协议（Border Gateway Protocol，BGP）</strong>。</p><p>网络是一堆管子组成的吗？ 额 算是吧。</p><h1 id="29、互联网"><a href="#29、互联网" class="headerlink" title="29、互联网"></a>29、互联网</h1><p>任意计算机都和一个巨大的分布式网络连接在一起，称为<strong>互联网（Internet）</strong>。</p><p>当你在家中通过计算机观看网上视频时，你的计算机首先需要连接到<strong>局域网LAN</strong>，这个局域网是由家里WiFi路由器连接的所有设备组成的。然后家里的局域网再通过路由器连接到<strong>广域网（Wide Area Network，WAN</strong>），广域网的路由器一般属于你的<strong>互联网服务提供商（Internet Service Provider，ISP）</strong>。在广域网里，首先会有一个区域性路由器，比如覆盖你所在街区的一个路由器，然后该路由器会连接到一个更大的广域网中，比如覆盖你所在的城市，可能再跳跃几次，最终会到达互联网主干，一般由一群超大型、带宽超高的路由器组成。</p><blockquote><p>即首先会连接到你家里的WiFi路由器构建的局域网，然后该路由器再连接到ISP提供的广域网中，该广域网是由很多层层递进的路由器构成的。</p></blockquote><p>比如要从YouTube中获得视频，数据包首先会到达互联网主干，沿着主干到达对应保存该视频文件的YouTube服务器，可能这里会跳4次到达互联网主干，然后跳两次穿过互联网主干，最终再跳4次到达YouTube服务器，所以总共会跳跃10次。</p><p>我们可以通过<code>traceroute</code>来看跳跃了几次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Windows上的Traceroute</span><br><span class="line">1.按开始按钮</span><br><span class="line">2.输入“ CMD”，然后按“ Enter”</span><br><span class="line">3.在命令提示符下，键入“ tracert dftba.com”</span><br><span class="line"></span><br><span class="line">在Mac上的Traceroute</span><br><span class="line">1.点击“转到”下拉菜单</span><br><span class="line">2.点击“实用程序”</span><br><span class="line">3.打开终端</span><br><span class="line">4.键入“ traceroute dftba.com”</span><br><span class="line"></span><br><span class="line">Linux上的Traceroute</span><br><span class="line">1.通过键入CTRL + Alt + T打开终端</span><br><span class="line">2.输入：“ traceroute dftba.com”</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229165556176.png" alt="image-20200229165556176"></p><center>通过traceroute查看到dftba.com中转的次数</center>经历了11次中转。<p>但是数据包到底是怎么传递过去的呢？如果传输时数据包丢失了，会发生什么？当我们在浏览器中输入网址时，浏览器怎么知道服务器的地址是什么呢？</p><p>就像上节介绍的，互联网是一个巨大分布式网络，如果要发送的数据较大，分组传输就会将数据拆成一个个较小的数据包进行传输。其中数据包要想在互联网上进行传输，就要符合<strong>互联网协议（Internet Protocol，IP）</strong>。类似于邮寄手写信一般，每封信都需要一个地址，并且地址必须是唯一的，并且信的大小和重量也是有限制的，否则信件就无法送达。IP数据包也是如此，因为IP是一个非常底层的协议，数据包的头部只包含目标地址（IP地址），意味着当数据包到达对方电脑时，计算机不知道要把数据包交给哪个程序（比如QQ或微信），因此需要在IP之上，开发更高级的协议。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229170514722.png" alt="image-20200229170514722"></p><center>数据包的结构</center>最简单常见的协议称为用户数据报协议（User Datagram Protocol，UDP）。UDP也有头部，位于data payload里面，在data之前。UDP头部里面包含了很多有用的信息，其中之一就是**端口号（Port Number）**，每个想访问网络的程序都要向操作系统申请一个端口号。所以当数据包到达时，接收方的操作系统会读取UDP头部里的端口号，来确定该数据包是要交给哪个软件的。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229170831643.png" alt="image-20200229170831643"></p><center>UDP</center>比如 Skype 会申请端口 3478，当一个数据包到达时接收方的操作系统会读 UDP 头部，读里面的端口号如果看到端口号是 3478，就把数据包交给 Skype。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229171417934.png" alt="image-20200229171417934"></p><center>端口号</center>![image-20200229170954885](assets/image-20200229170954885.png)<blockquote><p>IP协议通过IP地址把数据包送到正确的计算机内；UDP通过数据包里的端口号送到正确的程序。</p></blockquote><p>同时UDP的头部中还有<strong>校验和（Checksum）</strong>，通过对数据求和来检查数据是否正确。假设UDP数据包里原始数据是<code>89 111 33 32 58 41</code>， 最简单的计算校验和的方式就是，在发送数据包之前，计算机会把所有数据加在一起，计算出校验和364。在UDP中，校验和是以16位形式存储的，如果计算出来的和超过16位能表示的最大值，则高位数会被丢弃，只保留低位。当接收方计算机接收到这个数据包时，也会重复以上过程，如果计算出来的校验和和UDP中保存的校验和相同，代表数据是正常的，否则数据是出错的。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/v2-9211cf69881af0f8ba2e4a8e8b5ce8ee_720w.jpg" alt="img"></p><p>但是，UDP不提供数据修复或数据重发机制，当接收方知道数据损坏后，一般只是丢弃这个数据包。并且当发送方使用UDP协议发送数据包时，是无法得知数据包是否到达目的地的。有些程序并不在意以上问题，因为UDP十分简单且快速。比如<u>视频</u>通常使用UDP协议，当数据包丢失时，也就造成视频卡顿。</p><p>但是有些数据不能接受数据包丢失的问题，比如发送电子邮件时，所有数据必须到达，所以就需要<strong>传输控制协议（Transmission Control Protocol，TCP）</strong>。和UDP一样，它的头部也保存在数据之前，人们通常将<u>IP协议和TCP协议</u>统称为<strong>TCP/IP协议</strong>。TCP的头部中也包含端口号和校验和，并且TCP协议还提供更高级的功能：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/v2-969988861bec7064179dd4e99b60dbf8_720w.png" alt="img"></p><center>TCP</center>1. TCP的数据包是<u>有序号</u>的，使得接收方可以通过这个序号将数据包排成正确顺序，即使到达时间不同。 2. TCP要求接收方的电脑收到数据包并校验和检查无误后，需要给发送方发送一个**确认码（Acknowledgement，ACK）**，代表数据包已经正确接收。当发送方接收到确认码后，就知道上一个数据包成功抵达了，发送方就会发送下一个数据包，如果这次发送方过了一段时间没有接收到确认码，则会重新发送一次。即使这里只是由于确认码延迟了，使得接收方那里有重复的数据包，但是通过序列号，可以直接删除重复的数据包。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229171954069.png" alt="image-20200229171954069"></p><p>并且数据包并不会一个个数据包进行传输，而是<strong>同时发送多个数据包</strong>，同时接收多个<strong>确认码(ACK)</strong>，这将大大提高效率，不用浪费时间等待确认码。并且通过确认码的成功率和来回时间，我们可以推测网络的拥塞程度，TCP通过这个信息，来调整同时发包数量来解决拥塞问题。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/v2-061760eadb27bb199a2a917547852efc_720w.jpg" alt="img"></p><p>简而言之，TCP可以处理乱序和丢包问题，并且可以根据拥塞情况自动调整传输率。</p><p>但是由于确认码数据包的存在，使得TCP需要传输的数据包数量翻了一倍，并且并没有传输更多信息，这对时间要求很高的程序代价太高，所以这类程序就会使用UDP协议（比如射击类游戏）。</p><p>当计算机访问一个网站时，需要两个东西<code>：IP地址（目标网站的地址）</code>和 <code>端口号（对应于你使用的计算机浏览器）</code>（例如：例如 <code>172.217.7.238 的 80 端口</code> 这是谷歌的 IP 地址和端口号）。但是通过IP地址访问网站十分不方便，所以互联网提供一个特殊服务，来将<strong>域名（Domain Name）</strong>和IP地址一一对应，称为<strong>域名系统（Dimain Name System，DNS）</strong>，一般DNS服务器都是由ISP提供的。当你在浏览器中输入网站域名时，浏览器就会去访问DNS服务器，DNS就会去查表，如果域名存在，则会返回浏览器对应IP地址，然后浏览器就会给这个IP地址发送TCP请求。</p><p>因为当前域名特别多，所以DNS不会将其保存成列表形式，而是将其保存成树状结构。最顶层是<strong>顶级域名（Top Level Domain，TLD）</strong>，比如<code>.com</code>和<code>.gov</code>；下一层是<strong>二级域名（Second Level Domain）</strong>， 比如<code>google.com</code>和<code>dftba.com</code>；再下一层是<strong>子域名（Sub-domain）</strong>，比如<code>images.google.com</code>等等。由于这个树结构特别大，因此这些数据分布在很多DNS服务器上，不同服务器负责树的不同部分。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229172611126.png" alt="image-20200229172611126"></p><center>域结构<center><p>总结上两节（28、29）的内容，其实计算机网络分成很多层次，接下来从最底层到最高层：</p><ol><li><strong>物理层（Physical Layer）</strong>，比如线路中的电信号，以及无线网络中的无线信号。</li><li><strong>数据链路层（Data Link Layer）</strong>负责操控物理层，其中包含MAC地址、冲突检测、指数回退以及其他一些底层协议。</li><li><strong>网络层（Network Layer）</strong>负责各种报文交换和路由技术。</li><li><strong>传输层（Transport Layer）</strong>负责在计算机之间进行点到点的传输，还会检测和修复错误，比如UDP和TCP协议。</li><li><strong>会话层（Session Layer）</strong>会使用TCP和UDP来创建连接，传递信息，然后关掉连接。</li></ol><p>以上是<strong>开放式系统互联通信参考模型（Open System Interconnection model，OSI）</strong>下的5层，这个框架将网络通信划分成了很多层，每一层处理各自的问题。这种抽象可以使得分工改进多个层，而无需考虑整体复杂性。并且OSI还有额外两层：<strong>表示层（Presentation Layer）</strong>和<strong>应用层（Application Layer）</strong>，在下一节中进行介绍。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229172753982.png" alt="image-20200229172753982"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229172822261.png" alt="image-20200229172822261"></p><h1 id="30、万维网"><a href="#30、万维网" class="headerlink" title="30、万维网"></a>30、万维网</h1><p>前两节介绍的东西共同组成了互联网，这一节将向上抽象一层，来讨论<strong>万维网（World Wide Web）</strong>。万维网和互联网的概念完全不同，万维网是运行于互联网之上的，还有其他比如Skype、Instagram等也是运行在互联网之上的。<strong>互联网是用来传输数据的管道</strong>，各种程序都会使用到，<u>其中传输最多数据的程序就是万维网</u>，我们可以使用特殊的程序——<strong>浏览器（Web Browser）</strong>来访问万维网。</p><p>万维网的最基本单位是单个页面，里面包含内容，也有访问其他页面的链接，这些链接称为<strong>超链接（Hyperlink）</strong>。这些超链接形成巨大的互联网络，这也是万维网名字的由来。并且由于文字超链接的强大，它有一个特殊的名字——<strong>超文本（Hypertext）</strong>。如今超文本最常指向的是另一个页面，这些页面会被获取并由浏览器进行渲染。</p><p>为了使网页能够互相连接，每个网页需要一个唯一的地址，这个地址称为<strong>统一资源定位器（Uniform Resource Locator，URL）</strong>，比如<code>thecrashcourse.com/courses</code>就是一个页面URL。</p><p>当你访问<code>thecrashcourse.com</code>网址时，计算机首先会进行DNS查询，这里输入一个域名，然后DNS就会返回给浏览器对应的计算机IP地址。然后浏览器就会打开一个TCP连接到这个IP地址对应的计算机上，而这个计算机运行着一个特殊的软件——<strong>网络服务器（Web Server）</strong>，网络服务器的标准端口是80。此时，你的计算机就连接到了<code>thecrashcourse.com</code>对应的服务器了，下一步是向服务器请求<code>courses</code> 页面，这里就会用到<strong>超文本传输协议（Hypertext Transfer Protocol，HTTP）</strong>。</p><p>HTTP的第一个标准是1991年创建的HTTP 0.9，只有一个指令<code>GET</code> 。因为这里我们想要获取<code>courses</code>页面， 我们可以直接向服务器发送指令<code>GET/courses</code>， 该指令以ASCII编码发送到服务器，服务器会返回该网址对应的页面，然后浏览器就会将其渲染到屏幕上。如果用户点击了另一个链接，计算机就会重新发送一个GET请求。在之后的版本中，HTTP添加了新的状态码，会将其放在请求页面的前面，比如状态码200表示网页被正确找到了，状态码400-499代表客户端出错。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/v2-5c297a37758affab1974f221b51a678d_720w.jpg" alt="img"></p><p>因为超文本的存储和发送都是以普通文本形式进行的，编码可能是ASCII或者UTF-8，这样就无法表明什么是链接，什么只是普通的文本了，所以必须开发一种标记方法，因此出现了<strong>超文本标记语言（Hypertext Markup Language，HTML）</strong>，第一代HTML创建于1990年的0.8版本，有18种指令。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/v2-d1f17935f645f06fc006ff22a4d68d4b_720w.jpg" alt="img"></p><center>制作一个简单的网页</center>综上，网络浏览器可以和网络服务器沟通，不仅获取网页和媒体，并且还负责显示。<p>随着后期万维网日益繁荣，人们越来越需要搜索。起初人们会维护一个目录，来链接到其他网站，但是随着网络越来越大，人工编辑目录变得很不方便，所以开发了搜索引擎。</p><p>最早的搜索引擎是JumpStation，它有3个部分：</p><ol><li><p>通过爬虫来将新链接添加进自己的列表中。</p></li><li><p>不断扩张的索引，用来记录访问过的网页上出现了哪些词。</p></li><li><p>查询索引的搜索算法，比如输入了某个关键字，则包含这个关键字的网页就会显示出来。</p></li></ol><p>早期的搜索引擎的排名方式直接取决于搜索词在页面上的出现次数，但是有的网页会通过在页面中重复该关键字来提高排名。Google成名的很大原因就是提出了一种算法来解决这个问题，与其信任页面上的内容，搜索引擎会看其他网页有没有连接到这个网页。</p><p>最后提一个概念——<strong>网络中立性（Network Neutrality）</strong>，它指的是要对所有数据包都平等对待，速度和优先级都应该一样。</p><h1 id="31、计算机安全"><a href="#31、计算机安全" class="headerlink" title="31、计算机安全"></a>31、计算机安全</h1><p>计算机安全的范围和计算能力的发展速度一样快，我们可以把计算机安全，看成是保护系统和数据的<strong>保密性、完整性和可用性</strong>。</p><blockquote><p><strong>保密性（Secrecy）：</strong>只有有权限的人才能<strong>读取</strong>计算机系统和数据，比如黑客泄露别人的信用卡信息，就是攻击保密性。</p><p><strong>完整性（Integrity）：</strong>只有有权限的人才能<strong>使用和修改</strong>系统和数据，比如黑客假冒你发送邮件，就是攻击完整性。</p><p><strong>可用性（Availability）：</strong>有权限的人应该随时可以访问系统和数据，<strong>拒绝服务攻击（DDOS</strong>）就是黑客发送大量的假请求到服务器上，使得网站很慢或者直接挂掉，这就是攻击可用性。</p></blockquote><p>为了实现这三个目标，安全专家会从抽象层面想想敌人可能是谁，这个称为<strong>威胁模型分析（Threat Model）</strong>。模型会对攻击者有个大致的描述：能力如何、目标是什么、可能使用什么手段。攻击手段又称为<strong>攻击矢量（Attack Vector）</strong>。威胁模型分析能够让你为特定情境做好准备，不被可能的攻击手段所淹没。换句话说，要怎么保护，具体看要对抗谁。</p><p>通常威胁模型分析中，会以能力水平进行区分。在给定的威胁模型下，安全架构师要提供解决方案，来保持系统安全。</p><p>有很多保护计算机系统、网络和数据的方法。很多安全问题可以总结成<strong>两个问题</strong>：</p><ol><li>你是谁？</li><li>你能访问什么？</li></ol><p>权限应该给适合的人而拒绝错误的人，所以为了区分谁是谁，我们使用<strong>身份认证（Authentication）</strong>来让计算机得知使用者是谁。通常身份认证有三种，各有利弊：</p><ol><li><strong>你知道什么：</strong>这个是基于某种只有用户和计算机知道的秘密，比如用户名和密码。这是如今使用最广最容易实现的方法。但是如果黑客知道了你的密码就惨了，或者可以通过暴力攻击试了密码的所有可能来获取你的密码，有些系统会在你尝试若干次错误后阻止你继续尝试。即使增长密码也很容易破解，所以现在很多网站都要求大小写字母加特殊字符，来增加可能的密码。</li><li><strong>你有什么：</strong>这是基于用户特定的物体，比如钥匙和锁。这种方法可以避免被人猜中密码的问题，而且通常需要人在现场，所以远程攻击就更加困难了。</li><li><strong>你是什么：</strong>这是基于你，通过你自己的特征展示给计算机来进行验证，比如指纹识别器和红膜扫描仪，这些方法特别的安全，但是最好的识别技术十分昂贵。“你知道什么”和“你有什么”是确定性的，但是来自传感器的数据每次都不相同，所以“你是什么”是概率性的，系统可能认不出你，或者将其他人认成了你。并且这种方法另一个问题就是无法重设，你无法修改自己的指纹或者虹膜。</li></ol><p>每种方法都有优缺点，一般建议使用两种或两种以上的认证方式。</p><p>当系统知道了你是谁，接下来就需要知道你能访问什么，这个称为<strong>访问控制（Access Control）</strong>，因此需要一个规范，来说明谁能访问什么、修改什么和使用什么。这个可以通过<strong>权限（Permission）</strong>或<strong>访问控制列表（Access Control List，ACL）</strong>来实现，其中描述了用户对每个文件、文件夹和程序的访问权限。</p><blockquote><p>读权限：允许用户查看文件内容。</p><p>写权限：允许用户修改文件内容。</p><p>执行权限：运行用户运行文件。</p></blockquote><p>有些阻止需要不同层次的权限，则ACL的正确配置就十分重要。假设我们有三个访问级别：<strong>公开、机密和顶级机密</strong>。有个经典模型称为<strong>Bell-LaPadula模型</strong>，其中包含两条规则：</p><ol><li>用户不能<strong>read up</strong>，即不能读等级更高的信息。</li><li>用户不能<strong>write down</strong>，即用户不能写更低权限的信息，这样能避免高级别的信息不会泄漏到低级别的文件中。</li></ol><p>通过身份认证和权限控制，可以让计算机知道你是谁和你能访问什么，但是必须先保证做这些事的软硬件必须是可信的。但是仍然无法保证程序或计算机系统的安全，因为安全软件在理论上可能是安全的，但是实现时可能会不小心留下漏洞。但是我们有办法减少漏洞出现的可能性，比如一发现漏洞就马上修补。</p><p>大部分漏洞都是具体实现时出错了，所以为了减少执行错误，就要减少执行。系统级安全的圣杯之一是安全内核或可信计算机基础：一组尽可能少的操作系统软件，这个安全性是接近可验证的。</p><p>构建安全内核的挑战在于，要决定内核应该有什么（代码越少越好）。当最小化代码数量后，要是能保证代码是安全的，那就很好了。现在最好的验证代码安全性的手段是<strong>独立安全监察和质量验证（Independent Verification and Validation）</strong>，让一群安全行业内的软件开发者来审计代码，这也是为什么安全型代码几乎都是开源的。</p><p>但是即使这样，还是有可能被黑客攻破，因此程序开发者需要控制损失的最大程度，这个称为<strong>隔离（Ioslation）</strong>。要实现隔离，可以<strong>“沙盒”（sandbox）</strong>程序，操作系统通过给每个程序独立的内存块，使得别的程序是无法触及的，这样就能把程序放到沙盒中，即使沙盒被破坏了，也不会影响别的程序执行。并且一台计算机可以运行多个<strong>虚拟机（Virtual Machine）</strong>，使得每个虚拟机都在自己的沙盒中。</p><h1 id="32、黑客-amp-攻击"><a href="#32、黑客-amp-攻击" class="headerlink" title="32、黑客&amp;攻击"></a>32、黑客&amp;攻击</h1><p>黑客入侵最常见的方式不是通过技术，而是欺骗别人，这个称为<strong>社会工程学（Social Engineering）</strong>，通过欺骗别人来让人泄露秘密，或让人配置电脑系统来变得易于攻击。最常见的攻击是<strong>网络钓鱼（Phishing）</strong>，其次还有<strong>假托（Pretexting）</strong>，攻击者给某个公司打电话，假装是IT部门的人，攻击者的第一通电话一般会叫人转接，这样另一个接的时候，电话看起来就像内部的，然后让别人把电脑配置得易于入侵，或者让他们泄露机密信息，比如密码或网络配置。</p><p>邮件里带<strong>木马（trojan horse）</strong>也是常见手段，木马通常会伪装成无害的东西，比如照片或发票，但实际上是恶意软件，有的会偷数据，有的会加密文件。</p><p>如果攻击者无法用木马或电话欺骗，攻击者只能被迫使用其他手段，方法之一就是暴力破解，尝试所有可能的密码，直到进入系统，大多数现代系统会加长等待时间来抵御这种攻击，每次失败就加长等待时间，甚至超过一定次数后，完全封锁。现在出现了一种攻破方法称为<strong>NAND镜像</strong>，如果能物理接触到电脑，可以往内存上接几根线，复制整个内存，然后暴力尝试密码，直到设备让你等待。这时只要把复制的内容覆盖掉内存，本质上重置了内存，就不用等待，可以继续尝试密码。</p><p>如果无法物理接触到设备，就需要远程攻击，比如通过互联网，这一般需要攻击者利用系统漏洞，来获得某些能力或访问权限，称为<strong>漏洞利用（Exploit）</strong>。一种常见的漏洞利用叫<strong>缓冲区溢出（Buffer Overflow）</strong>，这里的缓冲区是指预留的一块内存空间，比如我们在系统登录界面输入用户名和密码，而系统是用缓冲区来存储输入值的，假设缓冲区大小为10，并且缓冲区前后肯定还有其他数据，当用户输入用户名和密码时，这些值就会被复制到缓冲区中来进行验证，而该方法会溢出缓冲区，比如输入超过10个字符的密码，会覆盖掉相邻的数据，有时会让程序或系统崩溃，因为重要值被垃圾数据覆盖掉了。这里只是让系统崩溃，但是攻击者可以输入有意义的新值到程序的内存中，比如把<code>is_admin</code>标志位的值改为true，有了任意修改内存的能力，黑客就可以绕过登录这类东西，甚至使用那个程序劫持整个系统。</p><p>有许多方法阻止缓冲区溢出，最简单的方法就是复制到内存之前先检查长度，称为<strong>边界检查（Bounds checking</strong>），许多现代编程语言都自带边界检查，程序也会随机存放变量在内存中的位置，这样黑客就不知道应该覆盖内存的哪部分，使得更容易让程序崩溃，而不是获得访问权限。程序也可以在缓冲区后，预留一些不用的空间，然后跟踪里面的值，看是否发生变化，来判断是否有攻击，这些不用的内存空间称为<strong>金丝雀（Canaries）</strong>。</p><p>另一种经典手段是<strong>代码注入（Code Injection）</strong>，最常用于攻击用数据库的网站。假设网页上有登录提示，当用户点击“登录”，输入文本就会发送服务器，服务器就会运行代码，检查用户名是否存在，如果存在就看密码是否匹配。为此服务器会执行一段sql查询代码，比如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">password</span> <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> username=<span class="string">'___'</span>;</span><br></pre></td></tr></table></figure><p>这里语句就是要从<code>users</code>表中查找<code>username</code>为<code>___</code>的密码<code>password</code>。 这里的<code>___</code>就是用户输入的用户名。由此攻击者就能把sql命令输入到用户名中，比如<code>whatever&#39;;DROP TABLE users;&#39;</code>，这时上面的查询语句就会变成</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">password</span> <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> username=<span class="string">'whatever'</span>;<span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">users</span>;';</span><br></pre></td></tr></table></figure><p>如果服务器存在用户名<code>wharever</code>，数据库就会返回密码， 当然我们无法得知密码是什么，所以服务器会拒绝我们；如果不存在用户名<code>wharever</code>，服务器会返回空密码或者直接错误，服务器也会拒绝我们。 但是我们关心的是后面的代码<code>DROP TABLE users;</code><strong>这个是我们注入的命令</strong>，这个命令是删掉users这张表。如今几乎所有服务器都会防御这种手段。</p><p>程序员需要认识到从外界输入的信息都是危险的，必须要好好检查，很多用户名和密码表单，不会让你直接输入特殊符号，比如分号或括号，来作为第一道防御。好的服务器也会清理输入，比如修改或删除特殊字符，然后才放到数据库查询语句中。</p><p>当软件制造者不知道的新漏洞被发现时，称为<strong>0day漏洞（Zero Day Vulnerability）</strong>，黑客就会抢在白帽程序员做出补丁之前尽可能利用漏洞。</p><p>如果有足够多的电脑有漏洞，让恶意程序可以自动地在电脑之间互相传播，称为<strong>蠕虫（Worm）</strong>。如果黑客拿下大量电脑，这些电脑可以组成<strong>僵尸网络（Botnet）</strong>，可以用于很多目的，比如发大量垃圾邮件等，用别人电脑的计算能力来挖比特币，或发起DDOS来攻击服务器。DDOS就是僵尸网络里的所有电脑发一大堆垃圾信息到服务器上，造成服务器的阻塞。</p></center></center>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;red&gt;计算机科学速成课&lt;/red&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="《计算机科学速成课》" scheme="https://longlongqin.github.io/tags/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>LearnCpp chapter4</title>
    <link href="https://longlongqin.github.io/archives/c1a4eb67.html"/>
    <id>https://longlongqin.github.io/archives/c1a4eb67.html</id>
    <published>2020-03-31T05:59:58.000Z</published>
    <updated>2020-04-19T14:38:29.546Z</updated>
    
    <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapter4</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h2 id="4-1-基本的数据类型"><a href="#4-1-基本的数据类型" class="headerlink" title="4.1 基本的数据类型"></a>4.1 基本的数据类型</h2><ul><li><p>内存最小的单位是一个<strong>二进制数(binary digit)</strong>，即<strong>位(bit)</strong>。它可以存储一个0或者1。</p><blockquote><p>就像传统的电灯开关一样——灯开着(1)，灯关着(0)</p></blockquote></li><li><p>由连续的单元组成的内存，叫<strong>内存地址(memory addresses)</strong>，简称<strong>地址(addresses)</strong></p></li><li><p>现代计算机中，“位”是没有它自己的内存地址的。而是用一个“<strong>字节(byte)</strong>”来表示一个内存地址。</p><blockquote><p>因为内存地址是比较有限的，而且需要逐“位”访问数据的情况很少。</p><p><strong>字节</strong>是作为一个单位来操作的一组”位(bit)”。现代标准规定：一个字节由<strong>8个</strong>连续的<strong>位</strong>组成。</p></blockquote><p>下面的图片显示了一些连续的内存地址，以及相应的数据字节:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/MemoryAddresses.png" alt="MemoryAddresses"></p></li><li><p><strong>数据类型(Data types)</strong>，简称“<strong>类型(type)</strong>”</p><ul><li><p>我们使用<strong>数据类型</strong>来告诉编译器如何以某种有意义的方式解释内存的内容。</p><blockquote><p>如：当我们声明一个变量的类型为 整型(integer)时，就相当于告诉内存“<strong>这个变量使用的内存段将被解释为一个整数值</strong>”</p></blockquote></li><li><p>给对象(object)一个值(value)时，编译器和CPU就负责将您的值 编码(encode)为该数据类型的适当的位序列，并存储在内存中。<u>【记住：内存只存储<strong>位(bits)</strong>】</u></p><blockquote><p>如：给一个整型对象赋一个值,65。这个值就被转换为bits：<code>0100 0001</code>，并被存储在分配给对象的内存中。</p></blockquote></li><li><p>当这个对象被求值，产生一个值时，这个 位序列(sequence of bits) 被重新构造成原来的值。</p><blockquote><p>意思就是：<code>0100 0001</code>被转换回 值65.</p><p>幸运的是，这些转换工作都是由 编译器 和 CPU 来完成的。</p></blockquote></li></ul></li><li><p><strong>基本数据类型(fundamental data types)</strong>，但通常被非正式地称为<strong>基本类型(basic types)</strong>、<strong>基本类型(primitive types)</strong>或<strong>内置类型(built-in types)</strong>。</p><p>下面是一些基本数据类型：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200330175227962.png" alt="fundamental data types"></p><blockquote><p>1、注意：<strong>integer vs integral</strong>：<em>integral</em>即比<em>integer</em>范围更广</p><ul><li><strong>integer：表示整数，即正整数、负整数、0；</strong></li><li><strong>integral：包含了 integer、boolean(布尔型)、字符类型</strong>。</li></ul><p>他们两个名字比较相近，是因为：<u>integral类型在内存中存储形式是和integer一样</u>。</p><hr><p>2、 <strong><code>_t</code>后缀</strong></p><p>这个后缀，表示“类型”的意思。</p></blockquote></li></ul><h2 id="4-2-Void"><a href="#4-2-Void" class="headerlink" title="4.2 Void"></a>4.2 Void</h2><ul><li><p>void是最简单的类型，<strong>void</strong>，即“没有类型”</p></li><li><p>变量不能定义为void类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> value; <span class="comment">// won't work, variables can't be defined with a void type</span></span><br></pre></td></tr></table></figure></li><li><p>void用途：</p><ol><li><p><strong>Functions that do not return a value（函数不返回值）</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeValue</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">// void here means no return value</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The value of x is: "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="comment">// no return statement, because this function doesn't return a value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Functions that do not take parameters(函数中不带参数)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">void</span>)</span> <span class="comment">// void here means no parameters</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者这种形式【在C++中，推荐写这种形式】</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="comment">// empty function parameters is an implicit void</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="4-3-对象大小-amp-sizeof操作符"><a href="#4-3-对象大小-amp-sizeof操作符" class="headerlink" title="4.3 对象大小&amp;sizeof操作符"></a>4.3 对象大小&amp;sizeof操作符</h2><p><strong>对象的大小</strong>：</p><ul><li><p>对象的大小取决于它的数据类型</p></li><li><p>通常通过<strong>变量名访问内存</strong>，<strong>而不是直接通过内存地址</strong>。</p></li><li><p>1个bit(位)可以容纳2个可能的值，0或1；…….</p><blockquote><p><strong>即，具有n位(bits)的对象，可以容纳2^n 个可能的值。</strong></p></blockquote><p>因此，对象的大小限制了它可以存储的唯一值的个数。</p></li><li><p>每次定义一个对象时，<strong>只要该对象存在，就会使用一小部分空闲内存</strong>。</p></li></ul><p><strong>基本数据类型的大小</strong>：</p><ul><li><p>给定数据类型的大小<strong>取决于编译器 和/或 计算机体系结构!</strong></p><p>C++只保证每个基本数据类型的大小都是最小的：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200331095627896.png" alt="image-20200331095627896"></p><blockquote><p><strong>然而，这些类型的大小在不同的计算机上可能会不一样。</strong>比如，有些机器上的int大小为4 bytes</p></blockquote></li></ul><p><strong>操作符“sizeof”</strong></p><p>为了能够在计算机上直到类型的大小，C++提供了<strong>“sizeof”</strong>操作符来确认类型的大小。</p><blockquote><p><strong>sizeof：是一个一元操作符，它接受 类型 或 变量，然后返回它的大小(bytes)</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"bool:\t\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">bool</span>) &lt;&lt; <span class="string">"bytes\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"char:\t\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">char</span>) &lt;&lt; <span class="string">"bytes\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"wchar_t:\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">wchar_t</span>) &lt;&lt; <span class="string">"bytes\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"char16_t:\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">char16_t</span>) &lt;&lt; <span class="string">" bytes\n"</span>; <span class="comment">// C++11 only</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"char32_t:\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">char32_t</span>) &lt;&lt; <span class="string">" bytes\n"</span>; <span class="comment">// C++11 only</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"short:\t\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(short) &lt;&lt; <span class="string">" bytes\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"int:\t\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="string">" bytes\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"long:\t\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span>) &lt;&lt; <span class="string">" bytes\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"long long:\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>) &lt;&lt; <span class="string">" bytes\n"</span>; <span class="comment">// C++11 only</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"float:\t\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">float</span>) &lt;&lt; <span class="string">" bytes\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"double:\t\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">double</span>) &lt;&lt; <span class="string">" bytes\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"long double:\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">double</span>) &lt;&lt; <span class="string">" bytes\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//避免在visual studio 中运行时 闪过</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>运行结果会因为不同类型的机器or编译器，而出现差异。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200331101214364.png" alt="image-20200331101214364"></p><h2 id="4-4-有符号整型"><a href="#4-4-有符号整型" class="headerlink" title="4.4 有符号整型"></a>4.4 有符号整型</h2><ul><li>C++中有四种整型的类型：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200331101704637.png" alt="image-20200331101704637"></p><ul><li><p><strong>Signed integers(有符号整型)</strong></p><p>如：+1、-1、0这种都属于 有符号整型。</p><ul><li><p><strong>定义有符号整型：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【推荐】</span></span><br><span class="line">short s;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">long</span> i;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//除了int，其它类型也可以这样写：</span></span><br><span class="line">short <span class="keyword">int</span> s;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">long</span> liong i;</span><br><span class="line"><span class="comment">//这种【不推荐】，使用“int”后缀不利于观看</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以使用 signed前缀</span></span><br><span class="line"><span class="keyword">signed</span> shrt s;</span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">long</span> i;</span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">long</span> <span class="keyword">long</span> i;</span><br><span class="line"><span class="comment">//【不推荐】，因为signed冗余，不利于辨认</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>有符号整型的范围</strong></p><p>数据类型可以容纳的一组特定值，叫做：<strong>range(范围)</strong></p><blockquote><p>整型变量的“<strong>范围</strong>”的决定因素：</p><ol><li>该类型本身的大小；</li><li>该类型是否是 有符号 的。</li></ol><p>比如，大小为1字节的有符号整型，它的范围是：-128~127(包含范围的两端)，即它可以存储2^8=256 个可能的整数。</p></blockquote></li></ul><p>这是一个包含不同大小有符号整数范围的表:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200331104055635.png" alt="image-20200331104055635"></p><blockquote><p>小结，一个有 <strong>n</strong>-bits的 有符号变量，它可存储值的范围是：<strong>-(2^n-1^) ~ (2^n-1^ -1)</strong></p></blockquote><ul><li><p><strong>整数溢出</strong>，简称：<strong>溢出</strong></p><p>如果我们把值280,存储在 1个字节的有符号整型 中，他就会发生 <strong>溢出</strong>现象。此时，<strong>数据丢失是因为对象没有足够的内存来存储所有东西。</strong></p></li></ul><h2 id="4-5-无符号整型"><a href="#4-5-无符号整型" class="headerlink" title="4.5 无符号整型"></a>4.5 无符号整型</h2><center>不推荐使用</center><p><strong>无符号整型：unsigned integer。</strong>不能存储“负数”，<strong>可以存储：0 和 正整数</strong></p><ul><li><p><strong>定义无符号整型变量</strong></p><p>要定义无符号整数，我们使用<strong>unsigned</strong>关键字。按照惯例，这是放在前面的类型:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> short us;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ui;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> ul;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br></pre></td></tr></table></figure></li><li><p><strong>无符号整型范围</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200331105315653.png" alt="Unsigned integer range"></p><blockquote><p>一个有 n-bits 的无符号整型变量，它可存储的范围是：<strong>0 ~ (2^n^)-1</strong></p></blockquote><p>当不需要负数时，无符号整数非常适合于网络和内存很少的系统，<strong>因为无符号整数可以存储更多的正数而不占用额外的内存。</strong></p></li></ul><ul><li><p><strong>无符号整数的溢出：Unsigned integer overflow</strong></p><p>无符号整数不会溢出。<em>如果一个值超过范围，那么它会除以一个比这个范围大的数，然后将余数存起来。</em></p><ul><li><p><strong>正数溢出</strong></p><blockquote><p>如，在 1byte的范围中，存储数据。</p><ul><li>280在 范围为 1个字节 的整型中存储，因280&gt;255。所以，它会除以256(比 1个字节的范围的最大值大1，即比255大1的数，256)。280/256=24，<strong>所以存储的是24</strong>.</li><li>存储256。256&gt;255。则进行 256/256 = 0，<strong>即相当于存储 0</strong></li><li>存储257。257&gt;255。则进行 257/256 = 1，<strong>即相当于存储 1</strong></li></ul></blockquote><p>看一个程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> short x&#123; <span class="number">65535</span> &#125;; <span class="comment">// 最大的16位无符号值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x was: "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    x = <span class="number">65536</span>; <span class="comment">// 65536 is out of our range, so we get wrap-around</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x is now: "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    x = <span class="number">65537</span>; <span class="comment">// 65537 is out of our range, so we get wrap-around</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x is now: "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200331131152778.png" alt="image-20200331131152778"></p><hr></li></ul></li></ul><ul><li><p><strong>负数溢出</strong></p><p>虽然，无符号整数的范围是0~255(假如在 1byte的范围).但是我们不小心在无符号整型中输入了 负数，应该怎么办呢？</p><p>比如，当输入 -1 时。-1不在 0~255这个范围中。此时就循环到这个范围的顶部（最大值处），即 255。所以，在 1 byte 的范围的无符号整数中，<strong>输入 -1 ，存储的是 255。</strong></p><p><strong>输入-2，存储的是254。（从最顶部往回循环）</strong></p></li></ul><h2 id="4-6-固定宽度的整数和size-t"><a href="#4-6-固定宽度的整数和size-t" class="headerlink" title="4.6 固定宽度的整数和size_t"></a>4.6 固定宽度的整数和size_t</h2><p>之前讲了整型变量的最低size，其实他们可以按照不同的系统变得更大。</p><ul><li><p>为什么不固定整型变量的大小？</p><p>因为在C语言中，为了提高性能，C故意保持整数的大小是开放的，这样编译器实现者就可以为 int 选择一个在目标计算机架构上表现最好的大小。</p></li><li><p><strong>固定宽度的整型</strong></p><p>为了实现跨平台，C99定义了一系列的<strong>固定宽度的整型</strong>(在头文件<code>stdint.h</code>中)，使得在任何平台中的大小都一致。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200331142942242.png" alt="Fixed-width integers"></p><blockquote><p><strong>在C++11中的头文件<code>cstdint</code>中，也包含了上述的固定宽度整型。他们在命名空间<code>std</code>中定义的。</strong></p><p>如;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="keyword">int16_t</span> <span class="title">i</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>应该避免上述固定宽度的整数，因为它们可能不是在所有目标体系结构上定义的。</p></li></ul><hr><ul><li><p><strong>fast &amp; least 整型</strong>：快类型 &amp; 小类型</p><p>为了帮助解决上述缺点，c++ 11还定义了两个可选的整数集。</p><ol><li><p>*<em>fast type *</em></p><p><strong>无符号</strong>格式为： std::<strong>int_fast#_t</strong> ；<strong>有符号</strong>格式：std::<strong>uint_fast#_t</strong></p><p>它提供一个整型，它提供一个在你的机器上<u>表现得性能最好的宽度</u>，但是它的宽度最小是“# <strong>bits</strong>”（# = 8，16，32，or 64 <strong>bit</strong>）</p><blockquote><p>如：<code>std::int_fast32_t</code>将会给你一个最小为 32bits 的无符号整型</p></blockquote></li><li><p><strong>least type</strong></p><p><strong>无符号</strong>格式为： std::<strong>int_least#_t</strong> ；<strong>有符号</strong>格式：std::<strong>uint_least#_t</strong></p><p>它提供一个整型类型，它提供一个<u>最接近于</u>“# <strong>bits</strong>”的宽度，但是它的宽度最小是“# <strong>bits</strong>”（# = 8，16，32，or 64 <strong>bit</strong>）</p></li></ol><blockquote><p>小结：<strong><u>比较：<code>int#\_t</code>、<code>int_fast#_t</code>、<code>int_least#_t</code>的差异</u></strong>：</p><ul><li><code>int#_t</code>的bits(位数)是固定的，即有“# bits”；</li><li><code>int_fast#_t</code> 和 <code>int_least#_t</code>的bits(位数)最少有““# bits”；</li></ul><p>example：</p><p><code>int16_t</code>：是固定的16位的整型；</p><p><code>int_fast16_t</code>：可能转变成了64位的整型。（因为在你的机器上，64位整型最快了）</p><p><code>int_least16_t</code>：可能转变成了32位的整型。（假设因为你的系统中没有16位的整型，而32位此时<strong>是最接近</strong>16位 的整型了）</p></blockquote></li></ul><hr><ul><li><p>注意：<strong><code>std::int8_t</code>和<code>std::uint8_t</code><u>是char类型</u>，而不是integer</strong></p><p>在C++中，很多编译器对<code>std::int8_t</code>和<code>std::uint8_t</code>（以及相应的fast 和 least 整型）的定义和对待方式 是与 <code>signed char</code>(有符号字符类型) 的方式相同。</p><p>但是，在某些系统中，它确实是整型的，而不是char类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">int8_t</span> myint = <span class="number">65</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; myint;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************/</span></span><br><span class="line">运行结果是： A</span><br></pre></td></tr></table></figure><blockquote><p>所以，我们要<strong>避免使用这几个整型类型</strong>。</p></blockquote></li></ul><hr><p><strong>最佳使用整型</strong></p><ul><li>当整型的大小不做要求时，使用<strong><code>int</code></strong>；</li><li>如果需要一个保证为特定大小的变量，并且希望<strong>提高性能</strong>，使用<strong><code>int_fast#_t</code></strong>；</li><li>如果您需要一个保证为特定大小的变量，并且希望<strong>优先考虑内存保护而不是性能</strong>，使用 <strong><code>int_least#_t</code></strong></li></ul><p><strong>尽量不要使用这些</strong>：</p><ul><li>无符号整型，Unsigned types；</li><li>8 bits 的固定宽度的整型类型；</li><li>任何特定于编译器的固定宽度整数（例如，visual studio 定义了 __int8 ，__int16 等等）</li></ul><hr><p><strong><code>std::size_t</code></strong>是什么？</p><blockquote><p>是一个无符号整数类型，通常用于表示对象的大小或长度。</p></blockquote><p>sizeof返回一个<code>std::size_t</code>类型的值。</p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************/</span></span><br><span class="line">结果是： <span class="number">4</span>  【这个<span class="number">4</span>，就是 <span class="built_in">std</span>::<span class="keyword">size_t</span>类型的】</span><br></pre></td></tr></table></figure><ul><li><p><code>size_t</code>本身大小也是不固定的，它确保是无符号的，并且至少是16位。但是在大多数系统中，它的大小将等于应用程序的地址宽度。</p><blockquote><p>比如，在32位应用程序中，<code>size_t</code>是一个 32 bits 的无符号整型；在64位应用程序中，<code>size_t</code>是一个 64 bits 的无符号整型。</p></blockquote></li></ul><h2 id="4-7-科学计数法"><a href="#4-7-科学计数法" class="headerlink" title="4.7 科学计数法"></a>4.7 科学计数法</h2><p><strong>scientific notation</strong></p><p>科学计数法的形式：<strong>a×10^exponent^</strong>。其中, a：只能是0~9的数（不包括0，但包括9）</p><blockquote><p>如：1.2×10^4^ 、 5.9736 x 10^24^</p></blockquote><p>在C++中，我们用字母<code>e</code>（大写<code>E</code>也可以）来代表 10；</p><blockquote><p>1.2×10^4^ -&gt; 1.2e4 ； 5.9736 x 10^24^ -&gt; 5.9736e24</p><p>小于1的分数0.05表示为： 5e-2</p></blockquote><hr><ul><li><p><strong>有效数字：significant digits</strong></p><blockquote><p><em>有效数字的数量定义了数字的精度。</em>(有效数字越多，数字越精确。)</p></blockquote><p>e前面的数就是有效数字，如<code>5.9736e24</code>的有效数字是：5.9736，即，5个有效数字</p></li></ul><h2 id="4-8-浮点数float"><a href="#4-8-浮点数float" class="headerlink" title="4.8 浮点数float"></a>4.8 浮点数<code>float</code></h2><center>永远不要假设浮点数是精确的。</center><ul><li><p>三种浮点型数据：<strong><code>float</code>、<code>double</code>、<code>long double</code></strong></p><blockquote><p>与整数一样，c++没有定义这些类型的实际大小(但它确实保证了最小大小)。在现代体系结构中，浮点表示几乎总是遵循IEEE 754二进制格式。在这种格式中：</p><p><code>float</code>：4字节；</p><p><code>double</code>：8字节，</p><p><code>long double</code>：可以等于一个<code>double</code>(<strong>8字节</strong>)、<strong>80 bits(通常填充为12字节)</strong>或者 <strong>16字节</strong>。</p></blockquote><p>浮点型数据通常是 <strong>有符号的(sign)</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200331194441574.png" alt="image-20200331194441574"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x&#123;<span class="number">5</span>&#125;; <span class="comment">//整型</span></span><br><span class="line"><span class="keyword">double</span> y&#123;<span class="number">5.0</span>&#125;; <span class="comment">//5.0是一个浮点型(没有后缀，默认情况下是double类型)</span></span><br><span class="line"><span class="keyword">float</span> z&#123;<span class="number">5.0f</span>&#125;; <span class="comment">//5.0是一个浮点型，f后缀表示浮点类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********/</span></span><br><span class="line">【注】浮点型数据默认是：<span class="keyword">double</span>类型的，加上后缀“f”表示是 <span class="keyword">float</span>类型</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>浮点型数据的输出</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">5.0</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">6.7f</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">9876543.21</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************/</span></span><br><span class="line">输出结果：</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6.7</span></span><br><span class="line"><span class="number">9.87654e+06</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>第一个，即使我们输入的是5.0，但它输出的依然是 5。【默认情况下，如果小数部分为0,std::cout将不会打印数字的小数部分。】</li><li>第二个输出正常；</li><li>第三个输出是科学记数的形式。</li></ul></blockquote></li></ul><hr><ul><li><p><strong>浮点型的范围</strong></p><p>根据 IEEE 754的表示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200331195509853.png" alt="image-20200331195509853"></p></li></ul><hr><ul><li><p><strong>浮点型的精度</strong></p><ul><li>浮点型的默认精度是6：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">9.87654321f</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">987.654321f</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">987654.321f</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">9876543.21f</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">0.0000987654321f</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******输出**********/</span></span><br><span class="line"><span class="number">9.87654</span></span><br><span class="line"><span class="number">987.654</span></span><br><span class="line"><span class="number">987654</span></span><br><span class="line"><span class="number">9.87654e+006</span></span><br><span class="line"><span class="number">9.87654e-005</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：<strong>根据编译器的不同，指数的位数会被填充</strong>。比如：“9.87654e+006”的指数位置就被填充为3位。</p><p><strong>显示的最小指数位数是特定于编译器的，在Visual Studio 中填充为 <code>3 位</code></strong></p></blockquote></li></ul><ul><li><p>浮点变量的精度位数取决于大小(浮点数的精度小于双精度)和存储的特定值(某些值的精度高于其他值)。</p><p>用 <code>iomanip</code>头文件中的函数 <em>std::setprecison</em>来覆盖std::cout显示的默认精度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt; // for std::setprecision()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">16</span>); <span class="comment">// show 16 digits of precision</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">3.33333333333333333333333333333333333333f</span> &lt;&lt;<span class="string">'\n'</span>; <span class="comment">// f suffix means float</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">3.33333333333333333333333333333333333333</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// no suffix means double</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******输出*********/</span></span><br><span class="line"><span class="number">3.333333253860474</span></span><br><span class="line"><span class="number">3.333333333333334</span></span><br></pre></td></tr></table></figure><blockquote><p>可以看出，<strong><code>double</code>类型的比<code>float</code>类型的精度更高</strong>。</p></blockquote></li></ul><ul><li><p>精度不仅影响小数部分，他还影响比较大的数的精度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt; // for std::setprecision()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> f &#123; <span class="number">123456789.0f</span> &#125;; <span class="comment">// f has 10 significant digits</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">9</span>); <span class="comment">// to show 9 digits in f</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********结果**********/</span></span><br><span class="line"><span class="number">123456792</span></span><br></pre></td></tr></table></figure><blockquote><p>123456789.0 的有效数字是10个，但是浮点型通常有7位精度(123456792的结果只能精确到7位有效数字)。</p><p>我们失去了一些精度!当由于无法精确地存储数字而丢失精度时，这称为<strong>rounding error(舍入误差)</strong>。</p></blockquote><p>小结：<strong>通常情况推荐使用<code>double</code></strong></p></li></ul><hr><ul><li><p><strong>无限循环 &amp; 非数字 ：NaN and Inf</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> zero &#123;<span class="number">0.0</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> posinf &#123; <span class="number">5.0</span> / zero &#125;; <span class="comment">// positive infinity</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; posinf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">double</span> neginf &#123; <span class="number">-5.0</span> / zero &#125;; <span class="comment">// negative infinity</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; neginf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">double</span> nan &#123; zero / zero &#125;; <span class="comment">// not a number (mathematically invalid)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; nan &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******结果************/</span></span><br><span class="line"><span class="number">1.</span>#INF</span><br><span class="line"><span class="number">-1.</span>#INF</span><br><span class="line"><span class="number">1.</span>#IND</span><br></pre></td></tr></table></figure><blockquote><p>INF代表无穷，IND代表不确定。</p><p>请注意，输出Inf和NaN的结果是特定于平台的，因此您的结果可能会有所不同。</p></blockquote></li></ul><hr><p>总结：</p><ol><li><strong>浮点数用于存储非常大或非常小的数字，包括那些具有小数部分的数字。</strong></li><li>浮点数通常有较小的<strong>舍入误差</strong>，即使该数的有效位数比精度小。很多时候，这些数据的舍入误差没有被注意到，因为它们非常小，而且由于输出而被截断。但是，<strong>对浮点数的比较可能不会得到预期的结果。对这些值执行数学运算将导致舍入误差增大。</strong></li></ol><hr><h2 id="4-9-布尔型bool"><a href="#4-9-布尔型bool" class="headerlink" title="4.9 布尔型bool"></a>4.9 布尔型<code>bool</code></h2><p>实际上，<em>Boolean values</em>(布尔值)存储的布尔变量，不是以<code>true</code>、<code>false</code>的形式。<strong>而是以整型类型存储的，即<em>true</em>对应整型<em>1</em>；<em>false</em>对应整型<em>0</em>。</strong></p><blockquote><p>即，布尔值被认为是一个整型类型。</p></blockquote><hr><ul><li><p><strong>输出布尔值</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="literal">true</span>&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="literal">false</span>&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">bool</span> b&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;b&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;!b&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************结果***********/</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><hr><p>如果你想输出“<em>true</em>、<em>false</em>”。你可以用<code>std::boolalpah</code>：</p><blockquote><p><code>std::noboolalpha</code>是关闭作用</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="literal">false</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha; <span class="comment">//print bools as ture or false</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="literal">true</span>&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="literal">false</span>&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果**********/</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>整型与布尔型的转换：Integer to Boolean conversion</strong></p><ul><li><p>*<u>不能</u>用整型数字来初始化bool变量*</p><p><code>bool b{4};</code> //error: 不允许这样转换</p></li><li><p>但是，整型变量可以转换为布尔型：</p><blockquote><p>整型 <em>0</em> 可以被转换为<em>false<em>；其他的非0 的整型可以被转换为</em>true</em></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha; <span class="comment">// print bools as true or false</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> b1 = <span class="number">4</span> ; <span class="comment">// copy initialization allows implicit conversion from int to bool</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b1 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> b2 = <span class="number">0</span> ; <span class="comment">// copy initialization allows implicit conversion from int to bool</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b2 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果**********/</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><ul><li><p><strong>输入布尔型值</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> b &#123;&#125;; <span class="comment">// default initialize to false (0)</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a boolean value: "</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; b;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"You entered: "</span> &lt;&lt; b;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter a Boolean value: true</span><br><span class="line">You entered: 0</span><br></pre></td></tr></table></figure><p>发现，<strong>布尔型值的输入，只接受：<em>0</em> 和<em>1</em></strong> (不是 true 或者 false)。所以，如果输入的值是<em>0</em> 和<em>1</em>之外的其他值，都是失败的，即false，所以是0。</p><blockquote><p>因为在C++11或者更新的标准中，<strong>一个失败的输入也会使变量变为0，所以b也会被赋值为0。</strong></p></blockquote></li></ul><hr><h2 id="4-11-char类型"><a href="#4-11-char类型" class="headerlink" title="4.11 char类型"></a>4.11 <code>char</code>类型</h2><p>char数据类型是<strong>整数类型</strong>，这意味着<u>底层值存储为整数</u>，并且保证<u>大小为1字节</u>。</p><p>但是，与将布尔值解释为true或false类似，<u>将char值解释为ASCII字符</u>。</p><blockquote><p><strong>ASCII</strong>是美国信息交换标准代码的缩写，它定义了一种特殊的方式来将英文字符(加上一些其他符号)表示为0到127之间的数字(称为ASCII码或代码点)。</p><p><strong>字符文字总是放在单引号之间</strong>。例如，ASCII码97被解释为字符“a”。</p></blockquote><p>下面是完整的ASCII字符表:</p><table><thead><tr><th align="left">Code</th><th align="left">Symbol</th><th align="left">Code</th><th align="left">Symbol</th><th align="left">Code</th><th align="left">Symbol</th><th align="left">Code</th><th align="left">Symbol</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">NUL (null)</td><td align="left">32</td><td align="left">(space)</td><td align="left">64</td><td align="left">@</td><td align="left">96</td><td align="left">`</td></tr><tr><td align="left">1</td><td align="left">SOH (start of header)</td><td align="left">33</td><td align="left">!</td><td align="left">65</td><td align="left">A</td><td align="left">97</td><td align="left">a</td></tr><tr><td align="left">2</td><td align="left">STX (start of text)</td><td align="left">34</td><td align="left">”</td><td align="left">66</td><td align="left">B</td><td align="left">98</td><td align="left">b</td></tr><tr><td align="left">3</td><td align="left">ETX (end of text)</td><td align="left">35</td><td align="left">#</td><td align="left">67</td><td align="left">C</td><td align="left">99</td><td align="left">c</td></tr><tr><td align="left">4</td><td align="left">EOT (end of transmission)</td><td align="left">36</td><td align="left">$</td><td align="left">68</td><td align="left">D</td><td align="left">100</td><td align="left">d</td></tr><tr><td align="left">5</td><td align="left">ENQ (enquiry)</td><td align="left">37</td><td align="left">%</td><td align="left">69</td><td align="left">E</td><td align="left">101</td><td align="left">e</td></tr><tr><td align="left">6</td><td align="left">ACK (acknowledge)</td><td align="left">38</td><td align="left">&amp;</td><td align="left">70</td><td align="left">F</td><td align="left">102</td><td align="left">f</td></tr><tr><td align="left">7</td><td align="left">BEL (bell)</td><td align="left">39</td><td align="left">’</td><td align="left">71</td><td align="left">G</td><td align="left">103</td><td align="left">g</td></tr><tr><td align="left">8</td><td align="left">BS (backspace)</td><td align="left">40</td><td align="left">(</td><td align="left">72</td><td align="left">H</td><td align="left">104</td><td align="left">h</td></tr><tr><td align="left">9</td><td align="left">HT (horizontal tab)</td><td align="left">41</td><td align="left">)</td><td align="left">73</td><td align="left">I</td><td align="left">105</td><td align="left">i</td></tr><tr><td align="left">10</td><td align="left">LF (line feed/new line)</td><td align="left">42</td><td align="left">*</td><td align="left">74</td><td align="left">J</td><td align="left">106</td><td align="left">j</td></tr><tr><td align="left">11</td><td align="left">VT (vertical tab)</td><td align="left">43</td><td align="left">+</td><td align="left">75</td><td align="left">K</td><td align="left">107</td><td align="left">k</td></tr><tr><td align="left">12</td><td align="left">FF (form feed / new page)</td><td align="left">44</td><td align="left">,</td><td align="left">76</td><td align="left">L</td><td align="left">108</td><td align="left">l</td></tr><tr><td align="left">13</td><td align="left">CR (carriage return)</td><td align="left">45</td><td align="left">-</td><td align="left">77</td><td align="left">M</td><td align="left">109</td><td align="left">m</td></tr><tr><td align="left">14</td><td align="left">SO (shift out)</td><td align="left">46</td><td align="left">.</td><td align="left">78</td><td align="left">N</td><td align="left">110</td><td align="left">n</td></tr><tr><td align="left">15</td><td align="left">SI (shift in)</td><td align="left">47</td><td align="left">/</td><td align="left">79</td><td align="left">O</td><td align="left">111</td><td align="left">o</td></tr><tr><td align="left">16</td><td align="left">DLE (data link escape)</td><td align="left">48</td><td align="left">0</td><td align="left">80</td><td align="left">P</td><td align="left">112</td><td align="left">p</td></tr><tr><td align="left">17</td><td align="left">DC1 (data control 1)</td><td align="left">49</td><td align="left">1</td><td align="left">81</td><td align="left">Q</td><td align="left">113</td><td align="left">q</td></tr><tr><td align="left">18</td><td align="left">DC2 (data control 2)</td><td align="left">50</td><td align="left">2</td><td align="left">82</td><td align="left">R</td><td align="left">114</td><td align="left">r</td></tr><tr><td align="left">19</td><td align="left">DC3 (data control 3)</td><td align="left">51</td><td align="left">3</td><td align="left">83</td><td align="left">S</td><td align="left">115</td><td align="left">s</td></tr><tr><td align="left">20</td><td align="left">DC4 (data control 4)</td><td align="left">52</td><td align="left">4</td><td align="left">84</td><td align="left">T</td><td align="left">116</td><td align="left">t</td></tr><tr><td align="left">21</td><td align="left">NAK (negative acknowledge)</td><td align="left">53</td><td align="left">5</td><td align="left">85</td><td align="left">U</td><td align="left">117</td><td align="left">u</td></tr><tr><td align="left">22</td><td align="left">SYN (synchronous idle)</td><td align="left">54</td><td align="left">6</td><td align="left">86</td><td align="left">V</td><td align="left">118</td><td align="left">v</td></tr><tr><td align="left">23</td><td align="left">ETB (end of transmission block)</td><td align="left">55</td><td align="left">7</td><td align="left">87</td><td align="left">W</td><td align="left">119</td><td align="left">w</td></tr><tr><td align="left">24</td><td align="left">CAN (cancel)</td><td align="left">56</td><td align="left">8</td><td align="left">88</td><td align="left">X</td><td align="left">120</td><td align="left">x</td></tr><tr><td align="left">25</td><td align="left">EM (end of medium)</td><td align="left">57</td><td align="left">9</td><td align="left">89</td><td align="left">Y</td><td align="left">121</td><td align="left">y</td></tr><tr><td align="left">26</td><td align="left">SUB (substitute)</td><td align="left">58</td><td align="left">:</td><td align="left">90</td><td align="left">Z</td><td align="left">122</td><td align="left">z</td></tr><tr><td align="left">27</td><td align="left">ESC (escape)</td><td align="left">59</td><td align="left">;</td><td align="left">91</td><td align="left">[</td><td align="left">123</td><td align="left">{</td></tr><tr><td align="left">28</td><td align="left">FS (file separator)</td><td align="left">60</td><td align="left">&lt;</td><td align="left">92</td><td align="left">\</td><td align="left">124</td><td align="left">|</td></tr><tr><td align="left">29</td><td align="left">GS (group separator)</td><td align="left">61</td><td align="left">=</td><td align="left">93</td><td align="left">]</td><td align="left">125</td><td align="left">}</td></tr><tr><td align="left">30</td><td align="left">RS (record separator)</td><td align="left">62</td><td align="left">&gt;</td><td align="left">94</td><td align="left">^</td><td align="left">126</td><td align="left">~</td></tr><tr><td align="left">31</td><td align="left">US (unit separator)</td><td align="left">63</td><td align="left">?</td><td align="left">95</td><td align="left">_</td><td align="left">127</td><td align="left">DEL (delete)</td></tr></tbody></table><hr><ul><li><p><strong>初始化字符</strong></p><ol><li><p>使用字符 初始化：</p><p><code>char cha2{&#39;a&#39;};</code> <em>// initialize with code point for ‘a’ (stored as integer 97) (preferred)</em></p></li><li><p>使用整型数值 初始化：</p><p><code>char cha1{97};</code> <em>// initialize with integer 97 (‘a’) (not preferred)</em></p></li></ol></li></ul><hr><ul><li><p><strong>输出字符型</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch1&#123; <span class="string">'a'</span> &#125;; <span class="comment">// (preferred)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ch1; <span class="comment">// cout prints a character</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">char</span> ch2&#123; <span class="number">98</span> &#125;; <span class="comment">// code point for 'b' (not preferred)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ch2; <span class="comment">// cout prints a character</span></span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">'c'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******结果********/</span></span><br><span class="line">abc</span><br></pre></td></tr></table></figure><p>【注意】固定宽度我的整型：<code>int8_t</code>类型，是被当做有符号的char类型对待的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int8_t</span> a&#123; <span class="number">97</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200401174509017.png" alt="image-20200401174509017"></p></li></ul><hr><ul><li><p><strong>通过类型转换将字符打印为整数</strong></p><ul><li>一种(糟糕的)方法是将char赋值给一个整数，然后输出这个整数:</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch&#123;<span class="number">97</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> a&#123;ch&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果*********/</span></span><br><span class="line"><span class="number">97</span></span><br></pre></td></tr></table></figure><hr><ul><li><p>另一种较好的方法就是：<strong><em>type case</em>：强制类型转换</strong>，其格式为：</p><p><code>static_cast&lt;new_type&gt;(expression)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch1&#123;<span class="number">97</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> ch2&#123;<span class="string">'a'</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt; (ch1) &lt;&lt;<span class="string">'\n'</span>; <span class="comment">//强制类型转换</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt; (ch2) ; <span class="comment">//强制类型转换</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********结果********/</span></span><br><span class="line"><span class="number">97</span></span><br><span class="line"><span class="number">97</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，变量ch仍然是一个char，并且仍然保持相同的值。知识在本次输出时，输出的是整型类型的值。</p></li></ul><hr><p><strong><u>知识点</u>：</strong></p><blockquote><p>当您看到c++语法(不包括预处理器)使用<em>尖括号&lt;&gt;</em>时，<strong>尖括号之间的内容很可能是类型</strong>。这就是c++处理需要参数化类型的概念的典型方式。</p></blockquote></li></ul><hr><ul><li><p>【<strong>注意</strong>】：std::cin将<strong>允许您输入多个字符</strong>。<strong>然而，变量ch只能包含一个字符</strong>。因此，只有第一个输入字符被提取到变量ch中，<strong>其余的用户输入留在std::cin使用的输入缓冲区中，可以通过后续调用std::cin来提取。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Input a keyboard character: "</span>; <span class="comment">// assume the user enters "abcd" (without quotes)</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">char</span> ch&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; ch; <span class="comment">// ch = 'a', "bcd" is left queued.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="string">" has ASCII code "</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(ch) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Note: The following cin doesn't ask the user for input, it grabs queued input!</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; ch; <span class="comment">// ch = 'b', "cd" is left queued.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="string">" has ASCII code "</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(ch) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200401202849307.png" alt="image-20200401202849307">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200401202925333.png" alt="image-20200401202925333"></p></li></ul><hr><ul><li><p><strong><code>char</code>的大小、范围以及默认的sign(符号)</strong></p><ul><li><p><strong>size</strong>：C++中char类型通常为：1 byte；</p></li><li><p><strong>sign</strong>：默认情况下，char类型是 signed 或者 unsigned；</p><blockquote><p>如果使用字符来保存ASCII字符，则不需要指定符号(因为有符号和无符号字符都可以保存0到127之间的值)。</p><hr><p>一个有符号的字符可以容纳-128到127之间的数字；无符号字符可以容纳0到255之间的数字。</p></blockquote></li></ul></li></ul><hr><ul><li><p><strong>转义符：escape sequences</strong></p><p>转义符<strong>以 “\” 开头</strong>,<strong>后面跟着一个 字母 或 数字</strong>；</p><table><thead><tr><th align="left">Name</th><th align="left">Symbol</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">Alert</td><td align="left">\a</td><td align="left">Makes an alert, such as a beep</td></tr><tr><td align="left">Backspace</td><td align="left">\b</td><td align="left">Moves the cursor back one space</td></tr><tr><td align="left">Formfeed</td><td align="left">\f</td><td align="left">Moves the cursor to next logical page</td></tr><tr><td align="left">Newline</td><td align="left">\n</td><td align="left">Moves cursor to next line</td></tr><tr><td align="left">Carriage return</td><td align="left">\r</td><td align="left">Moves cursor to beginning of line</td></tr><tr><td align="left">Horizontal tab</td><td align="left">\t</td><td align="left">Prints a horizontal tab</td></tr><tr><td align="left">Vertical tab</td><td align="left">\v</td><td align="left">Prints a vertical tab</td></tr><tr><td align="left">Single quote</td><td align="left">\’</td><td align="left">Prints a single quote</td></tr><tr><td align="left">Double quote</td><td align="left">\”</td><td align="left">Prints a double quote</td></tr><tr><td align="left">Backslash</td><td align="left">\</td><td align="left">Prints a backslash.</td></tr><tr><td align="left">Question mark</td><td align="left">?</td><td align="left">Prints a question mark. No longer relevant. You can use question marks unescaped.</td></tr><tr><td align="left">Octal number</td><td align="left">(number)</td><td align="left">Translates into char represented by octal (<em>octal</em>：8进制)</td></tr><tr><td align="left">Hex number</td><td align="left">\x(number)</td><td align="left">Translates into char represented by hex number(<em>hex</em>：16进制)</td></tr></tbody></table></li></ul><hr><ul><li><p><strong>单引号</strong> VS <strong>双引号</strong> 的区别</p><ul><li><p>单个字符总是放在 单引号 中。(e.g. ‘a’, ‘+’, ‘5’)。<code>char</code>类型的只能接收一个符号(e.g. 字母 a, + , 数字 5)</p><p><code>char ch(&#39;56&#39;);</code> <em>// a char can only hold one symbol</em></p></li><li><p>放在双引号(例如“Hello, world!”)之间的文本称为<strong>字符串<em>string</em></strong>。一个 <em>string</em>是连续字符的集合(因此，一个字符串可以包含多个符号)。</p><p><code>std::cout &lt;&lt; &quot;hello world&quot; ;</code> <em>// “Hello, world!” is a string literal</em></p></li></ul><hr><p>知识点：<strong><em>string</em>类型在C++中，不是基本数据类型</strong></p></li></ul><hr><ul><li><em>char</em>的其他类型：<strong><code>wchar_t</code>、<code>char16_t</code>、<code>char32_t</code></strong><ul><li><code>wchar_t</code>：应避免使用(除非是在windows API接口时使用)。它的大小是在实现时才确定的，它并不可靠。</li><li><code>char16_t</code>、<code>char32_t</code>在C++11中添加，以提供对16位和32位Unicode字符的显式支持。在c++ 20中添加了<code>char8_t</code>。</li></ul></li></ul><hr><h2 id="4-12-字面常量"><a href="#4-12-字面常量" class="headerlink" title="4.12 字面常量"></a>4.12 字面常量</h2><ul><li><p><strong><em>constant</em></strong>：是固定的值，不可被改变。</p><blockquote><p>C++中有两种<em>constant</em>：<strong>字面常量</strong>、<strong>符号常量</strong>。</p></blockquote></li></ul><ul><li><p><strong>literal constant：字面常量</strong>，简称：<strong>literal</strong>。是直接将值插入代码中的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="number">5</span>; <span class="comment">//5是一个整型literal</span></span><br><span class="line"><span class="keyword">bool</span> mynameisqin&#123;<span class="literal">true</span>&#125;; <span class="comment">//true 是一个布尔型literal</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="number">3.4</span>; <span class="comment">//3.4 是一个双精度浮点型的literal</span></span><br></pre></td></tr></table></figure><p>上面这些都是常数，因为他们不能动态的被改变。</p><p>就像对象分类型一样，常量也是有类型的：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200402103515525.png" alt="常量的类型"></p></li></ul><hr><ul><li><p><strong>literal 的后缀</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200402103708146.png" alt="literal 的后缀"></p><p>example：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> value1 &#123;<span class="number">5u</span>&#125;; <span class="comment">//5的类型是 unsigned int</span></span><br><span class="line"><span class="keyword">long</span> value2 &#123;<span class="number">6L</span>&#125;; <span class="comment">// 6的类型是 long</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*默认情况，浮点类型是 double ；如果想定义其为float类型，可以添加后缀类实现*/</span></span><br><span class="line"><span class="keyword">float</span> f1 &#123;<span class="number">5.0f</span>&#125;; <span class="comment">//5.0 的类型是 float</span></span><br><span class="line"><span class="keyword">float</span> f2 &#123;<span class="number">4.1</span>&#125;; <span class="comment">//4.1的类型是   double</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>string literals</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world"</span>; <span class="comment">//这种是 C分割的 string literal</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello"</span> <span class="string">" world"</span>; <span class="comment">//C++将会把它们连接起来</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>Scientific notation for floating point literals：浮点型literal 的科学计数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> pi &#123;<span class="number">3.14159</span>&#125;; <span class="comment">//3.14159是一种一般形式</span></span><br><span class="line"><span class="keyword">double</span> avogadro &#123;<span class="number">6.02e23</span>&#125;; <span class="comment">//6.02e23 是双精度浮点型literal 的科学计数法形式</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>Octal and hexadecimal literals：八进制 &amp; 十六进制 的 literal</strong></p><ol><li><p><strong>八进制：octal</strong></p><p>八进制是以8为底，它可用的数为： 0, 1, 2, 3, 4, 5, 6, 7。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200402105451740.png" alt="八进制与十进制的对应"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*八进制的前缀是，数字“0”，不是字母“o”*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123;<span class="number">012</span>&#125;; <span class="comment">//"0"表示这个数字是八进制数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr></li><li><p><strong>十六进制：hexadecimal</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200402110146793.png" alt="十六进制与十进制的对应"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*十六进制数的前缀是：数字0和字母x，即 0x*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x&#123;<span class="number">0xF</span>&#125;; <span class="comment">//0x表示这个数是十六进制数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>十六进制通常用来<strong>表示内存地址</strong> 或 <strong>内存中的原始值</strong>。</p><blockquote><p>因为相对于二进制，16进制表示起来更加简洁。如：二进制的数<code>0011 1010 0111 1111 1001 1000 0010 0110</code>，单用16进制表示的话，就是<code>3A7F 9826</code></p></blockquote><hr><p>在C++14之前，无法给变量赋一个二进制的literal，但是，16进制对为我们提供了一个有用的解决方法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bin&#123;&#125;;</span><br><span class="line">    bin = <span class="number">0x01</span>; <span class="comment">// assign binary 0000 0001 to the variable</span></span><br><span class="line">    bin = <span class="number">0x02</span>; <span class="comment">// assign binary 0000 0010 to the variable</span></span><br><span class="line">    bin = <span class="number">0x04</span>; <span class="comment">// assign binary 0000 0100 to the variable</span></span><br><span class="line">    bin = <span class="number">0x08</span>; <span class="comment">// assign binary 0000 1000 to the variable</span></span><br><span class="line">    bin = <span class="number">0x10</span>; <span class="comment">// assign binary 0001 0000 to the variable</span></span><br><span class="line">    bin = <span class="number">0x20</span>; <span class="comment">// assign binary 0010 0000 to the variable</span></span><br><span class="line">    bin = <span class="number">0x40</span>; <span class="comment">// assign binary 0100 0000 to the variable</span></span><br><span class="line">    bin = <span class="number">0x80</span>; <span class="comment">// assign binary 1000 0000 to the variable</span></span><br><span class="line">    bin = <span class="number">0xFF</span>; <span class="comment">// assign binary 1111 1111 to the variable</span></span><br><span class="line">    bin = <span class="number">0xB3</span>; <span class="comment">// assign binary 1011 0011 to the variable</span></span><br><span class="line">    bin = <span class="number">0xF770</span>; <span class="comment">// assign binary 1111 0111 0111 0000 to the variable</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><hr><ul><li><p><strong>C++14中 二进制的literal</strong></p><p>在C++14中，使用数字0和字母b，即“0b”。给变量分配二进制的literal：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bin&#123;&#125;;</span><br><span class="line">    bin = <span class="number">0b1</span>;  <span class="comment">// assign binary 0000 0001 to the variable</span></span><br><span class="line">    bin = <span class="number">0b11</span>; <span class="comment">// assign binary 0000 0011 to the variable</span></span><br><span class="line">    bin = <span class="number">0b1010</span>; <span class="comment">// assign binary 0000 1010 to the variable</span></span><br><span class="line">    bin = <span class="number">0b11110000</span>; <span class="comment">// assign binary 1111 0000 to the variable</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*但是二进制数比较长，所以用“ ' ”来当做分隔符，便于读认*/</span></span><br><span class="line">#Include &lt;iostream&gt;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> bin &#123;<span class="number">0b1011'0010</span>&#125;;</span><br><span class="line">     <span class="keyword">long</span> value &#123;<span class="number">0'132'673'462</span>&#125;;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>输出 十进制、八进制、十六进制、二进制数</strong></p><blockquote><p>decimal、octal、hexadecimal、binary</p></blockquote><p>C++默认输出是十进制数，但是我们可以转换输出格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x &#123;<span class="number">12</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt;<span class="string">'\n'</span>; <span class="comment">//默认十进制</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::hex&lt;&lt;x &lt;&lt;<span class="string">'\n'</span>; <span class="comment">//16进制</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt;<span class="string">'\n'</span>; <span class="comment">//x变量的值现在被转换为16进制了</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::oct&lt;&lt; x &lt;&lt;<span class="string">'\n'</span>; <span class="comment">//8进制</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::dec&lt;&lt; x &lt;&lt;<span class="string">'\n'</span>; <span class="comment">//十进制</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****输出*******/</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line">c</span><br><span class="line">c</span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><hr><p><strong>输出二进制</strong>：输出二进制数比较麻烦一点。<strong>需要添加头文件：<code>&lt;bitset&gt;</code></strong>。</p><blockquote><p><code>std::bitset&lt;num&gt;</code>：表示我们存储的位数为num。它可以被初始化成一个 无符号整数值(可以使10，8，16，2进制的形式)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt; //for std::bitset</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// std::bitset&lt;8&gt; means we want to store 8 bits</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;8&gt; bin1&#123; <span class="number">0b1100'0101</span> &#125;; <span class="comment">// binary literal for binary 1100 0101</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;8&gt; bin2&#123; <span class="number">0xC5</span> &#125;; <span class="comment">// hexadecimal literal for binary 1100 0101</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; bin1 &lt;&lt; <span class="string">' '</span> &lt;&lt; bin2 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;4&gt;&#123; <span class="number">0b1010</span> &#125; &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// we can also print from std::bitset directly(输出完之后，被抛弃)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出*/</span></span><br><span class="line"><span class="number">11000101</span> <span class="number">11000101</span></span><br><span class="line"><span class="number">1010</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="4-13-const-constexpr-symbolic-constants"><a href="#4-13-const-constexpr-symbolic-constants" class="headerlink" title="4.13 const, constexpr, symbolic constants"></a>4.13 const, constexpr, symbolic constants</h2><p><strong>常量 变量：其值不能被修改，情形修改会出错</strong></p><ul><li><p>使用<strong>关键字<code>const</code></strong>，来表示该变量是常量：</p><blockquote><p>放在变量类型的前面、后面 都可以</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> gravity &#123;<span class="number">9.8</span>&#125;; <span class="comment">//放在类型的前面【推荐】</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> sidesInSquare &#123;<span class="number">4</span>&#125;; <span class="comment">//放在类型后面【不推荐】</span></span><br></pre></td></tr></table></figure></li></ul><hr><p><red><strong>常量变量(const variable)</strong>必须在定义时要初始化(即要赋值给他们)。赋值完成，它的值就不能被改变.</red></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******常量变量的值被改变*************/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> a &#123;<span class="number">5.0</span>&#125;;</span><br><span class="line">a = <span class="number">1.0</span>;  <span class="comment">//编译出错，因为常量变量的值被改变</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******常量变量不初始化********/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> a; <span class="comment">//compiler error, must be initialized upon definition</span></span><br></pre></td></tr></table></figure><hr><ul><li><p><strong>runtime VS compile time constants</strong></p><blockquote><p><strong>runtime</strong>：程序运行时；</p><p><strong>compile time</strong>：编译器运行时。</p></blockquote><ul><li><strong>runtime constants</strong>：初始化值只能在运行时解析的常量；</li><li><strong>compile-time constants</strong>：初始化值可以在编译时解析的；</li></ul><p>当您声明一个const变量时，编译器将隐式地跟踪它是运行时常量还是编译时常量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">getNumberOfBits</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> numberOfBits&#123; <span class="number">3</span> &#125;; <span class="comment">// Compile-time constant</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;numberOfBits&gt; b&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> otherNumberOfBits&#123; getNumberOfBits() &#125;; <span class="comment">// Run-time constant</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;otherNumberOfBits&gt; b2&#123;&#125;; <span class="comment">// Error[因为此时需要的是编译时常量，而不是运行时常量]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>常量表达式：constexpr</strong></p><p>为了提供更多的特性，c++ 11引入了新的<strong>关键字constexpr，它确保常量必须是 “编译时常量”:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">double</span> gravity &#123;<span class="number">9.8</span>&#125;; <span class="comment">//正确，9.8是编译时的字面常量</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> sum &#123;<span class="number">4</span>+<span class="number">5</span>&#125;; <span class="comment">//正确，4+5的值时编译时的字面常量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"enter your age:"</span>;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; age;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> myage &#123;age&#125;; <span class="comment">//错误，因为“age”是一个运行时常量</span></span><br></pre></td></tr></table></figure></li></ul><hr><p>【小结】：常量变量必须在定义时，对它初始化。</p><ul><li>当一个变量的值需要是 编译时常量时，推荐使用<code>constexpr</code>来声明它。</li><li>当一个变量的值需要是 运行时常量时，推荐使用<code>const</code>来声明它。</li></ul><hr><ul><li><p><strong>符号常量：symbolic constants</strong></p><p><strong>symbolic constant</strong>：是 字面常量(literal constant)的值 的名字。</p><hr><p>两种方法声明符号常量：</p><ol><li><p>使用<strong>“宏(macro)”</strong>定义：【不推荐】</p><p><code>#define identifier substitution_text</code></p><p>如：<code>#define a 10;</code></p></li><li><p>使用关键字<code>constexpr</code>变量：【推荐】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> maxstudentperclass &#123;<span class="number">30</span>&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> maxnamelength &#123;<span class="number">30</span>&#125;;</span><br></pre></td></tr></table></figure></li></ol></li></ul><hr><ul><li><p><strong>在多文件程序中使用符号常量</strong></p><p>在许多应用程序中，需要在整个代码中使用给定的符号常量(而不仅仅是在一个位置)。这些参数可以包括物理或数学常数(如pi或阿伏伽德罗常数)，或特定于应用程序的“调优”值(如摩擦系数或重力系数)。<strong>与其每次需要时都重新定义它们，不如在中心位置声明一次并在需要的地方使用它们。</strong>这样，如果你需要改变它们，你只需要在一个地方改变它们。</p><p>有很多种方法来实现它，这里使用比较简单的一种：</p><ol><li>首先，<strong>创建一个头文件</strong>来写相关的常量；</li><li>在这个头文件中，<strong>声明一个名称空间</strong>；</li><li>将你要用到的<strong>常量写在这个命名空间</strong>中；</li><li>在你需要这些常量的时候，<strong><code>#include</code>这个头文件</strong>。</li></ol><p>example：</p><ul><li><p>constants.h (C++11/14):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONSTANTS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONSTANTS_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//define your own namespace to hold constansts</span></span><br><span class="line"><span class="keyword">namespace</span> constants</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">double</span> pi &#123;<span class="number">3.14159</span>&#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">double</span> avogadro &#123;<span class="number">6.0221413e23</span>&#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">double</span> my_gravity &#123;<span class="number">9.2</span>&#125;;</span><br><span class="line">    <span class="comment">//.........other related constants</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li><li><p>In C++17, prefer “inline constexpr” instead:</p><p>constants.h (C++17 or newer):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONSTANTS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONSTANTS_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// define your own namespace to hold constants</span></span><br><span class="line"><span class="keyword">namespace</span> constants</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> pi &#123;<span class="number">3.14159</span>&#125;;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> avogadro &#123; <span class="number">6.0221413e23</span> &#125;;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> my_gravity &#123; <span class="number">9.2</span> &#125;; <span class="comment">// m/s^2 -- gravity is light on this planet</span></span><br><span class="line">    <span class="comment">// ... other related constants</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li></ul><p>使用<strong>“作用域解析符<code>::</code>”</strong>,在其他文件访问你的常量：</p><p><em>main.cpp</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"constants.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"enter a radius: "</span>;</span><br><span class="line">    <span class="keyword">int</span> radius&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; radius;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> circumference &#123;<span class="number">2.0</span>*radius*constants::pi&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"the circumference is: "</span> &lt;&lt;circumference &lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;p center large&gt;&lt;red&gt;LearnCpp chapter4&lt;/red&gt;&lt;/p&gt;&lt;/center&gt;&lt;center&gt;&lt;red&gt;https://www.learncpp.com&lt;/red&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C/C++" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"/>
    
    
      <category term="C/C++" scheme="https://longlongqin.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>LearnCpp chapter3</title>
    <link href="https://longlongqin.github.io/archives/5fc07ec4.html"/>
    <id>https://longlongqin.github.io/archives/5fc07ec4.html</id>
    <published>2020-03-30T05:59:58.000Z</published>
    <updated>2020-04-19T14:38:29.545Z</updated>
    
    <content type="html"><![CDATA[<center><p center large><red>LearnCpp-chapter3</red></p></center><center><red>https://www.learncpp.com</red></center><p>未完待续~~</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;p center large&gt;&lt;red&gt;LearnCpp-chapter3&lt;/red&gt;&lt;/p&gt;&lt;/center&gt;&lt;center&gt;&lt;red&gt;https://www.learncpp.com&lt;/red&gt;&lt;/center&gt;&lt;p&gt;未完待续~~&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C/C++" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"/>
    
    
      <category term="C/C++" scheme="https://longlongqin.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>LearnCpp chapter2</title>
    <link href="https://longlongqin.github.io/archives/28c74e52.html"/>
    <id>https://longlongqin.github.io/archives/28c74e52.html</id>
    <published>2020-03-26T09:07:50.000Z</published>
    <updated>2020-04-19T14:38:29.702Z</updated>
    
    <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapter2</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h2 id="2-1-函数"><a href="#2-1-函数" class="headerlink" title="2.1 函数"></a>2.1 函数</h2><p>当你读一本书的时候，突然有人给你打电话。然后你就用“书签”夹在当前阅读位置，去接电话。等你电话接完，再回到你放书签的那个地方继续读书。</p><p><strong>函数调用(function call)</strong>是一个表达式。它告诉CPU中断当前函数并在这里“放一个书签”，然后执行另一个函数(就是函数调用中提及的那个函数)。当调用结束后，CPU就返回到“书签”的位置，然后再继续执行。</p><blockquote><p><strong>caller</strong>：发起函数调用的函数叫做caller；</p><p><strong>callee(called function)</strong>：被调用的函数叫做callee(called function)。</p></blockquote><p><strong>int main()的返回值</strong>：</p><p>在int main()函数最后，会有返回值，这个值是返回到操作系统的，为了让操作系统知道这个程序执行成功与否。main函数的返回值，有一个特定名字叫做：<strong><u>status code （状态码）</u></strong></p><blockquote><p>一般 <code>return 0;</code> 表示程序执行成功。</p><p>返回非零值，表示程序执行错误。</p></blockquote><p>【<strong>Note</strong>】：<strong>C++规定，main函数必须是int型的。即： int main()</strong></p><h2 id="2-3-函数的形参与实参"><a href="#2-3-函数的形参与实参" class="headerlink" title="2.3 函数的形参与实参"></a>2.3 函数的形参与实参</h2><ul><li><p><strong>形参(parameter)</strong>：是指函数定义中参数；(形参初始化是通过调用者传来的值(即，实参)来初始化的 )</p><p><strong>实参(argument)</strong>：函数调用时的实际参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printValues</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">//函数定义时的参数x,y，即这里的x,y是形参</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printValues(<span class="number">6</span>, <span class="number">7</span>); <span class="comment">//调用函数。即，6和7是实参</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>实参与形参如何一起工作？</strong></p><p>当调用一个函数时，函数所有的parameters都被创建为变量，并且每个arguments的值都被复制到匹配的parameters中。这个过程称为<strong>pass by value(按值传递)</strong>。</p></li><li><p><strong>关于函数参数求值顺序的警告</strong></p><p>在C++中，没有规定实参匹配的顺序（顺序：从左→右，还是从右→左），因为匹配顺序不重要。</p><p>但是，如果实参是函数调用，那就需要注意了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someFunction(a(), b()); <span class="comment">// a() or b() may be called first</span></span><br></pre></td></tr></table></figure><ul><li>是从右→左，还是从右→左：<strong>取决于a()和b()的功能</strong>。</li></ul><p>如果你想要规定谁先的话，你可以显示的规定匹配顺序，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> avar&#123; a() &#125;; <span class="comment">// a() will always be called first</span></span><br><span class="line"><span class="keyword">int</span> bvar&#123; b() &#125;; <span class="comment">// b() will always be called second</span></span><br><span class="line"> </span><br><span class="line">someFunction(avar, bvar); <span class="comment">// it doesn't matter whether avar or bvar are copied first because they are just values</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="2-4-局部范围"><a href="#2-4-局部范围" class="headerlink" title="2.4 局部范围"></a>2.4 局部范围</h2><ul><li><strong>局部变量Local variables</strong>：函数的形参，和它内部定义的变量 属于“局部变量”。如：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// function parameters x and y are local variables</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> z&#123; x + y &#125;; <span class="comment">// z is a local variable too</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>局部变量生命周期</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// x and y are created and enter scope here</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// x and y are visible/usable within this function only</span></span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125; <span class="comment">// y and x go out of scope and are destroyed here</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a&#123; <span class="number">5</span> &#125;; <span class="comment">// a is created, initialized, and enters scope here</span></span><br><span class="line">    <span class="keyword">int</span> b&#123; <span class="number">6</span> &#125;; <span class="comment">// b is created, initialized, and enters scope here</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// a and b are usable within this function only</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(a, b) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// calls function add() with x=5 and y=6</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// b and a go out of scope and are destroyed here</span></span><br></pre></td></tr></table></figure><blockquote><p>执行过程：</p><ol><li><p>程序开始执行于main()函数；</p></li><li><p>main()函数的变量a被创建并赋值为5；（初始化）★</p></li><li><p>main()函数的变量b被创建并赋值为6；（初始化）★</p></li><li><p>函数add()被调用，并传入实参5，6；</p></li><li><p>add()函数的变量x被创建，并初值为5;（初始化）★</p></li><li><p>add()函数的变量y被创建，并初值为6;（初始化）★</p></li><li><p>操作符“+”计算表达式”x+y”，产生值11；</p></li><li><p>add函数将值11复制回调用者main()函数；</p></li><li><p>add函数的x、y被摧毁；★</p></li><li><p>main()函数在控制台上打印出11；</p></li><li><p>main()函数返回0到操作系统；</p></li><li><p>main()函数的a、b被摧毁。★</p></li></ol></blockquote><p>由此可知，<strong>局部变量的生命周期</strong>：是从他开始<u>被创建</u>（如上述的第2步，变量a被创建）一直到执行完这个它所在的函数（如上述的第9步）被摧毁。</p><p><strong>【Note】</strong>：变量的创建和摧毁发生在程序的<strong>运行期间（runtime）</strong>。所以生命周期是一个runtime属性。</p></li><li><p><strong>局部范围</strong></p><p><strong>标识符的范围</strong>决定了在源代码中标识符可以被访问的位置。范围是一个<strong>编译期间(compile-time)</strong>的属性。（当使用的标识符不在范围内时，编译器会报错）</p><p><strong>局部变量的范围</strong>：开始于它的<u>定义</u>，结束于<u>定义它们的花括号集合的末尾</u>。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// x is not in scope anywhere in this function</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello!\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// x can not be used here because it's not in scope yet</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> x&#123; <span class="number">0</span> &#125;; <span class="comment">// x enters scope here and can now be used</span></span><br><span class="line"> </span><br><span class="line">    doSomething();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// x goes out of scope here and can no longer be used</span></span><br></pre></td></tr></table></figure><h2 id="2-5-为什么要用函数"><a href="#2-5-为什么要用函数" class="headerlink" title="2.5 为什么要用函数"></a>2.5 为什么要用函数</h2></li></ul><p><strong>使用函数的优势</strong>：</p><ul><li><strong>有组织性Organization</strong>：随着程序越来越复杂，若将全部的代码都写在main()函数中，势必会增加复杂性。一个函数就像一个小型程序。将它与main函数分开写，我们就不必去考其余代码。</li><li><strong>可重用性Reusability</strong>：一个函数可以被调用无数次。就可以避免这种情况：如果写在main函数中，要调用n次这个功能，就要重新写这个功能n次。</li><li><strong>便于测试Testing</strong>：因为函数减少了代码冗余，所以首先要测试的代码就更少了。另外，因为函数是自包含的，所以一旦我们测试了一个函数以确保它可以工作，我们就不需要再次测试它，除非我们修改它。这减少了我们必须一次测试的代码量，使得查找bug(或者在第一时间避免bug)变得更加容易。</li><li><strong>可扩展性Extensibility</strong>：</li><li><strong>抽象化Abstraction</strong>：在每次用这个函数时，我们只需要知道它的名字。输入和输出。不必知道它是如何工作的。</li></ul><p><strong>如何高效的使用函数？</strong></p><ul><li>在一个程序中<u>出现多次的语句</u>通常应该构成一个函数。例如，如果我们以相同的方式多次读取来自用户的输入，那么这就是一个很好的函数候选。如果我们以相同的方式输出多次，这也是一个很好的候选函数。</li><li>一个函数通常应该执行一个(且仅一个)任务。</li><li>当一个函数变得太长、太复杂或难以理解时，可以将其分解为多个子函数。这就是所谓的<strong>重构refactoring</strong>。</li></ul><h2 id="2-6-空白与基本格式"><a href="#2-6-空白与基本格式" class="headerlink" title="2.6 空白与基本格式"></a>2.6 空白与基本格式</h2><h3 id="空白"><a href="#空白" class="headerlink" title="空白"></a>空白</h3><p><strong>空白Whitespace</strong>：是一个术语，指的是用于格式化目的的字符。在c++中，这主要指<strong>空格</strong>、<strong>制表符(tab)</strong>和<strong>换行</strong>。c++编译器通常会忽略空白，只有少数例外(在处理文本时)。因此，<strong>我们说c++是一种与空白无关的语言。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*下面这三个都是一样的作用*/</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>               &lt;&lt;            <span class="string">"Hello world!"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span></span><br><span class="line">&lt;&lt; <span class="string">"Hello world!"</span>;</span><br></pre></td></tr></table></figure><p>【注意】</p><ul><li>在<strong>文本</strong>中，不允许换行：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这种是不被允许的</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello</span></span><br><span class="line"><span class="string">    world!"</span> ;</span><br></pre></td></tr></table></figure><ul><li><p>但是这种情况是可以的：文本只是被空白(空格、制表符(tab)、换行)分离，他将会被连接：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的hello与world都是被双引号包含起来的</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello "</span></span><br><span class="line">     <span class="string">"world!"</span>; <span class="comment">// prints "Hello world!"</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h3><ol><li><p><strong>缩进(indentation)</strong>可以用：<strong>空格spaces</strong>或者<strong>tabs（制符表）</strong>。</p><blockquote><p>如果用制符表，建议将其调整为4个空格的缩进，3个也可以。</p></blockquote></li><li><p><strong>大花括号（brace）</strong>：</p><ul><li><p>Google中的C++风格：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>另一种风格：这一种不容易出错，更容易找出花括号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在大花括号中的每条语句，应该从其所在花括号算起隔开一个tab的距离，开始写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!\n"</span>;       <span class="comment">// tabbed in one tab (4 spaces)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Nice to meet you.\n"</span>;  <span class="comment">// tabbed in one tab (4 spaces)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>每一行的字符不要过长，一般不超过80个字符</p></li><li><p>如果一行别操作符(如，&lt;&lt; 、+)分割(split)。这个操作符应该被卸载下一行的开头：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">3</span> + <span class="number">4</span></span><br><span class="line">    + <span class="number">5</span> + <span class="number">6</span></span><br><span class="line">    * <span class="number">7</span> * <span class="number">8</span>;</span><br></pre></td></tr></table></figure></li><li><p>通过对齐值或注释或在代码块之间添加间距，使用空白使代码更易于阅读。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不易读</span></span><br><span class="line">cost = <span class="number">57</span>;</span><br><span class="line">pricePerItem = <span class="number">24</span>;</span><br><span class="line">value = <span class="number">5</span>;</span><br><span class="line">numberOfItems = <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//易读</span></span><br><span class="line">cost          = <span class="number">57</span>;</span><br><span class="line">pricePerItem  = <span class="number">24</span>;</span><br><span class="line">value         = <span class="number">5</span>;</span><br><span class="line">numberOfItems = <span class="number">17</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不易读</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!\n"</span>; <span class="comment">// cout lives in the iostream library</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"It is very nice to meet you!\n"</span>; <span class="comment">// these comments make the code hard to read</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Yeah!\n"</span>; <span class="comment">// especially when lines are different lengths</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//易读</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!\n"</span>;                  <span class="comment">// cout lives in the iostream library</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"It is very nice to meet you!\n"</span>;  <span class="comment">// these comments are easier to read</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Yeah!\n"</span>;                         <span class="comment">// especially when all lined up</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不易读</span></span><br><span class="line"><span class="comment">// cout lives in the iostream library</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!\n"</span>;</span><br><span class="line"><span class="comment">// these comments make the code hard to read</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"It is very nice to meet you!\n"</span>;</span><br><span class="line"><span class="comment">// especially when all bunched together</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Yeah!\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//易读</span></span><br><span class="line"><span class="comment">// cout lives in the iostream library</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!\n"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// these comments are easier to read</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"It is very nice to meet you!\n"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// when separated by whitespace</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Yeah!\n"</span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-7-提前声明与定义"><a href="#2-7-提前声明与定义" class="headerlink" title="2.7 提前声明与定义"></a>2.7 提前声明与定义</h2><p>一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of 3 and 4 is: "</span> &lt;&lt; add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在vs 2013中运行，会出现：</p><p><code>add.cpp(5) : error C3861: &#39;add&#39;: identifier not found</code></p><p><strong>原因：</strong>因为编译器是按照顺序进行编译的。当编译器在main函数的第5行中调用add函数，他不知道add是什么。因为目前为止还没有定义add函数（因为add函数的定义在第9行）</p><hr><p><strong>如何解决呢？</strong></p><ol><li><p>法一：<strong>调整代码顺序</strong>：让被调用的函数在调用者之前【在复杂程序中，不实用】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of 3 and 4 is: "</span> &lt;&lt; add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>如果在一个复杂的程序中，会调用很多函数，还有嵌套型的调用。如果去一个个个去找出调用顺序，然后去调整代码。这样是很乏味低效的。</strong></p></blockquote></li><li><p>法二<strong>[推荐]</strong>：<strong>提前声明forward declaration</strong>：在使用函数之前，先声明它。（然后就不用关注代码实现的顺序了）</p><blockquote><p>提前向声明<strong>允许我们在实际定义标识符之前告诉编译器标识符的存在。</strong></p></blockquote><p>为了编写一个函数的提前向声明，我们使用一个称为<strong>函数原型(function prototype)</strong>的声明语句。函数原型包括：函数的 返回<strong>类型</strong>、<strong>名字</strong>、<strong>形参</strong>，以<strong>分号(semicolon)</strong>结束。但是不包含函数<strong>主体(function body)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="comment">// forward declaration of add() (using a function prototype)</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of 3 and 4 is: "</span> &lt;&lt; add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// this works because we forward declared add() above</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// even though the body of add() isn't defined until here</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="忘记定义函数主题"><a href="#忘记定义函数主题" class="headerlink" title="忘记定义函数主题"></a>忘记定义函数主题</h3><ol><li><p>如果<strong>声明</strong>了函数，但<strong>没定义</strong>函数，而且这个函数<strong>没有被调用</strong>，那么这个程序<strong>可以被编译&amp;运行</strong>；</p></li><li><p>如果<strong>声明</strong>了函数，但<strong>没定义</strong>函数，而且而且这个函数<strong>有被调用</strong>，那么这个程序<strong>可以被编译</strong>，但<strong>链接会出错</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="comment">// forward declaration of add() using function prototype</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of 3 and 4 is: "</span> &lt;&lt; add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// note: No definition for function add</span></span><br></pre></td></tr></table></figure><p>上面程序在visual studio 中，会出现：编译成功，链接失败</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Compiling...</span><br><span class="line">add.cpp</span><br><span class="line">Linking...</span><br><span class="line">add.obj : error LNK2001: unresolved external symbol &quot;int __cdecl add(int,int)&quot; (?add@@YAHHH@Z)</span><br><span class="line">add.exe : fatal error LNK1120: 1 unresolved externals</span><br></pre></td></tr></table></figure></li></ol><h3 id="声明-VS-定义"><a href="#声明-VS-定义" class="headerlink" title="声明 VS. 定义"></a>声明 VS. 定义</h3><ul><li><p><strong>定义(define)</strong>：实现(函数或类型）或者是 实例化(对于变量）标识符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// implements function add()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> z&#123; x + y &#125;; <span class="comment">// instantiates variable z</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于<strong>链接器(linker)</strong>来说<strong>定义（define）</strong>是必要的的。</p></blockquote></li></ul><h4 id="单定义规则"><a href="#单定义规则" class="headerlink" title="单定义规则"></a>单定义规则</h4><p><strong>单定义规则（one definition rule）</strong>简称：<strong>ODR</strong>：在C++中非常有名的规则，主要分三部分：</p><ol><li><p>在给定的文件中（这里翻译不准确），每个函数、对象、类型、模板<u>只能有一次定义</u>。</p></li><li><p>在整个程序中，一个对象或者函数只能被定义一次；</p></li><li><p>类型、模板、内置函数、变量 被允许在不同的文件中有相同的定义。</p><hr></li></ol><p><strong>违背第1条，将会使编译器发出重新定义错误；</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// violation part1 of ODR, we've already defined function add</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> x; <span class="comment">// violation of ODR, we've already defined x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在visual studio中，会出现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">project3.cpp(9): error C2084: function &#39;int add(int,int)&#39; already has a body</span><br><span class="line">project3.cpp(3): note: see previous definition of &#39;add&#39;</span><br><span class="line">project3.cpp(16): error C2086: &#39;int x&#39;: redefinition</span><br><span class="line">project3.cpp(15): note: see declaration of &#39;x&#39;</span><br></pre></td></tr></table></figure></li></ul><p><strong>违背第2条，将会使连接器发出重新定义的错误；</strong></p><p><strong>违背第3条，将会产生未定义的行为。</strong></p><hr><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p><strong>声明(declaration)</strong>：是一个语句。它告诉编译器这里存在一个标识符和它的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="comment">// tells the compiler about a function named "add" that takes two int parameters and returns an int.  No body!</span></span><br><span class="line"><span class="keyword">int</span> x; <span class="comment">// tells the compiler about an integer variable named x</span></span><br></pre></td></tr></table></figure><blockquote><p>对<strong>编译器(complier)</strong>而言<strong>声明(declaeation)</strong>是必要的。</p></blockquote><p>在C++中，所有的<strong>定义</strong>也用作<strong>声明</strong>。上述例子中的<code>int x</code>是 定义，也是声明。</p><p>多数情况下，<strong>定义</strong>符合我们的目的，因为定义能同时满足“编译器”和“链接器”的要求。</p><hr><p><red>【所有的<strong>定义</strong>都是<strong>声明</strong>，但所有的<strong>声明</strong>并不一定是<strong>定义</strong>。这些不是定义的声明有一个名字：<u><strong>纯声明(pure declarations)</strong></u>】</red></p><ul><li>一个典型的例子就是：<u>函数原型(function prototype)</u>，它满足编译器的要求，但不满足链接器的要求。</li><li>其他类型的纯声明包含：提前声明变量 和 类型声明。</li></ul><p><strong>单定义规则不适用于纯声明。</strong>所以，你可以对一些标识符声明n多次都可以（虽然声明n次，会有很多次是冗余的）</p><hr><p>小结：</p><p>在很多编程语言中，“声明”就是指“纯声明”；“定义”就是指“定义也可以用于声明”。所以，<code>int x;</code>是一个定义（虽然他既是定义，也是声明）</p><h2 id="2-9-命名冲突-amp-命名空间"><a href="#2-9-命名冲突-amp-命名空间" class="headerlink" title="2.9 命名冲突&amp;命名空间"></a>2.9 命名冲突&amp;命名空间</h2><h3 id="命名冲突"><a href="#命名冲突" class="headerlink" title="命名冲突"></a>命名冲突</h3><p><strong>命名冲突：naming collision</strong> (or <strong>naming conflict</strong>).</p><blockquote><p>将两个同名的标识符放在同一个程序中，编译器或者链接器无法区分它们时，就会报错。这种情况就是：<strong>命名冲突</strong></p></blockquote><p>例如：</p><blockquote><p>a.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFcn</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>main.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFcn</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> * x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当编译器编译这个程序时，它将会<strong>单独的</strong>编译<em>a.cpp</em>和<em>main.cpp</em>，每个cpp文件都编译成功。但是，当链接时，链接器将会链接<em>a.cpp</em>和<em>main.cpp</em>中所有的定义到一起，此时就发现函数<em>myFun</em>命名冲突了。【注意，虽然函数<em>myFun</em>没有被调用，但在链接时还是会出错】</p><p>命名冲突一般出现在以下两种情况：</p><ol><li>一个函数(或全局变量)的两个(或多个)定义被引入到不同的文件中，这些文件被编译到同一个程序中。这将导致一个<strong>链接器错误</strong>，如上所示。</li><li>一个函数(或全局变量)的两个(或多个)定义被引入到同一个文件中(通常通过#include)。这将导致<strong>编译器错误</strong>。</li></ol><p>对于<strong>局部变量</strong>，C++提供一种局部范围的机制，它使定义在函数内部的局部变量不会冲突。但这种机制对于函数的名字无效。</p><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p><strong>命名空间：namespace</strong></p><p><strong>命名空间：</strong>之所以出来这样一个东西，是因为人类可用的单词数太少，并且不同的人写的程序不可能所有的变量都没有重名现象，对于库来说，这个问题尤其严重，如果两个人写的库文件中出现同名的变量或函数(不可避免)，使用起来就有问题了。为了解决这个问题，引入了名字空间这个概念，通过使用 namespace xxx；你所使用的库函数或变量就是在该名字空间中定义的，这样一来就不会引起不必要的冲突了。</p><blockquote><p>注意，在同一命名空间中，所有的名字必须是独一无二的。</p></blockquote><h4 id="全局命名空间"><a href="#全局命名空间" class="headerlink" title="全局命名空间"></a>全局命名空间</h4><p>在C++中，任何没有定义在 类、函数、或 命名空间 的名字，都被默认的归为“<strong>全局命名空间(global namespace)</strong>”，有时也叫“<strong>全局范围(global scope)</strong>”</p><h4 id="std-命名空间"><a href="#std-命名空间" class="headerlink" title="std 命名空间"></a>std 命名空间</h4><p>在最初设计c++时，c++标准库中的所有标识符(包括std::cin和std::cout)都可以在没有std::前缀的情况下使用(它们是全局命名空间的一部分)。</p><p>但是，这意味着标准库中的任何标识符都可能与你自己定义的标识符的名字(也在全局名称空间中定义)发生冲突。</p><p>为了避免这种冲突，C++将所有标准库中的所有函数都移入一个叫做<strong>“std(是standard的简称)”的命名空间</strong>，即：<strong>std namespace</strong></p><blockquote><p>所以，你看到的<em>std::cout</em>，这并不是它的名字，它实际上只是<em>cout</em>，<em>std</em>只是命名空间的名字，而<em>cout</em>是std namespace中的一部分。</p></blockquote><p><strong>【注】：如果你使用一个命名空间中的标识符，你必须告诉编译器，这个标识符是在这个命名空间内。</strong></p><hr><ol><li><p><strong>显示的命名空间限定符 std::</strong></p><p>最直接的方法是：告诉编译器我们使用<em>cout</em>是来自 <em>std</em>这个namespace(命名空间)的。可以使用前缀 “std::” 来完成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!"</span>; <span class="comment">// when we say cout, we mean the cout defined in the std namespace</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>‘::’</strong> 是一个操作符，叫做<strong>“作用域解析符(scope resolution operator)”</strong>。</p><p>在它左边的标识符表示：所在命名空间的名称；在它右边的标识符表示：这个命名空间的一个 标识符。</p><p>【注】如果“::”的左边没有东西，则默认为它在<strong>全局命名空间( global namespace )</strong>中。</p></blockquote><p>std::cout就表示<em>cout</em>是在 std namsoace 中。</p></li></ol><ol start="2"><li><p><strong>using namespace std</strong></p><p>另一种方法是：用<strong>使用指令(using directive)**</strong><code>using namespace std</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">// this is a using directive telling the compiler to check the std namespace when resolving identifiers with no prefix</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!"</span>; <span class="comment">// cout has no prefix, so the compiler will check to see if cout is defined locally or in namespace std</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>using directive</strong>：告诉编译器 当试图解析一个没有使用<u>命名空间前缀(namespace prefix)</u>的标识符时，检查一个指定的命名空间。</p></blockquote><p><strong>【不推荐此方法】</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // imports the declaration of std::cout</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">// makes std::cout accessible as "cout"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cout</span><span class="params">()</span> <span class="comment">// declares our own "cout" function</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, world!"</span>; <span class="comment">// Compile error!  Which cout do we want here?  The one in the std namespace or the one we defined above?</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况，将不会被编译。因为编译器不知道我们到底想用我们自己定义的cout函数，还是想用 std命名空间 中的cout函数。</p><p>并且，虽然标识符名称现在可能不冲突，但在将来的语言修订中，它可能与添加到std名称空间的新标识符发生冲突。</p></li></ol><h2 id="2-10-预处理器"><a href="#2-10-预处理器" class="headerlink" title="2.10 预处理器"></a>2.10 预处理器</h2><p>在编译之前，代码要经过一个阶段，叫做“<strong>翻译(translation)</strong>”。在翻译阶段会发生许多事情，以使您的代码准备好被编译(如果您感兴趣，可以在<a href="https://en.cppreference.com/w/cpp/language/translation_phases" target="_blank" rel="noopener">这里</a>找到翻译阶段的列表)。应用翻译的代码文件称为<strong>翻译单元(translation unit)</strong>。</p><p>最值得注意的是：翻译阶段包含<strong>预处理器(preprocessor)</strong>。最好将预处理器看作是一个单独的程序，它处理每个代码文件中的文本部分。</p><p>当预处理器运行时，它从头到尾的扫描源码文件，寻找预处理程序指令。</p><blockquote><p><strong>预处理指令(preprocessor directives)，也称作directives</strong>：<u>是以“#”符号开始，以换行符结束的指令(不是分号，即不要加分号)</u>。</p></blockquote><ul><li><strong>“使用指令(using directives)”</strong>不是预处理指令，所以不会被预处理器处理。所以当提起“directive”，通常指的是“preprocessor directive”</li></ul><h4 id="include"><a href="#include" class="headerlink" title="include"></a>include</h4><p>当你<em>#include*一个文件，预处理器将会把</em>#include*指令 替换为 include file的内容。（include file 的内容将会被预处理，然后被编译）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, world!"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当预处理器运行时，预处理器将会把<code>#include &lt;iostream&gt;</code>替换为 名为“iostream”的文件。</p></blockquote><h4 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h4><p><strong>宏定义：Macro defines</strong></p><p><em>#include</em> 指令可以用来创建<strong>宏</strong>。在C++中，<strong>宏</strong>是定义如何将 ‘输入文本’ 转换为 ‘替换输出文本’。</p><p>宏有两种基本类型：1️⃣<strong>对象式宏</strong>(<em>object-like macros</em>)。2️⃣<strong>函数式宏</strong>( <em>function-like macros</em>)</p><ol><li><p>函数式宏</p><p>函数式宏的作用类似于函数，并具有类似的用途。</p></li><li><p>对象式宏</p><p>可以被定义成以下两种形式：</p><ul><li><p>#define identifier</p></li><li><p>#define identifier substitution_text</p><blockquote><p>此处，identifier：宏名【一般是大写字母，用下划线表示空格】；substitution_text：替换文本(替换输出文本)</p></blockquote></li></ul><p>1.带有输出文本(substitution_text)：当预处理器处理此条指令时，宏名 将会被替换为‘输出文本’。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_NAME <span class="meta-string">"Alex"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"My name is: "</span> &lt;&lt; MY_NAME;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预处理程序将上述转换为以下内容:</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"My name is: "</span> &lt;&lt; <span class="string">"Alex"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.不带输出文本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USE_YEN</span></span><br></pre></td></tr></table></figure><p>如你所想，这条宏指令工作方式：标识符的任何进一步出现都将被删除，并将被nothing替换!</p></li></ol><h4 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h4><p><strong>条件编译：conditional compilation</strong></p><p>使用<strong>条件编译的预处理指令</strong>可以设置在什么条件下编译，什么条件下不编译。比较常见的条件编译指令有以下三个：<em>#ifdef*、</em>#ifndef<em>、</em>#endif*</p><ul><li><p><strong><em>#ifdef</em></strong> 预处理指令允许预处理器检查这个标识符(identifier)是否已经被 #define(定义了)。如果被定义，那么在<em>#ifdef*和</em>#endif*之间的代码将会被编译；如果没被定义，这些代码将会被忽略。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_JOE</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PRINT_JOE</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Joe\n"</span>; <span class="comment">// if PRINT_JOE is defined, compile this code</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PRINT_BOB</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Bob\n"</span>; <span class="comment">// if PRINT_BOB is defined, compile this code</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><em>ifndef</em></strong>指令和<em>ifdef*指令的作用是相反的。即，如果这个标识符没有被 #define，那么在</em>#ifndef<em>和</em>#endif*之间的代码才会被编译</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PRINT_BOB</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Bob\n"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是“Bob”,因为PRINT_BOB没有被 #define，所有才会执行。</p></li><li><p><strong><em>#if 0</em></strong> ：条件编译的另一个常见用法是使用<em>#if 0</em>来排除正在编译的代码块(就像它在一个注释块中一样):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Joe\n"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0 <span class="comment">// Don't compile anything starting here</span></span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Bob\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Steve\n"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// until this point</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>【注】<strong>对象式宏</strong>不会影响<strong>预处理器的其他指令</strong></p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO 9 <span class="comment">// Here's a macro substitution</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> FOO <span class="comment">// This FOO does not get replaced because it’s part of another preprocessor directive</span></span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; FOO; <span class="comment">// This FOO gets replaced with 9 because it's part of the normal code</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="宏定义的范围"><a href="#宏定义的范围" class="headerlink" title="宏定义的范围"></a>宏定义的范围</h4><p>指令在编译之前，从上到下逐个文件地解析。</p><ol><li><strong>同一文件中</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_NAME <span class="meta-string">"Alex"</span></span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"My name is: "</span> &lt;&lt; MY_NAME;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然，上面的代码表面上看起来：<em>#define MY_NAME “Alex”</em>是定义在函数<em>foo</em>内部的。<strong>但是预处理器将不会注意，因为它不懂C++中的概念，例如函数。所以，这个程序的执行流程与#define MY_NAME “Alex”在函数foo之前或之后定义的行为相同。</strong>但是，一般情况下，我们习惯于将 <code>#define identifiers</code>这种宏定义放在函数的外面。</p><ol start="2"><li><strong>同一项目的不同文件中</strong></li></ol><p>预处理程序完成后，将丢弃该文件中定义的所有标识符。这意味着指令仅从<strong>定义点</strong>到<strong>定义它们的文件末尾</strong>有效。<u>在一个代码文件中定义的指令不会影响同一项目中的其他代码文件。</u></p><p>example：</p><p><code>function.cpp:</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PRINT</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Printing!"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PRINT</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Not printing!"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>; <span class="comment">// forward declaration for function doSomething()</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    doSomething();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行的结果是：Not printing!</p><p><strong>因为文件之间的宏定义互不影响。</strong></p><h2 id="2-11-头文件"><a href="#2-11-头文件" class="headerlink" title="2.11 头文件"></a>2.11 头文件</h2><p><strong>头文件：Header files</strong></p><p>当程序变得越来越大了，对每个函数都进行提前声明是很乏味无趣的。如果能够将所有的 提前声明 放在一个地方，然后在需要时导入它们，这不是很好吗?</p><blockquote><p><strong>code files</strong>：<strong>源文件(后缀 .cpp)</strong>；<strong>header files</strong>：<strong>头文件(后缀 .h 或 .hpp)</strong></p></blockquote><p>头文件的主要用途就是：将 声明 引入 源文件 中。</p><h4 id="使用标准库头文件"><a href="#使用标准库头文件" class="headerlink" title="使用标准库头文件"></a>使用标准库头文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, world!"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序使用<em>std::cout</em>。但是这个程序没有提供关于<em>std::cout</em>的声明或者定义，那编译器是如何知道<em>std::cout</em>是什么呢？</p><p>答：因为<em>std::cout<em>在头文件“iostream” 中 已经提前声明过了。当我们<code>#include &lt;iostream&gt;</code>时，我们就请求预处理器将头文件“iostream”中的所有内容(当然也包含</em>std::cout</em>)都复制过来。</p><blockquote><p><strong>注意：</strong><red>当<code>#include xxx</code>时，xxx头文件的所有内容都被引入到当前文件中。</red></p></blockquote><p><strong>头文件通常只包含：函数和对象的声明，不包含它们的定义</strong>。</p><blockquote><p>如 <em>std::cout</em>在头文件“iostream”中<u>声明</u>， 但 <u>定义</u>为c++标准库的一部分，在链接器阶段自动链接到程序中。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter2/IncludeLibrary.png" alt="IncludeLibrary"></p></blockquote><h4 id="创建自己的头文件"><a href="#创建自己的头文件" class="headerlink" title="创建自己的头文件"></a>创建自己的头文件</h4><p>步骤：</p><ol><li><strong>头文件保护符(header guaed)</strong></li><li>然后添加头文件(后缀 .h)进行声明；相应的也要添加源文件(后缀 .cpp)进行定义。【注意头文件、源文件的名字要一样】</li></ol><p>创建完之后：</p><p><code>add.h</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1) We really should have a header guard here, but will omit it for simplicity (we'll cover header guards in the next lesson)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2) This is the content of the .h file, which is where the declarations go</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="comment">// function prototype for add.h -- don't forget the semicolon!</span></span><br></pre></td></tr></table></figure><p><code>add.cpp</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"add.h"</span> <span class="comment">// Insert contents of add.h at this point.  Note use of double quotes here.【不是标准库的头文件，一般用双引号""】</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of 3 and 4 is "</span> &lt;&lt; add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序的编译、链接过程：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter2/IncludeHeader.png" alt="IncludeHeader"></p><h4 id="头文件的-lt-gt-amp-””"><a href="#头文件的-lt-gt-amp-””" class="headerlink" title="头文件的&lt;&gt;&amp;””"></a>头文件的&lt;&gt;&amp;””</h4><p><strong>尖括号</strong>：<strong>Angled brackets</strong> ，即<strong>&lt;&gt;</strong>。尖括号用来告诉预处理程序我们包含了编译器包含的头文件，所以它应该在<u>系统目录中查找那个头文件</u>。</p><p><strong>双引号</strong>：<strong>double-quotes</strong>，即<strong>“”</strong>。双引号告诉预处理器这是一个用户定义的头文件，所以它应该在当前目录中寻找这个头文件。如果没找到，它会检查其他的包含路径(已指定为compiler/IDE设置的一部分的路径)。如果还是失败的话，它将去系统目录中寻找这个头文件。</p><h4 id="“iostream”没-h-后缀？"><a href="#“iostream”没-h-后缀？" class="headerlink" title="“iostream”没 .h 后缀？"></a>“iostream”没 .h 后缀？</h4><ol><li><p>好奇，为什么“iostream”(或者其他标准库头文件)没有后缀 .h？</p><p>答：因为<em>iostream.h</em>是另一个头文件</p></li><li><p><em>iostream.h</em>与<em>iostream</em>：</p><p>在C++最开始创建的时候，所有标准库都是有 .h 后缀的。但是，后来ANSI委员会修改C++，将所有的标准库放在 <em>std 命名空间</em> 中，进而避免与用户自定义的标识符 冲突。</p><p>但是为题来了，将这些标准库移入<em>std 命名空间</em> 后，以前的程序将无法运行。为了解决这个问题，一个新的头文件：<em>iostream</em>出现，这个新头文件包含了 <em>iostream.h</em>的所有内容。然后，旧的程序依然可以用<code>#include &lt;iostream.h&gt;</code>，新程序就用<code>#include &lt;iostream&gt;</code></p></li></ol><h4 id="头文件路径建议"><a href="#头文件路径建议" class="headerlink" title="头文件路径建议"></a>头文件路径建议</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/myHeader.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../moreHeaders/myOtherHeader.h"</span></span></span><br></pre></td></tr></table></figure><p>这种设置成路径形式的头文件，假设现在路径没问题。但是很有可能在某一天，你的文件位置就不小心的被移动了，这时候就用不了了。</p><p>【建议】将你平常会用到的很多不同的文件放在比较固定的地方，然后在你的 compiler/IDE 这个固定地方的位置。这样当它在当前目录中找不到它们时，它就会去你设置的固定位置找。这通常可以通过在IDE项目设置中设置包含路径或搜索目录来实现。</p><blockquote><p>visual studio设置方法：</p><p>在“解决方案”中，点击project的“属性”，然后看到“VC++目录”中的“包含目录(include directories)”，在这里面添加你要使用的头文件的目录。</p></blockquote><p>这种方法的优点是，如果要更改目录结构，只需更改单个编译器或IDE设置，而不必更改每个代码文件。</p><h2 id="2-12-头文件保护符"><a href="#2-12-头文件保护符" class="headerlink" title="2.12 头文件保护符"></a>2.12 头文件保护符</h2><p><strong>头文件保护符：header guards</strong></p><h3 id="重复定义"><a href="#重复定义" class="headerlink" title="重复定义"></a>重复定义</h3><p><strong>duplicate definition：重复定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变量重定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x; <span class="comment">// this is a definition for variable x</span></span><br><span class="line">    <span class="keyword">int</span> x; <span class="comment">// compile error: duplicate definition</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数重定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> <span class="comment">// this is a definition for function foo</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> <span class="comment">// compile error: duplicate definition</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; foo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种比较容易修复。</p><hr><p>但是在头文件中，很容易出现一个头文件中的定义被include不止一次。这通常发生在 一个头文件 又#include 其他头文件：</p><p><code>square.h</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在头文件中，不建议出现 定义；但是这里为了方便举例</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSquareSides</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>geometry.h</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"square.h"</span></span></span><br></pre></td></tr></table></figure><p><code>main.cpp</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"square.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"geometry.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个程序。首先，在<code>main.cpp</code>中<em>#include square.h</em> ，它(<em>square.h</em>)将<code>getSquareSides</code>函数的定义复制到main.cpp中。然后，<code>main.cpp</code>又<em>#include geometry.h</em> ，它(<em>geometry.h</em>)又包含了<em>square.h</em>，所以也会将<em>square.h</em>中的内容(包括<code>getSquareSides</code>函数)复制到<em>geometry.h</em>，进而也就被复制到<em>main.cpp</em>中。</p><p>所以，当解析完所有的<em>#include</em>之后，main.cpp就变成这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSquareSides</span><span class="params">()</span>  <span class="comment">// from square.h</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSquareSides</span><span class="params">()</span> <span class="comment">// from geometry.h (via square.h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，就会出现重复定义，编译也会出错。每个单独的文件没问题，但是因为main.cpp最终#include了两次square.h的内容，所以我们遇到了问题。如何解决呢？？？答：使用<strong>header guard</strong></p><h3 id="头文件保护符"><a href="#头文件保护符" class="headerlink" title="头文件保护符"></a>头文件保护符</h3><p><strong>头文件保护符(header guard)</strong>是<strong>条件编译(conditional compilation)</strong>的指令，它的形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SOME_UNIQUE_NAME_HERE <span class="comment">//SOME_UNIQUE_NAME_HERE：你可以用任何名字代替它</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOME_UNIQUE_NAME_HERE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里是写关于 声明 的代码</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>当这个头文件被<em>#included</em>时，预处理器检查<code>SOME_UNIQUE_NAME_HERE</code>是否被定义过。</p><ul><li>如果这是我们第一次包含这个头文件，<code>SOME_UNIQUE_NAME_HERE</code>还没有被创建。然后就会定义<code>SOME_UNIQUE_NAME_HERE</code>，而且会包含文件的内容。</li><li>如果这个头文件之前已经被包含到这个文件中，那么<code>SOME_UNIQUE_NAME_HERE</code>是已经被定义过的，而且其内容也以经被包含在这个文件中。所以这个头文件的内容将会被忽略（由于<strong><code>#ifndef</code></strong>）。</li></ul><hr><p><strong>每一个头文件都应该要有头文件保护符</strong>。</p><hr><p><strong>好的头文件保护符命名规则</strong>：</p><p><code>&lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H</code>或者<code>&lt;FILE&gt;_&lt;LARGE RANDOM NUMBER&gt;_H</code>或者<code>&lt;FILE&gt;_&lt;CREATION DATE&gt;_H</code></p><hr><p>请注意，头文件保护的目标是防止<strong>源文件</strong>多次接收到被保护的<strong>头文件</strong>。根据设计，头文件保护<strong>不</strong>会阻止将给定的头文件(一次)包含到单独的源码文件中。这也会导致意想不到的问题：</p><p><code>square.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SQUARE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE_H</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSquareSides</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSquarePerimeter</span><span class="params">(<span class="keyword">int</span> sideLength)</span></span>; <span class="comment">// forward declaration for getSquarePerimeter</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>square.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"square.h"</span>  <span class="comment">// square.h is included once here</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSquarePerimeter</span><span class="params">(<span class="keyword">int</span> sideLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sideLength * getSquareSides();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"square.h"</span> <span class="comment">// square.h is also included once here</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a square has "</span> &lt;&lt; getSquareSides() &lt;&lt; <span class="string">" sides\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a square of length 5 has perimeter length "</span> &lt;&lt; getSquarePerimeter(<span class="number">5</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，square.h包含在main.cpp和square.cpp中。这意味着square.h的内容将被包含一次到square.cpp中，一次到main.cpp中。</p><blockquote><p>细节：</p><p>当<code>square.h</code>被包含在<code>square.cpp</code>中时，在<code>square.cpp</code>结束之前，<code>SQUARE_H</code>都一直被定义。（这阻止了<code>square.h</code>被多次包含于<code>square.cpp</code>。也真是头文件保护符起作用的）。然而，一旦<code>square.cpp</code>结束后，<code>SQUARE_H</code>将不再被定义。这就意味着当预处理器运行<code>main.cpp</code>时，<code>SQUARE_H</code>在<code>main.cpp</code>中最初是没有定义的。</p><p>结果就是，<code>square.cpp</code>和<code>main.cpp</code>都复制了<em>getSquareSides</em>的定义。这个程序将<strong>可以被编译</strong>，但是会<strong>链接出错</strong>（链接器会抱怨为什么会有不止一个的<em>getSquareSides</em>的定义）</p></blockquote><p><strong>最好的解决办法就是：将函数的<u>定义</u>放在源文件中(即 .cpp文件中)，头文件中只含有<u>声明</u>。</strong></p><h3 id="pragma-once"><a href="#pragma-once" class="headerlink" title="#pragma once"></a>#pragma once</h3><p><code>#program once</code>的作用和头文件标识符相同，但是它更加短。</p><blockquote><p>但是，<code>#program once</code>不是C++官方原生的一部分，所以<strong>不是所有的编译器都支持它</strong>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;p center large&gt;&lt;red&gt;LearnCpp chapter2&lt;/red&gt;&lt;/p&gt;&lt;/center&gt;&lt;center&gt;&lt;red&gt;https://www.learncpp.com&lt;/red&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C/C++" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/"/>
    
    
      <category term="C++" scheme="https://longlongqin.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Let’s Build A Simple Interpreter-10</title>
    <link href="https://longlongqin.github.io/archives/2f66ae56.html"/>
    <id>https://longlongqin.github.io/archives/2f66ae56.html</id>
    <published>2020-03-25T05:21:04.000Z</published>
    <updated>2020-04-19T14:38:29.546Z</updated>
    
    <content type="html"><![CDATA[<p>今天的改进内容：</p><ol><li>如何进行语法Fenix和解释Pascal的程序头部；</li><li>如何进行语法分析Pascal的变量声明；</li><li>将更新解释器，用<em>DIV</em>关键字来表示整数的出发、用品”<strong>/</strong>“来表示浮点数的除法；</li><li>添加Pascal语言的注释功能</li></ol><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-10/lsbasi_part10_intro.png" alt="img"></p><a id="more"></a><h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p>在进行细致的讲解之前，我们先下载本节的解释器的<a href="https://github.com/rspivak/lsbasi/blob/master/part10/python/spi.py" target="_blank" rel="noopener">源码：spy.py</a>和一个简单的Pascal语言的<a href="https://github.com/rspivak/lsbasi/blob/master/part10/python/part10.pas" target="_blank" rel="noopener">程序：part10.pas</a>。然后再在命令提示符(Windows10系统 可直接在左下角搜索框中搜索“cmd”)中进行输入：<code>python spi.py part10.pas</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-10/image-20200325134921750.png" alt="image-20200325134921750"></p><p>好了。现在来看看今天要改进的内容，我们将学习：</p><ol><li>如何进行语法Fenix和解释Pascal的程序头部；</li><li>如何进行语法分析Pascal的变量声明；</li><li>将更新解释器，用<em>DIV</em>关键字来表示整数的出发、用品”<strong>/</strong>“来表示浮点数的除法；</li><li>添加Pascal语言的注释功能</li></ol><h2 id="更新后的语法规则"><a href="#更新后的语法规则" class="headerlink" title="更新后的语法规则"></a>更新后的语法规则</h2><p>更新后的语法规则，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-10/lsbasi_part10_grammar1.png" alt="lsbasi_part10_grammar1"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-10/lsbasi_part10_grammar2.png" alt="lsbasi_part10_grammar2"></p><blockquote><p>这里给出一个简单地Pascal语言的程序，便于理解其语法：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PROGRAM</span> Part10;</span><br><span class="line"><span class="keyword">VAR</span></span><br><span class="line">   number     : INTEGER;</span><br><span class="line">   a, b, c, x : INTEGER;</span><br><span class="line">   y          : REAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> <span class="comment">&#123;Part10&#125;</span></span><br><span class="line">   <span class="keyword">BEGIN</span></span><br><span class="line">      number := <span class="number">2</span>;</span><br><span class="line">      a := number;</span><br><span class="line">      b := <span class="number">10</span> * a + <span class="number">10</span> * number <span class="keyword">DIV</span> <span class="number">4</span>;</span><br><span class="line">      c := a - - b</span><br><span class="line">   <span class="keyword">END</span>;</span><br><span class="line">   x := <span class="number">11</span>;</span><br><span class="line">   y := <span class="number">20</span> / <span class="number">7</span> + <span class="number">3.14</span>;</span><br><span class="line">   <span class="comment">&#123; writeln('a = ', a); &#125;</span></span><br><span class="line">   <span class="comment">&#123; writeln('b = ', b); &#125;</span></span><br><span class="line">   <span class="comment">&#123; writeln('c = ', c); &#125;</span></span><br><span class="line">   <span class="comment">&#123; writeln('number = ', number); &#125;</span></span><br><span class="line">   <span class="comment">&#123; writeln('x = ', x); &#125;</span></span><br><span class="line">   <span class="comment">&#123; writeln('y = ', y); &#125;</span></span><br><span class="line"><span class="keyword">END</span>.  <span class="comment">&#123;Part10&#125;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="1-program"><a href="#1-program" class="headerlink" title="1. program"></a>1. program</h3><p>程序定义的语法规则，包括：保留字“<strong><em>PROGRAM</em></strong>”、程序的<strong>名字</strong>、一个以点“<strong>.</strong>”结尾的<strong>block</strong>。如：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PROGRAM</span> Part10;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">END</span>.</span><br></pre></td></tr></table></figure><blockquote><p>上面是一个完整的Pascal程序</p></blockquote><h3 id="2-block"><a href="#2-block" class="headerlink" title="2. block"></a>2. block</h3><p>block包含：一个<strong>声明规则</strong>、<strong>复合语句</strong>，如：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例1</span></span><br><span class="line"><span class="keyword">VAR</span></span><br><span class="line">   number : INTEGER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例2</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><h3 id="3-declarations"><a href="#3-declarations" class="headerlink" title="3. declarations"></a>3. declarations</h3><p>Pascal的声明有几个部分，每个部分都是可选的。本节中，我们只讨论变量声明的部分。变量声明规则：要么有一个变量声明的子规则，要么是空的。</p><h3 id="4-VAR"><a href="#4-VAR" class="headerlink" title="4. VAR"></a>4. VAR</h3><p>Pascal是静态类语言，也就是说在使用每一个变量之前，都需要明确的声明它的类型。变量的声明在程序中用<strong>VAR</strong>保留字，如：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">VAR</span></span><br><span class="line">   number     : INTEGER;</span><br><span class="line">   a, b, c, x : INTEGER;</span><br><span class="line">   y          : REAL;</span><br></pre></td></tr></table></figure><h3 id="5-type-spec"><a href="#5-type-spec" class="headerlink" title="5. type_spec"></a>5. type_spec</h3><p>在本节中，数据类型是两种：INTEGER 和 REAL(float)，常出现在变量声明部分：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">VAR</span></span><br><span class="line">   a : INTEGER;</span><br><span class="line">   b : REAL;</span><br></pre></td></tr></table></figure><blockquote><p>本节中没有进行设计类型检查，这将会在后续文章中添加</p></blockquote><h3 id="6-term"><a href="#6-term" class="headerlink" title="6. term"></a>6. term</h3><p>term规则更新之后，将整数、浮点数的出发分开表示：DIV、/</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span> / <span class="number">7</span> = <span class="number">2.85714285714</span> <span class="comment">//浮点数出发</span></span><br><span class="line"><span class="number">20</span> <span class="keyword">DIV</span> <span class="number">7</span> = <span class="number">2</span>           <span class="comment">//整数除法</span></span><br></pre></td></tr></table></figure><h3 id="7-factor"><a href="#7-factor" class="headerlink" title="7. factor"></a>7. factor</h3><p>更新之后可以处理整数、浮点数的常量。</p><hr><p>以下是今天的完整语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">program : PROGRAM variable SEMI block DOT</span><br><span class="line"></span><br><span class="line">block : declarations compound_statement</span><br><span class="line"></span><br><span class="line">declarations : VAR (variable_declaration SEMI)+</span><br><span class="line">             | empty</span><br><span class="line"></span><br><span class="line">variable_declaration : ID (COMMA ID)* COLON type_spec</span><br><span class="line"></span><br><span class="line">type_spec : INTEGER | REAL</span><br><span class="line"></span><br><span class="line">compound_statement : BEGIN statement_list END</span><br><span class="line"></span><br><span class="line">statement_list : statement</span><br><span class="line">               | statement SEMI statement_list</span><br><span class="line"></span><br><span class="line">statement : compound_statement</span><br><span class="line">          | assignment_statement</span><br><span class="line">          | empty</span><br><span class="line"></span><br><span class="line">assignment_statement : variable ASSIGN expr</span><br><span class="line"></span><br><span class="line">empty :</span><br><span class="line"></span><br><span class="line">expr : term ((PLUS | MINUS) term)*</span><br><span class="line"></span><br><span class="line">term : factor ((MUL | INTEGER_DIV | FLOAT_DIV) factor)*</span><br><span class="line"></span><br><span class="line">factor : PLUS factor</span><br><span class="line">       | MINUS factor</span><br><span class="line">       | INTEGER_CONST</span><br><span class="line">       | REAL_CONST</span><br><span class="line">       | LPAREN expr RPAREN</span><br><span class="line">       | variable</span><br><span class="line"></span><br><span class="line">variable: ID</span><br></pre></td></tr></table></figure><h2 id="更新Lexer"><a href="#更新Lexer" class="headerlink" title="更新Lexer"></a>更新Lexer</h2><p>总结一下，lexer的改变：</p><ol><li>新的tokens</li><li>新的保留字</li><li>添加处理Pascal语言的注释，用<em>skip_comment</em></li><li>更新<em>integer</em></li><li>更新<em>get_next_token</em> ，使其能够返回新添加的tokens</li></ol><p>让我们深入研究一下上面提到的变化:</p><ol><li><p>为了处理程序头、变量的声明、整数与浮点数常量以及它们的除法。我们需要添加新的tokens，我们还需要更新“INTEGER”的含义：表示一个整数类型，而不是一个整数常量。</p><p>下面是更新后全部的<strong>tokens</strong>:</p><ul><li>PROGRAM (reserved keyword)</li><li>VAR (reserved keyword)</li><li>COLON (:)</li><li>COMMA (,)</li><li>INTEGER (we change it to mean integer type and not integer constant like 3 or 5)</li><li>REAL (for Pascal REAL type)</li><li>INTEGER_CONST (for example, 3 or 5)</li><li>REAL_CONST (for example, 3.14 and so on)</li><li>INTEGER_DIV for integer division (the <strong><em>DIV</em></strong> reserved keyword)</li><li>FLOAT_DIV for float division ( forward slash / )</li></ul></li><li><p>全部的<strong>保留字</strong>token：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RESERVED_KEYWORDS = &#123;</span><br><span class="line">    <span class="string">'PROGRAM'</span>: Token(<span class="string">'PROGRAM'</span>, <span class="string">'PROGRAM'</span>),</span><br><span class="line">    <span class="string">'VAR'</span>: Token(<span class="string">'VAR'</span>, <span class="string">'VAR'</span>),</span><br><span class="line">    <span class="string">'DIV'</span>: Token(<span class="string">'INTEGER_DIV'</span>, <span class="string">'DIV'</span>),</span><br><span class="line">    <span class="string">'INTEGER'</span>: Token(<span class="string">'INTEGER'</span>, <span class="string">'INTEGER'</span>),</span><br><span class="line">    <span class="string">'REAL'</span>: Token(<span class="string">'REAL'</span>, <span class="string">'REAL'</span>),</span><br><span class="line">    <span class="string">'BEGIN'</span>: Token(<span class="string">'BEGIN'</span>, <span class="string">'BEGIN'</span>),</span><br><span class="line">    <span class="string">'END'</span>: Token(<span class="string">'END'</span>, <span class="string">'END'</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>处理<strong>注释</strong>，添加一个<em>skip_comment</em> 函数来处理注释，它的原理就是在找到右花括号“｛”之前，丢弃所有字符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">skip_comment</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> self.current_char != <span class="string">'&#125;'</span>:</span><br><span class="line">        self.advance()</span><br><span class="line">    self.advance()  <span class="comment"># the closing curly brace</span></span><br></pre></td></tr></table></figure></li><li><p>重新命名<strong><em>integer</em>函数</strong>为<strong><em>number</em>函数</strong>，，使其能够处理整型常量和浮点型常量，如3和3.14：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">number</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Return a (multidigit) integer or float consumed from the input."""</span></span><br><span class="line">    result = <span class="string">''</span></span><br><span class="line">    <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">        result += self.current_char</span><br><span class="line">        self.advance()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.current_char == <span class="string">'.'</span>:</span><br><span class="line">        result += self.current_char</span><br><span class="line">        self.advance()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (</span><br><span class="line">            self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span></span><br><span class="line">            self.current_char.isdigit()</span><br><span class="line">        ):</span><br><span class="line">            result += self.current_char</span><br><span class="line">            self.advance()</span><br><span class="line"></span><br><span class="line">        token = Token(<span class="string">'REAL_CONST'</span>, float(result))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        token = Token(<span class="string">'INTEGER_CONST'</span>, int(result))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> token</span><br></pre></td></tr></table></figure></li><li><p>更新<strong><em>get_next_token</em>函数</strong>，使其能够返回新增的tokens：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> self.current_char == <span class="string">'&#123;'</span>:</span><br><span class="line">            self.advance()</span><br><span class="line">            self.skip_comment()</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> self.current_char.isdigit():</span><br><span class="line">            <span class="keyword">return</span> self.number()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.current_char == <span class="string">':'</span>:</span><br><span class="line">            self.advance()</span><br><span class="line">            <span class="keyword">return</span> Token(COLON, <span class="string">':'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.current_char == <span class="string">','</span>:</span><br><span class="line">            self.advance()</span><br><span class="line">            <span class="keyword">return</span> Token(COMMA, <span class="string">','</span>)</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> self.current_char == <span class="string">'/'</span>:</span><br><span class="line">            self.advance()</span><br><span class="line">            <span class="keyword">return</span> Token(FLOAT_DIV, <span class="string">'/'</span>)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></li></ol><h2 id="更新Parser"><a href="#更新Parser" class="headerlink" title="更新Parser"></a>更新Parser</h2><p>总结Parser的变化：</p><ol><li>新的<strong>抽象语法树结点（AST nodes）</strong>：<em>Program</em>, <em>Block</em>, <em>VarDecl</em>, <em>Type</em></li><li>对应新的语法规则的函数：<em>block</em>, <em>declarations</em>, <em>variable_declaration</em>, 和 <em>type_spec</em>.</li><li>更新已经存在的paeser中的方法：<em>program</em>, <em>term</em>, and <em>factor</em></li></ol><p>让我们深入研究一下上面提到的变化:</p><ol><li><p>新的<strong>AST nodes</strong>：</p><ul><li><p><em>Program</em> AST node：表示一个程序，也是我们的根节点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Program</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, block)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.block = block</span><br></pre></td></tr></table></figure></li><li><p><em>Block</em> AST node：包含声明与复合语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Block</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, declarations, compound_statement)</span>:</span></span><br><span class="line">        self.declarations = declarations</span><br><span class="line">        self.compound_statement = compound_statement</span><br></pre></td></tr></table></figure></li><li><p><em>VarDecl</em> AST node：表示一个变量声明，它包含一个边梁节点和变量的类型结点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VarDecl</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, var_node, type_node)</span>:</span></span><br><span class="line">        self.var_node = var_node</span><br><span class="line">        self.type_node = type_node</span><br></pre></td></tr></table></figure></li><li><p><em>Type</em> AST node：表示一个变量类型（INTEGER or REAL）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Type</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, token)</span>:</span></span><br><span class="line">        self.token = token</span><br><span class="line">        self.value = token.value</span><br></pre></td></tr></table></figure></li></ul></li><li><p>对应<strong>新增的语法规则的函数(方法)</strong>：<em>block</em>, <em>declarations</em>, <em>variable_declaration</em>, 和 <em>type_spec</em>.【这些方法负责解析新的语言结构和构造新的AST nodes】：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">block</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""block : declarations compound_statement"""</span></span><br><span class="line">    declaration_nodes = self.declarations()</span><br><span class="line">    compound_statement_node = self.compound_statement()</span><br><span class="line">    node = Block(declaration_nodes, compound_statement_node)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">declarations</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""declarations : VAR (variable_declaration SEMI)+</span></span><br><span class="line"><span class="string">                    | empty</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    declarations = []</span><br><span class="line">    <span class="keyword">if</span> self.current_token.type == VAR:</span><br><span class="line">        self.eat(VAR)</span><br><span class="line">        <span class="keyword">while</span> self.current_token.type == ID:</span><br><span class="line">            var_decl = self.variable_declaration()</span><br><span class="line">            declarations.extend(var_decl)</span><br><span class="line">            self.eat(SEMI)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> declarations</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">variable_declaration</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""variable_declaration : ID (COMMA ID)* COLON type_spec"""</span></span><br><span class="line">    var_nodes = [Var(self.current_token)]  <span class="comment"># first ID</span></span><br><span class="line">    self.eat(ID)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> self.current_token.type == COMMA:</span><br><span class="line">        self.eat(COMMA)</span><br><span class="line">        var_nodes.append(Var(self.current_token))</span><br><span class="line">        self.eat(ID)</span><br><span class="line"></span><br><span class="line">    self.eat(COLON)</span><br><span class="line"></span><br><span class="line">    type_node = self.type_spec()</span><br><span class="line">    var_declarations = [</span><br><span class="line">        VarDecl(var_node, type_node)</span><br><span class="line">        <span class="keyword">for</span> var_node <span class="keyword">in</span> var_nodes</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">return</span> var_declarations</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">type_spec</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""type_spec : INTEGER</span></span><br><span class="line"><span class="string">                 | REAL</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    token = self.current_token</span><br><span class="line">    <span class="keyword">if</span> self.current_token.type == INTEGER:</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.eat(REAL)</span><br><span class="line">    node = Type(token)</span><br><span class="line">    <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure></li><li><p>更新已有的<em>program</em>, <em>term</em>, 和, <em>factor</em> 方法来适应语法的改变：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">program</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""program : PROGRAM variable SEMI block DOT"""</span></span><br><span class="line">    self.eat(PROGRAM)</span><br><span class="line">    var_node = self.variable()</span><br><span class="line">    prog_name = var_node.value</span><br><span class="line">    self.eat(SEMI)</span><br><span class="line">    block_node = self.block()</span><br><span class="line">    program_node = Program(prog_name, block_node)</span><br><span class="line">    self.eat(DOT)</span><br><span class="line">    <span class="keyword">return</span> program_node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""term : factor ((MUL | INTEGER_DIV | FLOAT_DIV) factor)*"""</span></span><br><span class="line">    node = self.factor()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, INTEGER_DIV, FLOAT_DIV):</span><br><span class="line">        token = self.current_token</span><br><span class="line">        <span class="keyword">if</span> token.type == MUL:</span><br><span class="line">            self.eat(MUL)</span><br><span class="line">        <span class="keyword">elif</span> token.type == INTEGER_DIV:</span><br><span class="line">            self.eat(INTEGER_DIV)</span><br><span class="line">        <span class="keyword">elif</span> token.type == FLOAT_DIV:</span><br><span class="line">            self.eat(FLOAT_DIV)</span><br><span class="line"></span><br><span class="line">        node = BinOp(left=node, op=token, right=self.factor())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""factor : PLUS factor</span></span><br><span class="line"><span class="string">              | MINUS factor</span></span><br><span class="line"><span class="string">              | INTEGER_CONST</span></span><br><span class="line"><span class="string">              | REAL_CONST</span></span><br><span class="line"><span class="string">              | LPAREN expr RPAREN</span></span><br><span class="line"><span class="string">              | variable</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    token = self.current_token</span><br><span class="line">    <span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">        self.eat(PLUS)</span><br><span class="line">        node = UnaryOp(token, self.factor())</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">        self.eat(MINUS)</span><br><span class="line">        node = UnaryOp(token, self.factor())</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="keyword">elif</span> token.type == INTEGER_CONST:</span><br><span class="line">        self.eat(INTEGER_CONST)</span><br><span class="line">        <span class="keyword">return</span> Num(token)</span><br><span class="line">    <span class="keyword">elif</span> token.type == REAL_CONST:</span><br><span class="line">        self.eat(REAL_CONST)</span><br><span class="line">        <span class="keyword">return</span> Num(token)</span><br><span class="line">    <span class="keyword">elif</span> token.type == LPAREN:</span><br><span class="line">        self.eat(LPAREN)</span><br><span class="line">        node = self.expr()</span><br><span class="line">        self.eat(RPAREN)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        node = self.variable()</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure></li></ol><p>现在来看看我们的<strong>抽象语法树<em>Abstract Syntax Tree</em></strong>，下面是一个Pascal程序：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PROGRAM</span> Part10AST;</span><br><span class="line"><span class="keyword">VAR</span></span><br><span class="line">   a, b : INTEGER;</span><br><span class="line">   y    : REAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> <span class="comment">&#123;Part10AST&#125;</span></span><br><span class="line">   a := <span class="number">2</span>;</span><br><span class="line">   b := <span class="number">10</span> * a + <span class="number">10</span> * a <span class="keyword">DIV</span> <span class="number">4</span>;</span><br><span class="line">   y := <span class="number">20</span> / <span class="number">7</span> + <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">END</span>.  <span class="comment">&#123;Part10AST&#125;</span></span><br></pre></td></tr></table></figure><p>它的解析树为：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-10/lsbasi_part10_ast-1585124028847.png" alt="lsbasi_part10_ast"></p><p>在图中可以看到我们添加的新节点。</p><h2 id="更新Interpreter"><a href="#更新Interpreter" class="headerlink" title="更新Interpreter"></a>更新Interpreter</h2><p>现在，剩下的就是向解释器类添加新的访问者方法。下面是将要新增的四个访问方法（对应新增的四种结点）：</p><ul><li><em>visit_Program</em></li><li><em>visit_Block</em></li><li><em>visit_VarDecl</em></li><li><em>visit_Type</em></li></ul><ol><li><p>其中对于<em>VarDecl</em>和<em>Type</em>，解释器对他们什么都不做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_Program</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    self.visit(node.block)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_Block</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> declaration <span class="keyword">in</span> node.declarations:</span><br><span class="line">        self.visit(declaration)</span><br><span class="line">    self.visit(node.compound_statement)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_VarDecl</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    <span class="comment"># Do nothing</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_Type</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    <span class="comment"># Do nothing</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li><li><p>更新<em>visit_BinOp</em> 方法，使其能够准确的解释整数和浮点数的除法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_BinOp</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> node.op.type == PLUS:</span><br><span class="line">        <span class="keyword">return</span> self.visit(node.left) + self.visit(node.right)</span><br><span class="line">    <span class="keyword">elif</span> node.op.type == MINUS:</span><br><span class="line">        <span class="keyword">return</span> self.visit(node.left) - self.visit(node.right)</span><br><span class="line">    <span class="keyword">elif</span> node.op.type == MUL:</span><br><span class="line">        <span class="keyword">return</span> self.visit(node.left) * self.visit(node.right)</span><br><span class="line">    <span class="keyword">elif</span> node.op.type == INTEGER_DIV:</span><br><span class="line">        <span class="keyword">return</span> self.visit(node.left) // self.visit(node.right)</span><br><span class="line">    <span class="keyword">elif</span> node.op.type == FLOAT_DIV:</span><br><span class="line">        <span class="keyword">return</span> float(self.visit(node.left)) / float(self.visit(node.right))</span><br></pre></td></tr></table></figure></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下，在本文中，扩展了Pascal解释器的哪些部分：</p><ul><li>添加新的语法规则和更新现有的规则；</li><li>添加新token，并相应地添加新方法去处理这些tokens，更新了现有的方法；</li><li>parser中：为新的语法结构添加新的AST nodes；</li><li>向我们的递归下降解析器添加与新语法规则相对应的新方法，并更新一些现有的方法；</li><li>interpreter中添加新的访问方法，更新了一个现存的访问方法</li></ul><p>我们也出去了一些“HACKS”(part9 中提到的)：</p><ul><li>本文的解释器可以处理程序头部(<strong><em>PROGRAM</em></strong> header)</li><li>变量可以用VAR关键字来声明</li><li>将整数与浮点数的除法分开来</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的改进内容：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;如何进行语法Fenix和解释Pascal的程序头部；&lt;/li&gt;&lt;li&gt;如何进行语法分析Pascal的变量声明；&lt;/li&gt;&lt;li&gt;将更新解释器，用&lt;em&gt;DIV&lt;/em&gt;关键字来表示整数的出发、用品”&lt;strong&gt;/&lt;/strong&gt;“来表示浮点数的除法；&lt;/li&gt;&lt;li&gt;添加Pascal语言的注释功能&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif&quot; data-original=&quot;LSBASI-10/lsbasi_part10_intro.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Let’s Build A Simple Interpreter" scheme="https://longlongqin.github.io/tags/Let%E2%80%99s-Build-A-Simple-Interpreter/"/>
    
  </entry>
  
  <entry>
    <title>LSBASI整理</title>
    <link href="https://longlongqin.github.io/archives/6fc94bb0.html"/>
    <id>https://longlongqin.github.io/archives/6fc94bb0.html</id>
    <published>2020-03-24T05:34:22.000Z</published>
    <updated>2020-04-19T14:38:29.546Z</updated>
    
    <content type="html"><![CDATA[<center><red>持续更新</red></center><a id="more"></a><h2 id="part-3"><a href="#part-3" class="headerlink" title="part 3"></a><a href="https://www.longlongqin.github.io/archives/f957.html" target="_blank" rel="noopener">part 3</a></h2><ul><li>实现了<strong>加减混合运算</strong>，并引入<strong>语法图概念</strong></li></ul><h2 id="part-4"><a href="#part-4" class="headerlink" title="part 4"></a><a href="https://www.longlongqin.github.io/archives/3b16.html" target="_blank" rel="noopener">part 4</a></h2><ul><li>实现了整数的<strong>乘除混合运算</strong>，引入<strong>上下文无关语法(context-free-grammars)，即BNF</strong></li></ul><h2 id="part-5"><a href="#part-5" class="headerlink" title="part 5"></a><a href="https://www.longlongqin.github.io/archives/173c.html" target="_blank" rel="noopener">part 5</a></h2><ul><li>实现了<strong>加减乘除混合运算</strong>，引入<strong>结合律(associativity)</strong>和<strong>优先级(precedence)</strong></li></ul><h2 id="part-6"><a href="#part-6" class="headerlink" title="part 6"></a><a href="https://www.longlongqin.github.io/archives/167c.html" target="_blank" rel="noopener">part 6</a></h2><ul><li>新增<strong>括号运算</strong></li></ul><h2 id="part-7"><a href="#part-7" class="headerlink" title="part 7"></a><a href="https://www.longlongqin.github.io/archives/5a757a52.html" target="_blank" rel="noopener">part 7</a></h2><ul><li>从本小节开始，将<code>interpreter</code>和<code>parser</code>分开来实现。并引入<strong>抽象语法树(AST)</strong>和<strong>解析树(parse tree)</strong>概念</li></ul><h2 id="part-8"><a href="#part-8" class="headerlink" title="part 8"></a><a href="https://www.longlongqin.github.io/archives/ae12.html" target="_blank" rel="noopener">part 8</a></h2><ul><li>新增<strong>一元操作符(unary operators)</strong>：“+”，“-”</li></ul><h2 id="part-9"><a href="#part-9" class="headerlink" title="part 9"></a><a href="https://www.longlongqin.github.io/archives/8632918.html" target="_blank" rel="noopener">part 9</a></h2><h2 id="整体分析"><a href="#整体分析" class="headerlink" title="整体分析"></a>整体分析</h2><p>整体分析，不管是part x，都一起分析，看看他的整体结构：</p><h3 id="Lexer"><a href="#Lexer" class="headerlink" title="Lexer"></a>Lexer</h3><ul><li><p>token类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">INTEGER       = <span class="string">'INTEGER'</span> <span class="comment">#用于表示整数类型</span></span><br><span class="line">REAL          = <span class="string">'REAL'</span>  <span class="comment">#表示浮点型</span></span><br><span class="line">INTEGER_CONST = <span class="string">'INTEGER_CONST'</span> <span class="comment">#整型常量</span></span><br><span class="line">REAL_CONST    = <span class="string">'REAL_CONST'</span>  <span class="comment">#浮点型常量</span></span><br><span class="line">PLUS          = <span class="string">'PLUS'</span></span><br><span class="line">MINUS         = <span class="string">'MINUS'</span></span><br><span class="line">MUL           = <span class="string">'MUL'</span></span><br><span class="line">INTEGER_DIV   = <span class="string">'INTEGER_DIV'</span> <span class="comment">#整型数的除法</span></span><br><span class="line">FLOAT_DIV     = <span class="string">'FLOAT_DIV'</span> <span class="comment">#浮点数的除法</span></span><br><span class="line">LPAREN        = <span class="string">'LPAREN'</span> <span class="comment">#左小括号</span></span><br><span class="line">RPAREN        = <span class="string">'RPAREN'</span> <span class="comment">#右小括号</span></span><br><span class="line">ID            = <span class="string">'ID'</span> <span class="comment">#表示有效的标识符</span></span><br><span class="line">ASSIGN        = <span class="string">'ASSIGN'</span> <span class="comment">#这种token表示两个字符，“:=”,用于赋值语句</span></span><br><span class="line">BEGIN         = <span class="string">'BEGIN'</span> </span><br><span class="line">END           = <span class="string">'END'</span></span><br><span class="line">SEMI          = <span class="string">'SEMI'</span> <span class="comment"># 表示分号，用于标记复合语句中的一个句子的结尾</span></span><br><span class="line">DOT           = <span class="string">'DOT'</span> <span class="comment">#点，用于Pascal语言中program的定义</span></span><br><span class="line">PROGRAM       = <span class="string">'PROGRAM'</span> </span><br><span class="line">VAR           = <span class="string">'VAR'</span></span><br><span class="line">COLON         = <span class="string">'COLON'</span> <span class="comment">#冒号</span></span><br><span class="line">COMMA         = <span class="string">'COMMA'</span> <span class="comment">#逗号</span></span><br><span class="line">EOF           = <span class="string">'EOF'</span></span><br></pre></td></tr></table></figure></li><li><p>保留字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RESERVED_KEYWORDS = &#123;</span><br><span class="line">    <span class="string">'PROGRAM'</span>: Token(<span class="string">'PROGRAM'</span>, <span class="string">'PROGRAM'</span>),</span><br><span class="line">    <span class="string">'VAR'</span>: Token(<span class="string">'VAR'</span>, <span class="string">'VAR'</span>),</span><br><span class="line">    <span class="string">'DIV'</span>: Token(<span class="string">'INTEGER_DIV'</span>, <span class="string">'DIV'</span>),</span><br><span class="line">    <span class="string">'INTEGER'</span>: Token(<span class="string">'INTEGER'</span>, <span class="string">'INTEGER'</span>),</span><br><span class="line">    <span class="string">'REAL'</span>: Token(<span class="string">'REAL'</span>, <span class="string">'REAL'</span>),</span><br><span class="line">    <span class="string">'BEGIN'</span>: Token(<span class="string">'BEGIN'</span>, <span class="string">'BEGIN'</span>),</span><br><span class="line">    <span class="string">'END'</span>: Token(<span class="string">'END'</span>, <span class="string">'END'</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>词法分析器的结构：</p><ol><li><p>有一个<code>___init__</code>的函数，在创建实例的时候，就会自动调用这个方法；</p></li><li><p>一个提示错误的函数<code>error</code>；</p></li><li><p>然后开始处理“词”，这里有一个函数<code>advance</code>用于向前进一步(pos会➕1）：</p><ul><li><p><code>peek</code>：为了在以相同的字符开头时，区分是“保留字”还是“标识符”。</p><blockquote><p>在这里，我们可以在不消耗下一个字符的情况下去查看缓冲区：就是利用peek_pos移动查看下一个字符，而真正的pos不动。</p></blockquote></li><li><p><code>skip_comment</code>：处理注释；</p></li><li><p><code>skip_whitespace</code>：处理空格；</p></li><li><p><code>number</code>：在part10之前，叫做integer，因为现在不仅有整型数据，还有浮点型的。所以改名为number。</p></li><li><p><code>_id</code>：处理“标识符”和“保留字”</p></li></ul></li><li><p><code>get_next_token</code>：词法分析器的核心部分，前面的都是设计，现在才开始识别出一个个的token，下面就是列出识别token的种类：</p><blockquote><p>其实这里叫做：<code>get_token_and_go_next</code>比较直观，这个函数是，先识别出一个token，然后再继续寻找下一个token</p></blockquote><ol><li>左括号token：<strong>“{”</strong></li><li><strong>保留字</strong>token、<strong>标识符</strong>token。（用函数<code>_id()</code>来完成）</li><li><strong>整型变量</strong>token</li><li>赋值符号<strong>“:=”</strong>token</li><li>冒号<strong>“:”</strong>token</li><li>分号<strong>“;”</strong>token</li><li>逗号<strong>“,”</strong>token</li><li><strong>加、减、乘</strong> token</li><li>除法token<ul><li>整数除法：<strong>“DIV”</strong> token</li><li>浮点数除法：<strong>“/”</strong> token</li></ul></li><li>左小括号<strong>“(”</strong> token ； &amp; 右小括号<strong>“)”</strong> token</li><li>点<strong>“.”</strong> token</li></ol></li></ol></li></ul><h3 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h3><p>​ 语法分析，主要是分析词法分析器传过来的一个个token，分析它们之间的运算关系，即语法：</p><p>它们之间的关系，即语法，用<strong>抽象语法树</strong>来表示：</p><ol><li>一个基类：<code>AST</code>。（后面的继承于它）</li><li>一个二元操作符类：<code>BinOp(AST)</code>（表示加减乘除运算）</li><li></li></ol>]]></content>
    
    <summary type="html">
    
      总结
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Let&#39;s Build A Simple Interpreter" scheme="https://longlongqin.github.io/tags/Let-s-Build-A-Simple-Interpreter/"/>
    
  </entry>
  
  <entry>
    <title>我的云书签</title>
    <link href="https://longlongqin.github.io/archives/eaabd222.html"/>
    <id>https://longlongqin.github.io/archives/eaabd222.html</id>
    <published>2020-03-22T16:05:49.000Z</published>
    <updated>2020-04-19T14:38:29.545Z</updated>
    
    <content type="html"><![CDATA[<p center large><center><green>搜集学习资料&好用的工具</green></center></p><a id="more"></a><hr><h2 id="Ⅰ-CS-学习"><a href="#Ⅰ-CS-学习" class="headerlink" title="Ⅰ CS 学习"></a><red>Ⅰ CS 学习</red></h2><h3 id="00全科资料"><a href="#00全科资料" class="headerlink" title="00全科资料"></a>00全科资料</h3><h4 id="1-面试笔记集合"><a href="#1-面试笔记集合" class="headerlink" title="1. 面试笔记集合"></a>1. 面试笔记集合</h4><table><thead><tr><th>资源</th><th>描述</th></tr></thead><tbody><tr><td><strong><a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">CS-Notes</a></strong>、<a href="https://cyc2018.github.io/CS-Notes/#/" target="_blank" rel="noopener">网页版</a>、【<a href="https://github.com/longlongqin/CS-Notes" target="_blank" rel="noopener">备用链接</a>】</td><td>📚 技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计、Java、Python、C++</td></tr><tr><td><strong><a href="https://github.com/linw7/Skill-Tree" target="_blank" rel="noopener">准备秋招，欢迎来树上取果实</a></strong></td><td>这里将以最短的篇幅，最清晰的层级结构去总结那些对C++后台开发最为核心的内容。</td></tr><tr><td><strong><a href="https://github.com/zhengjianglong915/note-of-interview" target="_blank" rel="noopener">《互联网面试笔记》</a></strong></td><td>收集和分析互联网常见面试题，并将这些面试知识整理成文方便大家查阅。主要是面向java程序员，但基础知识部分不同语言程序员(c,c++,python等）都可以参考</td></tr><tr><td><strong><a href="https://github.com/huihut/interview" target="_blank" rel="noopener">C/C++笔记</a></strong></td><td>C/C++ 技术面试基础知识总结，包括语言、程序库、数据结构、算法、系统、网络、链接装载库等知识及面试经验、招聘、内推等信息。 <a href="https://interview.huihut.com" target="_blank" rel="noopener">https://interview.huihut.com</a></td></tr></tbody></table><hr><h4 id="2-教程集合"><a href="#2-教程集合" class="headerlink" title="2. 教程集合"></a>2. 教程集合</h4><ol><li><p><a href="https://github.com/Ewenwan/ShiYanLou" target="_blank" rel="noopener"><strong>学习C &amp; C++</strong></a></p><blockquote><p>学习C &amp; C++ &amp; python&amp;汇编语言 LLVM编译器 数据结构 算法 操作系统 单片机 linux 面试</p></blockquote></li></ol><hr><h3 id="01实用网站"><a href="#01实用网站" class="headerlink" title="01实用网站"></a>01实用网站</h3><ol><li><p><strong><a href="https://www.geeksforgeeks.org/" target="_blank" rel="noopener">geeksforgeeks</a></strong></p><blockquote><p>是印度的一家致力于计算机科学的百科全书，根据不同的用户计算机水平而发布不同的难度等级，从基础到专家级，内容涵盖了编程、算法、面试问题等。​</p></blockquote></li><li></li></ol><hr><h3 id="02项目练习"><a href="#02项目练习" class="headerlink" title="02项目练习"></a>02项目练习</h3><p><a href="https://github.com/tuvtran/project-based-learning#cc" target="_blank" rel="noopener">基于项目学习</a>（project-based-learning)</p><hr><h3 id="03编程相关书籍"><a href="#03编程相关书籍" class="headerlink" title="03编程相关书籍"></a>03编程相关书籍</h3><ol><li><a href="https://github.com/EbookFoundation/free-programming-books" target="_blank" rel="noopener">英文版</a></li><li><a href="https://github.com/justjavac/free-programming-books-zh_CN" target="_blank" rel="noopener">中文版</a></li></ol><hr><h3 id="04科目"><a href="#04科目" class="headerlink" title="04科目"></a>04科目</h3><h4 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h4><p>适合回顾知识点：<a href="https://oi-wiki.org/" target="_blank" rel="noopener">https://oi-wiki.org/</a></p><hr><table><thead><tr><th>学习教程</th><th>描述</th><th>状态</th></tr></thead><tbody><tr><td><a href="https://www.cnblogs.com/skywang12345/p/3603935.html" target="_blank" rel="noopener"><strong>数据结构与算法系列</strong></a></td><td>博客园中的一个博主写的</td><td><strong><u>再看</u>👁️</strong></td></tr><tr><td><strong><a href="https://github.com/nonstriater/Learn-Algorithms" target="_blank" rel="noopener">算法学习笔记</a></strong></td><td>这里的内容是学习算法过程的一些记录，希望能一直坚持下去。</td><td></td></tr><tr><td><a href="https://github.com/xiufengcheng/DATASTRUCTURE" target="_blank" rel="noopener">备用</a></td><td></td><td></td></tr></tbody></table><hr><table><thead><tr><th>可视化工具</th><th>描述</th></tr></thead><tbody><tr><td><strong><a href="https://visualgo.net/zh" target="_blank" rel="noopener">Visualgo</a></strong></td><td>可视化的观察数据结构的操作</td></tr><tr><td><strong><a href="http://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">David Galles可视化演示(JS)</a></strong></td><td>旧金山大学David Galles可视化演示(JS)</td></tr><tr><td><a href="https://github.com/algorithm-visualizer/algorithm-visualizer" target="_blank" rel="noopener"><strong>可以从代码中可视化算法</strong></a></td><td>算法可视化工具是一个交互式的在线平台，可以从代码中可视化算法。</td></tr><tr><td><a href="https://github.com/xiufengcheng/DATASTRUCTURE#可视化" target="_blank" rel="noopener"><strong>更多可视化工具</strong></a></td><td></td></tr></tbody></table><hr><h4 id="2-learn-OpenGL"><a href="#2-learn-OpenGL" class="headerlink" title="2. learn OpenGL"></a>2. learn OpenGL</h4><p>中文教学网址：<a href="https://learnopengl-cn.github.io/intro/" target="_blank" rel="noopener">https://learnopengl-cn.github.io/intro/</a></p><hr><h4 id="3-C-C"><a href="#3-C-C" class="headerlink" title="3. C/C++"></a>3. C/C++</h4><hr><p><strong>C语言相关：</strong></p><p><a href="https://wizardforcel.gitbooks.io/lcthw/content/" target="_blank" rel="noopener"><strong>笨办法学C</strong></a></p><hr><center>官方文档</center><ul><li><a href="https://en.cppreference.com/w/" target="_blank" rel="noopener"><strong>cppreference</strong></a></li></ul><hr><center>相关网站</center><table><thead><tr><th>网站</th><th>描述</th></tr></thead><tbody><tr><td><strong><a href="http://www.cplusplus.com/" target="_blank" rel="noopener">Cplusplus</a></strong></td><td>这也是一个学习 C++ 的优秀网站，除了提供相应的教程之外，还有一个很棒的论坛。和其它网站相比，它的价值更多体现在参考上，因为里面解释了许多编程概念，如果对某个特定的东西感到困惑，那么这些概念将会很有帮助。</td></tr><tr><td><strong><a href="https://www.tutorialspoint.com/cplusplus/index.htm" target="_blank" rel="noopener">TutorialsPoint</a></strong></td><td>Tutorialspoint 是一个顶级网站，之所以这么说，是因为你想学的任何技术（包括 C++），它几乎都提供了详细的教程。保存好就对了，超级有用。</td></tr><tr><td><strong><a href="https://github.com/fffaraz/awesome-cpp" target="_blank" rel="noopener">Awesome C++</a></strong></td><td>GitHub 上的 Awesome-XXX 系列的资源整理，awesome-cpp 就是 fffaraz 发起维护的 C++ 资源列表，内容包括：标准库、Web 应用框架、人工智能、数据库、图片处理、机器学习、日志、代码分析等</td></tr></tbody></table><hr><center>学习路线</center><p><a href="http://www.renrenstudy.com/default/cplus-advanced-learning/" target="_blank" rel="noopener">C++学习进阶(陈皓)</a></p><center>学习教程</center><table><thead><tr><th>资料</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.learncpp.com/cpp-tutorial/syntax-and-semantic-errors/" target="_blank" rel="noopener">LearnCpp</a></td><td>一个很好地C++学习网站</td></tr><tr><td><a href="https://www.cnblogs.com/nihaoCPP/p/3925336.html" target="_blank" rel="noopener">你好，C++</a></td><td>辅助学习文章阅读（有时间可以看）</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><hr><h2 id="Ⅱ-关注的博客"><a href="#Ⅱ-关注的博客" class="headerlink" title="Ⅱ 关注的博客"></a>Ⅱ 关注的博客</h2><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><ol><li><a href="http://linux.vbird.org/linux_basic/" target="_blank" rel="noopener"><strong>鳥哥的 Linux 私房菜</strong></a></li></ol><hr><h2 id="Ⅲ-Github中的资源"><a href="#Ⅲ-Github中的资源" class="headerlink" title="Ⅲ Github中的资源"></a>Ⅲ Github中的资源</h2><center>[github仓库排名](https://gitstar-ranking.com/repositories)</center><ol><li><p><a href="https://github.com/kamranahmedse/developer-roadmap" target="_blank" rel="noopener">web开发人员的路线图</a></p></li><li><p><strong>自学计算机课程的参考</strong></p><ul><li><p><strong><a href="https://github.com/ossu/computer-science-cn" target="_blank" rel="noopener">计算机技术与科学自学之旅</a></strong>(中文)</p><blockquote><p>开源社区大学计算机科学课程中文项目（OSSU CS CN)旨在为英语能力有待提高的中文学习者提供全中文的在线本科计算机科学学习课程。消除学习者在自学计算机课程中遇到的语言障碍。请注意本课程并不是英文课程的对照翻译，而是在其基础上结合地区实际情况提供全中文的在线教育。<strong>值得注意的是，我们仍然推荐学有余力者在学习完本课程后系统学习和掌握英语技能。</strong></p></blockquote></li><li><p><strong><a href="https://github.com/ossu/computer-science" target="_blank" rel="noopener">computer-science</a></strong></p><blockquote><p>通往免费自学计算机科学教育的道路!</p></blockquote></li></ul></li></ol><h2 id="Ⅱ-工具"><a href="#Ⅱ-工具" class="headerlink" title="Ⅱ 工具"></a><red>Ⅱ 工具</red></h2><h3 id="01写作相关"><a href="#01写作相关" class="headerlink" title="01写作相关"></a>01写作相关</h3><ol><li><p><strong>编辑器</strong></p><ul><li><p><strong><a href="https://github.com/mdnice/markdown-nice" target="_blank" rel="noopener">公众号排版(支持Markdown)</a></strong>：<strong>推荐</strong>【分为：Google插件 &amp; 在线版】</p><ul><li><a href="https://mdnice.com/" target="_blank" rel="noopener">在线版</a></li></ul></li><li><p><strong><a href="https://www.135editor.com/" target="_blank" rel="noopener">135编辑器</a></strong>：</p><blockquote><p>一款强大的微信公众号文章排版</p></blockquote></li></ul></li><li><p><strong>插件</strong></p><ul><li><p><a href="https://yiban.io/" target="_blank" rel="noopener">壹伴</a>：</p><blockquote><p>壹伴运营神器_新媒体小编最喜欢的微信排版工具</p></blockquote></li></ul></li><li><p><strong><a href="https://urlify.cn/" target="_blank" rel="noopener">短链生成</a></strong></p></li><li><p><strong><a href="https://squoosh.app/" target="_blank" rel="noopener">图片压缩</a></strong></p></li><li><p><strong><a href="http://tools.jb51.net/static/colorpicker/" target="_blank" rel="noopener">RGB及其它类型颜色查询</a></strong></p></li><li><p><strong>无版权图片</strong></p><ol><li><p><a href="https://pixabay.com/images/search/" target="_blank" rel="noopener"><strong>Pixabay</strong></a>：</p><blockquote><p>Pixabay是一个支持中文搜索的免费可商用图库。</p></blockquote></li><li><p><a href="https://gratisography.com/" target="_blank" rel="noopener"><strong>Gratisography</strong></a>：</p><blockquote><p>Gratisography是一个免费高分辨率摄影图片库，所有的图片都可以用于个人或者商业用途，每周更新图片你只需要点击即可下载。</p></blockquote></li><li><p><a href="https://unsplash.com/" target="_blank" rel="noopener"><strong>Unsplash</strong></a>：</p><blockquote><p>每天更新一张高质量的图片素材，全是生活中的景象作品，清新的生活气息图片。</p></blockquote></li><li><p><a href="https://www.pexels.com/" target="_blank" rel="noopener"><strong>Pexels</strong></a>：</p><blockquote><p>根据英文关键词搜索图片，还能根据不同颜色分类查找，匹配的图片复古自带滤镜，风格简约，图片质量很高，素材丰富。</p></blockquote></li><li><p><a href="https://visualhunt.com/" target="_blank" rel="noopener"><strong>VisualHunt</strong></a>：</p><blockquote><p>可以通过颜色来查找图片。</p></blockquote></li><li><p><a href="https://www.photock.jp/" target="_blank" rel="noopener"><strong>Photock</strong></a>：</p><blockquote><p>天空、水、河、海、草坪、火、山、动物、建筑、夜景、日本景点、日本历史文化图片等等。</p></blockquote></li><li><p><a href="http://pngimg.com/" target="_blank" rel="noopener"><strong>pngimg</strong></a>：</p><blockquote><p>全部都是无背景图片，非常适合那些需要png透明底配图的。而且它分类也很细，找起来方便。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/image-20200323143423265.png" alt="image-20200323143423265"></p></blockquote></li><li><p><a href="https://www.foodiesfeed.com/" target="_blank" rel="noopener"><strong>Foodiesfeed</strong></a>：</p><blockquote><p>专注于<u>美食</u>的图片网站，高清无水印，根据分类选择匹配关键词。</p></blockquote></li><li><p><a href="https://www.everypixel.com/" target="_blank" rel="noopener"><strong>Everypixel</strong></a>：</p><blockquote><p>Everypixel 是一款帮助用户寻找免费图片素材的搜索引擎，选择免费或付费，利用AI和图片分析技术筛选图片，并查看图片来源网站。</p></blockquote></li><li><p><a href="https://www.howtostartanllc.org/free-stock-photos/" target="_blank" rel="noopener">https://www.howtostartanllc.org/free-stock-photos/</a></p><blockquote><p>这是一个汇总了很多个免费图片网站的导航。</p></blockquote></li></ol></li></ol><hr><h3 id="02-云同步备份功能"><a href="#02-云同步备份功能" class="headerlink" title="02 云同步备份功能"></a>02 云同步备份功能</h3><ol><li><p><a href="https://www.jianguoyun.com/" target="_blank" rel="noopener"><strong>坚果云</strong></a></p><blockquote><p>可以实现本地与云端实时同步，还带有历史版本回退功能。缺点：每月上传只有1G容量，只能同步体积较小的文件。</p></blockquote></li><li><p><a href="https://www.fangcloud.com/" target="_blank" rel="noopener"><strong>亿方云</strong></a>：</p><blockquote><p>可以实现本地与云端实时同步，还带有历史版本回退功能。功能和坚果云类似。</p></blockquote></li></ol><hr><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li><a href="https://github.com/mdnice/markdown-resume" target="_blank" rel="noopener">Markdown 简历排版</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p center large&gt;&lt;center&gt;&lt;green&gt;搜集学习资料&amp;好用的工具&lt;/green&gt;&lt;/center&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="forme" scheme="https://longlongqin.github.io/tags/forme/"/>
    
  </entry>
  
  <entry>
    <title>凸包总结</title>
    <link href="https://longlongqin.github.io/archives/bf113a1c.html"/>
    <id>https://longlongqin.github.io/archives/bf113a1c.html</id>
    <published>2020-03-22T08:08:18.000Z</published>
    <updated>2020-04-19T14:38:29.547Z</updated>
    
    <content type="html"><![CDATA[<h2 id="凸包的相关“test”测试"><a href="#凸包的相关“test”测试" class="headerlink" title="凸包的相关“test”测试"></a><a href="https://www.longlongqin.github.io/archives/510d.html" target="_blank" rel="noopener">凸包的相关“test”测试</a></h2><p><strong>一些定义：</strong></p><ul><li><p><strong>凸包[Convex Hull]</strong>：简单理解为将很多钉子围住的“皮筋”。</p></li><li><p><strong>极点(Extreme Point)</strong>：有一个点集S。如果存在通过点P的直线L，使得点集S中除了点P之外的其他的点都在这个直线的同一侧，则这个点P就是<strong>极点(Extreme Points)</strong>。</p></li><li><p><strong>极边(Extreme Edge)</strong>：两个极点连成的边，剩余的所有点均会在该边的一侧。</p></li></ul><h3 id="To-Left-Test"><a href="#To-Left-Test" class="headerlink" title="To-Left Test"></a>To-Left Test</h3><p>To-Left测试是相对于另外这两个点所确定的那条<strong>有向</strong>直线而言的，任何一条有向直线不仅会把平面分成两部分，我们还可以知道哪一边是左边，哪一边是右边。To-Left，其实就是说这个点相对于刚才的那条有向线而言到底是位于它的左侧(就是true)，还是右侧(就是false)。</p><blockquote><p>这里用到了行列式来求三角形面积（请看下面手写证明）。下图中的这个行列式实际上算的是它的”面积(指：有向面积）”的<strong>两倍</strong>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ToLeft</span> <span class="params">(Point p, Point q, Point s)</span> <span class="comment">//判断点s对于线段pq的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Area2(p,q,s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Area2</span><span class="params">(Point p, Point q, Point s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.x*q.y - p.y*q.x + q.x*s.y - q.y*s.x</span><br><span class="line">            +s.x * p.y - s.y *p.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>行列式来求三角形面积的证明：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="%E5%87%B8%E5%8C%85%E6%80%BB%E7%BB%93/v2-7c2f030cc1b9012bfefe41f0598ec6e9_720w.jpg" alt="img"></p></blockquote><center>图片来源于：https://zhuanlan.zhihu.com/p/35543479</center><h3 id="In-Trangle-Test"><a href="#In-Trangle-Test" class="headerlink" title="In-Trangle Test"></a>In-Trangle Test</h3><p>其实这个算法就是判断点是否在三角形内部。</p><p>这个测试最直接的理解为：使用了三次<em>To-Left Test</em>，三角形有三条边，所以每一条边都测试一次：</p><ul><li>三次<em>To-Left Test</em>结果相同的（均为true或者是false），则证明在三角形内部。</li><li>三次结果中有一次不相同，则证明在三角形外部。</li></ul><h3 id="判断极边"><a href="#判断极边" class="headerlink" title="判断极边"></a>判断极边</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//判断极边的核心</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkEdge</span><span class="params">(Point S[], <span class="keyword">int</span> n, <span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> lEmpty =TRUE, REmpty = TRUE;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n&amp;&amp;(LEmpty||REmpty); k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k!=p &amp;&amp; k!=q)</span><br><span class="line">            ToLeft(S[p], S[q], S[k]) ? LEmpty=FALSE: REmpty=FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(LEmpty || REmpty)</span><br><span class="line">        S[p].extreme =S[q].extreme= TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="in-convex-polygon-test"><a href="#in-convex-polygon-test" class="headerlink" title="in-convex-polygon test"></a>in-convex-polygon test</h3><p><strong>判定待定点是否位于某多边形内部（in-convex-polygon test）</strong></p><p>实现的方法就是：按一定方向（约定为逆时针）凸包的每条边和待定点做ToLeft test，一旦有一次test为false就说明改点在凸包外面。</p><h2 id="构造凸包的方法"><a href="#构造凸包的方法" class="headerlink" title="构造凸包的方法"></a>构造凸包的方法</h2><h3 id="1-利用极点法"><a href="#1-利用极点法" class="headerlink" title="1 利用极点法"></a>1 利用<strong>极点法</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extremePoint</span> <span class="params">(<span class="built_in">point</span> S[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>; s&lt;n; s++)</span><br><span class="line">        S[s].extreme = TRUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>; p&lt;n; p++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> q=p+<span class="number">1</span>; q&lt;n; q++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> r=q+<span class="number">1</span>; r&lt;n; r++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>; s&lt;n; s++)</span><br><span class="line">                &#123;</span><br><span class="line"><span class="keyword">if</span>(s==p || s==q || s==r ||!S[s].extreme)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(Intriangle(S[p],S[q],S[r],S[s]))</span><br><span class="line">                        S[s].extreme = FALSE;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n^4)</p></blockquote><h3 id="2-利用极边法"><a href="#2-利用极边法" class="headerlink" title="2 利用极边法"></a>2 利用<strong>极边法</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> markEE（<span class="built_in">point</span> S[], <span class="keyword">int</span> n）</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++) <span class="comment">//将所有点的初始状态都设置成：非极点</span></span><br><span class="line">        S[K].extreme = FALSE; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p=<span class="number">0</span>; p&lt;n; p++) <span class="comment">//遍历每条边，看他是否是极边</span></span><br><span class="line">        <span class="keyword">for</span>(q=p+<span class="number">1</span>; q&lt;n; q++)</span><br><span class="line">            checkEdge(S,n,p,q) <span class="comment">//判断极边的核心</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//判断极边的核心</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkEdge</span><span class="params">(Point S[], <span class="keyword">int</span> n, <span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> lEmpty =TRUE, REmpty = TRUE;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n&amp;&amp;(LEmpty||REmpty); k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k!=p &amp;&amp; k!=q)</span><br><span class="line">            ToLeft(S[p], S[q], S[k]) ? LEmpty=FALSE: REmpty=FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(LEmpty || REmpty)</span><br><span class="line">        S[p].extreme =S[q].extreme= TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n^3)</p></blockquote><h3 id="3-incremental-construction（增量构造）"><a href="#3-incremental-construction（增量构造）" class="headerlink" title="3 incremental construction（增量构造）"></a>3 incremental construction（增量构造）</h3><p>详细讲解：<a href="https://www.longlongqin.github.io/archives/7c53.html" target="_blank" rel="noopener">https://www.longlongqin.github.io/archives/7c53.html</a></p><p><strong>该算法的核心步骤就是：</strong>复杂度 O(n^2)</p><ol><li><p>判定新加入点与凸包的位置关系：用<strong>in-convex-polygon test</strong></p><blockquote><p>in-convex-polygon test在上面有讲</p></blockquote></li><li><p>向凸包插入新点：<strong>support-line</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200311230823679.png" alt="新点准备插入现有凸包"></p><p>如上面的点x，如何插入现有凸包当中呢？</p><p><strong>插入过程：</strong>插入过程其实就是寻找两个连接点s和t，然后将新点x与t、s分别连接得到新的凸包。t、s两个点将原凸包的边界分成两部分：st和ts两个邮箱线段。构造新凸包就要保留远端st，舍弃近端ts。取代ts的是x和s、t的连接线xt和xs。其中xt、xs被称为<strong>切线（tangent）</strong>或者<strong>support line（支撑线）</strong>。（配合下图理解）</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/v2-8afbf4ebfa808eec9ffff8c111ae6465_720w.jpg" alt="img"></p><ul><li><p>现在就是<strong>如何找到t、s这两个点？</strong></p><p>在凸包上任取一点v，按<strong>逆</strong>时针方向v点会有一个直接前驱点和直接后继点。考察有向直线xv与点v直接前驱和直接后继的位置关系（两次to left test），记为一个<strong>pattern表</strong>。</p><p>【结果无非是四种情况：v的直接前驱和直接后继相对于有向直线xv的位置是RL，LR，LL，RR。例如上图黄色点v，是R和L；蓝色点v分别是L和R。实际上凸包边界st上所有点的pattern都为RL，ts上所有点的pattern都为LR。关键点在于：点S的pattern是LL，点t的pattern为RR。】</p></li></ul></li></ol><p>说了这么多，其实我们可以将上面的两步合为一步：<strong><u>对于每个待定点x，不必特意去考虑它与凸包的位置关系，而是遍历凸包上每一个点。</u></strong></p><blockquote><p>对于凸包<strong>边界</strong>上的每一个点，我们都能通过两次to left test迅速判断出pattern。</p><p>对于x位于凸包<strong>外部</strong>的情况，经过遍历凸包的点，我们很容易就能得到s和t的位置，得到两条support line，从而构造出新的凸包；</p><p>而对于x位于凸包<strong>内部</strong>的情况，凸包边界每个点都不可能出现RR或LL的情况，直接舍弃x即可。</p></blockquote><h3 id="4-Jarvis-March"><a href="#4-Jarvis-March" class="headerlink" title="4 Jarvis March"></a>4 Jarvis March</h3><p>详细讲解：<a href="https://longlongqin.github.io/archives/9c7f.html">https://longlongqin.github.io/archives/9c7f.html</a></p><p>又称：Gift Wrapping</p><p>算法步骤：</p><ol><li>初始化所有点，设置点集的初态为 <strong>非极点</strong></li><li>找到开始的第一个极点：用<strong>LTL方法</strong></li><li>寻找下一个极点：用<strong><em>ToLeft test</em></strong>寻找下一个极点</li><li>循环步骤3，直到找到所有极点</li></ol><p>也就是：首先从任何一个极点（用LTL确定）开始，然后找到一条以这个极点为端点的极边。然后沿着这个极边的另一个端点<strong>（endpoint）</strong>出发，再找出下一条极边。如此反复操作，最终会找到一条以最初极点为endpoint的极边，得到一个封闭的环，凸包也构造完成。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200312175230158.png" alt="image-20200312175230158"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LTL</span><span class="params">(Point S[], <span class="keyword">int</span> n)</span> <span class="comment">//寻找最下and最左的点作为第一个极点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ltl = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;n; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S[k].y &lt; S[ltl].y || (S[k].y==S[ltl].y &amp;&amp; S[k].x&lt;S[ltl].x) )</span><br><span class="line">            ltl = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ltl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Javis</span> <span class="params">(Point S[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; k++)</span><br><span class="line">    S[k].extreme=FALSE; <span class="comment">//1.将所有点标记为非极点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ltl = LTL(S, n); <span class="comment">//2.找到ltl</span></span><br><span class="line">    <span class="keyword">int</span> k = ltl; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        S[k].extreme = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">-1</span>; <span class="comment">//要找的下一个极点用s表示</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t=<span class="number">0</span>; t&lt;n; t++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (t!=k &amp;&amp; t!=s &amp;&amp; ( s==<span class="number">-1</span> || !ToLeft(S[K],S[s],S[t]) ) )</span><br><span class="line">                s = t; </span><br><span class="line">        &#125;  </span><br><span class="line">        S[k].succ = s; <span class="comment">//新的极边确定</span></span><br><span class="line">        k = s； <span class="comment">//更新k的值，变为下一次查找的边的起点</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(k != ltl) <span class="comment">//如果循环回到了原来的点，则结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度：Jarvis March算法算法的复杂度<strong>更准确的表示为O(nh)。</strong>h（凸包边界的点的个数）又由最终输出结果，即凸包本身来决定，输出结果决定了构造过程的复杂度，这就是所谓的“输出敏感性”。这种类型的算法又被称为output sensitive algorithm。这种特性在其它凸包算法中也会体现。</p><h3 id="5-Graham-Scan"><a href="#5-Graham-Scan" class="headerlink" title="5 Graham Scan"></a>5 Graham Scan</h3><p>详细讲解；<a href="https://longlongqin.github.io/archives/3478.html">https://longlongqin.github.io/archives/3478.html</a></p><p><strong>算法流程：</strong></p><ol><li><p><strong>预排序(presorting)</strong>：即找到某个基准点，然后将其余所有的点按照相对于基准点的<strong>极坐标</strong>排序。它主要做了三个事情：</p><blockquote><p>1、<strong>找出基准点</strong>：用<strong>lowest-then-leftmost point（LTL）</strong>，然后对其他点按照极坐标排序：根据极角排序的方法，在：（<a href="https://longlongqin.github.io/archives/510d.html#补：根据极角排序）">https://longlongqin.github.io/archives/510d.html#补：根据极角排序）</a></p><p>2、<strong>找出起始边</strong>：从排好序的点集，选取前两个点，就是起始边。</p><p>3、<strong>将起始边 与 剩下的n-2条边分别存储在不同的栈(stack)中：</strong>如下图</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="%E5%87%B8%E5%8C%85%E6%80%BB%E7%BB%93/image-20200314181609764.png" alt="栈：T和S"></p></blockquote></li><li><p><strong>Scan扫描</strong></p><p>这一步是算法的核心。</p><p>scan的过程主要关注三个点：<strong>栈S的栈顶（S[0]）、次栈顶（S[1]）和栈T的栈顶（T[0]）</strong>。也就下图红色标注的三个点：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/20180207210925858.jpg" alt="img"></p><ul><li>可以观察到，每次待处理的S[0]和S[1]构成的边一定是一条极边（如上图点1和点2），算法<strong>关键步骤</strong>就是对边这条极边和T[0]做to left test，判断T[0]位于边S[0]S[1]的左边还是右边。若在左边则继续拓展，若在右边则否定掉此前认定的极边。无论结果如何，每次判定都会将问题规模缩小一个单元，算法结束时T最终肯定为空。T空后，<strong>S中存留下的点正是凸包的极点</strong>，这些点自底而上正是凸包边界点的逆时针遍历，也得到了整个凸包构造问题的解。</li></ul></li></ol><p><strong>复杂度：</strong></p><p>Graham Scan算法复杂度由三部分决定：</p><ul><li>persorting，采用一般排序算法，复杂度是O(nlogn)</li><li>逐步迭代，O(n)：算法一步步纳入新点，会迭代n步。</li><li>scan，O(?)</li></ul><p><strong>所以算法的总体复杂度：O(nlogn + n * ?) ，可见scan的复杂度决定了算法总体的复杂度。</strong></p><ul><li>算法一步步纳入新点，会迭代n步。但是在每个点上都有可能做回溯操作，所以scan的复杂度是不确定的。我们来以上图最坏情况为例，到第8个点时判定为false，舍弃点7，回溯。下一步判断也为false，舍弃点6，回溯。如此回溯直到算法开始的点2。这次scan倒退了高达O(n)个点，如果每次scan都是如此那么算法整体复杂度就为：O(nlogn + n * n) = O(n^2)了，那这种算法的意义也就不大了。</li></ul><p>其实上述分析并非错误，只是不够精确。O(n^2)确实是Graham Scan算法的一个<strong>上界</strong>，但是这个上界并不是紧的。</p><p>问题就出在分析假定了每次都会出现回退高达O(n)个点。</p><p><strong>代码部分：</strong><a href="https://longlongqin.github.io/archives/d4fa.html">https://longlongqin.github.io/archives/d4fa.html</a></p><h2 id="6-Divide-And-Conquer"><a href="#6-Divide-And-Conquer" class="headerlink" title="6 [Divide And Conquer]"></a>6 [Divide And Conquer]</h2><p>详细讲解：<a href="https://longlongqin.github.io/archives/f32f.html">https://longlongqin.github.io/archives/f32f.html</a></p>]]></content>
    
    <summary type="html">
    
      对凸包这一章节的总结
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://longlongqin.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="凸包" scheme="https://longlongqin.github.io/tags/%E5%87%B8%E5%8C%85/"/>
    
  </entry>
  
</feed>
