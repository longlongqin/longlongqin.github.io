<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>龙龙‘S BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://longlongqin.github.io/"/>
  <updated>2020-06-01T14:26:13.452Z</updated>
  <id>https://longlongqin.github.io/</id>
  
  <author>
    <name>longlongqin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C&amp;C++/调试c++程序</title>
    <link href="https://longlongqin.github.io/archives/50be15c2.html"/>
    <id>https://longlongqin.github.io/archives/50be15c2.html</id>
    <published>2020-06-01T02:16:27.348Z</published>
    <updated>2020-06-01T14:26:13.452Z</updated>
    
    <content type="html"><![CDATA[<h1 id="语法和语义错误"><a href="#语法和语义错误" class="headerlink" title="语法和语义错误"></a>语法和语义错误</h1><p>原文：<a href="https://www.learncpp.com/cpp-tutorial/syntax-and-semantic-errors/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/syntax-and-semantic-errors/</a></p><hr><p>软件错误非常普遍。制作它们很容易，但要找到它们却很难。在本章中，我们将探索与在我们的c++程序中发现和清除bug相关的主题，包括学习如何使用集成调试器(IDE的一部分)。</p><p>当根据c++语言的语法编写无效的语句时，会发生<strong>语法错误</strong>。这包括错误，如缺少分号，使用未声明的变量，不匹配的括号或大括号等。例如，下面的程序包含相当多的语法错误:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt; <span class="string">"Hi there"</span>; &lt;&lt; x; <span class="comment">// invalid operator (&lt;), extraneous semicolon, undeclared variable (x)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> <span class="comment">// missing semicolon at end of statement</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>幸运的是，编译器通常会捕获语法错误并生成警告或错误，因此您可以轻松地识别和修复问题。然后只需重新编译，直到消除所有错误。</p><p>一旦你的程序正确编译，让它实际产生你想要的结果可能会很棘手。当语句在语法上有效，但没有按照程序员的意图执行时，就会发生<strong>语义错误</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" / "</span> &lt;&lt; b &lt;&lt; <span class="string">" = "</span> &lt;&lt; a / b; <span class="comment">// 除0没有定义</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现代编译器已经能够更好地检测某些类型的常见语义错误(例如使用未初始化的变量)。然而，在大多数情况下，编译器将无法捕获大多数这类问题，因为编译器的设计目的是加强语法，而不是意图。</p><p>在上面的例子中，错误是很容易发现的。但是在大多数重要的程序中，通过肉眼观察代码不容易发现语义错误。这就是调试技术可以派上用场的地方。</p><h1 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h1><p>原文：<a href="https://www.learncpp.com/cpp-tutorial/the-debugging-process/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/the-debugging-process/</a></p><p>假设您编写了一个程序，但是它不能正确地工作——代码编译得很好，但是当您运行它时，您将得到一个不正确的结果。你一定在什么地方犯了语义错误。你怎么找到它的?如果您一直遵循最佳实践，编写一些代码，然后对其进行测试，那么您可能已经很清楚错误在哪里了。或者你可能完全没有线索。</p><h2 id="调试的一般方法"><a href="#调试的一般方法" class="headerlink" title="调试的一般方法"></a>调试的一般方法</h2><p>一旦发现问题，调试问题通常包括五个步骤:</p><ol><li>找出问题的根本原因(通常是不能工作的代码行)</li><li>确保您理解问题发生的原因</li><li>决定如何解决这个问题</li><li>修复导致问题的问题</li><li>重新测试以确保问题已经解决，没有出现新的问题</li></ol><p>练习：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Adds two numbers</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y; <span class="comment">// function is supposed to add, but it doesn't</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// should produce 8, but produces 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码有一点很好: 错误非常明显，因为错误的答案通过第11行打印到屏幕上。这为我们的调查提供了一个起点。</p><p><strong>Find the root cause:</strong> On line 11, we can see that we’re passing in literals for arguments (5 and 3), so there is no room for error there. Since the inputs to function <em>add</em> are correct, but the output isn’t, it’s pretty apparent that function <em>add</em> must be producing the wrong value. The only statement in function <em>add</em> is the return statement, which must be the culprit. We’ve found the problem line. Now that we know where to focus our attention, noticing that we’re subtracting instead of adding is something you’re likely to find via inspection.</p><p><strong>Understand the problem:</strong> In this case, it’s obvious why the wrong value is being generated – we’re using the wrong operator.</p><p><strong>Determine a fix:</strong> We’ll simply change <em>operator-</em> to <em>operator+</em>.</p><p><strong>Repair the issue:</strong> This is actually changing <em>operator-</em> to <em>operator+</em> and ensuring the program recompiles.</p><p><strong>Retest:</strong> After implementing the change, rerunning the program will indicate that our program now produces the correct value of 8. For this simple program, that’s all the testing that’s needed.</p><p>This example is trivial, but illustrates the basic process you’ll go through when diagnosing any program.</p><h1 id="调试策略"><a href="#调试策略" class="headerlink" title="调试策略"></a>调试策略</h1><p>原文：<a href="https://www.learncpp.com/cpp-tutorial/a-strategy-for-debugging/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/a-strategy-for-debugging/</a></p><hr><p>在调试程序时，在大多数情况下，您的大部分时间都将花在寻找错误的实际位置上。一旦发现了问题，剩下的步骤 (修复问题并验证问题是否已修复) 相比之下通常是微不足道的。</p><h2 id="通过代码检查发现问题"><a href="#通过代码检查发现问题" class="headerlink" title="通过代码检查发现问题"></a>通过代码检查发现问题</h2><p>假设你注意到一个问题，你想要找出这个问题的原因。在许多情况下(<strong>特别是在较小的程序中</strong>)，我们可以很快确定问题所在。</p><p>然而，随着程序变得越来越复杂，通过代码检查发现问题也变得越来越复杂。</p><ul><li>首先，有更多的代码需要查看。在一个有数千行代码的程序中，查看每一行代码都要花费很长的时间(更不用说它是非常无聊的)。</li><li>其次，代码本身往往更复杂，出错的地方也更多。</li><li>第三，代码的行为可能不会给您提供很多关于哪里出了问题的线索。如果你写了一个程序来输出股票推荐，但实际上它什么也没输出，你可能就不知道从哪里开始寻找问题了。</li><li>最后，错误可能是由于错误的假设造成的。几乎不可能从视觉上发现由错误假设引起的错误，因为在检查代码时，您可能会做出相同的错误假设，而不会注意到错误。</li></ul><p>因此，如果我们有一个问题，我们不能通过代码检查发现，我们如何找到它?</p><h2 id="通过运行程序发现问题"><a href="#通过运行程序发现问题" class="headerlink" title="通过运行程序发现问题"></a>通过运行程序发现问题</h2><p>幸运的是，如果我们不能通过代码检查发现问题，那么我们可以采用另一种方法:<strong>我们可以观察程序运行时的行为，并尝试从中诊断问题。</strong>这种方法可以概括为:</p><ol><li>找出重现问题的方法</li><li>运行程序并收集信息以缩小问题所在</li><li>重复前面的步骤，直到找到问题为止</li></ol><p>在本章的其余部分，我们将讨论促进这种方法的技术。</p><h3 id="重现问题"><a href="#重现问题" class="headerlink" title="重现问题"></a>重现问题</h3><p>发现问题的第一步也是最重要的一步是能够重现问题。原因很简单: 除非你能观察到问题的发生，否则很难发现问题。</p><h3 id="关注问题"><a href="#关注问题" class="headerlink" title="关注问题"></a>关注问题</h3><p>一旦我们可以合理地重现问题，下一步就是找出问题在代码的什么地方。根据问题的性质，这可能是容易的，也可能是困难的。</p><h1 id="基本的调试策略"><a href="#基本的调试策略" class="headerlink" title="基本的调试策略"></a>基本的调试策略</h1><h2 id="调试策略-1-注释掉代码"><a href="#调试策略-1-注释掉代码" class="headerlink" title="调试策略#1:注释掉代码"></a>调试策略#1:注释掉代码</h2><p>如果程序显示出错误行为，减少必须搜索的代码量的一种方法是注释一些代码，看看问题是否仍然存在。如果问题仍然存在，注释掉的代码不负责。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    getNames(); <span class="comment">// ask user to enter a bunch of names</span></span><br><span class="line">    doMaintenance(); <span class="comment">// do some random stuff</span></span><br><span class="line">    sortNames(); <span class="comment">// sort them in alphabetical order</span></span><br><span class="line">    printNames(); <span class="comment">// print the sorted list of names</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们假设这个程序应该按字母顺序打印用户输入的名称，但是它按相反的字母顺序打印它们。问题在哪里?</p><p>它可以是上面的代码中的任何一个。但是我们可能怀疑<code>doMaintenance();</code>与这个问题没有任何关系，所以让我们注释掉它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    getNames(); <span class="comment">// ask user to enter a bunch of names</span></span><br><span class="line"><span class="comment">//    doMaintenance(); // do some random stuff</span></span><br><span class="line">    sortNames(); <span class="comment">// sort them in alphabetical order</span></span><br><span class="line">    printNames(); <span class="comment">// print the sorted list of names</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果问题消失了，那么问题一定是由<code>doMaintenance</code>引起的，我们应该把注意力集中在维护上。</p><p>但是，如果问题仍然存在(这种可能性更大)，那么我们就知道<code>doMaintenance</code>并不是错误，我们可以将该函数排除在外。这并不能帮助我们理解实际的问题是在对<code>doMaintenance</code>的调用之前还是之后，但是它减少了我们随后要检查的代码量。</p><p>不要忘记您注释掉了哪些函数，以便稍后取消注释!</p><h2 id="调试策略-2-验证代码流"><a href="#调试策略-2-验证代码流" class="headerlink" title="调试策略#2:验证代码流"></a>调试策略#2:验证代码流</h2><p>在更复杂的程序中常见的另一个问题是，程序调用一个函数的次数太多或太少(包括完全不调用)。</p><p>在这种情况下，将语句放在函数的顶部以打印函数名是很有帮助的。这样，当程序运行时，您就可以看到调用了哪些函数。</p><blockquote><p>当打印用于调试的信息时，使用<strong><code>std::cerr</code></strong>而不是std::cout。</p><ul><li>这样做的一个原因是std::cout可能会被缓冲，这意味着在您请求std::cout输出信息和它实际执行输出信息之间可能会有一个停顿。如果您使用std::cout输出，然后您的程序立即崩溃，那么std::cout可能还没有实际输出。这可能会误导你问题在哪里。</li><li>另一方面，std::cerr是无缓冲的，这意味着您发送给它的任何内容都会立即输出。这有助于确保所有调试输出尽快出现(以牺牲某些性能为代价，我们通常在调试时并不关心这些性能)。</li></ul></blockquote><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; getValue;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然我们希望这个程序打印值4，但它实际上会在不同的机器上打印不同的值。在作者的机器上，它打印:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00101424</span><br></pre></td></tr></table></figure><p>让我们在这些函数中添加一些调试语句:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"getValue() called\n"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main() called\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; getValue;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>在添加临时调试语句时，最好不要缩进它们。这使得以后更容易找到它们并移除。</strong></p></blockquote><p>现在，当这些函数执行时，它们将输出它们的名称，表明它们被调用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main() called</span><br><span class="line">00101424</span><br></pre></td></tr></table></figure><p>现在我们可以看到函数getValue从未被调用。调用函数的代码一定有问题。让我们仔细看看这句话:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; getValue;</span><br></pre></td></tr></table></figure><p>看，我们忘了函数调用的括号了。应该是:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"getValue() called\n"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main() called\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; getValue(); <span class="comment">// added parenthesis here</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将生成正确的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main() called</span><br><span class="line">getValue() called</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>我们可以删除临时调试语句。</strong></p><h2 id="调试策略-3-打印值"><a href="#调试策略-3-打印值" class="headerlink" title="调试策略#3:打印值"></a>调试策略#3:打印值</h2><p>对于某些类型的错误，程序可能正在计算或传递错误的值。</p><p>我们还可以输出变量(包括参数)或表达式的值，以确保它们是正确的。</p><p>考虑下面的程序，它本应该添加两个数字，但却不能正确工作:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printResult</span><span class="params">(<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The answer is: "</span> &lt;&lt; z &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getUserInput</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line"><span class="keyword">int</span> x&#123;&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x&#123; getUserInput() &#125;;</span><br><span class="line"><span class="keyword">int</span> y&#123; getUserInput() &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" + "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> z&#123; add(x, <span class="number">5</span>) &#125;;</span><br><span class="line">printResult(z);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是这个程序的一些输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Enter a number: 4</span><br><span class="line">Enter a number: 3</span><br><span class="line">4 + 3</span><br><span class="line">The answer is: 9</span><br></pre></td></tr></table></figure><p>这是不正确的。看到错误了吗?即使在这个简短的程序中，也很难发现它。让我们添加一些代码来调试我们的值:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printResult</span><span class="params">(<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The answer is: "</span> &lt;&lt; z &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getUserInput</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line"><span class="keyword">int</span> x&#123;&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x&#123; getUserInput() &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main::x = "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">int</span> y&#123; getUserInput() &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main::y = "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" + "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> z&#123; add(x, <span class="number">5</span>) &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main::z = "</span> &lt;&lt; z &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">printResult(z);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是上面的输出:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Enter a number: <span class="number">4</span></span><br><span class="line">main::x = <span class="number">4</span></span><br><span class="line">Enter a number: <span class="number">3</span></span><br><span class="line">main::y = <span class="number">3</span></span><br><span class="line"><span class="number">4</span> + <span class="number">3</span></span><br><span class="line">main::z = <span class="number">9</span></span><br><span class="line">The answer is: <span class="number">9</span></span><br></pre></td></tr></table></figure><p>变量x和y得到了正确的值，但变量z没有。问题必须在这两点之间，这使得函数<code>add()</code>成为一个关键问题。</p><p>让我们修改函数<code>add</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"add() called (x="</span> &lt;&lt; x &lt;&lt;<span class="string">", y="</span> &lt;&lt; y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//⭐</span></span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printResult</span><span class="params">(<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The answer is: "</span> &lt;&lt; z &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getUserInput</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line"><span class="keyword">int</span> x&#123;&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x&#123; getUserInput() &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main::x = "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">int</span> y&#123; getUserInput() &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main::y = "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" + "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> z&#123; add(x, <span class="number">5</span>) &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main::z = "</span> &lt;&lt; z &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">printResult(z);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Now we’ll <span class="built_in">get</span> the output:</span><br><span class="line"></span><br><span class="line">Enter a number: <span class="number">4</span></span><br><span class="line">main::x = <span class="number">4</span></span><br><span class="line">Enter a number: <span class="number">3</span></span><br><span class="line">main::y = <span class="number">3</span></span><br><span class="line">add() called (x=<span class="number">4</span>, y=<span class="number">5</span>)</span><br><span class="line">main::z = <span class="number">9</span></span><br><span class="line">The answer is: <span class="number">9</span></span><br></pre></td></tr></table></figure><p>变量y的值是3，但是我们的函数add却得到了参数y的值5，我们一定是传递了错误的参数。果然:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> z&#123; add(x, <span class="number">5</span>) &#125;;</span><br></pre></td></tr></table></figure><p>在这里。我们传递的是文字5，而不是变量y的值作为参数。这是一个简单的修复，然后我们可以<strong>删除调试语句</strong>。</p><h3 id="为什么使用-打印语句-进行调试不是很好"><a href="#为什么使用-打印语句-进行调试不是很好" class="headerlink" title="为什么使用 打印语句 进行调试不是很好"></a>为什么使用 打印语句 进行调试不是很好</h3><p>虽然将调试语句添加到用于诊断的程序中是一种常见的基本技术，也是一种功能性技术(特别是当调试器由于某种原因不可用时)，但它并不是很好，原因如下:</p><ol><li>调试语句使代码混乱。</li><li>调试语句会使程序的输出变得混乱。</li><li>在使用完调试语句之后，必须删除它们，这使得它们不可重用。</li><li>调试语句需要修改代码来添加和删除，这可能会引入新的错误。</li></ol><p>我们可以做得更好。我们将在以后的课程中探索如何做到这一点。</p><h1 id="更多的调试策略"><a href="#更多的调试策略" class="headerlink" title="更多的调试策略"></a>更多的调试策略</h1><h2 id="对调试代码进行条件化"><a href="#对调试代码进行条件化" class="headerlink" title="对调试代码进行条件化"></a>对调试代码进行条件化</h2><p>考虑以下包含一些调试语句的程序:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getUserInput</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"getUserInput() called\n"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line"><span class="keyword">int</span> x&#123;&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main() called\n"</span>;</span><br><span class="line">    <span class="keyword">int</span> x&#123; getUserInput() &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"You entered: "</span> &lt;&lt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当您完成调试语句时，您将需要删除它们，或者注释掉它们。然后，如果您稍后还想要它们，就必须将它们添加回去，或者取消注释。</p><p>一种更容易在程序中禁用和启用调试的方法是使用<strong>预处理器指令使调试语句有条件</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENABLE_DEBUG <span class="comment">// 注释出以禁用调试</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getUserInput</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENABLE_DEBUG  <span class="comment">//⭐</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"getUserInput() called\n"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">//⭐</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line"><span class="keyword">int</span> x&#123;&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENABLE_DEBUG  <span class="comment">//⭐</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main() called\n"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">//⭐</span></span></span><br><span class="line">    <span class="keyword">int</span> x&#123; getUserInput() &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"You entered: "</span> &lt;&lt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们可以通过 注释/取消注释 #define ENABLE_DEBUG 来启用调试。这允许我们重用以前添加的调试语句，然后在使用它们时禁用它们，而不必从代码中实际删除它们。</p><p>如果这是一个<strong>多文件程序，那么#define ENABLE_DEBUG将位于一个头文件中</strong>，该头文件包含在所有代码文件中，因此我们可以在单个位置 注释/取消注 释#define，并让它传播到所有代码文件。</p><p>这解决了必须删除调试语句的问题和这样做的风险：</p><ul><li>但代价是代码更加混乱。</li><li>这种方法的另一个缺点是，如果您输入错误(例如拼错“DEBUG”)或忘记将头文件包含到代码文件中，那么可能无法启用该文件的部分或全部调试。</li></ul><h2 id="使用一个日志记录器"><a href="#使用一个日志记录器" class="headerlink" title="使用一个日志记录器"></a>使用一个日志记录器</h2><p>通过预处理程序进行条件化调试的另一种方法 是将调试信息发送到<strong>日志文件</strong>。</p><blockquote><p><strong>日志文件</strong>是一个记录软件中发生的事件的文件(通常存储在磁盘上)。</p><p>将信息写入日志文件的过程称为<strong>日志记录</strong>。</p></blockquote><p>大多数应用程序和操作系统编写的日志文件可用于帮助诊断发生的问题。</p><p>日志文件有一些优点：</p><ul><li><p>因为写入日志文件的信息与程序的输出是分开的，所以可以避免将正常输出和调试输出混合在一起所造成的混乱。</p></li><li><p>日志文件也可以很容易地发送给其他人进行诊断——因此，如果使用您的软件的人遇到问题，您可以让他们将日志文件发送给您，这可能会帮助您了解问题所在。</p></li></ul><p>虽然可以编写自己的代码来创建日志文件并向它们发送输出，<strong>但是最好使用现有的第三方日志工具之一</strong>。你用哪一个取决于你。</p><p>为了便于说明，我们将展示使用<a href="https://github.com/SergiusTheBest/plog" target="_blank" rel="noopener">plog</a>日志记录器输出到日志记录器的内容。</p><blockquote><p>Plog是作为一组头文件实现的，因此很容易在任何需要的地方包含它，而且它是轻量级的，易于使用。</p></blockquote><h3 id="如何使用plog日志记录器"><a href="#如何使用plog日志记录器" class="headerlink" title="如何使用plog日志记录器"></a>如何使用plog日志记录器</h3><p>If you want to compile the above example yourself, or use plog in your own projects, you can follow these instructions to install it:</p><p>First, get the latest plog release:</p><ul><li>Visit the <a href="https://github.com/SergiusTheBest/plog" target="_blank" rel="noopener">plog</a> repo.</li><li>Click the “releases” tab (it’s in the same row as “commits”, “branches”, “packages”, etc…)</li><li>Under the release tagged as “latest release” on the left, click the link “Source code (zip)” to download the latest release.</li></ul><p>Next, unzip the entire archive to `` on your hard drive.</p><p>Finally, for each project, set the <code>\plog-\include\</code> directory as an <code>include directory</code> inside your IDE. There are instructions on how to do this for Visual Studio here: <a href="https://www.learncpp.com/cpp-tutorial/a2-using-libraries-with-visual-studio-2005-express/" target="_blank" rel="noopener">A.2 – Using libraries with Visual Studio</a> and Code::Blocks here: <a href="https://www.learncpp.com/cpp-tutorial/a3-using-libraries-with-codeblocks/" target="_blank" rel="noopener">A.3 – Using libraries with Code::Blocks</a>.</p><h1 id="使用集成调试器-单步调试"><a href="#使用集成调试器-单步调试" class="headerlink" title="使用集成调试器: 单步调试"></a>使用集成调试器: 单步调试</h1><p>原文：<a href="https://www.learncpp.com/cpp-tutorial/using-an-integrated-debugger-stepping/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/using-an-integrated-debugger-stepping/</a></p><hr><p>当您运行程序时，执行从主函数的顶部开始，然后一个语句接着一个语句地执行，直到程序结束。</p><p>在任何时候当你的程序运行时,程序跟踪很多事情：你使用的变量的值，调用了哪些函数(当这些函数返回,程序将知道回到)，以及程序内的当前执行点(所以它知道这语句执行下一个)。所有这些被跟踪的信息都称为您的<strong>程序状态</strong>(或者简称为<strong>状态</strong>)。</p><p>在以前的课程中，我们探讨了各种修改代码以帮助调试的方法，包括打印诊断信息或使用日志记录器。这些是在程序<strong>运行时</strong>检查程序状态的简单方法。</p><p>尽管这些方法如果使用得当是有效的，但是它们仍然有缺点:</p><ul><li>它们需要修改代码，这需要时间，并且可能会引入新的错误，而且它们会使代码变得混乱，使现有的代码更难理解。</li></ul><p>到目前为止，我们所展示的技术背后有一个未阐明的假设:一旦我们运行代码，它就会运行到完成(只有在接受输入时才会暂停)，而我们没有机会在任何我们想要的地方干预和检查程序的结果。</p><p>但是，如果我们能够去掉这个假设呢?幸运的是,我们可以。大多数现代IDE都带有一个集成的工具，称为<strong>调试器</strong>，它的设计目的就是实现这一点。</p><h2 id="调试器"><a href="#调试器" class="headerlink" title="调试器"></a>调试器</h2><p><strong>调试器</strong>是一种计算机程序，它允许程序员控制程序的执行方式，并在程序运行时检查程序状态。例如，程序员可以使用调试器逐行执行程序，同时检查变量的值。通过比较变量的实际值和预期值，或者观察代码的执行路径，调试器可以极大地帮助跟踪语义(逻辑)错误。</p><p>调试器背后的强大功能有两方面：</p><ul><li>精确控制程序执行的能力；</li><li>以及 查看(和修改，如果需要)程序状态的能力。</li></ul><p>早期的调试器(如<a href="http://en.wikipedia.org/wiki/Gdb" target="_blank" rel="noopener">gdb</a>)是具有命令行接口的独立程序，程序员必须在命令行中输入晦涩难懂的命令才能工作。</p><p>后来的调试器(例如Borland的 <a href="http://en.wikipedia.org/wiki/Turbo_Debugger" target="_blank" rel="noopener">turbo debugger</a>的早期版本)仍然是独立的，但是有了自己的“图形化”前端，使得使用它们更加容易。</p><p>现在，大多数现代ide都有<strong>集成的调试器</strong>——也就是说，调试器使用与代码编辑器相同的接口，因此可以使用编写代码时使用的环境进行调试(而不必切换程序)。</p><p>几乎所有现代调试器都包含相同的基本特性标准集——然而，在如何安排菜单来访问这些功能方面几乎没有一致性，键盘快捷键的一致性就更少了。</p><p>本章的其余部分将用于学习如何使用调试器。</p><blockquote><p><strong>不要忽视学习使用调试器。随着程序变得越来越复杂，与查找和修复问题所节省的时间相比，学习如何有效地使用集成调试器所花费的时间就显得微不足道了。</strong></p></blockquote><h3 id="Step-into"><a href="#Step-into" class="headerlink" title="Step into"></a>Step into</h3><blockquote><p>In Visual Studio, the <em>step into</em> command can be accessed via <em>Debug menu &gt; Step Into</em>, or by pressing the F11 shortcut key.</p></blockquote><p>step into命令在程序的正常执行路径中执行下一个语句，然后暂停程序的执行，以便我们可以使用调试器检查程序的状态。</p><blockquote><p>如果正在执行的语句包含一个函数调用，单步执行会导致程序跳转到正在调用的函数的顶部，并在那里暂停。</p></blockquote><p>当你的程序不运行，你执行第一个调试命令，你可能会看到相当多的事情发生:</p><ul><li>如果需要，程序将重新编译。</li><li>程序将开始运行。因为我们的应用程序是一个控制台程序，所以应该打开控制台输出窗口。它将是空的，因为我们还没有输出任何东西。</li><li>您的IDE可能会打开一些诊断窗口，这些窗口的名称可能是“诊断工具”、“调用堆栈”和“监视”。稍后我们将介绍其中的一些内容—现在您可以忽略它们。</li></ul><h3 id="Step-over"><a href="#Step-over" class="headerlink" title="Step over"></a>Step over</h3><blockquote><p>In Visual Studio, the <em>step over</em> command can be accessed via <em>Debug menu &gt; Step Over</em>, or by pressing the F10 shortcut key.</p></blockquote><p>与step into类似，step over命令在程序的正常执行路径中执行下一条语句。但是，step into将输入函数调用并逐行执行它们，而<strong>step over将执行整个函数而不停止并在函数执行后将控制权返回给您。</strong></p><h3 id="Step-out"><a href="#Step-out" class="headerlink" title="Step out"></a>Step out</h3><blockquote><p>In Visual Studio, the <em>step out</em> command can be accessed via <em>Debug menu &gt; Step Out</em>, or by pressing the Shift-F11 快捷键组合.</p></blockquote><p>与其他两个单步执行命令不同，<strong>Step out</strong>不只是执行下一行代码。相反，<strong>它执行当前正在执行的函数中的所有剩余代码，然后在函数返回时将控制权返回给您。</strong></p><h3 id="Step-back"><a href="#Step-back" class="headerlink" title="Step back"></a>Step back</h3><p>一些调试器(如Visual Studio Enterprise Edition和GDB 7.0)引入了单步调试功能，通常称为<strong>单步后退</strong>或<strong>反向调试</strong>（<em>step back</em> or <em>reverse debugging</em>）。</p><p><strong>Step back</strong>的目的是回退最后一步，这样您就可以将程序返回到先前的状态。如果您执行的操作超过了一步，或者您想重新检查刚刚执行的语句，那么这将非常有用。由于其复杂性，这种功能还没有标准化，并且会因调试器的不同而有所不同。截止到编写本文时(2019年1月)，Visual Studio Community edition和最新版本的Code::Blocks都不支持这种功能。希望在未来的某个时候，它会慢慢渗透到这些产品中，并被更广泛的使用。</p><h1 id="使用集成调试器-运行和断点"><a href="#使用集成调试器-运行和断点" class="headerlink" title="使用集成调试器: 运行和断点"></a>使用集成调试器: 运行和断点</h1><h2 id="运行到光标处"><a href="#运行到光标处" class="headerlink" title="运行到光标处"></a>运行到光标处</h2><p>第一个有用的命令通常称为<strong>Run to cursor（运行到光标处）</strong>。这个<strong>Run to cursor</strong>命令执行程序，直到执行到光标所选择的语句为止。然后，它将控制权返回给您，以便您可以从该点开始调试。</p><p>这是一种高效的方式，可以在代码中的特定点开始调试，或者如果已经在调试，则可以直接移动到需要进一步检查的位置。</p><blockquote><p><strong>For Visual Studio users</strong></p><p>在Visual Studio中，右击代码中的语句并从上下文菜单中选择run to cursor，或者按下ctrl-F10组合键，就可以访问run to cursor命令。</p></blockquote><h2 id="Continue"><a href="#Continue" class="headerlink" title="Continue"></a>Continue</h2><p>在调试会话进行到一半时，您可能希望从那时开始运行程序。最简单的方法是使用<strong>continue命令</strong>。</p><p><strong>continue 调试命令</strong>只是继续按正常方式运行程序，直到程序终止，或者直到有东西触发控件再次返回给您(例如断点，我们将在本课后面介绍)。</p><blockquote><p><strong>For Visual Studio users</strong></p><p>在Visual Studio中，可以通过Debug <em>menu</em>&gt; <em>continue</em> 或 按F5快捷键在调试程序时访问continue命令。</p></blockquote><h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><p>continue命令有一个名为start的孪生兄弟。start命令执行与continue相同的操作，<strong>只是从程序的开头开始。它只能在不在调试会话中调用。</strong></p><blockquote><p>在Visual Studio中，<strong>可以在不调试程序的情况下</strong>通过 Debug <em>menu</em> &gt; start debugging 或按下F5快捷键来访问start命令。</p></blockquote><h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><p>本节要讨论的最后一个主题是断点。<strong>断点</strong>是一种特殊的标记，它告诉调试器在调试模式下运行时，在断点处停止程序的执行。</p><blockquote><p><strong>For Visual Studio users</strong></p><p>在Visual Studio中,可以通过设置或删除断点 <em>Debug menu &gt; Toggle Breakpoint</em>, 或右键单击一个语句, 从上下文菜单中选择Toggle breakpoint或按 F9快捷键,或通过点击左边的行号(浅灰色区域)。</p></blockquote><h2 id="设置下一条语句"><a href="#设置下一条语句" class="headerlink" title="设置下一条语句"></a>设置下一条语句</h2><p>还有一个调试命令使用得非常不常见，但至少值得了解，即使您不经常使用它。</p><p><strong>设置下一条语句</strong> 命令允许我们将执行点更改为其他一些语句(有时也称为<strong>跳转</strong>)。这可以用来向前跳转执行点，跳过一些本来要执行的代码，或者向后跳转，让已经执行的代码重新运行。</p><blockquote><p><strong>For Visual Studio users</strong></p><p>在Visual Studio中，您可以通过右键单击一个语句并从上下文菜单中选择<em>Set next statement</em>，或者按下Ctrl-Shift-F10快捷组合键来跳过执行点。此选项与上下文相关，<strong>仅在已经调试程序时才会出现。</strong></p></blockquote><p>注意：</p><p><em>set next statement</em> 命令将更改执行点，但不会更改程序状态。您的变量将保留它们在跳转之前的任何值。因此，与其他情况相比，跳转可能会导致程序产生不同的值、结果或行为。明智地使用此功能(特别是向后跳转)。</p><p>不应该使用<em>set next statement</em> 将执行点更改为其他函数。这将导致未定义的行为，并可能导致崩溃。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>现在，您了解了使用集成调试器监视和控制程序执行方式的主要方法。虽然这些命令对于诊断代码流问题非常有用(例如，确定是否调用某些函数)，但是它们只是集成调试器给表带来的好处的一部分。</p><p>在下一课中，我们将开始探索检查程序状态的其他方法，您将需要这些命令作为先决条件。我们走吧!</p><h1 id="使用集成调试器-监视变量"><a href="#使用集成调试器-监视变量" class="headerlink" title="使用集成调试器: 监视变量"></a>使用集成调试器: 监视变量</h1><h2 id="监视变量"><a href="#监视变量" class="headerlink" title="监视变量"></a>监视变量</h2><p><strong>监视变量是在程序以调试模式执行时检查变量值的过程</strong>。大多数调试器都提供了几种方法来实现这一点。</p><ul><li><p><strong>检查简单变量(如x) 值的最简单方法是将鼠标悬停在变量x上</strong>。一些现代调试器支持这种检查简单变量的方法，这是最直接的方法。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-Watch2-min.png" alt="img"></p><blockquote><p>注意，您可以将鼠标悬停在任何变量x上，而不仅仅是当前行上的变量x。例如，如果我们将鼠标悬停在第12行x上，我们将看到相同的值:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-Watch3-min.png" alt="img"></p></blockquote></li><li><p>如果你在使用Visual Studio，你也可以使用<strong>QuickWatch</strong>。用鼠标高亮显示变量名x，然后从右键菜单中选择“QuickWatch”。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-QuickWatch1-min.png" alt="img"></p><p>这将打开一个包含变量当前值的子窗口:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-QuickWatch2-min.png" alt="img"></p><p>如果你打开了QuickWatch，请关闭它</p></li></ul><h2 id="监视窗口"><a href="#监视窗口" class="headerlink" title="监视窗口"></a>监视窗口</h2><p>如果你想知道一个变量的值在一个特定的时间点 ，使用<strong>鼠标悬停</strong>或<strong>QuickWatch</strong>方法检查变量很好。但是，它并不特别适合在运行代码时监视变量更改的值，因为您必须不断地 重新悬停/重新选择变量。</p><p>为了解决这个问题，所有现代集成调试器都提供了另一个特性，称为<strong>监视窗口</strong>。</p><p><strong>监视窗口</strong>是一个窗口，您可以在其中添加您想要持续检查的变量，并且当您单步执行程序时，这些变量将被更新。</p><p>当您进入调试模式时，监视窗口可能已经在您的屏幕上了，但是如果不是这样，您可以通过IDE的窗口命令(通常在视图或调试菜单中可以找到这些命令)打开它。</p><blockquote><p><strong>For Visual Studio users</strong></p><p>在Visual Studio中，<em>Debug menu &gt; Windows &gt; Watch &gt; Watch 1</em>. 中可以找到监视菜单。请注意，<strong>要启用此选项，必须处于调试模式，因此请先进入程序。</strong></p><p>此窗口出现的位置(停靠左、右或底部)可能不同。您可以通过将Watch 1选项卡拖动到应用程序窗口的另一侧来更改其停靠位置。</p></blockquote><p>超出作用域的变量(例如，函数中已经返回给调用者的局部变量)将留在您的监视窗口中，但通常要么被标记为“不可用”，要么显示最后一个已知值，但显示为灰色。如果变量返回到作用域(例如再次调用函数)，它的值将再次显示。因此，即使变量不在监视范围内，也可以将它们留在监视窗口中。</p><h2 id="监视窗口可以计算表达式"><a href="#监视窗口可以计算表达式" class="headerlink" title="监视窗口可以计算表达式"></a>监视窗口可以计算表达式</h2><p><strong>监视窗口</strong>还允许计算简单表达式。</p><h2 id="局部监视"><a href="#局部监视" class="headerlink" title="局部监视"></a>局部监视</h2><p>因为在调试时检查函数内部局部变量的值是很常见的，所以许多调试器会提供某种方式来快速监视 作用域中所有局部变量的值。</p><blockquote><p><strong>For Visual Studio users</strong></p><p>在Visual Studio中，可以在<strong>局部变量窗口</strong>中看到所有局部变量的值，可以在<em>Debug menu &gt; Windows &gt; Locals</em> 中找到。请注意，<strong>您必须处于调试会话中才能激活此窗口。</strong></p></blockquote><h1 id="使用集成调试器-调用栈"><a href="#使用集成调试器-调用栈" class="headerlink" title="使用集成调试器: 调用栈"></a>使用集成调试器: 调用栈</h1><p>现代调试器还包含一个调试信息窗口，它在调试程序时非常有用，即<strong>调用堆栈窗口</strong>。</p><p>当您的程序调用一个函数时，您已经知道它标记了当前位置，进行了函数调用，然后返回。它怎么知道回到哪里去? <strong>答案是它在调用堆栈中保持跟踪</strong>。</p><p>调用堆栈是所有已被调用以到达当前执行点的活动函数的列表。调用堆栈包括每个被调用函数的条目，以及函数返回时将返回到哪一行代码。</p><p>每当调用一个新函数时，该函数都会被添加到调用堆栈的顶部。当 当前函数返回给调用方时，它将从调用堆栈的顶部移除，而控制将返回给它下面的函数。</p><p><strong>“调用堆栈”窗口</strong>是一个显示当前调用堆栈的调试器窗口。如果没有看到“调用堆栈”窗口，则需要告诉IDE显示它。</p><blockquote><p><strong>For Visual Studio users</strong></p><p>在Visual Studio中，可以通过 <em>Debug menu &gt; Windows &gt; Call Stack</em>。请注意，<strong>您必须处于调试会话中才能激活此窗口。</strong></p></blockquote><hr><p>祝贺您，现在您已经了解了使用集成调试器的基本知识!通过使用单步执行、断点、监视和调用堆栈窗口，您现在已经具备了调试几乎所有问题的基础知识。</p><p>像许多事情一样，要想熟练使用调试器，需要一些实践和反复试验。但是，我们再次重申，花在学习如何有效使用集成调试器上的时间将比花在调试程序上的时间节省许多倍!</p><h1 id="在问题变成问题之前找到问题"><a href="#在问题变成问题之前找到问题" class="headerlink" title="在问题变成问题之前找到问题"></a>在问题变成问题之前找到问题</h1><p>当您犯语义错误时，当您运行程序时，这个错误可能不会立即被发现。一个问题可能潜伏在你的代码中很长一段时间都没有被发现，直到新引入的代码或改变的环境导致它作为程序故障出现。</p><p>在找到错误之前，错误在代码库中停留的时间越长，就越有可能难以找到它，本来很容易修复的错误会变成一场耗费时间和精力的调试冒险。</p><p>我们能做些什么呢?</p><h2 id="不要犯错误"><a href="#不要犯错误" class="headerlink" title="不要犯错误"></a>不要犯错误</h2><p>最好的办法是一开始就不要犯错误。这里有一个不完整的清单，可以帮助避免犯错误:</p><ul><li>遵循最佳实践</li><li>累了就别编程</li><li>了解一门语言中常见的陷阱(我们警告过你不要做的所有事情)</li><li>保持程序简单</li><li>不要让函数太长</li><li>尽可能使用标准库而不是编写自己的代码。</li><li>使用注释</li></ul><h2 id="重构功能"><a href="#重构功能" class="headerlink" title="重构功能"></a>重构功能</h2><p>当您向程序添加新功能(“行为更改”)时，您会发现一些函数的长度在增加。随着函数变长，它们变得更加复杂和难以理解。</p><p>解决这个问题的一种方法是将一个长函数分解成多个短函数。在不改变代码行为(通常是为了使其更易于维护)的情况下对代码进行结构更改的过程称为<strong>重构</strong>。</p><blockquote><p>那么对于一个函数，多长才算长呢?</p><p>一个占据一个垂直屏幕的函数通常被认为太长——如果必须滚动才能阅读整个函数，那么函数的可理解性就会显著下降。但是越短越好——函数小于10行就很好。小于5行的函数甚至更好。</p></blockquote><h2 id="介绍防御性编程"><a href="#介绍防御性编程" class="headerlink" title="介绍防御性编程"></a>介绍防御性编程</h2><p>错误不仅可能是您自己造成的(例如，不正确的逻辑)，还可能发生在您的用户以您没有预料到的方式使用应用程序时。</p><blockquote><p>例如，如果您要求用户输入一个整数，而用户输入的却是字母，那么在这种情况下，您的程序是如何运行的呢?除非您预料到了这一点，并为本例添加了一些错误处理，否则情况可能不太好。</p></blockquote><p><strong>防御性编程</strong>是一种实践，程序员试图预测软件可能被最终用户或使用代码的其他开发人员(包括程序员自己)滥用的所有方式。这些误用通常可以被发现，然后减轻(例如，要求输入错误输入的用户重试)。</p><p>我们将在以后的课程中探索与错误处理相关的主题。</p><h2 id="快速找到错误"><a href="#快速找到错误" class="headerlink" title="快速找到错误"></a>快速找到错误</h2><p>由于在大型程序中不出错是很困难的，所以下一个最好的方法就是快速捕获您确实犯的错误。</p><p><strong>最好的方法是每次编写一点程序，然后测试代码并确保它能正常工作。</strong></p><p>然而，还有一些其他的技术我们也可以使用。</p><h3 id="测试功能介绍"><a href="#测试功能介绍" class="headerlink" title="测试功能介绍"></a>测试功能介绍</h3><p>帮助发现程序问题的一种常见方法是<strong>编写测试函数来“练习”所编写的代码</strong>。这里有一个原始的尝试，更多的是为了说明的目的比任何东西:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testadd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"This function should print: 2 0 0 -2\n"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">1</span>, <span class="number">1</span>) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">-1</span>, <span class="number">1</span>) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">1</span>, <span class="number">-1</span>) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">-1</span>, <span class="number">-1</span>) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">testadd();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>testadd()函数通过使用不同的值调用add()函数来测试它。如果所有的值都符合我们的期望，那么我们就可以合理地确信函数是有效的。更好的是，我们可以保留这个函数，并在每次更改函数add时运行它，以确保我们没有意外地破坏它。</p><p>这是<strong>单元测试</strong>的基本形式，<strong>单元测试是一种软件测试方法，通过测试小单元的源代码来确定它们是否正确。</strong></p><p>与日志记录框架一样，可以使用许多第三方单元测试框架。也可以自己编写，不过我们需要更多的语言特性来处理主题。我们将在以后的课程中对此进行讨论。</p><h3 id="约束条件介绍"><a href="#约束条件介绍" class="headerlink" title="约束条件介绍"></a>约束条件介绍</h3><p>基于约束的技术包括添加一些额外的代码(如果需要，可以在非调试版本中编译)，以检查是否违反了一些假设或期望。</p><p>例如，如果我们编写一个函数来计算一个数字的阶乘，这个函数需要一个非负参数，那么该函数可以进行检查，以确保调用者在继续之前传入了一个非负的数字。如果调用方传入一个负数，那么函数可能会立即出错，而不是生成一些不确定的结果，从而帮助确保立即捕获问题。</p><p><strong>一种常见的方法是通过assert和static_assert</strong>，我们在<strong><a href="https://www.learncpp.com/cpp-tutorial/7-12a-assert-and-static_assert/" target="_blank" rel="noopener">7.12a – Assert and static_assert</a>.</strong>中介绍了这两个方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;语法和语义错误&quot;&gt;&lt;a href=&quot;#语法和语义错误&quot; class=&quot;headerlink&quot; title=&quot;语法和语义错误&quot;&gt;&lt;/a&gt;语法和语义错误&lt;/h1&gt;&lt;p&gt;原文：&lt;a href=&quot;https://www.learncpp.com/cpp-tutorial/
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C&amp;C++/静态与动态链接库</title>
    <link href="https://longlongqin.github.io/archives/d30baea4.html"/>
    <id>https://longlongqin.github.io/archives/d30baea4.html</id>
    <published>2020-05-31T06:49:00.247Z</published>
    <updated>2020-06-01T01:09:23.341Z</updated>
    
    <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/a1-static-and-dynamic-libraries/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/a1-static-and-dynamic-libraries/</a></p><hr><p><strong>库(library)</strong>是一个代码包，可以被许多程序重用。通常，一个c++库分为两部分:</p><ul><li>一个<strong>头文件</strong>，定义库向使用它的程序公开(提供)的功能。</li><li>预编译的<strong>二进制文件</strong>，包含预编译成机器语言的功能的实现。</li></ul><p><strong>一些库可能被分成多个文件和/或具有多个头文件。</strong></p><p><strong>预编译库</strong>有几个原因：</p><ul><li>首先，由于库很少更改，它们不需要经常重新编译。每次编写使用它们的程序时都重新编译库是浪费时间。</li><li>其次，因为预编译对象是机器语言的，所以它阻止人们访问或更改源代码，这对于企业或不希望出于知识产权原因而提供源代码的人来说非常重要。</li></ul><p>有两种类型的库:</p><ul><li><strong>静态库</strong></li><li><strong>动态库</strong></li></ul><h1 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h1><p><strong>静态库(也称为归档库(archive))</strong>由一些<strong>例程(routines)</strong>组成，这些例程被编译并直接链接到程序中。当您编译一个使用静态库的程序时，<u>程序所使用的静态库的所有功能都将成为可执行文件的一部分。</u></p><blockquote><p>在Windows中，静态库通常有一个<strong><code>.lib</code>扩展名</strong>；</p><p>而在linux上，静态库通常有一个<strong><code>.a</code>(存档)扩展名</strong>。</p></blockquote><p>静态库的一个<strong>优点</strong>是，您只需要分发可执行文件就可以让用户运行您的程序。</p><p>因为静态库成为程序的一部分，这就确保了程序总是使用正确版本的库；此外，因为静态库成为程序的一部分，所以可以像使用为自己的程序编写的功能一样使用它们。</p><p><strong>不利</strong>的一面是，由于库的副本成为使用它的每个可执行文件的一部分，这会导致大量的空间浪费。静态库也不能轻松升级——要更新库，需要替换整个可执行文件。</p><h1 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h1><p><strong>动态库(也称为共享库)</strong>由在<strong><u>运行时</u></strong>加载到应用程序中的例程组成。当您编译使用动态库的程序时，该库不会成为可执行文件的一部分——它仍然是一个单独的单元。</p><blockquote><p>在Windows上，动态库通常有一个<strong><code>.dll</code>(动态链接库)扩展名</strong>；</p><p>而在Linux上，动态库通常有一个<strong><code>.so</code>(共享对象)扩展名</strong>。</p></blockquote><p>动态库的一个<strong>优点</strong>是许多程序可以共享一个副本，这节省了空间。也许一个更大的优点是：动态库可以升级到一个新的版本，而不需要替换使用它的所有可执行文件。</p><p><strong>缺点</strong>：</p><p>因为动态库没有链接到程序中，所以使用动态库的程序<u>必须显式地加载动态库并与之交互</u>。这种机制可能会让人感到困惑，并使与动态库的交互变得非常棘手。</p><p><u>为了使动态库更易于使用，可以使用<strong>导入库( import library )</strong></u>。</p><p><strong>导入库</strong>是一个自动加载和使用动态库过程的库。</p><blockquote><p>在Windows上，这通常是通过一个与动态库(.dll)同名 的 <strong>小型静态库(.lib)</strong> 来完成的。静态库在<strong>编译时</strong>链接到程序中，然后动态库的功能 就可以 <u>像静态库一样</u> 有效地使用。</p><p>在Linux上，<strong>共享对象(.so)文件</strong>同时充当 动态库 和 导入库 。大多数链接器 可以在创建动态库时 为 动态库构建导入库。</p></blockquote><h1 id="安装和使用库"><a href="#安装和使用库" class="headerlink" title="安装和使用库"></a>安装和使用库</h1><p>现在您已经了解了不同种类的库，让我们讨论一下如何在程序中实际使用库。在c++中安装一个库通常需要4个步骤:</p><ul><li><ol><li><strong>获取库</strong>。</li></ol><blockquote><p>最好的选择是为您的操作系统下载一个预编译包(如果存在的话)，这样您就不必自己编译库了。</p><p>如果您的操作系统没有提供这样的包，那么您必须下载一个<u>只包含源代码的包</u>并自己编译它(这超出了本课的范围)。</p></blockquote><p>在Windows上，库通常以<code>.zip</code>文件的形式发布。</p><p>在Linux上，库通常以包的形式发布(例如<code>. rpm</code>)。</p><p>您的包管理器可能有一些比较流行的库(例如 SDL)。已经列出了，以便于安装，所以先检查一下。</p></li><li><ol start="2"><li><strong>安装库</strong>。</li></ol><p>在Linux上，这通常涉及调用包管理器并让它完成所有工作。</p><p>在Windows上，这通常涉及到将库解压缩到您选择的目录。</p><blockquote><p>我们建议将所有库保存在一个位置，以便于访问。例如，<strong>使用一个名为C:\Libs的目录，并将每个库放在它自己的子目录中。</strong></p></blockquote></li><li><ol start="3"><li><strong>确保编译器知道在哪里查找库的头文件</strong>。</li></ol><p>在Windows上，通常这是安装库文件到的目录的include子目录(例如。如果您将您的库安装到C:\libs\SDL-1.2.11，头文件可能在C:\libs\SDL-1.2.11\include中)。</p><p>在Linux上，头文件通常安装在/usr/include中，它应该已经是包含文件搜索路径的一部分。但是，如果文件安装在其他地方，则必须告诉编译器在哪里找到它们。</p></li><li><ol start="4"><li><strong>告诉链接器在哪里查找库文件</strong>。与步骤3一样，这通常涉及将目录添加到链接器查找库的位置列表中。</li></ol><p>在Windows上，这通常是安装库文件的目录的<code>/lib</code>子目录。</p><p>在Linux上，库通常安装在<code>/usr/lib</code>上，它应该已经是库搜索路径的一部分。</p></li></ul><p>一旦库被安装，IDE知道到哪里去找它，通常需要为每个想要使用库的项目执行以下3个步骤:</p><ul><li><ol start="5"><li><strong>如果使用静态库或导入库，请告诉链接器要链接哪个库文件</strong>。</li></ol></li><li><ol start="6"><li><p><strong>在程序中#include 库的头文件</strong>。</p><p>这将告诉编译器库所提供的所有功能，以便您的程序能够正确地编译。</p></li></ol></li><li><ol start="7"><li><strong>如果使用动态库，请确保程序知道在哪里可以找到它们</strong>。</li></ol><p>在Linux下，库通常安装在/usr/lib中，它位于LD_LIBRARY_PATH环境变量中的路径之后的默认搜索路径中。</p><p>在Windows上，默认的搜索路径包括：程序运行的目录、通过调用SetDllDirectory()设置的目录、Windows、System和System32目录以及path环境变量中的目录。</p><blockquote><p>使用.dll的最简单方法是将.dll复制到可执行文件的位置。由于您通常会将.dll与可执行文件一起发布，因此无论如何将它们放在一起都是有意义的。</p></blockquote></li></ul><p>步骤3-5涉及到配置IDE——</p><ul><li><p>幸运的是，几乎所有ide在执行这些操作时都以相同的方式工作。</p></li><li><p>不幸的是，因为每个IDE都有不同的接口，所以这个过程中最困难的部分就是找到执行这些步骤的正确位置。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.learncpp.com/cpp-tutorial/a1-static-and-dynamic-libraries/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.lea
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C&amp;C++/文件的随机IO</title>
    <link href="https://longlongqin.github.io/archives/60adc21f.html"/>
    <id>https://longlongqin.github.io/archives/60adc21f.html</id>
    <published>2020-05-28T02:23:18.479Z</published>
    <updated>2020-05-28T02:52:50.593Z</updated>
    
    <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/187-random-file-io/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/187-random-file-io/</a></p><hr><h1 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h1><p>类中的每个文件流类都包含一个<strong>文件指针</strong>，用于跟踪当前的读/写位置文件。</p><p>当从文件中读取或写入文件时，读取/写入发生在文件指针的当前位置。</p><blockquote><p>默认情况，<strong>当打开文件进行读写操作时，文件指针被设置为文件的开头</strong>。</p><p>但是，<strong>如果以追加模式打开文件</strong>，文件指针就会移动到文件的<strong>末尾</strong>，这样写入操作就不会覆盖文件的任何当前内容。</p></blockquote><h1 id="使用seekg-和seekp-随机访问文件"><a href="#使用seekg-和seekp-随机访问文件" class="headerlink" title="使用seekg()和seekp()随机访问文件"></a>使用seekg()和seekp()随机访问文件</h1><p>之前，我们访问的文件都是按顺序访问的。——也就是说，我们之前是按顺序读取或写入文件内容。</p><p>但是，也可以进行<strong>随机文件访问</strong>。——即，跳过文件中的各个点，来读其内容。</p><blockquote><p>当您的文件中充满了记录，并且您希望检索特定的记录时，这将非常有用。</p></blockquote><p>随机访问文件 是通过<code>seekg()</code>函数(用于input) 和 <code>seekp()</code>函数(用于output) 来操作文件指针。</p><blockquote><p>其中：“g”表示：get ；“p”表示：put。</p></blockquote><p>对于某些类型的流、seekg()(更改读位置) 和 seekp()(更改写位置) 独立操作。</p><p><strong>但是对于，文件流：读和写位置总是相同的，所以可以使用seekg和seekp互换。</strong></p><p><code>seekg()</code>和<code>seekp()</code>函数接受两个参数。</p><ul><li>第一个参数：是决定文件指针的偏移量。</li><li>第二个参数：是一个Ios标志，它指定偏移量参数应该从哪里偏移。</li></ul><table><thead><tr><th>Ios seek flag</th><th>Meaning</th></tr></thead><tbody><tr><td>beg</td><td>the offset is relative to the begining of the file(default)</td></tr><tr><td>cur</td><td>the offset is relative to the current location of the file pointer</td></tr><tr><td>end</td><td>the offset is relative to the end of the file</td></tr></tbody></table><p><strong>正偏移</strong>量意味着将文件指针移动到文件末尾，而<strong>负偏移</strong>意味着将文件指针移动指向文件开头。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inf.seekg(<span class="number">14</span>, ios::cur); <span class="comment">// move forward 14 bytes</span></span><br><span class="line">inf.seekg(<span class="number">-18</span>, ios::cur); <span class="comment">// move backwards 18 bytes</span></span><br><span class="line">inf.seekg(<span class="number">22</span>, ios::beg); <span class="comment">// move to 22nd byte in file</span></span><br><span class="line">inf.seekg(<span class="number">24</span>); <span class="comment">// move to 24th byte in file</span></span><br><span class="line">inf.seekg(<span class="number">-28</span>, ios::<span class="built_in">end</span>); <span class="comment">// move to the 28th byte before end of the file</span></span><br></pre></td></tr></table></figure><p>移动到文件的开头或结尾很容易:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inf.seekg(<span class="number">0</span>, ios::beg); <span class="comment">// move to beginning of file</span></span><br><span class="line">inf.seekg(<span class="number">0</span>, ios::<span class="built_in">end</span>); <span class="comment">// move to end of file</span></span><br></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>让我们使用<code>seekg()</code>和我们在上一课中创建的输入文件来做一个示例。这个输入文件看起来像这样:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">This is <span class="built_in">line</span> <span class="number">1</span></span><br><span class="line">This is <span class="built_in">line</span> <span class="number">2</span></span><br><span class="line">This is <span class="built_in">line</span> <span class="number">3</span></span><br><span class="line">This is <span class="built_in">line</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>下面是代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="function">ifstream <span class="title">inf</span><span class="params">(<span class="string">"Sample.dat"</span>)</span></span>;</span><br><span class="line">    <span class="comment">// If we couldn't open the input file stream for reading</span></span><br><span class="line">    <span class="keyword">if</span> (!inf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Print an error and exit</span></span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Uh oh, Sample.dat could not be opened for reading!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> strData;</span><br><span class="line">    inf.seekg(<span class="number">5</span>); <span class="comment">// move to 5th character</span></span><br><span class="line">    <span class="comment">// Get the rest of the line and print it</span></span><br><span class="line">    getline(inf, strData);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; strData &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    inf.seekg(<span class="number">8</span>, ios::cur); <span class="comment">// move 8 more bytes into file</span></span><br><span class="line">    <span class="comment">// Get rest of the line and print it</span></span><br><span class="line">    getline(inf, strData);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; strData &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    inf.seekg(<span class="number">-15</span>, ios::<span class="built_in">end</span>); <span class="comment">// move 15 bytes before end of file</span></span><br><span class="line">    <span class="comment">// Get rest of the line and print it</span></span><br><span class="line">    getline(inf, strData);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; strData &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.learncpp.com/cpp-tutorial/187-random-file-io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.learncpp.com/cpp
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C&amp;C++/文件的基本IO</title>
    <link href="https://longlongqin.github.io/archives/2926b12b.html"/>
    <id>https://longlongqin.github.io/archives/2926b12b.html</id>
    <published>2020-05-28T00:48:44.911Z</published>
    <updated>2020-05-28T01:36:17.065Z</updated>
    
    <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/186-basic-file-io/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/186-basic-file-io/</a></p><hr><p>c++中的文件I/O的工作方式与普通I/O非常相似(只是增加了一些细微的复杂性)。</p><p>在c++中有3个基本的文件I/O类:（<strong>头文件<code>fstream</code>中</strong>）</p><ul><li><code>ifstream</code> (derived from istream),</li><li><code>ofstream</code> (derived from ostream),</li><li><code>fstream</code> (derived from iostream).</li></ul><p>这些类分别执行文件 <strong>输入</strong>、<strong>输出</strong>和 <strong>输入/输出</strong>。</p><p>与cout、cin、cerr和clog流不同，<strong>文件流必须由程序员显式地设置。</strong></p><p>然而，这非常简单:</p><ul><li>要打开文件进行读取 和/或 写入，只需实例化适当文件I/O类的一个对象，以文件的名称作为参数。然后使用插入(&lt;&lt;)或提取(&gt;&gt;)操作符来写入或读取文件中的数据。</li><li>一旦你完成，有几种方法来<strong>关闭</strong>一个文件:<ul><li>显式调用close()函数，</li><li>或者只需让文件I/O变量超出范围 (文件I/O类析构函数将为您关闭文件)。</li></ul></li></ul><h1 id="文件输出"><a href="#文件输出" class="headerlink" title="文件输出"></a>文件输出</h1><p>要在下面的示例中执行文件输出，我们将使用<strong>ofstream类</strong>。这是非常直接的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ofstream用于编写文件</span></span><br><span class="line"><span class="comment">//我们将创建一个名为Sample.dat的文件</span></span><br><span class="line">    <span class="built_in">std</span>::ofstream outf&#123; <span class="string">"Sample.dat"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 如果我们不能打开输出文件流进行写入</span></span><br><span class="line">    <span class="keyword">if</span> (!outf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 打印错误并退出</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Uh oh, Sample.dat could not be opened for writing!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 我们将在这个文件中写入两行</span></span><br><span class="line">    outf &lt;&lt; <span class="string">"This is line 1"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    outf &lt;&lt; <span class="string">"This is line 2"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当outf超出范围时，ofstream析构函数将关闭文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果查看项目目录，应该会看到一个名为Sample.dat的文件。如果您使用文本编辑器打开它，您将看到它确实包含我们写入文件的两行。</p><blockquote><p>注意，也可以使用put()函数将<strong>单个</strong>字符写入文件。</p></blockquote><h1 id="文件输入"><a href="#文件输入" class="headerlink" title="文件输入"></a>文件输入</h1><p>现在，我们将获取我们在上一个示例中编写的文件，并将其从磁盘读入。</p><p>注意，如果我们到达了文件的末尾(EOF)， ifstream将返回0。我们将使用这个事实来决定需要读多少。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ifstream用于读取文件</span></span><br><span class="line"><span class="comment">// 我们将从一个名为Sample.dat的文件中进行读取</span></span><br><span class="line">    <span class="built_in">std</span>::ifstream inf&#123; <span class="string">"Sample.dat"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// If we couldn't open the output file stream for reading</span></span><br><span class="line">    <span class="keyword">if</span> (!inf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Print an error and exit</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Uh oh, Sample.dat could not be opened for reading!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 还有很多东西要读</span></span><br><span class="line">    <span class="keyword">while</span> (inf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将文件中的内容读入一个字符串并打印出来</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> strInput;</span><br><span class="line">        inf &gt;&gt; strInput;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; strInput &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When inf goes out of scope, the ifstream</span></span><br><span class="line">    <span class="comment">// destructor will close the file</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">This</span><br><span class="line">is</span><br><span class="line"><span class="built_in">line</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">This</span><br><span class="line">is</span><br><span class="line"><span class="built_in">line</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>嗯，那不是我们想要的。请记住，<strong>提取操作符会在空格处中断</strong>。为了整行读取，<strong>我们必须使用getline()函数。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ifstream is used for reading files</span></span><br><span class="line">    <span class="comment">// We'll read from a file called Sample.dat</span></span><br><span class="line">    <span class="built_in">std</span>::ifstream inf&#123; <span class="string">"Sample.dat"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// If we couldn't open the input file stream for reading</span></span><br><span class="line">    <span class="keyword">if</span> (!inf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Print an error and exit</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Uh oh, Sample.dat could not be opened for reading!\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// While there's still stuff left to read</span></span><br><span class="line">    <span class="keyword">while</span> (inf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// read stuff from the file into a string and print it</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> strInput;</span><br><span class="line">        <span class="built_in">std</span>::getline(inf, strInput); <span class="comment">//⭐⭐⭐</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; strInput &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When inf goes out of scope, the ifstream</span></span><br><span class="line">    <span class="comment">// destructor will close the file</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">This is <span class="built_in">line</span> <span class="number">1</span></span><br><span class="line">This is <span class="built_in">line</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h1 id="缓冲输出"><a href="#缓冲输出" class="headerlink" title="缓冲输出"></a>缓冲输出</h1><p><strong>c++的输出可以被缓冲。</strong></p><blockquote><p>这意味着输出到文件流的任何内容都可能<strong>不会立即写入磁盘</strong>。相反，几个输出操作可以成批处理并一起处理。</p></blockquote><p>这主要是出于性能原因。</p><h2 id="刷新缓冲区"><a href="#刷新缓冲区" class="headerlink" title="刷新缓冲区"></a>刷新缓冲区</h2><p>当将缓冲区写入磁盘时，这称为<strong>刷新缓冲区</strong>。</p><h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p><u>使缓冲区被刷新的一种方法是<strong>关闭文件</strong></u>——缓冲区的内容将被刷新到磁盘，然后文件将被关闭。</p><p>缓冲通常不是问题，但在某些情况下，它会给粗心大意的人带来麻烦。</p><ul><li><p>这种情况下的罪魁祸首是<strong>当缓冲区中有数据时，程序立即 终止</strong>(通过崩溃或调用exit())。<u>在这些情况下，文件流类的析构函数不会被执行，这意味着文件永远不会被关闭，这意味着缓冲区永远不会被刷新。</u></p><p><strong>在这种情况下，缓冲区中的数据不写入磁盘，而是永远丢失</strong>。<u>这就是为什么在调用exit()之前显式地关闭所有打开的文件总是一个好主意。</u></p></li></ul><h3 id="手动刷新"><a href="#手动刷新" class="headerlink" title="手动刷新"></a>手动刷新</h3><ul><li><p><strong>可以使用<code>ostream::flush()</code>函数手动刷新缓冲区</strong>，</p></li><li><p><strong>或者将<code>std::flush</code>发送到输出流</strong>。</p></li></ul><p>这两种方法都有助于确保缓冲区的内容被立即写入磁盘，以防程序崩溃。</p><p><strong>有趣的是<code>std::endl</code>; 也刷新输出流。</strong></p><ul><li>因此，过度使用std::endl(导致不必要的缓冲区刷新) 会在执行开销很大的缓冲I/O(例如写入文件)时对性能造成影响。</li></ul><p>出于这个原因，关心性能的<strong>程序员通常会使用’ \n ‘而不是std::endl来将换行符插入到输出流中</strong>，以避免不必要的缓冲区刷新。</p><h1 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h1><p>如果我们试图<strong>写入</strong>一个已经存在的文件，会发生什么? 再次运行输出示例 表明，每次运行程序时，原始文件都被完全覆盖。</p><p><strong>如果我们想要在文件的末尾追加更多的数据</strong>，该怎么办?</p><ul><li><p>结果是，<strong>文件流构造函数接受一个可选的第二个参数，该参数允许您指定有关文件应该如何打开的信息。</strong></p></li><li><p>这个参数称为<strong>mode</strong>，它接受的有效标志（<strong>位于Ios类中</strong>）。</p></li></ul><table><thead><tr><th align="left">Ios file mode</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">app</td><td align="left">Opens the file in append mode</td></tr><tr><td align="left">ate</td><td align="left">Seeks to the end of the file before reading/writing</td></tr><tr><td align="left">binary</td><td align="left">Opens the file in binary mode (instead of text mode)</td></tr><tr><td align="left">in</td><td align="left">Opens the file in read mode (default for ifstream)</td></tr><tr><td align="left">out</td><td align="left">Opens the file in write mode (default for ofstream)</td></tr><tr><td align="left">trunc</td><td align="left">Erases the file if it already exists</td></tr></tbody></table><p><strong>可以通过位操作(使用<code>|</code>操作符)指定多个标志。</strong></p><p>在文件模式下，</p><ul><li>Ifstream默认为<code>std::ios::in</code>；</li><li>Ofstream默认为<code>std::ios::out</code>文件模式。</li><li>fstream 默认为<code>std::ios::in | std::ios::out</code>文件模式，这意味着你可以在默认情况下读和写。</li></ul><p>让我们编写一个程序，在前面创建的Sample.dat文件中追加两行代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 我们会传递ios:app标志告诉ofstream去追加</span></span><br><span class="line"><span class="comment">// 而不是重写文件。我们不需要通过std::ios::out</span></span><br><span class="line"><span class="comment">// 因为ofstream默认std::ios::out</span></span><br><span class="line">    <span class="built_in">std</span>::ofstream outf&#123; <span class="string">"Sample.dat"</span>, <span class="built_in">std</span>::ios::app &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// If we couldn't open the output file stream for writing</span></span><br><span class="line">    <span class="keyword">if</span> (!outf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Print an error and exit</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Uh oh, Sample.dat could not be opened for writing!\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    outf &lt;&lt; <span class="string">"This is line 3"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    outf &lt;&lt; <span class="string">"This is line 4"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When outf goes out of scope, the ofstream</span></span><br><span class="line">    <span class="comment">// destructor will close the file</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">This is line 1</span><br><span class="line">This is line 2</span><br><span class="line">This is line 3</span><br><span class="line">This is line 4</span><br></pre></td></tr></table></figure><h1 id="使用open-显式打开文件"><a href="#使用open-显式打开文件" class="headerlink" title="使用open()显式打开文件"></a>使用open()显式打开文件</h1><p>就像可以使用<strong>close()显式地关闭文件流</strong>一样，也可以使用<strong>open()显式地打开文件流</strong>。</p><ul><li>open()的工作原理与文件流构造函数类似——<strong>它接受一个文件名和一个可选的文件模式。</strong></li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::ofstream outf&#123; <span class="string">"Sample.dat"</span> &#125;;</span><br><span class="line">outf &lt;&lt; <span class="string">"This is line 1"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">outf &lt;&lt; <span class="string">"This is line 2"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">outf.<span class="built_in">close</span>(); <span class="comment">// 显式关闭文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 追加一行</span></span><br><span class="line">outf.<span class="built_in">open</span>(<span class="string">"Sample.dat"</span>, <span class="built_in">std</span>::ios::app);</span><br><span class="line">outf &lt;&lt; <span class="string">"This is line 3\n"</span>;</span><br><span class="line">outf.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><p>其他参考文章：</p><p><a href="https://www.runoob.com/cplusplus/cpp-files-streams.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/cpp-files-streams.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.learncpp.com/cpp-tutorial/186-basic-file-io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.learncpp.com/cpp-
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C&amp;C++/流状态和输入验证</title>
    <link href="https://longlongqin.github.io/archives/ba87b609.html"/>
    <id>https://longlongqin.github.io/archives/ba87b609.html</id>
    <published>2020-05-27T09:55:34.276Z</published>
    <updated>2020-05-27T14:09:14.278Z</updated>
    
    <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/185-stream-states-and-input-validation/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/185-stream-states-and-input-validation/</a></p><hr><h1 id="流状态"><a href="#流状态" class="headerlink" title="流状态"></a>流状态</h1><p><strong><code>ios_base</code></strong>类包含几个状态标志，用来指示使用流时可能发生的各种情况:</p><table><thead><tr><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">goodbit</td><td align="left">Everything is okay</td></tr><tr><td align="left">badbit</td><td align="left">Some kind of fatal error occurred (e.g. the program tried to read past the end of a file)</td></tr><tr><td align="left">eofbit</td><td align="left">The stream has reached the end of a file</td></tr><tr><td align="left">failbit</td><td align="left">A non-fatal error occurred (eg. the user entered letters when the program was expecting an integer)</td></tr></tbody></table><p>虽然这些标志存在于<code>ios_base</code>中，因为<code>ios</code>是从<code>ios_base</code>派生而来的，而且<code>ios</code>比<code>ios_base</code>需要更少的输入，但它们通常是通过<code>ios</code>访问的(例如<code>std::ios::failbit</code>)。</p><p><strong><code>ios</code></strong>还提供了一些成员功能，以便方便地访问这些国家:</p><table><thead><tr><th align="left">Member function</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">good()</td><td align="left">Returns true if the goodbit is set (the stream is ok)</td></tr><tr><td align="left">bad()</td><td align="left">Returns true if the badbit is set (a fatal error occurred)</td></tr><tr><td align="left">eof()</td><td align="left">Returns true if the eofbit is set (the stream is at the end of a file)</td></tr><tr><td align="left">fail()</td><td align="left">Returns true if the failbit is set (a non-fatal error occurred)</td></tr><tr><td align="left">clear()</td><td align="left">Clears all flags and restores the stream to the goodbit state</td></tr><tr><td align="left">clear(state)</td><td align="left">Clears all flags and sets the state flag passed in</td></tr><tr><td align="left">rdstate()</td><td align="left">Returns the currently set flags</td></tr><tr><td align="left">setstate(state)</td><td align="left">Sets the state flag passed in</td></tr></tbody></table><p>最常处理的位是故障位 (failbit)，它是在用户输入无效输入时设置的。例如，考虑以下程序:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter your age: "</span>;</span><br><span class="line"><span class="keyword">int</span> nAge;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; nAge;</span><br></pre></td></tr></table></figure><p>注意，这个程序期望用户输入一个整数。但是，如果用户输入非数字数据，如“Alex”，cin将无法提取任何数据进行计数，并设置成故障位。</p><p>如果出现错误，并且将流设置为<code>goodbit</code>以外的任何内容。则将忽略该流上的进一步流操作。这个条件可以通过调用<code>clear()</code>函数来清除。</p><h1 id="输入验证"><a href="#输入验证" class="headerlink" title="输入验证"></a>输入验证</h1><p><strong>输入验证</strong>是检查用户输入是否满足某些条件的过程。输入验证通常可以分为两种类型: <strong>字符串</strong>和<strong>数字</strong>。</p><ul><li><p>对于<strong>字符串验证</strong>，我们接受所有用户输入作为一个字符串，然后根据其格式是否正确接受或拒绝该字符串。</p><p>在大多数语言中(特别是像Perl和PHP这样的脚本语言)，这是通过正则表达式完成的。但是，c++没有内置的正则表达式支持。</p><p>因此，这通常是通过检查字符串的每个字符来完成的，以确保它满足一些条件。</p></li><li><p>对于<strong>数字验证</strong>，我们通常关心的是确保用户输入的数字在一个特定的范围内(例如，在0到20之间)。但是，与字符串验证不同，用户可以输入完全不是数字的内容——我们也需要处理这些情况。</p></li></ul><p>为了帮助我们，c++提供了许多有用的函数，我们可以使用这些函数来确定特定字符是数字还是字母。<strong><code>cctype</code>头文件</strong>中有以下函数:</p><table><thead><tr><th align="left">Function</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">isalnum(int)</td><td align="left">Returns non-zero if the parameter is a letter or a digit</td></tr><tr><td align="left">isalpha(int)</td><td align="left">Returns non-zero if the parameter is a letter</td></tr><tr><td align="left">iscntrl(int)</td><td align="left">Returns non-zero if the parameter is a control character</td></tr><tr><td align="left">isdigit(int)</td><td align="left">Returns non-zero if the parameter is a digit</td></tr><tr><td align="left">isgraph(int)</td><td align="left">Returns non-zero if the parameter is printable character that is not whitespace</td></tr><tr><td align="left">isprint(int)</td><td align="left">Returns non-zero if the parameter is printable character (including whitespace)</td></tr><tr><td align="left">ispunct(int)</td><td align="left">Returns non-zero if the parameter is neither alphanumeric nor whitespace</td></tr><tr><td align="left">isspace(int)</td><td align="left">Returns non-zero if the parameter is whitespace</td></tr><tr><td align="left">isxdigit(int)</td><td align="left">Returns non-zero if the parameter is a hexadecimal digit (0-9, a-f, A-F)</td></tr></tbody></table><h2 id="字符串验证"><a href="#字符串验证" class="headerlink" title="字符串验证"></a>字符串验证</h2><p>让我们做一个简单的字符串验证，要求用户输入他们的名字。我们的验证标准是用户只输入字母字符或空格。如果遇到其他情况，输入将被拒绝。</p><blockquote><p><strong>当涉及到可变长度输入时</strong>，验证字符串的最佳方法(除了使用正则表达式库之外)是遍历字符串的每个字符，并确保它满足验证标准。这就是我们要做的。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Get user's name</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter your name: "</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> strName;</span><br><span class="line"><span class="built_in">std</span>::getline(<span class="built_in">cin</span>, strName); <span class="comment">// get the entire line, including spaces</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> bRejected&#123; <span class="literal">false</span> &#125;; <span class="comment">// has strName been rejected?</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Step through each character in the string until we either hit</span></span><br><span class="line"><span class="comment">// the end of the string, or we rejected a character</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> nIndex&#123; <span class="number">0</span> &#125;; nIndex &lt; strName.length() &amp;&amp; !bRejected; ++nIndex)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// If the current character is an alpha character, that's fine</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">isalpha</span>(strName[nIndex]))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// If it's a space, that's fine too</span></span><br><span class="line"><span class="keyword">if</span> (strName[nIndex] == <span class="string">' '</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Otherwise we're rejecting this input</span></span><br><span class="line">bRejected = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// If the input has been accepted, exit the while loop</span></span><br><span class="line"><span class="comment">// otherwise we're going to loop again</span></span><br><span class="line"><span class="keyword">if</span> (!bRejected)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数值验证"><a href="#数值验证" class="headerlink" title="数值验证"></a>数值验证</h2><p>在处理数字输入时，最明显的方法是使用<strong>提取操作符</strong>将输入提取为数字类型。通过检查<strong>故障位</strong>，我们可以判断用户是否输入了数字。</p><p>让我们试试这个方法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nAge;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter your age: "</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; nAge;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">cin</span>.fail()) <span class="comment">// no extraction took place</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">clear</span>(); <span class="comment">// reset the state bits back to goodbit so we can use ignore()</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="number">32767</span>, <span class="string">'\n'</span>); <span class="comment">// clear out the bad input from the stream</span></span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// try again</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (nAge &lt;= <span class="number">0</span>) <span class="comment">// make sure nAge is positive</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"You entered: "</span> &lt;&lt; nAge &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用户输入一个数字，<code>cin.fail()</code>将为false，我们将按break语句，退出循环。如果用户输入以字母开头的输入，<code>cin.fail()</code>将为真，我们将进入条件句。</p><p>更多详细的讲解，请看<a href="https://www.learncpp.com/cpp-tutorial/185-stream-states-and-input-validation/" target="_blank" rel="noopener">原文</a>。这里先不写，说不定以后会补上<code>~~~~</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.learncpp.com/cpp-tutorial/185-stream-states-and-input-validation/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C&amp;C++/字符串的流(stream)类</title>
    <link href="https://longlongqin.github.io/archives/4be6fd59.html"/>
    <id>https://longlongqin.github.io/archives/4be6fd59.html</id>
    <published>2020-05-27T03:18:36.500Z</published>
    <updated>2020-05-27T03:39:57.831Z</updated>
    
    <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/184-stream-classes-for-strings/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/184-stream-classes-for-strings/</a></p><hr><p>到目前为止，您看到的所有I/O示例都是写给cout或从cin读取的。</p><p>然而，还有另一组类叫做<strong>字符串的流类</strong>，它允许您使用熟悉的 插入(&lt;&lt;) 和 提取(&gt;&gt;)操作符来处理字符串。</p><p>与istream和ostream一样，字符串流提供了一个保存数据的缓冲区。但是，与cin和cout不同，这些流没有连接到I/O通道(例如键盘、监视器等)。<strong>字符串流的主要用途之一是缓冲输出以便以后显示，或者逐行处理输入。</strong></p><p>字符串有六个流类，：在<strong>头文件<code>sstream</code></strong>中。</p><ul><li><p>用于读取和写入正常字符宽度的字符串。</p><ul><li>istringstream(继承自istream)，</li><li>ostringstream(继承自ostream)，</li><li>stringstream(继承自iostream)</li></ul></li><li><p>用于读取和写入宽字符串。</p><ul><li>wistringstream</li><li>wostringstream</li><li>wstringstream</li></ul></li></ul><p>有两种方法可以将数据<strong>导入</strong>stringstream：</p><ol><li>使用插入(&lt;&lt;)操作符:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> os;</span><br><span class="line">os &lt;&lt; <span class="string">"en garde!"</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// insert "en garde!" into the stringstream</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用str(string)函数设置缓冲区的值:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> os;</span><br><span class="line">os.str(<span class="string">"en garde!"</span>); <span class="comment">// set the stringstream buffer to "en garde!"</span></span><br></pre></td></tr></table></figure><p>从stringstream中<strong>获取</strong>数据有两种类似的方法:</p><ol><li>使用str()函数检索缓冲区的结果:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> os;</span><br><span class="line">os &lt;&lt; <span class="string">"12345 67.89"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; os.str();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">12345</span> <span class="number">67.89</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用<strong>提取(&gt;&gt;)</strong>操作符:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> os;</span><br><span class="line">os &lt;&lt; <span class="string">"12345 67.89"</span>; <span class="comment">// insert a string of numbers into the stream</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> strValue;</span><br><span class="line">os &gt;&gt; strValue;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> strValue2;</span><br><span class="line">os &gt;&gt; strValue2;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// print the numbers separated by a dash</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; strValue &lt;&lt; <span class="string">" - "</span> &lt;&lt; strValue2 &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p>注意，<strong>&gt;&gt;操作符</strong>遍历字符串——每次连续使用&gt;&gt;都会返回流中的下一个可提取值。</p><p>另一方面，<strong>str()返回流的整个值</strong>，即使已经在流上使用了&gt;&gt;。</p><h1 id="字符串和数字之间的转换"><a href="#字符串和数字之间的转换" class="headerlink" title="字符串和数字之间的转换"></a>字符串和数字之间的转换</h1><p>因为插入和提取操作符知道如何处理所有基本数据类型，<strong>所以我们可以使用它们将字符串转换为数字，反之亦然。</strong></p><p>首先，让我们看看如何<strong>将数字转换成字符串</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> os;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> nValue&#123; <span class="number">12345</span> &#125;;</span><br><span class="line"><span class="keyword">double</span> dValue&#123; <span class="number">67.89</span> &#125;;</span><br><span class="line">os &lt;&lt; nValue &lt;&lt; <span class="string">' '</span> &lt;&lt; dValue;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> strValue1, strValue2;</span><br><span class="line">os &gt;&gt; strValue1 &gt;&gt; strValue2;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; strValue1 &lt;&lt; <span class="string">' '</span> &lt;&lt; strValue2 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">12345</span> <span class="number">67.89</span></span><br></pre></td></tr></table></figure><p>现在让我们把<strong>一个 数字 字符串 转换成一个数字</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> os;</span><br><span class="line">os &lt;&lt; <span class="string">"12345 67.89"</span>; <span class="comment">// insert a string of numbers into the stream</span></span><br><span class="line"><span class="keyword">int</span> nValue;</span><br><span class="line"><span class="keyword">double</span> dValue;</span><br><span class="line"> </span><br><span class="line">os &gt;&gt; nValue &gt;&gt; dValue;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; nValue &lt;&lt; <span class="string">' '</span> &lt;&lt; dValue &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">12345</span> <span class="number">67.89</span></span><br></pre></td></tr></table></figure><h1 id="清除stringstream以便重用"><a href="#清除stringstream以便重用" class="headerlink" title="清除stringstream以便重用"></a>清除stringstream以便重用</h1><p>有几种方法可以清空stringstream的缓冲区。</p><ol><li><p>使用str()与一个空白c风格的字符串 将它设置为空字符串:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> os;</span><br><span class="line">os &lt;&lt; <span class="string">"Hello "</span>;</span><br><span class="line"> </span><br><span class="line">os.str(<span class="string">""</span>); <span class="comment">// erase the buffer</span></span><br><span class="line"> </span><br><span class="line">os &lt;&lt; <span class="string">"World!"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; os.str();</span><br></pre></td></tr></table></figure></li><li><p>使用str()和一个空的std::string对象 将它设置为空字符串:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> os;</span><br><span class="line">os &lt;&lt; <span class="string">"Hello "</span>;</span><br><span class="line"> </span><br><span class="line">os.str(<span class="built_in">std</span>::<span class="built_in">string</span>&#123;&#125;); <span class="comment">// erase the buffer</span></span><br><span class="line"> </span><br><span class="line">os &lt;&lt; <span class="string">"World!"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; os.str();</span><br></pre></td></tr></table></figure><p>这两个程序产生以下相同的结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">World!</span><br></pre></td></tr></table></figure></li></ol><p><strong>当清除一个stringstream时，调用clear()函数通常也是一个好主意:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> os;</span><br><span class="line">os &lt;&lt; <span class="string">"Hello "</span>;</span><br><span class="line"> </span><br><span class="line">os.str(<span class="string">""</span>); <span class="comment">// erase the buffer</span></span><br><span class="line">os.<span class="built_in">clear</span>(); <span class="comment">// reset error flags</span></span><br><span class="line"> </span><br><span class="line">os &lt;&lt; <span class="string">"World!"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; os.str();</span><br></pre></td></tr></table></figure><p>clear()函数 重置可能已经设置的任何错误标志，并将流返回到ok状态。在下一课中，我们将更多地讨论流状态和错误标志。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.learncpp.com/cpp-tutorial/184-stream-classes-for-strings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.lear
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C&amp;C++/ostream与ios 输出</title>
    <link href="https://longlongqin.github.io/archives/927246b0.html"/>
    <id>https://longlongqin.github.io/archives/927246b0.html</id>
    <published>2020-05-27T02:02:36.147Z</published>
    <updated>2020-05-27T03:17:42.008Z</updated>
    
    <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/183-output-with-ostream-and-ios/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/183-output-with-ostream-and-ios/</a></p><hr><p>在本节中，我们将研究iostream输出类(ostream)的各个方面。</p><p>注意:</p><p><strong>本课中的所有I/O功能都位于std名称空间中</strong>。<strong>这意味着所有I/O对象和函数要么必须以“std::”为前缀，要么必须使用“using namespace std;”语句。</strong></p><h1 id="插入操作符-lt-lt"><a href="#插入操作符-lt-lt" class="headerlink" title="插入操作符(&lt;&lt;)"></a>插入操作符(&lt;&lt;)</h1><p>插入操作符(&lt;&lt;)<strong>用于将信息放入输出流。</strong></p><p>c++为所有内置数据类型预定义了插入操作，您已经了解了如何为您自己的类[重载插入操作符](<a href="http://www.learncpp.com/cpp-tutorial/93-overloading-the-io-operators/" target="_blank" rel="noopener">overload the insertion operator</a>)。</p><p>在关于<a href="https://www.learncpp.com/cpp-tutorial/183-output-with-ostream-and-ios/" target="_blank" rel="noopener">Input and output (I/O) streams</a>的课程中，您看到istream和ostream都来自于一个名为ios的类。ios(和ios_base)的任务之一是控制输出的格式化选项。</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>有两种方法来改变格式选项:</p><ul><li><p><strong>标志(flag)</strong>——可以将标志看作可以打开和关闭的布尔变量。</p></li><li><p><strong>控制器(manipulator)</strong>——控制器 是放置在流中的对象，它影响输入和输出的方式。</p></li></ul><h2 id="标志-flag"><a href="#标志-flag" class="headerlink" title="标志(flag)"></a>标志(flag)</h2><p>要<strong>打开标志</strong>，请使用<strong>setf()</strong>函数，并将适当的标志作为参数。</p><p>例如，在默认情况下，c++不会在正数前面打印+符号。但是，通过使用std::ios::showpos标志，我们可以改变这个行为:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::showpos); <span class="comment">// turn on the std::ios::showpos flag</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这将产生以下输出:*/</span></span><br><span class="line">+<span class="number">27</span></span><br></pre></td></tr></table></figure><p>可以使用<strong>OR(|)操作符</strong>同时打开多个ios标志:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::showpos | <span class="built_in">std</span>::ios::uppercase); <span class="comment">// turn on the std::ios::showpos and std::ios::uppercase flag</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p>要<strong>关闭标志</strong>，请使用<strong>unsetf()</strong>函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::showpos); <span class="comment">// turn on the std::ios::showpos flag</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.unsetf(<span class="built_in">std</span>::ios::showpos); <span class="comment">// turn off the std::ios::showpos flag</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">28</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这将产生以下输出:*/</span></span><br><span class="line">+<span class="number">27</span></span><br><span class="line"><span class="number">28</span></span><br></pre></td></tr></table></figure><p>在使用setf()时，还有一个需要注意的问题。</p><ul><li>许多标志属于组，称为<strong>格式组(format group)</strong>。格式组是一组执行类似 (有时互斥) 格式选项的标志。</li></ul><p>例如，名为“basefield”的格式组包含标志“oct”、“dec”和“hex”，它们控制整数值的基数。默认情况下，设置“dec”标志。因此，如果我们这样做:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::hex); <span class="comment">// try to turn on hex output</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*我们得到如下输出:*/</span></span><br><span class="line"><span class="number">27</span></span><br></pre></td></tr></table></figure><p>它没有工作! <strong>原因是setf()只打开标志</strong>——因此，当我们打开std::hex时，std::ios::dec仍然是打开的，而std::ios::dec显然是优先的。有两种方法可以解决这个问题。</p><ul><li><p>首先，我们<strong>可以关闭std::ios::dec</strong>，这样就只设置了std::ios::hex:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.unsetf(<span class="built_in">std</span>::ios::dec); <span class="comment">// turn off decimal output</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::hex); <span class="comment">// turn on hexadecimal output</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">1b</span></span><br></pre></td></tr></table></figure></li><li><p>第二种方法是使用另一种形式的setf()，它有两个参数:</p><ul><li>第一个参数是要设置的标志，</li><li>第二个是它所属的格式化组。</li></ul><p>当使用这种形式的setf()时，属于这个组的所有标志都是关闭的，只有传入的标志是打开的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Turn on std::ios::hex as the only std::ios::basefield flag</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::hex, <span class="built_in">std</span>::ios::basefield);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">1b</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="控制器-manipulator"><a href="#控制器-manipulator" class="headerlink" title="控制器(manipulator)"></a>控制器(manipulator)</h2><p>使用setf()和unsetf()可能会有些笨拙，因此c++提供了第二种方法来更改格式化选项: <strong>控制器(manipulator)</strong>。</p><p>控制器的优点是他们足够聪明，<strong>能够打开和关闭适当的标志</strong>。</p><p>这里有一个例子，使用一些控制器来改变基地:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print 27 in hex</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">28</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// we're still in hex</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::dec &lt;&lt; <span class="number">29</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// back to decimal</span></span><br></pre></td></tr></table></figure><p>这个程序产生的输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1b</span><br><span class="line">1c</span><br><span class="line">29</span><br></pre></td></tr></table></figure><p><strong>通常，使用 控制器 比 设置和取消标志 要容易得多。</strong>许多选项可以通过标志和操作器(例如更改基数)来使用，但是，其他选项只能通过标志或操作器来使用，因此了解如何使用这两个选项非常重要。</p><h2 id="有用的格式器"><a href="#有用的格式器" class="headerlink" title="有用的格式器"></a>有用的格式器</h2><p>下面是一些更有用的标志、控制器和 成员函数 的列表。</p><ul><li><p><strong>标记</strong>位于<strong>std::ios</strong>类中</p></li><li><p><strong>控制器</strong>位于<strong>std名称空间</strong>中，</p></li><li><p><strong>成员函数</strong>位于<strong>std::ostream类</strong>中。</p></li></ul><table><thead><tr><th align="left">Group</th><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"></td><td align="left">std::ios::boolalpha</td><td align="left">If set, booleans print “true” or “false”. If not set, booleans print 0 or 1</td></tr></tbody></table><table><thead><tr><th align="left">Manipulator</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">std::boolalpha</td><td align="left">Booleans print “true” or “false”</td></tr><tr><td align="left">std::noboolalpha</td><td align="left">Booleans print 0 or 1 (default)</td></tr></tbody></table><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="literal">false</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::boolalpha);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="literal">false</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::noboolalpha &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="literal">false</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="literal">false</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="literal">true</span> <span class="literal">false</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="literal">true</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><hr><table><thead><tr><th align="left">Group</th><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"></td><td align="left">std::ios::showpos</td><td align="left">If set, prefix positive numbers with a +</td></tr></tbody></table><table><thead><tr><th align="left">Manipulator</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">std::showpos</td><td align="left">Prefixes positive numbers with a +</td></tr><tr><td align="left">std::noshowpos</td><td align="left">Doesn’t prefix positive numbers with a +</td></tr></tbody></table><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">5</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::showpos);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">5</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::noshowpos &lt;&lt; <span class="number">5</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::showpos &lt;&lt; <span class="number">5</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">+<span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">+<span class="number">5</span></span><br></pre></td></tr></table></figure><hr><table><thead><tr><th align="left">Group</th><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"></td><td align="left">std::ios::uppercase</td><td align="left">If set, uses upper case letters</td></tr></tbody></table><table><thead><tr><th align="left">Manipulator</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">std::uppercase</td><td align="left">Uses upper case letters</td></tr><tr><td align="left">std::nouppercase</td><td align="left">Uses lower case letters</td></tr></tbody></table><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">12345678.9</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::uppercase);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">12345678.9</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::nouppercase &lt;&lt; <span class="number">12345678.9</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::uppercase &lt;&lt; <span class="number">12345678.9</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">1.23457e+007</span></span><br><span class="line"><span class="number">1.23457E+007</span></span><br><span class="line"><span class="number">1.23457e+007</span></span><br><span class="line"><span class="number">1.23457E+007</span></span><br></pre></td></tr></table></figure><hr><table><thead><tr><th align="left">Group</th><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">std::ios::basefield</td><td align="left">std::ios::dec</td><td align="left">Prints values in decimal (default)</td></tr><tr><td align="left">std::ios::basefield</td><td align="left">std::ios::hex</td><td align="left">Prints values in hexadecimal</td></tr><tr><td align="left">std::ios::basefield</td><td align="left">std::ios::oct</td><td align="left">Prints values in octal</td></tr><tr><td align="left">std::ios::basefield</td><td align="left">(none)</td><td align="left">Prints values according to leading characters of value</td></tr></tbody></table><table><thead><tr><th align="left">Manipulator</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">std::dec</td><td align="left">Prints values in decimal</td></tr><tr><td align="left">std::hex</td><td align="left">Prints values in hexadecimal</td></tr><tr><td align="left">std::oct</td><td align="left">Prints values in octal</td></tr></tbody></table><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::dec, <span class="built_in">std</span>::ios::basefield);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::oct, <span class="built_in">std</span>::ios::basefield);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::hex, <span class="built_in">std</span>::ios::basefield);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::dec &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::oct &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">33</span></span><br><span class="line"><span class="number">1b</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">33</span></span><br><span class="line"><span class="number">1b</span></span><br></pre></td></tr></table></figure><p>现在，您应该能够通过标记和控制器查看设置格式之间的关系。在以后的示例中，我们将使用控制器，除非它们不可用。</p><h1 id="精度、符号和小数点"><a href="#精度、符号和小数点" class="headerlink" title="精度、符号和小数点"></a>精度、符号和小数点</h1><p>通过使用操作器(或标志)，可以更改显示浮点数的精度和格式。有几种格式化选项以某种复杂的方式组合在一起，因此我们将仔细研究这个问题。</p><table><thead><tr><th align="left">Group</th><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">std::ios::floatfield</td><td align="left">std::ios::fixed</td><td align="left">Uses decimal notation for floating-point numbers</td></tr><tr><td align="left">std::ios::floatfield</td><td align="left">std::ios::scientific</td><td align="left">Uses scientific notation for floating-point numbers</td></tr><tr><td align="left">std::ios::floatfield</td><td align="left">(none)</td><td align="left">Uses fixed for numbers with few digits, scientific otherwise</td></tr><tr><td align="left">std::ios::floatfield</td><td align="left">std::ios::showpoint</td><td align="left">Always show a decimal point and trailing 0’s for floating-point values</td></tr></tbody></table><table><thead><tr><th align="left">Manipulator</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">std::fixed</td><td align="left">Use decimal notation for values</td></tr><tr><td align="left">std::scientific</td><td align="left">Use scientific notation for values</td></tr><tr><td align="left">std::showpoint</td><td align="left">Show a decimal point and trailing 0’s for floating-point values</td></tr><tr><td align="left">std::noshowpoint</td><td align="left">Don’t show a decimal point and trailing 0’s for floating-point values</td></tr><tr><td align="left">std::setprecision(int)</td><td align="left">Sets the precision of floating-point numbers (defined in iomanip.h)</td></tr></tbody></table><table><thead><tr><th align="left">Member function</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">std::precision()</td><td align="left">Returns the current precision of floating-point numbers</td></tr><tr><td align="left">std::precision(int)</td><td align="left">Sets the precision of floating-point numbers and returns old precision</td></tr></tbody></table><ul><li><strong>如果使用固定记数法或科学记数法</strong>，则精度决定了在分数中显示多少位小数。注意，如果精度小于有效数字的数目，则该数字将四舍五入。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::fixed &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">3</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">4</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">5</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">6</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">7</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::scientific &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">3</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">4</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">5</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">6</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">7</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">123.456</span><br><span class="line">123.4560</span><br><span class="line">123.45600</span><br><span class="line">123.456000</span><br><span class="line">123.4560000</span><br><span class="line"></span><br><span class="line">1.235e+002</span><br><span class="line">1.2346e+002</span><br><span class="line">1.23456e+002</span><br><span class="line">1.234560e+002</span><br><span class="line">1.2345600e+002</span><br></pre></td></tr></table></figure><ul><li><strong>如果既不使用固定数字，也不使用科学数字，则精度决定应显示多少位有效数字。</strong>同样，如果精度小于有效数字的数目，则该数字将四舍五入。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">3</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">4</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">5</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">6</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">7</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">123</span><br><span class="line">123.5</span><br><span class="line">123.46</span><br><span class="line">123.456</span><br><span class="line">123.456</span><br></pre></td></tr></table></figure><ul><li><strong>使用showpoint控制器器或标记，您可以让流 写入小数点和尾随零</strong>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::showpoint &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">3</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">4</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">5</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">6</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">7</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123.</span></span><br><span class="line"><span class="number">123.5</span></span><br><span class="line"><span class="number">123.46</span></span><br><span class="line"><span class="number">123.456</span></span><br><span class="line"><span class="number">123.4560</span></span><br></pre></td></tr></table></figure><p>下面是一些例子的总结表:</p><table><thead><tr><th align="left">Option</th><th align="left">Precision</th><th align="left">12345.0</th><th align="left">0.12345</th></tr></thead><tbody><tr><td align="left">Normal</td><td align="left">3</td><td align="left">1.23e+004</td><td align="left">0.123</td></tr><tr><td align="left">4</td><td align="left">1.235e+004</td><td align="left">0.1235</td><td align="left"></td></tr><tr><td align="left">5</td><td align="left">12345</td><td align="left">0.12345</td><td align="left"></td></tr><tr><td align="left">6</td><td align="left">12345</td><td align="left">0.12345</td><td align="left"></td></tr><tr><td align="left">Showpoint</td><td align="left">3</td><td align="left">1.23e+004</td><td align="left">0.123</td></tr><tr><td align="left">4</td><td align="left">1.235e+004</td><td align="left">0.1235</td><td align="left"></td></tr><tr><td align="left">5</td><td align="left">12345.</td><td align="left">0.12345</td><td align="left"></td></tr><tr><td align="left">6</td><td align="left">12345.0</td><td align="left">0.123450</td><td align="left"></td></tr><tr><td align="left">Fixed</td><td align="left">3</td><td align="left">12345.000</td><td align="left">0.123</td></tr><tr><td align="left">4</td><td align="left">12345.0000</td><td align="left">0.1235</td><td align="left"></td></tr><tr><td align="left">5</td><td align="left">12345.00000</td><td align="left">0.12345</td><td align="left"></td></tr><tr><td align="left">6</td><td align="left">12345.000000</td><td align="left">0.123450</td><td align="left"></td></tr><tr><td align="left">Scientific</td><td align="left">3</td><td align="left">1.235e+004</td><td align="left">1.235e-001</td></tr><tr><td align="left">4</td><td align="left">1.2345e+004</td><td align="left">1.2345e-001</td><td align="left"></td></tr><tr><td align="left">5</td><td align="left">1.23450e+004</td><td align="left">1.23450e-001</td><td align="left"></td></tr><tr><td align="left">6</td><td align="left">1.234500e+004</td><td align="left">1.234500e-001</td><td align="left"></td></tr></tbody></table><h1 id="宽度、填充字符和对齐"><a href="#宽度、填充字符和对齐" class="headerlink" title="宽度、填充字符和对齐"></a>宽度、填充字符和对齐</h1><p>通常，当您打印数字时，数字的打印与周围的空间无关。然而，向左或向右打印数字是可能的。</p><ul><li><strong>为了做到这一点，我们必须首先定义一个字段宽度，它定义了一个值将具有的输出空间的数量。</strong><ul><li>如果实际打印的数字小于字段宽度，它将被左对齐或右对齐(如指定)。</li><li>如果实际数字大于字段宽度，则<u>不会截断它</u>——它将溢出字段。</li></ul></li></ul><table><thead><tr><th align="left">Group</th><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">std::ios::adjustfield</td><td align="left">std::ios::internal</td><td align="left">Left-justifies the sign of the number, and right-justifies the value</td></tr><tr><td align="left">std::ios::adjustfield</td><td align="left">std::ios::left</td><td align="left">Left-justifies the sign and value</td></tr><tr><td align="left">std::ios::adjustfield</td><td align="left">std::ios::right</td><td align="left">Right-justifies the sign and value (default)</td></tr></tbody></table><table><thead><tr><th align="left">Manipulator</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">std::internal</td><td align="left">Left-justifies the sign of the number, and right-justifies the value</td></tr><tr><td align="left">std::left</td><td align="left">Left-justifies the sign and value</td></tr><tr><td align="left">std::right</td><td align="left">Right-justifies the sign and value</td></tr><tr><td align="left">std::setfill(char)</td><td align="left">Sets the parameter as the fill character (defined in iomanip.h)</td></tr><tr><td align="left">std::setw(int)</td><td align="left">Sets the field width for input and output to the parameter (defined in iomanip.h)</td></tr></tbody></table><table><thead><tr><th align="left">Member function</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">std::fill()</td><td align="left">Returns the current fill character</td></tr><tr><td align="left">std::fill(char)</td><td align="left">Sets the fill character and returns the old fill character</td></tr><tr><td align="left">std::width()</td><td align="left">Returns the current field width</td></tr><tr><td align="left">std::width(int)</td><td align="left">Sets the current field width and returns old field width</td></tr></tbody></table><p>为了使用任何这些格式化器，我们首先必须设置字段宽度。</p><blockquote><p>这可以通过<strong>width(int)</strong>成员函数或<strong>setw()</strong>机械手来完成。<strong>注意，右对齐是默认的。</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">-12345</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print default value with no field width</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">10</span>) &lt;&lt; <span class="number">-12345</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print default with field width</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">10</span>) &lt;&lt; left &lt;&lt; <span class="number">-12345</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print left justified</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">10</span>) &lt;&lt; right &lt;&lt; <span class="number">-12345</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print right justified</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">10</span>) &lt;&lt; internal &lt;&lt; <span class="number">-12345</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print internally justified</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">-12345</span></span><br><span class="line">    <span class="number">-12345</span></span><br><span class="line"><span class="number">-12345</span></span><br><span class="line">    <span class="number">-12345</span></span><br><span class="line">-    <span class="number">12345</span></span><br></pre></td></tr></table></figure><p><strong>需要注意的一点是，setw()和width()只影响下一个输出语句</strong>。它们不像其他一些标志/操纵器那样持久。</p><p>现在，让我们设置一个填充字符，并做同样的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.<span class="built_in">fill</span>(<span class="string">'*'</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">-12345</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print default value with no field width</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">10</span>) &lt;&lt; <span class="number">-12345</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print default with field width</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">10</span>) &lt;&lt; left &lt;&lt; <span class="number">-12345</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print left justified</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">10</span>) &lt;&lt; right &lt;&lt; <span class="number">-12345</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print right justified</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">10</span>) &lt;&lt; internal &lt;&lt; <span class="number">-12345</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print internally justified</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">-12345</span></span><br><span class="line">****<span class="number">-12345</span></span><br><span class="line"><span class="number">-12345</span>****</span><br><span class="line">****<span class="number">-12345</span></span><br><span class="line">-****<span class="number">12345</span></span><br></pre></td></tr></table></figure><p>请注意，字段中的所有空格都已用填充字符填充。</p><p>ostream类和iostream库包含其他可能有用的输出函数、标志和操作符，这取决于您需要做什么。与istream类一样，这些主题实际上更适合于关注标准库的教程或书籍(例如Nicolai M. Josuttis的优秀书籍《c++标准模板库》)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.learncpp.com/cpp-tutorial/183-output-with-ostream-and-ios/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.lea
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C&amp;C++/istream输入</title>
    <link href="https://longlongqin.github.io/archives/dac06bda.html"/>
    <id>https://longlongqin.github.io/archives/dac06bda.html</id>
    <published>2020-05-27T01:28:28.965Z</published>
    <updated>2020-05-27T01:59:51.258Z</updated>
    
    <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/182-input-with-istream/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/182-input-with-istream/</a></p><hr><p>iostream库相当复杂——因此我们无法在本教程中完整地介绍它。但是，我们将向您展示最常用的功能。在本节中，我们将研究input类(istream)的各个方面。</p><h1 id="提取操作符-gt-gt"><a href="#提取操作符-gt-gt" class="headerlink" title="提取操作符(&gt;&gt;)"></a>提取操作符(&gt;&gt;)</h1><p>正如在许多课程中看到的，我们可以使用<strong>提取操作符(&gt;&gt;)</strong>从输入流中读取信息。</p><p><strong>c++为所有内置数据类型提供了预定义的提取操作</strong>，您已经了解了如何<a href="https://www.google.com/search?q=overload+the+extraction+operator&oq=overload+the+extraction+operator+&aqs=chrome..69i57&sourceid=chrome&ie=UTF-8" target="_blank" rel="noopener">重载自己类的提取操作符</a>。</p><p>读取字符串时，提取操作符的一个常见问题是如何防止输入溢出缓冲区。给出以下例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; buf;</span><br></pre></td></tr></table></figure><p>如果用户输入18个字符会发生什么?缓冲区溢出，就会发生不好的事情。一般来说，对用户将输入多少字符做任何假设都不是一个好主意。</p><p>处理这个问题的一种方法是使用<strong>控制符</strong>。<strong>控制符</strong>是一个对象，当使用提取(&gt;&gt;)或插入(&lt;&lt;)操作符时，用于修改流。</p><blockquote><p>您已经广泛使用过的一个控制符是“endl”，它既打印换行字符，又刷新任何缓冲输出。</p></blockquote><p><strong>c++提供了一个名为setw的机械手(在iomanip.h头文件中)，</strong>它可以用来限制从流中读取的字符的数量。</p><blockquote><p>要使用setw()，只需提供作为参数读取的最大字符数，并将其插入到您的输入语句中，</p></blockquote><p>如下所示:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; <span class="built_in">std</span>::setw(<span class="number">10</span>) &gt;&gt; buf;</span><br></pre></td></tr></table></figure><p>这个程序现在将只从流中读取前9个字符(为终止符留出空间)。任何剩余的字符都将留在流中，直到下一次提取。</p><h1 id="提取和空白"><a href="#提取和空白" class="headerlink" title="提取和空白"></a>提取和空白</h1><p>到目前为止，我们没有提到的一件事是<strong>提取操作符处理“格式化”的数据</strong>——也就是说，它跳过空白(空格、制表符和换行符)。</p><p>看看下面的程序:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; ch)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ch;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当用户输入以下内容时:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello my name is Alex</span><br></pre></td></tr></table></figure><p>提取操作符跳过空格和换行符。因此，输出为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HellomynameisAlex</span><br></pre></td></tr></table></figure><p><strong>通常，您希望获得用户输入，但不放弃空格。为此，istream类提供了许多可用于此目的的函数。</strong></p><h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><ul><li><p><strong><code>get()</code></strong>——最有用的函数之一是get()函数，它只从输入流中获取一个字符。下面是上面使用get()的同一个程序:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>(ch))</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ch;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*现在当我们使用输入:*/</span></span><br><span class="line">Hello my name is Alex</span><br><span class="line"><span class="comment">/*它的结果是*/</span></span><br><span class="line">Hello my name is Alex</span><br></pre></td></tr></table></figure><p><strong>std::get()也有一个字符串版本，需要读取最多的字符:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> strBuf[<span class="number">11</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>(strBuf, <span class="number">11</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; strBuf &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*现在当我们使用输入:*/</span></span><br><span class="line">Hello my name is Alex</span><br><span class="line"><span class="comment">/*它的结果是*/</span></span><br><span class="line">Hello my n</span><br></pre></td></tr></table></figure><blockquote><p>注意，我们只读取了前10个字符(必须留下一个字符作为终止符)。其余字符留在输入流中。</p></blockquote></li></ul><p>关于<strong>get()</strong>需要注意的一件重要事情是，它<strong>不读取换行字符</strong>! 这可能会导致一些意想不到的结果:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> strBuf[<span class="number">11</span>];</span><br><span class="line">    <span class="comment">// Read up to 10 characters</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>(strBuf, <span class="number">11</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; strBuf &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Read up to 10 more characters</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>(strBuf, <span class="number">11</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; strBuf &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用户输入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello!</span><br></pre></td></tr></table></figure><p>程序将打印:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello!</span><br></pre></td></tr></table></figure><p>然后终止! 为什么不要求增加10个字符呢? 答案是，因为第一个get()读到换行，然后停止。第二个get()看到cin流中仍然有输入，并试图读取它。但第一个字符是换行符，所以它立即停止。</p><h2 id="getline"><a href="#getline" class="headerlink" title="getline()"></a>getline()</h2><p>因此，还有另一个名为getline()的函数，它的工作方式与get()完全相同，<strong>但它会读取换行符</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> strBuf[<span class="number">11</span>];</span><br><span class="line">    <span class="comment">// Read up to 10 characters</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.getline(strBuf, <span class="number">11</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; strBuf &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Read up to 10 more characters</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.getline(strBuf, <span class="number">11</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; strBuf &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码将按照您的期望执行，即使用户输入一个带有换行符的字符串。</p><p><strong>如果需要知道getline()的最后一次调用提取了多少字符，</strong> 使用<strong><code>gcount ()</code></strong> :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> strBuf[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.getline(strBuf, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; strBuf &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">cin</span>.gcount() &lt;&lt; <span class="string">" characters were read"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一些更有用的istream函数"><a href="#一些更有用的istream函数" class="headerlink" title="一些更有用的istream函数"></a>一些更有用的istream函数</h1><p>这里有一些更有用的输入函数，你可能想利用:</p><ul><li><p><strong><code>ignore()</code>：</strong>丢弃流中的第一个字符**。</p></li><li><p><strong><code>ignore(int nCount)</code></strong>：丢弃第一个nCount字符。</p></li><li><p><strong><code>peek()</code></strong>：允许您从流中读取字符，而无需从流中删除字符。</p></li><li><p><strong><code>unget()</code></strong>：将最后读取的字符返回到流中，以便下一个调用可以再次读取它。</p></li><li><p><strong><code>putback(char ch)</code></strong>：允许您将选择的字符放回流中，以便下一次调用读取。</p></li></ul><p>istream包含了许多其他的函数和上面提到的函数的变体，它们可能是有用的，这取决于你需要做什么。但是，这些主题更适合于关注标准库的教程或书籍（如 <a href="https://www.amazon.com/Standard-Library-Tutorial-Reference-2nd/dp/0321623215" target="_blank" rel="noopener">“The C++ Standard Library”</a> by Nicolai M. Josuttis）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.learncpp.com/cpp-tutorial/182-input-with-istream/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.learncpp.com
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C&amp;C++/输入输出(IO)流</title>
    <link href="https://longlongqin.github.io/archives/57266241.html"/>
    <id>https://longlongqin.github.io/archives/57266241.html</id>
    <published>2020-05-27T00:43:46.335Z</published>
    <updated>2020-05-27T01:17:58.901Z</updated>
    
    <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/181-input-and-output-io-streams/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/181-input-and-output-io-streams/</a></p><hr><p>输入和输出功能不是作为核心c++语言的一部分定义的，而是通过c++标准库提供的 (因此驻留在<strong>std名称空间</strong>中)。</p><p>在以前的课程中，您包括了iostream库头，并使用cin和cout对象来执行简单的I/O。在这节课中，我们将更详细地了解iostream库。</p><h1 id="iostream库"><a href="#iostream库" class="headerlink" title="iostream库"></a><code>iostream</code>库</h1><p>当您包含iostream报头时，您可以访问 负责提供I/O功能的整个类层次结构 (包括一个实际名为iostream的类)。非文件 I/O类的类层次结构如下:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="http://www.learncpp.com/images/CppTutorial/Section13/iostream.gif" alt="img"></p><p>关于这个层次结构，您可能注意到的第一件事是它使用了多重继承(我们告诉您尽可能避免的事情)。但是，为了避免任何典型的多重继承问题，已经设计并广泛测试了iostream库，所以您可以自由地使用它。</p><h2 id="流-Streams"><a href="#流-Streams" class="headerlink" title="流(Streams)"></a>流(Streams)</h2><p>你可能注意到的第二件事是，<strong>“流”</strong>这个词使用得非常频繁。在最基本的方面，c++中的I/O是用流实现的。<strong>抽象地说，流就是可以按顺序访问的字节序列。随着时间的推移，流可能产生或消耗无限数量的数据。</strong></p><p>通常我们处理两种不同类型的流：</p><ul><li><p><strong>输入流</strong>用于保存来自数据生成器 (如键盘、文件或网络)的输入。</p><blockquote><p>例如，当程序当前不期望任何输入时，用户可以按键盘上的一个键。而不是忽略用户的按键，数据被放入一个输入流，在那里它将等待，直到程序为它准备好。</p></blockquote></li><li><p>相反，<strong>输出流</strong>用于保存特定数据使用者 (如监视器、文件或打印机)的输出。</p><blockquote><p>当向输出设备写入数据时，设备可能还没有准备好接受该数据——例如，当程序将数据写入其输出流时，打印机可能仍然处于预热状态。这些数据将保存在输出流中，直到打印机开始使用它。</p></blockquote></li></ul><p>一些设备，如文件和网络，可以同时作为输入源和输出源。</p><p><strong>流的好处是程序员只需要学习如何与流交互，就可以将数据读写到许多不同的设备上</strong>。流如何与它们所连接的实际设备进行接口的详细信息由环境或操作系统决定。</p><h1 id="在c-中的输入-输出"><a href="#在c-中的输入-输出" class="headerlink" title="在c++中的输入/输出"></a>在c++中的输入/输出</h1><p>虽然<strong>ios类</strong>通常派生自ios_base类，但ios 通常是您将直接使用的最基本的类。ios类定义了一些输入流和输出流共有的东西。我们将在以后的课程中讨论这些内容。</p><p><strong>istream类</strong>是<strong>处理输入流</strong>时使用的主要类。<strong>对于输入流，提取操作符(&gt;&gt;) 用于从流中删除值。</strong> 这是有意义的:</p><ul><li>当用户在键盘上按下一个键时，键代码就被放置在输入流中。然后，程序从流中提取值，以便使用它。</li></ul><p><strong>ostream类</strong>是<strong>处理输出流</strong>时使用的主要类。<strong>对于输出流，使用插入操作符(&lt;&lt;)将值放入流中</strong>。这也是有意义的:</p><ul><li>您将您的值插入到流中，数据使用者(例如。监控)使用。</li></ul><p><strong>iostream类可以处理输入和输出，允许双向I/O。</strong></p><p>最后，有一堆类以“_withassign”结束。这些 流类 派生自istream、ostream和iostream (分别)，并定义了赋值运算符，允许您将一个流分配给另一个流。在大多数情况下，您不会直接处理这些类。</p><h1 id="c-中的标准流"><a href="#c-中的标准流" class="headerlink" title="c++中的标准流"></a>c++中的标准流</h1><p><strong>标准流是由环境提供给计算机程序的预先连接的流。</strong></p><p>c++附带了四个预定义的标准流对象，它们已经为您的使用进行了设置。</p><ul><li><code>cin</code>——与标准输入(通常是键盘)绑定的 istream_withassign类</li><li><code>cout</code>——与标准输出(通常是监视器)绑定的ostream_withassign类</li><li><code>cerr</code>—— 一个与标准<u>错误</u>(通常是监视器)绑定的ostream_withassign类，提供 未缓冲 的<strong>输出</strong></li><li><code>clog</code>—— 一个与标准错误(通常是监视器)绑定的ostream_withassign类，提供缓冲 <strong>输出</strong></li></ul><p><strong>非缓冲输出通常是立即处理的，而缓冲输出通常是作为一个块存储和写入的</strong>。因为clog不是经常使用，所以它常常从标准流列表中被省略。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.learncpp.com/cpp-tutorial/181-input-and-output-io-streams/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.lea
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C&amp;C++/std：：string的插入</title>
    <link href="https://longlongqin.github.io/archives/e56a544e.html"/>
    <id>https://longlongqin.github.io/archives/e56a544e.html</id>
    <published>2020-05-26T15:14:08.036Z</published>
    <updated>2020-05-26T15:18:25.497Z</updated>
    
    <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/17-7-stdstring-inserting/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/17-7-stdstring-inserting/</a></p><hr><p>可以通过<strong>insert()</strong>函数将字符插入到现有的字符串中。</p><p><strong><code>string&amp; string::insert (size_type index, const string&amp; str)</code></strong></p><p><strong><code>string&amp; string::insert (size_type index, const char* str)</code></strong></p><ul><li>这两个函数都将str的字符插入到索引处的字符串中</li><li>两个函数都返回*this，因此它们可以被“链接”。</li><li>如果索引无效，两个函数都会抛出out_of_range</li><li>如果结果超过最大字符数，这两个函数都会抛出一个length_error异常。</li><li>在c风格的字符串版本中，str不能为空。</li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sString</span><span class="params">(<span class="string">"aaaa"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">sString.insert(<span class="number">2</span>, <span class="built_in">string</span>(<span class="string">"bbbb"</span>));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">sString.insert(<span class="number">4</span>, <span class="string">"cccc"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aaaa</span><br><span class="line">aabbbbaa</span><br><span class="line">aabbccccbbaa</span><br></pre></td></tr></table></figure><p>下面，将只给出函数的声明，具体解释，请看原文对应内容：</p><p><strong><code>string&amp; string::insert (size_type index, const string&amp; str, size_type startindex, size_type num)</code></strong></p><p><strong><code>string&amp; string::insert(size_type index, const char* str, size_type len)</code></strong></p><p><strong><code>string&amp; string::insert(size_type index, size_type num, char c)</code></strong></p><p><strong><code>void insert(iterator it, size_type num, char c)</code></strong></p><p><strong><code>iterator string::insert(iterator it, char c)</code></strong></p><p><strong><code>void string::insert(iterator it, InputIterator begin, InputIterator end)</code></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.learncpp.com/cpp-tutorial/17-7-stdstring-inserting/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.learncpp.c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C&amp;C++/std：：string的末尾追加字符串</title>
    <link href="https://longlongqin.github.io/archives/54babab5.html"/>
    <id>https://longlongqin.github.io/archives/54babab5.html</id>
    <published>2020-05-26T14:50:42.447Z</published>
    <updated>2020-05-26T15:12:56.340Z</updated>
    
    <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/17-6-stdstring-appending/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/17-6-stdstring-appending/</a></p><hr><p>使用<strong>运算符+=</strong>、<strong>append()</strong>或<strong>push_back()</strong>函数可以很容易地将字符串追加到现有字符串的末尾。</p><p><strong><code>string&amp; string::operator+= (const string&amp; str)</code></strong></p><p><strong><code>string&amp; string::append (const string&amp; str)</code></strong></p><ul><li>这两个函数都将str的字符追加到字符串中。</li></ul><ul><li>两个函数都返回*this，因此它们可以被“链接”。</li><li>如果结果超过最大字符数，这两个函数都会抛出一个length_error异常。</li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sString</span><span class="params">(<span class="string">"one"</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">sString += <span class="built_in">string</span>(<span class="string">" two"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sThree</span><span class="params">(<span class="string">" three"</span>)</span></span>;</span><br><span class="line">sString.append(sThree);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one two three</span><br></pre></td></tr></table></figure><p>还有一种<strong>append()</strong>方法可以附加子字符串:</p><p><strong><code>string&amp; string::append (const string&amp; str, size_type index, size_type num)</code></strong></p><ul><li>这个函数将从str开始的num字符追加到字符串。</li><li>返回*this，这样它可以被“链接”。</li><li>如果索引超出范围，则抛出out_of_range</li><li>如果结果超过最大字符数，则抛出length_error异常。</li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sString</span><span class="params">(<span class="string">"one "</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> <span class="title">sTemp</span><span class="params">(<span class="string">"twothreefour"</span>)</span></span>;</span><br><span class="line">sString.append(sTemp, <span class="number">3</span>, <span class="number">5</span>); <span class="comment">// append substring of sTemp starting at index 3 of length 5</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one three</span><br></pre></td></tr></table></figure><p>运算符+=和append()也有<strong>处理c风格字符串</strong>的版本:</p><p><strong><code>string&amp; string::operator+= (const char* str)</code></strong></p><p><strong><code>string&amp; string::append (const char* str)</code></strong></p><ul><li><p>这两个函数都将str的字符追加到字符串中。</p></li><li><p>两个函数都返回*this，因此它们可以被“链接”。</p></li><li><p>如果结果超过最大字符数，这两个函数都会抛出一个length_error异常。</p></li><li><p>str不应该为空。</p></li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sString</span><span class="params">(<span class="string">"one"</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">sString += <span class="string">" two"</span>;</span><br><span class="line">sString.append(<span class="string">" three"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one two three</span><br></pre></td></tr></table></figure><p>下面还有很多，将只给出其声明，具体解释，请看原教程对应内容：</p><p><strong><code>string&amp; string::append (const char* str, size_type len)</code></strong></p><p><strong><code>string&amp; string::operator+= (char c)</code></strong></p><p><strong><code>void string::push_back (char c)</code></strong></p><p><strong><code>string&amp; string::append (size_type num, char c)</code></strong></p><p><strong><code>string&amp; string::append (InputIterator start, InputIterator end)</code></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.learncpp.com/cpp-tutorial/17-6-stdstring-appending/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.learncpp.c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C&amp;C++/std：：string的赋值 与 交换</title>
    <link href="https://longlongqin.github.io/archives/6b2ecf81.html"/>
    <id>https://longlongqin.github.io/archives/6b2ecf81.html</id>
    <published>2020-05-26T14:34:12.818Z</published>
    <updated>2020-05-26T14:49:37.863Z</updated>
    
    <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/17-5-stdstring-assignment-and-swapping/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/17-5-stdstring-assignment-and-swapping/</a></p><hr><h1 id="字符串赋值"><a href="#字符串赋值" class="headerlink" title="字符串赋值"></a>字符串赋值</h1><p><strong>给字符串赋值的最简单方法是使用重载的运算符=函数</strong>。<strong>还有一个assign()成员函数</strong>，它复制了某些功能。</p><p><strong><code>string&amp; string::operator= (const string&amp; str)</code></strong></p><p><strong><code>string&amp; string::assign (const string&amp; str)</code></strong></p><p><strong><code>string&amp; string::operator= (const char* str)</code></strong></p><p><strong><code>string&amp; string::assign (const char* str)</code></strong></p><p><strong><code>string&amp; string::operator= (char c)</code></strong></p><ul><li>这些函数将各种类型的值赋给字符串。</li><li>这些函数返回*this，因此它们可以被“链接”。</li><li>注意，<strong>不存在接受单个字符</strong>的<strong>assign()</strong>函数。</li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> sString;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Assign a string value</span></span><br><span class="line">sString = <span class="built_in">string</span>(<span class="string">"One"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> <span class="title">sTwo</span><span class="params">(<span class="string">"Two"</span>)</span></span>;</span><br><span class="line">sString.assign(sTwo);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Assign a C-style string</span></span><br><span class="line">sString = <span class="string">"Three"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">sString.assign(<span class="string">"Four"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Assign a char</span></span><br><span class="line">sString = <span class="string">'5'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Chain assignment</span></span><br><span class="line"><span class="built_in">string</span> sOther;</span><br><span class="line">sString = sOther = <span class="string">"Six"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="string">" "</span> &lt;&lt; sOther &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">One</span><br><span class="line">Two</span><br><span class="line">Three</span><br><span class="line">Four</span><br><span class="line"><span class="number">5</span></span><br><span class="line">Six Six</span><br></pre></td></tr></table></figure><h2 id="assign-成员函数也有其他一些版本"><a href="#assign-成员函数也有其他一些版本" class="headerlink" title="assign()成员函数也有其他一些版本"></a>assign()成员函数也有其他一些版本</h2><p><strong><code>string&amp; string::assign (const string&amp; str, size_type index, size_type len)</code></strong></p><ul><li><p>赋值一个str的子字符串，从index开始，长度为len</p></li><li><p>如果索引超出范围，则抛出out_of_range异常</p></li><li><p>返回*this，这样它可以被“链接”。</p></li></ul><p>如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> <span class="title">sSource</span><span class="params">(<span class="string">"abcdefg"</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span> sDest;</span><br><span class="line"> </span><br><span class="line">sDest.assign(sSource, <span class="number">2</span>, <span class="number">4</span>); <span class="comment">// assign a substring of source from index 2 of length 4</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sDest &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cdef</span><br></pre></td></tr></table></figure><p><strong><code>string&amp; string::assign (const char\* chars, size_type len)</code></strong></p><ul><li><p>从c风格的数组字符中分配len字符</p></li><li><p>如果结果超过最大字符数，则抛出length_error异常</p></li><li><p>返回*this，这样它可以被“链接”。</p></li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> sDest;</span><br><span class="line"> </span><br><span class="line">sDest.assign(<span class="string">"abcdefg"</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sDest &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcd</span><br></pre></td></tr></table></figure><p><strong>这个函数有潜在的危险，不建议使用它。</strong></p><p><strong><code>string&amp; string::assign (size_type len, char c)</code></strong></p><ul><li>使用len个字符c 来赋值</li><li>如果结果超过最大字符数，则抛出length_error异常</li><li>返回*this，这样它可以被“链接”。</li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> sDest;</span><br><span class="line"> </span><br><span class="line">sDest.assign(<span class="number">4</span>, <span class="string">'g'</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sDest &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gggg</span><br></pre></td></tr></table></figure><h1 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h1><p>如果有两个字符串，并且希望交换它们的值，那么可以使用两个名为<strong>swap()</strong>的函数。</p><p><strong><code>void string::swap (string &amp;str)</code></strong></p><p><strong><code>void swap (string &amp;str1, string &amp;str2)</code></strong></p><ul><li><p>两个函数交换两个字符串的值。<strong>成员函数</strong>交换<em>this和str，*</em>全局函数**交换str1和str2。</p></li><li><p>这些函数是有效的，应该用来代替赋值来执行字符串交换。</p></li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sStr1</span><span class="params">(<span class="string">"red"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sStr2</span><span class="params">(<span class="string">"blue"</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sStr1 &lt;&lt; <span class="string">" "</span> &lt;&lt; sStr2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">swap(sStr1, sStr2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sStr1 &lt;&lt; <span class="string">" "</span> &lt;&lt; sStr2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">sStr1.swap(sStr2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sStr1 &lt;&lt; <span class="string">" "</span> &lt;&lt; sStr2 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">red blue</span><br><span class="line">blue red</span><br><span class="line">red blue</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.learncpp.com/cpp-tutorial/17-5-stdstring-assignment-and-swapping/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C&amp;C++/std：：string的字符访问 及 转换为C风格数组</title>
    <link href="https://longlongqin.github.io/archives/a3edb06.html"/>
    <id>https://longlongqin.github.io/archives/a3edb06.html</id>
    <published>2020-05-26T14:04:03.302Z</published>
    <updated>2020-05-26T14:32:56.148Z</updated>
    
    <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/17-4-stdstring-character-access-and-conversion-to-c-style-arrays/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/17-4-stdstring-character-access-and-conversion-to-c-style-arrays/</a></p><hr><h1 id="访问字符"><a href="#访问字符" class="headerlink" title="访问字符"></a>访问字符</h1><h2 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符[]"></a>重载运算符[]</h2><p>有两种几乎相同的方法来访问字符串中的字符。更容易使用和更快的版本是<strong>重载运算符[]</strong>:</p><p><strong><code>char&amp; string::operator[] (size_type nIndex)</code></strong></p><p><strong><code>const char&amp; string::operator[] (size_type nIndex) const</code></strong></p><ul><li><p>这两个函数都返回带有索引nIndex的字符</p></li><li><p>传递无效索引将导致未定义的行为</p></li><li><p>使用length()作为索引仅对const字符串有效，并返回由字符串的默认构造函数生成的值。不建议您这样做。</p></li><li><p>因为char&amp;是返回类型，所以可以使用它编辑数组中的字符</p></li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sSource&#123; <span class="string">"abcdefg"</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sSource[<span class="number">5</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">sSource[<span class="number">5</span>] = <span class="string">'X'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sSource &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f</span><br><span class="line">abcdeXg</span><br></pre></td></tr></table></figure><h2 id="非操作符版本"><a href="#非操作符版本" class="headerlink" title="非操作符版本"></a>非操作符版本</h2><p>还有一个非操作符版本。<strong>这个版本比较慢</strong>，因为它使用异常来检查nIndex是否有效。</p><p><strong>如果你不确定nIndex是否有效，你应该使用这个版本来访问数组</strong>:</p><p><strong><code>char&amp; string::at (size_type nIndex)</code></strong></p><p><strong><code>const char&amp; string::at (size_type nIndex) const</code></strong></p><ul><li><p>这两个函数都返回带有索引nIndex的字符</p></li><li><p>传递无效索引将导致out_of_range异常</p></li><li><p>因为char&amp;是返回类型，所以可以使用它编辑数组中的字符</p></li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sSource&#123; <span class="string">"abcdefg"</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sSource.at(<span class="number">5</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">sSource.at(<span class="number">5</span>) = <span class="string">'X'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sSource &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><h1 id="转换为c风格的数组"><a href="#转换为c风格的数组" class="headerlink" title="转换为c风格的数组"></a>转换为c风格的数组</h1><p>许多函数(包括所有C函数)都希望将字符串格式化为C风格的字符串，而不是std::string。由于这个原因，std::string提供了3种不同的方法来将std::string转换成c风格的字符串。</p><ul><li><p><strong><code>const char* string::c_str () const</code></strong> ⭐【推荐】</p><ul><li>以const c风格的字符串返回字符串的内容</li><li>将追加一个空终止符</li><li>c风格的字符串属于std::string，不应该被删除</li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sSource&#123; <span class="string">"abcdefg"</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">strlen</span>(sSource.c_str());</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong><code>const char* string::data () const</code></strong></p><ul><li>以const c风格的字符串返回字符串的内容</li><li>将追加一个空终止符。这个函数执行的操作与c_str()相同</li><li>c风格的字符串属于std::string，不应该被删除</li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sSource&#123; <span class="string">"abcdefg"</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *szString&#123; <span class="string">"abcdefg"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个c样式字符串的前n个字符，如果它们相等，则返回0</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">memcmp</span>(sSource.data(), szString, sSource.length()) == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The strings are equal"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The strings are not equal"</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The strings are equal</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong><code>size_type string::copy(char *szBuf, size_type nLength) const</code></strong></p></li><li><p><strong><code>size_type string::copy(char *szBuf, size_type nLength, size_type nIndex) const</code></strong></p><ul><li>这两种风格都将字符串的最多nLength字符复制到szBuf，从字符nIndex开始</li><li>返回复制的字符数</li><li><strong>没</strong>有空值被追加。由调用者负责确保szBuf被初始化为NULL或使用返回的长度终止字符串</li><li>调用者负责不溢出szBuf</li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sSource&#123; <span class="string">"sphinx of black quartz, judge my vow"</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span> szBuf[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> nLength&#123; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(sSource.copy(szBuf, <span class="number">5</span>, <span class="number">10</span>)) &#125;;</span><br><span class="line">szBuf[nLength] = <span class="string">'\0'</span>;  <span class="comment">// 确保终止缓冲区中的字符串</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; szBuf &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">black</span><br></pre></td></tr></table></figure></li></ul><p><strong>除非您需要充分利用效率，否则c_str()是这三个函数中最简单、最安全的一个。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.learncpp.com/cpp-tutorial/17-4-stdstring-character-access-and-conversion-to-c-style-arrays/&quot; target=&quot;_blan
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C&amp;C++/std：：string长度和容量</title>
    <link href="https://longlongqin.github.io/archives/cc14dac2.html"/>
    <id>https://longlongqin.github.io/archives/cc14dac2.html</id>
    <published>2020-05-26T09:30:48.856Z</published>
    <updated>2020-05-26T14:01:51.473Z</updated>
    
    <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/17-3-stdstring-length-and-capacity/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/17-3-stdstring-length-and-capacity/</a></p><hr><p>一旦创建了字符串，了解它们的长度通常是很有用的。这就是长度和容量操作发挥作用的地方。</p><p>我们还将讨论将std::string转换回c风格字符串的各种方法，这样您就可以将它们用于需要char*类型的字符串的函数。</p><h1 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h1><p>字符串的长度非常简单——<strong>它是字符串中的字符数</strong>。确定字符串长度有两个相同的函数:</p><ul><li><p><strong><code>size_type string::length() const</code></strong></p></li><li><p><strong><code>size_type string::size() const</code></strong></p></li></ul><p>这两个函数都返回字符串中的当前字符数(<strong>不包括null终止符</strong>)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sSource</span><span class="params">(<span class="string">"012345678"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sSource.length() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="确定字符串是否有字符"><a href="#确定字符串是否有字符" class="headerlink" title="确定字符串是否有字符"></a>确定字符串是否有字符</h2><p>虽然可以使用length()来确定一个字符串是否有字符，<strong>但是使用empty()函数更有效</strong>:</p><p><strong><code>bool string::empty() const</code></strong></p><ul><li>如果字符串没有字符，则返回true，否则返回false。</li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sString1</span><span class="params">(<span class="string">"Not Empty"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (sString1.empty() ? <span class="string">"true"</span> : <span class="string">"false"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">string</span> sString2; <span class="comment">// empty</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (sString2.empty() ? <span class="string">"true"</span> : <span class="string">"false"</span>)  &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h1 id="字符串可容纳最大的容量"><a href="#字符串可容纳最大的容量" class="headerlink" title="字符串可容纳最大的容量"></a>字符串可容纳最大的容量</h1><p>还有一个与大小相关的函数，您可能永远不会用到，但是为了完整起见，我们将在这里包括它:</p><p><strong><code>size_type string::max_size() cons</code>t</strong></p><ul><li><p><strong>返回字符串允许的最大字符数</strong>。</p></li><li><p>这个值会随着操作系统和系统架构的不同而变化。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sString</span><span class="params">(<span class="string">"MyString"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString.max_size() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;教程中的结果</span><br><span class="line">4294967294</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在我自己电脑中的结果</span><br><span class="line">2147483647</span><br></pre></td></tr></table></figure><h1 id="字符串的容量-capacity"><a href="#字符串的容量-capacity" class="headerlink" title="字符串的容量( capacity)"></a>字符串的容量( capacity)</h1><p>字符串的容量<strong>反映了字符串为保存其内容而分配的内存大小。</strong></p><ul><li>此值以字符串字符为度量，不包括NULL终止符。（例如，一个容量为8的字符串可以容纳8个字符。）</li></ul><p><strong><code>size_type string::capacity() const</code></strong></p><ul><li>返回一个字符串在不重新分配的情况下可以容纳的字符数。</li></ul><p>如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sString</span><span class="params">(<span class="string">"01234567"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Length: "</span> &lt;&lt; sString.length() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Capacity: "</span> &lt;&lt; sString.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Length: 8</span><br><span class="line">Capacity: 15</span><br></pre></td></tr></table></figure><p>注意，容量大于字符串的长度!虽然我们的字符串长度为8，但实际上该字符串分配了足够15个字符的内存!为什么要这样做?</p><h2 id="字符串容量-capacity-大于等于-字符串长度"><a href="#字符串容量-capacity-大于等于-字符串长度" class="headerlink" title="字符串容量( capacity) 大于等于 字符串长度"></a>字符串容量( capacity) 大于等于 字符串长度</h2><p>注意，容量大于字符串的长度!虽然我们的字符串长度为8，但实际上该字符串分配了足够15个字符的内存!为什么要这样做?</p><ul><li>如果用户想在一个字符串中放入比该字符串所能容纳的更多的字符，则必须将该字符串重新分配到更大的容量中。例如，如果一个字符串的长度和容量都为8，那么向该字符串添加任何字符都将强制重新分配。通过使容量大于实际的字符串，<strong>这就为用户提供了一些缓冲空间，以便在需要进行重新分配之前扩展字符串。</strong></li></ul><p>事实证明，重新分配有以下几个不利原因：</p><ul><li><p>首先，<strong>重新分配字符串相对比较昂贵。</strong></p><ul><li><p>首先，必须分配新内存。</p></li><li><p>然后必须将字符串中的每个字符复制到新内存中。如果字符串很大，这可能需要很长时间。</p></li><li><p>最后，旧的内存空间必须释放。如果您正在进行许多重新分配，这个过程会显著降低程序的运行速度。</p></li></ul></li><li><p>其次，每当重新分配一个字符串时，该字符串的内容就会<strong>更改为一个新的内存地址</strong>。<strong>这意味着对字符串的所有引用、指针和迭代器都是无效的!</strong></p></li></ul><h2 id="设置字符串的容量的下限"><a href="#设置字符串的容量的下限" class="headerlink" title="设置字符串的容量的下限"></a>设置字符串的容量的下限</h2><p><strong><code>void string::reserve(size_type unSize)</code></strong></p><p><strong><code>void string::reserve()</code></strong></p><ul><li>第一个函数特点是<strong>将字符串的容量<u>至少</u>设置为unSize(可以更大</strong>)。<u>注意，这可能需要重新分配。</u></li><li>当调用第一个函数时，<strong>但大小小于当前容量，则函数将尝试收缩容量以匹配长度</strong>。这是一个非绑定请求。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sString</span><span class="params">(<span class="string">"01234567"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Length: "</span> &lt;&lt; sString.length() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Capacity: "</span> &lt;&lt; sString.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">sString.reserve(<span class="number">200</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Length: "</span> &lt;&lt; sString.length() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Capacity: "</span> &lt;&lt; sString.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">sString.reserve();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Length: "</span> &lt;&lt; sString.length() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Capacity: "</span> &lt;&lt; sString.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Length: <span class="number">8</span></span><br><span class="line">Capacity: <span class="number">15</span></span><br><span class="line">Length: <span class="number">8</span></span><br><span class="line">Capacity: <span class="number">207</span></span><br><span class="line">Length: <span class="number">8</span></span><br><span class="line">Capacity: <span class="number">207</span></span><br></pre></td></tr></table></figure><p>这个例子展示了两件有趣的事情。</p><ul><li>首先，虽然我们要求200的容量，但实际上我们得到了207的容量。容量总是保证至少与您的请求一样大，但也可能更大。</li><li>然后，我们请求更改容量以适应字符串<strong>。这个请求被忽略了，因为容量没有改变。</strong></li></ul><h2 id="向字符串添加一个字符"><a href="#向字符串添加一个字符" class="headerlink" title="向字符串添加一个字符"></a>向字符串添加一个字符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sString</span><span class="params">(<span class="string">"0123456789abcde"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Length: "</span> &lt;&lt; sString.length() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Capacity: "</span> &lt;&lt; sString.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Now add a new character</span></span><br><span class="line">sString += <span class="string">"f"</span>; ⭐⭐⭐</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Length: "</span> &lt;&lt; sString.length() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Capacity: "</span> &lt;&lt; sString.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Length: 15</span><br><span class="line">Capacity: 15</span><br><span class="line">Length: 16</span><br><span class="line">Capacity: 31</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.learncpp.com/cpp-tutorial/17-3-stdstring-length-and-capacity/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C&amp;C++/std：：string构造和销毁</title>
    <link href="https://longlongqin.github.io/archives/550c4d87.html"/>
    <id>https://longlongqin.github.io/archives/550c4d87.html</id>
    <published>2020-05-26T08:40:46.744Z</published>
    <updated>2020-05-26T09:27:51.826Z</updated>
    
    <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/17-2-stdstring-construction-and-destruction/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/17-2-stdstring-construction-and-destruction/</a></p><hr><p>在这节课中，我们将学习如何构造std::string的对象，以及如何从数字创建字符串，反之亦然。</p><h1 id="String-的构造"><a href="#String-的构造" class="headerlink" title="String 的构造"></a><strong>String</strong> 的构造</h1><p>string类有许多构造函数，可用于创建字符串。我们将在这里逐一介绍。</p><p>注意：<code>string::size_type</code>解析为<code>size_t</code>，它与<code>sizeof</code>操作符返回的无符号整数类型 相同。它的实际大小因环境而异。出于本教程的目的，将它想象成一个无符号整型。</p><h2 id="string-string"><a href="#string-string" class="headerlink" title="string::string()"></a>string::string()</h2><p>这是<strong>默认的构造函数</strong>。它创建一个<strong>空字符串</strong>。</p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sSource;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sSource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"> <span class="comment">//什么都没有，因为这是空字符串</span></span><br></pre></td></tr></table></figure><h2 id="string-string-const-string-amp-strString"><a href="#string-string-const-string-amp-strString" class="headerlink" title="string::string(const string&amp; strString)"></a>string::string(const string&amp; strString)</h2><p>这是<strong>复制构造函数</strong>。这个构造函数<strong>创建一个新的字符串作为strString的副本</strong>。</p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sSource&#123; <span class="string">"my string"</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sOutput&#123; sSource &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sOutput;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my string</span><br></pre></td></tr></table></figure><h2 id="string-string-const-string-amp-strString-size-type-unIndex-size-type-unLength"><a href="#string-string-const-string-amp-strString-size-type-unIndex-size-type-unLength" class="headerlink" title="string::string(const string&amp; strString, size_type unIndex, size_type unLength)"></a>string::string(const string&amp; strString, size_type unIndex, size_type unLength)</h2><p><strong><code>string::string(const string&amp; strString, size_type unIndex)</code></strong></p><p><strong><code>string::string(const string&amp; strString, size_type unIndex, size_type unLength)</code></strong></p><ul><li><p>此构造函数创建一个新字符串，该字符串从索引 unIndex开始，最多包含来自strString的 unLength长度字符。</p><blockquote><p>如果遇到NULL，即使没有达到unLength，字符串复制也将结束。</p></blockquote></li><li><p><u>如果不提供unLength</u>，则使用从unIndex开始的所有字符。</p></li><li><p>如果unIndex大于字符串的大小，则会抛出out_of_range异常。</p></li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sSource&#123; <span class="string">"my string"</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sOutput&#123; sSource, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sOutput&lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">sOutput2</span><span class="params">(sSource, <span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sOutput2 &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string</span><br><span class="line">stri</span><br></pre></td></tr></table></figure><h2 id="string-string-const-char-szCString"><a href="#string-string-const-char-szCString" class="headerlink" title="string::string(const char *szCString)"></a>string::string(const char *szCString)</h2><ul><li><p>这个构造函数从c风格的字符串szCString创建一个新字符串，直到但不包括NULL终止符。</p></li><li><p>如果结果大小超过最大字符串长度，将抛出length_error异常。</p></li><li><p><strong>警告:szCString不能为空。</strong></p></li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *szSource&#123; <span class="string">"my string"</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sOutput&#123; szSource &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sOutput &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my string</span><br></pre></td></tr></table></figure><h2 id="string-string-const-char-szCString-size-type-unLength"><a href="#string-string-const-char-szCString-size-type-unLength" class="headerlink" title="string::string(const char *szCString, size_type unLength)"></a>string::string(const char *szCString, size_type unLength)</h2><ul><li><p>这个构造函数从c样式的字符串szCString的 第一个字符开始 到 第 unLength个字符(包含它) 结束 创建一个新字符串。</p></li><li><p>如果结果大小超过最大字符串长度，将抛出length_error异常。</p></li><li><p>警告：<strong>仅对于此函数</strong>，在szCString中null不被视为字符串结束字符! 这意味着如果字符串的长度太大，是可以读取字符串的末尾的字符的。 注意不要溢出你的字符串缓冲区!</p></li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *szSource&#123; <span class="string">"my string"</span> &#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">sOutput</span><span class="params">(szSource, <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sOutput &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my s</span><br></pre></td></tr></table></figure><h2 id="string-string-size-type-nNum-char-chChar"><a href="#string-string-size-type-nNum-char-chChar" class="headerlink" title="string::string(size_type nNum, char chChar)"></a>string::string(size_type nNum, char chChar)</h2><ul><li><p>这个构造函数创建一个由nNum个 chChar字符 初始化的新字符串。</p></li><li><p>如果结果大小超过最大字符串长度，将抛出length_error异常。</p></li></ul><p>如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">sOutput</span><span class="params">(<span class="number">4</span>, <span class="string">'Q'</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sOutput &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QQQQ</span><br></pre></td></tr></table></figure><h2 id="template-string-string-InputIterator-itBeg-InputIterator-itEnd"><a href="#template-string-string-InputIterator-itBeg-InputIterator-itEnd" class="headerlink" title="template string::string(InputIterator itBeg, InputIterator itEnd)"></a>template string::string(InputIterator itBeg, InputIterator itEnd)</h2><ul><li><p>这个构造函数创建由一个范围为 [itBeg, itEnd]字符 初始化的新字符串。</p></li><li><p>如果结果大小超过最大字符串长度，将抛出length_error异常。</p></li></ul><p>这个没有示例代码。它很模糊，你可能永远不会用到它。</p><h1 id="string-的销毁"><a href="#string-的销毁" class="headerlink" title="string 的销毁"></a>string 的销毁</h1><p><strong><code>string::~string()</code></strong></p><p>字符串的销毁：</p><ul><li>这是破坏者。它销毁字符串并释放内存。</li></ul><p>这里也没有示例代码，因为析构函数不是显式调用的。</p><h1 id="由数字构造字符串"><a href="#由数字构造字符串" class="headerlink" title="由数字构造字符串"></a>由数字构造字符串</h1><p>在std::string类中一个值得注意的遗漏是<strong>缺乏从数字创建字符串的能力</strong>。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sFour&#123; <span class="number">4</span> &#125;;</span><br></pre></td></tr></table></figure><p>产生以下错误:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:vcprojectstest2test2test.cpp(10) : error C2664: &#39;std::basic_string&lt;_Elem,_Traits,_Ax&gt;::basic_string(std::basic_string&lt;_Elem,_Traits,_Ax&gt;::_Has_debug_it)&#39; : cannot convert parameter 1 from &#39;int&#39; to &#39;std::basic_string&lt;_Elem,_Traits,_Ax&gt;::_Has_debug_it&#39;</span><br></pre></td></tr></table></figure><p>还记得我说过字符串类会产生可怕的错误吗? 这里的相关信息是:</p><p><code>不能将参数1从&#39;int&#39;转换为&#39;std::basic_string</code></p><p>换句话说，它试图将int转换成字符串，但是失败了。</p><p><strong>将数字转换为字符串的最简单方法是使用std::ostringstream类。</strong></p><p>std::ostringstream（头文件<code>&lt;sstream&gt;</code>中）已经设置为接受来自各种来源的输入，包括字符、数字、字符串等…….。它同样能够<strong>输出字符串（可以通过提取操作符&gt;&gt;，也可以通过str()函数）</strong>。</p><blockquote><p>有关std::ostringstream的更多信息，请看<a href="https://www.learncpp.com/cpp-tutorial/184-stream-classes-for-strings/" target="_blank" rel="noopener">18.4 – Stream classes for strings</a>.</p></blockquote><p>这里有一个简单的解决方案来创建<code>std::string</code>从各种类型的输入:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">ToString</span><span class="params">(T tX)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">ostringstream</span> oStream;</span><br><span class="line">    oStream &lt;&lt; tX;</span><br><span class="line">    <span class="keyword">return</span> oStream.str();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> sFour&#123; ToString(<span class="number">4</span>) &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> sSixPointSeven&#123; ToString(<span class="number">6.7</span>) &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> sA&#123; ToString(<span class="string">'A'</span>) &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sFour &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sSixPointSeven &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sA &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">6.7</span><br><span class="line">A</span><br></pre></td></tr></table></figure><p>请注意，此解决方案省略了任何错误检查。将tX插入oStream可能会失败。一个适当的响应是在转换失败时抛出异常。</p><h1 id="将字符串转换为数字"><a href="#将字符串转换为数字" class="headerlink" title="将字符串转换为数字"></a>将字符串转换为数字</h1><p>类似于上面的解决方案:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">FromString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; sString, T &amp;tX)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">istringstream</span> <span class="title">iStream</span><span class="params">(sString)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> !(iStream &gt;&gt; tX).fail(); <span class="comment">// extract value into tX, return success or not</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> dX;</span><br><span class="line">    <span class="keyword">if</span> (FromString(<span class="string">"3.4"</span>, dX))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dX &lt;&lt; <span class="string">'\n'</span>; </span><br><span class="line">    <span class="keyword">if</span> (FromString(<span class="string">"ABC"</span>, dX))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dX &lt;&lt; <span class="string">'\n'</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.4</span><br></pre></td></tr></table></figure><p>注意，第二次转换失败并返回false。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.learncpp.com/cpp-tutorial/17-2-stdstring-construction-and-destruction/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;htt
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C&amp;C++/std：：string and std：：wstring</title>
    <link href="https://longlongqin.github.io/archives/67452a19.html"/>
    <id>https://longlongqin.github.io/archives/67452a19.html</id>
    <published>2020-05-26T07:45:21.184Z</published>
    <updated>2020-05-26T08:35:59.014Z</updated>
    
    <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/17-1-stdstring-and-stdwstring/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/17-1-stdstring-and-stdwstring/</a></p><hr><p>标准库包含许多有用的类——但最有用的可能是<strong>std::string</strong>。</p><p>std::string(和std::wstring)是一个字符串类，它提供了许多操作来分配、比较和修改字符串。在本章中，我们将深入研究这些字符串类。</p><blockquote><p>注意:</p><p><strong>C-style字符串将被称为“C-style string”</strong>，<strong>而std::string(和std::wstring)将被简单地称为“string”。</strong></p></blockquote><h1 id="字符串类-字符串类的动机-的动机"><a href="#字符串类-字符串类的动机-的动机" class="headerlink" title="字符串类(字符串类的动机)的动机"></a>字符串类(字符串类的动机)的动机</h1><h2 id="C风格字符串的缺点"><a href="#C风格字符串的缺点" class="headerlink" title="C风格字符串的缺点"></a>C风格字符串的缺点</h2><p>在 <a href="http://www.learncpp.com/cpp-tutorial/66-c-style-strings/" target="_blank" rel="noopener">C-style strings</a>中，我们介绍了<strong>c风格</strong>的字符串，它使用字符<strong>数组</strong>来存储字符串。</p><p>如果您尝试过使用c风格的字符串做任何事情，那么您会很快得出这样的结论:</p><ul><li>使用c风格的字符串很麻烦，很容易出错，而且很难调试。</li></ul><p>c风格的字符串有很多<strong>缺点</strong>，主要是围绕这样一个事实:</p><ul><li><p><strong>您必须自己完成所有的内存管理</strong>。</p><blockquote><p>例如，如果您想要分配字符串“hello!进入一个缓冲区，你必须先动态分配一个缓冲区的正确长度:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *strHello = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">7</span>];</span><br><span class="line"><span class="comment">//不要忘记说明null终止符的额外字符!</span></span><br></pre></td></tr></table></figure><p>然后你必须实际 复制值:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(strHello, <span class="string">"hello!"</span>);</span><br><span class="line"> &gt;<span class="comment">//希望你使你的缓冲区足够大，所以没有缓冲区溢出!</span></span><br></pre></td></tr></table></figure><p>当然，因为字符串是动态分配的，你必须记住，当你处理完它时，要正确地释放它:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span>[] strHello;</span><br><span class="line">  &gt;<span class="comment">//不要忘记使用数组删除代替普通的删除!</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>此外，C提供的用于处理数字的许多直观操作符(如赋值和比较)根本不适用于C风格的字符串。</strong>有时这些方法看似有效，但实际上产生了不正确的结果。例如：</p><ul><li>使用==比较两个c风格的字符串实际上会进行指针比较，而不是字符串比较。</li><li>使用operator=将一个c风格的字符串赋值给另一个c风格的字符串，乍一看似乎可行，但实际上是在做指针复制(浅复制)，这通常不是您想要的。</li></ul><p>这类事情会导致程序崩溃，很难找到和调试!</p></li></ul><ul><li>最后，处理c风格的字符串需要记住许多关于什么是安全/不安全的挑剔规则，记住一堆具有有趣名称的函数，如strcat()和strcmp()，而不是使用直观的操作符，并执行大量手工内存管理。</li></ul><p>幸运的是，c++和标准库提供了更好的处理字符串的方法: <strong>std::string和std::wstring类。</strong></p><p>通过使用c++概念，例如构造函数、析构函数和操作符重载，std::string允许您以一种直观和安全的方式创建和操作字符串! <u>不再需要内存管理，不再需要奇怪的函数名，灾难发生的可能性也大大降低。</u></p><h2 id="std-string概述"><a href="#std-string概述" class="headerlink" title="std::string概述"></a>std::string概述</h2><p>位于 <strong>头文件<code>&lt;string&gt;</code>中</strong></p><p>实际上在字符串头中有3个不同的字符串类。</p><ul><li><p>第<strong>一</strong>个模板基类名为basic_string&lt;&gt;:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">charT</span>, <span class="title">class</span> <span class="title">traits</span> = <span class="title">char_traits</span>&lt;charT&gt;, <span class="title">class</span> <span class="title">Allocator</span> = <span class="title">allocator</span>&lt;charT&gt; &gt;</span></span><br><span class="line"><span class="class">        <span class="title">class</span> <span class="title">basic_string</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您不会直接使用这个类，所以暂时不要担心什么trait或 Allocator。在几乎所有可能的情况下，默认值就足够了。</p></li></ul><ul><li><p>标准库提供了<strong>两</strong>种basic_string&lt;&gt;:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> basic_string&lt;<span class="keyword">char</span>&gt; <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">typedef</span> basic_string&lt;<span class="keyword">wchar_t</span>&gt; <span class="built_in">wstring</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是您将实际使用的两个类。</p><ul><li><p>std::string用于 标准ascii和utf-8字 符串。</p></li><li><p>std::wstring用于 宽字符/unicode (utf-16) 字符串。</p><blockquote><p>没有用于utf-32字符串的内置类(尽管如果需要的话，您应该能够从basic_string&lt;&gt;扩展自己的类)。</p></blockquote></li></ul></li></ul><p>尽管您将直接使用std::string和std::wstring，但所有字符串功能都是在basic_string&lt;&gt;类中实现的。通过模板化，String和wstring能够直接访问该功能。因此，本文提供的所有函数都可以用于string和wstring。</p><p>这里是string类中所有函数的列表。这些函数中的大多数具有多种风格，可以处理不同类型的输入，我们将在接下来的课程中更深入地介绍这些内容。</p><table><thead><tr><th align="left">Function</th><th align="left">Effect</th></tr></thead><tbody><tr><td align="left"><strong>Creation and destruction</strong></td><td align="left"></td></tr><tr><td align="left"><a href="http://www.learncpp.com/cpp-tutorial/17-2-ststring-construction-and-destruction/" target="_blank" rel="noopener">(constructor)</a> <a href="http://www.learncpp.com/cpp-tutorial/17-2-ststring-construction-and-destruction/" target="_blank" rel="noopener">(destructor)</a></td><td align="left">Create or copy a string Destroy a string</td></tr><tr><td align="left"><strong>Size and capacity</strong></td><td align="left"></td></tr><tr><td align="left"><a href="http://www.learncpp.com/cpp-tutorial/17-3-stdstring-length-and-capacity/" target="_blank" rel="noopener">capacity()</a> <a href="http://www.learncpp.com/cpp-tutorial/17-3-stdstring-length-and-capacity/" target="_blank" rel="noopener">empty()</a> <a href="http://www.learncpp.com/cpp-tutorial/17-3-stdstring-length-and-capacity/" target="_blank" rel="noopener">length(), size()</a> <a href="http://www.learncpp.com/cpp-tutorial/17-3-stdstring-length-and-capacity/" target="_blank" rel="noopener">max_size()</a> <a href="http://www.learncpp.com/cpp-tutorial/17-3-stdstring-length-and-capacity/" target="_blank" rel="noopener">reserve()</a></td><td align="left">Returns the number of characters that can be held without reallocation Returns a boolean indicating whether the string is empty Returns the number of characters in string Returns the maximum string size that can be allocated Expand or shrink the capacity of the string</td></tr><tr><td align="left"><strong>Element access</strong></td><td align="left"></td></tr><tr><td align="left"><a href="http://www.learncpp.com/cpp-tutorial/17-4-stdstring-character-access-and-conversion-to-c-style-arrays/" target="_blank" rel="noopener">[], at()</a></td><td align="left">Accesses the character at a particular index</td></tr><tr><td align="left"><strong>Modification</strong></td><td align="left"></td></tr><tr><td align="left"><a href="http://www.learncpp.com/cpp-programming/17-5-stdstring-assignment-and-swapping/" target="_blank" rel="noopener">=, assign()</a> <a href="http://www.learncpp.com/uncategorized/17-6-stdstring-appending/" target="_blank" rel="noopener">+=, append(), push_back()</a> <a href="http://www.learncpp.com/cpp-tutorial/17-7-stdstring-inserting/" target="_blank" rel="noopener">insert()</a> clear() erase() replace() resize() <a href="http://www.learncpp.com/cpp-programming/17-5-stdstring-assignment-and-swapping/" target="_blank" rel="noopener">swap()</a></td><td align="left">Assigns a new value to the string Concatenates characters to end of the string Inserts characters at an arbitrary index in string Delete all characters in the string Erase characters at an arbitrary index in string Replace characters at an arbitrary index with other characters Expand or shrink the string (truncates or adds characters at end of string) Swaps the value of two strings</td></tr><tr><td align="left"><strong>Input and Output</strong></td><td align="left"></td></tr><tr><td align="left">&gt;&gt;, getline() &lt;&lt; <a href="http://www.learncpp.com/cpp-tutorial/17-4-stdstring-character-access-and-conversion-to-c-style-arrays/" target="_blank" rel="noopener">c_str()</a> <a href="http://www.learncpp.com/cpp-tutorial/17-4-stdstring-character-access-and-conversion-to-c-style-arrays/" target="_blank" rel="noopener">copy()</a> <a href="http://www.learncpp.com/cpp-tutorial/17-4-stdstring-character-access-and-conversion-to-c-style-arrays/" target="_blank" rel="noopener">data()</a></td><td align="left">Reads values from the input stream into the string Writes string value to the output stream Returns the contents of the string as a NULL-terminated C-style string Copies contents (not NULL-terminated) to a character array Returns the contents of the string as a non-NULL-terminated character array</td></tr><tr><td align="left"><strong>String comparison</strong></td><td align="left"></td></tr><tr><td align="left">==, != &lt;, &lt;=, &gt; &gt;= compare()</td><td align="left">Compares whether two strings are equal/unequal (returns bool) Compares whether two strings are less than / greater than each other (returns bool) Compares whether two strings are equal/unequal (returns -1, 0, or 1)</td></tr><tr><td align="left"><strong>Substrings and concatenation</strong></td><td align="left"></td></tr><tr><td align="left">+ substr()</td><td align="left">Concatenates two strings Returns a substring</td></tr><tr><td align="left"><strong>Searching</strong></td><td align="left"></td></tr><tr><td align="left">find() find_first_of() find_first_not_of() find_last_of() find_last_not_of() rfind()</td><td align="left">Find index of first character/substring Find index of first character from a set of characters Find index of first character not from a set of characters Find index of last character from a set of characters Find index of last character not from a set of characters Find index of last character/substring</td></tr><tr><td align="left"><strong>Iterator and allocator support</strong></td><td align="left"></td></tr><tr><td align="left">begin(), end() get_allocator() rbegin(), rend()</td><td align="left">Forward-direction iterator support for beginning/end of string Returns the allocator Reverse-direction iterator support for beginning/end of string</td></tr></tbody></table><p>虽然标准的库字符串类提供了很多功能，但有几个明显的遗漏:</p><ul><li>正则表达式</li><li>用于从数字创建字符串的构造函数</li><li>大写/大写/小写函数</li><li>不区分大小写的比较</li><li>标记化/将字符串拆分为数组</li><li>获取字符串的左或右部分的简单函数</li><li>空白修剪</li><li>格式化一个字符串 sprintf 样式</li><li>由utf-8转换为utf-16或反之亦然</li></ul><p>对于大多数情况，您必须编写自己的函数，<strong>或者将字符串转换为C样式的字符串(使用c_str())，并使用提供此功能的C函数。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.learncpp.com/cpp-tutorial/17-1-stdstring-and-stdwstring/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.learn
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C&amp;C++/algorithm</title>
    <link href="https://longlongqin.github.io/archives/38f02bc7.html"/>
    <id>https://longlongqin.github.io/archives/38f02bc7.html</id>
    <published>2020-05-26T07:01:48.858Z</published>
    <updated>2020-05-26T07:18:20.422Z</updated>
    
    <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/16-4-stl-algorithms-overview/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/16-4-stl-algorithms-overview/</a></p><hr><p><strong>头文件：<code>algorithm</code></strong></p><p>除了容器类和迭代器之外，STL还提供了一些用于处理容器类元素的通用<strong>算法</strong>。它们允许您执行诸如搜索、排序、插入、重新排序、删除和复制容器类的元素等操作。</p><p>注意，<strong>算法是作为使用迭代器操作的函数来实现的</strong>。这意味着每个算法只需要实现一次，它通常会自动为所有提供一组迭代器的容器(包括您的自定义容器类)工作。</p><p>虽然这是非常强大的，可以导致编写复杂代码的能力非常快，它也有一些缺点：</p><ul><li><strong>某些算法和容器类型的组合可能不起作用，可能导致无限循环，或者可能起作用，但性能非常差。因此，使用这些在你的风险。</strong></li></ul><p>STL提供了相当多的算法，在这里，我们只讨论一些更常见、更容易使用的方法。其余的(和完整的细节)将保存在关于STL算法的一章中。</p><h1 id="min-element-与-max-element"><a href="#min-element-与-max-element" class="headerlink" title="min_element 与 max_element"></a>min_element 与 max_element</h1><p><code>std::min_element</code>和<code>std::max_element</code>算法查找容器类中的最小和最大元素。</p><p><code>std::iota</code>生成一系列连续的值。在头文件：<code>&lt;numeric&gt;</code>中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // ⭐std::min_element and std::max_element</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt; // std::iota</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">li</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 用从0开始的数字 填充li。</span></span><br><span class="line">    <span class="built_in">std</span>::iota(li.<span class="built_in">begin</span>(), li.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *<span class="built_in">std</span>::min_element(li.<span class="built_in">begin</span>(), li.<span class="built_in">end</span>()) &lt;&lt; <span class="string">' '</span></span><br><span class="line">              &lt;&lt; *<span class="built_in">std</span>::max_element(li.<span class="built_in">begin</span>(), li.<span class="built_in">end</span>()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果：*/</span></span><br><span class="line"><span class="number">0</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.learncpp.com/cpp-tutorial/16-4-stl-algorithms-overview/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.learnc
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C&amp;C++/STL迭代器</title>
    <link href="https://longlongqin.github.io/archives/34a9aaba.html"/>
    <id>https://longlongqin.github.io/archives/34a9aaba.html</id>
    <published>2020-05-26T02:47:38.727Z</published>
    <updated>2020-05-26T03:29:01.487Z</updated>
    
    <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/16-3-stl-iterators-overview/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/16-3-stl-iterators-overview/</a></p><hr><p><strong>Iterator(迭代器)</strong>是一个<strong>对象</strong>，<strong>它可以遍历(迭代)一个容器类，而用户不需要知道容器是如何实现的。</strong></p><blockquote><p>对于许多类(特别是列表和关联类)，迭代器是访问这些类元素的主要方式。</p></blockquote><ul><li><p>操作符<code>*</code>：\对迭代器的解引用将返回迭代器当前指向的元素。</p></li><li><p>操作符<code>++</code>：将迭代器移动到容器中的下一个元素。（大多数迭代器还提供运算符——移动到前面的元素。）</p></li><li><p>操作符<code>==</code>与<code>!=</code>：确定两个迭代器是否指向同一个元素的基本比较操作符。</p><blockquote><p>要比较两个迭代器所指向的值，首先取消对迭代器的引用，然后使用比较操作符。</p></blockquote></li><li><p>操作符<code>=</code>：将迭代器分配到一个<strong>新位置</strong>(通常是容器元素的开始或结束位置)。</p><blockquote><p>要分配迭代器所指向的元素的值，首先对迭代器解引用，然后使用赋值操作符(<code>=</code>)。</p></blockquote></li></ul><p>每个容器包含四个基本的成员函数，用于<strong>操作符<code>=</code></strong>:</p><ul><li><strong><code>begin()</code></strong>：返回一个迭代器，<strong>表示容器中元素的开头</strong>。</li><li><strong><code>end()</code></strong>：返回一个迭代器，<strong>该迭代器表示元素的末尾</strong>。</li><li><strong><code>cbegin()</code></strong>：返回一个const(只读)迭代器，表示容器中元素的开头。</li><li><strong><code>cend()</code></strong>：返回一个const(只读)迭代器，表示元素的末尾。</li></ul><p>最后，所有容器都提供(至少)两种迭代器:</p><ul><li><strong><code>container::iterator</code></strong>：提供了一个读/写迭代器</li><li><strong><code>container::const_iterator</code></strong>：提供了一个只读迭代器</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>遍历一个 <strong>vector</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vect;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count &lt; <span class="number">6</span>; ++count)</span><br><span class="line">        vect.push_back(count);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it; <span class="comment">// declare a read-only iterator</span></span><br><span class="line">    it = vect.cbegin(); <span class="comment">// assign it to the start of the vector</span></span><br><span class="line">    <span class="keyword">while</span> (it != vect.cend()) <span class="comment">// while it hasn't reach the end</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>; <span class="comment">// print the value of the element it points to</span></span><br><span class="line">        ++it; <span class="comment">// and iterate to the next element</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历<strong>list(列表)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; li;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count &lt; <span class="number">6</span>; ++count)</span><br><span class="line">        li.push_back(count);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it; <span class="comment">// declare an iterator</span></span><br><span class="line">    it = li.cbegin(); <span class="comment">// assign it to the start of the list</span></span><br><span class="line">    <span class="keyword">while</span> (it != li.cend()) <span class="comment">// while it hasn't reach the end</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>; <span class="comment">// print the value of the element it points to</span></span><br><span class="line">        ++it; <span class="comment">// and iterate to the next element</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，代码几乎与向量的情况相同，尽管向量和列表的内部实现几乎完全不同!</p><p>遍历一个<strong>set(集合)</strong></p><p>在下面的例子中，我们将从6个数字创建一个集合，并使用迭代器来打印集合中的值:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; myset;</span><br><span class="line">    myset.insert(<span class="number">7</span>);</span><br><span class="line">    myset.insert(<span class="number">2</span>);</span><br><span class="line">    myset.insert(<span class="number">-6</span>);</span><br><span class="line">    myset.insert(<span class="number">8</span>);</span><br><span class="line">    myset.insert(<span class="number">1</span>);</span><br><span class="line">    myset.insert(<span class="number">-4</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it; <span class="comment">// declare an iterator</span></span><br><span class="line">    it = myset.cbegin(); <span class="comment">// assign it to the start of the set</span></span><br><span class="line">    <span class="keyword">while</span> (it != myset.cend()) <span class="comment">// while it hasn't reach the end</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>; <span class="comment">// print the value of the element it points to</span></span><br><span class="line">        ++it; <span class="comment">// and iterate to the next element</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，尽管填充集合的方式与填充 vector 和 list的方式不同，但是用于迭代集合元素的代码在本质上是相同的。</p><p>遍历<strong>map(映射)</strong></p><p>这个有点复杂。Maps and multimaps 取元素对(定义为std::pair)。我们使用<strong><code>make_pair()</code>辅助函数</strong>来轻松地创建对。*<em>std::pair *</em>允许通过第一个和第二个成员访问pair的元素。</p><p>在我们的map中，我们使用first作为键，second作为值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; mymap;</span><br><span class="line">mymap.insert(<span class="built_in">std</span>::make_pair(<span class="number">4</span>, <span class="string">"apple"</span>));</span><br><span class="line">mymap.insert(<span class="built_in">std</span>::make_pair(<span class="number">2</span>, <span class="string">"orange"</span>));</span><br><span class="line">mymap.insert(<span class="built_in">std</span>::make_pair(<span class="number">1</span>, <span class="string">"banana"</span>));</span><br><span class="line">mymap.insert(<span class="built_in">std</span>::make_pair(<span class="number">3</span>, <span class="string">"grapes"</span>));</span><br><span class="line">mymap.insert(<span class="built_in">std</span>::make_pair(<span class="number">6</span>, <span class="string">"mango"</span>));</span><br><span class="line">mymap.insert(<span class="built_in">std</span>::make_pair(<span class="number">5</span>, <span class="string">"peach"</span>));</span><br><span class="line"> </span><br><span class="line"><span class="keyword">auto</span> it&#123; mymap.cbegin() &#125;; <span class="comment">// declare a const iterator and assign to start of vector</span></span><br><span class="line"><span class="keyword">while</span> (it != mymap.cend()) <span class="comment">// while it hasn't reach the end</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">"="</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">" "</span>; <span class="comment">// print the value of the element it points to</span></span><br><span class="line">++it; <span class="comment">// and iterate to the next element</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，迭代器很容易遍历容器的每个元素。您根本不需要关心map如何存储数据!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.learncpp.com/cpp-tutorial/16-3-stl-iterators-overview/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.learncp
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C&amp;C++/容器类STL</title>
    <link href="https://longlongqin.github.io/archives/ef749515.html"/>
    <id>https://longlongqin.github.io/archives/ef749515.html</id>
    <published>2020-05-26T01:17:51.614Z</published>
    <updated>2020-05-26T02:44:38.151Z</updated>
    
    <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/16-2-stl-containers-overview/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/16-2-stl-containers-overview/</a></p><hr><p>到目前为止，<strong>STL库最常用的功能是STL容器类</strong>。如果您需要快速复习一下容器类，请查看<a href="https://www.learncpp.com/cpp-tutorial/106-container-classes/" target="_blank" rel="noopener">10.6 – Container classes</a>。</p><p>STL包含许多不同的容器类，可以在不同的情况下使用。一般来说，容器类分为三个基本类别:</p><ul><li>序列容器</li><li>关联容器</li><li>容器适配器</li></ul><h1 id="序列容器"><a href="#序列容器" class="headerlink" title="序列容器"></a>序列容器</h1><p><strong>序列容器是维护容器中元素顺序的容器类</strong>。序列容器的一个定义特性是，<u>您可以根据位置选择元素的插入位置</u>。</p><p>序列容器最常见的例子是<strong>数组</strong>：如果您将四个元素插入到一个数组中，那么这些元素将按照您插入它们的确切顺序排列。</p><p>在c++ 11中，STL包含6个序列容器:</p><ul><li><p>std::vector</p><blockquote><p>在头文件：<code>vector</code>中</p></blockquote></li><li><p>std::deque</p><blockquote><p>在头文件：<code>deque</code>中</p></blockquote></li><li><p>std::array</p></li><li><p>std::list</p></li><li><p>std::forward_list</p></li><li><p>std::basic_string</p></li></ul><h2 id="std-vector"><a href="#std-vector" class="headerlink" title="std::vector"></a>std::vector</h2><p>如果你学过物理，你可能会认为<strong>矢量</strong>是同时具有大小和方向的实体。但是，STL中名为<strong>vector的类</strong>是一个动态数组，能够根据需要增长以包含它的元素。</p><p>vector类允许通过操作符[]<strong>随机访问</strong>它的元素，并且插入和删除vector中<strong>末尾</strong>的元素通常是很快的。</p><p>下面的程序将6个数字插入到一个向量中，并使用重载的[]运算符访问它们以打印它们。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vect;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count &lt; <span class="number">6</span>; ++count)</span><br><span class="line">        vect.push_back(<span class="number">10</span> - count); <span class="comment">// insert at end of array</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index=<span class="number">0</span>; index &lt; vect.<span class="built_in">size</span>(); ++index)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; vect[index] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">10</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="std-deque"><a href="#std-deque" class="headerlink" title="std::deque"></a>std::deque</h2><p><strong>deque类</strong>(发音为“deck”)是一个双端队列类，<strong>实现为一个可以从两端增长的动态数组。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; deq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count &lt; <span class="number">3</span>; ++count)</span><br><span class="line">    &#123;</span><br><span class="line">        deq.push_back(count); <span class="comment">// insert at end of array</span></span><br><span class="line">        deq.push_front(<span class="number">10</span> - count); <span class="comment">// insert at front of array</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index=<span class="number">0</span>; index &lt; deq.<span class="built_in">size</span>(); ++index)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; deq[index] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="std-list"><a href="#std-list" class="headerlink" title="std::list"></a>std::list</h2><p>std::list是一种特殊类型的序列容器，称为<strong>双链表</strong>，其中容器中的每个元素都包含指向列表中的下一个和前一个元素的指针。</p><p>std::list只提供对列表的<strong>开始和结束的访问</strong>。<strong>不提供随机访问</strong>。</p><blockquote><p>如果您想要在中间找到一个值，您必须从一端开始并“遍历列表”，直到找到您想要找到的元素。</p><p>通常使用迭代器遍历列表。</p></blockquote><p>列表的优点是<strong>，如果您已经知道要将元素插入到列表的何处，那么将元素插入到列表中会非常快</strong>。</p><h2 id="特殊的：string"><a href="#特殊的：string" class="headerlink" title="特殊的：string"></a>特殊的：string</h2><p>尽管STL string(和wstring)类通常不作为一种序列容器类型包含在内，但它们实际上是，因为它们可以被认为是一个带有char(或wchar)类型数据元素的向量。</p><h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><p>关联容器是在将输入插入容器时<strong>自动对其输入排序的容器</strong>。默认情况下，<strong>关联容器使用操作符&lt;比较元素。</strong></p><ul><li><p><strong>set</strong>是一个容器，<u>它存储惟一的元素，不允许有重复的元素</u>。<strong>元素根据它们的值排序。</strong></p></li><li><p><strong>multiset</strong>是一个允许重复元素的集合。</p></li><li><p><strong>map</strong>(也称为关联数组)是一个集合，<strong>其中每个元素都是一对，称为键/值对</strong>。该键用于对数据进行排序和索引，并且必须是唯一的。值是实际的数据。</p></li><li><p><strong>multimap</strong>(也称为<strong>字典</strong>) 是允许重复键的映射。所有键按升序排列，你可以通过键查找值。</p><blockquote><p>现实生活中的字典是多种多样的:</p><p><strong>键</strong>是单词，而<strong>值</strong>是单词的含义。有些单词可以有多种含义，这就是为什么字典是多用途地图而不是地图的原因。</p></blockquote></li></ul><h1 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h1><p>容器适配器是适应特定用途的特殊<strong>预定义容器</strong>。关于容器适配器的有趣之处在于，您可以选择希望它们使用的序列容器。</p><ul><li><p><strong>stack(栈)</strong>是一个容器，元素在<strong>后进先出</strong>上下文中操作。</p><blockquote><p><strong>栈默认使用deque作为它们的默认序列容器</strong>(这看起来很奇怪，因为vector似乎更适合)，但可以使用vector或 list。</p></blockquote></li><li><p><strong>queue(队列)</strong>是一个容器，元素在FIFO(<strong>先入先出</strong>)上下文中操作，<u>元素被插入(推入)到容器的后面，然后从前面删除(弹出)</u>。</p><blockquote><p><strong>队列默认使用deque，但也可以使用list。</strong></p></blockquote></li><li><p>*<em>priority queue(优先队列) *</em> 是一种保持元素排序的队列(通过操作符&lt;)。<u>推入元素时，元素在队列中排序</u>。从前端删除一个元素将 返回 优先队列中优先级最高的项。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.learncpp.com/cpp-tutorial/16-2-stl-containers-overview/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.learnc
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C&amp;C++/标准库</title>
    <link href="https://longlongqin.github.io/archives/b054a192.html"/>
    <id>https://longlongqin.github.io/archives/b054a192.html</id>
    <published>2020-05-26T00:48:20.949Z</published>
    <updated>2020-05-26T00:59:31.475Z</updated>
    
    <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/16-1-the-standard-template-library-stl/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/16-1-the-standard-template-library-stl/</a></p><hr><p>恭喜你! 您已经完成了教程的主要部分!</p><p>前面的课程中，我们介绍了许多c++语言的主要特性(包括c++ 11/14/17语言扩展中的一些特性)。</p><p>因此，显而易见的问题是，“下一步是什么?”你可能注意到的一件事是，很多程序都在反复使用相同的概念:循环、字符串、数组、排序等等…… 您可能还注意到，使用容器的非类版本和通用算法编写程序很容易出错。好消息是，c++附带了一个充满了可重用类的库，您可以在其中构建程序。这个库称为<strong>c++标准库</strong>。</p><p><strong>The Standard Library</strong></p><p>标准库包含一组提供模板容器、算法和迭代器的类。如果您需要一个公共类或算法，标准库中很可能就有。这样做的好处是，您可以利用这些类，而不需要自己编写和调试这些类，而且标准库很好地提供了这些类的相当有效的版本。缺点是标准库很复杂，而且可能有点吓人，因为所有东西都是模板化的。</p><p>幸运的是，您可以将标准库分成小块，只使用需要的部分，而忽略其他部分，直到您准备好处理它。</p><p>在接下来的几节课中，我们将从高层次上了解标准库提供的容器、算法和迭代器的类型。在以后的课程中，我们将深入探讨一些特定的类。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.learncpp.com/cpp-tutorial/16-1-the-standard-template-library-stl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
