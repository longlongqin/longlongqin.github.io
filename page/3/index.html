<!DOCTYPE html><html><head hexo-theme="https://volantis.js.org/#2.1.4"><meta charset="utf-8"><meta name="robots" content="noindex,follow"><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><title>龙龙‘S BLOG</title><link rel="alternate" href="/atom.xml" title="龙龙‘S BLOG"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css"><link rel="shortcut icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1.4.3/css/style.css"><script>function setLoadingBarProgress(e){document.getElementById("loading-bar").style.width=e+"%"}</script></head><body><script type="text/javascript" src="/js/love.js"></script><script type="text/javascript" src="/js/ergao.js"></script><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><header class="l_header shadow blur"><div class="wrapper"><div class="nav-sub container--flex"><a class="logo flat-box"></a><ul class="switcher h-list"><li><a class="s-comment flat-btn fas fa-comments fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-toc flat-btn fas fa-list fa-fw" target="_self" href="javascript:void(0)"></a></li></ul></div><div class="nav-main container container--flex"><a class="logo flat-box" target="_self" href="/"><i class="fas fa-home"></i> 龙龙</a><div class="menu navigation"><ul class="h-list"><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list-alt fa-fw fa-fw"></i> 索引</a><ul class="submenu"><li><a class="flat-box" href="/categories/" id="categories"><i class="fas fa-folder-open fa-fw fa-fw"></i> 分类</a><ul class="submenu"><li><a class="flat-box" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="categoriesE5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-fire fa-fw"></i> 学习笔记</a></li><li><a class="flat-box" href="/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" id="categoriesE5AE9EE794A8E68A80E5B7A7"><i class="fas fa-fire fa-fw"></i> 实用技巧</a></li></ul></li><li><a class="flat-box" href="/tags/" id="tags"><i class="fas fa-tags fa-fw fa-fw"></i> 标签</a></li><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list fa-fw fa-fw"></i> 时间轴</a></li></ul></li><li><a class="flat-box" href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="E5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-book fa-fw"></i> 学习笔记</a></li><li><a class="flat-box"><i class="fas fa-wrench fa-fw"></i> 工具</a><ul class="submenu"><li><a class="flat-box" href="https://www.thinkcmf.com/font/search/index.html" target="_blank" rel="noopener" id="https:www.thinkcmf.comfontsearchindex.html"><i class="fas fa-font fa-fw"></i> Font Awesome图标</a></li><li><a class="flat-box" href="https://www.sojson.com/image/change.html" target="_blank" rel="noopener" id="https:www.sojson.comimagechange.html"><i class="fa fa-crop fa-fw"></i> 在线图片尺寸修改</a></li><li><a class="flat-box" href="http://dir.scmor.com/" target="_blank" rel="noopener" id="http:dir.scmor.com"><i class="fa fa-search fa-fw"></i> Google学术&搜索镜像</a></li><li><a class="flat-box" href="https://emojixd.com/" target="_blank" rel="noopener" id="https:emojixd.com"><i class="fa fa-smile-o fa-fw"></i> Emoji表情符号辞典📓</a></li></ul></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw fa-fw"></i> 关于</a><ul class="submenu"><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-user-circle fa-fw fa-fw"></i> 关于我</a></li><hr><li><a class="flat-box" href="/friends/" id="friends"><i class="fas fa-link fa-fw"></i> 友人帐</a></li><li><a class="flat-box" href="/comment/" id="comment"><i class="fas fa-comment fa-fw"></i> 留言板</a></li><hr><li><a class="flat-box" href="https://github.com/longlongqin" target="_blank" rel="noopener" id="https:github.comlonglongqin"><i class="fab fa-github fa-fw fa-fw"></i> 我的Github</a></li><li><a class="flat-box" href="https://longlongqin.gitee.io" target="_blank" rel="noopener" id="https:longlongqin.gitee.io"><i class="fa fa-chevron-circle-right fa-fw"></i> matery主题博客</a></li></ul></li><li><a class="flat-box" href="https://volantis.js.org/tag-plugins/" target="_blank" rel="noopener" id="https:volantis.js.orgtag-plugins"><i class="fa fa-bookmark fa-fw"></i> Volantis主题文档</a></li><li><a class="flat-box" href="/easysearch/" id="easysearch"><i class="fa fa-search fa-fw"></i> easy搜索</a></li></ul></div><div class="m_search"><form name="searchform" class="form u-search-form"><i class="icon fas fa-search fa-fw"></i> <input type="text" class="input u-search-input" placeholder="search for everything"></form></div><ul class="switcher h-list"><li><a class="s-search flat-btn fas fa-search fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-menu flat-btn fas fa-bars fa-fw" target="_self" href="javascript:void(0)"></a></li></ul></div></div></header><ul class="menu-phone navigation white-box"><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list-alt fa-fw fa-fw"></i> 索引</a></li><li><a class="flat-box" href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="E5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-book fa-fw"></i> 学习笔记</a></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw fa-fw"></i> 关于</a></li></ul><script>setLoadingBarProgress(40)</script><div class="l_body nocover"><div class="body-wrapper"><div class="l_main"><section class="post-list"><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/8cf18577.html">C&C++/std：：shared_ptr和std：：weak_ptr的循环依赖问题</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月25日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：1.9k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：8分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/15-7-circular-dependency-issues-with-stdshared_ptr-and-stdweak_ptr/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/15-7-circular-dependency-issues-with-stdshared_ptr-and-stdweak_ptr/</a></p><hr><p>在上一节课中，我们了解了std::shared_ptr如何允许多个智能指针共同拥有相同的资源。然而，在某些情况下，这可能会成为问题。考虑下面的情况，两个独立对象中的共享指针都指向另一个对象:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // for std::shared_ptr</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Person&gt; m_partner; <span class="comment">// initially created empty</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		</span><br><span class="line">	Person(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name): m_name(name)</span><br><span class="line">	&#123; </span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_name &lt;&lt; <span class="string">" created\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~Person()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_name &lt;&lt; <span class="string">" destroyed\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="title">partnerUp</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Person&gt; &amp;p1, <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Person&gt; &amp;p2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!p1 || !p2)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">		p1-&gt;m_partner = p2;</span><br><span class="line">		p2-&gt;m_partner = p1;</span><br><span class="line"> </span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p1-&gt;m_name &lt;&lt; <span class="string">" is now partnered with "</span> &lt;&lt; p2-&gt;m_name &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> lucy = <span class="built_in">std</span>::make_shared&lt;Person&gt;(<span class="string">"Lucy"</span>); <span class="comment">// create a Person named "Lucy"</span></span><br><span class="line">	<span class="keyword">auto</span> ricky = <span class="built_in">std</span>::make_shared&lt;Person&gt;(<span class="string">"Ricky"</span>); <span class="comment">// create a Person named "Ricky"</span></span><br><span class="line"> </span><br><span class="line">	partnerUp(lucy, ricky); <span class="comment">// Make "Lucy" point to "Ricky" and vice-versa</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们使用<code>make_shared()</code>动态分配两个person，“Lucy”和“Ricky” (以确保Lucy和Ricky在main()的末尾被销毁) 。</p><p>然后我们把它们合起来(即。调用函数<code>partnerUp</code>)。</p><ul><li>这将std::shared_ptr内的“Lucy”指向“Ricky”，而std::shared_ptr内的“Ricky”指向“Lucy”。</li></ul><p>共享指针是用来共享的，所以lucy共享指针和Rick的m_partner共享指针都指向“lucy”是可以的(反之亦然)。</p><p>但是，这个程序并没有按照预期执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Lucy created</span><br><span class="line">Ricky created</span><br><span class="line">Lucy is now partnered with Ricky</span><br></pre></td></tr></table></figure><p>没有按照预期进行资源释放，发生了什么？</p><ul><li><p>调用<code>partnerUp()</code>之后，有两个指向“Ricky” (ricky和lucy的m_partner) 的共享指针，以及两个指向“Lucy” (Lucy和Ricky的m_partner) 的共享指针。</p><p>在函数结束时，<strong>ricky</strong>共享指针首先超出作用域。当这种情况发生时，ricky会检查是否有其他共享指针共同拥有这个Person“Ricky”。是有的(Lucy的m_partner)。正因为如此，它没有释放“Ricky”(如果释放了，那么Lucy的m_partner将以一个悬浮指针结束)。现在，我们有一个指向“Ricky”(Lucy的m_partner)的共享指针，还有两个指向“Lucy”(Lucy，和Ricky的m_partner)的共享指针。</p><p>接下来，<strong>lucy</strong>共享指针超出范围，同样的事情发生了。共享指针lucy检查是否有其他共享指针共同拥有这个人“lucy”。是有的(Ricky的m_partner)，所以“Lucy”没有被释放。此时，有一个共享指针指向“Lucy”(Ricky的m_partner)，还有一个共享指针指向“Ricky”(Lucy的m_partner)。</p><p>然后程序就结束了—— “Lucy” 和 “Ricky” 都没有被释放! 从本质上讲，“Lucy”最终阻止了 “Ricky”被毁灭， “Ricky”最终阻止了“Lucy”被毁灭。</p></li></ul><p>事实证明，这种情况在共享指针形成循环引用的任何时候都可能发生。</p><h1 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h1><p><strong>循环引用</strong>是一系列引用，<u>其中每个对象引用下一个对象，最后一个对象引用回第一个对象，从而导致引用循环</u>。<strong>这些引用不需要是实际的c++引用——它们可以是指针、惟一id或任何其他标识特定对象的方法。</strong></p><blockquote><p><strong>在共享指针的上下文中，引用将是指针。</strong></p></blockquote><p>这正是我们在上面的例子中看到的:</p><ul><li>“Lucy” 指向 “Ricky”；而 “Ricky” 也指向 “Lucy” 。</li></ul><blockquote><p>用三个指针，当A点在B点，B点在C点，C点在A点，会得到同样的结果。</p></blockquote><p>共享指针形成循环的实际效果是，<strong>每个对象最终保持下一个对象为活动状态</strong>（<strong>最后一个对象保持第一个对象为活动状态</strong>。）</p><p><strong>因此，在这个系列中没有对象可以被释放，因为它们都认为其他一些对象仍然需要它!</strong></p><h1 id="单个std-shared-ptr也可以造成循环依赖问题"><a href="#单个std-shared-ptr也可以造成循环依赖问题" class="headerlink" title="单个std::shared_ptr也可以造成循环依赖问题"></a>单个<code>std::shared_ptr</code>也可以造成循环依赖问题</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // for std::shared_ptr</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Resource&gt; m_ptr; <span class="comment">// initially created empty</span></span><br><span class="line">	</span><br><span class="line">	Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">	~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> ptr1 = <span class="built_in">std</span>::make_shared&lt;Resource&gt;();</span><br><span class="line"> </span><br><span class="line">	ptr1-&gt;m_ptr = ptr1; <span class="comment">// ⭐m_ptr现在正在共享包含它自己的资源</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，当ptr1超出作用域时，它不会释放资源，因为资源的m_ptr正在共享资源。然后就没有人可以删除资源了(m_ptr永远不会超出作用域，所以它永远不会有机会)。因此，程序打印:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Resource acquired</span><br></pre></td></tr></table></figure><h1 id="std-weak-ptr来解决循环依赖问题"><a href="#std-weak-ptr来解决循环依赖问题" class="headerlink" title="std::weak_ptr来解决循环依赖问题"></a><strong>std::weak_ptr</strong>来解决循环依赖问题</h1><p><code>std::weak_ptr</code>是为了解决上面描述的“周期性所有权”问题而设计的。<code>std::weak_ptr</code>是一个观察者——它可以 像std::shared_ptr一样 观察和访问(或其他std::weak_ptrs)相同的对象，<strong>但它不被视为所有者。</strong></p><p>请记住，<strong>当一个std::shared指针超出作用域时，它只考虑其他std::shared_ptr是否共同拥有该对象。std: weak_ptr不算数!</strong></p><p>让我们使用std::weak_ptr来解决本节中刚开始的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // for std::shared_ptr and std::weak_ptr</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line">	<span class="built_in">std</span>::weak_ptr&lt;Person&gt; m_partner; <span class="comment">// ⭐⭐⭐note: This is now a std::weak_ptr</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		</span><br><span class="line">	Person(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name): m_name(name)</span><br><span class="line">	&#123; </span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_name &lt;&lt; <span class="string">" created\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~Person()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_name &lt;&lt; <span class="string">" destroyed\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="title">partnerUp</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Person&gt; &amp;p1, <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Person&gt; &amp;p2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!p1 || !p2)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">		p1-&gt;m_partner = p2;</span><br><span class="line">		p2-&gt;m_partner = p1;</span><br><span class="line"> </span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p1-&gt;m_name &lt;&lt; <span class="string">" is now partnered with "</span> &lt;&lt; p2-&gt;m_name &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> lucy = <span class="built_in">std</span>::make_shared&lt;Person&gt;(<span class="string">"Lucy"</span>);</span><br><span class="line">	<span class="keyword">auto</span> ricky = <span class="built_in">std</span>::make_shared&lt;Person&gt;(<span class="string">"Ricky"</span>);</span><br><span class="line"> </span><br><span class="line">	partnerUp(lucy, ricky);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Lucy created</span><br><span class="line">Ricky created</span><br><span class="line">Lucy is now partnered with Ricky</span><br><span class="line">Ricky destroyed</span><br><span class="line">Lucy destroyed</span><br></pre></td></tr></table></figure><p>在功能上，它的工作方式几乎与有问题的示例相同。但是，现在当ricky超出范围时，它会看到没有其他std::shared_ptr指向“ricky”(来自“Lucy”的std::weak_ptr不计算)。因此，它将释放“Ricky”。露西也是如此。</p><h2 id="std-weak-ptr-的使用"><a href="#std-weak-ptr-的使用" class="headerlink" title="std::weak_ptr 的使用"></a>std::weak_ptr 的使用</h2><p>std::weak_ptr缺点是不能直接使用(<strong>它们没有操作符-&gt;</strong>)。</p><p>要使用std::weak_ptr，必须首先将其转换为std::shared_ptr。然后可以使用std::shared_ptr。</p><ul><li>要将std::weak_ptr转换为std::shared_ptr，可以使用<strong><code>lock()</code>成员函数</strong>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // for std::shared_ptr and std::weak_ptr</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line">	<span class="built_in">std</span>::weak_ptr&lt;Person&gt; m_partner; <span class="comment">// note: This is now a std::weak_ptr</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">	Person(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name) : m_name(name)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_name &lt;&lt; <span class="string">" created\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~Person()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_name &lt;&lt; <span class="string">" destroyed\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="title">partnerUp</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Person&gt; &amp;p1, <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Person&gt; &amp;p2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!p1 || !p2)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">		p1-&gt;m_partner = p2;</span><br><span class="line">		p2-&gt;m_partner = p1;</span><br><span class="line"> </span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p1-&gt;m_name &lt;&lt; <span class="string">" is now partnered with "</span> &lt;&lt; p2-&gt;m_name &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Person&gt; <span class="title">getPartner</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_partner.lock(); &#125; <span class="comment">//⭐⭐⭐ use lock() to convert weak_ptr to shared_ptr</span></span><br><span class="line">	<span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> lucy = <span class="built_in">std</span>::make_shared&lt;Person&gt;(<span class="string">"Lucy"</span>);</span><br><span class="line">	<span class="keyword">auto</span> ricky = <span class="built_in">std</span>::make_shared&lt;Person&gt;(<span class="string">"Ricky"</span>);</span><br><span class="line"> </span><br><span class="line">	partnerUp(lucy, ricky);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">auto</span> partner = ricky-&gt;getPartner(); <span class="comment">// get shared_ptr to Ricky's partner</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ricky-&gt;getName() &lt;&lt; <span class="string">"'s partner is: "</span> &lt;&lt; partner-&gt;getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Lucy created</span><br><span class="line">Ricky created</span><br><span class="line">Lucy is now partnered with Ricky</span><br><span class="line">Ricky&#39;s partner is: Lucy</span><br><span class="line">Ricky destroyed</span><br><span class="line">Lucy destroyed</span><br></pre></td></tr></table></figure><p>我们不需要担心与std::shared_ptr变量“m_partner”的循环依赖关系，因为它只是函数内部的一个局部变量。它最终将在函数结束时超出作用域，引用计数将递减1。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><code>std::hared_ptr</code>可以在需要多个智能指针共享资源时使用。当最后一个<code>std::shared_ptr</code>超出作用域时，资源将被释放。</p><p><code>std::weak_ptr</code>可以在需要智能指针时使用，<strong>该指针可以查看和使用共享资源，但不参与该资源的所有权</strong></p></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/96b73b83.html">C&C++/智能指针“std：：shared_ptr”</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月25日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：1.8k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：7分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/15-6-stdshared_ptr/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/15-6-stdshared_ptr/</a></p><hr><h1 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h1><ul><li><p><strong>智能指针<code>std::unique_ptr</code></strong>，<strong>旨在单独拥有和管理一种资源</strong>。</p></li><li><p>而，<strong>智能指针<code>std::shared_ptr</code></strong>，<strong>旨在解决需要多个智能指针共同拥有一个资源的情况。</strong></p><blockquote><p>也就是说，<strong>多个<code>std::shared_ptr</code>指向同一个资源是没有问题的</strong>。</p></blockquote><p><strong><code>std::shared_ptr</code> 位于头文件<code>&lt;memory&gt;</code> 之中</strong>（<code>std::unique_ptr</code>也在该头文件中）</p></li></ul><h2 id="当多个std-shared-ptr指向同一资源，使用“复制”"><a href="#当多个std-shared-ptr指向同一资源，使用“复制”" class="headerlink" title="当多个std::shared_ptr指向同一资源，使用“复制”"></a>当多个std::shared_ptr指向同一资源，使用“复制”</h2><p>在内部，<code>std::shared_ptr</code> 会跟踪共享资源的 <strong>std::shared_ptr的数量</strong>。<u>只要有至少一个<code>std::shared_ptr</code>指向该资源，该资源就不会被释放，即使单个<code>std::shared_ptr</code>被销毁。</u></p><p><strong>只有在这些众多指向同一资源的 std::shared_ptr 中的最后一个 超出其作用域（或者 被重新分配指向其他东西）时，这个资源才会被释放。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // for std::shared_ptr</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">	~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 分配一个资源对象，并让std::shared_ptr 拥有它</span></span><br><span class="line">	Resource *res = <span class="keyword">new</span> Resource;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Resource&gt; <span class="title">ptr1</span><span class="params">(res)</span></span>;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Resource&gt; <span class="title">ptr2</span><span class="params">(ptr1)</span></span>; <span class="comment">// 使用复制初始化 使另一个std::shared_ptr指向相同的对象</span></span><br><span class="line"> </span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Killing one shared pointer\n"</span>;</span><br><span class="line">	&#125; <span class="comment">// ptr2超出了范围，但是什么也没有发生</span></span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Killing another shared pointer\n"</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// ptr1超出了这里的范围，分配的资源被销毁</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Resource acquired</span><br><span class="line">Killing one shared pointer</span><br><span class="line">Killing another shared pointer</span><br><span class="line">Resource destroyed</span><br></pre></td></tr></table></figure><p>在上面的代码中，<strong>我们创建了一个动态 资源对象，并设置了一个名为ptr1的std::shared_ptr来管理它</strong>。</p><p>在嵌套块内部，我们使用复制初始化 (std::shared_ptr允许这样做，因为资源可以共享) 来创建第二个std::shared_ptr (ptr2)，它指向相同的资源。</p><ul><li><p>当ptr2超出范围时，资源不会被释放，因为ptr1仍然指向资源。</p></li><li><p>当ptr1超出范围时，ptr1注意到不再有std::shared_ptr管理资源，因此它释放资源。</p></li></ul><p><strong>注意，我们从第一个共享指针创建了第二个共享指针(使用复制初始化)。这是很重要的</strong>。考虑以下类似的方案:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // for std::shared_ptr</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">	~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Resource *res = <span class="keyword">new</span> Resource;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Resource&gt; <span class="title">ptr1</span><span class="params">(res)</span></span>;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Resource&gt; <span class="title">ptr2</span><span class="params">(res)</span></span>; <span class="comment">// ⭐直接从res创建ptr2(而不是ptr1)</span></span><br><span class="line"> </span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Killing one shared pointer\n"</span>;</span><br><span class="line">	&#125; <span class="comment">// ptr2 goes out of scope here, and the allocated Resource is destroyed</span></span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Killing another shared pointer\n"</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// ptr1 goes out of scope here, and the allocated Resource is destroyed again</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Resource acquired</span><br><span class="line">Killing one shared pointer</span><br><span class="line">Resource destroyed</span><br><span class="line">Killing another shared pointer</span><br><span class="line">Resource destroyed</span><br></pre></td></tr></table></figure><p>这里的不同之处在于，我们分别创建了两个std::shared_ptr。<strong>因此，即使它们都指向相同的资源，它们也不知道对方的存在。（<a href="##独立创建两个指向相同资源的std::shared_ptr会出错">具体解释在下面</a>）</strong> 当ptr2超出范围时，它认为自己是资源的唯一所有者，并释放资源。当ptr1稍后超出范围时，它会进行相同的思考，并再次尝试删除资源。然后坏事发生了。</p><p><strong>幸运的是，当需要多个共享指针指向同一资源时，可以通过使用复制赋值或复制初始化轻松避免这种情况。</strong></p><blockquote><p><strong>规则:如果需要多个指向同一资源的std::shared_ptr，则始终复制一个现有的std::shared_ptr。</strong></p></blockquote><h1 id="std-make-shared"><a href="#std-make-shared" class="headerlink" title="std::make_shared"></a>std::make_shared</h1><p><strong>就像std::make_unique()可以用来在c++ 14中创建一个std::unique_ptr；</strong></p><p><strong><code>std::make_shared()</code>可以用来创建一个<code>std::shared_ptr</code>。</strong></p><blockquote><p><code>std::make_shared()</code>在c++ 11中可用。</p></blockquote><p>这是我们最初的例子，使用<code>std::make_shared()</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // for std::shared_ptr</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">	~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 分配一个Resource对象，并将其所有权 给std::shared_ptr</span></span><br><span class="line">	<span class="keyword">auto</span> ptr1 = <span class="built_in">std</span>::make_shared&lt;Resource&gt;();</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> ptr2 = ptr1; <span class="comment">// 使用ptr1的复制初始化创建ptr2</span></span><br><span class="line"> </span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Killing one shared pointer\n"</span>;</span><br><span class="line">	&#125; <span class="comment">// ptr2 goes out of scope here, but nothing happens</span></span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Killing another shared pointer\n"</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// ptr1 goes out of scope here, and the allocated Resource is destroyed</span></span><br></pre></td></tr></table></figure><p><strong>使用std::make_shared()的原因与std::make_unique()相同。</strong></p><ul><li><code>std::make_shared()</code>更简单、更安全 (但无法使用此方法直接创建指向同一资源的两个std::shared_ptr)。</li></ul><h1 id="std-shared-ptr实际上包含两个指针"><a href="#std-shared-ptr实际上包含两个指针" class="headerlink" title="std::shared_ptr实际上包含两个指针"></a><code>std::shared_ptr</code>实际上包含两个指针</h1><p><code>std::unique_ptr</code>，它在内部使用<strong>一个指针</strong>；</p><p>而<code>std::shared_ptr</code>，它在内部使用<strong>两个指针</strong>。</p><ul><li>一个指针指向<strong>被管理的资源</strong>。</li><li>其他的点指向一个“<strong>控制块”</strong>。它是一个动态分配的对象，跟踪一堆东西，<u>包括有多少std::shared_ptr指向资源。</u></li></ul><p>当通过std::shared_ptr的构造函数 创建std::shared_ptr时，将<u>分别</u>分配 托管对象(通常传入) 和 控制块(构造函数创建) 的内存。</p><p><strong>但是，在使用std::make_shared()时，可以将其优化为单个内存分配，从而提高性能。</strong></p><h2 id="独立创建两个指向相同资源的std-shared-ptr会出错"><a href="#独立创建两个指向相同资源的std-shared-ptr会出错" class="headerlink" title="独立创建两个指向相同资源的std::shared_ptr会出错"></a>独立创建两个指向相同资源的std::shared_ptr会出错</h2><p>这也解释了为什么独立地创建两个指向相同资源的std::shared_ptr会给我们带来麻烦。</p><ul><li><p>每个std::shared_ptr都有一个指向资源的指针。但是，每个std::shared_ptr将独立地分配它自己的控制块，<strong>这将表明它是唯一拥有该资源的指针。</strong></p></li><li><p>因此，当std::shared_ptr超出作用域时，它将释放资源，而没有意识到还有其他std::shared_ptr也试图管理该资源。</p></li></ul><p><strong>但是，当使用复制赋值克隆std::shared_ptr时，可以适当地更新控制块中的数据，以指示现在有额外的std::shared_ptr共同管理资源。</strong></p><h1 id="std-shared-ptr可以std-unique-ptr中创建"><a href="#std-shared-ptr可以std-unique-ptr中创建" class="headerlink" title="std::shared_ptr可以std::unique_ptr中创建"></a><code>std::shared_ptr</code>可以<code>std::unique_ptr</code>中创建</h1><p>一个<code>std::unique_ptr</code>可以通过一个特殊的<code>std::shared_ptr</code>构造函数转换成一个<code>std::shared_ptr</code>，这个构造函数接受一个<code>std::unique_ptr</code> r-value。</p><p><code>std::unique_ptr</code>的内容将被<strong>移动</strong>到<code>std::shared_ptr</code>。</p><p>但是，<strong>std::shared_ptr不能安全地转换为std::unique_ptr。</strong></p><p>这意味着，如果要创建一个将返回智能指针的函数，最好返回一个std::unique_ptr，并在适当的时候将其分配给一个std::shared_ptr。</p><h1 id="std-shared-ptr的危害"><a href="#std-shared-ptr的危害" class="headerlink" title="std::shared_ptr的危害"></a><code>std::shared_ptr</code>的危害</h1><p><code>std::shared_ptr</code>遇到了一些与<code>std::unique_ptr</code>相同的挑战：</p><ul><li>如果没有正确地处理std::shared_ptr (可能是因为它是动态分配的且从未删除，也可能是因为它是动态分配且从未删除的对象的一部分) 那么它所管理的资源也不会被释放。</li></ul><p>使用std::unique_ptr，您只需要担心一个智能指针被正确处理。</p><p>对于std::shared_ptr，您必须考虑所有这些问题。<strong>如果管理资源的std::shared_ptr中的任何一个没有被正确销毁，资源将不会被正确释放。</strong></p><h1 id="std-shared-ptr和数组"><a href="#std-shared-ptr和数组" class="headerlink" title="std::shared_ptr和数组"></a>std::shared_ptr和数组</h1><p>在c++ 14和更早的版本中，std::shared_ptr不支持管理数组，不应该用于管理C风格的数组。</p><p><strong>从c++ 17开始，std::shared_ptr就支持数组了</strong>。<strong>但是</strong>，从c++ 17开始，<strong>std::make_shared仍然缺乏对数组的适当支持</strong>，不应该用于创建共享数组。这可能会在c++ 20中得到解决。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>std::shared_ptr是为需要多个智能指针共同管理同一资源而设计的。当管理资源的最后一个std::shared_ptr被销毁时，资源将被释放。</p></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/e8f15917.html">C&C++/智能指针“std：：unique_ptr”</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月24日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：3k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：12分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/15-5-stdunique_ptr/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/15-5-stdunique_ptr/</a></p><hr><p><strong>智能指针是一个管理动态分配对象的<u>类</u>。尽管智能指针可以提供其他特性，但智能指针的定义特征是它管理动态分配的资源，并确保在适当的时间(通常是当智能指针超出范围时)正确地清理动态分配的对象。</strong></p><p>因此，<strong>智能指针永远不应该自己动态分配</strong> (否则，智能指针可能没有被释放，这意味着它拥有的对象将不会被释放，从而导致内存泄漏)。</p><blockquote><p>通过在栈上分配智能指针(作为局部变量或类的组合成员)，我们可以保证当智能指针包含的函数或对象结束时，它将正确地超出作用域，确保智能指针拥有的对象被正确释放。</p></blockquote><p>c++ 11标准库附带了4个智能指针类:</p><ul><li><p><code>std::auto_ptr</code>(你不应该使用它——它在c++ 17中被删除了)，</p></li><li><p><code>std::unique_ptr</code>, ⭐</p></li><li><p><code>std::shared_ptr</code></p></li><li><p><code>std::weak_ptr</code>。</p></li></ul><p>其中，<code>std::unique_ptr</code>是使用最多的智能指针类，所以，就主要讲一下这个指针类。</p><h1 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a><code>std::unique_ptr</code></h1><blockquote><p><strong>在头文件 <code>&lt;memory&gt;</code> 中</strong></p></blockquote><p>在C++11中，<code>std::unique_ptr</code>是<code>std::auto_ptr</code> 的替代品。<strong>它应该用于管理任何不被多个对象共享的动态分配的对象。</strong></p><p>也就是说，<strong><code>std::unique_ptr</code>应该完全拥有它管理的对象，而不是与其他类共享该所有权。</strong></p><p>一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // for std::unique_ptr</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">	~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// allocate a Resource object and have it owned by std::unique_ptr</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Resource&gt; res&#123; <span class="keyword">new</span> Resource() &#125;; <span class="comment">//⭐</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// res goes out of scope here, and the allocated Resource is destroyed</span></span><br></pre></td></tr></table></figure><p><strong>因为<code>std::unique_ptr</code>是在这里的栈上分配的，所以它最终肯定会超出范围，当超出范围时，它将删除它正在管理的资源。</strong></p><h2 id="std-unique-ptr内置使用移动语义"><a href="#std-unique-ptr内置使用移动语义" class="headerlink" title="std::unique_ptr内置使用移动语义"></a><code>std::unique_ptr</code>内置使用移动语义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // for std::unique_ptr</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">	~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Resource&gt; res1&#123; <span class="keyword">new</span> Resource&#123;&#125; &#125;; <span class="comment">// Resource created here</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Resource&gt; res2&#123;&#125;; <span class="comment">// Start as nullptr</span></span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"res1 is "</span> &lt;&lt; (<span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(res1) ? <span class="string">"not null\n"</span> : <span class="string">"null\n"</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"res2 is "</span> &lt;&lt; (<span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(res2) ? <span class="string">"not null\n"</span> : <span class="string">"null\n"</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// res2 = res1; //无法编译: 因为std::unique_ptr 禁止复制赋值</span></span><br><span class="line">	res2 = <span class="built_in">std</span>::<span class="built_in">move</span>(res1); <span class="comment">// res2假定为 所有者，res1设置为null</span></span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Ownership transferred\n"</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"res1 is "</span> &lt;&lt; (<span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(res1) ? <span class="string">"not null\n"</span> : <span class="string">"null\n"</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"res2 is "</span> &lt;&lt; (<span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(res2) ? <span class="string">"not null\n"</span> : <span class="string">"null\n"</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// Resource 在res2超出作用域时被销毁</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Resource acquired</span><br><span class="line">res1 is not null</span><br><span class="line">res2 is null</span><br><span class="line">Ownership transferred</span><br><span class="line">res1 is null</span><br><span class="line">res2 is not null</span><br><span class="line">Resource destroyed</span><br></pre></td></tr></table></figure><p><strong>因为std::unique_ptr在设计时考虑到了移动语义，所以禁用了复制初始化和复制赋值。</strong></p><p><strong>如果要传输<code>std::unique_ptr</code>管理的内容，必须使用移动语义。</strong></p><blockquote><p>在上面的程序中，我们通过<code>std::move</code>(它将res1转换为r-value，这将触发一个 移动赋值，而不是一个复制赋值)来完成这个任务。</p></blockquote><h2 id="访问被管理的对象"><a href="#访问被管理的对象" class="headerlink" title="访问被管理的对象"></a>访问被管理的对象</h2><p><code>std::unique_ptr</code>有一个重载的<strong>操作符*</strong>和<strong>操作符-&gt;</strong>，<u>可以用来返回被管理的资源。</u></p><ul><li><strong>操作符*</strong>返回对托管资源的<strong>引用</strong>；</li><li><strong>操作符-&gt;</strong>返回一个<strong>指针</strong>。</li></ul><p>请记住，<code>std::unique_ptr</code>可能并不总是管理一个对象 —— <strong>这可能是因为它创建为空 (使用默认构造函数或传递nullptr作为参数)；也可能是因为它所管理的资源被移动到了另一个std::unique_ptr。</strong></p><p><strong>因此，在使用这两种操作符之前，我们应该检查std::unique_ptr是否确实有资源</strong>。</p><blockquote><p><strong><u>幸运的是，这很简单：<code>std::unique_ptr</code>有一个到bool的强制转换，如果<code>std::unique_ptr</code>正在管理一个资源，该转换将返回true。</u></strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // for std::unique_ptr</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">	~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> Resource &amp;res)</span><br><span class="line">	&#123;</span><br><span class="line">		out &lt;&lt; <span class="string">"I am a resource\n"</span>;</span><br><span class="line">		<span class="keyword">return</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Resource&gt; res&#123; <span class="keyword">new</span> Resource&#123;&#125; &#125;;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (res) <span class="comment">// 使用隐式强制转换为bool 以确保res包含资源</span></span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *res &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print the Resource that res is owning⭐⭐⭐</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Resource acquired</span><br><span class="line">I am a resource</span><br><span class="line">Resource destroyed</span><br></pre></td></tr></table></figure><blockquote><p>注意：上面例子中的：<code>std::cout &lt;&lt; *res &lt;&lt; &#39;\n&#39;;</code>这一句，实际上为：</p><p><code>std::operator&lt;&lt;(operator&lt;&lt;(std::cout, res.operator*()), &#39;\n&#39;);</code></p><p><strong>也就是说，这里的操作符* 实际上是返回的是 引用。</strong></p></blockquote><p>在上面的程序中，我们使用重载操作符*获取std::unique_ptr res拥有的资源对象，然后将其发送到std::cout进行打印。</p><h2 id="std-unique-ptr和数组"><a href="#std-unique-ptr和数组" class="headerlink" title="std::unique_ptr和数组"></a><code>std::unique_ptr</code>和数组</h2><p>与std::auto_ptr不同，<strong><code>std::unique_ptr</code>足够智能，可以知道是使用标量删除还是数组删除，因此std::unique_ptr可以用于标量对象和数组。</strong></p><blockquote><p>但是，<strong>std::array或std::vector(或std::string )几乎总是比使用固定数组、动态数组或c风格的字符串的std::unique_ptr更好的选择。</strong></p></blockquote><h1 id="std-make-unique"><a href="#std-make-unique" class="headerlink" title="std::make_unique"></a><code>std::make_unique</code></h1><p>c++ 14附带了一个名为<code>std::make_unique()</code>的附加函数。这个模板函数<strong>构造</strong>一个模板类型的<strong>对象</strong>，并用传入函数的参数对其进行初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // for std::unique_ptr and std::make_unique</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_numerator&#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> m_denominator&#123; <span class="number">1</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Fraction(<span class="keyword">int</span> numerator = <span class="number">0</span>, <span class="keyword">int</span> denominator = <span class="number">1</span>) :</span><br><span class="line">		m_numerator&#123; numerator &#125;, m_denominator&#123; denominator &#125;</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> Fraction &amp;f1)</span><br><span class="line">	&#123;</span><br><span class="line">		out &lt;&lt; f1.m_numerator &lt;&lt; <span class="string">"/"</span> &lt;&lt; f1.m_denominator;</span><br><span class="line">		<span class="keyword">return</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 用分子3和分母5创建一个动态分配的Fraction</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Fraction&gt; f1&#123; <span class="built_in">std</span>::make_unique&lt;Fraction&gt;(<span class="number">3</span>, <span class="number">5</span>) &#125;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *f1 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 创建一个长度为4的Fraction的动态分配数组</span></span><br><span class="line">	<span class="comment">// 在这里我们也可以使用自动类型推断来达到很好的效果</span></span><br><span class="line">	<span class="keyword">auto</span> f2&#123; <span class="built_in">std</span>::make_unique&lt;Fraction[]&gt;(<span class="number">4</span>) &#125;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f2[<span class="number">0</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3&#x2F;5</span><br><span class="line">0&#x2F;1</span><br></pre></td></tr></table></figure><p>使用std::make_unique()是可选的，但建议不要自己创建std::unique_ptr。这是因为使用std::make_unique的代码更简单，而且需要的输入也更少(与自动类型推断一起使用时)。此外，它还解决了一个<strong>异常安全问题</strong>，这个问题可能是由于c++没有指定函数参数的计算顺序而导致的。</p><blockquote><p><strong>使用std::make_unique()而不是创建std::unique_ptr并自己使用new</strong></p></blockquote><h2 id="更详细的看异常安全问题"><a href="#更详细的看异常安全问题" class="headerlink" title="更详细的看异常安全问题"></a>更详细的看异常安全问题</h2><p>对于那些想知道上面提到的“异常安全问题”是什么，这里是对这个问题的描述。</p><p>考虑这样一个表达:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">some_function(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> T), function_that_can_throw_exception());</span><br></pre></td></tr></table></figure><p>编译器在处理这个调用方面有很大的灵活性。它可以创建一个新的T，然后调用<code>function_that_can_throw_exception()</code>，然后创建<strong>std::unique_ptr</strong>来管理动态分配的T。<u>如果<code>function_that_can_throw_exception()</code>抛出异常，那么分配的T将不会被回收，因为执行回收的智能指针还没有创建。这导致了T被泄露。</u></p><p><strong>std::make_unique()</strong>不会遇到这个问题，<strong>因为对象T的创建和std::unique_ptr的创建都发生在std::make_unique()函数中，在这个函数中，执行顺序没有歧义。</strong></p><h1 id="从函数返回std-unique-ptr"><a href="#从函数返回std-unique-ptr" class="headerlink" title="从函数返回std::unique_ptr"></a>从函数返回<code>std::unique_ptr</code></h1><p><code>std::unique_ptr</code>可以安全地从一个函数返回值:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Resource&gt; <span class="title">createResource</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;Resource&gt;();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Resource&gt; ptr&#123; createResource() &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// do whatever</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，createResource()按值返回<code>std::unique_ptr</code>。</p><ul><li><p><strong>如果未将此值赋给任何值，则临时返回值将超出范围，资源将被清理。</strong></p></li><li><p>如果它被赋值 (如main()所示)，</p><ul><li>在c++ 14或更早的版本中，将使用move语义将资源从返回值转移到赋值的对象(在上面的示例ptr中)</li><li>而在c++ 17或更新版本中，将省略返回。</li></ul></li></ul><p><strong>这使得通过std::unique_ptr返回资源比返回原始指针安全得多!</strong></p><p><strong>通常，您不应该通过 指针 或 引用 返回std::unique_ptr(除非您有特定的强制理由)。</strong>,应该直接返回std::unique_ptr</p><h1 id="将std-unique-ptr传递给一个函数"><a href="#将std-unique-ptr传递给一个函数" class="headerlink" title="将std::unique_ptr传递给一个函数"></a>将<code>std::unique_ptr</code>传递给一个函数</h1><h2 id="获得传入参数的所有权"><a href="#获得传入参数的所有权" class="headerlink" title="获得传入参数的所有权"></a>获得传入参数的所有权</h2><p><strong>如果希望函数获得指针内容的所有权，请按<u>值</u>传递std::unique_ptr</strong>。注意，由于已经禁用了复制语义，因此需要使用<strong>std::move</strong>来实际传入变量（如果传入参数是左值时，需要）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // for std::unique_ptr</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">	~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> Resource &amp;res)</span><br><span class="line">	&#123;</span><br><span class="line">		out &lt;&lt; <span class="string">"I am a resource\n"</span>;</span><br><span class="line">		<span class="keyword">return</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">void takeOwnership(std::unique_ptr&lt;Resource&gt; res) ⭐</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (res)</span><br><span class="line">          <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *res &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125; <span class="comment">// the Resource is destroyed here</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ptr&#123; <span class="built_in">std</span>::make_unique&lt;Resource&gt;() &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//    takeOwnership(ptr); 这不起作用，需要使用移动语义⭐⭐</span></span><br><span class="line">    takeOwnership(<span class="built_in">std</span>::<span class="built_in">move</span>(ptr)); <span class="comment">// ok: use move semantics</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Ending program\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Resource acquired</span><br><span class="line">I am a resource</span><br><span class="line">Resource destroyed</span><br><span class="line">Ending program</span><br></pre></td></tr></table></figure><p><strong>注意</strong>，在这种情况下，Resource的所有权被转移到takeOwnership()，因此Resource在takeOwnership()的末尾而不是main()的末尾被销毁。</p><h2 id="不获得传入参数的所有权"><a href="#不获得传入参数的所有权" class="headerlink" title="不获得传入参数的所有权"></a>不获得传入参数的所有权</h2><p><strong>但是，在大多数情况下，您不希望函数取得资源的所有权</strong>。虽然可以通过<strong>引用传递</strong>std::unique_ptr(这将允许函数使用对象而不拥有该对象)，但是应该只在调用的函数可能更改或改变被管理的对象时才这样做。</p><p>相反，最好只传递资源本身(通过<strong>指针</strong>或<strong>引用</strong>传递，这取决于null是否为有效参数)。这允许函数不知道调用方是如何管理其资源的。<strong>要从std::unique_ptr获得原始资源指针，可以使用get()成员函数</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // for std::unique_ptr</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">	~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> Resource &amp;res)</span><br><span class="line">	&#123;</span><br><span class="line">		out &lt;&lt; <span class="string">"I am a resource\n"</span>;</span><br><span class="line">		<span class="keyword">return</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 该函数只使用该资源，因此我们将接受指向该资源的指针，而不是对整个std::unique_ptr&lt; resource &gt;的引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useResource</span><span class="params">(Resource *res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (res)</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *res &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> ptr&#123; <span class="built_in">std</span>::make_unique&lt;Resource&gt;() &#125;;</span><br><span class="line"> </span><br><span class="line">	useResource(ptr.<span class="built_in">get</span>()); <span class="comment">// 注意:这里使用get()获取指向资源的指针</span></span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Ending program\n"</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// The Resource is destroyed here</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Resource acquired</span><br><span class="line">I am a resource</span><br><span class="line">Ending program</span><br><span class="line">Resource destroyed</span><br></pre></td></tr></table></figure><h1 id="std-unique-ptr-和-类"><a href="#std-unique-ptr-和-类" class="headerlink" title="std::unique_ptr 和 类"></a>std::unique_ptr 和 类</h1><p>当然，您可以使用std::unique_ptr<strong>作为类</strong>的组合<strong>成员</strong>。这样，<strong>您就不必担心类析构函数会不会删除动态内存，因为std::unique_ptr将在类对象被销毁时自动销毁</strong>。</p><p>但是，请注意，如果您的类对象是动态分配的，那么对象本身就有可能没有被正确释放，在这种情况下，即使使用智能指针也无济于事。</p><h1 id="滥用std-unique-ptr"><a href="#滥用std-unique-ptr" class="headerlink" title="滥用std:: unique_ptr"></a>滥用std:: unique_ptr</h1><p>有两种容易误用<code>std::unique_ptr</code>的方法，这两种方法都很容易避免。</p><ul><li><p><strong>首先，不要让多个类管理相同的资源。</strong>例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Resource *res&#123; <span class="keyword">new</span> Resource() &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Resource&gt; res1&#123; res &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Resource&gt; res2&#123; res &#125;;</span><br></pre></td></tr></table></figure><p><strong>虽然这在语法上是合法的</strong>，但是最终的结果是res1和res2都将尝试删除资源，这将导致未定义的行为。</p></li><li><p>其次，<strong>不要</strong>在std::unique_ptr中<strong>手动删除资源</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Resource *res&#123; <span class="keyword">new</span> Resource() &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Resource&gt; res1&#123; res &#125;;</span><br><span class="line"><span class="keyword">delete</span> res;</span><br></pre></td></tr></table></figure><p>如果这样做，那么std::unique_ptr将尝试删除已经删除的资源，再次导致未定义的行为。</p></li></ul><p><strong>注意，std::make_unique()可以防止上述两种情况在无意中发生。</strong></p></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/323fcdb7.html">C&C++/std：：move</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月24日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：1.3k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：5分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/15-4-stdmove/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/15-4-stdmove/</a></p><hr><p>一旦您开始更经常地使用move语义，<strong>您就会开始发现需要调用move语义的情况，但是您必须使用的对象是l-values，而不是r-values</strong>。以下面的swap函数为例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">myswap</span>(<span class="title">T</span>&amp; <span class="title">a</span>, <span class="title">T</span>&amp; <span class="title">b</span>) </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">  T tmp &#123; a &#125;; <span class="comment">// invokes copy constructor</span></span><br><span class="line">  a = b; <span class="comment">// invokes copy assignment</span></span><br><span class="line">  b = tmp; <span class="comment">// invokes copy assignment</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> x&#123; <span class="string">"abc"</span> &#125;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> y&#123; <span class="string">"de"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x: "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"y: "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	myswap(x, y);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x: "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"y: "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入两个类型为T的对象(在本例中是std::string)，这个函数通过创建三个副本来交换它们的值。因此，这个程序打印:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x: abc</span><br><span class="line">y: de</span><br><span class="line">x: de</span><br><span class="line">y: abc</span><br></pre></td></tr></table></figure><p>正如我们上节课所示，复制的效率可能很低。这个版本的swap会复制3份。这会导致大量的字符串创建和销毁，这是缓慢的。</p><p>但是，这里没有必要进行复制。我们真正要做的是交换a和b的值，用3步就可以完成! <strong>因此，如果我们从复制语义切换到移动语义，我们可以使我们的代码更具有性能。</strong></p><blockquote><p>但是，<strong>这里的问题是，参数a和b是l-value引用，而不是r-value引用，所以我们没有办法调用移动构造函数和移动赋值运算符，来替换 复制构造函数和复制赋值</strong>。默认情况下，我们获得复制构造函数和复制赋值行为。我们该怎么办?</p></blockquote><h1 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h1><p><strong>在c++ 11中，<code>std::move</code>是一个标准的库函数，它的作用只有一个——将它的参数转换成r-value。</strong>我们可以向std::move传递一个l-value，它将返回一个r-value引用。<strong>std::move在头文件：<code>utility</code>中定义。</strong></p><p>下面是与上面相同的程序，但是使用了一个myswap()函数，<u>该函数使用std::move将我们的l-values转换成r-values，这样我们就可以调用移动语义</u>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt; // for std::move⭐</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">myswap</span>(<span class="title">T</span>&amp; <span class="title">a</span>, <span class="title">T</span>&amp; <span class="title">b</span>) </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">  T tmp &#123; <span class="built_in">std</span>::<span class="built_in">move</span>(a) &#125;; <span class="comment">// invokes move constructor⭐</span></span><br><span class="line">  a = <span class="built_in">std</span>::<span class="built_in">move</span>(b); <span class="comment">// invokes move assignment⭐</span></span><br><span class="line">  b = <span class="built_in">std</span>::<span class="built_in">move</span>(tmp); <span class="comment">// invokes move assignment⭐</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> x&#123; <span class="string">"abc"</span> &#125;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> y&#123; <span class="string">"de"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x: "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"y: "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	myswap(x, y);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x: "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"y: "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x: abc</span><br><span class="line">y: de</span><br><span class="line">x: de</span><br><span class="line">y: abc</span><br></pre></td></tr></table></figure><p>这样更有效率。<strong>初始化tmp时，我们使用std::move将l-value变量x转换为r-value，而不是复制x。由于参数是r-value，因此调用move语义，并将x移动到tmp中。</strong></p><blockquote><p>通过多次交换，变量x的值被移动到y, y的值也被移动到x。</p></blockquote><h1 id="在std-vector中使用std-move"><a href="#在std-vector中使用std-move" class="headerlink" title="在std::vector中使用std::move"></a>在s<code>td::vector</code>中使用<code>std::move</code></h1><p>我们还可以<strong>在填充容器的元素时使用std::move</strong>，例如使用 l-value 填充std::vector。</p><p>在接下来的程序中，我们首先使用复制语义向 向量 添加一个元素。然后使用移动语义向向量添加一个元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt; // for std::move</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; v;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"Knock"</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Copying str\n"</span>;</span><br><span class="line">	v.push_back(str); <span class="comment">// calls l-value version of push_back, which copies str into the array element</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"str: "</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"vector: "</span> &lt;&lt; v[<span class="number">0</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nMoving str\n"</span>;</span><br><span class="line"> </span><br><span class="line">	v.push_back(<span class="built_in">std</span>::<span class="built_in">move</span>(str)); <span class="comment">// calls r-value version of push_back, which moves str into the array element</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"str: "</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"vector:"</span> &lt;&lt; v[<span class="number">0</span>] &lt;&lt; <span class="string">' '</span> &lt;&lt; v[<span class="number">1</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Copying str</span><br><span class="line">str: Knock</span><br><span class="line"><span class="built_in">vector</span>: Knock</span><br><span class="line"></span><br><span class="line">Moving str</span><br><span class="line">str:  		<span class="comment">//⭐⭐⭐</span></span><br><span class="line"><span class="built_in">vector</span>: Knock Knock</span><br></pre></td></tr></table></figure><ul><li>在第一种情况下，我们向push_back()传递一个<strong>l-value</strong>，因此它使用<strong>复制语义</strong>向向量添加一个元素。<u>由于这个原因，str中的值被保留了。</u></li><li>在第二种情况下，我们向push_back()传递了一个<strong>r-value</strong> (实际上是一个通过std::move转换的l值)，因此它使用move语义向向量添加一个元素。这更有效，<strong>因为向量元素可以窃取字符串的值，而不必复制它。在本例中，str为空。</strong></li></ul><p><strong>注意，在使用移动语义后，被使用的对象（在本例为str）中的数据会被窃取给 使用移动语义的对象。所以，移动语句执行之后，被使用的对象的值将不复存在。</strong></p><h1 id="std-move在什么地方比较有用？"><a href="#std-move在什么地方比较有用？" class="headerlink" title="std::move在什么地方比较有用？"></a>std::move在什么地方比较有用？</h1><ul><li><p>在对元素数组进行排序时，<code>std::move</code>也很有用。许多排序算法(如选择排序和冒泡排序)都是通过交换元素对来实现的。在以前的课程中，我们不得不求助于复制语义来进行交换。现在我们可以使用移动语义，这是更有效的。</p></li><li><p>如果我们希望将一个智能指针管理的内容移动到另一个智能指针，它也很有用。</p></li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>当我们想把 l-value 当作 r-value 来调用 移动语义 而不是 复制语义 时，可以使用<code>std::move</code>。</p></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/68c36619.html">C&C++/移动构造函数和移动赋值</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月23日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：3.2k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：13分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/15-3-move-constructors-and-move-assignment/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/15-3-move-constructors-and-move-assignment/</a></p><hr><p>在这节课中，我们将深入了解c++ 11如何通过<strong>移动构造函数</strong>和<strong>移动赋值</strong>来解决这些问题。</p><h1 id="复制构造函数和复制赋值"><a href="#复制构造函数和复制赋值" class="headerlink" title="复制构造函数和复制赋值"></a>复制构造函数和复制赋值</h1><p><strong>复制构造函数</strong>用于通过复制同一个类的对象来初始化一个类。</p><p><strong>复制赋值</strong>用于将一个类复制到另一个现有类。</p><blockquote><p><strong>默认情况下，如果没有显式提供，c++将提供复制构造函数和复制赋值操作符。</strong></p><p>这些编译器提供的函数执行<strong>浅拷贝</strong>，这可能会给分配动态内存的类带来问题。</p></blockquote><p>因此，处理动态内存的类应该覆盖这些函数来执行<strong>深度复制</strong>。</p><p>让我们回到本章第一节课（<a href="https://www.yuque.com/longlongqin/pw9qpx/pn4iny）的Auto_ptr智能指针类的例子，让我们看看一个实现了复制构造函数和复制赋值运算符的版本，**它可以进行深度复制**，以及一个执行这些操作的示例程序" target="_blank" rel="noopener">https://www.yuque.com/longlongqin/pw9qpx/pn4iny）的Auto_ptr智能指针类的例子，让我们看看一个实现了复制构造函数和复制赋值运算符的版本，**它可以进行深度复制**，以及一个执行这些操作的示例程序</a>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Auto_ptr3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	T* m_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Auto_ptr3(T* ptr = <span class="literal">nullptr</span>)</span><br><span class="line">		:m_ptr(ptr)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	~Auto_ptr3()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> m_ptr;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Copy constructor</span></span><br><span class="line">	<span class="comment">// Do deep copy of a.m_ptr to m_ptr（深度复制）</span></span><br><span class="line">	Auto_ptr3(<span class="keyword">const</span> Auto_ptr3&amp; a)</span><br><span class="line">	&#123;</span><br><span class="line">		m_ptr = <span class="keyword">new</span> T;</span><br><span class="line">		*m_ptr = *a.m_ptr;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Copy assignment</span></span><br><span class="line">	<span class="comment">// Do deep copy of a.m_ptr to m_ptr（深度复制）</span></span><br><span class="line">	Auto_ptr3&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Auto_ptr3&amp; a)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Self-assignment detection</span></span><br><span class="line">		<span class="keyword">if</span> (&amp;a == <span class="keyword">this</span>)</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">// Release any resource we're holding</span></span><br><span class="line">		<span class="keyword">delete</span> m_ptr;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">// Copy the resource</span></span><br><span class="line">		m_ptr = <span class="keyword">new</span> T;</span><br><span class="line">		*m_ptr = *a.m_ptr;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *m_ptr; &#125;</span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_ptr; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isNull</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_ptr == <span class="literal">nullptr</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">	~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">Auto_ptr3&lt;Resource&gt; <span class="title">generateResource</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Auto_ptr3&lt;Resource&gt; <span class="title">res</span><span class="params">(<span class="keyword">new</span> Resource)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> res; <span class="comment">// this return value will invoke the copy constructor</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Auto_ptr3&lt;Resource&gt; mainres;</span><br><span class="line">	mainres = generateResource(); <span class="comment">// this assignment will invoke the copy assignment</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个程序中，我们使用一个名为<code>generateResource()</code>的函数来创建一个封装了资源的智能指针，然后将其传递回函数main()。函数main()然后将其赋值给一个现有的Auto_ptr3对象。</p><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Resource acquired</span><br><span class="line">Resource acquired</span><br><span class="line">Resource destroyed</span><br><span class="line">Resource acquired</span><br><span class="line">Resource destroyed</span><br><span class="line">Resource destroyed</span><br></pre></td></tr></table></figure><p><strong>对于这样一个简单的程序来说，需要创建和销毁大量的资源!这是怎么回事？</strong>让我们仔细看看。在这个程序中有6个关键步骤(每个打印消息一个):</p><ul><li><p>在generateResource()内部，使用动态分配的资源创建并初始化局部变量res，这将导致第一个“Resource acquired”。</p></li><li><p>Res通过值返回到main()。我们在这里通过值返回，因为res是一个局部变量——它不能通过地址或引用返回，因为当generateResource()结束时res将被销毁。因此res被拷贝创建到一个临时对象中。因为我们的复制构造函数做了深度复制，所以在这里分配了一个新的资源，这将导致第二个“Resource acquired”。</p></li><li><p>Res超出范围，破坏最初创建的资源，从而导致第一个“Resource destroyed”。</p></li><li><p>临时对象通过复制分配被分配给mainres。由于我们的复制赋值也是深度复制，所以会分配一个新的资源，从而导致另一个“Resource acquired”。</p></li><li><p>赋值表达式结束，临时对象超出表达式范围并被销毁，导致“Resource destroyed”。</p></li><li><p>在main()的末尾，mainres超出范围，并显示最终的“Resource destroyed”。</p></li></ul><p>因此，简而言之，因为我们调用<strong>复制构造函数</strong>一次来将构造res复制到一个临时对象，而调用<strong>复制赋值</strong>一次来将临时对象复制到mainres，我们最终总共分配和销毁了3个单独的对象。</p><p>效率很低，但至少它不会崩溃!</p><h1 id="移动构造函数和移动赋值"><a href="#移动构造函数和移动赋值" class="headerlink" title="移动构造函数和移动赋值"></a>移动构造函数和移动赋值</h1><p>但是，使用<strong>移动语义</strong>，我们可以做得更好。</p><p>c++ 11定义了两个新的函数来服务于移动语义：<strong>移动构造函数、移动赋值</strong></p><ul><li><p><strong>复制构造函数</strong>和<strong>复制赋值</strong>的目的是将一个对象复制到另一个对象；</p><blockquote><p>它的参数要求：<strong>const l-value reference parameter</strong>（const 的左值引用 作为形参）</p></blockquote></li><li><p><strong>移动构造函数</strong>和<strong>移动赋值</strong>的目标是将资源的所有权从一个对象转移到另一个对象(这比复制要便宜得多)。</p><blockquote><p>它的参数要求：<strong>non-const r-value reference parameters</strong>（非const 的右值引用 作为形参）</p></blockquote></li></ul><p>这里是与上面相同的Auto_ptr3类，使用移动构造函数和移动赋值 运算符。</p><blockquote><p>为了进行比较，我们在深度复制复制构造函数和复制赋值操作符中留了一个。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Auto_ptr4</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	T* m_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Auto_ptr4(T* ptr = <span class="literal">nullptr</span>)</span><br><span class="line">		:m_ptr(ptr)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	~Auto_ptr4()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> m_ptr;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Copy constructor</span></span><br><span class="line">	<span class="comment">// Do deep copy of a.m_ptr to m_ptr</span></span><br><span class="line">	Auto_ptr4(<span class="keyword">const</span> Auto_ptr4&amp; a)</span><br><span class="line">	&#123;</span><br><span class="line">		m_ptr = <span class="keyword">new</span> T;</span><br><span class="line">		*m_ptr = *a.m_ptr;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Move constructor⭐⭐⭐</span></span><br><span class="line">	<span class="comment">// Transfer ownership of a.m_ptr to m_ptr</span></span><br><span class="line">	Auto_ptr4(Auto_ptr4&amp;&amp; a)</span><br><span class="line">		: m_ptr(a.m_ptr)</span><br><span class="line">	&#123;</span><br><span class="line">		a.m_ptr = <span class="literal">nullptr</span>; <span class="comment">// we'll talk more about this line below</span></span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Copy assignment</span></span><br><span class="line">	<span class="comment">// Do deep copy of a.m_ptr to m_ptr</span></span><br><span class="line">	Auto_ptr4&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Auto_ptr4&amp; a)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Self-assignment detection</span></span><br><span class="line">		<span class="keyword">if</span> (&amp;a == <span class="keyword">this</span>)</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">// Release any resource we're holding</span></span><br><span class="line">		<span class="keyword">delete</span> m_ptr;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">// Copy the resource</span></span><br><span class="line">		m_ptr = <span class="keyword">new</span> T;</span><br><span class="line">		*m_ptr = *a.m_ptr;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Move assignment⭐⭐⭐</span></span><br><span class="line">	<span class="comment">// Transfer ownership of a.m_ptr to m_ptr</span></span><br><span class="line">	Auto_ptr4&amp; <span class="keyword">operator</span>=(Auto_ptr4&amp;&amp; a)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Self-assignment detection</span></span><br><span class="line">		<span class="keyword">if</span> (&amp;a == <span class="keyword">this</span>)</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">// Release any resource we're holding</span></span><br><span class="line">		<span class="keyword">delete</span> m_ptr;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">// Transfer ownership of a.m_ptr to m_ptr</span></span><br><span class="line">		m_ptr = a.m_ptr;</span><br><span class="line">		a.m_ptr = <span class="literal">nullptr</span>; <span class="comment">// we'll talk more about this line below</span></span><br><span class="line"> </span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *m_ptr; &#125;</span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_ptr; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isNull</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_ptr == <span class="literal">nullptr</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">	~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">Auto_ptr4&lt;Resource&gt; <span class="title">generateResource</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Auto_ptr4&lt;Resource&gt; <span class="title">res</span><span class="params">(<span class="keyword">new</span> Resource)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> res; <span class="comment">// this return value will invoke the move constructor</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Auto_ptr4&lt;Resource&gt; mainres;</span><br><span class="line">	mainres = generateResource(); <span class="comment">// this assignment will invoke the move assignment</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移动构造函数和移动赋值操作符很简单。我们只是移动(窃取)源对象的资源，而不是将源对象(a)深度复制到隐式对象中。这涉及到将源指针浅复制到隐式对象中，然后将源指针设置为null。</p><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Resource acquired</span><br><span class="line">Resource destroyed</span><br></pre></td></tr></table></figure><p>这就简洁很多了。</p><p>程序的流程和以前完全一样。但是，这个程序不是调用复制构造函数和复制赋值操作符，<strong>而是调用移动构造函数和移动赋值操作符。再看得深一点:</strong></p><ul><li><p>在generateResource()内部，使用动态分配的资源创建并初始化局部变量res，这将导致第一个“Resource acquired”。</p></li><li><p>Res通过值返回到main()。Res被构造成一个临时对象，将存储在Res中的动态创建的对象传递给临时对象。我们将在下面讨论为什么会发生这种情况。</p></li><li><p>Res超出了范围。因为res不再管理指针(它被移动到临时指针)，所以这里没有什么有趣的事情发生。</p></li><li><p>临时对象 被移动赋值给mainres。这将 动态创建的对象 存储到 临时对象mainres 中。</p></li><li><p>赋值表达式结束，临时对象超出表达式作用域并被销毁。但是，因为临时不再管理指针(它被移动到mainres)，所以这里也没有什么有趣的事情发生。</p></li><li><p>在main()的末尾，mainres超出范围，并显示最终的“Resource destroyed”。</p></li></ul><h1 id="移动语义的背后"><a href="#移动语义的背后" class="headerlink" title="移动语义的背后"></a>移动语义的背后</h1><p>现在您已经有了足够的上下文来理解<strong>移动语义</strong>背后的关键见解。</p><ul><li><p>如果我们构造一个对象或者做一个赋值，参数是<strong>l-value</strong>，我们唯一能做的就是*<em>复制 *</em>l-value。我们不能假定改变l-value是安全的，因为它可能在以后的程序中再次使用。如果我们有一个表达式“a = b”，我们就不会希望b会以任何方式改变。</p></li><li><p>然而，如果我们构造一个对象或者做一个赋值，其中参数是<strong>r-value</strong>，<u>那么我们知道r-value只是某种临时对象</u>。与其复制它(这可能很昂贵)，我们可以简单地将它的资源(这很便宜)转移到我们正在构造或分配的对象。这样做是安全的，因为这个临时的表达式将在表达式的最后被销毁，所以我们知道它将永远不会再被使用!</p></li></ul><p>c++ 11，通过r-value引用，使我们能够在参数是r-value还是l-value时提供不同的行为，使我们能够更聪明、更有效地决定我们的对象应该如何行为。</p><h1 id="移动函数应该始终保持两个对象处于良好定义的状态"><a href="#移动函数应该始终保持两个对象处于良好定义的状态" class="headerlink" title="移动函数应该始终保持两个对象处于良好定义的状态"></a>移动函数应该始终保持两个对象处于良好定义的状态</h1><p>在上面的例子中，移动构造函数 和 移动赋值函数 都将<code>a.m_ptr</code>设置为<code>nullptr</code>。这似乎无关紧要——毕竟，<strong>如果“a”是一个临时的r-value，如果参数“a”无论如何都将被销毁，为什么还要做“清除”呢?</strong></p><ul><li>答案很简单：<strong>当“a”超出范围时，将调用a的析构函数，<code>a.m_ptr</code>将被删除。</strong> <strong>如果在此时，<code>a.m_ptr</code>仍然指向与<code>m_ptr</code>相同的对象，然后m_ptr将保留为空悬指针。当包含m_ptr的对象最终被使用(或销毁)时，我们将得到未定义的行为。</strong></li></ul><h1 id="由“值”返回的l-value-会自动用“移动”而不是“复制”"><a href="#由“值”返回的l-value-会自动用“移动”而不是“复制”" class="headerlink" title="由“值”返回的l-value 会自动用“移动”而不是“复制”"></a>由“值”返回的l-value 会自动用“移动”而不是“复制”</h1><p>在上面Auto_ptr4示例的<code>generateResource()</code>函数中，<strong>当变量res由值返回时，它将被移动而不是复制，即使res是一个l-value。</strong></p><p>c++规范有一个特殊的规则，<strong>该规则说，从函数按值返回的自动对象可以移动，即使它们是l-value。</strong></p><blockquote><p>这是有意义的，因为res将在函数的末尾被销毁! 我们还不如窃取它的资源，而不是制造一个昂贵且不必要的副本。</p></blockquote><p>虽然编译器可以移动l-value返回值，但是在某些情况下，它甚至可以通过完全省略复制来做得更好(这避免了复制或移动)。在这种情况下，既不调用复制构造函数，也不调用移动构造函数。</p><h1 id="禁用复制"><a href="#禁用复制" class="headerlink" title="禁用复制"></a>禁用复制</h1><p>在上面的Auto_ptr4类中，我们将 复制构造函数 和 赋值运算符 留作比较之用。</p><p>但在支持<strong>移动</strong>的类中，有时需要删除 复制构造函数 和 复制赋值函数，以确保不进行复制。</p><blockquote><p>在Auto_ptr类的情况下，我们不想复制我们的模板对象T——因为它很昂贵，而且不管T是什么类，都可能不支持复制!</p></blockquote><p>这是Auto_ptr的一个版本，支持移动语义，但不支持复制语义:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Auto_ptr5</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	T* m_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Auto_ptr5(T* ptr = <span class="literal">nullptr</span>)</span><br><span class="line">		:m_ptr(ptr)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	~Auto_ptr5()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> m_ptr;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Copy constructor -- no copying allowed!⭐</span></span><br><span class="line">	Auto_ptr5(<span class="keyword">const</span> Auto_ptr5&amp; a) = <span class="keyword">delete</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Move constructor⭐⭐</span></span><br><span class="line">	<span class="comment">// Transfer ownership of a.m_ptr to m_ptr</span></span><br><span class="line">	Auto_ptr5(Auto_ptr5&amp;&amp; a)</span><br><span class="line">		: m_ptr(a.m_ptr)</span><br><span class="line">	&#123;</span><br><span class="line">		a.m_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Copy assignment -- no copying allowed!⭐</span></span><br><span class="line">	Auto_ptr5&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Auto_ptr5&amp; a) = <span class="keyword">delete</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Move assignment⭐⭐</span></span><br><span class="line">	<span class="comment">// Transfer ownership of a.m_ptr to m_ptr</span></span><br><span class="line">	Auto_ptr5&amp; <span class="keyword">operator</span>=(Auto_ptr5&amp;&amp; a)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Self-assignment detection</span></span><br><span class="line">		<span class="keyword">if</span> (&amp;a == <span class="keyword">this</span>)</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">// Release any resource we're holding</span></span><br><span class="line">		<span class="keyword">delete</span> m_ptr;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">// Transfer ownership of a.m_ptr to m_ptr</span></span><br><span class="line">		m_ptr = a.m_ptr;</span><br><span class="line">		a.m_ptr = <span class="literal">nullptr</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *m_ptr; &#125;</span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_ptr; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isNull</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_ptr == <span class="literal">nullptr</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果试图<strong>按值</strong>向函数传递一个 <strong>Auto_ptr5类型的l-value</strong>，编译器会报错：初始化复制构造函数参数所需的复制构造函数已被删除。</p><blockquote><p>这很好，因为我们可能应该通过const l-value引用传递Auto_ptr5 !</p></blockquote><p><strong>Auto_ptr5是(最后)一个好的智能指针类</strong>。事实上，标准库包含一个非常类似的类(您应该使用它)，名为<strong><code>std::unique_ptr</code></strong>。我们将在本章稍后讨论std::unique_ptr。</p><h2 id="测试-使用“复制”和“移动”之间的性能差别"><a href="#测试-使用“复制”和“移动”之间的性能差别" class="headerlink" title="测试 使用“复制”和“移动”之间的性能差别"></a>测试 使用“复制”和“移动”之间的性能差别</h2><p>让我们看一下另一个<u>使用动态内存</u>的类: 一个简单的动态模板化数组。该类包含一个<strong>深度复制复制构造函数</strong>和<strong>复制赋值操作符</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">DynamicArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T* m_array;</span><br><span class="line">	<span class="keyword">int</span> m_length;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	DynamicArray(<span class="keyword">int</span> length)</span><br><span class="line">		: m_array(<span class="keyword">new</span> T[length]), m_length(length)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	~DynamicArray()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] m_array;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Copy constructor(深度复制)</span></span><br><span class="line">	DynamicArray(<span class="keyword">const</span> DynamicArray &amp;arr)</span><br><span class="line">		: m_length(arr.m_length)</span><br><span class="line">	&#123;</span><br><span class="line">		m_array = <span class="keyword">new</span> T[m_length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_length; ++i)</span><br><span class="line">			m_array[i] = arr.m_array[i];</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Copy assignment（深度复制）</span></span><br><span class="line">	DynamicArray&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> DynamicArray &amp;arr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (&amp;arr == <span class="keyword">this</span>)</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">delete</span>[] m_array;</span><br><span class="line">		</span><br><span class="line">		m_length = arr.m_length;</span><br><span class="line">		m_array = <span class="keyword">new</span> T[m_length];</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_length; ++i)</span><br><span class="line">			m_array[i] = arr.m_array[i];</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_length; &#125;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) &#123; <span class="keyword">return</span> m_array[index]; &#125;</span><br><span class="line">	<span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_array[index]; &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以使用 <a href="https://www.learncpp.com/cpp-tutorial/8-16-timing-your-code/" target="_blank" rel="noopener">8.16 – Timing your code</a>中的函数，来测试：深度复制、移动语义 这两者实现的程序之间的性能的差别。</p><p>具体测试代码：详见<a href="https://www.learncpp.com/cpp-tutorial/15-3-move-constructors-and-move-assignment/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/15-3-move-constructors-and-move-assignment/</a> 中的“<strong>Another example</strong>”板块。</p><p>比较两个程序的运行时，0.0056 / 0.00825559 = 67.8%。移动版本几乎快了33% !</p></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/145edd42.html">C&C++/右值引用</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月22日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：1.9k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：7分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/15-2-rvalue-references/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/15-2-rvalue-references/</a></p><hr><p>回到第一章，我们提到了左值和右值，然后告诉你们不要太担心它们。在c++ 11之前，这是一个公平的建议。但是在c++ 11中理解移动语义需要重新审视这个主题。现在我们来做一下。</p><h1 id="左值与右值"><a href="#左值与右值" class="headerlink" title="左值与右值"></a>左值与右值</h1><p>尽管在它们的名字中有“value”这个词，<strong>l-values和r-values实际上并不是值的属性，而是表达式的属性。</strong></p><p>c++中的每个表达式都有两个属性:</p><ul><li><p><strong>类型</strong>(用于类型检查) 和 <strong>值类别</strong>(用于某些类型的语法检查，例如表达式的结果是否可以赋值)。</p><blockquote><p>在c++ 03和更早的版本中，l-值和r-值是仅有的两个可用的值类别。</p></blockquote></li></ul><p><strong>左值：</strong></p><p><strong>将l-value(也称为locator值)</strong>： 视为<strong>函数</strong>或<strong>对象</strong> (或计算结果 为函数或对象的<strong>表达式</strong>) 是最简单的。<strong>所有的左值都有指定的内存地址。</strong></p><p>当左值最初被定义时，它们被定义为“<strong>适合位于赋值表达式左侧的值</strong>”。</p><p>但是，后来，const关键字被添加到语言中，左值被分为两个子类别:</p><ul><li>可修改的左值(其值可被修改)；</li><li>不可修改的左值(其值不可被修改)，被const限定。</li></ul><p><strong>右值：</strong></p><p>把<strong>右值</strong>看作 <strong>“不是左值的所有东西”</strong> 是最简单的。</p><blockquote><p>这显然包括<strong>文字</strong>(例如<code>5</code>)、<strong>临时值</strong>(例如<code>x+1</code> ) 和<strong>匿名对象</strong>(例如 <code>Fraction(5,2)</code>)。</p></blockquote><p>右值通常针对它们的值进行计算，<strong>具有表达式作用域(</strong>在它们所在的表达式结束时死亡)，<strong>并且不能被赋值</strong>。</p><blockquote><p>这个<strong>不能被赋值规则</strong>是有意义的，因为赋值会对对象产生副作用。</p><ul><li>因为右值有表达式作用域，如果我们将一个值赋值给右值，这个右值会在 我们在下一个表达式中使用它时 <strong>超出作用域</strong>。</li><li>或者，<strong>我们必须在表达式中多次使用具有副作用的变量</strong>(到目前为止，您应该知道导致未定义行为的原因!)</li></ul></blockquote><h2 id="3个新的值类别"><a href="#3个新的值类别" class="headerlink" title="3个新的值类别"></a>3个新的值类别</h2><p>为了支持移动语义，c++ 11引入了3个新的值类别:</p><ul><li>pr-values；</li><li>x-values；</li><li>gl-values；</li></ul><blockquote><p>如果您感兴趣， <a href="https://en.cppreference.com/w/cpp/language/value_category" target="_blank" rel="noopener">cppreference.com</a> 提供了一个广泛的表达式列表，这些表达式适用于各种值类别，以及关于它们的更多详细信息。</p></blockquote><hr><h2 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h2><p>在c++ 11之前，只有一种类型的引用存在于c++中，因此它被称为“引用”。然而，<strong>在c++ 11中，它有时被称为l-value引用</strong>。<strong>左值引用只能用 可修改的左值 初始化。</strong></p><table><thead><tr><th align="left">L-value reference</th><th align="left">Can be initialized with</th><th align="left">Can modify</th></tr></thead><tbody><tr><td align="left">Modifiable l-values</td><td align="left">Yes</td><td align="left">Yes</td></tr><tr><td align="left">Non-modifiable l-values</td><td align="left">No</td><td align="left">No</td></tr><tr><td align="left">R-values</td><td align="left">No</td><td align="left">No</td></tr></tbody></table><p><strong>被const限定的L-value对象</strong> 引用 <strong>可以用 l-values和r-values 进行初始化</strong>。<u>但是，这些值不能修改</u>。</p><table><thead><tr><th align="left">L-value reference to const</th><th align="left">Can be initialized with</th><th align="left">Can modify</th></tr></thead><tbody><tr><td align="left">Modifiable l-values</td><td align="left">Yes</td><td align="left">No</td></tr><tr><td align="left">Non-modifiable l-values</td><td align="left">Yes</td><td align="left">No</td></tr><tr><td align="left">R-values</td><td align="left">Yes</td><td align="left">No</td></tr></tbody></table><p><strong>对const对象的L-value引用特别有用，因为它们允许我们将任何类型的参数</strong>(L-value或r-value)<strong>传递到函数中，而不需要复制参数。</strong></p><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p><strong>c++ 11添加了一种称为 r-value引用 的新引用类型。</strong></p><p>r-value引用 <strong>是一个被设计为只能使用 r-value 来初始化的引用。</strong></p><blockquote><p>左值引用 的定义使用<strong>一个</strong><code>&amp;</code>符号；</p><p>右值引用 的定义使用<strong>两个</strong><code>&amp;</code>符号；</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x&#123;<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> &amp;lref&#123;x&#125;; <span class="comment">//左值引用使用 左值x 来初始化</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rref&#123;<span class="number">5</span>&#125;; <span class="comment">//右值引用使用 右值5 来初始化</span></span><br></pre></td></tr></table></figure><p><strong>右值引用 不能使用 左值来初始化。</strong></p><table><thead><tr><th align="left">R-value reference</th><th align="left">Can be initialized with</th><th align="left">Can modify</th></tr></thead><tbody><tr><td align="left">Modifiable l-values</td><td align="left">No</td><td align="left">No</td></tr><tr><td align="left">Non-modifiable l-values</td><td align="left">No</td><td align="left">No</td></tr><tr><td align="left">R-values</td><td align="left">Yes</td><td align="left">Yes</td></tr></tbody></table><table><thead><tr><th align="left">R-value reference to const</th><th align="left">Can be initialized with</th><th align="left">Can modify</th></tr></thead><tbody><tr><td align="left">Modifiable l-values</td><td align="left">No</td><td align="left">No</td></tr><tr><td align="left">Non-modifiable l-values</td><td align="left">No</td><td align="left">No</td></tr><tr><td align="left">R-values</td><td align="left">Yes</td><td align="left">No</td></tr></tbody></table><p><strong>R-value引用有两个有用的属性。</strong></p><ul><li>首先，r-value引用 将 初始化它们的对象 的生命周期延长 ( 对const对象的l-value引用也可以做到这一点)。</li><li>非常量的右值引用 允许您修改它的右值!</li></ul><p>看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_numerator;</span><br><span class="line">	<span class="keyword">int</span> m_denominator;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Fraction(<span class="keyword">int</span> numerator = <span class="number">0</span>, <span class="keyword">int</span> denominator = <span class="number">1</span>) :</span><br><span class="line">		m_numerator&#123; numerator &#125;, m_denominator&#123; denominator &#125;</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> Fraction &amp;f1)</span><br><span class="line">	&#123;</span><br><span class="line">		out &lt;&lt; f1.m_numerator &lt;&lt; <span class="string">'/'</span> &lt;&lt; f1.m_denominator;</span><br><span class="line">		<span class="keyword">return</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> &amp;&amp;rref&#123; Fraction&#123; <span class="number">3</span>, <span class="number">5</span> &#125; &#125;; <span class="comment">// r-value 引用一个 临时的Fraction</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// f1 的operator&lt;&lt; 绑定到临时的Fraction，不创建副本。</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rref &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// rref (and the temporary Fraction) goes out of scope here</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3&#x2F;5</span><br></pre></td></tr></table></figure><p><u>作为一个匿名对象的<code>Fraction(3, 5)</code> 通常会在定义它的表达式结束时超出范围。</u>但是，<strong>由于我们正在用它初始化一个r-value引用，它的生命周期被延长到块的末尾。</strong>然后我们可以使用r值引用来打印Fraction的值。</p><p>现在让我们看一个不那么直观的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> &amp;&amp;rref&#123; <span class="number">5</span> &#125;; <span class="comment">// 因为我们正在用文字常量初始化一个r-value引用，所以这里创建了一个值为5的临时引用</span></span><br><span class="line">    rref = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rref &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>虽然用一个文字值初始化一个r-value引用然后能够改变那个值看起来很奇怪，但是当用一个文字值初始化一个r-value引用时，一个文字值得临时值 将被构建，所以这个引用引用的是一个临时对象，而不是一个文字值。</p><blockquote><p>在上述两种方式中，右值引用都不常用。</p></blockquote><h1 id="右值引用作为函数参数"><a href="#右值引用作为函数参数" class="headerlink" title="右值引用作为函数参数"></a>右值引用作为函数参数</h1><p>R-value引用通常用作函数参数。当您希望对l-value和r-value参数有不同的行为时，这对于函数重载非常有用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;lref)</span> <span class="comment">// l-value arguments will select this function</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"l-value reference to const\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> &amp;&amp;rref)</span> <span class="comment">// r-value arguments will select this function</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"r-value reference\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x&#123; <span class="number">5</span> &#125;;</span><br><span class="line">	fun(x); <span class="comment">// l-value argument calls l-value version of function</span></span><br><span class="line">	fun(<span class="number">5</span>); <span class="comment">// r-value argument calls r-value version of function</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将打印*/</span></span><br><span class="line">l-value reference to <span class="keyword">const</span></span><br><span class="line">r-value reference</span><br></pre></td></tr></table></figure><p>你为什么要这么做?我们将在下一课中更详细地讨论这个问题。<strong>不用说，它是移动语义的重要组成部分。</strong></p><p>注意一个有趣的东西：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;ref&#123;<span class="number">4</span>&#125;;</span><br><span class="line">fun(ref);</span><br></pre></td></tr></table></figure><p>这实际会调用函数的<strong>l-value版本</strong>! 虽然虽然变量ref的类型是 r-value引用一个字面常量整数，<strong>但它实际上是一个l-value本身(所有命名变量都是这样)。</strong></p><p>造成这种混淆的原因是在两个不同的上下文中使用了“右值”这个词。我们可以这样想：</p><ul><li><p><strong>被命名的对象 是 左值</strong>；<strong>匿名对象 是 右值</strong>。</p></li><li><p>无论是 命名对象 还是 匿名对象的<u>类型</u> 与它本身是 左值还是右值 无关。</p></li></ul><p><u>所以，上面的<code>ref</code>被命名了（名字就是ref），所以 对象ref 是一个左值。</u>也就是说：它是一个 右值引用 的被命名的对象。</p><h1 id="返回一个右值引用"><a href="#返回一个右值引用" class="headerlink" title="返回一个右值引用"></a>返回一个右值引用</h1><p><strong>您几乎不应该返回一个r-value引用，同理，您几乎不应该返回一个l-value引用</strong>。<strong>在大多数情况下，当被引用的对象在函数结束时超出作用域时，您将返回一个挂起的引用</strong>。</p></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/cace6777.html">C&C++/智能指针与移动语义</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月21日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：2.9k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：11分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/15-1-intro-to-smart-pointers-move-semantics/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/15-1-intro-to-smart-pointers-move-semantics/</a></p><hr><p>考虑一个函数，我们动态分配一个值:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Resource *ptr = <span class="keyword">new</span> Resource; <span class="comment">// Resource是一个结构体或者类</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管上面的代码看起来相当简单，但是很容易忘记释放ptr。<strong>即使您记得在函数结束时删除ptr，如果函数提前退出，也有许多方法可以不删除ptr</strong>。</p><ul><li><p>通过提前返回:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Resource *ptr = <span class="keyword">new</span> Resource;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter an integer: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 函数提前返回，ptr不会被删除!</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// do stuff with ptr here</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过抛出异常:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Resource *ptr = <span class="keyword">new</span> Resource;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter an integer: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">0</span>; <span class="comment">// 函数提前返回，ptr不会被删除!</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// do stuff with ptr here</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在上述两个程序中，执行早期的return或throw语句，导致函数终止而不删除变量ptr。因此，为变量ptr分配的内存现在会泄漏(并且在每次调用此函数并提前返回时将再次泄漏)。</p><p>本质上<strong>，这类问题的发生是因为指针变量本身没有内在的机制来清除。</strong></p><h1 id="智能指针类的拯救"><a href="#智能指针类的拯救" class="headerlink" title="智能指针类的拯救?"></a>智能指针类的拯救?</h1><p><strong>类最好的一点是，它们包含析构函数，当类的对象超出作用域时，析构函数会自动执行。</strong></p><p>因此，如果在构造函数中分配(或获取)内存，可以在析构函数中释放内存，并确保在销毁类对象时释放内存(不管它是否超出作用域、是否被显式删除等等)。</p><p>这是我们在 <a href="https://www.learncpp.com/cpp-tutorial/8-7-destructors/" target="_blank" rel="noopener">8.7 – Destructors</a>中讨论的RAII编程范例的核心。</p><p>那么我们可以使用一个类来帮助我们管理和清理指针吗?我们可以!</p><p>考虑这样一个类，它的唯一工作就是持有并“拥有”传递给它的指针，然后在类对象超出作用域时释放该指针。<strong>只要该类的对象仅作为局部变量创建，我们就可以保证该类将适当地超出作用域(不管我们的函数何时或如何终止)，并且所拥有的指针将被销毁。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Auto_ptr1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	T* m_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// Pass in a pointer to "own" via the constructor</span></span><br><span class="line">	Auto_ptr1(T* ptr=<span class="literal">nullptr</span>)</span><br><span class="line">		:m_ptr(ptr)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// The destructor will make sure it gets deallocated</span></span><br><span class="line">	~Auto_ptr1()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> m_ptr;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Overload dereference and operator-&gt; so we can use Auto_ptr1 like m_ptr.</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *m_ptr; &#125;</span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_ptr; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// A sample class to prove the above works</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">    ~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;<span class="function">Auto_ptr1&lt;Resource&gt; <span class="title">res</span><span class="params">(<span class="keyword">new</span> Resource)</span></span>; &#125; <span class="comment">// 注意这里的内存分配</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// ... 但不需要显式删除</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 还要注意，角括号中的资源不需要 * 符号，因为它是由模板提供的</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// res超出了这里的范围，并破坏了为我们分配的资源</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Resource acquired</span><br><span class="line">Resource destroyed</span><br></pre></td></tr></table></figure><p>考虑一下这个程序和类是如何工作的。</p><ul><li><p>首先，我们动态创建一个 Resource，并将其作为参数传递给模板化的Auto_ptr1类。从这一点开始，我们的Auto_ptr1变量res拥有这个Resource对象。（Auto_ptr1与m_ptr有一个复合关系。）</p></li><li><p>因为res被声明为一个局部变量，并且具有块作用域，所以当块结束时，它将超出作用域，并被销毁(不用担心忘记释放它)。</p></li><li><p>因为它是一个类，当它被销毁时，Auto_ptr1析构函数将被调用。这个析构函数将确保它所持有的资源指针被删除!</p></li><li><p>只要Auto_ptr1被定义为一个局部变量(具有自动持续时间，因此类名的“Auto”部分)，无论函数如何终止(即使它提前终止)，资源都将保证在声明它的块的末尾被销毁。</p></li></ul><p>这样的<strong>类</strong>称为<strong>智能指针</strong>。</p><p><strong>智能指针</strong>是一个复合类，用于管理动态分配的内存，并确保在智能指针对象超出作用域时删除内存。(与此相关的是，内置指针有时被称为<strong>“哑指针”</strong>，因为它们自己不能清理)。</p><p>现在让我们回到上面的someFunction()例子，并展示一个智能指针类如何解决我们的挑战:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Auto_ptr1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	T* m_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// Pass in a pointer to "own" via the constructor</span></span><br><span class="line">	Auto_ptr1(T* ptr=<span class="literal">nullptr</span>)</span><br><span class="line">		:m_ptr(ptr)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// The destructor will make sure it gets deallocated</span></span><br><span class="line">	~Auto_ptr1()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> m_ptr;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Overload dereference and operator-&gt; so we can use Auto_ptr1 like m_ptr.</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *m_ptr; &#125;</span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_ptr; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// A sample class to prove the above works</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">    ~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hi!\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Auto_ptr1&lt;Resource&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> Resource)</span></span>; <span class="comment">// ptr now owns the Resource</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter an integer: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// the function returns early</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// do stuff with ptr here</span></span><br><span class="line">    ptr-&gt;sayHi();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    someFunction();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用户输入一个非零整数，上面的程序将打印:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Resource acquired</span><br><span class="line">Enter an integer: 1</span><br><span class="line">Hi</span><br><span class="line">Resource destroyed</span><br></pre></td></tr></table></figure><p>如果用户输入0，以上程序将提前终止，打印:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Resource acquired</span><br><span class="line">Enter an integer: <span class="number">0</span></span><br><span class="line">Resource destroyed</span><br></pre></td></tr></table></figure><p>注意，即使在用户输入0并且函数提前终止的情况下，资源仍然被正确释放。</p><p><strong>因为ptr变量是一个局部变量，所以当函数终止时ptr将被销毁(不管它如何终止)。因为Auto_ptr1析构函数将清理资源，所以我们确信资源将被正确清理。</strong></p><h2 id="一个关键的缺陷"><a href="#一个关键的缺陷" class="headerlink" title="一个关键的缺陷"></a>一个关键的缺陷</h2><p>Auto_ptr1类有一个严重的缺陷，隐藏在一些自动生成的代码后面。在进一步阅读之前，看看您是否能够识别它是什么。我们会等待……</p><p>Rather than tell you, we’ll show you. Consider the following program:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Same as above</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Auto_ptr1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	T* m_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Auto_ptr1(T* ptr=<span class="literal">nullptr</span>)</span><br><span class="line">		:m_ptr(ptr)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	~Auto_ptr1()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> m_ptr;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *m_ptr; &#125;</span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_ptr; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">	~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Auto_ptr1&lt;Resource&gt; <span class="title">res1</span><span class="params">(<span class="keyword">new</span> Resource)</span></span>;</span><br><span class="line">	<span class="function">Auto_ptr1&lt;Resource&gt; <span class="title">res2</span><span class="params">(res1)</span></span>; <span class="comment">// 或者，不初始化res2，然后赋值res2 = res1;</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序打印:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Resource acquired</span><br><span class="line">Resource destroyed</span><br><span class="line">Resource destroyed</span><br></pre></td></tr></table></figure><p>您的程序很可能(但不一定)会在此时崩溃。现在看到问题了吗?</p><ul><li><strong>因为我们没有提供复制构造函数或赋值运算符，c++为我们提供了一个。</strong><u>它提供的函数只做浅拷贝</u>。因此，当我们用res1初始化res2时，Auto_ptr1变量都指向相同的资源。当res2超出范围时，它会删除资源，留下一个悬空指针给res1。当res1删除它的(已删除的)资源时，崩溃!</li></ul><h2 id="使用移动语句-Move-semantics-解决"><a href="#使用移动语句-Move-semantics-解决" class="headerlink" title="使用移动语句(Move semantics)解决"></a>使用移动语句(Move semantics)解决</h2><p><strong>如果不让我们的复制构造函数和赋值操作符复制指针(“复制语义”)，<u>而是将指针的所有权从源对象转移/移动到目标对象会怎么样</u>?</strong> 这是move语义背后的核心思想。</p><blockquote><p><strong>移动语义</strong> <strong>意味着该类将转移对象的所有权，而不是复制。</strong></p></blockquote><p>让我们更新我们的Auto_ptr1类，以展示如何做到这一点:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Auto_ptr2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	T* m_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Auto_ptr2(T* ptr=<span class="literal">nullptr</span>)</span><br><span class="line">		:m_ptr(ptr)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	~Auto_ptr2()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> m_ptr;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 由移动语义 实现的复制构造函数</span></span><br><span class="line">	Auto_ptr2(Auto_ptr2&amp; a) <span class="comment">// note: not const</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_ptr = a.m_ptr; <span class="comment">// 将哑指针从源对象转移到本地对象</span></span><br><span class="line">		a.m_ptr = <span class="literal">nullptr</span>; <span class="comment">// 确保该指针不再拥有源对象</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 实现移动语义的赋值运算符</span></span><br><span class="line">	Auto_ptr2&amp; <span class="keyword">operator</span>=(Auto_ptr2&amp; a) <span class="comment">// note: not const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (&amp;a == <span class="keyword">this</span>)</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">delete</span> m_ptr; <span class="comment">// 确保我们首先释放目标已经持有的指针</span></span><br><span class="line">		m_ptr = a.m_ptr; <span class="comment">// 然后将哑指针从源对象转移到本地对象</span></span><br><span class="line">		a.m_ptr = <span class="literal">nullptr</span>; <span class="comment">// 确保该指针不再拥有源对象</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *m_ptr; &#125;</span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_ptr; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isNull</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_ptr == <span class="literal">nullptr</span>;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">	~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Auto_ptr2&lt;Resource&gt; <span class="title">res1</span><span class="params">(<span class="keyword">new</span> Resource)</span></span>;</span><br><span class="line">	Auto_ptr2&lt;Resource&gt; res2; <span class="comment">// Start as nullptr</span></span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"res1 is "</span> &lt;&lt; (res1.isNull() ? <span class="string">"null\n"</span> : <span class="string">"not null\n"</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"res2 is "</span> &lt;&lt; (res2.isNull() ? <span class="string">"null\n"</span> : <span class="string">"not null\n"</span>);</span><br><span class="line"> </span><br><span class="line">	res2 = res1; <span class="comment">// res2 assumes ownership, res1 is set to null</span></span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Ownership transferred\n"</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"res1 is "</span> &lt;&lt; (res1.isNull() ? <span class="string">"null\n"</span> : <span class="string">"not null\n"</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"res2 is "</span> &lt;&lt; (res2.isNull() ? <span class="string">"null\n"</span> : <span class="string">"not null\n"</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Resource acquired</span><br><span class="line">res1 is not null</span><br><span class="line">res2 is null</span><br><span class="line">Ownership transferred</span><br><span class="line">res1 is null</span><br><span class="line">res2 is not null</span><br><span class="line">Resource destroyed</span><br></pre></td></tr></table></figure><p><strong>注意，我们的重载操作符<code>=</code>将m_ptr的所有权从res1赋予给了res2!</strong> <strong>因此，我们不会得到指针的副本，所有东西都会被清理干净。</strong></p><h1 id="（智能指针的）std-auto-ptr及为什么要避免使用它"><a href="#（智能指针的）std-auto-ptr及为什么要避免使用它" class="headerlink" title="（智能指针的）std::auto_ptr及为什么要避免使用它"></a>（智能指针的）<code>std::auto_ptr</code>及为什么要避免使用它</h1><p>现在是讨论<code>std::auto_ptr</code>的合适时机。</p><p><strong><code>std::auto_ptr</code>是在c++ 98中引入的，它是c++对标准化智能指针的第一次尝试。<code>std::auto_ptr</code>选择 像Auto_ptr2类 一样实现move语义。</strong></p><p><u>但是，<code>std::auto_ptr</code>(以及我们的Auto_ptr2类)有很多问题，使得使用它很危险。</u></p><ul><li><p>首先，由于<code>std::auto_ptr</code>通过<strong>复制构造函数</strong>和<strong>赋值操作符(=)</strong>实现了<strong>移动语义</strong>，因此<u>按值</u>向函数传递<code>std::auto_ptr</code>将导致您的资源被移动到函数参数处 (并在函数参数超出作用域时在函数末尾销毁)。然后，当您从调用方访问auto_ptr参数时(没有意识到它已被传输和删除)，您突然取消了对空指针的引用。崩溃!</p></li><li><p>其次，<code>std::auto_ptr</code>总是使用非数组delete删除其内容。这意味着auto_ptr不能正确地处理动态分配的数组，<u>因为它使用了错误的重新分配类型</u>。更糟糕的是，它不能阻止您向它传递一个动态数组，然后它会错误地管理这个数组，从而导致内存泄漏。</p></li><li><p>最后，auto_ptr不能很好地处理标准库中的许多其他类，包括大多数容器和算法。<strong>这是因为这些标准库类假设当它们复制一个项时，它实际上是复制 而不是移动。</strong></p></li></ul><p>由于上述缺点，<strong><code>std::auto_ptr</code>在c++ 11中已经被弃用</strong>，不应该使用。事实上，<strong><code>std::auto_ptr</code>将作为c++ 17的一部分从标准库中完全删除!</strong></p><p>规则:<code>std::auto_ptr</code>是不推荐的，不应该使用。<strong>(推荐使用<code>std::unique_ptr</code>或<code>std::shared_ptr</code>)..</strong></p><h1 id="Moving-forward"><a href="#Moving-forward" class="headerlink" title="Moving forward"></a>Moving forward</h1><p>auto_ptr的设计的核心问题是，<strong>在c++ 11之前，c++语言根本没有机制来区分“复制语义”和“移动语义”。</strong>覆盖复制语义 来实现移动语义 会导致奇怪的边缘情况和意外的错误。例如，您可以编写res1 = res2，却不知道res2是否会被更改!</p><p>因此，<strong>在c++ 11中，“移动”的概念被正式定义，“移动语义”被添加到语言中，以正确区分复制和移动。</strong>既然我们已经为移动语义的用处做好了准备，我们将在本章的其余部分探索移动语义的主题。我们还将使用移动语义修复Auto_ptr2类。</p><p>在c++ 11中，<code>std::auto_ptr</code>已经被一堆其他类型的 “移动感知”智能指针 所取代：</p><ul><li><code>std::unique_ptr</code>,</li><li><code>std::weak_ptr</code>，</li><li>以及<code>std::shared_ptr</code>。</li></ul></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/263cd357.html">C&C++/异常的缺点和危险</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月21日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：1.2k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：4分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/148-exception-dangers-and-downsides/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/148-exception-dangers-and-downsides/</a></p><hr><p>与几乎所有有利因素一样，例外也有一些潜在的不利因素。本文并不是全面的，只是指出在使用异常(或决定是否使用异常)时应该考虑的一些主要问题。</p><h1 id="清理资源"><a href="#清理资源" class="headerlink" title="清理资源"></a>清理资源</h1><p>新程序员在使用异常时遇到的最大问题之一是当异常发生时清理资源的问题。考虑下面的例子:</p><ol><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    openFile(filename);</span><br><span class="line">    writeFile(filename, data);</span><br><span class="line">    closeFile(filename);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (FileException &amp;exception)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to write to file: "</span> &lt;&lt; exception.what() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果WriteFile()失败并抛出一个FileException，会发生什么情况?</p><p>此时，我们已经打开了文件，现在控制流跳转到FileException处理程序，打印错误并退出。注意，该文件从未关闭过!这个例子应该改写如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    openFile(filename);</span><br><span class="line">    writeFile(filename, data);</span><br><span class="line">    closeFile(filename);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (FileException &amp;exception)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Make sure file is closed</span></span><br><span class="line">    closeFile(filename);</span><br><span class="line">    <span class="comment">// Then write error</span></span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to write to file: "</span> &lt;&lt; exception.what() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li></li></ol><p><strong>在处理动态分配的内存时</strong>，这种错误通常以另一种形式出现:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    Person *john &#123; <span class="keyword">new</span> Person(<span class="string">"John"</span>, <span class="number">18</span>, PERSON_MALE) &#125;;</span><br><span class="line">    processPerson(john);</span><br><span class="line">    <span class="keyword">delete</span> john;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (PersonException &amp;exception)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span>&lt;&lt; <span class="string">"Failed to process person: "</span> &lt;&lt; exception.what() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果processPerson()抛出异常，控制流将跳转到catch处理程序。结果，john再也没有被释放了!</p><p>这个示例比前一个稍微复杂一些——因为john是try块的本地对象，所以当try块退出时，它就超出了作用域。</p><blockquote><p>这意味着异常处理程序根本不能访问john(它已经被销毁了)，所以它无法释放内存。</p></blockquote><p>然而，有两种相对简单的方法来解决这个问题。</p><ul><li><p>首先，<strong>在try块外部声明john</strong>，这样当try块退出时，它就不会超出作用域:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Person *john = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    john &#123; <span class="keyword">new</span> Person(<span class="string">"John"</span>, <span class="number">18</span>, PERSON_MALE) &#125;;</span><br><span class="line">    processPerson(john);</span><br><span class="line">    <span class="keyword">delete</span> john;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (PersonException &amp;exception)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> john;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to process person: "</span> &lt;&lt; exception.what() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为john声明在try块之外，所以它可以在try块和catch处理程序中访问。这意味着catch处理程序可以正确地进行清理。</p></li><li><p>第二种方法是使用<strong>类的局部变量，该变量知道在超出作用域时如何清除自身</strong>(通常称为“<strong>智能指针</strong>”)。</p><blockquote><p>标准库提供了一个名为<strong><code>std::unique_ptr</code></strong>的类，可用于此目的。</p><p><strong><code>std::unique_ptr</code>是一个保存指针的模板类，当指针超出作用域时释放它。</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // for std::unique_ptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    Person *john &#123; <span class="keyword">new</span> Person(<span class="string">"John"</span>, <span class="number">18</span>, PERSON_MALE) &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Person&gt; upJohn &#123;john&#125;;  <span class="comment">// upJohn 现在拥有 john</span></span><br><span class="line">    ProcessPerson(john);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当upJohn超出范围时，它将删除john</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (PersonException &amp;exception)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to process person: "</span> &lt;&lt; exception.what() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="异常和析构函数"><a href="#异常和析构函数" class="headerlink" title="异常和析构函数"></a>异常和析构函数</h1><p>与构造函数不同，<strong>在构造函数中抛出异常是指示对象创建未成功的一种有用方法</strong>，<strong>但是异常不应该在析构函数中抛出。</strong></p><p>当栈展开过程中从析构函数引发异常时，会发生此问题。如果发生这种情况，编译器就会处于这样一种情况: <u>它不知道是继续 栈展开过程 还是 处理新的异常</u>。——最终的结果是您的程序将立即终止。</p><p><u>因此，最好的做法就是完全避免在析构函数中使用异常。而是将消息写入日志文件。</u></p><h1 id="性能方面"><a href="#性能方面" class="headerlink" title="性能方面"></a>性能方面</h1><p>异常情况确实会带来小小的性能代价<strong>。它们会增加可执行文件的大小，而且由于必须执行额外的检查，它们还可能导致运行速度变慢。</strong> <strong>然而，异常的主要性能损失是在实际抛出异常时发生的。在这种情况下，必须释放栈并找到适当的异常处理程序，这是一个相对昂贵的操作。</strong></p><p>需要注意的是，一些现代计算机架构支持一种称为零成本异常的异常模型。零成本异常(如果受支持)在非错误情况下没有额外的运行时成本(这是我们最关心的性能情况)。然而，在发现异常的情况下，它们会招致更大的性能消耗。</p><h1 id="什么情况下使用异常？"><a href="#什么情况下使用异常？" class="headerlink" title="什么情况下使用异常？"></a>什么情况下使用异常？</h1><p>当下列各项都为真时，最好使用异常处理:</p><ul><li>正在处理的错误可能只会偶尔发生。</li><li>严重的错误，并且执行无法继续。</li><li>错误不能在它发生的地方处理。</li><li>没有一种好的方法可以将错误代码返回给调用者。</li></ul></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/2b44a8c.html">C&C++/函数try块</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月21日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：1.2k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：4分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/14-7-function-try-blocks/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/14-7-function-try-blocks/</a></p><hr><p>Try和catch块在大多数情况下都能很好地工作，但是有一种特殊情况下它们是不充分的。考虑下面的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A(<span class="keyword">int</span> x) : m_x(x)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (x &lt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	B(<span class="keyword">int</span> x) : A(x)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// What happens if creation of A fails and we want to handle it here?</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">B <span class="title">b</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (<span class="keyword">int</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Oops\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，派生类B调用基类构造函数A，这会引发异常。因为对象b的创建已经放在try块中(在main()函数中)，如果A抛出异常，main的try块会捕捉到它。因此，这个程序打印:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Oops</span><br></pre></td></tr></table></figure><p>但如果我们想在B内部捕获异常呢？在调用B构造函数的主体之前，对基构造函数A的调用通过成员初始化列表进行。没有办法在它周围包装一个标准的try块。</p><p>在这种情况下，我们必须使用一个稍微修改过的try块，称为<strong>函数try块</strong>。</p><h1 id="函数try块"><a href="#函数try块" class="headerlink" title="函数try块"></a>函数try块</h1><p><strong>函数try块的设计允许您围绕整个函数体建立异常处理程序，而不是围绕一个代码块。</strong></p><p>函数try块的语法有点难描述，所以我们将通过例子来说明:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A(<span class="keyword">int</span> x) : m_x(x)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (x &lt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	B(<span class="keyword">int</span> x) <span class="keyword">try</span> : A(x) <span class="comment">// 注意这里添加了try关键字</span></span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (...) <span class="comment">// 注意，这与函数本身处于同一缩进级别</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 成员初始化器列表或构造函数体中的异常在这里捕获</span></span><br><span class="line"> </span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Exception caught\n"</span>;</span><br><span class="line">		<span class="comment">// 如果这里没有显式地抛出异常，则将隐式地重新抛出当前异常</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">B <span class="title">b</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (<span class="keyword">int</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Oops\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当这个程序运行时，它产生的输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception caught</span><br><span class="line">Oops</span><br></pre></td></tr></table></figure><p>让我们更详细地研究一下这个程序。</p><ul><li><p>首先，注意在成员初始化器列表之前添加了<strong>“try”关键字</strong>。<strong>这表明在该点之后 (直到函数结束) 的所有内容都应该在try块中考虑。</strong></p></li><li><p>其次，请注意，<strong>关联的catch块与整个函数的缩进级别相同</strong>。在try关键字和函数体末尾之间抛出的任何异常都可以在这里捕获。</p></li><li><p>最后，与普通的catch块不同，<strong>它允许您解析异常、抛出新异常或重新抛出现有异常，使用函数级try块，您必须抛出或重新抛出异常。</strong> 如果您没有显式地抛出一个新的异常，或者重新抛出当前的异常(使用throw关键字本身)，该异常将被隐式地重新抛出栈。</p></li></ul><p><strong>尽管函数级try块也可以用于非成员函数</strong>，但通常不会这样做，因为很少需要这样做。<strong>它们几乎只用于构造函数!</strong></p><h1 id="函数try块可以捕获基类和当前类的异常"><a href="#函数try块可以捕获基类和当前类的异常" class="headerlink" title="函数try块可以捕获基类和当前类的异常"></a>函数try块可以捕获基类和当前类的异常</h1><p><strong>在上面的例子中，如果A和B的构造函数都抛出一个异常，它将被B的构造函数周围的try块捕获。</strong></p><p>我们可以在下面的例子中看到，我们从类B而不是类A抛出一个异常:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A(<span class="keyword">int</span> x) : m_x(x)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	B(<span class="keyword">int</span> x) <span class="keyword">try</span> : A(x) <span class="comment">// note addition of try keyword here</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (x &lt;= <span class="number">0</span>) <span class="comment">// 把这个从A移到B</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="number">1</span>; <span class="comment">// 这个也被移过来</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (...)</span><br><span class="line">	&#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Exception caught\n"</span>;</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// If an exception isn't explicitly thrown here, the current exception will be implicitly rethrown</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">B <span class="title">b</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (<span class="keyword">int</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Oops\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception caught</span><br><span class="line">Oops</span><br></pre></td></tr></table></figure><h1 id="不要使用函数try块来清理资源"><a href="#不要使用函数try块来清理资源" class="headerlink" title="不要使用函数try块来清理资源"></a>不要使用函数try块来清理资源</h1><p><strong>当对象构造失败时，将不调用该类的析构函数。</strong></p><p>因此，您可能会试图使用一个 函数try块 来清理一个在失败之前已经部分分配了资源的类。但是，<u>引用失败对象的成员被认为是未定义的行为，因为在catch块执行之前对象是“死”的。</u> <strong>这意味着你不能在类后使用 函数try块 来清理。</strong></p><blockquote><p>如果您希望在类之后进行清理，<strong>请遵循清理抛出异常的类的标准规则</strong>（参见<a href="https://www.learncpp.com/cpp-tutorial/145-exceptions-classes-and-inheritance/" target="_blank" rel="noopener">14.5 – Exceptions, classes, and inheritance</a>的 “当构造函数失败时(When constructor fail)” 小节）</p></blockquote><p><strong>函数try主要用于在将异常传递到栈之前记录失败，或者更改抛出异常的类型。</strong></p></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/9b640ff1.html">C&C++/重新抛出异常</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月21日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：1.5k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：6分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/14-6-rethrowing-exceptions/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/14-6-rethrowing-exceptions/</a></p><hr><p>有时候，您可能会遇到这样的情况:</p><p>您想要捕获异常，但又不想(或有能力 )在捕获它的时候完全处理它。当您想要记录一个错误，但是将问题传递给调用者实际处理时，这是很常见的。</p><p>当函数可以使用返回代码时，这很简单。考虑下面的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Database* <span class="title">createDatabase</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        Database *d = <span class="keyword">new</span> Database(filename);</span><br><span class="line">        d-&gt;<span class="built_in">open</span>(); <span class="comment">// assume this throws an int exception on failure</span></span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">int</span> exception)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Database creation failed</span></span><br><span class="line">        <span class="comment">// Write an error to some global logfile</span></span><br><span class="line">        g_log.logError(<span class="string">"Creation of Database failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码片段中，函数的任务是创建数据库对象、打开数据库并返回数据库对象。在出现错误的情况下(例如传入了错误的文件名)，异常处理程序记录一个错误，然后合理地返回一个空指针。</p><p>现在考虑以下函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIntValueFromDatabase</span><span class="params">(Database *d, <span class="built_in">std</span>::<span class="built_in">string</span> table, <span class="built_in">std</span>::<span class="built_in">string</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(d);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> d-&gt;getIntValue(table, key); <span class="comment">// throws int exception on failure</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">int</span> exception)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Write an error to some global logfile</span></span><br><span class="line">        g_log.logError(<span class="string">"doSomethingImportant failed"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// However, we haven't actually handled this error</span></span><br><span class="line">        <span class="comment">// So what do we do here?</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个函数成功的情况下，它返回一个整数值——任何整数值都可以是一个有效值。</p><p>但是在getIntValue()出现问题的情况下又如何呢? 在这种情况下，getIntValue()将抛出一个整数异常，该异常将被getIntValueFromDatabase()中的catch块捕获，该块将记录错误。但是，我们如何告诉getIntValueFromDatabase()的调用者出错了呢? 与上面的例子不同，这里没有一个好的返回代码可以使用(因为任何整数返回值都可能是有效的)。</p><h1 id="抛出新异常"><a href="#抛出新异常" class="headerlink" title="抛出新异常"></a>抛出新异常</h1><p>一个明显的解决方案是抛出一个新的异常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIntValueFromDatabase</span><span class="params">(Database *d, <span class="built_in">std</span>::<span class="built_in">string</span> table, <span class="built_in">std</span>::<span class="built_in">string</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(d);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> d-&gt;getIntValue(table, key); <span class="comment">// throws int exception on failure</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">int</span> exception)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Write an error to some global logfile</span></span><br><span class="line">        g_log.logError(<span class="string">"doSomethingImportant failed"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">throw</span> <span class="string">'q'</span>; <span class="comment">// throw char exception 'q' up the stack to be handled by caller of getIntValueFromDatabase()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，程序从getIntValue()获取int异常，记录错误，然后用 char值’ q ‘ 抛出一个新的异常。虽然从catch块抛出异常看起来很奇怪，但这是允许的。</p><blockquote><p><strong>请记住，只有在try块中抛出的异常才有资格被捕获。</strong></p><p><strong>这意味着在catch块中抛出的异常不会被它所在的catch块捕获。相反，它将在堆栈上传播到调用者。</strong></p></blockquote><p><u>从catch块抛出的异常可以是任何类型的异常——它不需要与刚才捕获的异常相同的类型。</u></p><h1 id="重新抛出异常-错误的方式"><a href="#重新抛出异常-错误的方式" class="headerlink" title="重新抛出异常(错误的方式)"></a>重新抛出异常(错误的方式)</h1><p>另一个选项是重新抛出相同的异常。一种方法是这样做:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIntValueFromDatabase</span><span class="params">(Database *d, <span class="built_in">std</span>::<span class="built_in">string</span> table, <span class="built_in">std</span>::<span class="built_in">string</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(d);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> d-&gt;getIntValue(table, key); <span class="comment">// throws int exception on failure</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">int</span> exception)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Write an error to some global logfile</span></span><br><span class="line">        g_log.logError(<span class="string">"doSomethingImportant failed"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">throw</span> exception;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管这种方法有效，但也有一些缺点。</p><ul><li><p>首先，它不会抛出与捕获到的异常完全相同的异常——而是抛出一个经过<strong>复制</strong>初始化的变量异常<strong>副本</strong>。</p></li><li><p>尽管编译器可以自由地省略副本，但也有可能不这么做，因此这可能会降低性能。</p></li></ul><p>但值得注意的是，考虑下面的情况:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIntValueFromDatabase</span><span class="params">(Database *d, <span class="built_in">std</span>::<span class="built_in">string</span> table, <span class="built_in">std</span>::<span class="built_in">string</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(d);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> d-&gt;getIntValue(table, key); <span class="comment">// throws Derived exception on failure</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Base &amp;exception) <span class="comment">//⭐使用引用 传入</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Write an error to some global logfile</span></span><br><span class="line">        g_log.logError(<span class="string">"doSomethingImportant failed"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">throw</span> exception; <span class="comment">// Danger: this throws a Base object, not a Derived object</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在本例中，getIntValue()抛出一个派生对象，但是catch块正在捕获一个基引用。可以这样，因为我们知道我们可以有一个派生对象的基引用。</p><p>然而，当我们抛出异常时，抛出的异常是由变量exception复制初始化的。变量exception 是 基类型，因此复制初始化的异常 也是基类型(不是派生的!)</p><p>你可以在下面的程序中看到:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> Derived();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Base&amp; b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Caught Base b, which is actually a "</span>;</span><br><span class="line">            b.<span class="built_in">print</span>();</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">            <span class="keyword">throw</span> b; <span class="comment">// the Derived object gets sliced here</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Base&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Caught Base b, which is actually a "</span>;</span><br><span class="line">        b.<span class="built_in">print</span>();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Caught Base b, which is actually a Derived</span><br><span class="line">Caught Base b, which is actually a Base</span><br></pre></td></tr></table></figure><p>结果的第二行 表明Base实际上是一个Base而不是一个派生的事实 <strong>证明派生对象是被切片的</strong>。</p><h1 id="重新抛出异常-正确的方式"><a href="#重新抛出异常-正确的方式" class="headerlink" title="重新抛出异常(正确的方式)"></a>重新抛出异常(正确的方式)</h1><p>幸运的是，<strong>C++提供了一种方法来重新抛出与刚才捕获的异常完全相同的异常。</strong> 要做到这一点，<strong><u>只需使用catch块中的 throw关键字(没有关联的变量)</u></strong>，就像这样:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> Derived();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Base&amp; b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Caught Base b, which is actually a "</span>;</span><br><span class="line">            b.<span class="built_in">print</span>();</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">            <span class="keyword">throw</span>; <span class="comment">// ⭐⭐ 注意:我们现在在这里重新抛出对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Base&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Caught Base b, which is actually a "</span>;</span><br><span class="line">        b.<span class="built_in">print</span>();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Caught Base b, which is actually a Derived</span><br><span class="line">Caught Base b, which is actually a Derived ⭐</span><br></pre></td></tr></table></figure><p><strong>这个<code>throw</code>关键字看起来不会抛出任何特定的东西，实际上会重新抛出刚才捕获的异常。不需要创建副本，这意味着我们不必担心性能问题。</strong></p></div></section></article></div></section><br><div class="prev-next"><a class="prev" rel="prev" href="/page/2/"><section class="post prev white-box shadow"><i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页&nbsp;</section></a><p class="current">3 / 15</p><a class="next" rel="next" href="/page/4/"><section class="post next white-box shadow">&nbsp;下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i></section></a></div></div><aside class="l_side"><section class="widget blogger shadow desktop"><div class="content"><div class="avatar"><img class="avatar" src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"></div><div class="text"><p><span id="jinrishici-sentence">龙龙‘S BLOG</span></p><script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script></div><div class="social-wrapper"><a href="/atom.xml" class="social fas fa-rss flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="mailto:1198216723@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://github.com/longlongqin" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://music.163.com/#/user/home?id=285545421" class="social fas fa-headphones-alt flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a></div></div></section><section class="widget grid shadow desktop mobile"><header><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i><span class="name">站内导航</span></header><div class="content"><div class="grid navigation"><a class="flat-box" title="/" href="/" id="home"><i class="fas fa-clock fa-fw" aria-hidden="true"></i> 近期文章 </a><a class="flat-box" title="/archives/" href="/archives/" rel="nofollow" id="archives"><i class="fas fa-archive fa-fw" aria-hidden="true"></i> 文章归档 </a><a class="flat-box" title="/friends/" href="/friends/" rel="nofollow" id="friends"><i class="fas fa-link fa-fw" aria-hidden="true"></i> 友人帐 </a><a class="flat-box" title="/about/" href="/about/" rel="nofollow" id="about"><i class="fas fa-info-circle fa-fw" aria-hidden="true"></i> 关于小站</a></div></div></section><section class="widget category shadow desktop"><header><a href="/blog/categories/"><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i><span class="name">文章分类</span></a></header><div class="content"><ul class="entry navigation"><li><a class="flat-box" title="/categories/OJ/" href="/categories/OJ/" id="categoriesOJ"><div class="name">OJ</div><div class="badge">(1)</div></a></li><li><a class="flat-box" title="/categories/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" href="/categories/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" id="categorieshexoE58D9AE5AEA2E690ADE5BBBA"><div class="name">hexo博客搭建</div><div class="badge">(1)</div></a></li><li><a class="flat-box" title="/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" href="/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" id="categoriesE58D9AE5AEA2E690ADE5BBBA"><div class="name">博客搭建</div><div class="badge">(4)</div></a></li><li><a class="flat-box" title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="categoriesE5ADA6E4B9A0E7AC94E8AEB0"><div class="name">学习笔记</div><div class="badge">(48)</div></a></li><li><a class="flat-box child" title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/" id="categoriesE5ADA6E4B9A0E7AC94E8AEB0C-C"><div class="name">C/C++</div><div class="badge">(25)</div></a></li><li><a class="flat-box child" title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git/" id="categoriesE5ADA6E4B9A0E7AC94E8AEB0Git"><div class="name">Git</div><div class="badge">(1)</div></a></li><li><a class="flat-box" title="/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" href="/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" id="categoriesE5AE9EE794A8E68A80E5B7A7"><div class="name">实用技巧</div><div class="badge">(1)</div></a></li><li><a class="flat-box" title="/categories/%E9%85%8D%E7%BD%AE/" href="/categories/%E9%85%8D%E7%BD%AE/" id="categoriesE9858DE7BDAE"><div class="name">配置</div><div class="badge">(1)</div></a></li></ul></div></section><section class="widget tagcloud shadow desktop"><header><a href="/blog/tags/"><i class="fas fa-tags fa-fw" aria-hidden="true"></i><span class="name">热门标签</span></a></header><div class="content"><a href="/tags/C/" style="font-size:16px;color:#8b8b8b">C++</a> <a href="/tags/C-C/" style="font-size:24px;color:#555">C/C++</a> <a href="/tags/Git/" style="font-size:14px;color:#999">Git</a> <a href="/tags/Hexo%E4%B8%BB%E9%A2%98/" style="font-size:14px;color:#999">Hexo主题</a> <a href="/tags/Let-s-Build-A-Simple-Interpreter/" style="font-size:22px;color:#636363">Let's Build A Simple Interpreter</a> <a href="/tags/Let%E2%80%99s-Build-A-Simple-Interpreter/" style="font-size:18px;color:#7e7e7e">Let’s Build A Simple Interpreter</a> <a href="/tags/OJ/" style="font-size:14px;color:#999">OJ</a> <a href="/tags/Yilia%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/" style="font-size:14px;color:#999">Yilia主题配置</a> <a href="/tags/forme/" style="font-size:14px;color:#999">forme</a> <a href="/tags/front-matter%E9%85%8D%E7%BD%AE/" style="font-size:14px;color:#999">front-matter配置</a> <a href="/tags/github/" style="font-size:14px;color:#999">github</a> <a href="/tags/hexo%E6%98%BE%E7%A4%BApdf/" style="font-size:14px;color:#999">hexo显示pdf</a> <a href="/tags/matery%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/" style="font-size:14px;color:#999">matery主题配置</a> <a href="/tags/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE%E3%80%8B/" style="font-size:18px;color:#7e7e7e">《计算机科学速成课》</a> <a href="/tags/%E5%87%B8%E5%8C%85/" style="font-size:20px;color:#707070">凸包</a> <a href="/tags/%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91%E5%92%8C%E9%80%BB%E8%BE%91%E9%97%A8/" style="font-size:14px;color:#999">布尔逻辑和逻辑门</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" style="font-size:14px;color:#999">计算几何</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE/" style="font-size:14px;color:#999">计算机科学速成课</a> <a href="/tags/%E9%85%8D%E7%BD%AE/" style="font-size:14px;color:#999">配置</a></div></section></aside><footer class="clearfix white"><br><br><div class="aplayer-container"><meting-js theme="#1BCDFC" autoplay volume="0.6" loop order="list" fixed="false" list-max-height="340px" server="netease" type="song" id="186453" list-folded="true"></meting-js></div><br><div class="social-wrapper"><a href="/atom.xml" class="social fas fa-rss flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="mailto:1198216723@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://github.com/longlongqin" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://music.163.com/#/user/home?id=285545421" class="social fas fa-headphones-alt flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a></div><red>&copy; 2020-2021 longlongqin 😊| powered by HEXO | theme volantis</red><br><yellow><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("03/01/2020 18:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="小站已运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒 "}setInterval("createtime()",250)</script></yellow><br><green><i class="fas fa-chart-area"></i> <span class="post-count">字数统计：307.9k</span></green>|<script type="text/javascript" src="https://v1.cnzz.com/z_stat.php?id=1278663994&web_id=1278663994"></script><br><cyan>博客内容遵循</cyan><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank"><cyan>署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</cyan></a></footer><script>setLoadingBarProgress(80)</script><script>setLoadingBarProgress(60)</script></div><a class="s-top fas fa-arrow-up fa-fw" href="javascript:void(0)"></a></div><script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script><script>var SEARCH_SERVICE="hexo",ROOT="/";ROOT.endsWith("/")||(ROOT+="/")</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script><script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script><script type="text/javascript">$(function(){Waves.attach(".flat-btn",["waves-button"]),Waves.attach(".float-btn",["waves-button","waves-float"]),Waves.attach(".float-btn-light",["waves-button","waves-float","waves-light"]),Waves.attach(".flat-box",["waves-block"]),Waves.attach(".float-box",["waves-block","waves-float"]),Waves.attach(".waves-image"),Waves.init()})</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script><script type="text/javascript">$(function(){var n=["https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/background/4.jpg"];!function(n){for(var o=n.length;o--;){var r=Math.floor(Math.random()*o),t=n[r];n[r]=n[o],n[o]=t}}(n),$(".cover").backstretch(n,{duration:"20000",fade:"1500"})})</script><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js" async></script><script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js" async></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1.4/js/app.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1/js/search.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script><script>!function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copyed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-clipboard-check');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPYED';
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-exclamation-triangle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
      });
    }
    initCopyCode();
  }(window, document);</script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>let LAZY_LOAD_IMAGE = "[object Object]";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });</script><script>setLoadingBarProgress(100)</script><script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)t=c[r],0<=(n=t.getBoundingClientRect()).bottom&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this);</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script></body></html>