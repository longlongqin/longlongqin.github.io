<!DOCTYPE html><html><head hexo-theme="https://volantis.js.org/#2.1.4"><meta charset="utf-8"><meta name="robots" content="noindex,follow"><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><title>龙龙‘S BLOG</title><link rel="alternate" href="/atom.xml" title="龙龙‘S BLOG"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css"><link rel="shortcut icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1.4.3/css/style.css"><script>function setLoadingBarProgress(e){document.getElementById("loading-bar").style.width=e+"%"}</script></head><body><script type="text/javascript" src="/js/love.js"></script><script type="text/javascript" src="/js/ergao.js"></script><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><header class="l_header shadow blur"><div class="wrapper"><div class="nav-sub container--flex"><a class="logo flat-box"></a><ul class="switcher h-list"><li><a class="s-comment flat-btn fas fa-comments fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-toc flat-btn fas fa-list fa-fw" target="_self" href="javascript:void(0)"></a></li></ul></div><div class="nav-main container container--flex"><a class="logo flat-box" target="_self" href="/"><i class="fas fa-home"></i> 龙龙</a><div class="menu navigation"><ul class="h-list"><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list-alt fa-fw fa-fw"></i> 索引</a><ul class="submenu"><li><a class="flat-box" href="/categories/" id="categories"><i class="fas fa-folder-open fa-fw fa-fw"></i> 分类</a><ul class="submenu"><li><a class="flat-box" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="categoriesE5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-fire fa-fw"></i> 学习笔记</a></li><li><a class="flat-box" href="/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" id="categoriesE5AE9EE794A8E68A80E5B7A7"><i class="fas fa-fire fa-fw"></i> 实用技巧</a></li></ul></li><li><a class="flat-box" href="/tags/" id="tags"><i class="fas fa-tags fa-fw fa-fw"></i> 标签</a></li><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list fa-fw fa-fw"></i> 时间轴</a></li></ul></li><li><a class="flat-box" href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="E5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-book fa-fw"></i> 学习笔记</a></li><li><a class="flat-box"><i class="fas fa-wrench fa-fw"></i> 工具</a><ul class="submenu"><li><a class="flat-box" href="https://www.thinkcmf.com/font/search/index.html" target="_blank" rel="noopener" id="https:www.thinkcmf.comfontsearchindex.html"><i class="fas fa-font fa-fw"></i> Font Awesome图标</a></li><li><a class="flat-box" href="https://www.sojson.com/image/change.html" target="_blank" rel="noopener" id="https:www.sojson.comimagechange.html"><i class="fa fa-crop fa-fw"></i> 在线图片尺寸修改</a></li><li><a class="flat-box" href="http://dir.scmor.com/" target="_blank" rel="noopener" id="http:dir.scmor.com"><i class="fa fa-search fa-fw"></i> Google学术&搜索镜像</a></li><li><a class="flat-box" href="https://emojixd.com/" target="_blank" rel="noopener" id="https:emojixd.com"><i class="fa fa-smile-o fa-fw"></i> Emoji表情符号辞典📓</a></li></ul></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw fa-fw"></i> 关于</a><ul class="submenu"><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-user-circle fa-fw fa-fw"></i> 关于我</a></li><hr><li><a class="flat-box" href="/friends/" id="friends"><i class="fas fa-link fa-fw"></i> 友人帐</a></li><li><a class="flat-box" href="/comment/" id="comment"><i class="fas fa-comment fa-fw"></i> 留言板</a></li><hr><li><a class="flat-box" href="https://github.com/longlongqin" target="_blank" rel="noopener" id="https:github.comlonglongqin"><i class="fab fa-github fa-fw fa-fw"></i> 我的Github</a></li><li><a class="flat-box" href="https://longlongqin.gitee.io" target="_blank" rel="noopener" id="https:longlongqin.gitee.io"><i class="fa fa-chevron-circle-right fa-fw"></i> matery主题博客</a></li></ul></li><li><a class="flat-box" href="https://volantis.js.org/tag-plugins/" target="_blank" rel="noopener" id="https:volantis.js.orgtag-plugins"><i class="fa fa-bookmark fa-fw"></i> Volantis主题文档</a></li><li><a class="flat-box" href="/easysearch/" id="easysearch"><i class="fa fa-search fa-fw"></i> easy搜索</a></li></ul></div><div class="m_search"><form name="searchform" class="form u-search-form"><i class="icon fas fa-search fa-fw"></i> <input type="text" class="input u-search-input" placeholder="search for everything"></form></div><ul class="switcher h-list"><li><a class="s-search flat-btn fas fa-search fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-menu flat-btn fas fa-bars fa-fw" target="_self" href="javascript:void(0)"></a></li></ul></div></div></header><ul class="menu-phone navigation white-box"><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list-alt fa-fw fa-fw"></i> 索引</a></li><li><a class="flat-box" href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="E5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-book fa-fw"></i> 学习笔记</a></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw fa-fw"></i> 关于</a></li></ul><script>setLoadingBarProgress(40)</script><div class="l_body nocover"><div class="body-wrapper"><div class="l_main"><section class="post-list"><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/156886df.html">C&C++/常量类对象及成员函数</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月9日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：1.7k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：7分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/810-const-class-objects-and-member-functions/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/810-const-class-objects-and-member-functions/</a></p><hr><p>在 <a href="https://www.learncpp.com/cpp-tutorial/const-constexpr-and-symbolic-constants/" target="_blank" rel="noopener">4.13 – Const, constexpr, and symbolic constants</a>中，您学习了基本数据类型(int, double, char，等等)可以通过const关键字变为静态，并且所有<strong>Const变量必须在创建时初始化。</strong></p><p>在const基本数据类型的情况下，可以通过复制、直接或统一初始化来进行初始化:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> value1 = <span class="number">5</span>; <span class="comment">// copy initialization</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">value2</span><span class="params">(<span class="number">7</span>)</span></span>; <span class="comment">// direct initialization</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> value3 &#123; <span class="number">9</span> &#125;; <span class="comment">// uniform initialization (C++11)</span></span><br></pre></td></tr></table></figure><h1 id="常量类"><a href="#常量类" class="headerlink" title="常量类"></a>常量类</h1><p>类似地，实例化的类对象也可以通过使用const关键字 来生成const<strong>。初始化是通过类构造函数完成的:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Date date1; <span class="comment">// initialize using default constructor</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> Date <span class="title">date2</span><span class="params">(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">16</span>)</span></span>; <span class="comment">// initialize using parameterized constructor</span></span><br><span class="line"><span class="keyword">const</span> Date date3 &#123; <span class="number">2020</span>, <span class="number">10</span>, <span class="number">16</span> &#125;; <span class="comment">// initialize using parameterized constructor (C++11)</span></span><br></pre></td></tr></table></figure><p>一旦通过构造函数初始化了const类对象，任何修改对象成员变量的尝试都是不允许的，因为这会违反对象的const属性。</p><blockquote><p>“修改”既包括直接<strong>更改成员变量</strong>(如果它们是公共的)，也包括<strong>调用设置成员变量值的成员函数。</strong></p></blockquote><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value;</span><br><span class="line"> </span><br><span class="line">    Something(): m_value(<span class="number">0</span>) &#123; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; m_value = value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_value ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Something something; <span class="comment">// calls default constructor</span></span><br><span class="line"> </span><br><span class="line">    something.m_value = <span class="number">5</span>; <span class="comment">//✖ compiler error: violates const</span></span><br><span class="line">    something.setValue(<span class="number">5</span>); <span class="comment">//✖ compiler error: violates const</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h1><h2 id="const类对象只能显式地调用const成员函数"><a href="#const类对象只能显式地调用const成员函数" class="headerlink" title="const类对象只能显式地调用const成员函数"></a>const类对象只能<u>显式</u>地调用const成员函数</h2><p>请看下面的语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; something.getValue();</span><br></pre></td></tr></table></figure><p>也许令人惊讶的是，<strong>这也会导致一个编译错误</strong>，即使<code>getValue()</code>不做任何改变成员变量的事情!</p><p>结果是，<strong>const类对象只能<u>显式</u>地调用const成员函数</strong>，而<code>getValue()</code>没有被标记为const成员函数。</p><hr><h2 id="书写格式"><a href="#书写格式" class="headerlink" title="书写格式"></a>书写格式</h2><p><strong>const成员函数</strong>是一个成员函数，它保证<strong>不会</strong>： <strong>修改对象</strong>或 <strong>调用任何非const成员函数</strong>(因为它们可能修改对象)。</p><h3 id="常量成员函数-在类定义之中-定义"><a href="#常量成员函数-在类定义之中-定义" class="headerlink" title="常量成员函数 在类定义之中 定义"></a>常量成员函数 在类定义之中 定义</h3><blockquote><p>要使getValue()成为const成员函数，我们<strong>只需将const关键字添加到函数原型中，在参数列表之后，但在函数体之前</strong>:</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value;</span><br><span class="line"> </span><br><span class="line">    Something(): m_value(<span class="number">0</span>) &#123; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resetValue</span><span class="params">()</span> </span>&#123; m_value = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; m_value = value; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> m_value;&#125; </span><br><span class="line">    <span class="comment">//⭐注意:const关键字添加在参数列表之后，但是在函数体之前</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="常量成员函数-在类定义之外-定义"><a href="#常量成员函数-在类定义之外-定义" class="headerlink" title="常量成员函数 在类定义之外 定义"></a>常量成员函数 在类定义之外 定义</h3><p>对于定义在类定义之外的成员函数，<strong>必须在 类定义中的函数原型 和 函数定义上 使用const关键字:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value;</span><br><span class="line"> </span><br><span class="line">    Something(): m_value(<span class="number">0</span>) &#123; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resetValue</span><span class="params">()</span> </span>&#123; m_value = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; m_value = value; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">//⭐ 注意这里添加了const关键字</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Something::getValue</span><span class="params">()</span> <span class="keyword">const</span> <span class="comment">// ⭐这里也添加关键字const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>此外，<strong>任何试图更改成员变量或调用非const成员函数 的 const成员函数 都会导致编译器错误。</strong>例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value ;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resetValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; m_value = <span class="number">0</span>; &#125; <span class="comment">// 编译错误, const成员函数不能修改成员变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="构造函数不能是const"><a href="#构造函数不能是const" class="headerlink" title="构造函数不能是const"></a>构造函数不能是const</h1><p>注意，<strong>构造函数不能标记为const。这是因为构造函数需要能够初始化它们的成员变量</strong>，而const构造函数则不能这样做。因此，不允许const构造函数。</p><h1 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h1><p>尽管实例化const类对象是创建const对象的一种方法<strong>，但更常见的方法是通过const引用将一个对象传递给一个函数</strong>。</p><hr><blockquote><p>在关于 <a href="http://www.learncpp.com/cpp-tutorial/73-passing-arguments-by-reference/" target="_blank" rel="noopener">passing arguments by reference</a>中，我们讨论了通过const引用而不是通过值传递类参数的优点。</p><p>总而言之，通过值传递类参数会导致生成类的副本(这比较慢)——大多数时候，我们不需要副本，<strong>对原始参数的引用可以很好地工作，而且更有性能，因为它避免了不必要的副本。</strong></p></blockquote><p>我们通常使用引用const，以确保函数不会在不经意间更改参数，并允许函数处理r-value(例如文字)，<u>这些r-value可以作为const引用传递，但不能作为非const引用</u>。</p><h2 id="不能在const对象上调用非const成员函数"><a href="#不能在const对象上调用非const成员函数" class="headerlink" title="不能在const对象上调用非const成员函数"></a>不能在const对象上调用非const成员函数</h2><p>您能找出以下代码的错误吗?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_year;</span><br><span class="line">    <span class="keyword">int</span> m_month;</span><br><span class="line">    <span class="keyword">int</span> m_day;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Date(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span><br><span class="line">    &#123;</span><br><span class="line">        setDate(year, month, day);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDate</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_year = year;</span><br><span class="line">        m_month = month;</span><br><span class="line">        m_day = day;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getYear</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_year; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMonth</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_month; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDay</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_day; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDate</span><span class="params">(<span class="keyword">const</span> Date &amp;date)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; date.getYear() &lt;&lt; <span class="string">"/"</span> &lt;&lt; date.getMonth() &lt;&lt; <span class="string">"/"</span> &lt;&lt; date.getDay() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Date <span class="title">date</span><span class="params">(<span class="number">2016</span>, <span class="number">10</span>, <span class="number">16</span>)</span></span>;</span><br><span class="line">    printDate(date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是，在<code>printDate</code>函数内部，date被视为一个const对象。使用这个常量 date，我们<u>调用函数<code>getYear()</code>、<code>getMonth()</code>和<code>getDay()</code>，它们都是非const的</u>。<strong>因为我们不能在const对象上调用非const成员函数，这将导致编译错误。</strong></p><ul><li><p>解决方法：使getYear()、getMonth()和getDay()这些函数成为 const:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_year;</span><br><span class="line">    <span class="keyword">int</span> m_month;</span><br><span class="line">    <span class="keyword">int</span> m_day;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Date(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span><br><span class="line">    &#123;</span><br><span class="line">        setDate(year, month, day);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// setDate() cannot be const, modifies member variables</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDate</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_year = year;</span><br><span class="line">        m_month = month;</span><br><span class="line">        m_day = day;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// The following getters can all be made const⭐</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getYear</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_year; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMonth</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_month; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDay</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_day; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h1 id="重载const和非const函数"><a href="#重载const和非const函数" class="headerlink" title="重载const和非const函数"></a>重载const和非const函数</h1><p>最后，虽然不经常这样做，<strong>但有可能重载一个函数，使其具有同一个函数的const和非const版本:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_value;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Something(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;value=<span class="string">""</span>) &#123; m_value= value; &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ⭐用于const对象的getValue()</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> m_value;&#125; <span class="comment">//⭐⭐⭐</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ⭐用于非const对象的getValue()</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="title">getValue</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_value;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><code>const std::string&amp; getValue() const {return m_value;}</code></p><ul><li><p><strong>最左边</strong>的const是函数返回类型的一部分，<strong>表示返回了一个const引用。</strong></p></li><li><p><strong>最右边</strong>的const表示成员函数<u>自身是const</u>。<strong>这意味着它不会改变对象的状态，并且可以被const类的对象调用。</strong></p></li></ul></blockquote><p>函数的const版本将在任何const对象上调用，而非const版本将在任何非const对象上调用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Something something;</span><br><span class="line">	something.getValue() = <span class="string">"Hi"</span>; <span class="comment">// calls non-const getValue();</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">const</span> Something something2;</span><br><span class="line">	something2.getValue(); <span class="comment">// calls const getValue();    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用const和非const版本的函数重载通常是在返回值需要在稳定性上有所不同时完成的。在上面的例子中：</p><ul><li><p>getValue()的非const版本将只与非const对象一起工作，但是更加灵活，因为我们可以使用它来读写m_value(通过分配字符串“Hi”来完成)。</p></li><li><p>getValue()的const版本<strong>既可以使用const对象，也可以使用非const对象</strong>，但是返回一个const引用，以确保我们不能修改const对象的数据。</p></li></ul></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/8605edc6.html">C&C++/类的代码与头文件</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月8日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：1.7k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：6分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><h1 id="在类定义之外定义成员函数"><a href="#在类定义之外定义成员函数" class="headerlink" title="在类定义之外定义成员函数"></a>在类定义之外定义成员函数</h1><p>随着类变得越来越长、越来越复杂，<strong>在类中包含所有成员函数定义</strong>会使类更难管理和使用。使用一个已经编写好的类只需要了解它的公共接口(公共成员函数)，而不需要了解类的底层工作方式。成员函数实现的细节只是一个障碍。</p><p>幸运的是，<strong>c++提供了一种将类的“声明”部分与“实现”部分分离的方法</strong>。</p><blockquote><p><strong>这是通过在类定义之外定义类成员函数来实现的。</strong></p><p>要做到这一点，只需定义类的成员函数，就像它们是普通函数一样，<strong>但是要使用范围解析操作符(::)将类名作为函数的前缀(与名称空间相同)。</strong></p></blockquote><hr><p>一个例子：</p><blockquote><p>请注意，这些函数的原型仍然存在于类定义中，但是实际的实现已经移到了类定义之外</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_year;</span><br><span class="line">    <span class="keyword">int</span> m_month;</span><br><span class="line">    <span class="keyword">int</span> m_day;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Date(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetDate</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getYear</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_year; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMonth</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_month; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDay</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> m_day; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Date constructor</span></span><br><span class="line">Date::Date(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span><br><span class="line">&#123;</span><br><span class="line">    SetDate(year, month, day);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Date member function</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Date::SetDate</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_month = month;</span><br><span class="line">    m_day = day;</span><br><span class="line">    m_year = year;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="将类定义放在头文件中"><a href="#将类定义放在头文件中" class="headerlink" title="将类定义放在头文件中"></a>将类定义放在头文件中</h1><p>在有关头文件的课程中 (<a href="http://www.learncpp.com/cpp-tutorial/19-header-files/" target="_blank" rel="noopener">header files</a>) ，您了解到可以将<strong>函数声明放在头文件</strong>中，以便在多个文件甚至多个项目中使用这些函数。</p><p><strong>类定义也可以放在头文件中</strong>，以便于在多个文件或多个项目中重用。</p><blockquote><p>传统上，类定义放在与类同名的头文件中，类外部定义的成员函数放在与类同名的.cpp文件中。</p></blockquote><p>如：</p><p>Date.h:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DATE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATE_H</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_year;</span><br><span class="line">    <span class="keyword">int</span> m_month;</span><br><span class="line">    <span class="keyword">int</span> m_day;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Date(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetDate</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getYear</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_year; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMonth</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_month; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDay</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> m_day; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>Date.cpp:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Date.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Date constructor</span></span><br><span class="line">Date::Date(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span><br><span class="line">&#123;</span><br><span class="line">    SetDate(year, month, day);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Date member function</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Date::SetDate</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_month = month;</span><br><span class="line">    m_day = day;</span><br><span class="line">    m_year = year;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，任何其他想要使用Date类的头文件或代码文件都可以简单地<code>#include &quot;Date.h&quot;</code>。注意，data .cpp还需要编译到任何使用Date.h的项目中，以便链接器知道如何实现Date。</p><h2 id="在头文件中定义类是否违反了one-definition规则"><a href="#在头文件中定义类是否违反了one-definition规则" class="headerlink" title="在头文件中定义类是否违反了one-definition规则?"></a>在头文件中定义类是否违反了one-definition规则?</h2><p>这是不应该的。如果您的头文件具有适当的头保护，则不应该在同一个文件中多次包含类定义。</p><p><u>类型(包括类)</u><strong>不受</strong>one-definition规则的约束，该规则规定每个程序只能有一个定义。因此，在多个代码文件中包含类定义并没有问题(如果有的话，类也没有多大用处)。</p><h2 id="在头文件中定义成员函数是否违反了one-definition规则"><a href="#在头文件中定义成员函数是否违反了one-definition规则" class="headerlink" title="在头文件中定义成员函数是否违反了one-definition规则?"></a>在头文件中定义成员函数是否违反了one-definition规则?</h2><ul><li>视情况而定。在类定义<strong>中</strong> 定义的成员函数被认为是<strong>隐式内联</strong>的。内联函数不受one-definition规则中每个程序的一个定义的约束。<strong>这意味着在类定义本身内部定义普通的成员函数(例如访问函数)是没有问题的。</strong></li></ul><ul><li><p>在类定义<strong>之外</strong>定义的成员函数<strong>被视为普通函数</strong>，并且受一个定义规则中每个程序部分的一个定义的约束。</p><p>因此，这些函数应该在代码文件(.cpp)中定义，而不是在头文件中定义。唯一的例外是模板函数，我们将在以后的章节中讨论。</p></li></ul><h2 id="应该在头文件和cpp文件中定义什么，在类定义的内部-和-外部-定义什么"><a href="#应该在头文件和cpp文件中定义什么，在类定义的内部-和-外部-定义什么" class="headerlink" title="应该在头文件和cpp文件中定义什么，在类定义的内部 和 外部 定义什么?"></a>应该在头文件和cpp文件中定义什么，在类定义的内部 和 外部 定义什么?</h2><p>您可能会试图将所有成员函数定义<strong>放入类内的头文件中</strong>。虽然这将编译，但这样做有几个缺点：</p><ul><li><p>首先，如上所述，这会使类定义变得混乱。</p></li><li><p>类中定义的函数是隐式内联的。对于从许多地方调用的大型函数，这会使代码膨胀。</p></li><li><p>第三，如果您更改了<strong>头文件</strong>的代码，那么您需要重新编译包含该头文件的每个文件。</p><blockquote><p>这可能会产生连锁反应，一个微小的更改就会导致整个程序需要重新编译(这可能很慢)。</p><hr></blockquote><p>(但是，你<strong>更改.cpp文件，编译器只会重新编译改动过的 .cpp文件</strong>)</p></li></ul><hr><p>因此，我们建议如下:</p><ul><li>对于 仅在一个通常不重用的文件 中使用的类，直接在使用它们的单个.cpp文件中定义它们。</li><li>对于在多个文件中使用的类，或者用于一般重用的类，请在与类同名的.h文件中定义它们。</li><li>普通成员函数(普通构造函数或析构函数、访问函数等)可以<strong>在类<u>中</u>定义</strong>。</li><li>非普通成员函数应该在与类同名的<strong>.cpp文件中定义</strong>。</li></ul><h2 id="成员函数的默认参数应该在类定义中声明-头文件中"><a href="#成员函数的默认参数应该在类定义中声明-头文件中" class="headerlink" title="成员函数的默认参数应该在类定义中声明(头文件中)"></a>成员函数的默认参数应该在类定义中声明(头文件中)</h2><p>成员函数的默认参数应该在类定义中声明(在头文件中)，在那里任何人都可以看到#includes 这个头文件。</p><h1 id="库"><a href="#库" class="headerlink" title="库"></a>库</h1><p><strong>分离类定义和类实现对于可用于扩展程序的库非常常见</strong>。</p><p>在您的整个程序中，你已经#included 许多标准的库，如iostream, string, vector, array等等。您的程序需要头文件的声明，以便编译器验证您正在编写的程序在语法上是正确的。</p><blockquote><p>注意，您不需要添加 iostream.cpp, string.cpp, vector.cpp, or array.cpp 到你的程序中。</p></blockquote><p>但是，<strong>属于c++标准库的类的实现包含在一个预编译文件中</strong>，该文件在<strong>链接阶段</strong>被链接进来。你永远看不到代码。</p><hr><p>除了一些开源软件(同时提供.h和.cpp文件)之外，<strong>大多数第三方库只提供头文件和预编译的库文件</strong>。这有几个原因：</p><ul><li>链接预编译的库比每次需要时重新编译要快；</li><li>预编译库的单个副本可以被许多应用程序共享，而编译后的代码被编译到使用它的每个可执行文件中(增大文件大小)。</li><li>知识产权原因(您不希望别人窃取您的代码)。</li></ul><p>将您自己的文件分隔为声明(头文件)和实现(代码文件)不仅是一种良好的形式，而且还使创建您自己的自定义库更加容易。创建自己的库超出了本教程的范围，但是将声明和实现分离是这样做的先决条件。</p></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/7d6924a1.html">C&C++/隐藏的“this”指针</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月8日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：2.2k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：8分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/8-8-the-hidden-this-pointer/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/8-8-the-hidden-this-pointer/</a></p><hr><p>新的面向对象程序员经常问的一个关于类的问题是，“<strong>当一个成员函数被调用时，c++如何跟踪它被调用的对象?”</strong></p><p>答案是：<strong>C++使用了一个名为“this”的隐藏指针!</strong> 让我们更详细地看看“this”。</p><p>下面是一个简单的类，它保存一个整数并提供一个构造函数和访问函数。<strong>注意，不需要析构函数，因为c++可以为我们清理整数成员变量</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_id;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Simple(<span class="keyword">int</span> id)</span><br><span class="line">    &#123;</span><br><span class="line">        setID(id);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setID</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123; m_id = id; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getID</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_id; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是一个使用这个类的示例程序:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Simple <span class="title">simple</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    simple.setID(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; simple.getID() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>当我们调用<code>simple.setID(2);</code>时，c++知道<code>setID()</code>函数应该对simple对象进行操作，<code>m_id</code>实际上指的是<code>simple.m_id</code>。让我们研究一下这背后的机制。</p><h1 id="隐藏的-this指针"><a href="#隐藏的-this指针" class="headerlink" title="隐藏的*this指针"></a>隐藏的<code>*this</code>指针</h1><p>看看上面例子中的代码行:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">simple.setID(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>尽管对<code>setID()</code>函数的调用<u>看起来</u>只有一个参数，但<u>实际上</u>它有两个! 在编译时，编译器将转换<code>simple.setID(2);</code>为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setID(&amp;simple, <span class="number">2</span>); <span class="comment">//注意，simple已经从一个对象前缀 更改为一个函数参数!</span></span><br></pre></td></tr></table></figure><p>注意，这现在只是一个标准的函数调用，</p><blockquote><p>而 simple对象 (以前是一个对象前缀) <strong>现在通过 地址传递 作为函数的参数。</strong></p></blockquote><hr><p><strong>但这只是答案的一半。</strong></p><blockquote><p><strong>由于函数调用现在添加了一个新的的参数，因此需要修改成员函数定义，以接受(并使用)这个参数作为参数</strong>。因此，有以下成员函数:</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setID</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123; m_id = id; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被转换为：⭐</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setID</span><span class="params">(Simple* <span class="keyword">const</span> <span class="keyword">this</span>, <span class="keyword">int</span> id)</span> </span>&#123;<span class="keyword">this</span>-&gt;m_id = id;&#125;</span><br></pre></td></tr></table></figure><hr><p>当编译器编译一个普通成员函数时，它会隐式地向函数添加一个名为“this”的新参数。<strong>this指针</strong>是一个隐藏的<strong>const指针</strong>，<u>它保存成员函数所调用的对象的地址。</u></p><hr><p><strong>还有一个细节要处理</strong>。</p><p>在成员函数内部，还需要更新任何类成员(函数和变量)，以便它们引用调用成员函数的对象。这很容易做到，只要在每一个前面加上<strong>“this -&gt;”</strong>就可以了。</p><blockquote><p>因此，在<code>setID()</code>函数体中，<strong>m_id</strong>(它是一个类成员变量)被转换为<strong>this-&gt;m_id</strong>。因此，当“this”指向simple的地址时， <strong>this-&gt;m_id</strong>将解析为<strong>simple. m_id</strong>。</p></blockquote><h2 id="综上所述："><a href="#综上所述：" class="headerlink" title="综上所述："></a>综上所述：</h2><ol><li>当我们调用<code>simple.setID(2)</code>，编译器实际上调用 <code>setID(&amp;simple, 2)</code></li><li>在<code>setID()</code>中，“this”指针保存了 对象simple 的地址。</li><li><code>setID()</code>中的任何成员变量都以“<code>this-&gt;</code>”作为前缀。所以当我们说m_id = id时，编译器实际上是在执行<code>this-&gt;m_id = id</code>，在本例中将 <code>simple.m_id</code> 转换为 <code>id</code>。</li></ol><p>好消息是，所有这些都是自动发生的，不管你是否记得它是如何工作的。您需要记住的是，<strong>所有普通成员函数都有一个“this”指针，该指针指向函数所调用的对象。</strong></p><h1 id="“this”总是指向被操作的对象"><a href="#“this”总是指向被操作的对象" class="headerlink" title="“this”总是指向被操作的对象"></a>“this”总是指向被操作的对象</h1><p>新程序员有时会对存在多少“this”指针感到困惑。</p><p><strong>每个成员函数都有一个“this”指针参数，该参数被设置为正在操作的对象的地址</strong>。请看:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Simple <span class="title">A</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="comment">// this = &amp;A 在 Simple 构造函数的内部</span></span><br><span class="line">    <span class="function">Simple <span class="title">B</span><span class="params">(<span class="number">2</span>)</span></span>; <span class="comment">// this = &amp;B 在 Simple 构造函数的内部</span></span><br><span class="line">    A.setID(<span class="number">3</span>); <span class="comment">// this = &amp;A 在成员函数 setID 的内部</span></span><br><span class="line">    B.setID(<span class="number">4</span>); <span class="comment">// this = &amp;B 在成员函数 setID 的内部</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，“this”指针交替保存对象A或B的地址，这取决于我们是否在对象A或B上调用了成员函数。</p><hr><h1 id="“this”是一个参数，它存放于栈中"><a href="#“this”是一个参数，它存放于栈中" class="headerlink" title="“this”是一个参数，它存放于栈中"></a>“this”是一个参数，它存放于栈中</h1><p><strong>因为“this”只是一个函数参数，它不会向您的类添加任何内存使用</strong> (只会添加到成员函数调用，因此该参数在函数执行时在<strong>栈</strong>上运行)。</p><h1 id="显式地引用“this”"><a href="#显式地引用“this”" class="headerlink" title="显式地引用“this”"></a>显式地引用“this”</h1><p>大多数时候，您不需要显式地引用“this”指针。但是，在某些情况下这样做是有用的:</p><blockquote><p>首先，如果你有一个构造函数(或成员函数)，它有一个与成员变量同名的参数，你可以使用“this”来消除它们的歧义:</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Something(<span class="keyword">int</span> data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;data = data; <span class="comment">// this-&gt;data是成员变量，data是本地参数</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>请注意，我们的构造函数接受同名的参数作为成员变量。在本例中，“data”指的是参数，“this-&gt;data”指的是成员变量。虽然这是可接受的编码实践，但我们发现在所有<strong>成员变量名上使用“m_”前缀</strong>提供了更好的解决方案，它完全防止了重复的名称!</p><p>有些开发人员喜欢显式地将这个-&gt;添加到所有类成员中。我们建议您避免这样做，因为这样做会降低代码的可读性，并且没有什么好处。<strong>使用<code>m_</code>前缀是区分成员变量和非成员(本地)变量的一种更具可读性的方法。</strong></p><h2 id="链接成员函数"><a href="#链接成员函数" class="headerlink" title="链接成员函数"></a>链接成员函数</h2><p>其次，有时让类成员函数返回它正在处理的对象作为返回值是有用的。</p><p><strong>这样做的主要原因是允许将一系列成员函数“链接”在一起</strong>，这样就可以在同一个对象上调用多个成员函数!</p><p>其实你已经这样做了很长时间了。考虑下面这个常见的示例，在这个示例中，您使用std::cout输出了多于一位的文本:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, "</span> &lt;&lt; userName;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的代码，std::cout是一个对象，而操作符&lt;&lt;是操作该对象的成员函数。编译器像这样计算上面的代码片段:</span></span><br><span class="line">(<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, "</span>) &lt;&lt; userName;</span><br></pre></td></tr></table></figure><p>首先，操作符&lt;&lt; 使用std::cout和字符串文字“Hello，”将“Hello”打印到控制台。但是，由于这是表达式的一部分，操作符&lt;&lt;也需要返回一个值(或void)。如果操作符&lt;&lt;返回void，您将得到以下结果:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">void</span>) &lt;&lt; userName;</span><br><span class="line"><span class="comment">//这显然没有任何意义(并且编译器会抛出一个错误)。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//相反，操作符&lt;&lt;返回 *this，在这个上下文中是std::cout对象。</span></span><br><span class="line"><span class="comment">//这样，在第一个运算符&lt;&lt;被求值后，我们得到:</span></span><br><span class="line">(<span class="built_in">std</span>::<span class="built_in">cout</span>) &lt;&lt; userName;</span><br></pre></td></tr></table></figure><p>这样，我们只需要指定对象一次(在本例中是std::cout)，每个函数调用都会将其传递给下一个要使用的函数，从而允许我们将多个命令链接在一起。</p><hr><p>我们可以自己实现这种行为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Calc() &#123;m_value = <span class="number">0</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; m_value += value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; m_value -= value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mult</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; m_value *= value; &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果你想加5，减3，再乘以4，你必须这样做:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Calc calc;</span><br><span class="line">    calc.add(<span class="number">5</span>); <span class="comment">// returns void</span></span><br><span class="line">    calc.sub(<span class="number">3</span>); <span class="comment">// returns void</span></span><br><span class="line">    calc.mult(<span class="number">4</span>); <span class="comment">// returns void</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; calc.getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>但是</strong>，如果我们让每个函数返回*this，我们可以将这些调用链接在一起。以下是新版本的Calc与“链”功能:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Calc() &#123; m_value = <span class="number">0</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Calc&amp; <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;m_value += value; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">    <span class="function">Calc&amp; <span class="title">sub</span><span class="params">(<span class="keyword">int</span> vaule)</span> </span>&#123;m_value -= value; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">    <span class="function">Calc&amp; <span class="title">mult</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; m_value *= value; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gerValue</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_value;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意，add()、sub()和mult()现在返回*this。因此，这使我们能够做到以下几点:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Calc calc;</span><br><span class="line">    calc.add(<span class="number">5</span>).sub(<span class="number">3</span>).mult(<span class="number">4</span>);  <span class="comment">//⭐</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; calc.getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>我们已经有效地将三行压缩成一个表达式! 让我们仔细看看它是<strong>如何工作的</strong>。</p><ul><li><p>首先，<code>calc.add(5)</code>被调用。</p><blockquote><p>它给<code>m_value.add ()</code>增加5，然后返回<code>*this</code>，它只是calc的一个引用。<strong>因此，calc将是后续计算中使用的对象。</strong></p></blockquote></li><li><p>然后，<code>calc.sub(3)</code>被执行。</p><blockquote><p>从m_value中减去3，再次返回calc。</p></blockquote></li><li><p>最后，执行<code>calc.mult(4)</code></p><blockquote><p>将<code>m_value</code>乘以4，然后返回calc。（它没有进一步使用，因此被忽略。）</p></blockquote></li></ul><p>由于每个函数在执行时都会修改calc，所以calc的m_value现在包含值((((0 + 5)- 3)* 4)，即8。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>“this”指针是隐式添加到任何<u>非静态成员函数</u>的隐藏参数。大多数情况下，您不需要直接访问它。</p><p>但是如果需要，您可以访问它。值得注意的是“this”是一个<strong>const指针</strong>——即，<strong>您可以更改它所指向的底层对象的<u>值</u>，但是您<u>不能让它指向其他对象</u>!</strong></p></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/db2095e5.html">C&C++/析构函数</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月8日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：1.5k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：5分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/8-7-destructors/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/8-7-destructors/</a></p><p><strong>析构函数(Destructors)</strong>是另一种特殊的类成员函数，<strong>它在类的对象被销毁时执行</strong>。</p><blockquote><p><strong>构造函数的设计目的是初始化类</strong>；而<strong>析构函数的设计目的是帮助清理类</strong>。</p></blockquote><hr><p>当一个对象通常超出作用域，或者使用delete关键字显式删除动态分配的对象时，会自动调用类析构函数(如果存在的话)，以便在从内存中删除对象之前进行任何必要的清理。</p><p><strong>对于简单的类 (那些只初始化普通成员变量值的类)，不需要析构函数</strong>，因为c++会自动为您清理内存。</p><p>然而,如果你的类对象持有任何资源 (如动态内存,或处理的文件或数据库) ,或者如果你需要做任何维护对象被摧毁之前, <strong>析构函数是完美的地方，因为它通常是发生在对象被销毁之前的最后一件事。</strong></p><h1 id="析构函数的命名"><a href="#析构函数的命名" class="headerlink" title="析构函数的命名"></a>析构函数的命名</h1><p>和构造函数一样，析构函数也有特定的命名规则：</p><ul><li>析构函数必须具有与类相同的名称，前面有一个波浪号(~)。</li><li>析构函数<strong>不能</strong>接受参数。</li><li>析构函数<strong>没有</strong>返回类型。</li></ul><p>注意，<strong>规则2意味着每个类只能存在一个析构函数</strong>，因为没有重载析构函数的方法（因为它们不能根据参数彼此区分。）</p><hr><p>通常，<u>您<strong>不应该</strong>显式地调用析构函数(因为当对象被销毁时，会自动调用它)</u>，因为很少有需要多次清理对象的情况。</p><p>然而，析构函数可以安全地调用其他成员函数，因为对象直到析构函数执行后才会被销毁。</p><p>来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	IntArray(<span class="keyword">int</span> length) <span class="comment">//构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		assert(length &gt; <span class="number">0</span>);</span><br><span class="line">		m_array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt;(length)]&#123;&#125;;</span><br><span class="line">		m_length = length;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~IntArray() <span class="comment">//析构函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//动态删除我们之前分配的数组</span></span><br><span class="line">		<span class="keyword">delete</span>[] m_array;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_array[index] = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_array[index];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getlength</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_length;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span>* m_array;</span><br><span class="line">	<span class="keyword">int</span> m_length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	IntArray arr&#123; <span class="number">10</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> count&#123; <span class="number">0</span> &#125;; count &lt; arr.getlength(); count++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr.setValue(count, count + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The value of element 5 is: "</span> &lt;&lt; arr.getValue(<span class="number">5</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">//类ar在这里被销毁，所以，析构函数~IntArray() 在这里被调用</span></span><br></pre></td></tr></table></figure><p>在第一行，我们实例化一个名为ar的新IntArray类对象，并传入一个长度为10的值。它调用构造函数，构造函数动态地为数组成员分配内存。我们必须在这里使用动态分配，因为在编译时我们不知道数组的长度是多少(调用者决定)。</p><p>在main()的末尾，ar超出了范围。这将导致调用~IntArray()析构函数，它将删除我们在构造函数中分配的数组!</p><h1 id="进一步看构造、析构-函数被调用的时间"><a href="#进一步看构造、析构-函数被调用的时间" class="headerlink" title="进一步看构造、析构 函数被调用的时间"></a>进一步看构造、析构 函数被调用的时间</h1><p>如前所述，在创建对象时调用构造函数，在销毁对象时调用析构函数。在下面的例子中，我们在构造函数和析构函数中使用<code>std::cout</code>语句来说明这一点:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_nID;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Simple(<span class="keyword">int</span> nID)</span><br><span class="line">        : m_nID&#123; nID &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Constructing Simple "</span> &lt;&lt; nID &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~Simple()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Destructing Simple"</span> &lt;&lt; m_nID &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getID</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_nID; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 在栈上分配一个Simple</span></span><br><span class="line">    Simple simple&#123; <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; simple.getID() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 动态分配一个Simple</span></span><br><span class="line">    Simple *pSimple&#123; <span class="keyword">new</span> Simple&#123; <span class="number">2</span> &#125; &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pSimple-&gt;getID() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 我们动态地分配了pSimple，所以我们必须删除它。</span></span><br><span class="line">    <span class="comment">//⭐【不推荐】请看下面的RAII中的讲解:"规则: 如果您的类动态分配内存，请使用RAII范型，不要动态分配类的对象 "</span></span><br><span class="line">    <span class="keyword">delete</span> pSimple;  <span class="comment">//在这里调用了析构函数</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// simple goes out of scope here  再次调用析构函数</span></span><br></pre></td></tr></table></figure><p>这个程序产生以下结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Constructing Simple 1</span><br><span class="line">1</span><br><span class="line">Constructing Simple 2</span><br><span class="line">2</span><br><span class="line">Destructing Simple 2</span><br><span class="line">Destructing Simple 1</span><br></pre></td></tr></table></figure><p>注意，“Simple 1”在“Simple 2”之后被销毁<strong>，因为我们在函数结束之前删除了pSimple，而Simple直到main()结束才被销毁。</strong></p><hr><p><strong>全局变量</strong>在main()之前构造，在main()之后销毁。</p><h1 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h1><p>*<em>RAII(资源获取即初始化) *</em>是一种编程技术，通过自动持续时间(例如，非动态分配的对象)将资源使用绑定到对象的生存期。</p><p>在c++中，RAII是通过具有 构造函数 和 析构函数 的<strong>类</strong>实现的。</p><p>资源 (如内存、文件或数据库句柄等) <u>通常是在对象的构造函数中获得的</u>(不过如果有意义的话，也可以在创建对象之后获得)。然后，可以在对象处于活动状态时使用该资源。当对象被销毁时，资源在析构函数中释放。</p><p><strong>RAII的主要优点</strong>是它有助于防止资源泄漏(例如内存未释放)，因为所有资源持有对象都被自动清除。</p><hr><p>本课顶部的<code>IntArray类</code>是一个实现RAII的类的例子——在构造函数中实现分配，在析构函数中实现释放。</p><p><code>std::string</code>和<code>std::vector</code>是标准库中遵循RAII的类的示例——动态内存在初始化时获得，在销毁时自动清除。</p><blockquote><p>规则:<strong>如果您的类动态分配内存，请使用RAII范型，不要动态分配类的对象</strong></p></blockquote><h1 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h1><p>正如您所看到的，<strong>当构造函数和析构函数一起使用时，您的类可以在它们自己之后初始化和清理，而程序员不需要做任何特殊的工作</strong>! 这减少了出错的可能性，并使类更易于使用。</p></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/8dd10d3c.html">C&C++/函数功能重叠--委托函数</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月8日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：1.6k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：6分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/8-6-overlapping-and-delegating-constructors/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/8-6-overlapping-and-delegating-constructors/</a></p><hr><h1 id="Overlapping"><a href="#Overlapping" class="headerlink" title="Overlapping"></a>Overlapping</h1><h2 id="含有重叠功能的构造函数"><a href="#含有重叠功能的构造函数" class="headerlink" title="含有重叠功能的构造函数"></a>含有重叠功能的构造函数</h2><p>当实例化一个新对象时，对象的构造函数被C++编译器隐式地调用。拥有多个具有重叠功能的构造函数的类并不少见。考虑以下类别:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该类有两个构造函数:一个默认构造函数和一个接受整数的构造函数。因为构造函数的“执行代码”部分是两个构造函数都需要的，所以代码在每个构造函数中重复。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// code to do A</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Foo(<span class="keyword">int</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// code to do A</span></span><br><span class="line">        <span class="comment">// code to do B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>正如您(希望)已经了解到的，尽可能避免出现重复的代码，所以让我们来看看解决这个问题的一些方法。</p><h2 id="解决重叠功能部分"><a href="#解决重叠功能部分" class="headerlink" title="解决重叠功能部分"></a>解决重叠功能部分</h2><h3 id="显而易见的解决方案在c-11之前是行不通的"><a href="#显而易见的解决方案在c-11之前是行不通的" class="headerlink" title="显而易见的解决方案在c++ 11之前是行不通的"></a>显而易见的解决方案在c++ 11之前是行不通的</h3><ol><li><p>最明显的解决方案是让Foo(int)构造函数调用Foo()构造函数来执行A部分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// code to do A</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Foo(<span class="keyword">int</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        Foo(); <span class="comment">// 使用上面的构造函数执行A(不起作用)</span></span><br><span class="line">        <span class="comment">// code to do B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>或者是这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// code to do A</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Foo(<span class="keyword">int</span> value): Foo() <span class="comment">// use the above constructor  to do A (在C++11之前，是行不通的)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// code to do B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>然而，对于预c++ 11编译器，如果您试图让一个构造函数调用另一个构造函数，<strong>它通常会编译，但它不会像您所期望的那样工作</strong>，并且您可能会花费很长时间试图找出原因，即使使用调试器也是如此。</p><blockquote><p>可能的一种解释：在C++ 11之前，从另一个构造函数显式地调用另一个构造函数 将创建一个临时对象，使用构造函数初始化临时对象，然后丢弃它，保持原始对象不变。</p></blockquote><h3 id="使用单独的函数"><a href="#使用单独的函数" class="headerlink" title="使用单独的函数"></a>使用单独的函数</h3><p><strong>C++ 允许构造函数调用类中的 <u>非构造函数</u>。但要注意，<u>非构造函数使用的任何成员都已经初始化了</u>。</strong>尽管您可能会试图将代码从第一个构造函数复制到第二个构造函数，但是有重复的代码会使您的类更难于理解，维护起来也更麻烦。<strong>此问题的最佳解决方案是创建一个非构造函数来执行公共初始化，并让两个构造函数都调用该函数。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// code to do A</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo()</span><br><span class="line">    &#123;</span><br><span class="line">        DoA();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Foo(<span class="keyword">int</span> nValue)</span><br><span class="line">    &#123;</span><br><span class="line">        DoA();</span><br><span class="line">        <span class="comment">// code to do B</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过这种方式，代码重复率被保持到最小。</p><hr><h4 id="将初始化部分代码分离出来"><a href="#将初始化部分代码分离出来" class="headerlink" title="将初始化部分代码分离出来"></a>将初始化部分代码分离出来</h4><p>您可能会发现自己处于这样一种情况:</p><p><strong>您想要编写一个成员函数来重新初始化一个类，使其返回默认值</strong>。</p><p>由于您可能已经有一个这样的构造函数，所以您可能会尝试从您的成员函数中调用构造函数。然而，试图直接调用构造函数通常会导致意外行为。许多开发人员只是简单地从初始化函数的构造函数中复制代码，这可以工作，但是会导致重复的代码。</p><p>在这种情况下，<strong>最好的解决方案是将代码从构造函数移到新函数中，并让构造函数调用该函数来完成初始化数据的工作:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo()</span><br><span class="line">    &#123;</span><br><span class="line">        Init();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Foo(<span class="keyword">int</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        Init();</span><br><span class="line">        <span class="comment">// do something with value</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// code to init Foo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>包含一个<code>Init()</code>函数是相当常见的，该函数将成员变量初始化为其默认值，然后让每个构造函数在执行特定于参数的任务<strong>之前</strong>调用<code>Init()</code>函数。这将最小化代码重复，并允许您在任何地方显式地调用<code>Init()</code>。</p><blockquote><p>一个小警告:</p><p>在使用<code>Init()</code>函数和 动态分配内存时要小心。因为<code>Init()</code>函数可以由任何人在任何时候调用，所以在调用<code>Init()</code>时，动态分配的内存可能已经分配，也可能还没有分配。</p><p>要注意适当地处理这种情况——这可能有点令人困惑，因为非空指针可以是动态分配的内存，也可以是未初始化的指针!</p></blockquote><h1 id="在c-11中委托构造函数"><a href="#在c-11中委托构造函数" class="headerlink" title="在c++ 11中委托构造函数"></a>在c++ 11中委托构造函数</h1><p>从c++ 11开始，<strong>允许构造函数调用其他构造函数</strong>。这个过程称为<strong>委托构造函数</strong>(或构<strong>造函数链</strong>)。</p><p>要让一个构造函数调用另一个构造函数，只需调用成员初始化器列表中的构造函数。在这种情况下，直接调用另一个构造函数是可以接受的。应用到我们上面的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//code to do A</span></span><br><span class="line">    &#125;</span><br><span class="line">    Foo(<span class="keyword">int</span> value) : Foo() <span class="comment">//使用 默认构造函数Foo() 来执行A</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//code to do B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>正如您所期望的那样。<strong>确保从成员初始化器列表调用构造函数，而不是在构造函数的主体中调用。</strong></p><p>下面是另一个使用委托构造函数来减少冗余代码的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_id;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Employee(<span class="keyword">int</span> id=<span class="number">0</span>; <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name=<span class="string">""</span>)</span><br><span class="line">        : m_id(id), m_name(name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Employee "</span> &lt;&lt; m_name &lt;&lt; <span class="string">" created.\n"</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用委托构造函数来最小化冗余代码</span></span><br><span class="line">     Employee(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name) : Employee(<span class="number">0</span>, name) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个类有两个构造函数，其中一个委托给Employee(int, const std::string &amp;)。通过这种方式，冗余代码的数量被最小化(我们只需要编写一个构造函数体，而不是两个)。</p><h2 id="附加说明"><a href="#附加说明" class="headerlink" title="附加说明"></a>附加说明</h2><p>关于委托构造函数的一些附加说明。</p><ul><li>首先，委托给另一个构造函数的构造函数本身不允许执行任何成员初始化。所以你的构造函数可以委托或初始化，<strong>但不能同时委托和初始化</strong>。</li><li>其次，一个构造函数可以委托给另一个构造函数，后者再委托给第一个构造函数。这形成了一个无限循环，并将导致您的程序运行堆栈空间和崩溃。<strong>可以通过确保所有构造函数都解析为非委托的构造函数来避免这种情况。</strong></li></ul></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/4635f066.html">C&C++/非静态成员初始化</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月8日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：838字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：3分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-programming/8-5b-non-static-member-initialization/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-programming/8-5b-non-static-member-initialization/</a></p><hr><p>当编写一个具有多个构造函数的类(大多数构造函数)时，必须为每个构造函数中的所有成员指定默认值，这会导致代码冗余。<strong>如果更新成员的默认值，则需要修改每个构造函数</strong>。</p><p>从c++ 11开始，可以直接给<strong>普通的类成员变量(那些不使用static关键字的变量)</strong>一个默认的初始值:</p><blockquote><p>注意，使用非静态成员初始化 来 初始化成员 需要使用<strong>等号</strong>或<strong>大括号(统一)初始化器</strong>，但是<strong>直接初始化表（即，使用小括号）单在这里不起作用</strong>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//给这些普通的类成员变量(那些不使用static关键字的变量)一个默认的初始值:</span></span><br><span class="line">    <span class="comment">//注意：你可以用：“=” 或 “大括号(统一初始化)”</span></span><br><span class="line">    <span class="comment">//	   但是，"直接初始化(即，使用小括号)" 在这里是不能用的。⭐</span></span><br><span class="line">    <span class="keyword">double</span> m_length&#123; <span class="number">1.0</span> &#125;; <span class="comment">// m_length has a default value of 1.0</span></span><br><span class="line">    <span class="keyword">double</span> m_width&#123; <span class="number">1.0</span> &#125;; <span class="comment">// m_width has a default value of 1.0</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"length: "</span> &lt;&lt; m_length &lt;&lt; <span class="string">", width: "</span> &lt;&lt; m_width &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rectangle x&#123;&#125;; <span class="comment">// x.m_length = 1.0, x.m_width = 1.0</span></span><br><span class="line">    x.<span class="built_in">print</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">length: <span class="number">1.0</span>, <span class="built_in">width</span>: <span class="number">1.0</span></span><br></pre></td></tr></table></figure><p>非静态成员初始化 (也称为类内成员初始化) 为您的成员变量提供默认值，<strong>如果构造函数没有为成员本身提供初始化值(通过成员初始化列表)，则构造函数将使用这些值。</strong></p><hr><h1 id="构造函数仍然决定可以创建什么类型的对象"><a href="#构造函数仍然决定可以创建什么类型的对象" class="headerlink" title="构造函数仍然决定可以创建什么类型的对象"></a>构造函数仍然决定可以创建什么类型的对象</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_length&#123; <span class="number">1.0</span> &#125;;</span><br><span class="line">    <span class="keyword">double</span> m_width&#123; <span class="number">1.0</span> &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//注意:本例中没有提供默认构造函数</span></span><br><span class="line">    Rectangle(<span class="keyword">double</span> length, <span class="keyword">double</span> <span class="built_in">width</span>)</span><br><span class="line">        : m_length&#123; length &#125;, m_width&#123; <span class="built_in">width</span> &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// m_length and m_width 由构造函数初始化(不使用默认值)</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"length: "</span> &lt;&lt; m_length &lt;&lt; <span class="string">", width: "</span> &lt;&lt; m_width &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rectangle x&#123;&#125;; <span class="comment">//✖，将不会被编译。因为不存在默认的构造函数，所以不能用这种形式。（即使成员有默认的初始化值，但是它不是默认的构造函数提供的）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>尽管我们为所有成员提供了默认值，但是没有提供默认构造函数，所以我们无法创建没有参数的Rectangle对象。</strong></p><h1 id="构造函数的初始化器列表-优先于-默认初始值"><a href="#构造函数的初始化器列表-优先于-默认初始值" class="headerlink" title="构造函数的初始化器列表 优先于 默认初始值"></a>构造函数的初始化器列表 优先于 默认初始值</h1><p><strong>如果提供了默认初始值，同时也提供了 构造函数通过成员初始化器列表初始化成员，则成员初始化器列表优先</strong>。下面的例子说明了这一点:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_length&#123; <span class="number">1.0</span> &#125;;</span><br><span class="line">    <span class="keyword">double</span> m_width&#123; <span class="number">1.0</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Rectangle(<span class="keyword">double</span> length, <span class="keyword">double</span> <span class="built_in">width</span>)</span><br><span class="line">        : m_length&#123; length &#125;,</span><br><span class="line">          m_width&#123; <span class="built_in">width</span> &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//m_length and m_width 由构造函数初始化(不使用默认值)</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     Rectangle(<span class="keyword">double</span> length)</span><br><span class="line">        : m_length&#123; length &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// m_length 由构造函数初始化.</span></span><br><span class="line">        <span class="comment">// m_width's 使用默认的值(1.0)</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"length: "</span> &lt;&lt; m_length &lt;&lt; <span class="string">", width: "</span> &lt;&lt; m_width &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rectangle x&#123; <span class="number">2.0</span>, <span class="number">3.0</span> &#125;;</span><br><span class="line">    x.<span class="built_in">print</span>();</span><br><span class="line">    </span><br><span class="line">    Rectangle y&#123; <span class="number">4.0</span> &#125;;</span><br><span class="line">    y.<span class="built_in">print</span>();  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">length: <span class="number">2.0</span>, <span class="built_in">width</span>: <span class="number">3.0</span></span><br><span class="line">length: <span class="number">4.0</span>, <span class="built_in">width</span>: <span class="number">1.0</span></span><br></pre></td></tr></table></figure></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/781f4530.html">C&C++/构造函数</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月8日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：4.5k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：18分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/85-constructors/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/85-constructors/</a></p><hr><p>当一个类（或结构体）的所有成员都是<code>public</code>时，我们可以使用：</p><ul><li>初始化列表（initialization list ）</li><li>或者，统一初始化（uniform initialization）</li></ul><p>来初始化这个类（或结构体）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_x;</span><br><span class="line">    <span class="keyword">int</span> m_y;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo foo1 = &#123; <span class="number">4</span>, <span class="number">5</span> &#125;; <span class="comment">// initialization list</span></span><br><span class="line">    Foo foo2 &#123; <span class="number">6</span>, <span class="number">7</span> &#125;; <span class="comment">// uniform initialization</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是<strong>，一旦我们将任何成员变量设为私有，我们就不能再以这种方式初始化类了。</strong>这是有意义的:如果你不能直接访问一个变量(因为它是私有的)，讲道理你是不能够直接初始化它。</p><p>那么我们如何用私有成员变量初始化一个类呢? <strong>答案是通过构造函数。</strong></p><h1 id="构造函数-Constructor"><a href="#构造函数-Constructor" class="headerlink" title="构造函数(Constructor)"></a>构造函数(<strong>Constructor</strong>)</h1><p><strong>构造函数是</strong>一种特殊的 类成员函数，在实例化该类的对象时自动调用。</p><p><strong>构造函数</strong>通常<u>用于</u>初始化类的成员变量，使其具有适当的默认值或用户提供的值，或执行使用类所需的任何设置步骤(例如打开文件或数据库)。</p><p>与普通成员函数不同，构造函数有特定的<strong>命名规则</strong>：</p><ol><li>构造函数必须具有与类相同的名字(使用相同的大小写)</li><li>构造函数没有返回类型(甚至不是void)</li></ol><hr><h1 id="默认的构造函数"><a href="#默认的构造函数" class="headerlink" title="默认的构造函数"></a>默认的构造函数</h1><p><u>不接受参数</u>的构造函数 (或所有参数都有默认值的构造函数) 称为<strong>默认构造函数</strong>。</p><p>如果没有提供 <u>用户提供的初始化值</u>，则调用默认构造函数。</p><p>一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_numerator;</span><br><span class="line">    <span class="keyword">int</span> m_denominator;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Fraction() <span class="comment">// default constructor</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_numerator = <span class="number">0</span>;</span><br><span class="line">        m_denominator = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumerator</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_numerator;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDenominator</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_denominator;&#125;</span><br><span class="line">    <span class="keyword">double</span> getValue &#123;<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(m_numerator) / m_denominator; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Fraction frac; <span class="comment">//由于没有实参，所以会默认调用Fraction()</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; frac.getNumerator() &lt;&lt; <span class="string">"/"</span> &lt;&lt; frac.getDenominator() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">0</span>/<span class="number">1</span></span><br></pre></td></tr></table></figure><p>上面例子中，因为我们正在实例化一个没有参数的Fraction类型的对象，所以在为该对象分配内存之后，将立即调用默认构造函数，并初始化我们的对象。</p><blockquote><p>注意，我们的numerator和denominator是用默认构造函数中设置的值初始化的! 如果没有默认的构造函数，numerator和denominator就会有垃圾值，直到我们显式地为它们分配合理的值，或者通过其他方法初始化它们(记住: 默认情况下不会初始化基本变量)。</p></blockquote><hr><h1 id="接收参数的构造函数"><a href="#接收参数的构造函数" class="headerlink" title="接收参数的构造函数"></a>接收参数的构造函数</h1><p>虽然默认构造函数对于确保用合理的默认值初始化类非常有用。</p><p><u>但通常我们希望类的实例具有我们提供的特定值</u>。幸运的是，<u>还可以用参数声明构造函数。</u>下面是一个构造函数的例子，它使用两个整数参数来初始化分子和分母:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_numerator;</span><br><span class="line">	<span class="keyword">int</span> m_denominator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Fraction() <span class="comment">// default constructor</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_numerator = <span class="number">0</span>;</span><br><span class="line">		m_denominator = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//带有两个形参的构造函数，其中一个形参有默认的值⭐</span></span><br><span class="line">	Fraction(<span class="keyword">int</span> numerator, <span class="keyword">int</span> denominator = <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		assert(denominator != <span class="number">0</span>);</span><br><span class="line">		m_numerator = numerator;</span><br><span class="line">		m_denominator = denominator;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getNumerator</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_numerator; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getDenominator</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_denominator; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(m_numerator) / m_denominator; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意，我们现在有<strong>两个构造函数</strong>:</p><ul><li>一个是默认情况下调用的默认构造函数，</li><li>另一个是接受两个参数的构造函数。</li></ul><p>由于<u>函数重载</u>，这两个构造函数可以在同一个类中和平共处。实际上，只要每个构造函数都有唯一的签名 (参数的数量和类型)， 就可以定义任意数量的构造函数。</p><h2 id="如何使用带有参数的构造函数"><a href="#如何使用带有参数的构造函数" class="headerlink" title="如何使用带有参数的构造函数"></a>如何使用带有参数的构造函数</h2><p>我们可以直接使用 括号 或 直接初始化:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fraction fiveThirds&#123; <span class="number">5</span>, <span class="number">3</span> &#125;; <span class="comment">// 使用大括号 initialization, calls Fraction(int, int)【推荐⭐】</span></span><br><span class="line"><span class="function">Fraction <span class="title">threeQuarters</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>; <span class="comment">// 直接初始化, also calls Fraction(int, int)</span></span><br></pre></td></tr></table></figure><p>注意，<strong>我们给了构造函数的第二个参数一个默认值</strong>，<u>所以下面的操作也是合法</u>的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fraction six&#123; <span class="number">6</span> &#125;; <span class="comment">// calls Fraction(int, int) constructor, 第二个参数使用默认值</span></span><br></pre></td></tr></table></figure><hr><h1 id="在类中使用“-”来复制初始化（C-11之前）"><a href="#在类中使用“-”来复制初始化（C-11之前）" class="headerlink" title="在类中使用“=”来复制初始化（C++11之前）"></a>在类中使用“=”来复制初始化（C++11之前）</h1><p>本节只在您使用<strong>比c++ 11更老的标准</strong>时才有意义。</p><p>与基本变量非常相似，也可以使用复制初始化来初始化类:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fraction six = Fraction&#123; <span class="number">6</span> &#125;; <span class="comment">// Copy initialize a Fraction, will call Fraction(6, 1)</span></span><br><span class="line">Fraction seven = <span class="number">7</span>; <span class="comment">//复制初始化一个Fraction。编译器将尝试找到一种方法将7转换成Fraction，这将调用分数(7,1)构造函数。</span></span><br></pre></td></tr></table></figure><blockquote><p>但是，我们建议您<strong>避免对类进行这种形式的初始化</strong>，因为它的效率可能比较低。虽然直接初始化、统一初始化和复制初始化与基本类型的工作方式相同，但是复制初始化与类的工作方式不同(尽管最终结果通常相同)。我们将在以后的章节中更详细地探讨这些差异</p></blockquote><h1 id="减少构造函数的个数"><a href="#减少构造函数的个数" class="headerlink" title="减少构造函数的个数"></a>减少构造函数的个数</h1><p>在上面的Fraction类的 <u>双</u>构造函数 声明中，默认构造函数实际上有些多余。我们可以将这个类简化如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_numerator;</span><br><span class="line">    <span class="keyword">int</span> m_denominator;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Default constructor</span></span><br><span class="line">    Fraction(<span class="keyword">int</span> numerator=<span class="number">0</span>, <span class="keyword">int</span> denominator=<span class="number">1</span>) <span class="comment">//⭐</span></span><br><span class="line">    &#123;</span><br><span class="line">        assert(denominator != <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">        m_numerator = numerator;</span><br><span class="line">        m_denominator = denominator;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumerator</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_numerator; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDenominator</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_denominator; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(m_numerator) / m_denominator; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>尽管这个构造函数仍然是一个默认的构造函数，但是现在它已经被定义为可以接受 一个 或 两个 用户提供的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Fraction zero; <span class="comment">// will call Fraction(0, 1)</span></span><br><span class="line">Fraction zero&#123;&#125;; <span class="comment">// will call Fraction(0, 1)</span></span><br><span class="line">Fraction six&#123; <span class="number">6</span> &#125;; <span class="comment">// will call Fraction(6, 1)</span></span><br><span class="line">Fraction fiveThirds&#123; <span class="number">5</span>, <span class="number">3</span> &#125;; <span class="comment">// will call Fraction(5, 3)</span></span><br></pre></td></tr></table></figure><h1 id="隐式生成的默认构造函数"><a href="#隐式生成的默认构造函数" class="headerlink" title="隐式生成的默认构造函数"></a>隐式生成的默认构造函数</h1><p><strong>如果你的类没有构造函数，c++会自动为你生成一个public的默认构造函数。</strong>这有时被称为<u>隐式构造函数(或隐式生成的构造函数)</u>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_year;</span><br><span class="line">    <span class="keyword">int</span> m_month;</span><br><span class="line">    <span class="keyword">int</span> m_day;	  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用户没有提供构造函数，编译器将会生成一个默认的构造函数（即，不带参数的构造函数）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个特殊的隐式构造函数允许我们创建一个没有参数的Date对象，但是不初始化任何成员(因为所有的成员都是基本类型，它们在创建时不会初始化)。</p><blockquote><p>如果Date有自己是类类型的成员，例如std::string，那么这些成员的构造函数将被自动调用。</p></blockquote><p>看一个例子：（为了确保成员变量得到初始化，我们可以在它们的声明中初始化它们。）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_year&#123; <span class="number">1900</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> m_month&#123; <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> m_day&#123; <span class="number">1</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>虽然你看不到隐式生成的构造函数，但你可以证明它的存在:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_year&#123; <span class="number">1900</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> m_month&#123; <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> m_day&#123; <span class="number">1</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// No constructor provided, so C++ creates a public default constructor for us</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Date date&#123;&#125;; <span class="comment">// calls implicit constructor⭐</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="当类中有任何显式构造函数，则不会提供隐式构造函数"><a href="#当类中有任何显式构造函数，则不会提供隐式构造函数" class="headerlink" title="当类中有任何显式构造函数，则不会提供隐式构造函数"></a>当类中有任何显式构造函数，则不会提供隐式构造函数</h2><p>如果您的类有任何其他构造函数，则不会提供隐式生成的构造函数。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_year&#123; <span class="number">1900</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> m_month&#123; <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> m_day&#123; <span class="number">1</span> &#125;;  </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    Date(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day) <span class="comment">// normal non-default constructor</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_year = year;</span><br><span class="line">        m_month = month;</span><br><span class="line">        m_day = day;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">//由于上面已经有了一个显式的构造函数，所以就不会再提供隐式的构造函数了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Date date&#123;&#125;; <span class="comment">//错误:不能实例化对象，因为默认构造函数不存在，编译器也不会再生成默认构造函数（因为有显式的构造函数）</span></span><br><span class="line">    </span><br><span class="line">    Date today&#123; <span class="number">2020</span>, <span class="number">1</span>, <span class="number">19</span> &#125;; <span class="comment">// today is initialized to Jan 19th, 2020</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="显式的添加默认构造函数"><a href="#显式的添加默认构造函数" class="headerlink" title="显式的添加默认构造函数"></a>显式的添加默认构造函数</h1><p>要允许构造一个<strong>没有参数</strong>的<code>Date</code>，可以：</p><ul><li>向构造函数添加默认参数，</li><li>添加一个空的默认构造函数，</li><li>或者<strong>显式地添加一个默认构造函数。</strong>【推荐⭐】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_year&#123; <span class="number">1900</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> m_month&#123; <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> m_day&#123; <span class="number">1</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//告诉编译器创建一个默认构造函数，即使还有用户提供其他的构造函数。</span></span><br><span class="line">    Date() = <span class="keyword">default</span>; <span class="comment">//注意这个default⭐</span></span><br><span class="line"> </span><br><span class="line">    Date(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day) <span class="comment">// normal non-default constructor</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_year = year;</span><br><span class="line">        m_month = month;</span><br><span class="line">        m_day = day;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Date date&#123;&#125;; <span class="comment">// date is initialized to Jan 1st, 1900</span></span><br><span class="line">    Date today&#123; <span class="number">2020</span>, <span class="number">10</span>, <span class="number">14</span> &#125;; <span class="comment">// today is initialized to Oct 14th, 2020</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>使用<code>= default</code></strong>与添加一个空主体的默认构造函数几乎是一样的。唯一的区别是<code>= default</code>允许我们安全地初始化成员变量，即使它们没有初始化器:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Date() = <span class="keyword">default</span>; <span class="comment">//显示的默认构造函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// note: 成员声明中没有初始化</span></span><br><span class="line">	<span class="keyword">int</span> m_year;</span><br><span class="line">	<span class="keyword">int</span> m_month;</span><br><span class="line">	<span class="keyword">int</span> m_day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//用户提供的空的构造函数</span></span><br><span class="line">	Date2();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// note: 成员声明中没有初始化</span></span><br><span class="line">	<span class="keyword">int</span> m_year;</span><br><span class="line">	<span class="keyword">int</span> m_month;</span><br><span class="line">	<span class="keyword">int</span> m_day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Date today&#123;&#125;; <span class="comment">//将会是：0, 0, 0 ⭐</span></span><br><span class="line">	Date2 tommorrow&#123;&#125;; <span class="comment">//tommorrow 的成员没有初始化⭐</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="类包含类"><a href="#类包含类" class="headerlink" title="类包含类"></a>类包含类</h1><p>一个类可以包含其他类作为成员变量。默认情况下，在构造外部类时，成员变量将调用它们的默认构造函数。这发生在构造函数体执行之前。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A m_a; <span class="comment">// B contains A as a member variable</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure><p>在构造变量b时，调用b()构造函数。在执行构造函数体<strong>之前</strong>，<code>m_a</code>被初始化 (它需要调用class A的构造函数来初始化)，这个打印“A”。然后，返回到B构造函数，并执行B构造函数的主体。</p><blockquote><p>当你考虑它时，这是有意义的，<strong>因为B()构造函数可能想要使用变量m_a——所以m_a最好先初始化!</strong></p></blockquote><h2 id="类类型-class-type-的成员会被初始化"><a href="#类类型-class-type-的成员会被初始化" class="headerlink" title="类类型(class-type)的成员会被初始化"></a>类类型(class-type)的成员会被初始化</h2><p>与前一节中最后一个示例的不同之处在于<code>m_a</code>是一个<strong>类类型</strong>。<strong>即使我们没有显式地初始化类类型成员，它们也会被初始化。</strong></p><h1 id="构造函数重点"><a href="#构造函数重点" class="headerlink" title="构造函数重点"></a>构造函数重点</h1><ul><li><p>许多新程序员对<strong>构造函数是否创建对象</strong>感到困惑。它们不是——<strong>编译器在构造函数调用<u>之前</u>为对象设置内存分配。</strong></p></li><li><p>构造函数实际上有两个用途。</p><ul><li>首先，构造函数决定谁可以创建对象。也就是说<strong>，只有在找到匹配的构造函数时才能创建类的对象。</strong></li><li>其次，构造函数可以用来初始化对象。构造函数是否进行初始化取决于程序员。从语法上来说，构造函数完全不进行初始化是有效的(构造函数的作用仍然是允许创建对象，如上所述)。</li></ul></li><li><p>最后，<strong>构造函数只在创建对象时用于初始化</strong>。您<strong>不应该</strong>尝试<strong>调用构造函数来重新初始化现有对象</strong>。虽然它可以编译，但结果不是您想要的(相反，编译器将创建一个临时对象，然后丢弃它)。</p></li></ul><hr><h1 id="————————————–"><a href="#————————————–" class="headerlink" title="————————————–"></a>————————————–</h1><h1 id="构造函数的成员初始化器列表"><a href="#构造函数的成员初始化器列表" class="headerlink" title="构造函数的成员初始化器列表"></a>构造函数的成员初始化器列表</h1><p>原文：<a href="https://www.learncpp.com/cpp-tutorial/8-5a-constructor-member-initializer-lists/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/8-5a-constructor-member-initializer-lists/</a></p><hr><p>c++提供了一种通过<strong>成员初始化列表</strong>(通常称为“成员初始化列表”)来初始化类成员变量的方法 (而不是在它们创建之后给它们赋值)。</p><blockquote><p>不要将它们与我们可以用来为数组赋值的类似命名的初始化器列表混淆。</p><hr><p>在 <a href="https://www.learncpp.com/cpp-tutorial/variable-assignment-and-initialization/" target="_blank" rel="noopener">1.4 – Variable assignment and initialization</a>中，您了解了可以通过三种方式初始化变量:</p><ul><li>复制；</li><li>直接；</li><li>和统一初始化。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = <span class="number">1</span>; <span class="comment">//拷贝初始化</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">value2</span> <span class="params">(<span class="number">2.2</span>)</span></span>; <span class="comment">//直接吃石化</span></span><br><span class="line"><span class="keyword">char</span> value3 &#123;<span class="string">'c'</span>&#125;;  <span class="comment">//统一初始化</span></span><br></pre></td></tr></table></figure><p>在类中使用初始化列表 几乎与<strong>直接初始化</strong>或<strong>统一初始化</strong>相同。</p></blockquote><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.我们之前是这样写的：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_value1;</span><br><span class="line">	<span class="keyword">double</span> m_value2;</span><br><span class="line">	<span class="keyword">char</span> m_value3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Something()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 这些都是赋值，不是初始化</span></span><br><span class="line">		m_value1 = <span class="number">1</span>;</span><br><span class="line">		m_value2 = <span class="number">2.2</span>;</span><br><span class="line">		m_value3 = <span class="string">'c'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">//2.现在来改进（使用初始化列表）：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_value1;</span><br><span class="line">	<span class="keyword">double</span> m_value2;</span><br><span class="line">	<span class="keyword">char</span> m_value3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Something() : m_value1&#123; <span class="number">1</span> &#125;, m_value2&#123; <span class="number">2</span> &#125;, m_value3&#123; <span class="string">'c'</span> &#125;<span class="comment">//⭐</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 这里就不再需要赋值了</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>成员初始化器列表被插入到构造函数参数之后。<strong>它以冒号(:)开头</strong>，<strong>然后列出要初始化的每个变量以及该变量的值</strong>，<strong>中间用逗号分隔</strong>，<u>最后没有分号</u>。⭐</p><hr><p>注意，我们不再需要在构造函数体中执行赋值，因为初始化器列表将替换该功能。还要注意，初始化器列表不是以分号结束的。</p><h2 id="当用户传入初始值时"><a href="#当用户传入初始值时" class="headerlink" title="当用户传入初始值时"></a>当用户传入初始值时</h2><p>当然，当我们允许调用者传入初始值时，构造函数更有用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value1;</span><br><span class="line">    <span class="keyword">double</span> m_value2;</span><br><span class="line">    <span class="keyword">char</span> m_value3;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Something(<span class="keyword">int</span> value1, <span class="keyword">double</span> value2, <span class="keyword">char</span> value3=<span class="string">'c'</span>)</span><br><span class="line">        : m_value1&#123; value1 &#125;, m_value2&#123; value2 &#125;, m_value3&#123; value3 &#125; <span class="comment">//⭐ directly initialize our member variables</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// No need for assignment here</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Something("</span> &lt;&lt; m_value1 &lt;&lt; <span class="string">", "</span> &lt;&lt; m_value2 &lt;&lt; <span class="string">", "</span> &lt;&lt; m_value3 &lt;&lt; <span class="string">")\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Something something&#123; <span class="number">1</span>, <span class="number">2.2</span> &#125;; <span class="comment">// value1 = 1, value2=2.2, value3 gets default value 'c'</span></span><br><span class="line">    something.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Something(<span class="number">1</span>, <span class="number">2.2</span>, c)</span><br></pre></td></tr></table></figure><p>注意，<strong>您可以使用默认参数来提供一个默认值，以防用户没有传入一个值。</strong></p><h2 id="初始化const变量"><a href="#初始化const变量" class="headerlink" title="初始化const变量"></a>初始化const变量</h2><p>面是一个拥有const成员变量的类的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m_value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    something() : m_value&#123;<span class="number">5</span>&#125; <span class="comment">//✔。直接初始化我们的const成员变量</span></span><br><span class="line">    &#123;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是可行的，因为我们<strong>可以初始化const变量 (但不能赋值给它们!)</strong></p><h2 id="使用成员初始化器列表初始化数组成员"><a href="#使用成员初始化器列表初始化数组成员" class="headerlink" title="使用成员初始化器列表初始化数组成员"></a>使用成员初始化器列表初始化数组成员</h2><p>一个有数组成员的类:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m_array[<span class="number">5</span>];</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>在C++ 11之前</strong>，你只能通过一个成员初始化列表使一个数组成员 <strong>归零:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m_array[<span class="number">5</span>];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    something() : m_array&#123;&#125;</span><br><span class="line">    &#123;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从C++11开始，你可以完全初始化一个成员数组 使用统一初始化:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m_array[<span class="number">5</span>];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    something() : m_array&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; <span class="comment">//使用统一初始化来初始化我们的成员数组</span></span><br><span class="line">    &#123;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="初始化在其他类中定义的成员变量"><a href="#初始化在其他类中定义的成员变量" class="headerlink" title="初始化在其他类中定义的成员变量"></a>初始化在其他类中定义的成员变量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> x) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"A "</span>&lt;&lt;x&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A m_a;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    B(<span class="keyword">int</span> y) : m_a &#123;y<span class="number">-1</span>&#125;  <span class="comment">//调用 A(int)构造函数 初始化成员m_a</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b&#123;<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">A <span class="number">4</span></span><br><span class="line">B <span class="number">5</span></span><br></pre></td></tr></table></figure><p>构造变量b时，使用值5调用 b(int)构造函数。在该构造函数体执行之前，m_a先被初始化 用值4调用A(int)构造函数，即打印“A 4”。<em>：</em>然后，将结果返回到B构造函数，并执行B构造函数的主体，打印“B 5”。</p><h2 id="格式化初始化器列表"><a href="#格式化初始化器列表" class="headerlink" title="格式化初始化器列表"></a>格式化初始化器列表</h2><p>在如何格式化初始化器列表方面，c++提供了很大的灵活性，这实际上取决于您想如何继续。但这里有一些建议:</p><ul><li><p>如果初始化器列表和函数名在同一行，那么把所有东西都放在一行就可以了:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value1;</span><br><span class="line">    <span class="keyword">double</span> m_value2;</span><br><span class="line">    <span class="keyword">char</span> m_value3;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    something() : m_value1&#123; <span class="number">1</span> &#125;, m_value2&#123; <span class="number">2.2</span> &#125;, m_value3&#123; <span class="string">'c'</span> &#125; <span class="comment">// everything on one line</span></span><br><span class="line">    &#123;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>如果初始化器列表与函数名不在同一行，那么在下一行应该是缩进的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value1;</span><br><span class="line">    <span class="keyword">double</span> m_value2;</span><br><span class="line">    <span class="keyword">char</span> m_value3;    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    something(<span class="keyword">int</span> value1, <span class="keyword">double</span> value2, <span class="keyword">char</span> value3=<span class="string">'c'</span>) <span class="comment">//这一行上已经有很多东西了</span></span><br><span class="line">        : m_value1&#123; value1 &#125;, m_value2&#123; value2 &#125;, m_value3&#123; value3 &#125;  <span class="comment">//所以，我们可以把剩下的内容缩进到下一行</span></span><br><span class="line">    &#123;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>如果所有的初始值设定项都不在一行中(或者初始值设定项不是普通的)，那么你可以把它们隔开，每行一个:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value1;</span><br><span class="line">    <span class="keyword">double</span> m_value2;</span><br><span class="line">    <span class="keyword">char</span> m_value3;</span><br><span class="line">    <span class="keyword">float</span> m_value4;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    something(<span class="keyword">int</span> value1, <span class="keyword">double</span> value2, <span class="keyword">char</span> value3=<span class="string">'c'</span>, <span class="keyword">float</span> value4=<span class="number">34.6f</span>)  <span class="comment">//这一行上已经有很多东西了</span></span><br><span class="line">        : m_value1&#123; value1 &#125;, <span class="comment">//一行一个，每行末尾有一个逗号</span></span><br><span class="line">        m_value2&#123; value2 &#125;,</span><br><span class="line">        m_value3&#123; value3 &#125;,</span><br><span class="line">        m_value4&#123; value4 &#125; </span><br><span class="line">    &#123;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="初始化器列表顺序"><a href="#初始化器列表顺序" class="headerlink" title="初始化器列表顺序"></a>初始化器列表顺序</h2></li></ul><p>可能令人惊讶的是，初始化器列表中的变量 <u>没有</u> 按照初始化程序列表中指定的顺序初始化。相反，它们是按照在类中声明它们的顺序初始化的。</p><p>为取得最佳效果，应遵循以下建议:</p><ul><li>不要以这样的方式初始化成员变量，即它们依赖于首先初始化的其他成员变量 (换句话说，确保您的成员变量将正确初始化，即使初始化顺序不同)。</li><li>在初始化器列表中以与在类中声明变量相同的顺序初始化变量。只要遵循前面的建议，这并不是严格要求的，但是如果您不这样做，并且打开了所有警告（自己对警告级别的设置），那么编译器可能会给您一个警告。</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>成员初始化器列表允许我们初始化成员，而不是给它们赋值。</strong></p><p>这是初始化那些在初始化时需要值的成员 (如const或引用成员) 的<strong>唯一方法</strong>，</p><p>而且它比在构造函数体中赋值更有性能。<strong>成员初始化器列表既适用于基本类型，也适用于本身就是类的成员。</strong></p></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/1459e5c7.html">C&C++/访问函数及封装</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月7日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：692字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：2分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><h1 id="为什么要将成员变量设为私有"><a href="#为什么要将成员变量设为私有" class="headerlink" title="为什么要将成员变量设为私有?"></a>为什么要将成员变量设为私有?</h1><p>在前一课中，我们提到类成员变量通常是私有的。学习面向对象编程的开发人员通常很难理解为什么要这样做。为了回答这个问题，让我们从一个类比开始。</p><p>在现代生活中，我们可以使用许多电子设备。你的电视有一个遥控器，你可以用它来开/关电视。你开车(或踏板车)去上班。你用智能手机拍照。这三样东西都使用一个常见的模式: 它们提供了一个简单的界面供您使用(按钮、方向盘等)来执行操作。</p><p>然而，这些设备实际上是如何操作的对你来说是隐藏的。当你按下遥控器上的按钮时，你不需要知道它在做什么来和你的电视交流。当你踩下汽车的油门踏板时，你不需要知道内燃机是如何使车轮转动的。当你拍照时，你不需要知道传感器如何将光线收集到像素化的图像中。</p><p><strong>这种接口和实现的分离非常有用，因为它允许我们在不了解对象如何工作的情况下使用对象。这极大地降低了使用这些对象的复杂性，并增加了我们能够与之交互的对象的数量。</strong></p><p>出于类似的原因，<strong>实现 和 接口的分离 在编程中也很有用。</strong></p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>在面向对象编程中，<strong>封装(也称为信息隐藏)</strong>是这样一个过程：</p><p>它将对象实现的细节隐藏起来，不让对象的用户看到。相反，对象的用户通过公共接口访问对象。通过这种方式，用户可以使用对象，而不必了解它是如何实现的。</p><p><strong>在c++中，我们通过访问说明符来实现封装。</strong>通常，<strong>类的所有成员变量都是私有的(隐藏实现细节)</strong>，<strong>而大多数成员函数是公共的(为用户公开接口)。</strong>虽然要求类的用户使用公共接口似乎比直接提供对成员变量的公共访问更麻烦，但这样做实际上提供了大量有用的好处，有助于鼓励类的可重用性和可维护性。</p><blockquote><p>注意:“封装”一词有时也用来指将数据和处理该数据的函数打包在一起。我们更倾向于称之为面向对象编程。</p></blockquote><h2 id="封装的好处"><a href="#封装的好处" class="headerlink" title="封装的好处"></a>封装的好处</h2><ul><li>封装类更容易使用，并降低了程序的复杂性</li><li>封装类有助于保护您的数据和防止误用</li><li>封装类更容易调试</li></ul></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/5ded0966.html">C&C++/匿名函数</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月7日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：6k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：25分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/introduction-to-lambdas-anonymous-functions/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/introduction-to-lambdas-anonymous-functions/</a></p><p><strong>匿名函数：lambdas（anonymous functions）</strong></p><hr><p>考虑一下我们在之前课程中介绍的这段代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">containsNut</span><span class="params">(<span class="built_in">std</span>::string_view str)</span> <span class="comment">// static 是指在这个上下文中的内部链接</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// std::string_view::find returns std::string_view::npos if it doesn't find</span></span><br><span class="line">  <span class="comment">// the substring. Otherwise it returns the index where the substring occurs</span></span><br><span class="line">  <span class="comment">// in str.</span></span><br><span class="line">  <span class="keyword">return</span> (str.<span class="built_in">find</span>(<span class="string">"nut"</span>) != <span class="built_in">std</span>::string_view::npos);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::string_view, 4&gt; arr&#123; <span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"walnut"</span>, <span class="string">"lemon"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// std::find_if takes a pointer to a function</span></span><br><span class="line">  <span class="keyword">auto</span> found&#123; <span class="built_in">std</span>::find_if(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), containsNut) &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (found == arr.<span class="built_in">end</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"No nuts\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Found "</span> &lt;&lt; *found &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Found walnut</span><br></pre></td></tr></table></figure><p>其实这个可以被改进：</p><p>这里问题的根源是<code>std::find_if</code>要求我们给它传递一个函数指针。</p><h1 id="函数不能嵌套"><a href="#函数不能嵌套" class="headerlink" title="函数不能嵌套"></a>函数不能嵌套</h1><p>因此，我们必须定义一个<strong>只会使用一次的函数</strong>，它必须有一个名称，并且必须放在全局范围内(<strong>因为函数不能嵌套</strong>!)这个函数也很短，从一行代码就比从名称和注释更容易看出它的功能。</p><h1 id="使用匿名函数"><a href="#使用匿名函数" class="headerlink" title="使用匿名函数"></a>使用匿名函数</h1><p><strong>匿名函数表达式 (也称为lambda 或 closure ) 允许我们在另一个函数中定义匿名函数。</strong> <strong>嵌套</strong>很重要，因为它允许我们避免命名空间命名污染，并尽可能在使用它的地方定义函数(提供额外的上下文)。</p><p>lambdas的语法是c++中比较奇怪的东西之一，需要一点时间来适应<strong>。Lambdas的形式是</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[ captureClause ] ( parameters ) -&gt; returnType</span><br><span class="line">&#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不需要"captureClause"句和"parameters"，则它们都可以为空。</span></span><br><span class="line"><span class="comment">//"return type"是可选的。如果省略它，将使用auto(即，使用类型推断来确定返回类型)。</span></span><br><span class="line"><span class="comment">//虽然我们前面已经注意到，应该避免对函数返回类型进行类型推断，但是在这个上下文中，使用这种类型推断是可以的(因为这些函数通常都是非常琐碎的)。</span></span><br></pre></td></tr></table></figure><p>还要注意，<strong>lambdas没有名称</strong>，所以我们不需要提供名称。</p><p>这意味着一个普通的lambda定义是这样的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  []() &#123;&#125;; <span class="comment">// defines a lambda with no captures, no parameters, and no return type</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>重新写上面的那段代码（使用匿名函数）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::string_view, 4&gt; arr&#123; <span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"walnut"</span>, <span class="string">"lemon"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Define the function right where we use it.</span></span><br><span class="line">  <span class="keyword">auto</span> found&#123; <span class="built_in">std</span>::find_if(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(),</span><br><span class="line">                           [](<span class="built_in">std</span>::string_view str) <span class="comment">// here's our lambda, no capture clause⭐</span></span><br><span class="line">                           &#123;</span><br><span class="line">                             <span class="keyword">return</span> (str.<span class="built_in">find</span>(<span class="string">"nut"</span>) != <span class="built_in">std</span>::string_view::npos);</span><br><span class="line">                           &#125;) &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (found == arr.<span class="built_in">end</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"No nuts\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Found "</span> &lt;&lt; *found &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就像函数指针的情况，并产生一个相同的结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Found walnut</span><br></pre></td></tr></table></figure><hr><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>注意我们的 匿名函数 与我们的 <code>containsNut</code>函数 是多么的相似：</p><p>它们都具有相同的参数和函数体。lambda没有captureClause（捕获子句）(我们将在下一课中解释捕获子句是什么)，因为它不需要捕获子句。我们在lambda中省略了末尾的返回类型(为了简洁)，但是因为是操作符 != 返回一个bool，我们的lambda也将返回一个bool。</p><h1 id="匿名函数的类型"><a href="#匿名函数的类型" class="headerlink" title="匿名函数的类型"></a>匿名函数的类型</h1><p>在上面的例子中，我们在需要的地方定义了一个lambda。这种对lambda的使用有时被称为<strong>函数文字（function literal）</strong>。</p><p>但是上面的例子中的匿名函数的可读性很差。</p><p>就像我们可以用一个文字值(或函数指针)初始化一个变量以供以后使用一样，<strong>我们也可以用一个lambda定义初始化一个lambda变量，然后再使用它。</strong></p><p>比如：（在下面的代码段中，我们使用<code>std::all_of</code>来检查数组中的所有元素是否为偶数:）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们必须读lambda来理解发生了什么。(Bad)</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::all_of (<span class="built_in">array</span>.<span class="built_in">begin</span>(), <span class="built_in">array</span>.<span class="built_in">end</span>(), [] (<span class="keyword">int</span> i) &#123;<span class="keyword">return</span> ((i%<span class="number">2</span>) == <span class="number">0</span>);&#125;);</span><br></pre></td></tr></table></figure><p>我们可以改善可读性的这个如下:[推荐⭐]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相反，我们可以将lambda存储在指定的变量中，并将其传递给函数。</span></span><br><span class="line"><span class="keyword">auto</span> isEven&#123;</span><br><span class="line">    [] (<span class="keyword">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ((i%<span class="number">2</span>) == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::ll_of(<span class="built_in">array</span>.<span class="built_in">begin</span>(), <span class="built_in">array</span>.<span class="built_in">end</span>(), isEven);</span><br><span class="line"><span class="comment">//注意最后一行读起来有多好:“返回数组中的所有元素是否为偶数”</span></span><br></pre></td></tr></table></figure><h2 id="匿名函数的类型到底是什么？"><a href="#匿名函数的类型到底是什么？" class="headerlink" title="匿名函数的类型到底是什么？"></a>匿名函数的类型到底是什么？</h2><p>但是上面的匿名函数<code>isEven</code>到底是什么呢？</p><p>答：</p><p>事实证明，<strong>lambdas没有一个我们可以明确使用的类型。当我们写一个lambda时，编译器会生成一个唯一的类型，但是不暴露给我们。</strong></p><hr><p><strong>虽然我们不知道lambda的类型，但是有几种方法可以存储用于post-definition（后定义？？？）的lambda</strong>。<u>如果lambda有一个空的捕获子句</u>，我们可以使用下面三种方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//⭐1：一个常规的函数指针。只对 空捕获句子(capture clause) 有效。</span></span><br><span class="line">    <span class="keyword">double</span> (*addNumbers1) (doubel, <span class="keyword">double</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        [] (<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (a+b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    addNumbers1(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//⭐2： Using std::function。也可适用于匿名函数的capture clause非空的情况(下一课会讲)。</span></span><br><span class="line">    <span class="built_in">std</span>::function addNumbers2 <span class="comment">//注意：在C++17之前，应该这样写：std::function&lt;double(double, double)&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        [] (<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="keyword">return</span> (a+b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    addNumbers2(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//⭐3：使用auto。存储lambda的实际类型。</span></span><br><span class="line">    <span class="keyword">auto</span> addNumbers3</span><br><span class="line">    &#123;</span><br><span class="line">        [] (<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (a+b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    addNumbers3(<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用lambda实际类型的惟一方法是使用auto</strong>。<strong>auto还具有</strong><u>与std::function 相比</u><strong>没有开销的优点。</strong></p><h2 id="适用std-function而不适用auto的情况"><a href="#适用std-function而不适用auto的情况" class="headerlink" title="适用std::function而不适用auto的情况"></a>适用<code>std::function</code>而不适用<code>auto</code>的情况</h2><p>不幸的是，我们不能总是使用auto。</p><p><strong>在实际的lambda未知的情况下</strong>(例如，因为我们将lambda作为参数传递给一个函数，调用者决定将传递什么lambda)，我们不能使用auto。在这种情况下，应该使用std::function。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#incldue <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们不知道fn会是什么。std::function与常规函数和lambdas一起工作。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">repeat</span><span class="params">(<span class="keyword">int</span> repetitions, <span class="keyword">const</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt;&amp; fn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i&#123; <span class="number">0</span> &#125;; i &lt; repetitions; ++i )</span><br><span class="line">        fn(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    repeat(<span class="number">3</span>, [] (<span class="keyword">int</span> i) &#123;<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">'\n'</span>;&#125; );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><hr><h1 id="匿名函数其实不是真正的函数"><a href="#匿名函数其实不是真正的函数" class="headerlink" title="匿名函数其实不是真正的函数"></a>匿名函数其实不是真正的函数</h1><p>实际上，<strong>lambdas不是函数</strong></p><blockquote><p><strong>(这也是它们为什么在“函数不能嵌套”的规定下，可以使用的原因)。</strong></p></blockquote><p>它们是一种特殊的物体，叫做<strong>函子(functor)</strong>。<strong>函子是包含重载运算符() 的对象，使其可以像函数一样调用。</strong></p><hr><h1 id="泛型的匿名函数（generic-lambdas）"><a href="#泛型的匿名函数（generic-lambdas）" class="headerlink" title="泛型的匿名函数（generic lambdas）"></a>泛型的匿名函数（generic lambdas）</h1><p>在大多数情况下，lambda参数的工作原理与常规函数参数相同。</p><p>一个值得注意的例外是，因为c++ 14允许我们使用auto作为参数（注意:在c++ 20中，常规函数也可以使用auto作为参数）。</p><p><strong>当一个lambda有一个或多个<u>auto参数</u>时，编译器将从对lambda的调用中推断出需要哪些参数类型。</strong></p><hr><p>因为具有一个或多个auto参数的lambdas可以处理各种类型的数据，所以它们被称为<strong>generic lambdas</strong>。</p><p>看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">array</span> months&#123; <span class="comment">//C++17之前，使用：std::array&lt;const char*, 12&gt;</span></span><br><span class="line">	<span class="string">"January"</span>,</span><br><span class="line">	<span class="string">"February"</span>,</span><br><span class="line">	<span class="string">"March"</span>,</span><br><span class="line">	<span class="string">"April"</span>,</span><br><span class="line">	<span class="string">"May"</span>,</span><br><span class="line">	<span class="string">"June"</span>,</span><br><span class="line">	<span class="string">"July"</span>,</span><br><span class="line">	<span class="string">"August"</span>,</span><br><span class="line">	<span class="string">"September"</span>,</span><br><span class="line">	<span class="string">"October"</span>,</span><br><span class="line">	<span class="string">"November"</span>,</span><br><span class="line">	<span class="string">"December"</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//搜索以相同字母开头的连续两个月。</span></span><br><span class="line">	<span class="keyword">auto</span> samelatter&#123; <span class="built_in">std</span>::adjacent_find(months.<span class="built_in">begin</span>(), months.<span class="built_in">end</span>(),</span><br><span class="line">		[](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b)</span><br><span class="line">		&#123;<span class="keyword">return</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>]); &#125;</span><br><span class="line">		) &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确保找到两个月的时间。</span></span><br><span class="line">	<span class="keyword">if</span> (samelatter != months.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//std::next返回sameLetter之后的下一个迭代器</span></span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;*samelatter &lt;&lt; <span class="string">" and "</span> &lt;&lt;*<span class="built_in">std</span>::next(samelatter)</span><br><span class="line">			&lt;&lt; <span class="string">" start with the same letter\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">June <span class="keyword">and</span> July start with the same letter</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们使用auto类型的参数通过 const引用 来捕获字符串。</p><blockquote><p>因为<strong>所有的字符串类型都允许通过 操作符[] 访问它们各自的字符</strong>，所以我们不需要关心用户是否传入了<u>std::string</u>、<u>c风格的字符串</u>或<u>其他内容</u>。这允许我们写一个可以接受任何这些的lambda，意味着如果我们在几个月后改变类型，我们就不必重写lambda了。</p></blockquote><p>然而，有些情况auto，不是最好的选择：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span> months&#123; <span class="comment">// pre-C++17 use std::array&lt;const char*, 12&gt;</span></span><br><span class="line">    <span class="string">"January"</span>,</span><br><span class="line">    <span class="string">"February"</span>,</span><br><span class="line">    <span class="string">"March"</span>,</span><br><span class="line">    <span class="string">"April"</span>,</span><br><span class="line">    <span class="string">"May"</span>,</span><br><span class="line">    <span class="string">"June"</span>,</span><br><span class="line">    <span class="string">"July"</span>,</span><br><span class="line">    <span class="string">"August"</span>,</span><br><span class="line">    <span class="string">"September"</span>,</span><br><span class="line">    <span class="string">"October"</span>,</span><br><span class="line">    <span class="string">"November"</span>,</span><br><span class="line">    <span class="string">"December"</span></span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Count how many months consist of 5 letters</span></span><br><span class="line">  <span class="keyword">auto</span> fiveLetterMonths&#123; <span class="built_in">std</span>::count_if(months.<span class="built_in">begin</span>(), months.<span class="built_in">end</span>(),</span><br><span class="line">                                       [](<span class="built_in">std</span>::string_view str) &#123; <span class="comment">//⭐</span></span><br><span class="line">                                         <span class="keyword">return</span> (str.length() == <span class="number">5</span>);</span><br><span class="line">                                       &#125;) &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"There are "</span> &lt;&lt; fiveLetterMonths &lt;&lt; <span class="string">" months with 5 letters\n"</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">There are <span class="number">2</span> months with <span class="number">5</span> letters</span><br></pre></td></tr></table></figure><p>在本例中，使用auto将会推断出const char<em>的类型。*</em>c风格的字符串不容易使用(除了使用运算符[])**。</p><p>在本例中，<strong>我们倾向于显式地将参数定义为std::string_view</strong>，这使我们能够更轻松地处理底层数据(例如，我们可以询问string视图的长度，即使用户传入的是c风格的数组)。</p><h2 id="泛型lambda和静态变量"><a href="#泛型lambda和静态变量" class="headerlink" title="泛型lambda和静态变量"></a>泛型lambda和静态变量</h2><p><strong>需要注意的一件事是，一个独一无二的匿名函数将会(被)auto解析为不同的类型。</strong></p><p>下面的例子展示了一个泛型lambda如何变成两个不同的lambda:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//打印一个值并计算 @print被调用的次数。</span></span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">print</span></span><br><span class="line">    &#123;</span><br><span class="line">        [] (<span class="keyword">auto</span> value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">int</span> callcount &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; callcount++&lt;&lt; <span class="string">": "</span> &lt;&lt; value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"hello"</span>); <span class="comment">// 0: hello</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"world"</span>); <span class="comment">// 1: world</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>); <span class="comment">// 0: 1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>); <span class="comment">// 1: 2</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span> (<span class="string">"ding dong"</span>); <span class="comment">// 2: ding dong</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">0</span>: hello</span><br><span class="line"><span class="number">1</span>: world</span><br><span class="line"><span class="number">0</span>: <span class="number">1</span></span><br><span class="line"><span class="number">1</span>: <span class="number">2</span></span><br><span class="line"><span class="number">2</span>: ding dong</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们定义了一个lambda，然后使用两个不同的参数 (一个字符串文字参数 和 一个整数参数)来调用它。这将生成lambda的两个不同版本 (一个带有字符串文字参数，另一个带有整数参数)。</p><blockquote><p>大多数时候，这是无关紧要的。但是，请注意，<strong>如果泛型lambda使用静态持续时间变量，那么这些变量不会在生成的lambda之间共享。</strong></p></blockquote><p>我们可以在上面的示例中看到这一点，其中每个类型(字符串和整数)都有自己的惟一计数!</p><p>虽然我们只写了一次lambda，但是生成了两个lambda，每个lambda都有自己的callCount版本。<u>为了在两个生成的lambda之间共享一个计数器，我们必须在lambda之外定义一个变量</u>。现在，这意味着即使在函数外部也要定义变量。在上面的例子中，这意味着添加一个全局变量。在下一课中讨论lambda捕获之后，我们将能够避免全局变量。</p><h1 id="返回类型推导和跟踪返回类型"><a href="#返回类型推导和跟踪返回类型" class="headerlink" title="返回类型推导和跟踪返回类型"></a>返回类型推导和跟踪返回类型</h1><p>如果使用返回类型推断，则lambda的返回类型是从lambda内部的<code>return</code>语句中推导出来的。如果使用返回类型推断，lambda中的所有返回语句必须返回相同的类型(否则编译器将不知道选择哪一个)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> divide&#123; [](<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">bool</span> bInteger) &#123; <span class="comment">// 注意:没有指定的返回类型</span></span><br><span class="line">    <span class="keyword">if</span> (bInteger)</span><br><span class="line">      <span class="keyword">return</span> x / y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(x) / y; <span class="comment">// 错误:返回类型与以前的返回类型不匹配</span></span><br><span class="line">  &#125; &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; divide(<span class="number">3</span>, <span class="number">2</span>, <span class="literal">true</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; divide(<span class="number">3</span>, <span class="number">2</span>, <span class="literal">false</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将产生一个编译错误：</p><p>因为第一个返回语句(int)的返回类型 与 第二个返回语句(double)的返回类型不匹配。</p><p>如何解决呢？</p><p>在我们返回不同类型的情况下，我们有两个选项:</p><ol><li><strong>显式强制转换以使所有返回类型匹配；</strong></li><li><strong>显式地为lambda指定返回类型，并让编译器进行隐式转换。【推荐⭐】</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//注意：显式指定此值将返回一个double</span></span><br><span class="line">    <span class="keyword">auto</span> divide &#123;</span><br><span class="line">        [] (<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">bool</span> bInteger) -&gt;<span class="keyword">double</span> <span class="comment">//⭐</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (bInteger)</span><br><span class="line">                <span class="keyword">return</span> x/y; <span class="comment">// 将做一个隐式转换为double</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(x) / y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; divide(<span class="number">3</span>, <span class="number">2</span>, <span class="literal">true</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; divide(<span class="number">3</span>, <span class="number">2</span>, <span class="literal">false</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就像上面一样，如果您决定更改返回类型，<strong>您(通常)只需要更改lambda的返回类型，而不需要触及lambda主体。</strong></p><h1 id="——————————"><a href="#——————————" class="headerlink" title="——————————"></a>——————————</h1><h1 id="Lambda-captures"><a href="#Lambda-captures" class="headerlink" title="Lambda captures"></a>Lambda captures</h1><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/lambda-captures/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/lambda-captures/</a></p><hr><h2 id="Capture-clauses-and-capture-by-value"><a href="#Capture-clauses-and-capture-by-value" class="headerlink" title="Capture clauses and capture by value"></a>Capture clauses and capture by value</h2><p>现在，让我们修改nut示例，让用户选择要搜索的子字符串。这并不像你想象的那么直观。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::string_view, 4&gt; arr&#123; <span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"walnut"</span>, <span class="string">"lemon"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 询问用户要搜索什么。</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"search for: "</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> search&#123;&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; search;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">auto</span> found&#123; <span class="built_in">std</span>::find_if(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [](<span class="built_in">std</span>::string_view str) &#123;</span><br><span class="line">    <span class="comment">// 搜索@search而不是“nut”。</span></span><br><span class="line">    <span class="keyword">return</span> (str.<span class="built_in">find</span>(search) != <span class="built_in">std</span>::string_view::npos); <span class="comment">// 错误:search 在此范围内不可访问</span></span><br><span class="line">  &#125;) &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (found == arr.<span class="built_in">end</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Not found\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Found "</span> &lt;&lt; *found &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码无法编译。</p><p>与嵌套块不同的是，外层块中定义的任何标识符都可以在嵌套块的范围内访问，<strong>而</strong>lambdas只能访问特定类型的标识符:</p><ul><li>全局标识符、</li><li>编译时已知的实体</li><li>具有静态存储持续时间的实体。</li></ul><p>search不满足这些要求，所以lambda看不到它<strong>。这就是capture clause的作用。</strong></p><h2 id="capture-clause"><a href="#capture-clause" class="headerlink" title="capture clause"></a>capture clause</h2><p><strong>capture clause(捕获子句)</strong> 用于(间接地)为lambda提供对周围范围中可用变量（这些变量是它通常无法访问的）的访问，</p><p><strong>我们所需要做的就是在lambda中列出我们想要访问的实体，作为捕获子句的一部分</strong>。在这种情况下，我们想给我们的lambda访问变量search的值，所以我们把它添加到捕获子句:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">26</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">28</span></span><br><span class="line"><span class="number">29</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="number">31</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::string_view, 4&gt; arr&#123; <span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"walnut"</span>, <span class="string">"lemon"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"search for: "</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> search&#123;&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; search;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Capture @search                                vvvvvv⭐</span></span><br><span class="line">  <span class="keyword">auto</span> found&#123; <span class="built_in">std</span>::find_if(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [search](<span class="built_in">std</span>::string_view str) &#123;</span><br><span class="line">    <span class="keyword">return</span> (str.<span class="built_in">find</span>(search) != <span class="built_in">std</span>::string_view::npos);</span><br><span class="line">  &#125;) &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (found == arr.<span class="built_in">end</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Not found\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Found "</span> &lt;&lt; *found &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">search <span class="keyword">for</span>: nana</span><br><span class="line">Found banana</span><br></pre></td></tr></table></figure><h2 id="那么捕捉到底是如何工作的呢"><a href="#那么捕捉到底是如何工作的呢" class="headerlink" title="那么捕捉到底是如何工作的呢?"></a>那么捕捉到底是如何工作的呢?</h2><p>虽然上面例子中的lambda看起来像是直接访问main的搜索变量的值，但实际情况并非如此。<strong>Lambdas的外观和功能可能与嵌套块类似，但它们的工作方式略有不同(</strong>这一点很重要)。</p><p><strong>当执行lambda定义时，对于lambda捕获的每个变量，在lambda中创建该变量的克隆(具有相同的名称)。此时，这些克隆的变量是从同名的外部作用域变量初始化的。</strong></p><p>因此，在上面的例子中，当创建lambda对象时，lambda获得它自己的克隆变量<code>search</code>。这个克隆的<code>search</code>与main的<code>search</code>有相同的值，所以它的行为就像我们访问main的<code>search</code>，但我们没有。</p><blockquote><p>虽然这些克隆的变量具有相同的名称，<strong>但它们不一定具有与原始变量相同的类型</strong>。</p></blockquote><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>虽然lambdas看起来像函数，但它们实际上是可以像函数一样调用的对象(这些被称为<strong>functor</strong>——我们将在以后的课程中讨论如何从头创建自己的functor)。</p><p>当<strong>编译器</strong>遇到一个lambda定义时，它会为该lambda创建一个自定义对象定义。每个捕获的变量都成为该对象的数据成员。</p><p>在<strong>运行时</strong>，当遇到lambda定义时，将<u>实例化lambda对象</u>，并在此时初始化lambda的成员。</p><h2 id="捕获默认的const值"><a href="#捕获默认的const值" class="headerlink" title="捕获默认的const值"></a>捕获默认的const值</h2><p>默认情况下，变量由const值捕获。</p><p><strong>这意味着在创建lambda时，lambda捕获外部作用域变量的常量副本，也就是说不允许lambda修改它们。</strong></p><p>在下面的示例中，我们捕获变量ammo并尝试递减它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ammo&#123;<span class="number">10</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义一个lambda并将其存储在一个名为“shoot”的变量中。</span></span><br><span class="line">    <span class="keyword">auto</span> shoot&#123;</span><br><span class="line">        [ammo]() &#123;</span><br><span class="line">            <span class="comment">//✖，缴获的ammo为const copy。</span></span><br><span class="line">            --ammo;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Pew! "</span> &lt;&lt; ammo &lt;&lt; <span class="string">" shot(s) left.\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用lambda</span></span><br><span class="line">    shoot();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ammo &lt;&lt; <span class="string">" shot(s) left\n"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，当我们捕获ammo时，在lambda中创建了一个具有相同名称和值的新const变量。我们不能修改它，因为它是const，这会导致编译错误。</p><h2 id="捕获可变-mutable-的值"><a href="#捕获可变-mutable-的值" class="headerlink" title="捕获可变(mutable)的值"></a>捕获可变(mutable)的值</h2><p>为了允许对值捕获的变量进行修改，我们可以将lambda<strong>标记为<code>mutable</code>。</strong></p><blockquote><p><strong>关键字<code>mutable</code>会除去 从值捕获的所有变量 的<code>const</code>限定。</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ammo&#123; <span class="number">10</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">auto</span> shoot&#123;</span><br><span class="line">      <span class="comment">//在参数列表之后添加了mutable。</span></span><br><span class="line">      [ammo]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">          <span class="comment">//我们现在可以修改ammo了</span></span><br><span class="line">          --ammo;</span><br><span class="line">           <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Pew! "</span> &lt;&lt; ammo &lt;&lt; <span class="string">" shot(s) left.\n"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  shoot();</span><br><span class="line">  shoot();</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ammo &lt;&lt; <span class="string">" shot(s) left\n"</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Pew! <span class="number">9</span> shot(s) left.</span><br><span class="line">Pew! <span class="number">8</span> shot(s) left.</span><br><span class="line"><span class="number">10</span> shot(s) left  <span class="comment">//真正的ammo的值是没有变的。</span></span><br></pre></td></tr></table></figure><p>虽然现在可以编译，但是还是有逻辑上面的错误，什么错误呢？</p><p>就是：当我们呢调用匿名函数(<code>shoot()</code>)，这个匿名函数捕获一个<code>ammo</code>的副本。当匿名函数对<code>ammo</code>进行递减（由10到9到8），<strong>它递减的是<code>ammo</code>的副本，而不是真正的<code>ammo</code></strong>（如何修改本真的ammo呢？就是利用“引用”来捕获）</p><p>注意：<code>ammo</code>的值在对lambda的调用中保持不变!</p><h2 id="通过“引用”-捕获"><a href="#通过“引用”-捕获" class="headerlink" title="通过“引用” 捕获"></a>通过“引用” 捕获</h2><p>就像函数可以改变通过引用传递的参数的值一样，我们也可以通过<strong>引用</strong>捕获变量<strong>来允许lambda改变参数的值。</strong>(所以，<strong>使用引用捕获，将不再需要<code>mutable</code></strong>)</p><p>为了通过引用捕获变量，我们在捕获的变量名之前加上一个<strong>&amp;</strong>符号。</p><p>与被值捕获的变量不同，<strong>被引用捕获的变量是非const的</strong>，除非它们捕获的变量是const。</p><blockquote><p><strong>当您通常希望通过引用将参数传递给函数时(例如，对于非基本类型)，应该首选通过引用捕获而不是通过值捕获。</strong></p></blockquote><hr><p>这是上面的代码，修改为通过引用来捕获ammo:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ammo</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> shoot&#123;</span><br><span class="line">        <span class="comment">////我们不再需要mutable</span></span><br><span class="line">        [&amp;ammo]() &#123; <span class="comment">// &amp;ammo是指通过引用来捕获ammo</span></span><br><span class="line">            <span class="comment">//这里改变ammo会影响 main's 中的ammo</span></span><br><span class="line">            --ammo;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Pew! "</span> &lt;&lt; ammo &lt;&lt; <span class="string">" shot(s) left.\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  	shoot();</span><br><span class="line"> </span><br><span class="line"> 	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ammo &lt;&lt; <span class="string">" shot(s) left\n"</span>;</span><br><span class="line"> </span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Pew! <span class="number">9</span> shot(s) left.</span><br><span class="line"><span class="number">9</span> shot(s) left</span><br></pre></td></tr></table></figure><h2 id="捕获多个变量"><a href="#捕获多个变量" class="headerlink" title="捕获多个变量"></a>捕获多个变量</h2><p>可以通过用<strong>逗号分隔</strong>多个变量来捕获它们。这可以包括由<strong>值</strong>或<strong>引用</strong>捕获的变量组合:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> health&#123; <span class="number">33</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> armor&#123; <span class="number">100</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;CEnemy&gt; enemies&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过值 捕获 health、armor；通过引用捕获enemies</span></span><br><span class="line">[health, armor, &amp;enemies]()&#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="默认捕获"><a href="#默认捕获" class="headerlink" title="默认捕获"></a>默认捕获</h2><p>显式地列出想要捕获的变量可能会很麻烦。如果您修改您的lambda，您可能会忘记添加或删除捕获的变量。</p><p><strong>幸运的是，我们可以利用编译器的帮助来自动生成需要捕获的变量列表</strong>。</p><hr><p><strong>默认捕获</strong>(也称<strong>capture-default</strong>) 捕获lambda中提到的所有变量。<strong>如果使用默认捕获，则不捕获lambda中未提到的变量。</strong></p><ul><li><p>若要按<strong>值</strong>捕获所有使用的变量，请使用<strong>=</strong>的捕获值。</p></li><li><p>若要通过<strong>引用</strong>捕获所有使用的变量，请使用<strong>&amp;</strong>的捕获值。</p></li></ul><p>看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span> areas&#123; <span class="number">100</span>, <span class="number">25</span>, <span class="number">121</span>, <span class="number">40</span>, <span class="number">56</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span>&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter width and height: "</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; <span class="built_in">width</span> &gt;&gt; <span class="built_in">height</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">auto</span> found&#123; <span class="built_in">std</span>::find_if(areas.<span class="built_in">begin</span>(), areas.<span class="built_in">end</span>(),</span><br><span class="line">                           [=](<span class="keyword">int</span> knownArea) &#123; <span class="comment">// will default capture width and height by value</span></span><br><span class="line">                             <span class="keyword">return</span> (<span class="built_in">width</span> * <span class="built_in">height</span> == knownArea); <span class="comment">// because they're mentioned here</span></span><br><span class="line">                           &#125;) &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (found == areas.<span class="built_in">end</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I don't know this area :(\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Area found :)\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认捕获可以与普通捕获混合使用。我们可以通过值捕获一些变量，通过引用捕获另一些变量，但是每个变量只能捕获一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> health&#123; <span class="number">33</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> armor&#123; <span class="number">100</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;CEnemy&gt; enemies&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据值 捕获health和armor，根据引用捕获enemies。</span></span><br><span class="line">[health, armor, &amp;enemies]()&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过引用来捕获enemie，通过值来捕获其他的一切。</span></span><br><span class="line">[=, &amp;enemies]()&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过引用来捕获其他的一切，通过值来捕获armor。</span></span><br><span class="line">[&amp;, armor]()&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*下面是一些非法的*/</span></span><br><span class="line"><span class="comment">//1.我们已经说过，我们想通过引用来捕获所有信息。✖</span></span><br><span class="line">[&amp;, &amp;armor]()&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.我们已经说过，我们希望通过值来捕获一切。✖</span></span><br><span class="line">[=, armor]()&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.armor出现两次。✖</span></span><br><span class="line">[armor, &amp;health, &amp;armor]() &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.默认捕获必须是捕获组中的第一个元素。✖</span></span><br><span class="line">[armor, &amp;]()&#123;&#125;; -----应该是--》[ &amp;, armor]()&#123;&#125;;</span><br></pre></td></tr></table></figure><h1 id="在lambda-capture中定义新变量"><a href="#在lambda-capture中定义新变量" class="headerlink" title="在lambda-capture中定义新变量"></a>在lambda-capture中定义新变量</h1><p>有时，我们希望通过轻微的修改来捕获一个变量，或者声明一个只在lambda作用域内可见的新变量。</p><p>我们可以通过<strong>在lambda-capture中定义一个变量<u>而不指定它的类型</u>来做到这一点。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span> areas&#123; <span class="number">100</span>, <span class="number">25</span>, <span class="number">121</span>, <span class="number">40</span>, <span class="number">56</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span>&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter width and height: "</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; <span class="built_in">width</span> &gt;&gt; <span class="built_in">height</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 我们存储areas，但用户输入宽度和高度。</span></span><br><span class="line">  <span class="comment">// 我们需要先计算出面积，然后才能搜索它。</span></span><br><span class="line">  <span class="keyword">auto</span> found&#123; <span class="built_in">std</span>::find_if(areas.<span class="built_in">begin</span>(), areas.<span class="built_in">end</span>(),</span><br><span class="line">                           <span class="comment">// 声明一个仅对lambda可见的新变量(userarea)</span></span><br><span class="line">                           <span class="comment">// userarea的类型被自动推断为int</span></span><br><span class="line">                           [userArea&#123; <span class="built_in">width</span> * <span class="built_in">height</span> &#125;](<span class="keyword">int</span> knownArea) &#123;</span><br><span class="line">                             <span class="keyword">return</span> (userArea == knownArea);</span><br><span class="line">                           &#125;) &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (found == areas.<span class="built_in">end</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I don't know this area :(\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Area found :)\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当定义了lambda时，<code>userArea</code>只计算一次。计算的区域存储在lambda对象中，对于每个调用都是相同的。如果lambda是可变的，并且修改了在捕获中定义的变量，则原始值将被覆盖。</p><h2 id="空悬的捕获变量"><a href="#空悬的捕获变量" class="headerlink" title="空悬的捕获变量"></a>空悬的捕获变量</h2><p>变量在定义lambda的地方被捕获。如果被引用捕获的变量在lambda之前被销毁，lambda将保留一个悬空引用。</p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个lambda</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">makeWalrus</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 通过引用捕获name并返回lambda。</span></span><br><span class="line">    <span class="keyword">return</span> [&amp;]()&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">"I am a walrus, my name is "</span>&lt;&lt;name &lt;&lt;<span class="string">'\n'</span>; <span class="comment">//未定义行为</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个新的walrus，它的名字叫做Roofus.</span></span><br><span class="line">    <span class="comment">// sayName是makeWalrus返回的lambda。</span></span><br><span class="line">    <span class="keyword">auto</span> sayName &#123;makeWalrus(<span class="string">"Roofus"</span>)&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用makeWalrus返回的 lambda函数。</span></span><br><span class="line">    sayName();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对<code>makeWalrus</code>的调用将从字符串文本“Roofus”创建一个临时<code>std::string</code>。在<code>makeWalrus</code> 中的lambda 通过引用捕获了这个临时字符串。当返回<code>makeWalrus</code>时，临时字符串被销毁，但是lambda依然在引用它。然后当我们调用<code>sayName</code>，就会访问到这个空悬的引用，于是就造成了未定义行为。</p><blockquote><p>注意，<strong>如果按值将<code>name</code>传递给<code>makeWalrus</code>，也会发生这种情况。</strong></p></blockquote><hr><p>warning:</p><p><strong>通过引用捕获变量时要格外小心，特别是使用默认的引用捕获时。捕获的变量必须比lambda存在的时间长。</strong></p><hr><p>未完待续~~：<strong>Unintended copies of mutable lambdas</strong></p><blockquote><p>目前，本节剩下部分先不看。2020-05-07 22:26:38</p></blockquote></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/5844b406.html">C&C++/省略号(以及为啥避免使用他)</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月6日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：500字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：1分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/714-ellipsis-and-why-to-avoid-them/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/714-ellipsis-and-why-to-avoid-them/</a></p><hr><p>在我们目前看到的所有函数中，必须提前知道函数将使用的参数的数量(即使它们有默认值)。</p><p>但是，在某些情况下，<strong>能够向函数传递 可变数量的参数 是很有用的</strong>。c++提供了一种特殊的说明符，称为 <strong>ellipsis(省略号)</strong> (又名 <strong>“…”</strong> )，它允许我们精确地执行此操作。</p><p>使用省略号的函数采用以下形式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return_type function_name(argument_list, ...)</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>argument_list</code>：是一个或多个常规函数参数。</strong>(注意，使用省略号的函数必须至少有一个非省略号参数。) 传递给函数的任何参数都必须首先匹配</p></li><li><p><strong>省略号：</strong>（是由三个点组成）。必须总是函数中的最后一个参数。</p><blockquote><p>但是从概念上来说，<strong>把省略号看作一个数组是很有用的，这个数组包含的参数超出argument_list中的参数。</strong></p></blockquote></li></ul><hr><p>一个例子：</p><p>假设我们要写一个函数来计算一堆整数的平均值。我们会这样做:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdarg&gt; // needed to use ellipsis</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略号必须是最后一个参数</span></span><br><span class="line"><span class="comment">// count是我们传递了多少额外的参数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findAverage</span><span class="params">(<span class="keyword">int</span> count, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//我们通过va_list⭐访问省略号，因此我们声明一个</span></span><br><span class="line">	va_list <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//我们使用va_start⭐初始化va_list。</span></span><br><span class="line">	<span class="comment">//第一个参数是要初始化的列表，第二个参数是最后一个非省略号参数</span></span><br><span class="line">	va_start(<span class="built_in">list</span>, count);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 循环遍历所有省略号参数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> arg = <span class="number">0</span>; arg &lt; count; ++arg)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//我们使用va_arg⭐从我们的省略号中获取参数</span></span><br><span class="line">		<span class="comment">// 第一个参数是我们正在使用的va_list</span></span><br><span class="line">		<span class="comment">// 第二个参数是  参数的类型</span></span><br><span class="line">		sum += va_arg(<span class="built_in">list</span>, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//完成后清除va_list ⭐</span></span><br><span class="line">		va_end(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> sum / count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; findAverage(<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; findAverage(<span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>) &lt;&lt; <span class="string">'\n'</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3.5</span></span><br></pre></td></tr></table></figure></div></section></article></div></section><br><div class="prev-next"><a class="prev" rel="prev" href="/page/7/"><section class="post prev white-box shadow"><i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页&nbsp;</section></a><p class="current">8 / 15</p><a class="next" rel="next" href="/page/9/"><section class="post next white-box shadow">&nbsp;下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i></section></a></div></div><aside class="l_side"><section class="widget blogger shadow desktop"><div class="content"><div class="avatar"><img class="avatar" src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"></div><div class="text"><p><span id="jinrishici-sentence">龙龙‘S BLOG</span></p><script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script></div><div class="social-wrapper"><a href="/atom.xml" class="social fas fa-rss flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="mailto:1198216723@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://github.com/longlongqin" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://music.163.com/#/user/home?id=285545421" class="social fas fa-headphones-alt flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a></div></div></section><section class="widget grid shadow desktop mobile"><header><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i><span class="name">站内导航</span></header><div class="content"><div class="grid navigation"><a class="flat-box" title="/" href="/" id="home"><i class="fas fa-clock fa-fw" aria-hidden="true"></i> 近期文章 </a><a class="flat-box" title="/archives/" href="/archives/" rel="nofollow" id="archives"><i class="fas fa-archive fa-fw" aria-hidden="true"></i> 文章归档 </a><a class="flat-box" title="/friends/" href="/friends/" rel="nofollow" id="friends"><i class="fas fa-link fa-fw" aria-hidden="true"></i> 友人帐 </a><a class="flat-box" title="/about/" href="/about/" rel="nofollow" id="about"><i class="fas fa-info-circle fa-fw" aria-hidden="true"></i> 关于小站</a></div></div></section><section class="widget category shadow desktop"><header><a href="/blog/categories/"><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i><span class="name">文章分类</span></a></header><div class="content"><ul class="entry navigation"><li><a class="flat-box" title="/categories/OJ/" href="/categories/OJ/" id="categoriesOJ"><div class="name">OJ</div><div class="badge">(1)</div></a></li><li><a class="flat-box" title="/categories/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" href="/categories/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" id="categorieshexoE58D9AE5AEA2E690ADE5BBBA"><div class="name">hexo博客搭建</div><div class="badge">(1)</div></a></li><li><a class="flat-box" title="/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" href="/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" id="categoriesE58D9AE5AEA2E690ADE5BBBA"><div class="name">博客搭建</div><div class="badge">(4)</div></a></li><li><a class="flat-box" title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="categoriesE5ADA6E4B9A0E7AC94E8AEB0"><div class="name">学习笔记</div><div class="badge">(48)</div></a></li><li><a class="flat-box child" title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/" id="categoriesE5ADA6E4B9A0E7AC94E8AEB0C-C"><div class="name">C/C++</div><div class="badge">(25)</div></a></li><li><a class="flat-box child" title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git/" id="categoriesE5ADA6E4B9A0E7AC94E8AEB0Git"><div class="name">Git</div><div class="badge">(1)</div></a></li><li><a class="flat-box" title="/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" href="/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" id="categoriesE5AE9EE794A8E68A80E5B7A7"><div class="name">实用技巧</div><div class="badge">(1)</div></a></li><li><a class="flat-box" title="/categories/%E9%85%8D%E7%BD%AE/" href="/categories/%E9%85%8D%E7%BD%AE/" id="categoriesE9858DE7BDAE"><div class="name">配置</div><div class="badge">(1)</div></a></li></ul></div></section><section class="widget tagcloud shadow desktop"><header><a href="/blog/tags/"><i class="fas fa-tags fa-fw" aria-hidden="true"></i><span class="name">热门标签</span></a></header><div class="content"><a href="/tags/C/" style="font-size:16px;color:#8b8b8b">C++</a> <a href="/tags/C-C/" style="font-size:24px;color:#555">C/C++</a> <a href="/tags/Git/" style="font-size:14px;color:#999">Git</a> <a href="/tags/Hexo%E4%B8%BB%E9%A2%98/" style="font-size:14px;color:#999">Hexo主题</a> <a href="/tags/Let-s-Build-A-Simple-Interpreter/" style="font-size:22px;color:#636363">Let's Build A Simple Interpreter</a> <a href="/tags/Let%E2%80%99s-Build-A-Simple-Interpreter/" style="font-size:18px;color:#7e7e7e">Let’s Build A Simple Interpreter</a> <a href="/tags/OJ/" style="font-size:14px;color:#999">OJ</a> <a href="/tags/Yilia%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/" style="font-size:14px;color:#999">Yilia主题配置</a> <a href="/tags/forme/" style="font-size:14px;color:#999">forme</a> <a href="/tags/front-matter%E9%85%8D%E7%BD%AE/" style="font-size:14px;color:#999">front-matter配置</a> <a href="/tags/github/" style="font-size:14px;color:#999">github</a> <a href="/tags/hexo%E6%98%BE%E7%A4%BApdf/" style="font-size:14px;color:#999">hexo显示pdf</a> <a href="/tags/matery%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/" style="font-size:14px;color:#999">matery主题配置</a> <a href="/tags/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE%E3%80%8B/" style="font-size:18px;color:#7e7e7e">《计算机科学速成课》</a> <a href="/tags/%E5%87%B8%E5%8C%85/" style="font-size:20px;color:#707070">凸包</a> <a href="/tags/%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91%E5%92%8C%E9%80%BB%E8%BE%91%E9%97%A8/" style="font-size:14px;color:#999">布尔逻辑和逻辑门</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" style="font-size:14px;color:#999">计算几何</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE/" style="font-size:14px;color:#999">计算机科学速成课</a> <a href="/tags/%E9%85%8D%E7%BD%AE/" style="font-size:14px;color:#999">配置</a></div></section></aside><footer class="clearfix white"><br><br><div class="aplayer-container"><meting-js theme="#1BCDFC" autoplay volume="0.6" loop order="list" fixed="false" list-max-height="340px" server="netease" type="song" id="186453" list-folded="true"></meting-js></div><br><div class="social-wrapper"><a href="/atom.xml" class="social fas fa-rss flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="mailto:1198216723@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://github.com/longlongqin" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://music.163.com/#/user/home?id=285545421" class="social fas fa-headphones-alt flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a></div><red>&copy; 2020-2021 longlongqin 😊| powered by HEXO | theme volantis</red><br><yellow><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("03/01/2020 18:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="小站已运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒 "}setInterval("createtime()",250)</script></yellow><br><green><i class="fas fa-chart-area"></i> <span class="post-count">字数统计：307.9k</span></green>|<script type="text/javascript" src="https://v1.cnzz.com/z_stat.php?id=1278663994&web_id=1278663994"></script><br><cyan>博客内容遵循</cyan><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank"><cyan>署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</cyan></a></footer><script>setLoadingBarProgress(80)</script><script>setLoadingBarProgress(60)</script></div><a class="s-top fas fa-arrow-up fa-fw" href="javascript:void(0)"></a></div><script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script><script>var SEARCH_SERVICE="hexo",ROOT="/";ROOT.endsWith("/")||(ROOT+="/")</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script><script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script><script type="text/javascript">$(function(){Waves.attach(".flat-btn",["waves-button"]),Waves.attach(".float-btn",["waves-button","waves-float"]),Waves.attach(".float-btn-light",["waves-button","waves-float","waves-light"]),Waves.attach(".flat-box",["waves-block"]),Waves.attach(".float-box",["waves-block","waves-float"]),Waves.attach(".waves-image"),Waves.init()})</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script><script type="text/javascript">$(function(){var n=["https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/background/4.jpg"];!function(n){for(var o=n.length;o--;){var r=Math.floor(Math.random()*o),t=n[r];n[r]=n[o],n[o]=t}}(n),$(".cover").backstretch(n,{duration:"20000",fade:"1500"})})</script><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js" async></script><script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js" async></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1.4/js/app.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1/js/search.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script><script>!function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copyed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-clipboard-check');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPYED';
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-exclamation-triangle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
      });
    }
    initCopyCode();
  }(window, document);</script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>let LAZY_LOAD_IMAGE = "[object Object]";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });</script><script>setLoadingBarProgress(100)</script><script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)t=c[r],0<=(n=t.getBoundingClientRect()).bottom&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this);</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script></body></html>