<!DOCTYPE html><html><head hexo-theme="https://volantis.js.org/#2.1.4"><meta charset="utf-8"><meta name="robots" content="noindex,follow"><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><title>龙龙‘S BLOG</title><link rel="alternate" href="/atom.xml" title="龙龙‘S BLOG"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css"><link rel="shortcut icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1.4.3/css/style.css"><script>function setLoadingBarProgress(e){document.getElementById("loading-bar").style.width=e+"%"}</script></head><body><script type="text/javascript" src="/js/love.js"></script><script type="text/javascript" src="/js/ergao.js"></script><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><header class="l_header shadow blur"><div class="wrapper"><div class="nav-sub container--flex"><a class="logo flat-box"></a><ul class="switcher h-list"><li><a class="s-comment flat-btn fas fa-comments fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-toc flat-btn fas fa-list fa-fw" target="_self" href="javascript:void(0)"></a></li></ul></div><div class="nav-main container container--flex"><a class="logo flat-box" target="_self" href="/"><i class="fas fa-home"></i> 龙龙</a><div class="menu navigation"><ul class="h-list"><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list-alt fa-fw fa-fw"></i> 索引</a><ul class="submenu"><li><a class="flat-box" href="/categories/" id="categories"><i class="fas fa-folder-open fa-fw fa-fw"></i> 分类</a><ul class="submenu"><li><a class="flat-box" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="categoriesE5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-fire fa-fw"></i> 学习笔记</a></li><li><a class="flat-box" href="/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" id="categoriesE5AE9EE794A8E68A80E5B7A7"><i class="fas fa-fire fa-fw"></i> 实用技巧</a></li></ul></li><li><a class="flat-box" href="/tags/" id="tags"><i class="fas fa-tags fa-fw fa-fw"></i> 标签</a></li><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list fa-fw fa-fw"></i> 时间轴</a></li></ul></li><li><a class="flat-box" href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="E5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-book fa-fw"></i> 学习笔记</a></li><li><a class="flat-box"><i class="fas fa-wrench fa-fw"></i> 工具</a><ul class="submenu"><li><a class="flat-box" href="https://www.thinkcmf.com/font/search/index.html" target="_blank" rel="noopener" id="https:www.thinkcmf.comfontsearchindex.html"><i class="fas fa-font fa-fw"></i> Font Awesome图标</a></li><li><a class="flat-box" href="https://www.sojson.com/image/change.html" target="_blank" rel="noopener" id="https:www.sojson.comimagechange.html"><i class="fa fa-crop fa-fw"></i> 在线图片尺寸修改</a></li><li><a class="flat-box" href="http://dir.scmor.com/" target="_blank" rel="noopener" id="http:dir.scmor.com"><i class="fa fa-search fa-fw"></i> Google学术&搜索镜像</a></li><li><a class="flat-box" href="https://emojixd.com/" target="_blank" rel="noopener" id="https:emojixd.com"><i class="fa fa-smile-o fa-fw"></i> Emoji表情符号辞典📓</a></li></ul></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw fa-fw"></i> 关于</a><ul class="submenu"><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-user-circle fa-fw fa-fw"></i> 关于我</a></li><hr><li><a class="flat-box" href="/friends/" id="friends"><i class="fas fa-link fa-fw"></i> 友人帐</a></li><li><a class="flat-box" href="/comment/" id="comment"><i class="fas fa-comment fa-fw"></i> 留言板</a></li><hr><li><a class="flat-box" href="https://github.com/longlongqin" target="_blank" rel="noopener" id="https:github.comlonglongqin"><i class="fab fa-github fa-fw fa-fw"></i> 我的Github</a></li><li><a class="flat-box" href="https://longlongqin.gitee.io" target="_blank" rel="noopener" id="https:longlongqin.gitee.io"><i class="fa fa-chevron-circle-right fa-fw"></i> matery主题博客</a></li></ul></li><li><a class="flat-box" href="https://volantis.js.org/tag-plugins/" target="_blank" rel="noopener" id="https:volantis.js.orgtag-plugins"><i class="fa fa-bookmark fa-fw"></i> Volantis主题文档</a></li><li><a class="flat-box" href="/easysearch/" id="easysearch"><i class="fa fa-search fa-fw"></i> easy搜索</a></li></ul></div><div class="m_search"><form name="searchform" class="form u-search-form"><i class="icon fas fa-search fa-fw"></i> <input type="text" class="input u-search-input" placeholder="search for everything"></form></div><ul class="switcher h-list"><li><a class="s-search flat-btn fas fa-search fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-menu flat-btn fas fa-bars fa-fw" target="_self" href="javascript:void(0)"></a></li></ul></div></div></header><ul class="menu-phone navigation white-box"><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list-alt fa-fw fa-fw"></i> 索引</a></li><li><a class="flat-box" href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="E5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-book fa-fw"></i> 学习笔记</a></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw fa-fw"></i> 关于</a></li></ul><script>setLoadingBarProgress(40)</script><div class="l_body nocover"><div class="body-wrapper"><div class="l_main"><section class="post-list"><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/6a3f4577.html">C&C++/虚拟析构函数</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月14日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：951字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：3分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/123-virtual-destructors-virtual-assignment-and-overriding-virtualization/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/123-virtual-destructors-virtual-assignment-and-overriding-virtualization/</a></p><hr><h1 id="虚拟虚构函数"><a href="#虚拟虚构函数" class="headerlink" title="虚拟虚构函数"></a>虚拟虚构函数</h1><p>尽管c++为您的类提供了一个默认的析构函数(如果您自己不提供的话)，<strong>但有时您会希望提供自己的析构函数(特别是当类需要释放内存时)</strong>。</p><p><strong>如果要处理继承，应该始终将析构函数设为虚</strong>。</p><h2 id="当父类的析构函数是非virtual"><a href="#当父类的析构函数是非virtual" class="headerlink" title="当父类的析构函数是非virtual"></a>当父类的析构函数是非virtual</h2><p>考虑下面的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~Base() <span class="comment">// note: not virtual</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Calling ~Base()\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* m_array;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">int</span> length)</span><br><span class="line">    &#123;</span><br><span class="line">        m_array = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~Derived() <span class="comment">// note: not virtual (your compiler may warn you about this)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Calling ~Derived()\n"</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] m_array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived *derived &#123; <span class="keyword">new</span> Derived(<span class="number">5</span>) &#125;;</span><br><span class="line">    Base *base &#123; derived &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为base是一个基指针，所以在删除base时，程序会查看基析构函数是否是虚的。它不是，所以它假设它只需要调用基析构函数。我们可以从上面的例子中看出这一点:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calling ~Base()</span><br></pre></td></tr></table></figure><h2 id="当父类的析构函数是virtual"><a href="#当父类的析构函数是virtual" class="headerlink" title="当父类的析构函数是virtual"></a>当父类的析构函数是virtual</h2><p>但是，我们确实希望delete函数调用 Derived的析构函数(它将依次调用Base的析构函数)，否则m_array将不会被删除。<strong>我们通过使基类的析构函数为虚</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base() <span class="comment">// note: virtual</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Calling ~Base()\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* m_array;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">int</span> length)</span><br><span class="line">    &#123;</span><br><span class="line">        m_array = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">virtual</span> ~Derived() <span class="comment">// note: virtual</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Calling ~Derived()\n"</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] m_array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived *derived &#123; <span class="keyword">new</span> Derived(<span class="number">5</span>) &#125;;</span><br><span class="line">    Base *base &#123; derived &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Calling ~Derived()</span><br><span class="line">Calling ~Base()</span><br></pre></td></tr></table></figure><h2 id="无论何时处理继承，都应该显式的使析构函数为虚函数"><a href="#无论何时处理继承，都应该显式的使析构函数为虚函数" class="headerlink" title="无论何时处理继承，都应该显式的使析构函数为虚函数"></a>无论何时处理继承，都应该显式的使析构函数为虚函数</h2><p>与普通的虚成员函数一样，<strong>如果基类函数是虚的，则所有派生重写都将被视为虚的，而不管它们是否被指定为virtual</strong>。没有必要创建一个空的派生类析构函数来将它标记为虚的。</p><h1 id="虚拟分配"><a href="#虚拟分配" class="headerlink" title="虚拟分配"></a>虚拟分配</h1><p>可以使赋值运算符为virtual。然而，与析构函数的情况不同，虚拟化总是一个好主意，虚拟化赋值操作符实际上打开了一个充满蠕虫的包，并进入了本教程范围之外的一些高级主题。因此，为了简单起见，我们建议您暂时不要使用虚拟任务。</p><h2 id="忽视虚拟化"><a href="#忽视虚拟化" class="headerlink" title="忽视虚拟化"></a>忽视虚拟化</h2><p>很少会忽略函数的虚拟化。例如，考虑以下代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Base"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Derived"</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在某些情况下，您可能需要一个指向派生对象的基指针来调用<code>Base::getName()</code>，而不是<code>Derived::getName()</code>。要做到这一点，<strong>只需使用范围解析操作符</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived;</span><br><span class="line">    Base &amp;base &#123; derived &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用Base::GetName()而不是虚拟化的Derived::GetName()</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; base.Base::getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能不会经常用到它，但知道它至少是可能的是件好事。</p><h1 id="我们应该让所有析构函数都是虚的吗"><a href="#我们应该让所有析构函数都是虚的吗" class="headerlink" title="我们应该让所有析构函数都是虚的吗?"></a>我们应该让所有析构函数都是虚的吗?</h1><p>这是新程序员常问的问题。如上例所述，如果基类析构函数没有标记为虚函数，那么如果程序员稍后删除指向派生对象的基类指针，程序就有内存泄漏的风险。避免这种情况的一种方法是将所有析构函数标记为虚函数。但是你应该吗?</p><p><strong>很容易说yes，这样您以后就可以将任何类用作基类——但是这样做会带来性能损失(向您的类的每个实例添加一个虚指针)。所以你必须平衡成本和你的意图。</strong></p></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/f30af5b2.html">C&C++/说明符：override、final 及 协变返回类型</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月14日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：1.8k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：7分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/12-2a-the-override-and-final-specifiers-and-covariant-return-types/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/12-2a-the-override-and-final-specifiers-and-covariant-return-types/</a></p><hr><p>为了解决继承的一些常见问题，c++ 11在c++中添加了两个特殊的标识符:<strong>override和 final</strong>。</p><blockquote><p>注意，这些标识符不是关键字——它们是在特定上下文中具有特殊意义的普通标识符。</p></blockquote><p>虽然final并不是经常使用，但是override是一个非常好的补充，您应该经常使用它。</p><p>在这节课中，我们将看一下这两种情况，以及<strong>虚函数重写</strong> 返回类型必须匹配的规则的一个例外。</p><h1 id="override说明符"><a href="#override说明符" class="headerlink" title="override说明符"></a>override说明符</h1><p>正如我们在前一课中提到的，派生类虚函数<strong>只有在其签名和返回类型完全匹配时</strong>才被认为是<strong>重写</strong>。这可能会导致无意的问题：<strong>原本打算覆盖的函数实际上并不是这样</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName1</span><span class="params">(short <span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125; <span class="comment">// note: parameter is a short int</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName2</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125; <span class="comment">// note: function is const</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	B b;</span><br><span class="line">	A &amp;rBase = b;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rBase.getName1(<span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rBase.getName2(<span class="number">2</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">A</span><br><span class="line">A</span><br></pre></td></tr></table></figure><p>因为rBase是A 引用对B对象的引用，所以这里的目的是使用虚函数来访问B::getName1()和B::getName2()。</p><ul><li><p>但是，因为B::getName1()接受一个不同的参数(一个短整型而不是一个整型)，所以它不被认为是对a::getName1()的覆盖。</p></li><li><p>更狡猾的是，因为B::getName2()是const，而A::getName2()不是，B::getName2()不被认为是对A::getName2()的覆盖。</p></li></ul><blockquote><p>在这个特殊的例子中，因为A和B只是打印它们的名字，很容易看出我们把重写搞砸了，并且调用了错误的虚函数。但是，在更复杂的程序中，函数有未打印的行为或返回值，这样的问题很难调试。</p></blockquote><p>为了帮助解决函数的重写问题，c++ 11引入了重写说明符(<strong>override specifier</strong>)。</p><p><strong>重写说明符可以应用于任何重写函数</strong>，<u>方法是将说明符放在const要去的相同位置</u>。</p><blockquote><p><strong>如果函数没有覆盖基类函数(或应用于非虚函数)，编译器会将该函数标记为错误。</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName3</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//编译错误，函数不是覆盖(因为函数的形参与父类中的不一样)</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName1</span><span class="params">(short <span class="keyword">int</span> x)</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125;</span><br><span class="line">    <span class="comment">//编译错误，函数不是覆盖(因为这个函数与父类中相应的函数不能完全平匹配，它多了一个 const)</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName2</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125;</span><br><span class="line">    <span class="comment">//好的，该函数是重写A::getName3(int)</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName3</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序产生了两个编译错误:</p><ul><li>一个用于B::getName1()，</li><li>另一个用于B::getName2()，</li></ul><p>因为它们都没有覆盖先前的函数。</p><p>而B::getName3()会覆盖A::getName3()，因此不会为该行产生错误。</p><hr><h2 id="使用override说明符不会导致性能损失"><a href="#使用override说明符不会导致性能损失" class="headerlink" title="使用override说明符不会导致性能损失"></a>使用override说明符不会导致性能损失</h2><p><strong>使用覆盖说明符不会导致性能损失，而且它有助于避免意外错误</strong>。因此，我们强烈建议在您编写的每个虚函数重写中使用它，以确保您确实重写了您认为已经重写的函数。</p><h1 id="final说明符"><a href="#final说明符" class="headerlink" title="final说明符"></a>final说明符</h1><p>在某些情况下，<strong>您可能不希望别人能够重写一个虚函数，或者从一个类继承。</strong></p><p><strong>final说明符 可以用来告诉编译器强制执行它。如果用户试图覆盖已指定为final的函数或类，编译器将给出一个编译错误。</strong></p><h2 id="限制用户重写"><a href="#限制用户重写" class="headerlink" title="限制用户重写"></a>限制用户重写</h2><p>在我们想要限制用户重写函数的情况下，最终说明符( <strong>final specifier</strong>) 的位置与override specifier的位置相同，就像这样:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 注意在后面的行中使用final说明符——这使得这个函数不再是可覆盖的</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> <span class="keyword">override</span> <span class="keyword">final</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125; <span class="comment">// okay, overrides A::getName()</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">"C"</span>; &#125; <span class="comment">// compile error: overrides B::getName(), which is final</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的代码中，B::getName()覆盖了A::getName()，这是可以的。但是B::getName()有final 的说明符，这意味着对该函数的任何进一步重写都应该被认为是一个错误。确实，C::getName()试图覆盖B::getName() (这里的override说明符不相关，只是为了更好的实践)，所以编译器会给出一个编译错误。</p><h2 id="限制从该类继承"><a href="#限制从该类继承" class="headerlink" title="限制从该类继承"></a>限制从该类继承</h2><p>在我们想要防止从类继承的情况下，最后的说明符在类名后面应用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="title">final</span> :</span> <span class="keyword">public</span> A <span class="comment">// 注意这里的 final说明符的使用</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B <span class="comment">//⭐ compile error: cannot inherit from final class</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">"C"</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的例子中，类B被声明为final。因此，当C试图从B继承时，编译器会给出一个编译错误。</p><h1 id="协变返回类型"><a href="#协变返回类型" class="headerlink" title="协变返回类型"></a>协变返回类型</h1><p>在一种特殊情况下，派生类虚函数重写 可能具有与基类不同的<strong>返回类型</strong>，<strong>但仍然被认为是匹配重写</strong>。<strong>如果虚函数的返回类型是<u>指针</u>或对类的<u>引用</u>，则重写函数可以返回指针或对派生类的引用。这些被称为协变返回类型。</strong></p><p>这里有一个例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 这个版本的getThis()返回一个指向基类的指针</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Base* <span class="title">getThis</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"called Base::getThis()\n"</span>; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printType</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"returned a Base\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//通常，重写函数必须返回与基函数类型相同的对象</span></span><br><span class="line">	<span class="comment">// 但是，因为Derived是从Base派生的，所以可以返回Derived*而不是Base*</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Derived* <span class="title">getThis</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"called Derived::getThis()\n"</span>;  <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printType</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"returned a Derived\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Derived d;</span><br><span class="line">	Base *b = &amp;d;</span><br><span class="line">	d.getThis()-&gt;printType(); <span class="comment">// 调用Derived::getThis()，返回Derived*，再调用Derived::printType</span></span><br><span class="line">	b-&gt;getThis()-&gt;printType(); <span class="comment">//调用Derived::getThis(), 返回Base*, 再调用 Base::printType</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="function">called <span class="title">Derived::getThis</span><span class="params">()</span></span></span><br><span class="line"><span class="function">returned a Derived</span></span><br><span class="line"><span class="function">called <span class="title">Derived::getThis</span><span class="params">()</span></span></span><br><span class="line"><span class="function">returned a Base</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，一些较老的编译器(例如Visual Studio 6)不支持协变返回类型。</p></blockquote><p>关于协变返回类型有一个有趣的注意: <strong>c++不能动态选择类型，所以您总是会得到与所调用函数的基版本相匹配的类型。</strong></p><hr><p>在上面的例子中，我们首先调用<code>d.getThis()</code>。由于d是派生的，因此调用了<code>Derived::getThis()</code>，它返回一个Derived*。然后使用这个Derived* 调用非虚函数<code>Derived::printType()</code>。</p><p>有趣的情况是： 然后调用<code>b-&gt;getThis()</code>。变量b是一个指向派生对象的Base指针。<code>Base::getThis()</code>是虚函数，因此调用了<code>Derived::getThis()</code>。虽然<code>Derived::getThis()</code>返回一个Derived*，因为函数的基版本返回一个Base*，返回的Derived*向上转换为Base*。因此，调用<code>Base::printType()</code>。</p></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/aba94da5.html">C&C++/虚函数和多态性</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月14日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：3.2k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：12分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/122-virtual-functions/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/122-virtual-functions/</a></p><hr><blockquote><p>虚函数可用于解决的问题，详情请看：</p></blockquote><p>在前面关于<a href="http://www.learncpp.com/cpp-tutorial/121-pointers-and-references-to-the-base-class-of-derived-objects/" target="_blank" rel="noopener">pointers and references to the base class of derived objects</a>中，我们看了一些例子，其中使用基类的指针或引用有可能简化代码。<strong>但是，在每种情况下，我们都会遇到这样的问题: 基指针或引用只能调用函数的基版本，而不能调用派生版本。</strong></p><p>下面是这种行为的一个简单例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Base"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Derived"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived;</span><br><span class="line">    Base &amp;rBase&#123; derived &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rBase is a "</span> &lt;&lt; rBase.getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这节课中，我们将展示如何使用虚函数来解决这个问题。</p><h1 id="虚函数和多态性"><a href="#虚函数和多态性" class="headerlink" title="虚函数和多态性"></a>虚函数和多态性</h1><p><strong>虚函数</strong>是一种特殊类型的函数，当调用虚函数时，解析为存在于基类和派生类之间的函数的<u>最派生版本</u>。这种能力称为<strong>多态性</strong>。</p><blockquote><p>例如，A继承于B，B继承于C。如果从类A中调用一个虚函数，那么该函数会解析为离A<strong>最近的虚函数</strong>。</p></blockquote><p>如果派生函数具有相同的签名 (名称、参数类型以及是否为const)并返回类型作为该函数的基本版本，则将该函数视为<strong>匹配</strong>。这样的函数称为<strong>覆盖</strong>。</p><h2 id="第一个例子："><a href="#第一个例子：" class="headerlink" title="第一个例子："></a>第一个例子：</h2><p><strong>要使函数成为虚函数，只需将“virtual”关键字放在函数声明之前。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Base"</span>; &#125; <span class="comment">// note addition of virtual keyword</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Derived"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived;</span><br><span class="line">    Base &amp;rBase&#123; derived &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rBase is a "</span> &lt;&lt; rBase.getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">rBase is a Derived</span><br></pre></td></tr></table></figure><p>因为rBase是对派生对象的基部分的引用，所以在计算rBase.getName()时，它通常会解析为Base::getName()。<strong>但是，Base::getName()是虚的</strong>，<u>它告诉程序去查看在Base和派生之间是否还有其他派生版本的函数可用。在本例中，它将解析为 Derived::getName()!</u></p><blockquote><p>本例中，引用的对象derived是 Derived类，使用哪个虚函数？ 我们就从Derived类开始 在这个继承树形层级结构中，找到离Derived类最近的那个虚函数。—在这个例子中就是Derived类中的那个虚函数版本（因为它离Derived类最近呀。）</p></blockquote><h2 id="第二个例子："><a href="#第二个例子：" class="headerlink" title="第二个例子："></a>第二个例子：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"C"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"D"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C c;</span><br><span class="line">    A &amp;rBase&#123; c &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rBase is a "</span> &lt;&lt; rBase.getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*你认为这个程序会输出什么?*/</span></span><br><span class="line">rBase is a C</span><br></pre></td></tr></table></figure><p><em>：</em>让我们看看它是如何工作的。</p><ul><li><p>首先，我们实例化一个C类对象。</p></li><li><p>rBase是一个引用，我们将其设置为引用C对象的一部分 的 A。</p></li><li><p>最后，我们调用rBase.getName()。getName()的计算结果是A::getName()。</p><blockquote><p>但是，<strong>A::getName() 是虚的</strong>，<strong>因此编译器将调用A和C之间最派生的匹配</strong>。</p><p>在本例中，就是C::getName()。<strong>注意，它不会调用D::getName()，因为我们的原始对象是C，而不是D，所以只考虑A和C之间的函数。</strong></p></blockquote></li></ul><h1 id="使用virtual关键字"><a href="#使用virtual关键字" class="headerlink" title="使用virtual关键字"></a>使用<code>virtual</code>关键字</h1><p><strong>如果一个函数被标记为<code>virtual</code>，那么所有匹配的覆盖也被认为是虚函数，即使它们没有显式地标记为虚函数。</strong></p><blockquote><p>也就是说，如果父类A的某个函数被标记为<code>virtual</code>，以A为基类的派生类中的 相匹配的该函数的覆盖，就算不显式的标记该函数为<code>virtual</code>，它仍然是一个虚函数。</p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//父类中该函数被标记为 virtual</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Base"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//该派生类 对该函数的覆盖 没有显式的标记它为 virtual，但它仍然是虚函数</span></span><br><span class="line">	<span class="function"><span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Derived"</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>但是，在派生函数上使用关键字virtual并没有什么害处，它可以提醒您，该函数是一个虚函数，而不是一个普通的函数。<u>因此，在派生类中对虚拟化函数使用virtual关键字通常是一个好主意，尽管这并不是严格必需的。</u></p><h1 id="虚函数的返回类型"><a href="#虚函数的返回类型" class="headerlink" title="虚函数的返回类型"></a>虚函数的返回类型</h1><p>在正常情况下，<strong>虚函数的返回类型</strong> 及 <strong>其覆盖</strong> 必须匹配。考虑下面的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">5</span>; &#125; <span class="comment">//int</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">6.78</span>; &#125; <span class="comment">//double</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>在这种情况下，<code>Derived::getValue()</code> 不被认为是<code>Base::getValue()</code>的匹配覆盖 (它被认为是一个完全独立的函数)。</strong></p><blockquote><p>因为<code>Derived::getValue()</code>与<code>Base::getValue()</code>的返回类型不一样：一个为int，一个为double</p></blockquote><h1 id="不要从构造函数或析构函数调用虚函数"><a href="#不要从构造函数或析构函数调用虚函数" class="headerlink" title="不要从构造函数或析构函数调用虚函数"></a>不要从构造函数或析构函数调用虚函数</h1><p>这是另一个陷阱，经常抓住不知情的新程序员。不应该从构造函数或析构函数调用虚函数。为什么?</p><ul><li><p><strong>请记住，在创建派生类时，首先构造基部分。</strong>如果从基类构造函数调用虚函数，但类的派生部分还没有创建，它将无法调用函数的派生版本，因为派生函数没有要处理的派生对象。<strong>在C++中，它将调用基类版本。</strong></p></li><li><p>析构函数也存在类似的问题。如果在基类析构函数中调用虚函数，<strong>它将始终解析为函数的基类版本，因为类的派生部分已经被销毁。</strong></p></li></ul><p><strong>规则:永远不要从构造函数或析构函数调用虚函数</strong></p><h1 id="虚函数的缺点"><a href="#虚函数的缺点" class="headerlink" title="虚函数的缺点"></a>虚函数的缺点</h1><p>既然大多数情况下你希望函数是虚的，为什么不让所有的函数都是虚的呢?</p><p>答案是：</p><ul><li><strong>因为它的效率很低</strong>——解析一个虚函数调用要比解析一个常规函数调用花费更长的时间。</li><li>此外，<strong>编译器还必须为每个具有一个或多个虚函数的类对象分配一个额外的指针</strong>。我们将在本章以后的课程中更多地讨论这个问题。</li></ul><h1 id="——补充——"><a href="#——补充——" class="headerlink" title="——补充——-"></a>——补充——-</h1><p>多态性(polymorphism)可以简单地概括为“一个接口，多种方法”，它是面向对象编程领域的核心概念。</p><p>多态性指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。C++支持两种多态性：编译时多态性，运行时多态性。</p><ol><li>编译时多态性（静态多态）：通过重载函数实现：先期联编 early binding</li><li>运行时多态性（动态多态）：通过虚函数实现 ：滞后联编 late binding</li></ol><p>C++运行时多态性是通过虚函数来实现的，虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖(Override)，或者称为重写。</p><p>多态与非多态的实质区别就是函数地址是早绑定还是晚绑定。如果函数的调用，在编译器编译期间就可以确定函数的调用地址，并生产代码，是静态的，就是说地址是早绑定的。而如果函数调用的地址不能在编译器期间确定，需要在运行时才确定，这就属于晚绑定。</p><p>多态的目的：封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了“接口重用”。也即，不论传递过来的究竟是类的哪个对象，函数都能够通过同一个接口调用到适应各自对象的实现方法。</p><p>多态最常见的用法就是声明基类类型的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法。如果没有使用虚函数的话，即没有利用C++多态性，则利用基类指针调用相应的函数的时候，将总被限制在基类函数本身，而无法调用到子类中被重写过的函数。因为没有多态性，函数调用的地址将是固定的，因此将始终调用到同一个函数，这就无法实现“一个接口，多种方法”的目的了。</p><h2 id="需要注意："><a href="#需要注意：" class="headerlink" title="需要注意："></a>需要注意：</h2><ol><li>只有类的成员函数才能声明为虚函数，虚函数仅适用于有继承关系的类对象。普通函数不能声明为虚函数。</li><li>静态成员函数不能是虚函数，因为静态成员函数不受限于某个对象。</li><li>内联函数（inline）不能是虚函数，因为内联函数不能在运行中动态确定位置。</li><li>构造函数不能是虚函数。</li><li>析构函数可以是虚函数，而且建议声明为虚函数。</li></ol><h2 id="重写-vs-重载："><a href="#重写-vs-重载：" class="headerlink" title="重写 vs 重载："></a>重写 vs 重载：</h2><p>重写可以有两种，直接重写成员函数和重写虚函数，只有重写了虚函数的才能算作是体现了C++多态性。而重载则是允许有多个同名的函数，而这些函数的参数列表不同，允许参数个数不同，参数类型不同，或者两者都不同。编译器会根据这些函数的不同列表，将同名的函数的名称做修饰，从而生成一些不同名称的预处理函数，来实现同名函数调用时的重载问题。但这并没有体现多态性。</p><h2 id="隐藏："><a href="#隐藏：" class="headerlink" title="隐藏："></a>隐藏：</h2><p>除了重载与覆盖（重写），C++还有隐藏。隐藏是指派生类的函数屏蔽了与其同名的基类函数。隐藏规则如下：</p><ol><li>如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual 关键字，基类的函数将被隐藏（注意别与重载混淆，重载是在同一个类中发生）。</li><li>如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆，覆盖有virtual关键字）。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Base::f(float)"</span>&lt;&lt; x &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">float</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Base::g(float)"</span>&lt;&lt; x &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">(<span class="keyword">float</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Base::h(float)"</span>&lt;&lt; x &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//子类与基类函数同名，有virtual关键字，运行时多态</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Derived::f(float)"</span>&lt;&lt; x &lt;&lt;<span class="built_in">endl</span>;   <span class="comment">//多态、覆盖</span></span><br><span class="line">	&#125;</span><br><span class="line">        <span class="comment">//子类与基类函数同名，且无virtual关键字，隐藏</span></span><br><span class="line">        <span class="comment">//参数不同的隐藏</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> x)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Derived::g(int)"</span>&lt;&lt; x &lt;&lt;<span class="built_in">endl</span>;     <span class="comment">//隐藏</span></span><br><span class="line">	&#125;</span><br><span class="line">        <span class="comment">//参数相同的隐藏</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">(<span class="keyword">float</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Derived::h(float)"</span>&lt;&lt; x &lt;&lt;<span class="built_in">endl</span>;   <span class="comment">//隐藏</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Derived d;        <span class="comment">//子类对象</span></span><br><span class="line">	Base *pb = &amp;d;    <span class="comment">//基类类型指针，指向子类对象</span></span><br><span class="line">	Derived *pd = &amp;d; <span class="comment">//子类类型指针，指向子类对象</span></span><br><span class="line">	<span class="comment">// Good : behavior depends solely on type of the object</span></span><br><span class="line">	pb-&gt;f(<span class="number">3.14f</span>);   <span class="comment">// Derived::f(float) 3.14  调用子类方法，多态</span></span><br><span class="line">	pd-&gt;f(<span class="number">3.14f</span>);   <span class="comment">// Derived::f(float) 3.14  调用自己方法</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Bad : behavior depends on type of the pointer</span></span><br><span class="line">	pb-&gt;g(<span class="number">3.14f</span>);   <span class="comment">// Base::g(float)  3.14 </span></span><br><span class="line">	pd-&gt;g(<span class="number">3.14f</span>);   <span class="comment">// Derived::g(int) 3 </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Bad : behavior depends on type of the pointer</span></span><br><span class="line">	pb-&gt;h(<span class="number">3.14f</span>);   <span class="comment">// Base::h(float) 3.14</span></span><br><span class="line">	pd-&gt;h(<span class="number">3.14f</span>);   <span class="comment">// Derived::h(float) 3.14</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有virtual才可能发生多态现象，不发生多态（无virtual）调用就按原类型调用 。</p><p>上面的程序中：</p><p>（1）函数Derived::f(float)覆盖了Base::f(float)，发生多态重写（覆盖）。</p><p>（2）函数Derived::g(int)隐藏了Base::g(float)，而不是重载。</p><p>（3）函数Derived::h(float)隐藏了Base::h(float)，而不是覆盖。</p><p>总结为：在基类与子类函数名相同的前提下，根据参数是否相同、是否具有vritual关键字，可分为4种情况：</p><ol><li>参数相同、有virtual关键字：多态重写；</li><li>参数相同、无virtual关键字：隐藏；与重写区分。</li><li>参数不同、有virtual关键字：隐藏；与重载区分。</li><li>参数不同、无virtual关键字：隐藏；与重载区分。</li></ol></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/66c8de20.html">C&C++/指向派生对象的基类的指针和引用</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月13日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：2k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：9分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/121-pointers-and-references-to-the-base-class-of-derived-objects/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/121-pointers-and-references-to-the-base-class-of-derived-objects/</a></p><hr><p>在前一章中，您学习了如何使用继承从现有类派生新类的所有知识。在本章中，我<strong>们将重点讨论继承最重要和最强大的方面之一——虚拟函数。</strong></p><p>但是在我们讨论什么是虚函数之前，让我们先来设置为什么需要它们。</p><blockquote><p>在 <a href="http://www.learncpp.com/cpp-tutorial/113-order-of-construction-of-derived-classes/" target="_blank" rel="noopener">construction of derived classes</a>中，<strong>您了解了在创建派生类时，它由多个部分组成：一部分是继承的类；另一部分是它本身。</strong></p></blockquote><p>例如，这里有一个简单的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(<span class="keyword">int</span> value)</span><br><span class="line">        : m_value&#123; value &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Base"</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">int</span> value)</span><br><span class="line">        : Base&#123; value &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Derived"</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValueDoubled</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_value * <span class="number">2</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们创建一个派生对象时，它包含一个基类Base 部分(<strong>首先构造</strong>) 和 一个派生Derived部分<strong>(其次构造</strong>)。请记住，继承意味着两个类之间存在一个is-a关系。因为 派生的is-a 基，<strong>所以派生的包含基部分是合适的。</strong></p><h1 id="指针、引用和派生类"><a href="#指针、引用和派生类" class="headerlink" title="指针、引用和派生类"></a>指针、引用和派生类</h1><p>这应该是相当直观的，我们可以设置派生指针和引用的派生对象:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived&#123; <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"derived is a "</span> &lt;&lt; derived.getName() &lt;&lt; <span class="string">" and has value "</span> &lt;&lt; derived.getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    Derived &amp;rDerived&#123; derived &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rDerived is a "</span> &lt;&lt; rDerived.getName() &lt;&lt; <span class="string">" and has value "</span> &lt;&lt; rDerived.getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    Derived *pDerived&#123; &amp;derived &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"pDerived is a "</span> &lt;&lt; pDerived-&gt;getName() &lt;&lt; <span class="string">" and has value "</span> &lt;&lt; pDerived-&gt;getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指向派生类对象的基类指针与引用"><a href="#指向派生类对象的基类指针与引用" class="headerlink" title="指向派生类对象的基类指针与引用"></a>指向派生类对象的基类指针与引用</h2><p>然而，由于Derived有一个基部分，<strong>一个更有趣的问题是c++是否会让我们设置一个基指针或引用到一个派生的对象。事实证明，我们可以!</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived&#123; <span class="number">5</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面的也是合理的</span></span><br><span class="line">    Base &amp;rBase &#123;derived&#125;;</span><br><span class="line">    Base *pBase &#123;&amp;deriverd&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"derived is a "</span> &lt;&lt; derived.getName() &lt;&lt; <span class="string">" and has value "</span> &lt;&lt; derived.getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rBase is a "</span> &lt;&lt; rBase.getName() &lt;&lt; <span class="string">" and has value "</span> &lt;&lt; rBase.getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"pBase is a "</span> &lt;&lt; pBase-&gt;getName() &lt;&lt; <span class="string">" and has value "</span> &lt;&lt; pBase-&gt;getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为rBase和pBase是一个基类的引用和指针，所以它们只能看到基类的成员(或者基类继承的任何类)。</p><p>因此，即使<code>Derived::getName()</code> 的阴影(隐藏)<code>Base::getName()</code>的派生对象，基指针/引用不能看到<code>Derived::getName()</code>。</p><p>因此，它们调用<code>Base::getName()</code>，这就是为什么rBase和pBase报告说它们是基而不是派生的。</p><blockquote><p><strong>注意，这也意味着不可能使用rBase或pBase调用<code>Derived::getValueDoubled()</code>。他们看不到任何衍生的东西。</strong></p></blockquote><hr><p>另一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//我们使这个构造函数受保护，因为</span></span><br><span class="line">	<span class="comment">//我们不希望人们直接创建动物对象，</span></span><br><span class="line">	<span class="comment">//但是我们仍然希望派生类能够使用它。</span></span><br><span class="line">	Animal(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name) : m_name &#123;name&#125;</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::string_view <span class="title">speak</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"???"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Cat(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name) : Animal&#123;name&#125;</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::string_view <span class="title">speak</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Meow"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Dog(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name) : Animal&#123;name&#125;</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="built_in">std</span>::string_view <span class="title">speak</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Woof"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	Cat cat&#123; <span class="string">"Freed"</span> &#125;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"cat is named "</span> &lt;&lt; cat.getName() &lt;&lt; <span class="string">", and it says"</span></span><br><span class="line">		&lt;&lt; cat.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">	Dog dog&#123; <span class="string">"HeiHu"</span> &#125;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"dog is named "</span> &lt;&lt; dog.getName() &lt;&lt; <span class="string">", and it says "</span></span><br><span class="line">		&lt;&lt; dog.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">	Animal* pAnimal&#123; &amp;cat &#125;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"pAnimal is named "</span> &lt;&lt; pAnimal-&gt;getName() &lt;&lt; <span class="string">", and it says "</span></span><br><span class="line">		&lt;&lt; pAnimal-&gt;speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">	pAnimal = &amp;dog;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"pAnimal is named "</span> &lt;&lt; pAnimal-&gt;getName() &lt;&lt; <span class="string">", and it says "</span> </span><br><span class="line">		&lt;&lt; pAnimal-&gt;speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">cat is named Fred, <span class="keyword">and</span> it says Meow</span><br><span class="line">dog is named Garbo, <span class="keyword">and</span> it says Woof</span><br><span class="line">pAnimal is named Fred, <span class="keyword">and</span> it says ???</span><br><span class="line">pAnimal is named Garbo, <span class="keyword">and</span> it says ???</span><br></pre></td></tr></table></figure><p>我们在这里看到了同样的问题。因为pAnimal是一个动物指针，所以它只能看到类的动物部分。<strong>因此，pAnimal-&gt;speak()调用Animal::speak()，而不是Dog:: speak()或Cat::speak()函数。</strong></p><hr><h2 id="用于指向基类的指针和引用"><a href="#用于指向基类的指针和引用" class="headerlink" title="用于指向基类的指针和引用"></a>用于指向基类的指针和引用</h2><p>现在你可能会说，“上面的例子看起来有点傻。当我可以使用派生对象时，为什么要设置一个指针或引用来指向派生对象的基类?“事实证明，有相当多的理由。</p><ul><li><p>首先，假设您想编写一个函数来打印动物的名字和声音。<strong>如果不使用指向基类的指针，就必须使用重载函数来编写它</strong>，如下所示:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">report</span><span class="params">(<span class="keyword">const</span> Cat &amp;cat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cat.getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; cat.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">report</span><span class="params">(<span class="keyword">const</span> Dog &amp;dog)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; dog.getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; dog.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难，但是想想如果我们有30种不同的动物而不是2种，会发生什么。你必须写30个几乎相同的函数!另外，如果你添加了一种新的动物，你也必须为它写一个新的函数。考虑到唯一真正的区别是参数的类型，这是一个巨大的时间浪费。</p><p>然而，因为Cat 和 Dog 派生于 Animal，Cat 和 Dog 有一个Animal的部分。因此，我们应该能够这样做是有意义的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">report</span><span class="params">(<span class="keyword">const</span> Animal &amp;rAnimal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rAnimal.getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; rAnimal.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将允许我们传入任何派生自Animal的类，甚至是我们在编写函数之后创建的类! 不是每个派生类都有一个函数，而是有一个函数可以处理所有从Animal派生的类!</p><p>当然，问题是，因为rAnimal是一个 Animal 引用，所以rAnimal.speak()将调用Animal::speak()，而不是speak()的派生版本。</p></li><li><p>其次，假设您有3只猫和3只狗，您希望将它们放在一个数组中，以便于访问。因为数组只能保存一种类型的对象，没有指针或对基类的引用，所以必须为每个派生类型创建不同的数组，如下所示:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cat cats[]&#123; &#123; <span class="string">"Fred"</span> &#125;, &#123; <span class="string">"Misty"</span> &#125;, &#123; <span class="string">"Zeke"</span> &#125; &#125;;</span><br><span class="line">    Dog dogs[]&#123; &#123; <span class="string">"Garbo"</span> &#125;, &#123; <span class="string">"Pooky"</span> &#125;, &#123; <span class="string">"Truffle"</span> &#125; &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cat : cats)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cat.getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; cat.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;dog : dogs)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; dog.getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; dog.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，考虑一下如果你有30种不同的动物会发生什么。你需要30个数组，每种动物一个!</p><p>然而，因为猫和狗都来自于动物，我们应该能够做这样的事情是有道理的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cat fred&#123; <span class="string">"Fred"</span> &#125;;</span><br><span class="line">    Cat misty&#123; <span class="string">"Misty"</span> &#125;;</span><br><span class="line">    Cat zeke&#123; <span class="string">"Zeke"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    Dog garbo&#123; <span class="string">"Garbo"</span> &#125;;</span><br><span class="line">    Dog pooky&#123; <span class="string">"Pooky"</span> &#125;;</span><br><span class="line">    Dog truffle&#123; <span class="string">"Truffle"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 设置一个指向animals的 指针数组，并将这些指针设置为指向我们的Cat和Dog对象</span></span><br><span class="line">    Animal *animals[]&#123; &amp;fred, &amp;garbo, &amp;misty, &amp;pooky, &amp;truffle, &amp;zeke &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> animal : animals)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; animal-&gt;getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; animal-&gt;speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然他们可编译，可执行时，不幸的是，数组“animals”的每个元素都是指向动物的指针，这意味着animals[iii]-&gt;speak()将调用Animal::speak()，而不是我们想要的speak()的派生类版本。</p><p><strong>虽然这两种技术都可以节省我们大量的时间和精力，但它们都有相同的问题。指向基类的指针或引用调用函数的基版本，而不是派生版本。如果有什么方法可以让这些基指针调用函数的派生版本而不是基版本就好了……</strong> -————虚函数</p></li></ul></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/38f967fd.html">C&C++/多重继承</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月13日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：756字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：3分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/117-multiple-inheritance/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/117-multiple-inheritance/</a></p><hr><h1 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h1><p>到目前为止，我们介绍的所有继承示例都是<strong>单继承——也就是说，每个继承的类都有且只有一个父类</strong>。</p><p>然而，<strong>c++提供了进行多重继承的能力。多重继承使派生类能够从多个父类继承成员</strong>。</p><p>假设，假设我们想要编写一个程序来跟踪一群老师。老师是一个人，同时也是一个雇员(如果为自己工作，他们就是自己的雇主)。</p><blockquote><p>多重继承可用于创建教师类，该类继承Person和Employee的属性。</p></blockquote><p><strong>要使用多重继承，只需指定每个基类(就像在单继承中一样)，中间用逗号分隔。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="http://www.learncpp.com/images/CppTutorial/Section11/PersonTeacher.gif" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="built_in">std</span>::<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">        : m_name(name), m_age(age)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_age; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_employer;</span><br><span class="line">    <span class="keyword">double</span> m_wage;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Employee(<span class="built_in">std</span>::<span class="built_in">string</span> employer, <span class="keyword">double</span> wage)</span><br><span class="line">        : m_employer(employer), m_wage(wage)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">getEmployer</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_employer; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getWage</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_wage; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Teacher publicly inherits Person and Employee</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>:</span> <span class="keyword">public</span> Person, <span class="keyword">public</span> Employee  <span class="comment">//⭐记得用 逗号 隔开</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">     <span class="keyword">int</span> m_teachesGrade;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Teacher(<span class="built_in">std</span>::<span class="built_in">string</span> name, <span class="keyword">int</span> age, <span class="built_in">std</span>::<span class="built_in">string</span> employer, <span class="keyword">double</span> wage, <span class="keyword">int</span> teachesGrade)</span><br><span class="line">        : Person(name, age), Employee(employer, wage), m_teachesGrade(teachesGrade)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="多重继承的问题"><a href="#多重继承的问题" class="headerlink" title="多重继承的问题"></a>多重继承的问题</h1><p>虽然多重继承看起来像是单继承的简单扩展，但是多重继承引入了很多问题，这些问题会显著增加程序的复杂性，使它们成为维护的梦魇。让我们来看看这些情况。</p><ul><li>首先，<strong>当多个基类包含具有相同名称的函数时，可能会导致歧义</strong>。例如:</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">USBDevice</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">long</span> m_id;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    USBDevice(<span class="keyword">long</span> id)</span><br><span class="line">        : m_id(id)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getID</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_id; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkDevice</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">long</span> m_id;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NetworkDevice(<span class="keyword">long</span> id)</span><br><span class="line">        : m_id(id)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getID</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_id; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WirelessAdapter</span>:</span> <span class="keyword">public</span> USBDevice, <span class="keyword">public</span> NetworkDevice</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    WirelessAdapter(<span class="keyword">long</span> usbId, <span class="keyword">long</span> networkId)</span><br><span class="line">        : USBDevice(usbId), NetworkDevice(networkId)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">WirelessAdapter <span class="title">c54G</span><span class="params">(<span class="number">5442</span>, <span class="number">181742</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c54G.getID(); <span class="comment">// Which getID() do we call?⭐</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译<code>c54G.getID()</code>时，编译器会查看WirelessAdapter是否包含一个名为<code>getID()</code>的函数。它没有。</p><p>然后编译器查看父类中是否有一个名为getID()的函数。看到问题了吗? <u>问题是，c54G实际上包含两个getID()函数:一个继承自USBDevice，另一个继承自NetworkDevice。</u></p><p>因此，这个函数调用是不明确的，如果尝试编译它，您将收到一个编译器错误。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>但是，有一种方法可以解决这个问题: <strong>您可以显式地指定要调用的版本</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">WirelessAdapter <span class="title">c54G</span><span class="params">(<span class="number">5442</span>, <span class="number">181742</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c54G.USBDevice::getID(); <span class="comment">//⭐</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这个解决方法非常简单，但是当您的类继承了从其他类本身继承的4或6个基类时，您可以看到事情会变得多么复杂。随着继承更多的类，命名冲突的可能性呈指数级增加，并且每一个命名冲突都需要显式地解决。</p></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/c4d17f90.html">C&C++/改变继承的成员的访问级别 及 隐藏继承自父类的成员</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月13日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：973字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：3分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/11-6b-hiding-inherited-functionality/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/11-6b-hiding-inherited-functionality/</a></p><hr><h1 id="更改-继承成员的访问级别"><a href="#更改-继承成员的访问级别" class="headerlink" title="更改 继承成员的访问级别"></a>更改 继承成员的访问级别</h1><p><strong>C++使我们能够在派生类中更改继承成员的访问说明符。这是通过使用<code>using</code>来声明 (限定作用域的)基类成员 在派生类的新访问说明符下 更改其访问权限。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(<span class="keyword">int</span> value)</span><br><span class="line">        : m_value(value)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printValue</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_value; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>因为<code>Base::printValue()</code>已经被声明为 protected，所以它只能被Base或它的派生类调用。</p></blockquote><p>让我们定义一个派生类，<strong>它将printValue() 在该派生类中的访问说明符更改为public</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">int</span> value)</span><br><span class="line">        : Base(value)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Base::printValue 之前被继承为受保护的，所以公众没有权限访问</span></span><br><span class="line">    <span class="comment">// 但我们通过 using声明 将其改为pubic</span></span><br><span class="line">    <span class="keyword">using</span> Base::printValue; <span class="comment">// note: 没有小括号⭐</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这意味着这个代码将工作:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">derived</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// printValue is public in Derived, so this is okay</span></span><br><span class="line">    derived.printValue(); <span class="comment">// prints 7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li><p>首先，您<strong>只能</strong>更改派生类通常能够访问的基本成员的访问说明符。因此，<strong>永远不能将基成员的访问说明符从private更改为protected或public，因为派生类不能访问基类的私有成员。</strong></p></li><li><p>其次，从c++ 11开始，using声明 是改变访问级别的首选方法。但是，您也可以通过使用“访问声明”来更改访问级别。这与using声明方法的工作方式相同，<u>但是省略了“using”关键字。</u></p><blockquote><p>这种重新定义访问的<u>访问声明</u>方式现在被认为是不赞成的，但是您可能会看到使用这种模式的旧代码，因此值得了解。</p></blockquote></li></ul><h1 id="将功能隐藏起来"><a href="#将功能隐藏起来" class="headerlink" title="将功能隐藏起来"></a>将功能隐藏起来</h1><p><strong>在c++中，除了修改源代码外，不可能从基类中删除或限制功</strong>能。</p><p>但是，在派生类中，可以隐藏基类中存在的函数，这样就不能通过派生类访问它。<strong>这可以通过更改相关的 访问说明符来完成。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> m_value;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">using</span> Base::m_value;  <span class="comment">//⭐将Base类中的 (public)成员变量m_value 的访问属性修改为private</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Derived(<span class="keyword">int</span> value)</span><br><span class="line">	<span class="comment">// 我们不能初始化m_value，因为它是一个基类的 成员(基类 必须初始化它)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 但我们可以给它赋值</span></span><br><span class="line">		m_value = value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Derived <span class="title">derived</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 因为m_value已经被重新定义为private，所以下面的代码不能用</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; derived.m_value; <span class="comment">//✖</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这允许我们获取设计糟糕的基类，并将其数据封装在我们的派生类中。或者，与其公开继承Base的成员并通过覆盖它的访问说明符使m_value私有，我们可以私有的继承Base，这将首先导致所有的Base成员被私有继承。</p><hr><p><strong>你也可以在派生类中 将成员函数标记为delete，这确保了它们不能通过派生对象被调用</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">26</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">28</span></span><br><span class="line"><span class="number">29</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="number">31</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">33</span></span><br><span class="line"><span class="number">34</span></span><br><span class="line"><span class="number">35</span></span><br><span class="line"><span class="number">36</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_value;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Base(<span class="keyword">int</span> value)</span><br><span class="line">		: m_value(value)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Derived(<span class="keyword">int</span> value)</span><br><span class="line">		: Base(value)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>= <span class="keyword">delete</span>; <span class="comment">//⭐ mark this function as inaccessible</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Derived <span class="title">derived</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// The following won't work because getValue() has been deleted!</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; derived.getValue();</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们将getValue()函数标记为deleted。这意味着当我们试图调用函数的派生版本时，编译器会发出警告。</p><p><u>注意，getValue()的基本版本仍然是可访问的</u>。这意味着派生对象仍然可以访问getValue()，<strong>方法是先将派生对象向上转换为基对象</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Derived <span class="title">derived</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 我们仍然可以通过基类访问 在派生类中删除的函数</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;Base&gt;(derived).getValue(); <span class="comment">//⭐</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/cedb49a3.html">C&C++/调用 继承函数和覆盖行为</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月13日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：1.3k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：5分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/11-6a-calling-inherited-functions-and-overriding-behavior/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/11-6a-calling-inherited-functions-and-overriding-behavior/</a></p><hr><p>默认情况下，派生类继承基类中定义的所有行为。在本节课中，我们将更详细地研究如何选择成员函数，以及如何利用它来更改派生类中的行为。</p><h1 id="调用基类函数"><a href="#调用基类函数" class="headerlink" title="调用基类函数"></a>调用基类函数</h1><p>当使用派生类对象调用成员函数时，<strong>编译器首先查看该成员是否存在于派生类中。如果没有，它就开始遍历继承链并检查成员是否在任何父类中定义。它使用找到的第一个。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(<span class="keyword">int</span> value)</span><br><span class="line">        : m_value(value)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">identify</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a Base\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">int</span> value)</span><br><span class="line">        : Base(value)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">base</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    base.identify();</span><br><span class="line"> </span><br><span class="line">    <span class="function">Derived <span class="title">derived</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line">    derived.identify();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">I am a Base</span><br><span class="line">I am a Base</span><br></pre></td></tr></table></figure><p>当derived.identify()被调用时，编译器会查看Derived类中是否定义了identify()函数。它没有。然后它开始查找继承的类(在本例中是Base)。Base定义了一个identify()函数，所以它使用这个函数。换句话说，使用Base::identify()是因为派生的Derived::identify()不存在。</p><h1 id="重定义行为-重新定义父类中的函数"><a href="#重定义行为-重新定义父类中的函数" class="headerlink" title="重定义行为(重新定义父类中的函数)"></a>重定义行为(重新定义父类中的函数)</h1><p>但是，如果我们在派生类中定义了Derived::identify()，那么就会使用它。</p><p>这意味着我们可以通过在派生类中重新定义这个函数，来让函数以不同的方式工作!</p><p><strong>要修改基类中定义的函数在派生类中的工作方式，只需重新定义派生类中的函数。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">int</span> value)</span><br><span class="line">        : Base(value)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Here's our modified function</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">identify</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a Derived\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是与上面相同的例子，使用新的Derived::Identify()函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">base</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    base.identify();</span><br><span class="line"> </span><br><span class="line">    <span class="function">Derived <span class="title">derived</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line">    derived.identify();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I am a Base</span><br><span class="line">I am a Derived</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>注意，<strong>在派生类中重新定义函数时，派生函数不会继承基类中同名函数的访问说明符</strong>。它使用在派生类中定义的访问说明符。<strong>因此，在基类中定义为private的函数可以在派生类中重新定义为public，反之亦然!</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived "</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Derived derived;</span><br><span class="line">	derived.<span class="built_in">print</span>(); <span class="comment">// calls derived::print(), which is public</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="添加功能到现有的父类函数中"><a href="#添加功能到现有的父类函数中" class="headerlink" title="添加功能到现有的父类函数中"></a>添加功能到现有的父类函数中</h1><p><strong>有时我们并不想完全替换基类函数，而是希望向它添加额外的功能</strong>。在上面的例子中，注意派生的::identify()完全隐藏了Base::identify()! 这可能不是我们想要的<u>。可以让我们的派生函数调用同名函数的基本版本(以便重用代码)，然后向它添加额外的功能。</u></p><blockquote><p><strong>要让派生函数调用同名的基函数，只需执行一个普通的函数调用，但在函数前面加上作用域限定符(基类的名称和两个冒号)。</strong>下面的示例重新定义了Derived::identify()，因此它首先调用Base::identify()，然后执行它自己的附加操作。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">int</span> value)</span><br><span class="line">        : Base(value)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">identify</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Base::identify(); <span class="comment">// call Base::identify() first</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a Derived\n"</span>; <span class="comment">// then identify ourselves</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="为什么需要使用范围解析操作符"><a href="#为什么需要使用范围解析操作符" class="headerlink" title="为什么需要使用范围解析操作符(::)?"></a>为什么需要使用范围解析操作符(::)?</h2><p>如果我们像这样定义了Derived::identify():</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">int</span> value)</span><br><span class="line">        : Base(value)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">identify</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        identify(); <span class="comment">// Note: no scope resolution!</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a Derived"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>没有范围解析限定符的调用函数identify()将默认为当前类中的identify()，它实际上看起来是这种形式： Derived::identify()。</strong>这将导致Derived::identify()调用自身，这将导致无限循环!</p><h1 id="在派生类调用基类的友元函数"><a href="#在派生类调用基类的友元函数" class="headerlink" title="在派生类调用基类的友元函数"></a>在派生类调用基类的友元函数</h1><p>当我们试图在派生类调用基类的友元函数时，比如操作符&lt;&lt;，可能会遇到一点小麻烦。因为基类的friend函数实际上不是基类的一部分，<u>所以使用范围解析限定符不起作用</u>。相反，我们需要一种方法使我们的派生类暂时看起来像基类，这样就可以调用函数的正确版本。</p><blockquote><p><strong>幸运的是，使用static_cast很容易做到这一点</strong>。</p></blockquote><p>这里有一个例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_value;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Base(<span class="keyword">int</span> value)</span><br><span class="line">		: m_value(value)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (<span class="built_in">std</span>::ostream &amp;out, <span class="keyword">const</span> Base &amp;b)</span><br><span class="line">	&#123;</span><br><span class="line">		out &lt;&lt; <span class="string">"In Base\n"</span>;</span><br><span class="line">		out &lt;&lt; b.m_value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">		<span class="keyword">return</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Derived(<span class="keyword">int</span> value)</span><br><span class="line">		: Base(value)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (<span class="built_in">std</span>::ostream &amp;out, <span class="keyword">const</span> Derived &amp;d)</span><br><span class="line">	&#123;</span><br><span class="line">		out &lt;&lt; <span class="string">"In Derived\n"</span>;</span><br><span class="line">		<span class="comment">// static_cast派生到一个基对象, so we call the right version of operator&lt;&lt;</span></span><br><span class="line">		out &lt;&lt; <span class="keyword">static_cast</span>&lt;Base&gt;(d);  <span class="comment">//⭐</span></span><br><span class="line">		<span class="keyword">return</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Derived <span class="title">derived</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; derived;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">In derived <span class="comment">//先运行 “out &lt;&lt; "In Derived\n";”</span></span><br><span class="line">In base <span class="comment">//然后调用 基类Base中的友元函数</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><p>因为Derived类 派生自 Base类，<strong>所以我们可以将派生对象转换为基，这样就可以调用使用基的操作符&lt;&lt;的适当版本。</strong></p></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/664c52ef.html">C&C++/继承中的访问标识符</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月13日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：1.9k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：7分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/115-inheritance-and-access-specifiers/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/115-inheritance-and-access-specifiers/</a></p><hr><h1 id="private、public、protected"><a href="#private、public、protected" class="headerlink" title="private、public、protected"></a><code>private</code>、<code>public</code>、<code>protected</code></h1><ul><li><p><strong><code>private</code></strong>：私有成员只能由同一类或 friends 的成员函数访问。这意味着派生类不能直接访问基类的私有成员!</p><blockquote><p><strong>当类中的成员没有显式的给定 访问说明符，C++则默认其为：<code>private</code></strong></p></blockquote></li><li><p><strong><code>public</code></strong>：任何人都可以访问公共成员</p></li></ul><h2 id="protected受保护的访问说明符"><a href="#protected受保护的访问说明符" class="headerlink" title="protected受保护的访问说明符"></a><code>protected</code>受保护的访问说明符</h2><p>在处理继承类时，事情会变得有点复杂。</p><p>c++有一个我们还没有讨论的第三个访问说明符：<strong><code>protected</code>，因为它只在继承上下文中有用</strong>。</p><p><strong>受保护的访问说明符允许成员所属的类、朋友类和派生类访问成员</strong>。<strong>但是，受保护成员不能从类外部访问。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_public; <span class="comment">// can be accessed by anybody</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_protected; <span class="comment">// can be accessed by Base members, friends, and derived classes</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_private; <span class="comment">// can only be accessed by Base members and friends (but not derived classes)</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived()</span><br><span class="line">    &#123;</span><br><span class="line">        m_public = <span class="number">1</span>; <span class="comment">// allowed: can access public base members from derived class</span></span><br><span class="line">        m_protected = <span class="number">2</span>; <span class="comment">// allowed: can access protected base members from derived class</span></span><br><span class="line">        m_private = <span class="number">3</span>; <span class="comment">// not allowed: can not access private base members from derived class</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base base;</span><br><span class="line">    base.m_public = <span class="number">1</span>; <span class="comment">// allowed: can access public members from outside class</span></span><br><span class="line">    base.m_protected = <span class="number">2</span>; <span class="comment">//⭐ not allowed: can not access protected members from outside class</span></span><br><span class="line">    base.m_private = <span class="number">3</span>; <span class="comment">// not allowed: can not access private members from outside class</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，您可以看到受保护的基本成员<code>m_protected</code>可由派生类Derived直接访问，而不是由公共访问。</p><h3 id="何时使用受保护的访问说明符"><a href="#何时使用受保护的访问说明符" class="headerlink" title="何时使用受保护的访问说明符?"></a>何时使用受保护的访问说明符?</h3><p>基类中的<code>protected</code>属性的成员，派生类可以直接访问该成员。<strong>这意味着，如果您以后更改了关于protected属性的任何内容(类型、值的含义等等)，您可能需要同时更改基类和所有派生类。</strong></p><p>因此，当您(或您的团队)是从您自己的类派生出来的，并且派生类的数量是合理的时，使用受保护的访问说明符是最有用的。<strong>这样，如果您对基类的实现进行了更改，并且因此需要对派生类进行更新，那么您可以自己进行更新(并且更新不会永远进行，因为派生类的数量是有限的)。</strong></p><hr><p><strong>将成员设为私有可以提供更好的封装，并将派生类与对基类的更改隔离开来</strong>。但是，构建一个公共或受保护的接口来支持公共 和/或 派生类所需的所有访问方法或功能也是有成本的。这是额外的工作，可能不值得，除非您期望其他人是从您的类派生出来的，或者您有大量的派生类，更新它们的成本将非常昂贵。</p><h1 id="不同种类的继承及其对访问的影响"><a href="#不同种类的继承及其对访问的影响" class="headerlink" title="不同种类的继承及其对访问的影响"></a>不同种类的继承及其对访问的影响</h1><p>首先，类从其他类继承有三种不同的方法:public、protected和private。</p><p>要做到这一点，只需指定在选择要继承的类时想要的访问类型:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inherit from Base publicly</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pub</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Inherit from Base protectedly</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pro</span>:</span> <span class="keyword">protected</span> Base</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Inherit from Base privately</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pri</span>:</span> <span class="keyword">private</span> Base</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Def</span>:</span> Base <span class="comment">// Defaults to private inheritance</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>如果不选择继承类型，c++默认为私有继承(就像如果不指定其他类型，成员默认为私有访问)</strong></p><p>这给了我们9种组合:3种成员访问说明符(公共、私有和受保护)，以及3种继承类型(公共、私有和受保护)。</p><p>它们之间有什么区别呢? 简而言之，当成员被继承时，继承成员的访问说明符可能会根据使用的继承类型而改变(仅在派生类中)。换句话说，<strong>基类中为公有或受保护的成员可能会更改派生类中的访问说明符。</strong></p><p>当我们逐步分析这些例子时，请记住以下规则:</p><ul><li>一个类总是可以访问它自己的(非继承的)成员。</li><li>公共访问类的成员基于它正在访问的类的访问说明符。</li><li>类根据从父类继承的访问说明符访问继承的成员。这取决于所使用的访问说明符和继承类型。</li></ul><h2 id="公有继承"><a href="#公有继承" class="headerlink" title="公有继承"></a>公有继承</h2><p><strong>公有继承</strong>是目前最常用的继承类型。事实上，您很少会看到或使用其他类型的继承，所以您的主要关注点应该是理解这一部分。幸运的是，公共继承也是最容易理解的。<strong>当您公开继承基类时，</strong></p><ul><li><strong>继承的公共成员保持为public</strong>；</li><li><strong>继承的受保护成员保持为protected。</strong>；</li><li><strong>继承的私有成员保持不可访问，因为它们在基类中是私有的。</strong></li></ul><table><thead><tr><th align="left">Access specifier in base class</th><th align="left">Access specifier when inherited publicly</th></tr></thead><tbody><tr><td align="left">Public</td><td align="left">Public</td></tr><tr><td align="left">Protected</td><td align="left">Protected</td></tr><tr><td align="left">Private</td><td align="left">Inaccessible</td></tr></tbody></table><h2 id="保护继承"><a href="#保护继承" class="headerlink" title="保护继承"></a>保护继承</h2><p><strong>受保护继承</strong>是最不常见的继承方法。它几乎从未被使用过，除非在非常特殊的情况下。有了受保护的继承，</p><ul><li><strong>公共成员</strong>和<strong>受保护的成员</strong>就得到了保护；</li><li>而<strong>私有成员</strong>则无法访问。</li></ul><p>因为这种形式的继承非常罕见，我们就跳过这个例子，用一个表格总结一下:</p><table><thead><tr><th align="left">Access specifier in base class</th><th align="left">Access specifier when inherited protectedly</th></tr></thead><tbody><tr><td align="left">Public</td><td align="left">Protected</td></tr><tr><td align="left">Protected</td><td align="left">Protected</td></tr><tr><td align="left">Private</td><td align="left">Inaccessible</td></tr></tbody></table><h2 id="私有继承"><a href="#私有继承" class="headerlink" title="私有继承"></a>私有继承</h2><p>使用<strong>私有继承</strong>，<strong>基类的所有成员都继承为私有</strong>。</p><ul><li>这意味着私有成员保持私有；</li><li>受保护 和 公共成员变 为私有。</li></ul><p>注意，<u>这并不影响派生类访问从父类继承的成员的方式</u>。它只影响试图通过派生类访问这些成员的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_public;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_protected;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_private;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pri</span>:</span> <span class="keyword">private</span> Base <span class="comment">// note: private inheritance</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Private inheritance means:</span></span><br><span class="line">    <span class="comment">// Public inherited members become private (so m_public is treated as private)</span></span><br><span class="line">    <span class="comment">// Protected inherited members become private (so m_protected is treated as private)</span></span><br><span class="line">    <span class="comment">// Private inherited members stay inaccessible (so m_private is inaccessible)</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Pri()</span><br><span class="line">    &#123;</span><br><span class="line">        m_public = <span class="number">1</span>; <span class="comment">// okay: m_public is now private in Pri</span></span><br><span class="line">        m_protected = <span class="number">2</span>; <span class="comment">// okay: m_protected is now private in Pri</span></span><br><span class="line">        m_private = <span class="number">3</span>; <span class="comment">// not okay: derived classes can't access private members in the base class</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Outside access uses the access specifiers of the class being accessed.</span></span><br><span class="line">    <span class="comment">// In this case, the access specifiers of base.</span></span><br><span class="line">    Base base;</span><br><span class="line">    base.m_public = <span class="number">1</span>; <span class="comment">// okay: m_public is public in Base</span></span><br><span class="line">    base.m_protected = <span class="number">2</span>; <span class="comment">// not okay: m_protected is protected in Base</span></span><br><span class="line">    base.m_private = <span class="number">3</span>; <span class="comment">// not okay: m_private is private in Base</span></span><br><span class="line"> </span><br><span class="line">    Pri pri;</span><br><span class="line">    pri.m_public = <span class="number">1</span>; <span class="comment">// not okay: m_public is now private in Pri</span></span><br><span class="line">    pri.m_protected = <span class="number">2</span>; <span class="comment">// not okay: m_protected is now private in Pri</span></span><br><span class="line">    pri.m_private = <span class="number">3</span>; <span class="comment">// not okay: m_private is inaccessible in Pri</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以表格形式总结:</p><table><thead><tr><th align="left">Access specifier in base class</th><th align="left">Access specifier when inherited privately</th></tr></thead><tbody><tr><td align="left">Public</td><td align="left">Private</td></tr><tr><td align="left">Protected</td><td align="left">Private</td></tr><tr><td align="left">Private</td><td align="left">Inaccessible</td></tr></tbody></table><p>当派生类与基类没有明显关系，但在内部使用基类实现时，私有继承可能非常有用。在这种情况下，我们可能不希望基类的公共接口通过派生类的对象公开(如果我们公开继承)。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>访问说明符、继承类型 和 派生类 相互作用的方式会引起很多混淆。尽可能多地尝试和澄清事情:</p><ul><li>首先，<strong>类(和friend )总是可以访问它自己的非继承成员</strong>。<strong>访问说明符只影响外部人员和派生类是否可以访问这些成员。</strong></li><li>其次，当派生类继承成员时，这些成员可能会更改派生类中的访问说明符。<strong>但这并不影响派生类自己的(非继承的)成员(它们有自己的访问说明符)</strong>。<strong>它只影响外部人员和派生自派生类的类是否可以访问这些继承的成员。</strong></li><li>最后要注意的是，尽管在上面的例子中，我们只展示了使用成员变量的例子，<strong>但是这些访问规则对所有成员都适用(例如，在类中声明的成员函数和类型)。</strong></li></ul><p>下面是所有访问说明符和继承类型组合的表:</p><table><thead><tr><th align="left">Access specifier in base class</th><th align="left">Access specifier when inherited publicly</th><th align="left">Access specifier when inherited privately</th><th align="left">Access specifier when inherited protectedly</th></tr></thead><tbody><tr><td align="left">Public</td><td align="left">Public</td><td align="left">Private</td><td align="left">Protected</td></tr><tr><td align="left">Protected</td><td align="left">Protected</td><td align="left">Private</td><td align="left">Protected</td></tr><tr><td align="left">Private</td><td align="left">Inaccessible</td><td align="left">Inaccessible</td><td align="left">Inaccessible</td></tr></tbody></table></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/f3aa0b39.html">C&C++/派生类的构造函数及初始化</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月13日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：2.2k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：8分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/114-constructors-and-initialization-of-derived-classes/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/114-constructors-and-initialization-of-derived-classes/</a></p><hr><p>我们将深入了解构造函数在派生类初始化中的作用。为此，我们将继续使用我们在前一课中开发的简单的基类和派生类:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_id;</span><br><span class="line"> </span><br><span class="line">    Base(<span class="keyword">int</span> id=<span class="number">0</span>)</span><br><span class="line">        : m_id&#123; id &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_id; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> m_cost;</span><br><span class="line"> </span><br><span class="line">    Derived(<span class="keyword">double</span> cost=<span class="number">0.0</span>)</span><br><span class="line">        : m_cost&#123; cost &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getCost</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_cost; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>对于<strong>非派生类</strong>，构造函数只需要担心自己的成员。例如，考虑Base。我们可以像这样创建一个基对象:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base base&#123; <span class="number">5</span> &#125;; <span class="comment">// use Base(int) constructor</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是实例化base时实际发生的情况:</p><ol><li>为base 留出内存</li><li>调用适当的base的 构造函数</li><li>初始化列表 初始化变量</li><li>构造函数的主体执行</li><li>控件返回给调用方</li></ol></li><li><p>对于<strong>派生类</strong>，事情稍微复杂一些:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived&#123; <span class="number">1.3</span> &#125;; <span class="comment">// use Derived(double) constructor</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是实例化派生类时实际发生的情况:</p><ol><li>为derived 留出内存 (足够用于基部分和派生部分)</li><li>调用适当的Derived的 构造函数</li><li><strong>首先使用适当的 基构造函数 构造 基对象。如果没有指定基构造函数，则使用默认构造函数。</strong></li><li>初始化列表 初始化变量</li><li>构造函数的主体执行</li><li>控件返回给调用方</li></ol></li></ul><p>这种情况 与 非继承情况 之间的唯一真正区别是，<strong>在派生构造函数可以执行任何实质性操作之前，首先调用<u>基</u>构造函数</strong>。<strong>基构造函数设置对象的基部分，将控件返回给派生构造函数，并允许派生构造函数完成其工作。</strong></p><h1 id="初始化基类成员"><a href="#初始化基类成员" class="headerlink" title="初始化基类成员"></a>初始化基类成员</h1><p>我们的<strong>派生类</strong>当前的一个<u>缺点</u>是：当我们创建一个派生对象时，<strong>没有方法初始化m_id</strong>。如果我们想在创建派生对象时<strong>同时设置m_cost</strong> (来自对象的派生部分)<strong>和 m_id</strong> (来自对象的基本部分)，<u>该怎么办?</u></p><h2 id="错误的初始化"><a href="#错误的初始化" class="headerlink" title="错误的初始化"></a>错误的初始化</h2><blockquote><p>新程序员经常尝试解决这个问题如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> m_cost;</span><br><span class="line"> </span><br><span class="line">    Derived(<span class="keyword">double</span> cost=<span class="number">0.0</span>, <span class="keyword">int</span> id=<span class="number">0</span>)</span><br><span class="line">        <span class="comment">// does not work</span></span><br><span class="line">        : m_cost&#123; cost &#125;, m_id&#123; id &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getCost</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_cost; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是一个很好的尝试，而且几乎是正确的想法。我们<strong>确实需要向构造函数中添加另一个参数，否则c++将无法知道我们想要初始化m_id为什么值。</strong></p><p>但是，<strong>c++<u>不允许</u>类在构造函数的初始化列表中<u>初始化继承的成员变量</u></strong>。<strong>换句话说，变量的值只能在该变量所在的那个类的 构造函数的初始化列表中设置。</strong></p><blockquote><p>为啥会有这个限制？</p><p><strong>答案与const和引用变量有关</strong>。考虑一下如果m_id是常量会发生什么。因为const变量必须在创建时用一个值初始化，所以基类构造函数必须在创建变量时设置它的值。但是，当基类构造函数完成时，派生类构造函数的初始化列表就会执行。然后，每个派生类都有机会初始化该变量，可能会更改其值!通过将变量的初始化限制在这些变量所属的类的构造函数中，c++确保所有变量只初始化一次。</p></blockquote><p>最终的结果是上面的例子不起作用<strong>，因为m_id是从Base继承的，并且只有非继承的变量可以在初始化列表中初始化。</strong></p></blockquote><blockquote><p>但是，继承的变量仍然可以在构造函数体中<strong>使用赋值</strong>来更改它们的值。因此，新程序员也经常这样做:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> m_cost;</span><br><span class="line"> </span><br><span class="line">    Derived(<span class="keyword">double</span> cost=<span class="number">0.0</span>, <span class="keyword">int</span> id=<span class="number">0</span>)</span><br><span class="line">        : m_cost&#123; cost &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        m_id = id; <span class="comment">//⭐</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getCost</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_cost; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然这在这种情况是可行的，但是如果m_id是一个const或一个引用，它就不能工作(因为const值和引用必须在构造函数的初始化列表中初始化)。</p><p>它的效率也很低，因为m_id被赋值两次: 一次在基类构造函数的初始化列表中，一次在派生类构造函数的主体中。</p><p>最后，如果基类在构造过程中需要访问这个值，该怎么办?它没有办法访问它，因为它在派生构造函数执行之前是不设置的(基本上是最后执行)。</p></blockquote><h2 id="正确初始化"><a href="#正确初始化" class="headerlink" title="正确初始化"></a>正确初始化</h2><p>那么，当创建派生类对象时，我们如何正确初始化m_id呢?</p><blockquote><p>在到目前为止的所有示例中，当我们实例化一个派生类对象时，基类部分已经使用默认的基构造函数创建。为什么它总是使用默认的基构造函数? 因为我们从来没有让它使用其他的构造函数。</p></blockquote><p>幸运的是，<strong>C++允许我们显式地选择将调用哪个基类构造函数! 要做到这一点，<u>只需在派生类的初始化列表中添加对基类构造函数的调用</u>:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> m_cost;</span><br><span class="line"> </span><br><span class="line">    Derived(<span class="keyword">double</span> cost=<span class="number">0.0</span>, <span class="keyword">int</span> id=<span class="number">0</span>)</span><br><span class="line">        : Base&#123; id &#125;, <span class="comment">// ⭐Call Base(int) constructor with value id!</span></span><br><span class="line">            m_cost&#123; cost &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getCost</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_cost; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>现在，当我们执行这个代码时:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived&#123; <span class="number">1.3</span>, <span class="number">5</span> &#125;; <span class="comment">// use Derived(double, int) constructor</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Id: "</span> &lt;&lt; derived.getId() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Cost: "</span> &lt;&lt; derived.getCost() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Id: <span class="number">5</span></span><br><span class="line">Cost: <span class="number">1.3</span></span><br></pre></td></tr></table></figure><p>基类构造函数base (int) 将用于初始化m_id为 5，派生类构造函数将用于初始化m_cost为1.3 !</p><hr><p>更详细的细节：</p><ol><li>分配用于派生（derived ）的内存。</li><li>调用<code>Derived(double, int)</code>构造函数，其中cost = 1.3, id = 5</li><li>编译器会查看我们是否需要一个特定的基类构造函数。我们有! 因此它调用id = 5的Base(int)。</li><li>基类构造函数 初始化列表 将m_id设置为5</li><li>基类构造函数body执行，它什么也不做</li><li>基类构造函数返回</li><li>派生类构造函数初始化列表将m_cost设置为1.3</li><li>派生类构造函数body执行，它什么也不做</li><li>派生类构造函数返回</li></ol></blockquote><p>这看起来有点复杂，但实际上非常简单。所发生的一切就是<strong>派生构造函数调用特定的基构造函数来初始化对象的基部分</strong>。因为m_id位于对象的基部分中，所以基构造函数是惟一可以初始化该值的构造函数。</p><hr><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>注意，<strong>在派生构造函数初始化列表中调用 基构造函数 的位置并不重要——因为 基构造函数 总是先执行。</strong></p><h1 id="现在可以让我们的成员私有-private"><a href="#现在可以让我们的成员私有-private" class="headerlink" title="现在可以让我们的成员私有(private)"></a>现在可以让我们的成员私有(<code>private</code>)</h1><p>既然知道了如何初始化基类成员，<u>就不需要保持成员变量为公共</u>。<strong>我们再次将成员变量设为私有，这是应该的。</strong></p><blockquote><p>简单回顾一下，<strong>任何人都可以访问公共成员</strong>。</p><p><strong>私有成员只能由同一类的成员函数访问</strong>。注意，<strong>这意味着派生类不能直接访问基类的私有成员</strong> ! <strong>派生类将需要使用访问函数来访问基类的私有成员</strong>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// our member is now private</span></span><br><span class="line">    <span class="keyword">int</span> m_id;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(<span class="keyword">int</span> id=<span class="number">0</span>)</span><br><span class="line">        : m_id&#123; id &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_id; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// our member is now private</span></span><br><span class="line">    <span class="keyword">double</span> m_cost;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">double</span> cost=<span class="number">0.0</span>, <span class="keyword">int</span> id=<span class="number">0</span>)</span><br><span class="line">        : Base&#123; id &#125;, <span class="comment">// Call Base(int) constructor with value id!</span></span><br><span class="line">            m_cost&#123; cost &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getCost</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_cost; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived&#123; <span class="number">1.3</span>, <span class="number">5</span> &#125;; <span class="comment">// use Derived(double, int) constructor</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Id: "</span> &lt;&lt; derived.getId() &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//⭐通过访问函数访问私有成员</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Cost: "</span> &lt;&lt; derived.getCost() &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//⭐通过访问函数访问私有成员</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="派生类被销毁时调用析构函数的顺序"><a href="#派生类被销毁时调用析构函数的顺序" class="headerlink" title="派生类被销毁时调用析构函数的顺序"></a>派生类被销毁时调用析构函数的顺序</h1><p>当一个派生类被销毁时，<strong><u>每个析构函数都以相反的构造顺序被调用</u>。</strong></p><p>也就是说，我们派生类在被创建时，<strong>构造函数</strong>的调用顺序是：</p><ul><li>先调用 最基类的构造函数—-&gt; 子类的构造函数 —-&gt;子类的子类的构造函数—-&gt;….—–&gt;最后调用 最子类的构造函数。</li></ul><p>在销毁派生类时，<strong>析构函数</strong>调用的顺序：</p><ul><li>首先调用 最子类的析构函数—-&gt;….———&gt;最后调用 最基类的析构函数</li></ul></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/64f81817.html">C&C++/派生类的构造顺序</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月13日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：664字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：2分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/113-order-of-construction-of-derived-classes/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/113-order-of-construction-of-derived-classes/</a></p><hr><p>首先，让我们引入一些新类来帮助我们阐明一些重要的观点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_id;</span><br><span class="line"> </span><br><span class="line">    Base(<span class="keyword">int</span> id=<span class="number">0</span>)</span><br><span class="line">        : m_id(id)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_id; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> m_cost;</span><br><span class="line"> </span><br><span class="line">    Derived(<span class="keyword">double</span> cost=<span class="number">0.0</span>)</span><br><span class="line">        : m_cost(cost)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getCost</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_cost; &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在本例中，Derived类 是从 Base类 派生的。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="http://www.learncpp.com/images/CppTutorial/Section11/DerivedBase.gif" alt="img"></p><p>因为Derived 继承了Base的函数和变量，所以可以假设 Base的成员被<strong>复制</strong>到派生的。<strong>然而，事实并非如此</strong>。<strong>相反，我们可以将派生类考虑为两个部分的类:一个部分Derived，一个部分Base。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="http://www.learncpp.com/images/CppTutorial/Section11/DerivedBaseCombined.gif" alt="img"></p><p>当我们实例化一个普通(非派生)类时会发生什么:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base base;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Base是一个非派生类，因为它不从任何其他类继承。</span></span><br><span class="line"><span class="comment">//c++为Base分配内存，然后调用Base的默认构造函数来进行初始化。</span></span><br></pre></td></tr></table></figure><p>现在让我们看看当我们实例化一个派生类时会发生什么:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当我们实例化一个Derived实例时，首先构造了Derived的 基部分(使用基默认构造函数)。一旦基本部分完成，派生部分 就被构造(使用派生的默认构造函数)。在这一点上，没有更多的派生类，所以我们完成了。</span></span><br></pre></td></tr></table></figure><h1 id="派生类的构造顺序"><a href="#派生类的构造顺序" class="headerlink" title="派生类的构造顺序"></a>派生类的构造顺序</h1><p>如上所述，<u>派生实际上包括两部分</u>: <strong>基础部分 和 派生部分</strong>。当c++构造派生对象时，它是分阶段进行的。</p><ul><li>首先，首先构造<strong>最基本的类</strong>(在继承树的顶部)。</li><li>然后按顺序构造每个<strong>子类</strong>，直到最后构造 <strong>最子类</strong>(在继承树的底部)。</li></ul><p>用一个程序来说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_id;</span><br><span class="line"> </span><br><span class="line">    Base(<span class="keyword">int</span> id=<span class="number">0</span>)</span><br><span class="line">        : m_id(id)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_id; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> m_cost;</span><br><span class="line"> </span><br><span class="line">    Derived(<span class="keyword">double</span> cost=<span class="number">0.0</span>)</span><br><span class="line">        : m_cost(cost)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getCost</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_cost; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Instantiating Base\n"</span>;</span><br><span class="line">    Base cBase;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Instantiating Derived\n"</span>;</span><br><span class="line">    Derived cDerived;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Instantiating Base</span><br><span class="line">Base</span><br><span class="line">Instantiating Derived</span><br><span class="line">Base</span><br><span class="line">Derived</span><br><span class="line"><span class="comment">//可以看到，当我们构造派生函数时，首先构造派生函数的基部分。</span></span><br><span class="line"><span class="comment">//这是有道理的:从逻辑上讲，没有父元素，子元素就不能存在。</span></span><br><span class="line"><span class="comment">//这也是一种安全的方法:子类经常使用来自父类的变量和函数，但是父类对子类一无所知。</span></span><br><span class="line"><span class="comment">//实例化父类首先确保在创建派生类并准备使用它们时已经初始化了这些变量。</span></span><br></pre></td></tr></table></figure></div></section></article></div></section><br><div class="prev-next"><a class="prev" rel="prev" href="/page/5/"><section class="post prev white-box shadow"><i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页&nbsp;</section></a><p class="current">6 / 15</p><a class="next" rel="next" href="/page/7/"><section class="post next white-box shadow">&nbsp;下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i></section></a></div></div><aside class="l_side"><section class="widget blogger shadow desktop"><div class="content"><div class="avatar"><img class="avatar" src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"></div><div class="text"><p><span id="jinrishici-sentence">龙龙‘S BLOG</span></p><script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script></div><div class="social-wrapper"><a href="/atom.xml" class="social fas fa-rss flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="mailto:1198216723@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://github.com/longlongqin" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://music.163.com/#/user/home?id=285545421" class="social fas fa-headphones-alt flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a></div></div></section><section class="widget grid shadow desktop mobile"><header><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i><span class="name">站内导航</span></header><div class="content"><div class="grid navigation"><a class="flat-box" title="/" href="/" id="home"><i class="fas fa-clock fa-fw" aria-hidden="true"></i> 近期文章 </a><a class="flat-box" title="/archives/" href="/archives/" rel="nofollow" id="archives"><i class="fas fa-archive fa-fw" aria-hidden="true"></i> 文章归档 </a><a class="flat-box" title="/friends/" href="/friends/" rel="nofollow" id="friends"><i class="fas fa-link fa-fw" aria-hidden="true"></i> 友人帐 </a><a class="flat-box" title="/about/" href="/about/" rel="nofollow" id="about"><i class="fas fa-info-circle fa-fw" aria-hidden="true"></i> 关于小站</a></div></div></section><section class="widget category shadow desktop"><header><a href="/blog/categories/"><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i><span class="name">文章分类</span></a></header><div class="content"><ul class="entry navigation"><li><a class="flat-box" title="/categories/OJ/" href="/categories/OJ/" id="categoriesOJ"><div class="name">OJ</div><div class="badge">(1)</div></a></li><li><a class="flat-box" title="/categories/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" href="/categories/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" id="categorieshexoE58D9AE5AEA2E690ADE5BBBA"><div class="name">hexo博客搭建</div><div class="badge">(1)</div></a></li><li><a class="flat-box" title="/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" href="/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" id="categoriesE58D9AE5AEA2E690ADE5BBBA"><div class="name">博客搭建</div><div class="badge">(4)</div></a></li><li><a class="flat-box" title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="categoriesE5ADA6E4B9A0E7AC94E8AEB0"><div class="name">学习笔记</div><div class="badge">(48)</div></a></li><li><a class="flat-box child" title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/" id="categoriesE5ADA6E4B9A0E7AC94E8AEB0C-C"><div class="name">C/C++</div><div class="badge">(25)</div></a></li><li><a class="flat-box child" title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git/" id="categoriesE5ADA6E4B9A0E7AC94E8AEB0Git"><div class="name">Git</div><div class="badge">(1)</div></a></li><li><a class="flat-box" title="/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" href="/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" id="categoriesE5AE9EE794A8E68A80E5B7A7"><div class="name">实用技巧</div><div class="badge">(1)</div></a></li><li><a class="flat-box" title="/categories/%E9%85%8D%E7%BD%AE/" href="/categories/%E9%85%8D%E7%BD%AE/" id="categoriesE9858DE7BDAE"><div class="name">配置</div><div class="badge">(1)</div></a></li></ul></div></section><section class="widget tagcloud shadow desktop"><header><a href="/blog/tags/"><i class="fas fa-tags fa-fw" aria-hidden="true"></i><span class="name">热门标签</span></a></header><div class="content"><a href="/tags/C/" style="font-size:16px;color:#8b8b8b">C++</a> <a href="/tags/C-C/" style="font-size:24px;color:#555">C/C++</a> <a href="/tags/Git/" style="font-size:14px;color:#999">Git</a> <a href="/tags/Hexo%E4%B8%BB%E9%A2%98/" style="font-size:14px;color:#999">Hexo主题</a> <a href="/tags/Let-s-Build-A-Simple-Interpreter/" style="font-size:22px;color:#636363">Let's Build A Simple Interpreter</a> <a href="/tags/Let%E2%80%99s-Build-A-Simple-Interpreter/" style="font-size:18px;color:#7e7e7e">Let’s Build A Simple Interpreter</a> <a href="/tags/OJ/" style="font-size:14px;color:#999">OJ</a> <a href="/tags/Yilia%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/" style="font-size:14px;color:#999">Yilia主题配置</a> <a href="/tags/forme/" style="font-size:14px;color:#999">forme</a> <a href="/tags/front-matter%E9%85%8D%E7%BD%AE/" style="font-size:14px;color:#999">front-matter配置</a> <a href="/tags/github/" style="font-size:14px;color:#999">github</a> <a href="/tags/hexo%E6%98%BE%E7%A4%BApdf/" style="font-size:14px;color:#999">hexo显示pdf</a> <a href="/tags/matery%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/" style="font-size:14px;color:#999">matery主题配置</a> <a href="/tags/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE%E3%80%8B/" style="font-size:18px;color:#7e7e7e">《计算机科学速成课》</a> <a href="/tags/%E5%87%B8%E5%8C%85/" style="font-size:20px;color:#707070">凸包</a> <a href="/tags/%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91%E5%92%8C%E9%80%BB%E8%BE%91%E9%97%A8/" style="font-size:14px;color:#999">布尔逻辑和逻辑门</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" style="font-size:14px;color:#999">计算几何</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE/" style="font-size:14px;color:#999">计算机科学速成课</a> <a href="/tags/%E9%85%8D%E7%BD%AE/" style="font-size:14px;color:#999">配置</a></div></section></aside><footer class="clearfix white"><br><br><div class="aplayer-container"><meting-js theme="#1BCDFC" autoplay volume="0.6" loop order="list" fixed="false" list-max-height="340px" server="netease" type="song" id="186453" list-folded="true"></meting-js></div><br><div class="social-wrapper"><a href="/atom.xml" class="social fas fa-rss flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="mailto:1198216723@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://github.com/longlongqin" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://music.163.com/#/user/home?id=285545421" class="social fas fa-headphones-alt flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a></div><red>&copy; 2020-2020 longlongqin 😊| powered by HEXO | theme volantis</red><br><yellow><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("03/01/2020 18:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="小站已运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒 "}setInterval("createtime()",250)</script></yellow><br><green><i class="fas fa-chart-area"></i> <span class="post-count">字数统计：307.9k</span></green>|<script type="text/javascript" src="https://v1.cnzz.com/z_stat.php?id=1278663994&web_id=1278663994"></script><br><cyan>博客内容遵循</cyan><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank"><cyan>署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</cyan></a></footer><script>setLoadingBarProgress(80)</script><script>setLoadingBarProgress(60)</script></div><a class="s-top fas fa-arrow-up fa-fw" href="javascript:void(0)"></a></div><script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script><script>var SEARCH_SERVICE="hexo",ROOT="/";ROOT.endsWith("/")||(ROOT+="/")</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script><script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script><script type="text/javascript">$(function(){Waves.attach(".flat-btn",["waves-button"]),Waves.attach(".float-btn",["waves-button","waves-float"]),Waves.attach(".float-btn-light",["waves-button","waves-float","waves-light"]),Waves.attach(".flat-box",["waves-block"]),Waves.attach(".float-box",["waves-block","waves-float"]),Waves.attach(".waves-image"),Waves.init()})</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script><script type="text/javascript">$(function(){var n=["https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/background/4.jpg"];!function(n){for(var o=n.length;o--;){var r=Math.floor(Math.random()*o),t=n[r];n[r]=n[o],n[o]=t}}(n),$(".cover").backstretch(n,{duration:"20000",fade:"1500"})})</script><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js" async></script><script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js" async></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1.4/js/app.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1/js/search.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script><script>!function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copyed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-clipboard-check');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPYED';
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-exclamation-triangle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
      });
    }
    initCopyCode();
  }(window, document);</script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>let LAZY_LOAD_IMAGE = "[object Object]";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });</script><script>setLoadingBarProgress(100)</script><script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)t=c[r],0<=(n=t.getBoundingClientRect()).bottom&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this);</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script></body></html>