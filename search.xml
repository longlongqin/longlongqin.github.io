<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C&amp;C++/调试c++程序</title>
      <link href="/archives/50be15c2.html"/>
      <url>/archives/50be15c2.html</url>
      
        <content type="html"><![CDATA[<h1 id="语法和语义错误"><a href="#语法和语义错误" class="headerlink" title="语法和语义错误"></a>语法和语义错误</h1><p>原文：<a href="https://www.learncpp.com/cpp-tutorial/syntax-and-semantic-errors/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/syntax-and-semantic-errors/</a></p><hr><p>软件错误非常普遍。制作它们很容易，但要找到它们却很难。在本章中，我们将探索与在我们的c++程序中发现和清除bug相关的主题，包括学习如何使用集成调试器(IDE的一部分)。</p><p>当根据c++语言的语法编写无效的语句时，会发生<strong>语法错误</strong>。这包括错误，如缺少分号，使用未声明的变量，不匹配的括号或大括号等。例如，下面的程序包含相当多的语法错误:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt; <span class="string">"Hi there"</span>; &lt;&lt; x; <span class="comment">// invalid operator (&lt;), extraneous semicolon, undeclared variable (x)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> <span class="comment">// missing semicolon at end of statement</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>幸运的是，编译器通常会捕获语法错误并生成警告或错误，因此您可以轻松地识别和修复问题。然后只需重新编译，直到消除所有错误。</p><p>一旦你的程序正确编译，让它实际产生你想要的结果可能会很棘手。当语句在语法上有效，但没有按照程序员的意图执行时，就会发生<strong>语义错误</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" / "</span> &lt;&lt; b &lt;&lt; <span class="string">" = "</span> &lt;&lt; a / b; <span class="comment">// 除0没有定义</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现代编译器已经能够更好地检测某些类型的常见语义错误(例如使用未初始化的变量)。然而，在大多数情况下，编译器将无法捕获大多数这类问题，因为编译器的设计目的是加强语法，而不是意图。</p><p>在上面的例子中，错误是很容易发现的。但是在大多数重要的程序中，通过肉眼观察代码不容易发现语义错误。这就是调试技术可以派上用场的地方。</p><h1 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h1><p>原文：<a href="https://www.learncpp.com/cpp-tutorial/the-debugging-process/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/the-debugging-process/</a></p><p>假设您编写了一个程序，但是它不能正确地工作——代码编译得很好，但是当您运行它时，您将得到一个不正确的结果。你一定在什么地方犯了语义错误。你怎么找到它的?如果您一直遵循最佳实践，编写一些代码，然后对其进行测试，那么您可能已经很清楚错误在哪里了。或者你可能完全没有线索。</p><h2 id="调试的一般方法"><a href="#调试的一般方法" class="headerlink" title="调试的一般方法"></a>调试的一般方法</h2><p>一旦发现问题，调试问题通常包括五个步骤:</p><ol><li>找出问题的根本原因(通常是不能工作的代码行)</li><li>确保您理解问题发生的原因</li><li>决定如何解决这个问题</li><li>修复导致问题的问题</li><li>重新测试以确保问题已经解决，没有出现新的问题</li></ol><p>练习：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Adds two numbers</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y; <span class="comment">// function is supposed to add, but it doesn't</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// should produce 8, but produces 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码有一点很好: 错误非常明显，因为错误的答案通过第11行打印到屏幕上。这为我们的调查提供了一个起点。</p><p><strong>Find the root cause:</strong> On line 11, we can see that we’re passing in literals for arguments (5 and 3), so there is no room for error there. Since the inputs to function <em>add</em> are correct, but the output isn’t, it’s pretty apparent that function <em>add</em> must be producing the wrong value. The only statement in function <em>add</em> is the return statement, which must be the culprit. We’ve found the problem line. Now that we know where to focus our attention, noticing that we’re subtracting instead of adding is something you’re likely to find via inspection.</p><p><strong>Understand the problem:</strong> In this case, it’s obvious why the wrong value is being generated – we’re using the wrong operator.</p><p><strong>Determine a fix:</strong> We’ll simply change <em>operator-</em> to <em>operator+</em>.</p><p><strong>Repair the issue:</strong> This is actually changing <em>operator-</em> to <em>operator+</em> and ensuring the program recompiles.</p><p><strong>Retest:</strong> After implementing the change, rerunning the program will indicate that our program now produces the correct value of 8. For this simple program, that’s all the testing that’s needed.</p><p>This example is trivial, but illustrates the basic process you’ll go through when diagnosing any program.</p><h1 id="调试策略"><a href="#调试策略" class="headerlink" title="调试策略"></a>调试策略</h1><p>原文：<a href="https://www.learncpp.com/cpp-tutorial/a-strategy-for-debugging/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/a-strategy-for-debugging/</a></p><hr><p>在调试程序时，在大多数情况下，您的大部分时间都将花在寻找错误的实际位置上。一旦发现了问题，剩下的步骤 (修复问题并验证问题是否已修复) 相比之下通常是微不足道的。</p><h2 id="通过代码检查发现问题"><a href="#通过代码检查发现问题" class="headerlink" title="通过代码检查发现问题"></a>通过代码检查发现问题</h2><p>假设你注意到一个问题，你想要找出这个问题的原因。在许多情况下(<strong>特别是在较小的程序中</strong>)，我们可以很快确定问题所在。</p><p>然而，随着程序变得越来越复杂，通过代码检查发现问题也变得越来越复杂。</p><ul><li>首先，有更多的代码需要查看。在一个有数千行代码的程序中，查看每一行代码都要花费很长的时间(更不用说它是非常无聊的)。</li><li>其次，代码本身往往更复杂，出错的地方也更多。</li><li>第三，代码的行为可能不会给您提供很多关于哪里出了问题的线索。如果你写了一个程序来输出股票推荐，但实际上它什么也没输出，你可能就不知道从哪里开始寻找问题了。</li><li>最后，错误可能是由于错误的假设造成的。几乎不可能从视觉上发现由错误假设引起的错误，因为在检查代码时，您可能会做出相同的错误假设，而不会注意到错误。</li></ul><p>因此，如果我们有一个问题，我们不能通过代码检查发现，我们如何找到它?</p><h2 id="通过运行程序发现问题"><a href="#通过运行程序发现问题" class="headerlink" title="通过运行程序发现问题"></a>通过运行程序发现问题</h2><p>幸运的是，如果我们不能通过代码检查发现问题，那么我们可以采用另一种方法:<strong>我们可以观察程序运行时的行为，并尝试从中诊断问题。</strong>这种方法可以概括为:</p><ol><li>找出重现问题的方法</li><li>运行程序并收集信息以缩小问题所在</li><li>重复前面的步骤，直到找到问题为止</li></ol><p>在本章的其余部分，我们将讨论促进这种方法的技术。</p><h3 id="重现问题"><a href="#重现问题" class="headerlink" title="重现问题"></a>重现问题</h3><p>发现问题的第一步也是最重要的一步是能够重现问题。原因很简单: 除非你能观察到问题的发生，否则很难发现问题。</p><h3 id="关注问题"><a href="#关注问题" class="headerlink" title="关注问题"></a>关注问题</h3><p>一旦我们可以合理地重现问题，下一步就是找出问题在代码的什么地方。根据问题的性质，这可能是容易的，也可能是困难的。</p><h1 id="基本的调试策略"><a href="#基本的调试策略" class="headerlink" title="基本的调试策略"></a>基本的调试策略</h1><h2 id="调试策略-1-注释掉代码"><a href="#调试策略-1-注释掉代码" class="headerlink" title="调试策略#1:注释掉代码"></a>调试策略#1:注释掉代码</h2><p>如果程序显示出错误行为，减少必须搜索的代码量的一种方法是注释一些代码，看看问题是否仍然存在。如果问题仍然存在，注释掉的代码不负责。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    getNames(); <span class="comment">// ask user to enter a bunch of names</span></span><br><span class="line">    doMaintenance(); <span class="comment">// do some random stuff</span></span><br><span class="line">    sortNames(); <span class="comment">// sort them in alphabetical order</span></span><br><span class="line">    printNames(); <span class="comment">// print the sorted list of names</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们假设这个程序应该按字母顺序打印用户输入的名称，但是它按相反的字母顺序打印它们。问题在哪里?</p><p>它可以是上面的代码中的任何一个。但是我们可能怀疑<code>doMaintenance();</code>与这个问题没有任何关系，所以让我们注释掉它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    getNames(); <span class="comment">// ask user to enter a bunch of names</span></span><br><span class="line"><span class="comment">//    doMaintenance(); // do some random stuff</span></span><br><span class="line">    sortNames(); <span class="comment">// sort them in alphabetical order</span></span><br><span class="line">    printNames(); <span class="comment">// print the sorted list of names</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果问题消失了，那么问题一定是由<code>doMaintenance</code>引起的，我们应该把注意力集中在维护上。</p><p>但是，如果问题仍然存在(这种可能性更大)，那么我们就知道<code>doMaintenance</code>并不是错误，我们可以将该函数排除在外。这并不能帮助我们理解实际的问题是在对<code>doMaintenance</code>的调用之前还是之后，但是它减少了我们随后要检查的代码量。</p><p>不要忘记您注释掉了哪些函数，以便稍后取消注释!</p><h2 id="调试策略-2-验证代码流"><a href="#调试策略-2-验证代码流" class="headerlink" title="调试策略#2:验证代码流"></a>调试策略#2:验证代码流</h2><p>在更复杂的程序中常见的另一个问题是，程序调用一个函数的次数太多或太少(包括完全不调用)。</p><p>在这种情况下，将语句放在函数的顶部以打印函数名是很有帮助的。这样，当程序运行时，您就可以看到调用了哪些函数。</p><blockquote><p>当打印用于调试的信息时，使用<strong><code>std::cerr</code></strong>而不是std::cout。</p><ul><li>这样做的一个原因是std::cout可能会被缓冲，这意味着在您请求std::cout输出信息和它实际执行输出信息之间可能会有一个停顿。如果您使用std::cout输出，然后您的程序立即崩溃，那么std::cout可能还没有实际输出。这可能会误导你问题在哪里。</li><li>另一方面，std::cerr是无缓冲的，这意味着您发送给它的任何内容都会立即输出。这有助于确保所有调试输出尽快出现(以牺牲某些性能为代价，我们通常在调试时并不关心这些性能)。</li></ul></blockquote><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; getValue;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然我们希望这个程序打印值4，但它实际上会在不同的机器上打印不同的值。在作者的机器上，它打印:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00101424</span><br></pre></td></tr></table></figure><p>让我们在这些函数中添加一些调试语句:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"getValue() called\n"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main() called\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; getValue;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>在添加临时调试语句时，最好不要缩进它们。这使得以后更容易找到它们并移除。</strong></p></blockquote><p>现在，当这些函数执行时，它们将输出它们的名称，表明它们被调用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main() called</span><br><span class="line">00101424</span><br></pre></td></tr></table></figure><p>现在我们可以看到函数getValue从未被调用。调用函数的代码一定有问题。让我们仔细看看这句话:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; getValue;</span><br></pre></td></tr></table></figure><p>看，我们忘了函数调用的括号了。应该是:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"getValue() called\n"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main() called\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; getValue(); <span class="comment">// added parenthesis here</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将生成正确的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main() called</span><br><span class="line">getValue() called</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>我们可以删除临时调试语句。</strong></p><h2 id="调试策略-3-打印值"><a href="#调试策略-3-打印值" class="headerlink" title="调试策略#3:打印值"></a>调试策略#3:打印值</h2><p>对于某些类型的错误，程序可能正在计算或传递错误的值。</p><p>我们还可以输出变量(包括参数)或表达式的值，以确保它们是正确的。</p><p>考虑下面的程序，它本应该添加两个数字，但却不能正确工作:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printResult</span><span class="params">(<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The answer is: "</span> &lt;&lt; z &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getUserInput</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line"><span class="keyword">int</span> x&#123;&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x&#123; getUserInput() &#125;;</span><br><span class="line"><span class="keyword">int</span> y&#123; getUserInput() &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" + "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> z&#123; add(x, <span class="number">5</span>) &#125;;</span><br><span class="line">printResult(z);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是这个程序的一些输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Enter a number: 4</span><br><span class="line">Enter a number: 3</span><br><span class="line">4 + 3</span><br><span class="line">The answer is: 9</span><br></pre></td></tr></table></figure><p>这是不正确的。看到错误了吗?即使在这个简短的程序中，也很难发现它。让我们添加一些代码来调试我们的值:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printResult</span><span class="params">(<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The answer is: "</span> &lt;&lt; z &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getUserInput</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line"><span class="keyword">int</span> x&#123;&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x&#123; getUserInput() &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main::x = "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">int</span> y&#123; getUserInput() &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main::y = "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" + "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> z&#123; add(x, <span class="number">5</span>) &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main::z = "</span> &lt;&lt; z &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">printResult(z);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是上面的输出:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Enter a number: <span class="number">4</span></span><br><span class="line">main::x = <span class="number">4</span></span><br><span class="line">Enter a number: <span class="number">3</span></span><br><span class="line">main::y = <span class="number">3</span></span><br><span class="line"><span class="number">4</span> + <span class="number">3</span></span><br><span class="line">main::z = <span class="number">9</span></span><br><span class="line">The answer is: <span class="number">9</span></span><br></pre></td></tr></table></figure><p>变量x和y得到了正确的值，但变量z没有。问题必须在这两点之间，这使得函数<code>add()</code>成为一个关键问题。</p><p>让我们修改函数<code>add</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"add() called (x="</span> &lt;&lt; x &lt;&lt;<span class="string">", y="</span> &lt;&lt; y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//⭐</span></span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printResult</span><span class="params">(<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The answer is: "</span> &lt;&lt; z &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getUserInput</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line"><span class="keyword">int</span> x&#123;&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x&#123; getUserInput() &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main::x = "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">int</span> y&#123; getUserInput() &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main::y = "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" + "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> z&#123; add(x, <span class="number">5</span>) &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main::z = "</span> &lt;&lt; z &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">printResult(z);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Now we’ll <span class="built_in">get</span> the output:</span><br><span class="line"></span><br><span class="line">Enter a number: <span class="number">4</span></span><br><span class="line">main::x = <span class="number">4</span></span><br><span class="line">Enter a number: <span class="number">3</span></span><br><span class="line">main::y = <span class="number">3</span></span><br><span class="line">add() called (x=<span class="number">4</span>, y=<span class="number">5</span>)</span><br><span class="line">main::z = <span class="number">9</span></span><br><span class="line">The answer is: <span class="number">9</span></span><br></pre></td></tr></table></figure><p>变量y的值是3，但是我们的函数add却得到了参数y的值5，我们一定是传递了错误的参数。果然:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> z&#123; add(x, <span class="number">5</span>) &#125;;</span><br></pre></td></tr></table></figure><p>在这里。我们传递的是文字5，而不是变量y的值作为参数。这是一个简单的修复，然后我们可以<strong>删除调试语句</strong>。</p><h3 id="为什么使用-打印语句-进行调试不是很好"><a href="#为什么使用-打印语句-进行调试不是很好" class="headerlink" title="为什么使用 打印语句 进行调试不是很好"></a>为什么使用 打印语句 进行调试不是很好</h3><p>虽然将调试语句添加到用于诊断的程序中是一种常见的基本技术，也是一种功能性技术(特别是当调试器由于某种原因不可用时)，但它并不是很好，原因如下:</p><ol><li>调试语句使代码混乱。</li><li>调试语句会使程序的输出变得混乱。</li><li>在使用完调试语句之后，必须删除它们，这使得它们不可重用。</li><li>调试语句需要修改代码来添加和删除，这可能会引入新的错误。</li></ol><p>我们可以做得更好。我们将在以后的课程中探索如何做到这一点。</p><h1 id="更多的调试策略"><a href="#更多的调试策略" class="headerlink" title="更多的调试策略"></a>更多的调试策略</h1><h2 id="对调试代码进行条件化"><a href="#对调试代码进行条件化" class="headerlink" title="对调试代码进行条件化"></a>对调试代码进行条件化</h2><p>考虑以下包含一些调试语句的程序:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getUserInput</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"getUserInput() called\n"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line"><span class="keyword">int</span> x&#123;&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main() called\n"</span>;</span><br><span class="line">    <span class="keyword">int</span> x&#123; getUserInput() &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"You entered: "</span> &lt;&lt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当您完成调试语句时，您将需要删除它们，或者注释掉它们。然后，如果您稍后还想要它们，就必须将它们添加回去，或者取消注释。</p><p>一种更容易在程序中禁用和启用调试的方法是使用<strong>预处理器指令使调试语句有条件</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENABLE_DEBUG <span class="comment">// 注释出以禁用调试</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getUserInput</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENABLE_DEBUG  <span class="comment">//⭐</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"getUserInput() called\n"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">//⭐</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line"><span class="keyword">int</span> x&#123;&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENABLE_DEBUG  <span class="comment">//⭐</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main() called\n"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">//⭐</span></span></span><br><span class="line">    <span class="keyword">int</span> x&#123; getUserInput() &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"You entered: "</span> &lt;&lt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们可以通过 注释/取消注释 #define ENABLE_DEBUG 来启用调试。这允许我们重用以前添加的调试语句，然后在使用它们时禁用它们，而不必从代码中实际删除它们。</p><p>如果这是一个<strong>多文件程序，那么#define ENABLE_DEBUG将位于一个头文件中</strong>，该头文件包含在所有代码文件中，因此我们可以在单个位置 注释/取消注 释#define，并让它传播到所有代码文件。</p><p>这解决了必须删除调试语句的问题和这样做的风险：</p><ul><li>但代价是代码更加混乱。</li><li>这种方法的另一个缺点是，如果您输入错误(例如拼错“DEBUG”)或忘记将头文件包含到代码文件中，那么可能无法启用该文件的部分或全部调试。</li></ul><h2 id="使用一个日志记录器"><a href="#使用一个日志记录器" class="headerlink" title="使用一个日志记录器"></a>使用一个日志记录器</h2><p>通过预处理程序进行条件化调试的另一种方法 是将调试信息发送到<strong>日志文件</strong>。</p><blockquote><p><strong>日志文件</strong>是一个记录软件中发生的事件的文件(通常存储在磁盘上)。</p><p>将信息写入日志文件的过程称为<strong>日志记录</strong>。</p></blockquote><p>大多数应用程序和操作系统编写的日志文件可用于帮助诊断发生的问题。</p><p>日志文件有一些优点：</p><ul><li><p>因为写入日志文件的信息与程序的输出是分开的，所以可以避免将正常输出和调试输出混合在一起所造成的混乱。</p></li><li><p>日志文件也可以很容易地发送给其他人进行诊断——因此，如果使用您的软件的人遇到问题，您可以让他们将日志文件发送给您，这可能会帮助您了解问题所在。</p></li></ul><p>虽然可以编写自己的代码来创建日志文件并向它们发送输出，<strong>但是最好使用现有的第三方日志工具之一</strong>。你用哪一个取决于你。</p><p>为了便于说明，我们将展示使用<a href="https://github.com/SergiusTheBest/plog" target="_blank" rel="noopener">plog</a>日志记录器输出到日志记录器的内容。</p><blockquote><p>Plog是作为一组头文件实现的，因此很容易在任何需要的地方包含它，而且它是轻量级的，易于使用。</p></blockquote><h3 id="如何使用plog日志记录器"><a href="#如何使用plog日志记录器" class="headerlink" title="如何使用plog日志记录器"></a>如何使用plog日志记录器</h3><p>If you want to compile the above example yourself, or use plog in your own projects, you can follow these instructions to install it:</p><p>First, get the latest plog release:</p><ul><li>Visit the <a href="https://github.com/SergiusTheBest/plog" target="_blank" rel="noopener">plog</a> repo.</li><li>Click the “releases” tab (it’s in the same row as “commits”, “branches”, “packages”, etc…)</li><li>Under the release tagged as “latest release” on the left, click the link “Source code (zip)” to download the latest release.</li></ul><p>Next, unzip the entire archive to `` on your hard drive.</p><p>Finally, for each project, set the <code>\plog-\include\</code> directory as an <code>include directory</code> inside your IDE. There are instructions on how to do this for Visual Studio here: <a href="https://www.learncpp.com/cpp-tutorial/a2-using-libraries-with-visual-studio-2005-express/" target="_blank" rel="noopener">A.2 – Using libraries with Visual Studio</a> and Code::Blocks here: <a href="https://www.learncpp.com/cpp-tutorial/a3-using-libraries-with-codeblocks/" target="_blank" rel="noopener">A.3 – Using libraries with Code::Blocks</a>.</p><h1 id="使用集成调试器-单步调试"><a href="#使用集成调试器-单步调试" class="headerlink" title="使用集成调试器: 单步调试"></a>使用集成调试器: 单步调试</h1><p>原文：<a href="https://www.learncpp.com/cpp-tutorial/using-an-integrated-debugger-stepping/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/using-an-integrated-debugger-stepping/</a></p><hr><p>当您运行程序时，执行从主函数的顶部开始，然后一个语句接着一个语句地执行，直到程序结束。</p><p>在任何时候当你的程序运行时,程序跟踪很多事情：你使用的变量的值，调用了哪些函数(当这些函数返回,程序将知道回到)，以及程序内的当前执行点(所以它知道这语句执行下一个)。所有这些被跟踪的信息都称为您的<strong>程序状态</strong>(或者简称为<strong>状态</strong>)。</p><p>在以前的课程中，我们探讨了各种修改代码以帮助调试的方法，包括打印诊断信息或使用日志记录器。这些是在程序<strong>运行时</strong>检查程序状态的简单方法。</p><p>尽管这些方法如果使用得当是有效的，但是它们仍然有缺点:</p><ul><li>它们需要修改代码，这需要时间，并且可能会引入新的错误，而且它们会使代码变得混乱，使现有的代码更难理解。</li></ul><p>到目前为止，我们所展示的技术背后有一个未阐明的假设:一旦我们运行代码，它就会运行到完成(只有在接受输入时才会暂停)，而我们没有机会在任何我们想要的地方干预和检查程序的结果。</p><p>但是，如果我们能够去掉这个假设呢?幸运的是,我们可以。大多数现代IDE都带有一个集成的工具，称为<strong>调试器</strong>，它的设计目的就是实现这一点。</p><h2 id="调试器"><a href="#调试器" class="headerlink" title="调试器"></a>调试器</h2><p><strong>调试器</strong>是一种计算机程序，它允许程序员控制程序的执行方式，并在程序运行时检查程序状态。例如，程序员可以使用调试器逐行执行程序，同时检查变量的值。通过比较变量的实际值和预期值，或者观察代码的执行路径，调试器可以极大地帮助跟踪语义(逻辑)错误。</p><p>调试器背后的强大功能有两方面：</p><ul><li>精确控制程序执行的能力；</li><li>以及 查看(和修改，如果需要)程序状态的能力。</li></ul><p>早期的调试器(如<a href="http://en.wikipedia.org/wiki/Gdb" target="_blank" rel="noopener">gdb</a>)是具有命令行接口的独立程序，程序员必须在命令行中输入晦涩难懂的命令才能工作。</p><p>后来的调试器(例如Borland的 <a href="http://en.wikipedia.org/wiki/Turbo_Debugger" target="_blank" rel="noopener">turbo debugger</a>的早期版本)仍然是独立的，但是有了自己的“图形化”前端，使得使用它们更加容易。</p><p>现在，大多数现代ide都有<strong>集成的调试器</strong>——也就是说，调试器使用与代码编辑器相同的接口，因此可以使用编写代码时使用的环境进行调试(而不必切换程序)。</p><p>几乎所有现代调试器都包含相同的基本特性标准集——然而，在如何安排菜单来访问这些功能方面几乎没有一致性，键盘快捷键的一致性就更少了。</p><p>本章的其余部分将用于学习如何使用调试器。</p><blockquote><p><strong>不要忽视学习使用调试器。随着程序变得越来越复杂，与查找和修复问题所节省的时间相比，学习如何有效地使用集成调试器所花费的时间就显得微不足道了。</strong></p></blockquote><h3 id="Step-into"><a href="#Step-into" class="headerlink" title="Step into"></a>Step into</h3><blockquote><p>In Visual Studio, the <em>step into</em> command can be accessed via <em>Debug menu &gt; Step Into</em>, or by pressing the F11 shortcut key.</p></blockquote><p>step into命令在程序的正常执行路径中执行下一个语句，然后暂停程序的执行，以便我们可以使用调试器检查程序的状态。</p><blockquote><p>如果正在执行的语句包含一个函数调用，单步执行会导致程序跳转到正在调用的函数的顶部，并在那里暂停。</p></blockquote><p>当你的程序不运行，你执行第一个调试命令，你可能会看到相当多的事情发生:</p><ul><li>如果需要，程序将重新编译。</li><li>程序将开始运行。因为我们的应用程序是一个控制台程序，所以应该打开控制台输出窗口。它将是空的，因为我们还没有输出任何东西。</li><li>您的IDE可能会打开一些诊断窗口，这些窗口的名称可能是“诊断工具”、“调用堆栈”和“监视”。稍后我们将介绍其中的一些内容—现在您可以忽略它们。</li></ul><h3 id="Step-over"><a href="#Step-over" class="headerlink" title="Step over"></a>Step over</h3><blockquote><p>In Visual Studio, the <em>step over</em> command can be accessed via <em>Debug menu &gt; Step Over</em>, or by pressing the F10 shortcut key.</p></blockquote><p>与step into类似，step over命令在程序的正常执行路径中执行下一条语句。但是，step into将输入函数调用并逐行执行它们，而<strong>step over将执行整个函数而不停止并在函数执行后将控制权返回给您。</strong></p><h3 id="Step-out"><a href="#Step-out" class="headerlink" title="Step out"></a>Step out</h3><blockquote><p>In Visual Studio, the <em>step out</em> command can be accessed via <em>Debug menu &gt; Step Out</em>, or by pressing the Shift-F11 快捷键组合.</p></blockquote><p>与其他两个单步执行命令不同，<strong>Step out</strong>不只是执行下一行代码。相反，<strong>它执行当前正在执行的函数中的所有剩余代码，然后在函数返回时将控制权返回给您。</strong></p><h3 id="Step-back"><a href="#Step-back" class="headerlink" title="Step back"></a>Step back</h3><p>一些调试器(如Visual Studio Enterprise Edition和GDB 7.0)引入了单步调试功能，通常称为<strong>单步后退</strong>或<strong>反向调试</strong>（<em>step back</em> or <em>reverse debugging</em>）。</p><p><strong>Step back</strong>的目的是回退最后一步，这样您就可以将程序返回到先前的状态。如果您执行的操作超过了一步，或者您想重新检查刚刚执行的语句，那么这将非常有用。由于其复杂性，这种功能还没有标准化，并且会因调试器的不同而有所不同。截止到编写本文时(2019年1月)，Visual Studio Community edition和最新版本的Code::Blocks都不支持这种功能。希望在未来的某个时候，它会慢慢渗透到这些产品中，并被更广泛的使用。</p><h1 id="使用集成调试器-运行和断点"><a href="#使用集成调试器-运行和断点" class="headerlink" title="使用集成调试器: 运行和断点"></a>使用集成调试器: 运行和断点</h1><h2 id="运行到光标处"><a href="#运行到光标处" class="headerlink" title="运行到光标处"></a>运行到光标处</h2><p>第一个有用的命令通常称为<strong>Run to cursor（运行到光标处）</strong>。这个<strong>Run to cursor</strong>命令执行程序，直到执行到光标所选择的语句为止。然后，它将控制权返回给您，以便您可以从该点开始调试。</p><p>这是一种高效的方式，可以在代码中的特定点开始调试，或者如果已经在调试，则可以直接移动到需要进一步检查的位置。</p><blockquote><p><strong>For Visual Studio users</strong></p><p>在Visual Studio中，右击代码中的语句并从上下文菜单中选择run to cursor，或者按下ctrl-F10组合键，就可以访问run to cursor命令。</p></blockquote><h2 id="Continue"><a href="#Continue" class="headerlink" title="Continue"></a>Continue</h2><p>在调试会话进行到一半时，您可能希望从那时开始运行程序。最简单的方法是使用<strong>continue命令</strong>。</p><p><strong>continue 调试命令</strong>只是继续按正常方式运行程序，直到程序终止，或者直到有东西触发控件再次返回给您(例如断点，我们将在本课后面介绍)。</p><blockquote><p><strong>For Visual Studio users</strong></p><p>在Visual Studio中，可以通过Debug <em>menu</em>&gt; <em>continue</em> 或 按F5快捷键在调试程序时访问continue命令。</p></blockquote><h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><p>continue命令有一个名为start的孪生兄弟。start命令执行与continue相同的操作，<strong>只是从程序的开头开始。它只能在不在调试会话中调用。</strong></p><blockquote><p>在Visual Studio中，<strong>可以在不调试程序的情况下</strong>通过 Debug <em>menu</em> &gt; start debugging 或按下F5快捷键来访问start命令。</p></blockquote><h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><p>本节要讨论的最后一个主题是断点。<strong>断点</strong>是一种特殊的标记，它告诉调试器在调试模式下运行时，在断点处停止程序的执行。</p><blockquote><p><strong>For Visual Studio users</strong></p><p>在Visual Studio中,可以通过设置或删除断点 <em>Debug menu &gt; Toggle Breakpoint</em>, 或右键单击一个语句, 从上下文菜单中选择Toggle breakpoint或按 F9快捷键,或通过点击左边的行号(浅灰色区域)。</p></blockquote><h2 id="设置下一条语句"><a href="#设置下一条语句" class="headerlink" title="设置下一条语句"></a>设置下一条语句</h2><p>还有一个调试命令使用得非常不常见，但至少值得了解，即使您不经常使用它。</p><p><strong>设置下一条语句</strong> 命令允许我们将执行点更改为其他一些语句(有时也称为<strong>跳转</strong>)。这可以用来向前跳转执行点，跳过一些本来要执行的代码，或者向后跳转，让已经执行的代码重新运行。</p><blockquote><p><strong>For Visual Studio users</strong></p><p>在Visual Studio中，您可以通过右键单击一个语句并从上下文菜单中选择<em>Set next statement</em>，或者按下Ctrl-Shift-F10快捷组合键来跳过执行点。此选项与上下文相关，<strong>仅在已经调试程序时才会出现。</strong></p></blockquote><p>注意：</p><p><em>set next statement</em> 命令将更改执行点，但不会更改程序状态。您的变量将保留它们在跳转之前的任何值。因此，与其他情况相比，跳转可能会导致程序产生不同的值、结果或行为。明智地使用此功能(特别是向后跳转)。</p><p>不应该使用<em>set next statement</em> 将执行点更改为其他函数。这将导致未定义的行为，并可能导致崩溃。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>现在，您了解了使用集成调试器监视和控制程序执行方式的主要方法。虽然这些命令对于诊断代码流问题非常有用(例如，确定是否调用某些函数)，但是它们只是集成调试器给表带来的好处的一部分。</p><p>在下一课中，我们将开始探索检查程序状态的其他方法，您将需要这些命令作为先决条件。我们走吧!</p><h1 id="使用集成调试器-监视变量"><a href="#使用集成调试器-监视变量" class="headerlink" title="使用集成调试器: 监视变量"></a>使用集成调试器: 监视变量</h1><h2 id="监视变量"><a href="#监视变量" class="headerlink" title="监视变量"></a>监视变量</h2><p><strong>监视变量是在程序以调试模式执行时检查变量值的过程</strong>。大多数调试器都提供了几种方法来实现这一点。</p><ul><li><p><strong>检查简单变量(如x) 值的最简单方法是将鼠标悬停在变量x上</strong>。一些现代调试器支持这种检查简单变量的方法，这是最直接的方法。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-Watch2-min.png" alt="img"></p><blockquote><p>注意，您可以将鼠标悬停在任何变量x上，而不仅仅是当前行上的变量x。例如，如果我们将鼠标悬停在第12行x上，我们将看到相同的值:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-Watch3-min.png" alt="img"></p></blockquote></li><li><p>如果你在使用Visual Studio，你也可以使用<strong>QuickWatch</strong>。用鼠标高亮显示变量名x，然后从右键菜单中选择“QuickWatch”。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-QuickWatch1-min.png" alt="img"></p><p>这将打开一个包含变量当前值的子窗口:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-QuickWatch2-min.png" alt="img"></p><p>如果你打开了QuickWatch，请关闭它</p></li></ul><h2 id="监视窗口"><a href="#监视窗口" class="headerlink" title="监视窗口"></a>监视窗口</h2><p>如果你想知道一个变量的值在一个特定的时间点 ，使用<strong>鼠标悬停</strong>或<strong>QuickWatch</strong>方法检查变量很好。但是，它并不特别适合在运行代码时监视变量更改的值，因为您必须不断地 重新悬停/重新选择变量。</p><p>为了解决这个问题，所有现代集成调试器都提供了另一个特性，称为<strong>监视窗口</strong>。</p><p><strong>监视窗口</strong>是一个窗口，您可以在其中添加您想要持续检查的变量，并且当您单步执行程序时，这些变量将被更新。</p><p>当您进入调试模式时，监视窗口可能已经在您的屏幕上了，但是如果不是这样，您可以通过IDE的窗口命令(通常在视图或调试菜单中可以找到这些命令)打开它。</p><blockquote><p><strong>For Visual Studio users</strong></p><p>在Visual Studio中，<em>Debug menu &gt; Windows &gt; Watch &gt; Watch 1</em>. 中可以找到监视菜单。请注意，<strong>要启用此选项，必须处于调试模式，因此请先进入程序。</strong></p><p>此窗口出现的位置(停靠左、右或底部)可能不同。您可以通过将Watch 1选项卡拖动到应用程序窗口的另一侧来更改其停靠位置。</p></blockquote><p>超出作用域的变量(例如，函数中已经返回给调用者的局部变量)将留在您的监视窗口中，但通常要么被标记为“不可用”，要么显示最后一个已知值，但显示为灰色。如果变量返回到作用域(例如再次调用函数)，它的值将再次显示。因此，即使变量不在监视范围内，也可以将它们留在监视窗口中。</p><h2 id="监视窗口可以计算表达式"><a href="#监视窗口可以计算表达式" class="headerlink" title="监视窗口可以计算表达式"></a>监视窗口可以计算表达式</h2><p><strong>监视窗口</strong>还允许计算简单表达式。</p><h2 id="局部监视"><a href="#局部监视" class="headerlink" title="局部监视"></a>局部监视</h2><p>因为在调试时检查函数内部局部变量的值是很常见的，所以许多调试器会提供某种方式来快速监视 作用域中所有局部变量的值。</p><blockquote><p><strong>For Visual Studio users</strong></p><p>在Visual Studio中，可以在<strong>局部变量窗口</strong>中看到所有局部变量的值，可以在<em>Debug menu &gt; Windows &gt; Locals</em> 中找到。请注意，<strong>您必须处于调试会话中才能激活此窗口。</strong></p></blockquote><h1 id="使用集成调试器-调用栈"><a href="#使用集成调试器-调用栈" class="headerlink" title="使用集成调试器: 调用栈"></a>使用集成调试器: 调用栈</h1><p>现代调试器还包含一个调试信息窗口，它在调试程序时非常有用，即<strong>调用堆栈窗口</strong>。</p><p>当您的程序调用一个函数时，您已经知道它标记了当前位置，进行了函数调用，然后返回。它怎么知道回到哪里去? <strong>答案是它在调用堆栈中保持跟踪</strong>。</p><p>调用堆栈是所有已被调用以到达当前执行点的活动函数的列表。调用堆栈包括每个被调用函数的条目，以及函数返回时将返回到哪一行代码。</p><p>每当调用一个新函数时，该函数都会被添加到调用堆栈的顶部。当 当前函数返回给调用方时，它将从调用堆栈的顶部移除，而控制将返回给它下面的函数。</p><p><strong>“调用堆栈”窗口</strong>是一个显示当前调用堆栈的调试器窗口。如果没有看到“调用堆栈”窗口，则需要告诉IDE显示它。</p><blockquote><p><strong>For Visual Studio users</strong></p><p>在Visual Studio中，可以通过 <em>Debug menu &gt; Windows &gt; Call Stack</em>。请注意，<strong>您必须处于调试会话中才能激活此窗口。</strong></p></blockquote><hr><p>祝贺您，现在您已经了解了使用集成调试器的基本知识!通过使用单步执行、断点、监视和调用堆栈窗口，您现在已经具备了调试几乎所有问题的基础知识。</p><p>像许多事情一样，要想熟练使用调试器，需要一些实践和反复试验。但是，我们再次重申，花在学习如何有效使用集成调试器上的时间将比花在调试程序上的时间节省许多倍!</p><h1 id="在问题变成问题之前找到问题"><a href="#在问题变成问题之前找到问题" class="headerlink" title="在问题变成问题之前找到问题"></a>在问题变成问题之前找到问题</h1><p>当您犯语义错误时，当您运行程序时，这个错误可能不会立即被发现。一个问题可能潜伏在你的代码中很长一段时间都没有被发现，直到新引入的代码或改变的环境导致它作为程序故障出现。</p><p>在找到错误之前，错误在代码库中停留的时间越长，就越有可能难以找到它，本来很容易修复的错误会变成一场耗费时间和精力的调试冒险。</p><p>我们能做些什么呢?</p><h2 id="不要犯错误"><a href="#不要犯错误" class="headerlink" title="不要犯错误"></a>不要犯错误</h2><p>最好的办法是一开始就不要犯错误。这里有一个不完整的清单，可以帮助避免犯错误:</p><ul><li>遵循最佳实践</li><li>累了就别编程</li><li>了解一门语言中常见的陷阱(我们警告过你不要做的所有事情)</li><li>保持程序简单</li><li>不要让函数太长</li><li>尽可能使用标准库而不是编写自己的代码。</li><li>使用注释</li></ul><h2 id="重构功能"><a href="#重构功能" class="headerlink" title="重构功能"></a>重构功能</h2><p>当您向程序添加新功能(“行为更改”)时，您会发现一些函数的长度在增加。随着函数变长，它们变得更加复杂和难以理解。</p><p>解决这个问题的一种方法是将一个长函数分解成多个短函数。在不改变代码行为(通常是为了使其更易于维护)的情况下对代码进行结构更改的过程称为<strong>重构</strong>。</p><blockquote><p>那么对于一个函数，多长才算长呢?</p><p>一个占据一个垂直屏幕的函数通常被认为太长——如果必须滚动才能阅读整个函数，那么函数的可理解性就会显著下降。但是越短越好——函数小于10行就很好。小于5行的函数甚至更好。</p></blockquote><h2 id="介绍防御性编程"><a href="#介绍防御性编程" class="headerlink" title="介绍防御性编程"></a>介绍防御性编程</h2><p>错误不仅可能是您自己造成的(例如，不正确的逻辑)，还可能发生在您的用户以您没有预料到的方式使用应用程序时。</p><blockquote><p>例如，如果您要求用户输入一个整数，而用户输入的却是字母，那么在这种情况下，您的程序是如何运行的呢?除非您预料到了这一点，并为本例添加了一些错误处理，否则情况可能不太好。</p></blockquote><p><strong>防御性编程</strong>是一种实践，程序员试图预测软件可能被最终用户或使用代码的其他开发人员(包括程序员自己)滥用的所有方式。这些误用通常可以被发现，然后减轻(例如，要求输入错误输入的用户重试)。</p><p>我们将在以后的课程中探索与错误处理相关的主题。</p><h2 id="快速找到错误"><a href="#快速找到错误" class="headerlink" title="快速找到错误"></a>快速找到错误</h2><p>由于在大型程序中不出错是很困难的，所以下一个最好的方法就是快速捕获您确实犯的错误。</p><p><strong>最好的方法是每次编写一点程序，然后测试代码并确保它能正常工作。</strong></p><p>然而，还有一些其他的技术我们也可以使用。</p><h3 id="测试功能介绍"><a href="#测试功能介绍" class="headerlink" title="测试功能介绍"></a>测试功能介绍</h3><p>帮助发现程序问题的一种常见方法是<strong>编写测试函数来“练习”所编写的代码</strong>。这里有一个原始的尝试，更多的是为了说明的目的比任何东西:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testadd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"This function should print: 2 0 0 -2\n"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">1</span>, <span class="number">1</span>) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">-1</span>, <span class="number">1</span>) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">1</span>, <span class="number">-1</span>) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">-1</span>, <span class="number">-1</span>) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">testadd();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>testadd()函数通过使用不同的值调用add()函数来测试它。如果所有的值都符合我们的期望，那么我们就可以合理地确信函数是有效的。更好的是，我们可以保留这个函数，并在每次更改函数add时运行它，以确保我们没有意外地破坏它。</p><p>这是<strong>单元测试</strong>的基本形式，<strong>单元测试是一种软件测试方法，通过测试小单元的源代码来确定它们是否正确。</strong></p><p>与日志记录框架一样，可以使用许多第三方单元测试框架。也可以自己编写，不过我们需要更多的语言特性来处理主题。我们将在以后的课程中对此进行讨论。</p><h3 id="约束条件介绍"><a href="#约束条件介绍" class="headerlink" title="约束条件介绍"></a>约束条件介绍</h3><p>基于约束的技术包括添加一些额外的代码(如果需要，可以在非调试版本中编译)，以检查是否违反了一些假设或期望。</p><p>例如，如果我们编写一个函数来计算一个数字的阶乘，这个函数需要一个非负参数，那么该函数可以进行检查，以确保调用者在继续之前传入了一个非负的数字。如果调用方传入一个负数，那么函数可能会立即出错，而不是生成一些不确定的结果，从而帮助确保立即捕获问题。</p><p><strong>一种常见的方法是通过assert和static_assert</strong>，我们在<strong><a href="https://www.learncpp.com/cpp-tutorial/7-12a-assert-and-static_assert/" target="_blank" rel="noopener">7.12a – Assert and static_assert</a>.</strong>中介绍了这两个方法。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/静态与动态链接库</title>
      <link href="/archives/d30baea4.html"/>
      <url>/archives/d30baea4.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/a1-static-and-dynamic-libraries/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/a1-static-and-dynamic-libraries/</a></p><hr><p><strong>库(library)</strong>是一个代码包，可以被许多程序重用。通常，一个c++库分为两部分:</p><ul><li>一个<strong>头文件</strong>，定义库向使用它的程序公开(提供)的功能。</li><li>预编译的<strong>二进制文件</strong>，包含预编译成机器语言的功能的实现。</li></ul><p><strong>一些库可能被分成多个文件和/或具有多个头文件。</strong></p><p><strong>预编译库</strong>有几个原因：</p><ul><li>首先，由于库很少更改，它们不需要经常重新编译。每次编写使用它们的程序时都重新编译库是浪费时间。</li><li>其次，因为预编译对象是机器语言的，所以它阻止人们访问或更改源代码，这对于企业或不希望出于知识产权原因而提供源代码的人来说非常重要。</li></ul><p>有两种类型的库:</p><ul><li><strong>静态库</strong></li><li><strong>动态库</strong></li></ul><h1 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h1><p><strong>静态库(也称为归档库(archive))</strong>由一些<strong>例程(routines)</strong>组成，这些例程被编译并直接链接到程序中。当您编译一个使用静态库的程序时，<u>程序所使用的静态库的所有功能都将成为可执行文件的一部分。</u></p><blockquote><p>在Windows中，静态库通常有一个<strong><code>.lib</code>扩展名</strong>；</p><p>而在linux上，静态库通常有一个<strong><code>.a</code>(存档)扩展名</strong>。</p></blockquote><p>静态库的一个<strong>优点</strong>是，您只需要分发可执行文件就可以让用户运行您的程序。</p><p>因为静态库成为程序的一部分，这就确保了程序总是使用正确版本的库；此外，因为静态库成为程序的一部分，所以可以像使用为自己的程序编写的功能一样使用它们。</p><p><strong>不利</strong>的一面是，由于库的副本成为使用它的每个可执行文件的一部分，这会导致大量的空间浪费。静态库也不能轻松升级——要更新库，需要替换整个可执行文件。</p><h1 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h1><p><strong>动态库(也称为共享库)</strong>由在<strong><u>运行时</u></strong>加载到应用程序中的例程组成。当您编译使用动态库的程序时，该库不会成为可执行文件的一部分——它仍然是一个单独的单元。</p><blockquote><p>在Windows上，动态库通常有一个<strong><code>.dll</code>(动态链接库)扩展名</strong>；</p><p>而在Linux上，动态库通常有一个<strong><code>.so</code>(共享对象)扩展名</strong>。</p></blockquote><p>动态库的一个<strong>优点</strong>是许多程序可以共享一个副本，这节省了空间。也许一个更大的优点是：动态库可以升级到一个新的版本，而不需要替换使用它的所有可执行文件。</p><p><strong>缺点</strong>：</p><p>因为动态库没有链接到程序中，所以使用动态库的程序<u>必须显式地加载动态库并与之交互</u>。这种机制可能会让人感到困惑，并使与动态库的交互变得非常棘手。</p><p><u>为了使动态库更易于使用，可以使用<strong>导入库( import library )</strong></u>。</p><p><strong>导入库</strong>是一个自动加载和使用动态库过程的库。</p><blockquote><p>在Windows上，这通常是通过一个与动态库(.dll)同名 的 <strong>小型静态库(.lib)</strong> 来完成的。静态库在<strong>编译时</strong>链接到程序中，然后动态库的功能 就可以 <u>像静态库一样</u> 有效地使用。</p><p>在Linux上，<strong>共享对象(.so)文件</strong>同时充当 动态库 和 导入库 。大多数链接器 可以在创建动态库时 为 动态库构建导入库。</p></blockquote><h1 id="安装和使用库"><a href="#安装和使用库" class="headerlink" title="安装和使用库"></a>安装和使用库</h1><p>现在您已经了解了不同种类的库，让我们讨论一下如何在程序中实际使用库。在c++中安装一个库通常需要4个步骤:</p><ul><li><ol><li><strong>获取库</strong>。</li></ol><blockquote><p>最好的选择是为您的操作系统下载一个预编译包(如果存在的话)，这样您就不必自己编译库了。</p><p>如果您的操作系统没有提供这样的包，那么您必须下载一个<u>只包含源代码的包</u>并自己编译它(这超出了本课的范围)。</p></blockquote><p>在Windows上，库通常以<code>.zip</code>文件的形式发布。</p><p>在Linux上，库通常以包的形式发布(例如<code>. rpm</code>)。</p><p>您的包管理器可能有一些比较流行的库(例如 SDL)。已经列出了，以便于安装，所以先检查一下。</p></li><li><ol start="2"><li><strong>安装库</strong>。</li></ol><p>在Linux上，这通常涉及调用包管理器并让它完成所有工作。</p><p>在Windows上，这通常涉及到将库解压缩到您选择的目录。</p><blockquote><p>我们建议将所有库保存在一个位置，以便于访问。例如，<strong>使用一个名为C:\Libs的目录，并将每个库放在它自己的子目录中。</strong></p></blockquote></li><li><ol start="3"><li><strong>确保编译器知道在哪里查找库的头文件</strong>。</li></ol><p>在Windows上，通常这是安装库文件到的目录的include子目录(例如。如果您将您的库安装到C:\libs\SDL-1.2.11，头文件可能在C:\libs\SDL-1.2.11\include中)。</p><p>在Linux上，头文件通常安装在/usr/include中，它应该已经是包含文件搜索路径的一部分。但是，如果文件安装在其他地方，则必须告诉编译器在哪里找到它们。</p></li><li><ol start="4"><li><strong>告诉链接器在哪里查找库文件</strong>。与步骤3一样，这通常涉及将目录添加到链接器查找库的位置列表中。</li></ol><p>在Windows上，这通常是安装库文件的目录的<code>/lib</code>子目录。</p><p>在Linux上，库通常安装在<code>/usr/lib</code>上，它应该已经是库搜索路径的一部分。</p></li></ul><p>一旦库被安装，IDE知道到哪里去找它，通常需要为每个想要使用库的项目执行以下3个步骤:</p><ul><li><ol start="5"><li><strong>如果使用静态库或导入库，请告诉链接器要链接哪个库文件</strong>。</li></ol></li><li><ol start="6"><li><p><strong>在程序中#include 库的头文件</strong>。</p><p>这将告诉编译器库所提供的所有功能，以便您的程序能够正确地编译。</p></li></ol></li><li><ol start="7"><li><strong>如果使用动态库，请确保程序知道在哪里可以找到它们</strong>。</li></ol><p>在Linux下，库通常安装在/usr/lib中，它位于LD_LIBRARY_PATH环境变量中的路径之后的默认搜索路径中。</p><p>在Windows上，默认的搜索路径包括：程序运行的目录、通过调用SetDllDirectory()设置的目录、Windows、System和System32目录以及path环境变量中的目录。</p><blockquote><p>使用.dll的最简单方法是将.dll复制到可执行文件的位置。由于您通常会将.dll与可执行文件一起发布，因此无论如何将它们放在一起都是有意义的。</p></blockquote></li></ul><p>步骤3-5涉及到配置IDE——</p><ul><li><p>幸运的是，几乎所有ide在执行这些操作时都以相同的方式工作。</p></li><li><p>不幸的是，因为每个IDE都有不同的接口，所以这个过程中最困难的部分就是找到执行这些步骤的正确位置。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/文件的随机IO</title>
      <link href="/archives/60adc21f.html"/>
      <url>/archives/60adc21f.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/187-random-file-io/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/187-random-file-io/</a></p><hr><h1 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h1><p>类中的每个文件流类都包含一个<strong>文件指针</strong>，用于跟踪当前的读/写位置文件。</p><p>当从文件中读取或写入文件时，读取/写入发生在文件指针的当前位置。</p><blockquote><p>默认情况，<strong>当打开文件进行读写操作时，文件指针被设置为文件的开头</strong>。</p><p>但是，<strong>如果以追加模式打开文件</strong>，文件指针就会移动到文件的<strong>末尾</strong>，这样写入操作就不会覆盖文件的任何当前内容。</p></blockquote><h1 id="使用seekg-和seekp-随机访问文件"><a href="#使用seekg-和seekp-随机访问文件" class="headerlink" title="使用seekg()和seekp()随机访问文件"></a>使用seekg()和seekp()随机访问文件</h1><p>之前，我们访问的文件都是按顺序访问的。——也就是说，我们之前是按顺序读取或写入文件内容。</p><p>但是，也可以进行<strong>随机文件访问</strong>。——即，跳过文件中的各个点，来读其内容。</p><blockquote><p>当您的文件中充满了记录，并且您希望检索特定的记录时，这将非常有用。</p></blockquote><p>随机访问文件 是通过<code>seekg()</code>函数(用于input) 和 <code>seekp()</code>函数(用于output) 来操作文件指针。</p><blockquote><p>其中：“g”表示：get ；“p”表示：put。</p></blockquote><p>对于某些类型的流、seekg()(更改读位置) 和 seekp()(更改写位置) 独立操作。</p><p><strong>但是对于，文件流：读和写位置总是相同的，所以可以使用seekg和seekp互换。</strong></p><p><code>seekg()</code>和<code>seekp()</code>函数接受两个参数。</p><ul><li>第一个参数：是决定文件指针的偏移量。</li><li>第二个参数：是一个Ios标志，它指定偏移量参数应该从哪里偏移。</li></ul><table><thead><tr><th>Ios seek flag</th><th>Meaning</th></tr></thead><tbody><tr><td>beg</td><td>the offset is relative to the begining of the file(default)</td></tr><tr><td>cur</td><td>the offset is relative to the current location of the file pointer</td></tr><tr><td>end</td><td>the offset is relative to the end of the file</td></tr></tbody></table><p><strong>正偏移</strong>量意味着将文件指针移动到文件末尾，而<strong>负偏移</strong>意味着将文件指针移动指向文件开头。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inf.seekg(<span class="number">14</span>, ios::cur); <span class="comment">// move forward 14 bytes</span></span><br><span class="line">inf.seekg(<span class="number">-18</span>, ios::cur); <span class="comment">// move backwards 18 bytes</span></span><br><span class="line">inf.seekg(<span class="number">22</span>, ios::beg); <span class="comment">// move to 22nd byte in file</span></span><br><span class="line">inf.seekg(<span class="number">24</span>); <span class="comment">// move to 24th byte in file</span></span><br><span class="line">inf.seekg(<span class="number">-28</span>, ios::<span class="built_in">end</span>); <span class="comment">// move to the 28th byte before end of the file</span></span><br></pre></td></tr></table></figure><p>移动到文件的开头或结尾很容易:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inf.seekg(<span class="number">0</span>, ios::beg); <span class="comment">// move to beginning of file</span></span><br><span class="line">inf.seekg(<span class="number">0</span>, ios::<span class="built_in">end</span>); <span class="comment">// move to end of file</span></span><br></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>让我们使用<code>seekg()</code>和我们在上一课中创建的输入文件来做一个示例。这个输入文件看起来像这样:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">This is <span class="built_in">line</span> <span class="number">1</span></span><br><span class="line">This is <span class="built_in">line</span> <span class="number">2</span></span><br><span class="line">This is <span class="built_in">line</span> <span class="number">3</span></span><br><span class="line">This is <span class="built_in">line</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>下面是代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="function">ifstream <span class="title">inf</span><span class="params">(<span class="string">"Sample.dat"</span>)</span></span>;</span><br><span class="line">    <span class="comment">// If we couldn't open the input file stream for reading</span></span><br><span class="line">    <span class="keyword">if</span> (!inf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Print an error and exit</span></span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Uh oh, Sample.dat could not be opened for reading!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> strData;</span><br><span class="line">    inf.seekg(<span class="number">5</span>); <span class="comment">// move to 5th character</span></span><br><span class="line">    <span class="comment">// Get the rest of the line and print it</span></span><br><span class="line">    getline(inf, strData);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; strData &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    inf.seekg(<span class="number">8</span>, ios::cur); <span class="comment">// move 8 more bytes into file</span></span><br><span class="line">    <span class="comment">// Get rest of the line and print it</span></span><br><span class="line">    getline(inf, strData);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; strData &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    inf.seekg(<span class="number">-15</span>, ios::<span class="built_in">end</span>); <span class="comment">// move 15 bytes before end of file</span></span><br><span class="line">    <span class="comment">// Get rest of the line and print it</span></span><br><span class="line">    getline(inf, strData);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; strData &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/文件的基本IO</title>
      <link href="/archives/2926b12b.html"/>
      <url>/archives/2926b12b.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/186-basic-file-io/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/186-basic-file-io/</a></p><hr><p>c++中的文件I/O的工作方式与普通I/O非常相似(只是增加了一些细微的复杂性)。</p><p>在c++中有3个基本的文件I/O类:（<strong>头文件<code>fstream</code>中</strong>）</p><ul><li><code>ifstream</code> (derived from istream),</li><li><code>ofstream</code> (derived from ostream),</li><li><code>fstream</code> (derived from iostream).</li></ul><p>这些类分别执行文件 <strong>输入</strong>、<strong>输出</strong>和 <strong>输入/输出</strong>。</p><p>与cout、cin、cerr和clog流不同，<strong>文件流必须由程序员显式地设置。</strong></p><p>然而，这非常简单:</p><ul><li>要打开文件进行读取 和/或 写入，只需实例化适当文件I/O类的一个对象，以文件的名称作为参数。然后使用插入(&lt;&lt;)或提取(&gt;&gt;)操作符来写入或读取文件中的数据。</li><li>一旦你完成，有几种方法来<strong>关闭</strong>一个文件:<ul><li>显式调用close()函数，</li><li>或者只需让文件I/O变量超出范围 (文件I/O类析构函数将为您关闭文件)。</li></ul></li></ul><h1 id="文件输出"><a href="#文件输出" class="headerlink" title="文件输出"></a>文件输出</h1><p>要在下面的示例中执行文件输出，我们将使用<strong>ofstream类</strong>。这是非常直接的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ofstream用于编写文件</span></span><br><span class="line"><span class="comment">//我们将创建一个名为Sample.dat的文件</span></span><br><span class="line">    <span class="built_in">std</span>::ofstream outf&#123; <span class="string">"Sample.dat"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 如果我们不能打开输出文件流进行写入</span></span><br><span class="line">    <span class="keyword">if</span> (!outf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 打印错误并退出</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Uh oh, Sample.dat could not be opened for writing!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 我们将在这个文件中写入两行</span></span><br><span class="line">    outf &lt;&lt; <span class="string">"This is line 1"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    outf &lt;&lt; <span class="string">"This is line 2"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当outf超出范围时，ofstream析构函数将关闭文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果查看项目目录，应该会看到一个名为Sample.dat的文件。如果您使用文本编辑器打开它，您将看到它确实包含我们写入文件的两行。</p><blockquote><p>注意，也可以使用put()函数将<strong>单个</strong>字符写入文件。</p></blockquote><h1 id="文件输入"><a href="#文件输入" class="headerlink" title="文件输入"></a>文件输入</h1><p>现在，我们将获取我们在上一个示例中编写的文件，并将其从磁盘读入。</p><p>注意，如果我们到达了文件的末尾(EOF)， ifstream将返回0。我们将使用这个事实来决定需要读多少。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ifstream用于读取文件</span></span><br><span class="line"><span class="comment">// 我们将从一个名为Sample.dat的文件中进行读取</span></span><br><span class="line">    <span class="built_in">std</span>::ifstream inf&#123; <span class="string">"Sample.dat"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// If we couldn't open the output file stream for reading</span></span><br><span class="line">    <span class="keyword">if</span> (!inf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Print an error and exit</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Uh oh, Sample.dat could not be opened for reading!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 还有很多东西要读</span></span><br><span class="line">    <span class="keyword">while</span> (inf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将文件中的内容读入一个字符串并打印出来</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> strInput;</span><br><span class="line">        inf &gt;&gt; strInput;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; strInput &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When inf goes out of scope, the ifstream</span></span><br><span class="line">    <span class="comment">// destructor will close the file</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">This</span><br><span class="line">is</span><br><span class="line"><span class="built_in">line</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">This</span><br><span class="line">is</span><br><span class="line"><span class="built_in">line</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>嗯，那不是我们想要的。请记住，<strong>提取操作符会在空格处中断</strong>。为了整行读取，<strong>我们必须使用getline()函数。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ifstream is used for reading files</span></span><br><span class="line">    <span class="comment">// We'll read from a file called Sample.dat</span></span><br><span class="line">    <span class="built_in">std</span>::ifstream inf&#123; <span class="string">"Sample.dat"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// If we couldn't open the input file stream for reading</span></span><br><span class="line">    <span class="keyword">if</span> (!inf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Print an error and exit</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Uh oh, Sample.dat could not be opened for reading!\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// While there's still stuff left to read</span></span><br><span class="line">    <span class="keyword">while</span> (inf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// read stuff from the file into a string and print it</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> strInput;</span><br><span class="line">        <span class="built_in">std</span>::getline(inf, strInput); <span class="comment">//⭐⭐⭐</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; strInput &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When inf goes out of scope, the ifstream</span></span><br><span class="line">    <span class="comment">// destructor will close the file</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">This is <span class="built_in">line</span> <span class="number">1</span></span><br><span class="line">This is <span class="built_in">line</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h1 id="缓冲输出"><a href="#缓冲输出" class="headerlink" title="缓冲输出"></a>缓冲输出</h1><p><strong>c++的输出可以被缓冲。</strong></p><blockquote><p>这意味着输出到文件流的任何内容都可能<strong>不会立即写入磁盘</strong>。相反，几个输出操作可以成批处理并一起处理。</p></blockquote><p>这主要是出于性能原因。</p><h2 id="刷新缓冲区"><a href="#刷新缓冲区" class="headerlink" title="刷新缓冲区"></a>刷新缓冲区</h2><p>当将缓冲区写入磁盘时，这称为<strong>刷新缓冲区</strong>。</p><h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p><u>使缓冲区被刷新的一种方法是<strong>关闭文件</strong></u>——缓冲区的内容将被刷新到磁盘，然后文件将被关闭。</p><p>缓冲通常不是问题，但在某些情况下，它会给粗心大意的人带来麻烦。</p><ul><li><p>这种情况下的罪魁祸首是<strong>当缓冲区中有数据时，程序立即 终止</strong>(通过崩溃或调用exit())。<u>在这些情况下，文件流类的析构函数不会被执行，这意味着文件永远不会被关闭，这意味着缓冲区永远不会被刷新。</u></p><p><strong>在这种情况下，缓冲区中的数据不写入磁盘，而是永远丢失</strong>。<u>这就是为什么在调用exit()之前显式地关闭所有打开的文件总是一个好主意。</u></p></li></ul><h3 id="手动刷新"><a href="#手动刷新" class="headerlink" title="手动刷新"></a>手动刷新</h3><ul><li><p><strong>可以使用<code>ostream::flush()</code>函数手动刷新缓冲区</strong>，</p></li><li><p><strong>或者将<code>std::flush</code>发送到输出流</strong>。</p></li></ul><p>这两种方法都有助于确保缓冲区的内容被立即写入磁盘，以防程序崩溃。</p><p><strong>有趣的是<code>std::endl</code>; 也刷新输出流。</strong></p><ul><li>因此，过度使用std::endl(导致不必要的缓冲区刷新) 会在执行开销很大的缓冲I/O(例如写入文件)时对性能造成影响。</li></ul><p>出于这个原因，关心性能的<strong>程序员通常会使用’ \n ‘而不是std::endl来将换行符插入到输出流中</strong>，以避免不必要的缓冲区刷新。</p><h1 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h1><p>如果我们试图<strong>写入</strong>一个已经存在的文件，会发生什么? 再次运行输出示例 表明，每次运行程序时，原始文件都被完全覆盖。</p><p><strong>如果我们想要在文件的末尾追加更多的数据</strong>，该怎么办?</p><ul><li><p>结果是，<strong>文件流构造函数接受一个可选的第二个参数，该参数允许您指定有关文件应该如何打开的信息。</strong></p></li><li><p>这个参数称为<strong>mode</strong>，它接受的有效标志（<strong>位于Ios类中</strong>）。</p></li></ul><table><thead><tr><th align="left">Ios file mode</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">app</td><td align="left">Opens the file in append mode</td></tr><tr><td align="left">ate</td><td align="left">Seeks to the end of the file before reading/writing</td></tr><tr><td align="left">binary</td><td align="left">Opens the file in binary mode (instead of text mode)</td></tr><tr><td align="left">in</td><td align="left">Opens the file in read mode (default for ifstream)</td></tr><tr><td align="left">out</td><td align="left">Opens the file in write mode (default for ofstream)</td></tr><tr><td align="left">trunc</td><td align="left">Erases the file if it already exists</td></tr></tbody></table><p><strong>可以通过位操作(使用<code>|</code>操作符)指定多个标志。</strong></p><p>在文件模式下，</p><ul><li>Ifstream默认为<code>std::ios::in</code>；</li><li>Ofstream默认为<code>std::ios::out</code>文件模式。</li><li>fstream 默认为<code>std::ios::in | std::ios::out</code>文件模式，这意味着你可以在默认情况下读和写。</li></ul><p>让我们编写一个程序，在前面创建的Sample.dat文件中追加两行代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 我们会传递ios:app标志告诉ofstream去追加</span></span><br><span class="line"><span class="comment">// 而不是重写文件。我们不需要通过std::ios::out</span></span><br><span class="line"><span class="comment">// 因为ofstream默认std::ios::out</span></span><br><span class="line">    <span class="built_in">std</span>::ofstream outf&#123; <span class="string">"Sample.dat"</span>, <span class="built_in">std</span>::ios::app &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// If we couldn't open the output file stream for writing</span></span><br><span class="line">    <span class="keyword">if</span> (!outf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Print an error and exit</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Uh oh, Sample.dat could not be opened for writing!\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    outf &lt;&lt; <span class="string">"This is line 3"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    outf &lt;&lt; <span class="string">"This is line 4"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When outf goes out of scope, the ofstream</span></span><br><span class="line">    <span class="comment">// destructor will close the file</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">This is line 1</span><br><span class="line">This is line 2</span><br><span class="line">This is line 3</span><br><span class="line">This is line 4</span><br></pre></td></tr></table></figure><h1 id="使用open-显式打开文件"><a href="#使用open-显式打开文件" class="headerlink" title="使用open()显式打开文件"></a>使用open()显式打开文件</h1><p>就像可以使用<strong>close()显式地关闭文件流</strong>一样，也可以使用<strong>open()显式地打开文件流</strong>。</p><ul><li>open()的工作原理与文件流构造函数类似——<strong>它接受一个文件名和一个可选的文件模式。</strong></li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::ofstream outf&#123; <span class="string">"Sample.dat"</span> &#125;;</span><br><span class="line">outf &lt;&lt; <span class="string">"This is line 1"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">outf &lt;&lt; <span class="string">"This is line 2"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">outf.<span class="built_in">close</span>(); <span class="comment">// 显式关闭文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 追加一行</span></span><br><span class="line">outf.<span class="built_in">open</span>(<span class="string">"Sample.dat"</span>, <span class="built_in">std</span>::ios::app);</span><br><span class="line">outf &lt;&lt; <span class="string">"This is line 3\n"</span>;</span><br><span class="line">outf.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><p>其他参考文章：</p><p><a href="https://www.runoob.com/cplusplus/cpp-files-streams.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/cpp-files-streams.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/流状态和输入验证</title>
      <link href="/archives/ba87b609.html"/>
      <url>/archives/ba87b609.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/185-stream-states-and-input-validation/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/185-stream-states-and-input-validation/</a></p><hr><h1 id="流状态"><a href="#流状态" class="headerlink" title="流状态"></a>流状态</h1><p><strong><code>ios_base</code></strong>类包含几个状态标志，用来指示使用流时可能发生的各种情况:</p><table><thead><tr><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">goodbit</td><td align="left">Everything is okay</td></tr><tr><td align="left">badbit</td><td align="left">Some kind of fatal error occurred (e.g. the program tried to read past the end of a file)</td></tr><tr><td align="left">eofbit</td><td align="left">The stream has reached the end of a file</td></tr><tr><td align="left">failbit</td><td align="left">A non-fatal error occurred (eg. the user entered letters when the program was expecting an integer)</td></tr></tbody></table><p>虽然这些标志存在于<code>ios_base</code>中，因为<code>ios</code>是从<code>ios_base</code>派生而来的，而且<code>ios</code>比<code>ios_base</code>需要更少的输入，但它们通常是通过<code>ios</code>访问的(例如<code>std::ios::failbit</code>)。</p><p><strong><code>ios</code></strong>还提供了一些成员功能，以便方便地访问这些国家:</p><table><thead><tr><th align="left">Member function</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">good()</td><td align="left">Returns true if the goodbit is set (the stream is ok)</td></tr><tr><td align="left">bad()</td><td align="left">Returns true if the badbit is set (a fatal error occurred)</td></tr><tr><td align="left">eof()</td><td align="left">Returns true if the eofbit is set (the stream is at the end of a file)</td></tr><tr><td align="left">fail()</td><td align="left">Returns true if the failbit is set (a non-fatal error occurred)</td></tr><tr><td align="left">clear()</td><td align="left">Clears all flags and restores the stream to the goodbit state</td></tr><tr><td align="left">clear(state)</td><td align="left">Clears all flags and sets the state flag passed in</td></tr><tr><td align="left">rdstate()</td><td align="left">Returns the currently set flags</td></tr><tr><td align="left">setstate(state)</td><td align="left">Sets the state flag passed in</td></tr></tbody></table><p>最常处理的位是故障位 (failbit)，它是在用户输入无效输入时设置的。例如，考虑以下程序:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter your age: "</span>;</span><br><span class="line"><span class="keyword">int</span> nAge;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; nAge;</span><br></pre></td></tr></table></figure><p>注意，这个程序期望用户输入一个整数。但是，如果用户输入非数字数据，如“Alex”，cin将无法提取任何数据进行计数，并设置成故障位。</p><p>如果出现错误，并且将流设置为<code>goodbit</code>以外的任何内容。则将忽略该流上的进一步流操作。这个条件可以通过调用<code>clear()</code>函数来清除。</p><h1 id="输入验证"><a href="#输入验证" class="headerlink" title="输入验证"></a>输入验证</h1><p><strong>输入验证</strong>是检查用户输入是否满足某些条件的过程。输入验证通常可以分为两种类型: <strong>字符串</strong>和<strong>数字</strong>。</p><ul><li><p>对于<strong>字符串验证</strong>，我们接受所有用户输入作为一个字符串，然后根据其格式是否正确接受或拒绝该字符串。</p><p>在大多数语言中(特别是像Perl和PHP这样的脚本语言)，这是通过正则表达式完成的。但是，c++没有内置的正则表达式支持。</p><p>因此，这通常是通过检查字符串的每个字符来完成的，以确保它满足一些条件。</p></li><li><p>对于<strong>数字验证</strong>，我们通常关心的是确保用户输入的数字在一个特定的范围内(例如，在0到20之间)。但是，与字符串验证不同，用户可以输入完全不是数字的内容——我们也需要处理这些情况。</p></li></ul><p>为了帮助我们，c++提供了许多有用的函数，我们可以使用这些函数来确定特定字符是数字还是字母。<strong><code>cctype</code>头文件</strong>中有以下函数:</p><table><thead><tr><th align="left">Function</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">isalnum(int)</td><td align="left">Returns non-zero if the parameter is a letter or a digit</td></tr><tr><td align="left">isalpha(int)</td><td align="left">Returns non-zero if the parameter is a letter</td></tr><tr><td align="left">iscntrl(int)</td><td align="left">Returns non-zero if the parameter is a control character</td></tr><tr><td align="left">isdigit(int)</td><td align="left">Returns non-zero if the parameter is a digit</td></tr><tr><td align="left">isgraph(int)</td><td align="left">Returns non-zero if the parameter is printable character that is not whitespace</td></tr><tr><td align="left">isprint(int)</td><td align="left">Returns non-zero if the parameter is printable character (including whitespace)</td></tr><tr><td align="left">ispunct(int)</td><td align="left">Returns non-zero if the parameter is neither alphanumeric nor whitespace</td></tr><tr><td align="left">isspace(int)</td><td align="left">Returns non-zero if the parameter is whitespace</td></tr><tr><td align="left">isxdigit(int)</td><td align="left">Returns non-zero if the parameter is a hexadecimal digit (0-9, a-f, A-F)</td></tr></tbody></table><h2 id="字符串验证"><a href="#字符串验证" class="headerlink" title="字符串验证"></a>字符串验证</h2><p>让我们做一个简单的字符串验证，要求用户输入他们的名字。我们的验证标准是用户只输入字母字符或空格。如果遇到其他情况，输入将被拒绝。</p><blockquote><p><strong>当涉及到可变长度输入时</strong>，验证字符串的最佳方法(除了使用正则表达式库之外)是遍历字符串的每个字符，并确保它满足验证标准。这就是我们要做的。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Get user's name</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter your name: "</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> strName;</span><br><span class="line"><span class="built_in">std</span>::getline(<span class="built_in">cin</span>, strName); <span class="comment">// get the entire line, including spaces</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> bRejected&#123; <span class="literal">false</span> &#125;; <span class="comment">// has strName been rejected?</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Step through each character in the string until we either hit</span></span><br><span class="line"><span class="comment">// the end of the string, or we rejected a character</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> nIndex&#123; <span class="number">0</span> &#125;; nIndex &lt; strName.length() &amp;&amp; !bRejected; ++nIndex)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// If the current character is an alpha character, that's fine</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">isalpha</span>(strName[nIndex]))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// If it's a space, that's fine too</span></span><br><span class="line"><span class="keyword">if</span> (strName[nIndex] == <span class="string">' '</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Otherwise we're rejecting this input</span></span><br><span class="line">bRejected = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// If the input has been accepted, exit the while loop</span></span><br><span class="line"><span class="comment">// otherwise we're going to loop again</span></span><br><span class="line"><span class="keyword">if</span> (!bRejected)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数值验证"><a href="#数值验证" class="headerlink" title="数值验证"></a>数值验证</h2><p>在处理数字输入时，最明显的方法是使用<strong>提取操作符</strong>将输入提取为数字类型。通过检查<strong>故障位</strong>，我们可以判断用户是否输入了数字。</p><p>让我们试试这个方法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nAge;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter your age: "</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; nAge;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">cin</span>.fail()) <span class="comment">// no extraction took place</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">clear</span>(); <span class="comment">// reset the state bits back to goodbit so we can use ignore()</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="number">32767</span>, <span class="string">'\n'</span>); <span class="comment">// clear out the bad input from the stream</span></span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// try again</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (nAge &lt;= <span class="number">0</span>) <span class="comment">// make sure nAge is positive</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"You entered: "</span> &lt;&lt; nAge &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用户输入一个数字，<code>cin.fail()</code>将为false，我们将按break语句，退出循环。如果用户输入以字母开头的输入，<code>cin.fail()</code>将为真，我们将进入条件句。</p><p>更多详细的讲解，请看<a href="https://www.learncpp.com/cpp-tutorial/185-stream-states-and-input-validation/" target="_blank" rel="noopener">原文</a>。这里先不写，说不定以后会补上<code>~~~~</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/字符串的流(stream)类</title>
      <link href="/archives/4be6fd59.html"/>
      <url>/archives/4be6fd59.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/184-stream-classes-for-strings/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/184-stream-classes-for-strings/</a></p><hr><p>到目前为止，您看到的所有I/O示例都是写给cout或从cin读取的。</p><p>然而，还有另一组类叫做<strong>字符串的流类</strong>，它允许您使用熟悉的 插入(&lt;&lt;) 和 提取(&gt;&gt;)操作符来处理字符串。</p><p>与istream和ostream一样，字符串流提供了一个保存数据的缓冲区。但是，与cin和cout不同，这些流没有连接到I/O通道(例如键盘、监视器等)。<strong>字符串流的主要用途之一是缓冲输出以便以后显示，或者逐行处理输入。</strong></p><p>字符串有六个流类，：在<strong>头文件<code>sstream</code></strong>中。</p><ul><li><p>用于读取和写入正常字符宽度的字符串。</p><ul><li>istringstream(继承自istream)，</li><li>ostringstream(继承自ostream)，</li><li>stringstream(继承自iostream)</li></ul></li><li><p>用于读取和写入宽字符串。</p><ul><li>wistringstream</li><li>wostringstream</li><li>wstringstream</li></ul></li></ul><p>有两种方法可以将数据<strong>导入</strong>stringstream：</p><ol><li>使用插入(&lt;&lt;)操作符:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> os;</span><br><span class="line">os &lt;&lt; <span class="string">"en garde!"</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// insert "en garde!" into the stringstream</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用str(string)函数设置缓冲区的值:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> os;</span><br><span class="line">os.str(<span class="string">"en garde!"</span>); <span class="comment">// set the stringstream buffer to "en garde!"</span></span><br></pre></td></tr></table></figure><p>从stringstream中<strong>获取</strong>数据有两种类似的方法:</p><ol><li>使用str()函数检索缓冲区的结果:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> os;</span><br><span class="line">os &lt;&lt; <span class="string">"12345 67.89"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; os.str();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">12345</span> <span class="number">67.89</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用<strong>提取(&gt;&gt;)</strong>操作符:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> os;</span><br><span class="line">os &lt;&lt; <span class="string">"12345 67.89"</span>; <span class="comment">// insert a string of numbers into the stream</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> strValue;</span><br><span class="line">os &gt;&gt; strValue;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> strValue2;</span><br><span class="line">os &gt;&gt; strValue2;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// print the numbers separated by a dash</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; strValue &lt;&lt; <span class="string">" - "</span> &lt;&lt; strValue2 &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p>注意，<strong>&gt;&gt;操作符</strong>遍历字符串——每次连续使用&gt;&gt;都会返回流中的下一个可提取值。</p><p>另一方面，<strong>str()返回流的整个值</strong>，即使已经在流上使用了&gt;&gt;。</p><h1 id="字符串和数字之间的转换"><a href="#字符串和数字之间的转换" class="headerlink" title="字符串和数字之间的转换"></a>字符串和数字之间的转换</h1><p>因为插入和提取操作符知道如何处理所有基本数据类型，<strong>所以我们可以使用它们将字符串转换为数字，反之亦然。</strong></p><p>首先，让我们看看如何<strong>将数字转换成字符串</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> os;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> nValue&#123; <span class="number">12345</span> &#125;;</span><br><span class="line"><span class="keyword">double</span> dValue&#123; <span class="number">67.89</span> &#125;;</span><br><span class="line">os &lt;&lt; nValue &lt;&lt; <span class="string">' '</span> &lt;&lt; dValue;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> strValue1, strValue2;</span><br><span class="line">os &gt;&gt; strValue1 &gt;&gt; strValue2;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; strValue1 &lt;&lt; <span class="string">' '</span> &lt;&lt; strValue2 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">12345</span> <span class="number">67.89</span></span><br></pre></td></tr></table></figure><p>现在让我们把<strong>一个 数字 字符串 转换成一个数字</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> os;</span><br><span class="line">os &lt;&lt; <span class="string">"12345 67.89"</span>; <span class="comment">// insert a string of numbers into the stream</span></span><br><span class="line"><span class="keyword">int</span> nValue;</span><br><span class="line"><span class="keyword">double</span> dValue;</span><br><span class="line"> </span><br><span class="line">os &gt;&gt; nValue &gt;&gt; dValue;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; nValue &lt;&lt; <span class="string">' '</span> &lt;&lt; dValue &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">12345</span> <span class="number">67.89</span></span><br></pre></td></tr></table></figure><h1 id="清除stringstream以便重用"><a href="#清除stringstream以便重用" class="headerlink" title="清除stringstream以便重用"></a>清除stringstream以便重用</h1><p>有几种方法可以清空stringstream的缓冲区。</p><ol><li><p>使用str()与一个空白c风格的字符串 将它设置为空字符串:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> os;</span><br><span class="line">os &lt;&lt; <span class="string">"Hello "</span>;</span><br><span class="line"> </span><br><span class="line">os.str(<span class="string">""</span>); <span class="comment">// erase the buffer</span></span><br><span class="line"> </span><br><span class="line">os &lt;&lt; <span class="string">"World!"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; os.str();</span><br></pre></td></tr></table></figure></li><li><p>使用str()和一个空的std::string对象 将它设置为空字符串:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> os;</span><br><span class="line">os &lt;&lt; <span class="string">"Hello "</span>;</span><br><span class="line"> </span><br><span class="line">os.str(<span class="built_in">std</span>::<span class="built_in">string</span>&#123;&#125;); <span class="comment">// erase the buffer</span></span><br><span class="line"> </span><br><span class="line">os &lt;&lt; <span class="string">"World!"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; os.str();</span><br></pre></td></tr></table></figure><p>这两个程序产生以下相同的结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">World!</span><br></pre></td></tr></table></figure></li></ol><p><strong>当清除一个stringstream时，调用clear()函数通常也是一个好主意:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> os;</span><br><span class="line">os &lt;&lt; <span class="string">"Hello "</span>;</span><br><span class="line"> </span><br><span class="line">os.str(<span class="string">""</span>); <span class="comment">// erase the buffer</span></span><br><span class="line">os.<span class="built_in">clear</span>(); <span class="comment">// reset error flags</span></span><br><span class="line"> </span><br><span class="line">os &lt;&lt; <span class="string">"World!"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; os.str();</span><br></pre></td></tr></table></figure><p>clear()函数 重置可能已经设置的任何错误标志，并将流返回到ok状态。在下一课中，我们将更多地讨论流状态和错误标志。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/ostream与ios 输出</title>
      <link href="/archives/927246b0.html"/>
      <url>/archives/927246b0.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/183-output-with-ostream-and-ios/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/183-output-with-ostream-and-ios/</a></p><hr><p>在本节中，我们将研究iostream输出类(ostream)的各个方面。</p><p>注意:</p><p><strong>本课中的所有I/O功能都位于std名称空间中</strong>。<strong>这意味着所有I/O对象和函数要么必须以“std::”为前缀，要么必须使用“using namespace std;”语句。</strong></p><h1 id="插入操作符-lt-lt"><a href="#插入操作符-lt-lt" class="headerlink" title="插入操作符(&lt;&lt;)"></a>插入操作符(&lt;&lt;)</h1><p>插入操作符(&lt;&lt;)<strong>用于将信息放入输出流。</strong></p><p>c++为所有内置数据类型预定义了插入操作，您已经了解了如何为您自己的类[重载插入操作符](<a href="http://www.learncpp.com/cpp-tutorial/93-overloading-the-io-operators/" target="_blank" rel="noopener">overload the insertion operator</a>)。</p><p>在关于<a href="https://www.learncpp.com/cpp-tutorial/183-output-with-ostream-and-ios/" target="_blank" rel="noopener">Input and output (I/O) streams</a>的课程中，您看到istream和ostream都来自于一个名为ios的类。ios(和ios_base)的任务之一是控制输出的格式化选项。</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>有两种方法来改变格式选项:</p><ul><li><p><strong>标志(flag)</strong>——可以将标志看作可以打开和关闭的布尔变量。</p></li><li><p><strong>控制器(manipulator)</strong>——控制器 是放置在流中的对象，它影响输入和输出的方式。</p></li></ul><h2 id="标志-flag"><a href="#标志-flag" class="headerlink" title="标志(flag)"></a>标志(flag)</h2><p>要<strong>打开标志</strong>，请使用<strong>setf()</strong>函数，并将适当的标志作为参数。</p><p>例如，在默认情况下，c++不会在正数前面打印+符号。但是，通过使用std::ios::showpos标志，我们可以改变这个行为:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::showpos); <span class="comment">// turn on the std::ios::showpos flag</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这将产生以下输出:*/</span></span><br><span class="line">+<span class="number">27</span></span><br></pre></td></tr></table></figure><p>可以使用<strong>OR(|)操作符</strong>同时打开多个ios标志:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::showpos | <span class="built_in">std</span>::ios::uppercase); <span class="comment">// turn on the std::ios::showpos and std::ios::uppercase flag</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p>要<strong>关闭标志</strong>，请使用<strong>unsetf()</strong>函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::showpos); <span class="comment">// turn on the std::ios::showpos flag</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.unsetf(<span class="built_in">std</span>::ios::showpos); <span class="comment">// turn off the std::ios::showpos flag</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">28</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这将产生以下输出:*/</span></span><br><span class="line">+<span class="number">27</span></span><br><span class="line"><span class="number">28</span></span><br></pre></td></tr></table></figure><p>在使用setf()时，还有一个需要注意的问题。</p><ul><li>许多标志属于组，称为<strong>格式组(format group)</strong>。格式组是一组执行类似 (有时互斥) 格式选项的标志。</li></ul><p>例如，名为“basefield”的格式组包含标志“oct”、“dec”和“hex”，它们控制整数值的基数。默认情况下，设置“dec”标志。因此，如果我们这样做:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::hex); <span class="comment">// try to turn on hex output</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*我们得到如下输出:*/</span></span><br><span class="line"><span class="number">27</span></span><br></pre></td></tr></table></figure><p>它没有工作! <strong>原因是setf()只打开标志</strong>——因此，当我们打开std::hex时，std::ios::dec仍然是打开的，而std::ios::dec显然是优先的。有两种方法可以解决这个问题。</p><ul><li><p>首先，我们<strong>可以关闭std::ios::dec</strong>，这样就只设置了std::ios::hex:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.unsetf(<span class="built_in">std</span>::ios::dec); <span class="comment">// turn off decimal output</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::hex); <span class="comment">// turn on hexadecimal output</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">1b</span></span><br></pre></td></tr></table></figure></li><li><p>第二种方法是使用另一种形式的setf()，它有两个参数:</p><ul><li>第一个参数是要设置的标志，</li><li>第二个是它所属的格式化组。</li></ul><p>当使用这种形式的setf()时，属于这个组的所有标志都是关闭的，只有传入的标志是打开的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Turn on std::ios::hex as the only std::ios::basefield flag</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::hex, <span class="built_in">std</span>::ios::basefield);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">1b</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="控制器-manipulator"><a href="#控制器-manipulator" class="headerlink" title="控制器(manipulator)"></a>控制器(manipulator)</h2><p>使用setf()和unsetf()可能会有些笨拙，因此c++提供了第二种方法来更改格式化选项: <strong>控制器(manipulator)</strong>。</p><p>控制器的优点是他们足够聪明，<strong>能够打开和关闭适当的标志</strong>。</p><p>这里有一个例子，使用一些控制器来改变基地:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print 27 in hex</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">28</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// we're still in hex</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::dec &lt;&lt; <span class="number">29</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// back to decimal</span></span><br></pre></td></tr></table></figure><p>这个程序产生的输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1b</span><br><span class="line">1c</span><br><span class="line">29</span><br></pre></td></tr></table></figure><p><strong>通常，使用 控制器 比 设置和取消标志 要容易得多。</strong>许多选项可以通过标志和操作器(例如更改基数)来使用，但是，其他选项只能通过标志或操作器来使用，因此了解如何使用这两个选项非常重要。</p><h2 id="有用的格式器"><a href="#有用的格式器" class="headerlink" title="有用的格式器"></a>有用的格式器</h2><p>下面是一些更有用的标志、控制器和 成员函数 的列表。</p><ul><li><p><strong>标记</strong>位于<strong>std::ios</strong>类中</p></li><li><p><strong>控制器</strong>位于<strong>std名称空间</strong>中，</p></li><li><p><strong>成员函数</strong>位于<strong>std::ostream类</strong>中。</p></li></ul><table><thead><tr><th align="left">Group</th><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"></td><td align="left">std::ios::boolalpha</td><td align="left">If set, booleans print “true” or “false”. If not set, booleans print 0 or 1</td></tr></tbody></table><table><thead><tr><th align="left">Manipulator</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">std::boolalpha</td><td align="left">Booleans print “true” or “false”</td></tr><tr><td align="left">std::noboolalpha</td><td align="left">Booleans print 0 or 1 (default)</td></tr></tbody></table><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="literal">false</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::boolalpha);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="literal">false</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::noboolalpha &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="literal">false</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="literal">false</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="literal">true</span> <span class="literal">false</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="literal">true</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><hr><table><thead><tr><th align="left">Group</th><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"></td><td align="left">std::ios::showpos</td><td align="left">If set, prefix positive numbers with a +</td></tr></tbody></table><table><thead><tr><th align="left">Manipulator</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">std::showpos</td><td align="left">Prefixes positive numbers with a +</td></tr><tr><td align="left">std::noshowpos</td><td align="left">Doesn’t prefix positive numbers with a +</td></tr></tbody></table><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">5</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::showpos);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">5</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::noshowpos &lt;&lt; <span class="number">5</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::showpos &lt;&lt; <span class="number">5</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">+<span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">+<span class="number">5</span></span><br></pre></td></tr></table></figure><hr><table><thead><tr><th align="left">Group</th><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"></td><td align="left">std::ios::uppercase</td><td align="left">If set, uses upper case letters</td></tr></tbody></table><table><thead><tr><th align="left">Manipulator</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">std::uppercase</td><td align="left">Uses upper case letters</td></tr><tr><td align="left">std::nouppercase</td><td align="left">Uses lower case letters</td></tr></tbody></table><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">12345678.9</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::uppercase);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">12345678.9</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::nouppercase &lt;&lt; <span class="number">12345678.9</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::uppercase &lt;&lt; <span class="number">12345678.9</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">1.23457e+007</span></span><br><span class="line"><span class="number">1.23457E+007</span></span><br><span class="line"><span class="number">1.23457e+007</span></span><br><span class="line"><span class="number">1.23457E+007</span></span><br></pre></td></tr></table></figure><hr><table><thead><tr><th align="left">Group</th><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">std::ios::basefield</td><td align="left">std::ios::dec</td><td align="left">Prints values in decimal (default)</td></tr><tr><td align="left">std::ios::basefield</td><td align="left">std::ios::hex</td><td align="left">Prints values in hexadecimal</td></tr><tr><td align="left">std::ios::basefield</td><td align="left">std::ios::oct</td><td align="left">Prints values in octal</td></tr><tr><td align="left">std::ios::basefield</td><td align="left">(none)</td><td align="left">Prints values according to leading characters of value</td></tr></tbody></table><table><thead><tr><th align="left">Manipulator</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">std::dec</td><td align="left">Prints values in decimal</td></tr><tr><td align="left">std::hex</td><td align="left">Prints values in hexadecimal</td></tr><tr><td align="left">std::oct</td><td align="left">Prints values in octal</td></tr></tbody></table><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::dec, <span class="built_in">std</span>::ios::basefield);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::oct, <span class="built_in">std</span>::ios::basefield);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::hex, <span class="built_in">std</span>::ios::basefield);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::dec &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::oct &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">33</span></span><br><span class="line"><span class="number">1b</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">33</span></span><br><span class="line"><span class="number">1b</span></span><br></pre></td></tr></table></figure><p>现在，您应该能够通过标记和控制器查看设置格式之间的关系。在以后的示例中，我们将使用控制器，除非它们不可用。</p><h1 id="精度、符号和小数点"><a href="#精度、符号和小数点" class="headerlink" title="精度、符号和小数点"></a>精度、符号和小数点</h1><p>通过使用操作器(或标志)，可以更改显示浮点数的精度和格式。有几种格式化选项以某种复杂的方式组合在一起，因此我们将仔细研究这个问题。</p><table><thead><tr><th align="left">Group</th><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">std::ios::floatfield</td><td align="left">std::ios::fixed</td><td align="left">Uses decimal notation for floating-point numbers</td></tr><tr><td align="left">std::ios::floatfield</td><td align="left">std::ios::scientific</td><td align="left">Uses scientific notation for floating-point numbers</td></tr><tr><td align="left">std::ios::floatfield</td><td align="left">(none)</td><td align="left">Uses fixed for numbers with few digits, scientific otherwise</td></tr><tr><td align="left">std::ios::floatfield</td><td align="left">std::ios::showpoint</td><td align="left">Always show a decimal point and trailing 0’s for floating-point values</td></tr></tbody></table><table><thead><tr><th align="left">Manipulator</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">std::fixed</td><td align="left">Use decimal notation for values</td></tr><tr><td align="left">std::scientific</td><td align="left">Use scientific notation for values</td></tr><tr><td align="left">std::showpoint</td><td align="left">Show a decimal point and trailing 0’s for floating-point values</td></tr><tr><td align="left">std::noshowpoint</td><td align="left">Don’t show a decimal point and trailing 0’s for floating-point values</td></tr><tr><td align="left">std::setprecision(int)</td><td align="left">Sets the precision of floating-point numbers (defined in iomanip.h)</td></tr></tbody></table><table><thead><tr><th align="left">Member function</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">std::precision()</td><td align="left">Returns the current precision of floating-point numbers</td></tr><tr><td align="left">std::precision(int)</td><td align="left">Sets the precision of floating-point numbers and returns old precision</td></tr></tbody></table><ul><li><strong>如果使用固定记数法或科学记数法</strong>，则精度决定了在分数中显示多少位小数。注意，如果精度小于有效数字的数目，则该数字将四舍五入。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::fixed &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">3</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">4</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">5</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">6</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">7</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::scientific &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">3</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">4</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">5</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">6</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">7</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">123.456</span><br><span class="line">123.4560</span><br><span class="line">123.45600</span><br><span class="line">123.456000</span><br><span class="line">123.4560000</span><br><span class="line"></span><br><span class="line">1.235e+002</span><br><span class="line">1.2346e+002</span><br><span class="line">1.23456e+002</span><br><span class="line">1.234560e+002</span><br><span class="line">1.2345600e+002</span><br></pre></td></tr></table></figure><ul><li><strong>如果既不使用固定数字，也不使用科学数字，则精度决定应显示多少位有效数字。</strong>同样，如果精度小于有效数字的数目，则该数字将四舍五入。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">3</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">4</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">5</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">6</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">7</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">123</span><br><span class="line">123.5</span><br><span class="line">123.46</span><br><span class="line">123.456</span><br><span class="line">123.456</span><br></pre></td></tr></table></figure><ul><li><strong>使用showpoint控制器器或标记，您可以让流 写入小数点和尾随零</strong>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::showpoint &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">3</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">4</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">5</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">6</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">7</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123.</span></span><br><span class="line"><span class="number">123.5</span></span><br><span class="line"><span class="number">123.46</span></span><br><span class="line"><span class="number">123.456</span></span><br><span class="line"><span class="number">123.4560</span></span><br></pre></td></tr></table></figure><p>下面是一些例子的总结表:</p><table><thead><tr><th align="left">Option</th><th align="left">Precision</th><th align="left">12345.0</th><th align="left">0.12345</th></tr></thead><tbody><tr><td align="left">Normal</td><td align="left">3</td><td align="left">1.23e+004</td><td align="left">0.123</td></tr><tr><td align="left">4</td><td align="left">1.235e+004</td><td align="left">0.1235</td><td align="left"></td></tr><tr><td align="left">5</td><td align="left">12345</td><td align="left">0.12345</td><td align="left"></td></tr><tr><td align="left">6</td><td align="left">12345</td><td align="left">0.12345</td><td align="left"></td></tr><tr><td align="left">Showpoint</td><td align="left">3</td><td align="left">1.23e+004</td><td align="left">0.123</td></tr><tr><td align="left">4</td><td align="left">1.235e+004</td><td align="left">0.1235</td><td align="left"></td></tr><tr><td align="left">5</td><td align="left">12345.</td><td align="left">0.12345</td><td align="left"></td></tr><tr><td align="left">6</td><td align="left">12345.0</td><td align="left">0.123450</td><td align="left"></td></tr><tr><td align="left">Fixed</td><td align="left">3</td><td align="left">12345.000</td><td align="left">0.123</td></tr><tr><td align="left">4</td><td align="left">12345.0000</td><td align="left">0.1235</td><td align="left"></td></tr><tr><td align="left">5</td><td align="left">12345.00000</td><td align="left">0.12345</td><td align="left"></td></tr><tr><td align="left">6</td><td align="left">12345.000000</td><td align="left">0.123450</td><td align="left"></td></tr><tr><td align="left">Scientific</td><td align="left">3</td><td align="left">1.235e+004</td><td align="left">1.235e-001</td></tr><tr><td align="left">4</td><td align="left">1.2345e+004</td><td align="left">1.2345e-001</td><td align="left"></td></tr><tr><td align="left">5</td><td align="left">1.23450e+004</td><td align="left">1.23450e-001</td><td align="left"></td></tr><tr><td align="left">6</td><td align="left">1.234500e+004</td><td align="left">1.234500e-001</td><td align="left"></td></tr></tbody></table><h1 id="宽度、填充字符和对齐"><a href="#宽度、填充字符和对齐" class="headerlink" title="宽度、填充字符和对齐"></a>宽度、填充字符和对齐</h1><p>通常，当您打印数字时，数字的打印与周围的空间无关。然而，向左或向右打印数字是可能的。</p><ul><li><strong>为了做到这一点，我们必须首先定义一个字段宽度，它定义了一个值将具有的输出空间的数量。</strong><ul><li>如果实际打印的数字小于字段宽度，它将被左对齐或右对齐(如指定)。</li><li>如果实际数字大于字段宽度，则<u>不会截断它</u>——它将溢出字段。</li></ul></li></ul><table><thead><tr><th align="left">Group</th><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">std::ios::adjustfield</td><td align="left">std::ios::internal</td><td align="left">Left-justifies the sign of the number, and right-justifies the value</td></tr><tr><td align="left">std::ios::adjustfield</td><td align="left">std::ios::left</td><td align="left">Left-justifies the sign and value</td></tr><tr><td align="left">std::ios::adjustfield</td><td align="left">std::ios::right</td><td align="left">Right-justifies the sign and value (default)</td></tr></tbody></table><table><thead><tr><th align="left">Manipulator</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">std::internal</td><td align="left">Left-justifies the sign of the number, and right-justifies the value</td></tr><tr><td align="left">std::left</td><td align="left">Left-justifies the sign and value</td></tr><tr><td align="left">std::right</td><td align="left">Right-justifies the sign and value</td></tr><tr><td align="left">std::setfill(char)</td><td align="left">Sets the parameter as the fill character (defined in iomanip.h)</td></tr><tr><td align="left">std::setw(int)</td><td align="left">Sets the field width for input and output to the parameter (defined in iomanip.h)</td></tr></tbody></table><table><thead><tr><th align="left">Member function</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">std::fill()</td><td align="left">Returns the current fill character</td></tr><tr><td align="left">std::fill(char)</td><td align="left">Sets the fill character and returns the old fill character</td></tr><tr><td align="left">std::width()</td><td align="left">Returns the current field width</td></tr><tr><td align="left">std::width(int)</td><td align="left">Sets the current field width and returns old field width</td></tr></tbody></table><p>为了使用任何这些格式化器，我们首先必须设置字段宽度。</p><blockquote><p>这可以通过<strong>width(int)</strong>成员函数或<strong>setw()</strong>机械手来完成。<strong>注意，右对齐是默认的。</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">-12345</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print default value with no field width</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">10</span>) &lt;&lt; <span class="number">-12345</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print default with field width</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">10</span>) &lt;&lt; left &lt;&lt; <span class="number">-12345</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print left justified</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">10</span>) &lt;&lt; right &lt;&lt; <span class="number">-12345</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print right justified</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">10</span>) &lt;&lt; internal &lt;&lt; <span class="number">-12345</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print internally justified</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">-12345</span></span><br><span class="line">    <span class="number">-12345</span></span><br><span class="line"><span class="number">-12345</span></span><br><span class="line">    <span class="number">-12345</span></span><br><span class="line">-    <span class="number">12345</span></span><br></pre></td></tr></table></figure><p><strong>需要注意的一点是，setw()和width()只影响下一个输出语句</strong>。它们不像其他一些标志/操纵器那样持久。</p><p>现在，让我们设置一个填充字符，并做同样的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.<span class="built_in">fill</span>(<span class="string">'*'</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">-12345</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print default value with no field width</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">10</span>) &lt;&lt; <span class="number">-12345</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print default with field width</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">10</span>) &lt;&lt; left &lt;&lt; <span class="number">-12345</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print left justified</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">10</span>) &lt;&lt; right &lt;&lt; <span class="number">-12345</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print right justified</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">10</span>) &lt;&lt; internal &lt;&lt; <span class="number">-12345</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print internally justified</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">-12345</span></span><br><span class="line">****<span class="number">-12345</span></span><br><span class="line"><span class="number">-12345</span>****</span><br><span class="line">****<span class="number">-12345</span></span><br><span class="line">-****<span class="number">12345</span></span><br></pre></td></tr></table></figure><p>请注意，字段中的所有空格都已用填充字符填充。</p><p>ostream类和iostream库包含其他可能有用的输出函数、标志和操作符，这取决于您需要做什么。与istream类一样，这些主题实际上更适合于关注标准库的教程或书籍(例如Nicolai M. Josuttis的优秀书籍《c++标准模板库》)。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/istream输入</title>
      <link href="/archives/dac06bda.html"/>
      <url>/archives/dac06bda.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/182-input-with-istream/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/182-input-with-istream/</a></p><hr><p>iostream库相当复杂——因此我们无法在本教程中完整地介绍它。但是，我们将向您展示最常用的功能。在本节中，我们将研究input类(istream)的各个方面。</p><h1 id="提取操作符-gt-gt"><a href="#提取操作符-gt-gt" class="headerlink" title="提取操作符(&gt;&gt;)"></a>提取操作符(&gt;&gt;)</h1><p>正如在许多课程中看到的，我们可以使用<strong>提取操作符(&gt;&gt;)</strong>从输入流中读取信息。</p><p><strong>c++为所有内置数据类型提供了预定义的提取操作</strong>，您已经了解了如何<a href="https://www.google.com/search?q=overload+the+extraction+operator&oq=overload+the+extraction+operator+&aqs=chrome..69i57&sourceid=chrome&ie=UTF-8" target="_blank" rel="noopener">重载自己类的提取操作符</a>。</p><p>读取字符串时，提取操作符的一个常见问题是如何防止输入溢出缓冲区。给出以下例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; buf;</span><br></pre></td></tr></table></figure><p>如果用户输入18个字符会发生什么?缓冲区溢出，就会发生不好的事情。一般来说，对用户将输入多少字符做任何假设都不是一个好主意。</p><p>处理这个问题的一种方法是使用<strong>控制符</strong>。<strong>控制符</strong>是一个对象，当使用提取(&gt;&gt;)或插入(&lt;&lt;)操作符时，用于修改流。</p><blockquote><p>您已经广泛使用过的一个控制符是“endl”，它既打印换行字符，又刷新任何缓冲输出。</p></blockquote><p><strong>c++提供了一个名为setw的机械手(在iomanip.h头文件中)，</strong>它可以用来限制从流中读取的字符的数量。</p><blockquote><p>要使用setw()，只需提供作为参数读取的最大字符数，并将其插入到您的输入语句中，</p></blockquote><p>如下所示:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; <span class="built_in">std</span>::setw(<span class="number">10</span>) &gt;&gt; buf;</span><br></pre></td></tr></table></figure><p>这个程序现在将只从流中读取前9个字符(为终止符留出空间)。任何剩余的字符都将留在流中，直到下一次提取。</p><h1 id="提取和空白"><a href="#提取和空白" class="headerlink" title="提取和空白"></a>提取和空白</h1><p>到目前为止，我们没有提到的一件事是<strong>提取操作符处理“格式化”的数据</strong>——也就是说，它跳过空白(空格、制表符和换行符)。</p><p>看看下面的程序:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; ch)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ch;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当用户输入以下内容时:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello my name is Alex</span><br></pre></td></tr></table></figure><p>提取操作符跳过空格和换行符。因此，输出为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HellomynameisAlex</span><br></pre></td></tr></table></figure><p><strong>通常，您希望获得用户输入，但不放弃空格。为此，istream类提供了许多可用于此目的的函数。</strong></p><h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><ul><li><p><strong><code>get()</code></strong>——最有用的函数之一是get()函数，它只从输入流中获取一个字符。下面是上面使用get()的同一个程序:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>(ch))</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ch;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*现在当我们使用输入:*/</span></span><br><span class="line">Hello my name is Alex</span><br><span class="line"><span class="comment">/*它的结果是*/</span></span><br><span class="line">Hello my name is Alex</span><br></pre></td></tr></table></figure><p><strong>std::get()也有一个字符串版本，需要读取最多的字符:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> strBuf[<span class="number">11</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>(strBuf, <span class="number">11</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; strBuf &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*现在当我们使用输入:*/</span></span><br><span class="line">Hello my name is Alex</span><br><span class="line"><span class="comment">/*它的结果是*/</span></span><br><span class="line">Hello my n</span><br></pre></td></tr></table></figure><blockquote><p>注意，我们只读取了前10个字符(必须留下一个字符作为终止符)。其余字符留在输入流中。</p></blockquote></li></ul><p>关于<strong>get()</strong>需要注意的一件重要事情是，它<strong>不读取换行字符</strong>! 这可能会导致一些意想不到的结果:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> strBuf[<span class="number">11</span>];</span><br><span class="line">    <span class="comment">// Read up to 10 characters</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>(strBuf, <span class="number">11</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; strBuf &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Read up to 10 more characters</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>(strBuf, <span class="number">11</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; strBuf &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用户输入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello!</span><br></pre></td></tr></table></figure><p>程序将打印:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello!</span><br></pre></td></tr></table></figure><p>然后终止! 为什么不要求增加10个字符呢? 答案是，因为第一个get()读到换行，然后停止。第二个get()看到cin流中仍然有输入，并试图读取它。但第一个字符是换行符，所以它立即停止。</p><h2 id="getline"><a href="#getline" class="headerlink" title="getline()"></a>getline()</h2><p>因此，还有另一个名为getline()的函数，它的工作方式与get()完全相同，<strong>但它会读取换行符</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> strBuf[<span class="number">11</span>];</span><br><span class="line">    <span class="comment">// Read up to 10 characters</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.getline(strBuf, <span class="number">11</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; strBuf &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Read up to 10 more characters</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.getline(strBuf, <span class="number">11</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; strBuf &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码将按照您的期望执行，即使用户输入一个带有换行符的字符串。</p><p><strong>如果需要知道getline()的最后一次调用提取了多少字符，</strong> 使用<strong><code>gcount ()</code></strong> :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> strBuf[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.getline(strBuf, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; strBuf &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">cin</span>.gcount() &lt;&lt; <span class="string">" characters were read"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一些更有用的istream函数"><a href="#一些更有用的istream函数" class="headerlink" title="一些更有用的istream函数"></a>一些更有用的istream函数</h1><p>这里有一些更有用的输入函数，你可能想利用:</p><ul><li><p><strong><code>ignore()</code>：</strong>丢弃流中的第一个字符**。</p></li><li><p><strong><code>ignore(int nCount)</code></strong>：丢弃第一个nCount字符。</p></li><li><p><strong><code>peek()</code></strong>：允许您从流中读取字符，而无需从流中删除字符。</p></li><li><p><strong><code>unget()</code></strong>：将最后读取的字符返回到流中，以便下一个调用可以再次读取它。</p></li><li><p><strong><code>putback(char ch)</code></strong>：允许您将选择的字符放回流中，以便下一次调用读取。</p></li></ul><p>istream包含了许多其他的函数和上面提到的函数的变体，它们可能是有用的，这取决于你需要做什么。但是，这些主题更适合于关注标准库的教程或书籍（如 <a href="https://www.amazon.com/Standard-Library-Tutorial-Reference-2nd/dp/0321623215" target="_blank" rel="noopener">“The C++ Standard Library”</a> by Nicolai M. Josuttis）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/输入输出(IO)流</title>
      <link href="/archives/57266241.html"/>
      <url>/archives/57266241.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/181-input-and-output-io-streams/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/181-input-and-output-io-streams/</a></p><hr><p>输入和输出功能不是作为核心c++语言的一部分定义的，而是通过c++标准库提供的 (因此驻留在<strong>std名称空间</strong>中)。</p><p>在以前的课程中，您包括了iostream库头，并使用cin和cout对象来执行简单的I/O。在这节课中，我们将更详细地了解iostream库。</p><h1 id="iostream库"><a href="#iostream库" class="headerlink" title="iostream库"></a><code>iostream</code>库</h1><p>当您包含iostream报头时，您可以访问 负责提供I/O功能的整个类层次结构 (包括一个实际名为iostream的类)。非文件 I/O类的类层次结构如下:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="http://www.learncpp.com/images/CppTutorial/Section13/iostream.gif" alt="img"></p><p>关于这个层次结构，您可能注意到的第一件事是它使用了多重继承(我们告诉您尽可能避免的事情)。但是，为了避免任何典型的多重继承问题，已经设计并广泛测试了iostream库，所以您可以自由地使用它。</p><h2 id="流-Streams"><a href="#流-Streams" class="headerlink" title="流(Streams)"></a>流(Streams)</h2><p>你可能注意到的第二件事是，<strong>“流”</strong>这个词使用得非常频繁。在最基本的方面，c++中的I/O是用流实现的。<strong>抽象地说，流就是可以按顺序访问的字节序列。随着时间的推移，流可能产生或消耗无限数量的数据。</strong></p><p>通常我们处理两种不同类型的流：</p><ul><li><p><strong>输入流</strong>用于保存来自数据生成器 (如键盘、文件或网络)的输入。</p><blockquote><p>例如，当程序当前不期望任何输入时，用户可以按键盘上的一个键。而不是忽略用户的按键，数据被放入一个输入流，在那里它将等待，直到程序为它准备好。</p></blockquote></li><li><p>相反，<strong>输出流</strong>用于保存特定数据使用者 (如监视器、文件或打印机)的输出。</p><blockquote><p>当向输出设备写入数据时，设备可能还没有准备好接受该数据——例如，当程序将数据写入其输出流时，打印机可能仍然处于预热状态。这些数据将保存在输出流中，直到打印机开始使用它。</p></blockquote></li></ul><p>一些设备，如文件和网络，可以同时作为输入源和输出源。</p><p><strong>流的好处是程序员只需要学习如何与流交互，就可以将数据读写到许多不同的设备上</strong>。流如何与它们所连接的实际设备进行接口的详细信息由环境或操作系统决定。</p><h1 id="在c-中的输入-输出"><a href="#在c-中的输入-输出" class="headerlink" title="在c++中的输入/输出"></a>在c++中的输入/输出</h1><p>虽然<strong>ios类</strong>通常派生自ios_base类，但ios 通常是您将直接使用的最基本的类。ios类定义了一些输入流和输出流共有的东西。我们将在以后的课程中讨论这些内容。</p><p><strong>istream类</strong>是<strong>处理输入流</strong>时使用的主要类。<strong>对于输入流，提取操作符(&gt;&gt;) 用于从流中删除值。</strong> 这是有意义的:</p><ul><li>当用户在键盘上按下一个键时，键代码就被放置在输入流中。然后，程序从流中提取值，以便使用它。</li></ul><p><strong>ostream类</strong>是<strong>处理输出流</strong>时使用的主要类。<strong>对于输出流，使用插入操作符(&lt;&lt;)将值放入流中</strong>。这也是有意义的:</p><ul><li>您将您的值插入到流中，数据使用者(例如。监控)使用。</li></ul><p><strong>iostream类可以处理输入和输出，允许双向I/O。</strong></p><p>最后，有一堆类以“_withassign”结束。这些 流类 派生自istream、ostream和iostream (分别)，并定义了赋值运算符，允许您将一个流分配给另一个流。在大多数情况下，您不会直接处理这些类。</p><h1 id="c-中的标准流"><a href="#c-中的标准流" class="headerlink" title="c++中的标准流"></a>c++中的标准流</h1><p><strong>标准流是由环境提供给计算机程序的预先连接的流。</strong></p><p>c++附带了四个预定义的标准流对象，它们已经为您的使用进行了设置。</p><ul><li><code>cin</code>——与标准输入(通常是键盘)绑定的 istream_withassign类</li><li><code>cout</code>——与标准输出(通常是监视器)绑定的ostream_withassign类</li><li><code>cerr</code>—— 一个与标准<u>错误</u>(通常是监视器)绑定的ostream_withassign类，提供 未缓冲 的<strong>输出</strong></li><li><code>clog</code>—— 一个与标准错误(通常是监视器)绑定的ostream_withassign类，提供缓冲 <strong>输出</strong></li></ul><p><strong>非缓冲输出通常是立即处理的，而缓冲输出通常是作为一个块存储和写入的</strong>。因为clog不是经常使用，所以它常常从标准流列表中被省略。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/std：：string的插入</title>
      <link href="/archives/e56a544e.html"/>
      <url>/archives/e56a544e.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/17-7-stdstring-inserting/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/17-7-stdstring-inserting/</a></p><hr><p>可以通过<strong>insert()</strong>函数将字符插入到现有的字符串中。</p><p><strong><code>string&amp; string::insert (size_type index, const string&amp; str)</code></strong></p><p><strong><code>string&amp; string::insert (size_type index, const char* str)</code></strong></p><ul><li>这两个函数都将str的字符插入到索引处的字符串中</li><li>两个函数都返回*this，因此它们可以被“链接”。</li><li>如果索引无效，两个函数都会抛出out_of_range</li><li>如果结果超过最大字符数，这两个函数都会抛出一个length_error异常。</li><li>在c风格的字符串版本中，str不能为空。</li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sString</span><span class="params">(<span class="string">"aaaa"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">sString.insert(<span class="number">2</span>, <span class="built_in">string</span>(<span class="string">"bbbb"</span>));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">sString.insert(<span class="number">4</span>, <span class="string">"cccc"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aaaa</span><br><span class="line">aabbbbaa</span><br><span class="line">aabbccccbbaa</span><br></pre></td></tr></table></figure><p>下面，将只给出函数的声明，具体解释，请看原文对应内容：</p><p><strong><code>string&amp; string::insert (size_type index, const string&amp; str, size_type startindex, size_type num)</code></strong></p><p><strong><code>string&amp; string::insert(size_type index, const char* str, size_type len)</code></strong></p><p><strong><code>string&amp; string::insert(size_type index, size_type num, char c)</code></strong></p><p><strong><code>void insert(iterator it, size_type num, char c)</code></strong></p><p><strong><code>iterator string::insert(iterator it, char c)</code></strong></p><p><strong><code>void string::insert(iterator it, InputIterator begin, InputIterator end)</code></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/std：：string的末尾追加字符串</title>
      <link href="/archives/54babab5.html"/>
      <url>/archives/54babab5.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/17-6-stdstring-appending/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/17-6-stdstring-appending/</a></p><hr><p>使用<strong>运算符+=</strong>、<strong>append()</strong>或<strong>push_back()</strong>函数可以很容易地将字符串追加到现有字符串的末尾。</p><p><strong><code>string&amp; string::operator+= (const string&amp; str)</code></strong></p><p><strong><code>string&amp; string::append (const string&amp; str)</code></strong></p><ul><li>这两个函数都将str的字符追加到字符串中。</li></ul><ul><li>两个函数都返回*this，因此它们可以被“链接”。</li><li>如果结果超过最大字符数，这两个函数都会抛出一个length_error异常。</li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sString</span><span class="params">(<span class="string">"one"</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">sString += <span class="built_in">string</span>(<span class="string">" two"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sThree</span><span class="params">(<span class="string">" three"</span>)</span></span>;</span><br><span class="line">sString.append(sThree);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one two three</span><br></pre></td></tr></table></figure><p>还有一种<strong>append()</strong>方法可以附加子字符串:</p><p><strong><code>string&amp; string::append (const string&amp; str, size_type index, size_type num)</code></strong></p><ul><li>这个函数将从str开始的num字符追加到字符串。</li><li>返回*this，这样它可以被“链接”。</li><li>如果索引超出范围，则抛出out_of_range</li><li>如果结果超过最大字符数，则抛出length_error异常。</li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sString</span><span class="params">(<span class="string">"one "</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> <span class="title">sTemp</span><span class="params">(<span class="string">"twothreefour"</span>)</span></span>;</span><br><span class="line">sString.append(sTemp, <span class="number">3</span>, <span class="number">5</span>); <span class="comment">// append substring of sTemp starting at index 3 of length 5</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one three</span><br></pre></td></tr></table></figure><p>运算符+=和append()也有<strong>处理c风格字符串</strong>的版本:</p><p><strong><code>string&amp; string::operator+= (const char* str)</code></strong></p><p><strong><code>string&amp; string::append (const char* str)</code></strong></p><ul><li><p>这两个函数都将str的字符追加到字符串中。</p></li><li><p>两个函数都返回*this，因此它们可以被“链接”。</p></li><li><p>如果结果超过最大字符数，这两个函数都会抛出一个length_error异常。</p></li><li><p>str不应该为空。</p></li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sString</span><span class="params">(<span class="string">"one"</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">sString += <span class="string">" two"</span>;</span><br><span class="line">sString.append(<span class="string">" three"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one two three</span><br></pre></td></tr></table></figure><p>下面还有很多，将只给出其声明，具体解释，请看原教程对应内容：</p><p><strong><code>string&amp; string::append (const char* str, size_type len)</code></strong></p><p><strong><code>string&amp; string::operator+= (char c)</code></strong></p><p><strong><code>void string::push_back (char c)</code></strong></p><p><strong><code>string&amp; string::append (size_type num, char c)</code></strong></p><p><strong><code>string&amp; string::append (InputIterator start, InputIterator end)</code></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/std：：string的赋值 与 交换</title>
      <link href="/archives/6b2ecf81.html"/>
      <url>/archives/6b2ecf81.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/17-5-stdstring-assignment-and-swapping/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/17-5-stdstring-assignment-and-swapping/</a></p><hr><h1 id="字符串赋值"><a href="#字符串赋值" class="headerlink" title="字符串赋值"></a>字符串赋值</h1><p><strong>给字符串赋值的最简单方法是使用重载的运算符=函数</strong>。<strong>还有一个assign()成员函数</strong>，它复制了某些功能。</p><p><strong><code>string&amp; string::operator= (const string&amp; str)</code></strong></p><p><strong><code>string&amp; string::assign (const string&amp; str)</code></strong></p><p><strong><code>string&amp; string::operator= (const char* str)</code></strong></p><p><strong><code>string&amp; string::assign (const char* str)</code></strong></p><p><strong><code>string&amp; string::operator= (char c)</code></strong></p><ul><li>这些函数将各种类型的值赋给字符串。</li><li>这些函数返回*this，因此它们可以被“链接”。</li><li>注意，<strong>不存在接受单个字符</strong>的<strong>assign()</strong>函数。</li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> sString;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Assign a string value</span></span><br><span class="line">sString = <span class="built_in">string</span>(<span class="string">"One"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> <span class="title">sTwo</span><span class="params">(<span class="string">"Two"</span>)</span></span>;</span><br><span class="line">sString.assign(sTwo);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Assign a C-style string</span></span><br><span class="line">sString = <span class="string">"Three"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">sString.assign(<span class="string">"Four"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Assign a char</span></span><br><span class="line">sString = <span class="string">'5'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Chain assignment</span></span><br><span class="line"><span class="built_in">string</span> sOther;</span><br><span class="line">sString = sOther = <span class="string">"Six"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="string">" "</span> &lt;&lt; sOther &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">One</span><br><span class="line">Two</span><br><span class="line">Three</span><br><span class="line">Four</span><br><span class="line"><span class="number">5</span></span><br><span class="line">Six Six</span><br></pre></td></tr></table></figure><h2 id="assign-成员函数也有其他一些版本"><a href="#assign-成员函数也有其他一些版本" class="headerlink" title="assign()成员函数也有其他一些版本"></a>assign()成员函数也有其他一些版本</h2><p><strong><code>string&amp; string::assign (const string&amp; str, size_type index, size_type len)</code></strong></p><ul><li><p>赋值一个str的子字符串，从index开始，长度为len</p></li><li><p>如果索引超出范围，则抛出out_of_range异常</p></li><li><p>返回*this，这样它可以被“链接”。</p></li></ul><p>如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> <span class="title">sSource</span><span class="params">(<span class="string">"abcdefg"</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span> sDest;</span><br><span class="line"> </span><br><span class="line">sDest.assign(sSource, <span class="number">2</span>, <span class="number">4</span>); <span class="comment">// assign a substring of source from index 2 of length 4</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sDest &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cdef</span><br></pre></td></tr></table></figure><p><strong><code>string&amp; string::assign (const char\* chars, size_type len)</code></strong></p><ul><li><p>从c风格的数组字符中分配len字符</p></li><li><p>如果结果超过最大字符数，则抛出length_error异常</p></li><li><p>返回*this，这样它可以被“链接”。</p></li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> sDest;</span><br><span class="line"> </span><br><span class="line">sDest.assign(<span class="string">"abcdefg"</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sDest &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcd</span><br></pre></td></tr></table></figure><p><strong>这个函数有潜在的危险，不建议使用它。</strong></p><p><strong><code>string&amp; string::assign (size_type len, char c)</code></strong></p><ul><li>使用len个字符c 来赋值</li><li>如果结果超过最大字符数，则抛出length_error异常</li><li>返回*this，这样它可以被“链接”。</li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> sDest;</span><br><span class="line"> </span><br><span class="line">sDest.assign(<span class="number">4</span>, <span class="string">'g'</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sDest &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gggg</span><br></pre></td></tr></table></figure><h1 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h1><p>如果有两个字符串，并且希望交换它们的值，那么可以使用两个名为<strong>swap()</strong>的函数。</p><p><strong><code>void string::swap (string &amp;str)</code></strong></p><p><strong><code>void swap (string &amp;str1, string &amp;str2)</code></strong></p><ul><li><p>两个函数交换两个字符串的值。<strong>成员函数</strong>交换<em>this和str，*</em>全局函数**交换str1和str2。</p></li><li><p>这些函数是有效的，应该用来代替赋值来执行字符串交换。</p></li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sStr1</span><span class="params">(<span class="string">"red"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sStr2</span><span class="params">(<span class="string">"blue"</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sStr1 &lt;&lt; <span class="string">" "</span> &lt;&lt; sStr2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">swap(sStr1, sStr2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sStr1 &lt;&lt; <span class="string">" "</span> &lt;&lt; sStr2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">sStr1.swap(sStr2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sStr1 &lt;&lt; <span class="string">" "</span> &lt;&lt; sStr2 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">red blue</span><br><span class="line">blue red</span><br><span class="line">red blue</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/std：：string的字符访问 及 转换为C风格数组</title>
      <link href="/archives/a3edb06.html"/>
      <url>/archives/a3edb06.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/17-4-stdstring-character-access-and-conversion-to-c-style-arrays/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/17-4-stdstring-character-access-and-conversion-to-c-style-arrays/</a></p><hr><h1 id="访问字符"><a href="#访问字符" class="headerlink" title="访问字符"></a>访问字符</h1><h2 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符[]"></a>重载运算符[]</h2><p>有两种几乎相同的方法来访问字符串中的字符。更容易使用和更快的版本是<strong>重载运算符[]</strong>:</p><p><strong><code>char&amp; string::operator[] (size_type nIndex)</code></strong></p><p><strong><code>const char&amp; string::operator[] (size_type nIndex) const</code></strong></p><ul><li><p>这两个函数都返回带有索引nIndex的字符</p></li><li><p>传递无效索引将导致未定义的行为</p></li><li><p>使用length()作为索引仅对const字符串有效，并返回由字符串的默认构造函数生成的值。不建议您这样做。</p></li><li><p>因为char&amp;是返回类型，所以可以使用它编辑数组中的字符</p></li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sSource&#123; <span class="string">"abcdefg"</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sSource[<span class="number">5</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">sSource[<span class="number">5</span>] = <span class="string">'X'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sSource &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f</span><br><span class="line">abcdeXg</span><br></pre></td></tr></table></figure><h2 id="非操作符版本"><a href="#非操作符版本" class="headerlink" title="非操作符版本"></a>非操作符版本</h2><p>还有一个非操作符版本。<strong>这个版本比较慢</strong>，因为它使用异常来检查nIndex是否有效。</p><p><strong>如果你不确定nIndex是否有效，你应该使用这个版本来访问数组</strong>:</p><p><strong><code>char&amp; string::at (size_type nIndex)</code></strong></p><p><strong><code>const char&amp; string::at (size_type nIndex) const</code></strong></p><ul><li><p>这两个函数都返回带有索引nIndex的字符</p></li><li><p>传递无效索引将导致out_of_range异常</p></li><li><p>因为char&amp;是返回类型，所以可以使用它编辑数组中的字符</p></li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sSource&#123; <span class="string">"abcdefg"</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sSource.at(<span class="number">5</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">sSource.at(<span class="number">5</span>) = <span class="string">'X'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sSource &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><h1 id="转换为c风格的数组"><a href="#转换为c风格的数组" class="headerlink" title="转换为c风格的数组"></a>转换为c风格的数组</h1><p>许多函数(包括所有C函数)都希望将字符串格式化为C风格的字符串，而不是std::string。由于这个原因，std::string提供了3种不同的方法来将std::string转换成c风格的字符串。</p><ul><li><p><strong><code>const char* string::c_str () const</code></strong> ⭐【推荐】</p><ul><li>以const c风格的字符串返回字符串的内容</li><li>将追加一个空终止符</li><li>c风格的字符串属于std::string，不应该被删除</li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sSource&#123; <span class="string">"abcdefg"</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">strlen</span>(sSource.c_str());</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong><code>const char* string::data () const</code></strong></p><ul><li>以const c风格的字符串返回字符串的内容</li><li>将追加一个空终止符。这个函数执行的操作与c_str()相同</li><li>c风格的字符串属于std::string，不应该被删除</li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sSource&#123; <span class="string">"abcdefg"</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *szString&#123; <span class="string">"abcdefg"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个c样式字符串的前n个字符，如果它们相等，则返回0</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">memcmp</span>(sSource.data(), szString, sSource.length()) == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The strings are equal"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The strings are not equal"</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The strings are equal</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong><code>size_type string::copy(char *szBuf, size_type nLength) const</code></strong></p></li><li><p><strong><code>size_type string::copy(char *szBuf, size_type nLength, size_type nIndex) const</code></strong></p><ul><li>这两种风格都将字符串的最多nLength字符复制到szBuf，从字符nIndex开始</li><li>返回复制的字符数</li><li><strong>没</strong>有空值被追加。由调用者负责确保szBuf被初始化为NULL或使用返回的长度终止字符串</li><li>调用者负责不溢出szBuf</li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sSource&#123; <span class="string">"sphinx of black quartz, judge my vow"</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span> szBuf[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> nLength&#123; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(sSource.copy(szBuf, <span class="number">5</span>, <span class="number">10</span>)) &#125;;</span><br><span class="line">szBuf[nLength] = <span class="string">'\0'</span>;  <span class="comment">// 确保终止缓冲区中的字符串</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; szBuf &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">black</span><br></pre></td></tr></table></figure></li></ul><p><strong>除非您需要充分利用效率，否则c_str()是这三个函数中最简单、最安全的一个。</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/std：：string长度和容量</title>
      <link href="/archives/cc14dac2.html"/>
      <url>/archives/cc14dac2.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/17-3-stdstring-length-and-capacity/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/17-3-stdstring-length-and-capacity/</a></p><hr><p>一旦创建了字符串，了解它们的长度通常是很有用的。这就是长度和容量操作发挥作用的地方。</p><p>我们还将讨论将std::string转换回c风格字符串的各种方法，这样您就可以将它们用于需要char*类型的字符串的函数。</p><h1 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h1><p>字符串的长度非常简单——<strong>它是字符串中的字符数</strong>。确定字符串长度有两个相同的函数:</p><ul><li><p><strong><code>size_type string::length() const</code></strong></p></li><li><p><strong><code>size_type string::size() const</code></strong></p></li></ul><p>这两个函数都返回字符串中的当前字符数(<strong>不包括null终止符</strong>)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sSource</span><span class="params">(<span class="string">"012345678"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sSource.length() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="确定字符串是否有字符"><a href="#确定字符串是否有字符" class="headerlink" title="确定字符串是否有字符"></a>确定字符串是否有字符</h2><p>虽然可以使用length()来确定一个字符串是否有字符，<strong>但是使用empty()函数更有效</strong>:</p><p><strong><code>bool string::empty() const</code></strong></p><ul><li>如果字符串没有字符，则返回true，否则返回false。</li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sString1</span><span class="params">(<span class="string">"Not Empty"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (sString1.empty() ? <span class="string">"true"</span> : <span class="string">"false"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">string</span> sString2; <span class="comment">// empty</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (sString2.empty() ? <span class="string">"true"</span> : <span class="string">"false"</span>)  &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h1 id="字符串可容纳最大的容量"><a href="#字符串可容纳最大的容量" class="headerlink" title="字符串可容纳最大的容量"></a>字符串可容纳最大的容量</h1><p>还有一个与大小相关的函数，您可能永远不会用到，但是为了完整起见，我们将在这里包括它:</p><p><strong><code>size_type string::max_size() cons</code>t</strong></p><ul><li><p><strong>返回字符串允许的最大字符数</strong>。</p></li><li><p>这个值会随着操作系统和系统架构的不同而变化。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sString</span><span class="params">(<span class="string">"MyString"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString.max_size() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;教程中的结果</span><br><span class="line">4294967294</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在我自己电脑中的结果</span><br><span class="line">2147483647</span><br></pre></td></tr></table></figure><h1 id="字符串的容量-capacity"><a href="#字符串的容量-capacity" class="headerlink" title="字符串的容量( capacity)"></a>字符串的容量( capacity)</h1><p>字符串的容量<strong>反映了字符串为保存其内容而分配的内存大小。</strong></p><ul><li>此值以字符串字符为度量，不包括NULL终止符。（例如，一个容量为8的字符串可以容纳8个字符。）</li></ul><p><strong><code>size_type string::capacity() const</code></strong></p><ul><li>返回一个字符串在不重新分配的情况下可以容纳的字符数。</li></ul><p>如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sString</span><span class="params">(<span class="string">"01234567"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Length: "</span> &lt;&lt; sString.length() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Capacity: "</span> &lt;&lt; sString.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Length: 8</span><br><span class="line">Capacity: 15</span><br></pre></td></tr></table></figure><p>注意，容量大于字符串的长度!虽然我们的字符串长度为8，但实际上该字符串分配了足够15个字符的内存!为什么要这样做?</p><h2 id="字符串容量-capacity-大于等于-字符串长度"><a href="#字符串容量-capacity-大于等于-字符串长度" class="headerlink" title="字符串容量( capacity) 大于等于 字符串长度"></a>字符串容量( capacity) 大于等于 字符串长度</h2><p>注意，容量大于字符串的长度!虽然我们的字符串长度为8，但实际上该字符串分配了足够15个字符的内存!为什么要这样做?</p><ul><li>如果用户想在一个字符串中放入比该字符串所能容纳的更多的字符，则必须将该字符串重新分配到更大的容量中。例如，如果一个字符串的长度和容量都为8，那么向该字符串添加任何字符都将强制重新分配。通过使容量大于实际的字符串，<strong>这就为用户提供了一些缓冲空间，以便在需要进行重新分配之前扩展字符串。</strong></li></ul><p>事实证明，重新分配有以下几个不利原因：</p><ul><li><p>首先，<strong>重新分配字符串相对比较昂贵。</strong></p><ul><li><p>首先，必须分配新内存。</p></li><li><p>然后必须将字符串中的每个字符复制到新内存中。如果字符串很大，这可能需要很长时间。</p></li><li><p>最后，旧的内存空间必须释放。如果您正在进行许多重新分配，这个过程会显著降低程序的运行速度。</p></li></ul></li><li><p>其次，每当重新分配一个字符串时，该字符串的内容就会<strong>更改为一个新的内存地址</strong>。<strong>这意味着对字符串的所有引用、指针和迭代器都是无效的!</strong></p></li></ul><h2 id="设置字符串的容量的下限"><a href="#设置字符串的容量的下限" class="headerlink" title="设置字符串的容量的下限"></a>设置字符串的容量的下限</h2><p><strong><code>void string::reserve(size_type unSize)</code></strong></p><p><strong><code>void string::reserve()</code></strong></p><ul><li>第一个函数特点是<strong>将字符串的容量<u>至少</u>设置为unSize(可以更大</strong>)。<u>注意，这可能需要重新分配。</u></li><li>当调用第一个函数时，<strong>但大小小于当前容量，则函数将尝试收缩容量以匹配长度</strong>。这是一个非绑定请求。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sString</span><span class="params">(<span class="string">"01234567"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Length: "</span> &lt;&lt; sString.length() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Capacity: "</span> &lt;&lt; sString.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">sString.reserve(<span class="number">200</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Length: "</span> &lt;&lt; sString.length() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Capacity: "</span> &lt;&lt; sString.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">sString.reserve();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Length: "</span> &lt;&lt; sString.length() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Capacity: "</span> &lt;&lt; sString.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Length: <span class="number">8</span></span><br><span class="line">Capacity: <span class="number">15</span></span><br><span class="line">Length: <span class="number">8</span></span><br><span class="line">Capacity: <span class="number">207</span></span><br><span class="line">Length: <span class="number">8</span></span><br><span class="line">Capacity: <span class="number">207</span></span><br></pre></td></tr></table></figure><p>这个例子展示了两件有趣的事情。</p><ul><li>首先，虽然我们要求200的容量，但实际上我们得到了207的容量。容量总是保证至少与您的请求一样大，但也可能更大。</li><li>然后，我们请求更改容量以适应字符串<strong>。这个请求被忽略了，因为容量没有改变。</strong></li></ul><h2 id="向字符串添加一个字符"><a href="#向字符串添加一个字符" class="headerlink" title="向字符串添加一个字符"></a>向字符串添加一个字符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sString</span><span class="params">(<span class="string">"0123456789abcde"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Length: "</span> &lt;&lt; sString.length() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Capacity: "</span> &lt;&lt; sString.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Now add a new character</span></span><br><span class="line">sString += <span class="string">"f"</span>; ⭐⭐⭐</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Length: "</span> &lt;&lt; sString.length() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Capacity: "</span> &lt;&lt; sString.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Length: 15</span><br><span class="line">Capacity: 15</span><br><span class="line">Length: 16</span><br><span class="line">Capacity: 31</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/std：：string构造和销毁</title>
      <link href="/archives/550c4d87.html"/>
      <url>/archives/550c4d87.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/17-2-stdstring-construction-and-destruction/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/17-2-stdstring-construction-and-destruction/</a></p><hr><p>在这节课中，我们将学习如何构造std::string的对象，以及如何从数字创建字符串，反之亦然。</p><h1 id="String-的构造"><a href="#String-的构造" class="headerlink" title="String 的构造"></a><strong>String</strong> 的构造</h1><p>string类有许多构造函数，可用于创建字符串。我们将在这里逐一介绍。</p><p>注意：<code>string::size_type</code>解析为<code>size_t</code>，它与<code>sizeof</code>操作符返回的无符号整数类型 相同。它的实际大小因环境而异。出于本教程的目的，将它想象成一个无符号整型。</p><h2 id="string-string"><a href="#string-string" class="headerlink" title="string::string()"></a>string::string()</h2><p>这是<strong>默认的构造函数</strong>。它创建一个<strong>空字符串</strong>。</p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sSource;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sSource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"> <span class="comment">//什么都没有，因为这是空字符串</span></span><br></pre></td></tr></table></figure><h2 id="string-string-const-string-amp-strString"><a href="#string-string-const-string-amp-strString" class="headerlink" title="string::string(const string&amp; strString)"></a>string::string(const string&amp; strString)</h2><p>这是<strong>复制构造函数</strong>。这个构造函数<strong>创建一个新的字符串作为strString的副本</strong>。</p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sSource&#123; <span class="string">"my string"</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sOutput&#123; sSource &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sOutput;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my string</span><br></pre></td></tr></table></figure><h2 id="string-string-const-string-amp-strString-size-type-unIndex-size-type-unLength"><a href="#string-string-const-string-amp-strString-size-type-unIndex-size-type-unLength" class="headerlink" title="string::string(const string&amp; strString, size_type unIndex, size_type unLength)"></a>string::string(const string&amp; strString, size_type unIndex, size_type unLength)</h2><p><strong><code>string::string(const string&amp; strString, size_type unIndex)</code></strong></p><p><strong><code>string::string(const string&amp; strString, size_type unIndex, size_type unLength)</code></strong></p><ul><li><p>此构造函数创建一个新字符串，该字符串从索引 unIndex开始，最多包含来自strString的 unLength长度字符。</p><blockquote><p>如果遇到NULL，即使没有达到unLength，字符串复制也将结束。</p></blockquote></li><li><p><u>如果不提供unLength</u>，则使用从unIndex开始的所有字符。</p></li><li><p>如果unIndex大于字符串的大小，则会抛出out_of_range异常。</p></li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sSource&#123; <span class="string">"my string"</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sOutput&#123; sSource, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sOutput&lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">sOutput2</span><span class="params">(sSource, <span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sOutput2 &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string</span><br><span class="line">stri</span><br></pre></td></tr></table></figure><h2 id="string-string-const-char-szCString"><a href="#string-string-const-char-szCString" class="headerlink" title="string::string(const char *szCString)"></a>string::string(const char *szCString)</h2><ul><li><p>这个构造函数从c风格的字符串szCString创建一个新字符串，直到但不包括NULL终止符。</p></li><li><p>如果结果大小超过最大字符串长度，将抛出length_error异常。</p></li><li><p><strong>警告:szCString不能为空。</strong></p></li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *szSource&#123; <span class="string">"my string"</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sOutput&#123; szSource &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sOutput &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my string</span><br></pre></td></tr></table></figure><h2 id="string-string-const-char-szCString-size-type-unLength"><a href="#string-string-const-char-szCString-size-type-unLength" class="headerlink" title="string::string(const char *szCString, size_type unLength)"></a>string::string(const char *szCString, size_type unLength)</h2><ul><li><p>这个构造函数从c样式的字符串szCString的 第一个字符开始 到 第 unLength个字符(包含它) 结束 创建一个新字符串。</p></li><li><p>如果结果大小超过最大字符串长度，将抛出length_error异常。</p></li><li><p>警告：<strong>仅对于此函数</strong>，在szCString中null不被视为字符串结束字符! 这意味着如果字符串的长度太大，是可以读取字符串的末尾的字符的。 注意不要溢出你的字符串缓冲区!</p></li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *szSource&#123; <span class="string">"my string"</span> &#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">sOutput</span><span class="params">(szSource, <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sOutput &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my s</span><br></pre></td></tr></table></figure><h2 id="string-string-size-type-nNum-char-chChar"><a href="#string-string-size-type-nNum-char-chChar" class="headerlink" title="string::string(size_type nNum, char chChar)"></a>string::string(size_type nNum, char chChar)</h2><ul><li><p>这个构造函数创建一个由nNum个 chChar字符 初始化的新字符串。</p></li><li><p>如果结果大小超过最大字符串长度，将抛出length_error异常。</p></li></ul><p>如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">sOutput</span><span class="params">(<span class="number">4</span>, <span class="string">'Q'</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sOutput &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QQQQ</span><br></pre></td></tr></table></figure><h2 id="template-string-string-InputIterator-itBeg-InputIterator-itEnd"><a href="#template-string-string-InputIterator-itBeg-InputIterator-itEnd" class="headerlink" title="template string::string(InputIterator itBeg, InputIterator itEnd)"></a>template string::string(InputIterator itBeg, InputIterator itEnd)</h2><ul><li><p>这个构造函数创建由一个范围为 [itBeg, itEnd]字符 初始化的新字符串。</p></li><li><p>如果结果大小超过最大字符串长度，将抛出length_error异常。</p></li></ul><p>这个没有示例代码。它很模糊，你可能永远不会用到它。</p><h1 id="string-的销毁"><a href="#string-的销毁" class="headerlink" title="string 的销毁"></a>string 的销毁</h1><p><strong><code>string::~string()</code></strong></p><p>字符串的销毁：</p><ul><li>这是破坏者。它销毁字符串并释放内存。</li></ul><p>这里也没有示例代码，因为析构函数不是显式调用的。</p><h1 id="由数字构造字符串"><a href="#由数字构造字符串" class="headerlink" title="由数字构造字符串"></a>由数字构造字符串</h1><p>在std::string类中一个值得注意的遗漏是<strong>缺乏从数字创建字符串的能力</strong>。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sFour&#123; <span class="number">4</span> &#125;;</span><br></pre></td></tr></table></figure><p>产生以下错误:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:vcprojectstest2test2test.cpp(10) : error C2664: &#39;std::basic_string&lt;_Elem,_Traits,_Ax&gt;::basic_string(std::basic_string&lt;_Elem,_Traits,_Ax&gt;::_Has_debug_it)&#39; : cannot convert parameter 1 from &#39;int&#39; to &#39;std::basic_string&lt;_Elem,_Traits,_Ax&gt;::_Has_debug_it&#39;</span><br></pre></td></tr></table></figure><p>还记得我说过字符串类会产生可怕的错误吗? 这里的相关信息是:</p><p><code>不能将参数1从&#39;int&#39;转换为&#39;std::basic_string</code></p><p>换句话说，它试图将int转换成字符串，但是失败了。</p><p><strong>将数字转换为字符串的最简单方法是使用std::ostringstream类。</strong></p><p>std::ostringstream（头文件<code>&lt;sstream&gt;</code>中）已经设置为接受来自各种来源的输入，包括字符、数字、字符串等…….。它同样能够<strong>输出字符串（可以通过提取操作符&gt;&gt;，也可以通过str()函数）</strong>。</p><blockquote><p>有关std::ostringstream的更多信息，请看<a href="https://www.learncpp.com/cpp-tutorial/184-stream-classes-for-strings/" target="_blank" rel="noopener">18.4 – Stream classes for strings</a>.</p></blockquote><p>这里有一个简单的解决方案来创建<code>std::string</code>从各种类型的输入:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">ToString</span><span class="params">(T tX)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">ostringstream</span> oStream;</span><br><span class="line">    oStream &lt;&lt; tX;</span><br><span class="line">    <span class="keyword">return</span> oStream.str();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> sFour&#123; ToString(<span class="number">4</span>) &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> sSixPointSeven&#123; ToString(<span class="number">6.7</span>) &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> sA&#123; ToString(<span class="string">'A'</span>) &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sFour &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sSixPointSeven &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sA &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">6.7</span><br><span class="line">A</span><br></pre></td></tr></table></figure><p>请注意，此解决方案省略了任何错误检查。将tX插入oStream可能会失败。一个适当的响应是在转换失败时抛出异常。</p><h1 id="将字符串转换为数字"><a href="#将字符串转换为数字" class="headerlink" title="将字符串转换为数字"></a>将字符串转换为数字</h1><p>类似于上面的解决方案:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">FromString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; sString, T &amp;tX)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">istringstream</span> <span class="title">iStream</span><span class="params">(sString)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> !(iStream &gt;&gt; tX).fail(); <span class="comment">// extract value into tX, return success or not</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> dX;</span><br><span class="line">    <span class="keyword">if</span> (FromString(<span class="string">"3.4"</span>, dX))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dX &lt;&lt; <span class="string">'\n'</span>; </span><br><span class="line">    <span class="keyword">if</span> (FromString(<span class="string">"ABC"</span>, dX))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dX &lt;&lt; <span class="string">'\n'</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.4</span><br></pre></td></tr></table></figure><p>注意，第二次转换失败并返回false。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/std：：string and std：：wstring</title>
      <link href="/archives/67452a19.html"/>
      <url>/archives/67452a19.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/17-1-stdstring-and-stdwstring/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/17-1-stdstring-and-stdwstring/</a></p><hr><p>标准库包含许多有用的类——但最有用的可能是<strong>std::string</strong>。</p><p>std::string(和std::wstring)是一个字符串类，它提供了许多操作来分配、比较和修改字符串。在本章中，我们将深入研究这些字符串类。</p><blockquote><p>注意:</p><p><strong>C-style字符串将被称为“C-style string”</strong>，<strong>而std::string(和std::wstring)将被简单地称为“string”。</strong></p></blockquote><h1 id="字符串类-字符串类的动机-的动机"><a href="#字符串类-字符串类的动机-的动机" class="headerlink" title="字符串类(字符串类的动机)的动机"></a>字符串类(字符串类的动机)的动机</h1><h2 id="C风格字符串的缺点"><a href="#C风格字符串的缺点" class="headerlink" title="C风格字符串的缺点"></a>C风格字符串的缺点</h2><p>在 <a href="http://www.learncpp.com/cpp-tutorial/66-c-style-strings/" target="_blank" rel="noopener">C-style strings</a>中，我们介绍了<strong>c风格</strong>的字符串，它使用字符<strong>数组</strong>来存储字符串。</p><p>如果您尝试过使用c风格的字符串做任何事情，那么您会很快得出这样的结论:</p><ul><li>使用c风格的字符串很麻烦，很容易出错，而且很难调试。</li></ul><p>c风格的字符串有很多<strong>缺点</strong>，主要是围绕这样一个事实:</p><ul><li><p><strong>您必须自己完成所有的内存管理</strong>。</p><blockquote><p>例如，如果您想要分配字符串“hello!进入一个缓冲区，你必须先动态分配一个缓冲区的正确长度:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *strHello = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">7</span>];</span><br><span class="line"><span class="comment">//不要忘记说明null终止符的额外字符!</span></span><br></pre></td></tr></table></figure><p>然后你必须实际 复制值:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(strHello, <span class="string">"hello!"</span>);</span><br><span class="line"> &gt;<span class="comment">//希望你使你的缓冲区足够大，所以没有缓冲区溢出!</span></span><br></pre></td></tr></table></figure><p>当然，因为字符串是动态分配的，你必须记住，当你处理完它时，要正确地释放它:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span>[] strHello;</span><br><span class="line">  &gt;<span class="comment">//不要忘记使用数组删除代替普通的删除!</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>此外，C提供的用于处理数字的许多直观操作符(如赋值和比较)根本不适用于C风格的字符串。</strong>有时这些方法看似有效，但实际上产生了不正确的结果。例如：</p><ul><li>使用==比较两个c风格的字符串实际上会进行指针比较，而不是字符串比较。</li><li>使用operator=将一个c风格的字符串赋值给另一个c风格的字符串，乍一看似乎可行，但实际上是在做指针复制(浅复制)，这通常不是您想要的。</li></ul><p>这类事情会导致程序崩溃，很难找到和调试!</p></li></ul><ul><li>最后，处理c风格的字符串需要记住许多关于什么是安全/不安全的挑剔规则，记住一堆具有有趣名称的函数，如strcat()和strcmp()，而不是使用直观的操作符，并执行大量手工内存管理。</li></ul><p>幸运的是，c++和标准库提供了更好的处理字符串的方法: <strong>std::string和std::wstring类。</strong></p><p>通过使用c++概念，例如构造函数、析构函数和操作符重载，std::string允许您以一种直观和安全的方式创建和操作字符串! <u>不再需要内存管理，不再需要奇怪的函数名，灾难发生的可能性也大大降低。</u></p><h2 id="std-string概述"><a href="#std-string概述" class="headerlink" title="std::string概述"></a>std::string概述</h2><p>位于 <strong>头文件<code>&lt;string&gt;</code>中</strong></p><p>实际上在字符串头中有3个不同的字符串类。</p><ul><li><p>第<strong>一</strong>个模板基类名为basic_string&lt;&gt;:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">charT</span>, <span class="title">class</span> <span class="title">traits</span> = <span class="title">char_traits</span>&lt;charT&gt;, <span class="title">class</span> <span class="title">Allocator</span> = <span class="title">allocator</span>&lt;charT&gt; &gt;</span></span><br><span class="line"><span class="class">        <span class="title">class</span> <span class="title">basic_string</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您不会直接使用这个类，所以暂时不要担心什么trait或 Allocator。在几乎所有可能的情况下，默认值就足够了。</p></li></ul><ul><li><p>标准库提供了<strong>两</strong>种basic_string&lt;&gt;:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> basic_string&lt;<span class="keyword">char</span>&gt; <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">typedef</span> basic_string&lt;<span class="keyword">wchar_t</span>&gt; <span class="built_in">wstring</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是您将实际使用的两个类。</p><ul><li><p>std::string用于 标准ascii和utf-8字 符串。</p></li><li><p>std::wstring用于 宽字符/unicode (utf-16) 字符串。</p><blockquote><p>没有用于utf-32字符串的内置类(尽管如果需要的话，您应该能够从basic_string&lt;&gt;扩展自己的类)。</p></blockquote></li></ul></li></ul><p>尽管您将直接使用std::string和std::wstring，但所有字符串功能都是在basic_string&lt;&gt;类中实现的。通过模板化，String和wstring能够直接访问该功能。因此，本文提供的所有函数都可以用于string和wstring。</p><p>这里是string类中所有函数的列表。这些函数中的大多数具有多种风格，可以处理不同类型的输入，我们将在接下来的课程中更深入地介绍这些内容。</p><table><thead><tr><th align="left">Function</th><th align="left">Effect</th></tr></thead><tbody><tr><td align="left"><strong>Creation and destruction</strong></td><td align="left"></td></tr><tr><td align="left"><a href="http://www.learncpp.com/cpp-tutorial/17-2-ststring-construction-and-destruction/" target="_blank" rel="noopener">(constructor)</a> <a href="http://www.learncpp.com/cpp-tutorial/17-2-ststring-construction-and-destruction/" target="_blank" rel="noopener">(destructor)</a></td><td align="left">Create or copy a string Destroy a string</td></tr><tr><td align="left"><strong>Size and capacity</strong></td><td align="left"></td></tr><tr><td align="left"><a href="http://www.learncpp.com/cpp-tutorial/17-3-stdstring-length-and-capacity/" target="_blank" rel="noopener">capacity()</a> <a href="http://www.learncpp.com/cpp-tutorial/17-3-stdstring-length-and-capacity/" target="_blank" rel="noopener">empty()</a> <a href="http://www.learncpp.com/cpp-tutorial/17-3-stdstring-length-and-capacity/" target="_blank" rel="noopener">length(), size()</a> <a href="http://www.learncpp.com/cpp-tutorial/17-3-stdstring-length-and-capacity/" target="_blank" rel="noopener">max_size()</a> <a href="http://www.learncpp.com/cpp-tutorial/17-3-stdstring-length-and-capacity/" target="_blank" rel="noopener">reserve()</a></td><td align="left">Returns the number of characters that can be held without reallocation Returns a boolean indicating whether the string is empty Returns the number of characters in string Returns the maximum string size that can be allocated Expand or shrink the capacity of the string</td></tr><tr><td align="left"><strong>Element access</strong></td><td align="left"></td></tr><tr><td align="left"><a href="http://www.learncpp.com/cpp-tutorial/17-4-stdstring-character-access-and-conversion-to-c-style-arrays/" target="_blank" rel="noopener">[], at()</a></td><td align="left">Accesses the character at a particular index</td></tr><tr><td align="left"><strong>Modification</strong></td><td align="left"></td></tr><tr><td align="left"><a href="http://www.learncpp.com/cpp-programming/17-5-stdstring-assignment-and-swapping/" target="_blank" rel="noopener">=, assign()</a> <a href="http://www.learncpp.com/uncategorized/17-6-stdstring-appending/" target="_blank" rel="noopener">+=, append(), push_back()</a> <a href="http://www.learncpp.com/cpp-tutorial/17-7-stdstring-inserting/" target="_blank" rel="noopener">insert()</a> clear() erase() replace() resize() <a href="http://www.learncpp.com/cpp-programming/17-5-stdstring-assignment-and-swapping/" target="_blank" rel="noopener">swap()</a></td><td align="left">Assigns a new value to the string Concatenates characters to end of the string Inserts characters at an arbitrary index in string Delete all characters in the string Erase characters at an arbitrary index in string Replace characters at an arbitrary index with other characters Expand or shrink the string (truncates or adds characters at end of string) Swaps the value of two strings</td></tr><tr><td align="left"><strong>Input and Output</strong></td><td align="left"></td></tr><tr><td align="left">&gt;&gt;, getline() &lt;&lt; <a href="http://www.learncpp.com/cpp-tutorial/17-4-stdstring-character-access-and-conversion-to-c-style-arrays/" target="_blank" rel="noopener">c_str()</a> <a href="http://www.learncpp.com/cpp-tutorial/17-4-stdstring-character-access-and-conversion-to-c-style-arrays/" target="_blank" rel="noopener">copy()</a> <a href="http://www.learncpp.com/cpp-tutorial/17-4-stdstring-character-access-and-conversion-to-c-style-arrays/" target="_blank" rel="noopener">data()</a></td><td align="left">Reads values from the input stream into the string Writes string value to the output stream Returns the contents of the string as a NULL-terminated C-style string Copies contents (not NULL-terminated) to a character array Returns the contents of the string as a non-NULL-terminated character array</td></tr><tr><td align="left"><strong>String comparison</strong></td><td align="left"></td></tr><tr><td align="left">==, != &lt;, &lt;=, &gt; &gt;= compare()</td><td align="left">Compares whether two strings are equal/unequal (returns bool) Compares whether two strings are less than / greater than each other (returns bool) Compares whether two strings are equal/unequal (returns -1, 0, or 1)</td></tr><tr><td align="left"><strong>Substrings and concatenation</strong></td><td align="left"></td></tr><tr><td align="left">+ substr()</td><td align="left">Concatenates two strings Returns a substring</td></tr><tr><td align="left"><strong>Searching</strong></td><td align="left"></td></tr><tr><td align="left">find() find_first_of() find_first_not_of() find_last_of() find_last_not_of() rfind()</td><td align="left">Find index of first character/substring Find index of first character from a set of characters Find index of first character not from a set of characters Find index of last character from a set of characters Find index of last character not from a set of characters Find index of last character/substring</td></tr><tr><td align="left"><strong>Iterator and allocator support</strong></td><td align="left"></td></tr><tr><td align="left">begin(), end() get_allocator() rbegin(), rend()</td><td align="left">Forward-direction iterator support for beginning/end of string Returns the allocator Reverse-direction iterator support for beginning/end of string</td></tr></tbody></table><p>虽然标准的库字符串类提供了很多功能，但有几个明显的遗漏:</p><ul><li>正则表达式</li><li>用于从数字创建字符串的构造函数</li><li>大写/大写/小写函数</li><li>不区分大小写的比较</li><li>标记化/将字符串拆分为数组</li><li>获取字符串的左或右部分的简单函数</li><li>空白修剪</li><li>格式化一个字符串 sprintf 样式</li><li>由utf-8转换为utf-16或反之亦然</li></ul><p>对于大多数情况，您必须编写自己的函数，<strong>或者将字符串转换为C样式的字符串(使用c_str())，并使用提供此功能的C函数。</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/algorithm</title>
      <link href="/archives/38f02bc7.html"/>
      <url>/archives/38f02bc7.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/16-4-stl-algorithms-overview/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/16-4-stl-algorithms-overview/</a></p><hr><p><strong>头文件：<code>algorithm</code></strong></p><p>除了容器类和迭代器之外，STL还提供了一些用于处理容器类元素的通用<strong>算法</strong>。它们允许您执行诸如搜索、排序、插入、重新排序、删除和复制容器类的元素等操作。</p><p>注意，<strong>算法是作为使用迭代器操作的函数来实现的</strong>。这意味着每个算法只需要实现一次，它通常会自动为所有提供一组迭代器的容器(包括您的自定义容器类)工作。</p><p>虽然这是非常强大的，可以导致编写复杂代码的能力非常快，它也有一些缺点：</p><ul><li><strong>某些算法和容器类型的组合可能不起作用，可能导致无限循环，或者可能起作用，但性能非常差。因此，使用这些在你的风险。</strong></li></ul><p>STL提供了相当多的算法，在这里，我们只讨论一些更常见、更容易使用的方法。其余的(和完整的细节)将保存在关于STL算法的一章中。</p><h1 id="min-element-与-max-element"><a href="#min-element-与-max-element" class="headerlink" title="min_element 与 max_element"></a>min_element 与 max_element</h1><p><code>std::min_element</code>和<code>std::max_element</code>算法查找容器类中的最小和最大元素。</p><p><code>std::iota</code>生成一系列连续的值。在头文件：<code>&lt;numeric&gt;</code>中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // ⭐std::min_element and std::max_element</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt; // std::iota</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">li</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 用从0开始的数字 填充li。</span></span><br><span class="line">    <span class="built_in">std</span>::iota(li.<span class="built_in">begin</span>(), li.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *<span class="built_in">std</span>::min_element(li.<span class="built_in">begin</span>(), li.<span class="built_in">end</span>()) &lt;&lt; <span class="string">' '</span></span><br><span class="line">              &lt;&lt; *<span class="built_in">std</span>::max_element(li.<span class="built_in">begin</span>(), li.<span class="built_in">end</span>()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果：*/</span></span><br><span class="line"><span class="number">0</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/STL迭代器</title>
      <link href="/archives/34a9aaba.html"/>
      <url>/archives/34a9aaba.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/16-3-stl-iterators-overview/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/16-3-stl-iterators-overview/</a></p><hr><p><strong>Iterator(迭代器)</strong>是一个<strong>对象</strong>，<strong>它可以遍历(迭代)一个容器类，而用户不需要知道容器是如何实现的。</strong></p><blockquote><p>对于许多类(特别是列表和关联类)，迭代器是访问这些类元素的主要方式。</p></blockquote><ul><li><p>操作符<code>*</code>：\对迭代器的解引用将返回迭代器当前指向的元素。</p></li><li><p>操作符<code>++</code>：将迭代器移动到容器中的下一个元素。（大多数迭代器还提供运算符——移动到前面的元素。）</p></li><li><p>操作符<code>==</code>与<code>!=</code>：确定两个迭代器是否指向同一个元素的基本比较操作符。</p><blockquote><p>要比较两个迭代器所指向的值，首先取消对迭代器的引用，然后使用比较操作符。</p></blockquote></li><li><p>操作符<code>=</code>：将迭代器分配到一个<strong>新位置</strong>(通常是容器元素的开始或结束位置)。</p><blockquote><p>要分配迭代器所指向的元素的值，首先对迭代器解引用，然后使用赋值操作符(<code>=</code>)。</p></blockquote></li></ul><p>每个容器包含四个基本的成员函数，用于<strong>操作符<code>=</code></strong>:</p><ul><li><strong><code>begin()</code></strong>：返回一个迭代器，<strong>表示容器中元素的开头</strong>。</li><li><strong><code>end()</code></strong>：返回一个迭代器，<strong>该迭代器表示元素的末尾</strong>。</li><li><strong><code>cbegin()</code></strong>：返回一个const(只读)迭代器，表示容器中元素的开头。</li><li><strong><code>cend()</code></strong>：返回一个const(只读)迭代器，表示元素的末尾。</li></ul><p>最后，所有容器都提供(至少)两种迭代器:</p><ul><li><strong><code>container::iterator</code></strong>：提供了一个读/写迭代器</li><li><strong><code>container::const_iterator</code></strong>：提供了一个只读迭代器</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>遍历一个 <strong>vector</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vect;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count &lt; <span class="number">6</span>; ++count)</span><br><span class="line">        vect.push_back(count);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it; <span class="comment">// declare a read-only iterator</span></span><br><span class="line">    it = vect.cbegin(); <span class="comment">// assign it to the start of the vector</span></span><br><span class="line">    <span class="keyword">while</span> (it != vect.cend()) <span class="comment">// while it hasn't reach the end</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>; <span class="comment">// print the value of the element it points to</span></span><br><span class="line">        ++it; <span class="comment">// and iterate to the next element</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历<strong>list(列表)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; li;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count &lt; <span class="number">6</span>; ++count)</span><br><span class="line">        li.push_back(count);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it; <span class="comment">// declare an iterator</span></span><br><span class="line">    it = li.cbegin(); <span class="comment">// assign it to the start of the list</span></span><br><span class="line">    <span class="keyword">while</span> (it != li.cend()) <span class="comment">// while it hasn't reach the end</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>; <span class="comment">// print the value of the element it points to</span></span><br><span class="line">        ++it; <span class="comment">// and iterate to the next element</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，代码几乎与向量的情况相同，尽管向量和列表的内部实现几乎完全不同!</p><p>遍历一个<strong>set(集合)</strong></p><p>在下面的例子中，我们将从6个数字创建一个集合，并使用迭代器来打印集合中的值:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; myset;</span><br><span class="line">    myset.insert(<span class="number">7</span>);</span><br><span class="line">    myset.insert(<span class="number">2</span>);</span><br><span class="line">    myset.insert(<span class="number">-6</span>);</span><br><span class="line">    myset.insert(<span class="number">8</span>);</span><br><span class="line">    myset.insert(<span class="number">1</span>);</span><br><span class="line">    myset.insert(<span class="number">-4</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it; <span class="comment">// declare an iterator</span></span><br><span class="line">    it = myset.cbegin(); <span class="comment">// assign it to the start of the set</span></span><br><span class="line">    <span class="keyword">while</span> (it != myset.cend()) <span class="comment">// while it hasn't reach the end</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>; <span class="comment">// print the value of the element it points to</span></span><br><span class="line">        ++it; <span class="comment">// and iterate to the next element</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，尽管填充集合的方式与填充 vector 和 list的方式不同，但是用于迭代集合元素的代码在本质上是相同的。</p><p>遍历<strong>map(映射)</strong></p><p>这个有点复杂。Maps and multimaps 取元素对(定义为std::pair)。我们使用<strong><code>make_pair()</code>辅助函数</strong>来轻松地创建对。*<em>std::pair *</em>允许通过第一个和第二个成员访问pair的元素。</p><p>在我们的map中，我们使用first作为键，second作为值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; mymap;</span><br><span class="line">mymap.insert(<span class="built_in">std</span>::make_pair(<span class="number">4</span>, <span class="string">"apple"</span>));</span><br><span class="line">mymap.insert(<span class="built_in">std</span>::make_pair(<span class="number">2</span>, <span class="string">"orange"</span>));</span><br><span class="line">mymap.insert(<span class="built_in">std</span>::make_pair(<span class="number">1</span>, <span class="string">"banana"</span>));</span><br><span class="line">mymap.insert(<span class="built_in">std</span>::make_pair(<span class="number">3</span>, <span class="string">"grapes"</span>));</span><br><span class="line">mymap.insert(<span class="built_in">std</span>::make_pair(<span class="number">6</span>, <span class="string">"mango"</span>));</span><br><span class="line">mymap.insert(<span class="built_in">std</span>::make_pair(<span class="number">5</span>, <span class="string">"peach"</span>));</span><br><span class="line"> </span><br><span class="line"><span class="keyword">auto</span> it&#123; mymap.cbegin() &#125;; <span class="comment">// declare a const iterator and assign to start of vector</span></span><br><span class="line"><span class="keyword">while</span> (it != mymap.cend()) <span class="comment">// while it hasn't reach the end</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">"="</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">" "</span>; <span class="comment">// print the value of the element it points to</span></span><br><span class="line">++it; <span class="comment">// and iterate to the next element</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，迭代器很容易遍历容器的每个元素。您根本不需要关心map如何存储数据!</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/容器类STL</title>
      <link href="/archives/ef749515.html"/>
      <url>/archives/ef749515.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/16-2-stl-containers-overview/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/16-2-stl-containers-overview/</a></p><hr><p>到目前为止，<strong>STL库最常用的功能是STL容器类</strong>。如果您需要快速复习一下容器类，请查看<a href="https://www.learncpp.com/cpp-tutorial/106-container-classes/" target="_blank" rel="noopener">10.6 – Container classes</a>。</p><p>STL包含许多不同的容器类，可以在不同的情况下使用。一般来说，容器类分为三个基本类别:</p><ul><li>序列容器</li><li>关联容器</li><li>容器适配器</li></ul><h1 id="序列容器"><a href="#序列容器" class="headerlink" title="序列容器"></a>序列容器</h1><p><strong>序列容器是维护容器中元素顺序的容器类</strong>。序列容器的一个定义特性是，<u>您可以根据位置选择元素的插入位置</u>。</p><p>序列容器最常见的例子是<strong>数组</strong>：如果您将四个元素插入到一个数组中，那么这些元素将按照您插入它们的确切顺序排列。</p><p>在c++ 11中，STL包含6个序列容器:</p><ul><li><p>std::vector</p><blockquote><p>在头文件：<code>vector</code>中</p></blockquote></li><li><p>std::deque</p><blockquote><p>在头文件：<code>deque</code>中</p></blockquote></li><li><p>std::array</p></li><li><p>std::list</p></li><li><p>std::forward_list</p></li><li><p>std::basic_string</p></li></ul><h2 id="std-vector"><a href="#std-vector" class="headerlink" title="std::vector"></a>std::vector</h2><p>如果你学过物理，你可能会认为<strong>矢量</strong>是同时具有大小和方向的实体。但是，STL中名为<strong>vector的类</strong>是一个动态数组，能够根据需要增长以包含它的元素。</p><p>vector类允许通过操作符[]<strong>随机访问</strong>它的元素，并且插入和删除vector中<strong>末尾</strong>的元素通常是很快的。</p><p>下面的程序将6个数字插入到一个向量中，并使用重载的[]运算符访问它们以打印它们。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vect;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count &lt; <span class="number">6</span>; ++count)</span><br><span class="line">        vect.push_back(<span class="number">10</span> - count); <span class="comment">// insert at end of array</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index=<span class="number">0</span>; index &lt; vect.<span class="built_in">size</span>(); ++index)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; vect[index] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">10</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="std-deque"><a href="#std-deque" class="headerlink" title="std::deque"></a>std::deque</h2><p><strong>deque类</strong>(发音为“deck”)是一个双端队列类，<strong>实现为一个可以从两端增长的动态数组。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; deq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count &lt; <span class="number">3</span>; ++count)</span><br><span class="line">    &#123;</span><br><span class="line">        deq.push_back(count); <span class="comment">// insert at end of array</span></span><br><span class="line">        deq.push_front(<span class="number">10</span> - count); <span class="comment">// insert at front of array</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index=<span class="number">0</span>; index &lt; deq.<span class="built_in">size</span>(); ++index)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; deq[index] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="std-list"><a href="#std-list" class="headerlink" title="std::list"></a>std::list</h2><p>std::list是一种特殊类型的序列容器，称为<strong>双链表</strong>，其中容器中的每个元素都包含指向列表中的下一个和前一个元素的指针。</p><p>std::list只提供对列表的<strong>开始和结束的访问</strong>。<strong>不提供随机访问</strong>。</p><blockquote><p>如果您想要在中间找到一个值，您必须从一端开始并“遍历列表”，直到找到您想要找到的元素。</p><p>通常使用迭代器遍历列表。</p></blockquote><p>列表的优点是<strong>，如果您已经知道要将元素插入到列表的何处，那么将元素插入到列表中会非常快</strong>。</p><h2 id="特殊的：string"><a href="#特殊的：string" class="headerlink" title="特殊的：string"></a>特殊的：string</h2><p>尽管STL string(和wstring)类通常不作为一种序列容器类型包含在内，但它们实际上是，因为它们可以被认为是一个带有char(或wchar)类型数据元素的向量。</p><h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><p>关联容器是在将输入插入容器时<strong>自动对其输入排序的容器</strong>。默认情况下，<strong>关联容器使用操作符&lt;比较元素。</strong></p><ul><li><p><strong>set</strong>是一个容器，<u>它存储惟一的元素，不允许有重复的元素</u>。<strong>元素根据它们的值排序。</strong></p></li><li><p><strong>multiset</strong>是一个允许重复元素的集合。</p></li><li><p><strong>map</strong>(也称为关联数组)是一个集合，<strong>其中每个元素都是一对，称为键/值对</strong>。该键用于对数据进行排序和索引，并且必须是唯一的。值是实际的数据。</p></li><li><p><strong>multimap</strong>(也称为<strong>字典</strong>) 是允许重复键的映射。所有键按升序排列，你可以通过键查找值。</p><blockquote><p>现实生活中的字典是多种多样的:</p><p><strong>键</strong>是单词，而<strong>值</strong>是单词的含义。有些单词可以有多种含义，这就是为什么字典是多用途地图而不是地图的原因。</p></blockquote></li></ul><h1 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h1><p>容器适配器是适应特定用途的特殊<strong>预定义容器</strong>。关于容器适配器的有趣之处在于，您可以选择希望它们使用的序列容器。</p><ul><li><p><strong>stack(栈)</strong>是一个容器，元素在<strong>后进先出</strong>上下文中操作。</p><blockquote><p><strong>栈默认使用deque作为它们的默认序列容器</strong>(这看起来很奇怪，因为vector似乎更适合)，但可以使用vector或 list。</p></blockquote></li><li><p><strong>queue(队列)</strong>是一个容器，元素在FIFO(<strong>先入先出</strong>)上下文中操作，<u>元素被插入(推入)到容器的后面，然后从前面删除(弹出)</u>。</p><blockquote><p><strong>队列默认使用deque，但也可以使用list。</strong></p></blockquote></li><li><p>*<em>priority queue(优先队列) *</em> 是一种保持元素排序的队列(通过操作符&lt;)。<u>推入元素时，元素在队列中排序</u>。从前端删除一个元素将 返回 优先队列中优先级最高的项。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/标准库</title>
      <link href="/archives/b054a192.html"/>
      <url>/archives/b054a192.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/16-1-the-standard-template-library-stl/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/16-1-the-standard-template-library-stl/</a></p><hr><p>恭喜你! 您已经完成了教程的主要部分!</p><p>前面的课程中，我们介绍了许多c++语言的主要特性(包括c++ 11/14/17语言扩展中的一些特性)。</p><p>因此，显而易见的问题是，“下一步是什么?”你可能注意到的一件事是，很多程序都在反复使用相同的概念:循环、字符串、数组、排序等等…… 您可能还注意到，使用容器的非类版本和通用算法编写程序很容易出错。好消息是，c++附带了一个充满了可重用类的库，您可以在其中构建程序。这个库称为<strong>c++标准库</strong>。</p><p><strong>The Standard Library</strong></p><p>标准库包含一组提供模板容器、算法和迭代器的类。如果您需要一个公共类或算法，标准库中很可能就有。这样做的好处是，您可以利用这些类，而不需要自己编写和调试这些类，而且标准库很好地提供了这些类的相当有效的版本。缺点是标准库很复杂，而且可能有点吓人，因为所有东西都是模板化的。</p><p>幸运的是，您可以将标准库分成小块，只使用需要的部分，而忽略其他部分，直到您准备好处理它。</p><p>在接下来的几节课中，我们将从高层次上了解标准库提供的容器、算法和迭代器的类型。在以后的课程中，我们将深入探讨一些特定的类。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/std：：shared_ptr和std：：weak_ptr的循环依赖问题</title>
      <link href="/archives/8cf18577.html"/>
      <url>/archives/8cf18577.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/15-7-circular-dependency-issues-with-stdshared_ptr-and-stdweak_ptr/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/15-7-circular-dependency-issues-with-stdshared_ptr-and-stdweak_ptr/</a></p><hr><p>在上一节课中，我们了解了std::shared_ptr如何允许多个智能指针共同拥有相同的资源。然而，在某些情况下，这可能会成为问题。考虑下面的情况，两个独立对象中的共享指针都指向另一个对象:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // for std::shared_ptr</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Person&gt; m_partner; <span class="comment">// initially created empty</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">Person(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name): m_name(name)</span><br><span class="line">&#123; </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_name &lt;&lt; <span class="string">" created\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Person()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_name &lt;&lt; <span class="string">" destroyed\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="title">partnerUp</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Person&gt; &amp;p1, <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Person&gt; &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!p1 || !p2)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">p1-&gt;m_partner = p2;</span><br><span class="line">p2-&gt;m_partner = p1;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p1-&gt;m_name &lt;&lt; <span class="string">" is now partnered with "</span> &lt;&lt; p2-&gt;m_name &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> lucy = <span class="built_in">std</span>::make_shared&lt;Person&gt;(<span class="string">"Lucy"</span>); <span class="comment">// create a Person named "Lucy"</span></span><br><span class="line"><span class="keyword">auto</span> ricky = <span class="built_in">std</span>::make_shared&lt;Person&gt;(<span class="string">"Ricky"</span>); <span class="comment">// create a Person named "Ricky"</span></span><br><span class="line"> </span><br><span class="line">partnerUp(lucy, ricky); <span class="comment">// Make "Lucy" point to "Ricky" and vice-versa</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们使用<code>make_shared()</code>动态分配两个person，“Lucy”和“Ricky” (以确保Lucy和Ricky在main()的末尾被销毁) 。</p><p>然后我们把它们合起来(即。调用函数<code>partnerUp</code>)。</p><ul><li>这将std::shared_ptr内的“Lucy”指向“Ricky”，而std::shared_ptr内的“Ricky”指向“Lucy”。</li></ul><p>共享指针是用来共享的，所以lucy共享指针和Rick的m_partner共享指针都指向“lucy”是可以的(反之亦然)。</p><p>但是，这个程序并没有按照预期执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Lucy created</span><br><span class="line">Ricky created</span><br><span class="line">Lucy is now partnered with Ricky</span><br></pre></td></tr></table></figure><p>没有按照预期进行资源释放，发生了什么？</p><ul><li><p>调用<code>partnerUp()</code>之后，有两个指向“Ricky” (ricky和lucy的m_partner) 的共享指针，以及两个指向“Lucy” (Lucy和Ricky的m_partner) 的共享指针。</p><p>在函数结束时，<strong>ricky</strong>共享指针首先超出作用域。当这种情况发生时，ricky会检查是否有其他共享指针共同拥有这个Person“Ricky”。是有的(Lucy的m_partner)。正因为如此，它没有释放“Ricky”(如果释放了，那么Lucy的m_partner将以一个悬浮指针结束)。现在，我们有一个指向“Ricky”(Lucy的m_partner)的共享指针，还有两个指向“Lucy”(Lucy，和Ricky的m_partner)的共享指针。</p><p>接下来，<strong>lucy</strong>共享指针超出范围，同样的事情发生了。共享指针lucy检查是否有其他共享指针共同拥有这个人“lucy”。是有的(Ricky的m_partner)，所以“Lucy”没有被释放。此时，有一个共享指针指向“Lucy”(Ricky的m_partner)，还有一个共享指针指向“Ricky”(Lucy的m_partner)。</p><p>然后程序就结束了—— “Lucy” 和 “Ricky” 都没有被释放! 从本质上讲，“Lucy”最终阻止了 “Ricky”被毁灭， “Ricky”最终阻止了“Lucy”被毁灭。</p></li></ul><p>事实证明，这种情况在共享指针形成循环引用的任何时候都可能发生。</p><h1 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h1><p><strong>循环引用</strong>是一系列引用，<u>其中每个对象引用下一个对象，最后一个对象引用回第一个对象，从而导致引用循环</u>。<strong>这些引用不需要是实际的c++引用——它们可以是指针、惟一id或任何其他标识特定对象的方法。</strong></p><blockquote><p><strong>在共享指针的上下文中，引用将是指针。</strong></p></blockquote><p>这正是我们在上面的例子中看到的:</p><ul><li>“Lucy” 指向 “Ricky”；而 “Ricky” 也指向 “Lucy” 。</li></ul><blockquote><p>用三个指针，当A点在B点，B点在C点，C点在A点，会得到同样的结果。</p></blockquote><p>共享指针形成循环的实际效果是，<strong>每个对象最终保持下一个对象为活动状态</strong>（<strong>最后一个对象保持第一个对象为活动状态</strong>。）</p><p><strong>因此，在这个系列中没有对象可以被释放，因为它们都认为其他一些对象仍然需要它!</strong></p><h1 id="单个std-shared-ptr也可以造成循环依赖问题"><a href="#单个std-shared-ptr也可以造成循环依赖问题" class="headerlink" title="单个std::shared_ptr也可以造成循环依赖问题"></a>单个<code>std::shared_ptr</code>也可以造成循环依赖问题</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // for std::shared_ptr</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Resource&gt; m_ptr; <span class="comment">// initially created empty</span></span><br><span class="line"></span><br><span class="line">Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> ptr1 = <span class="built_in">std</span>::make_shared&lt;Resource&gt;();</span><br><span class="line"> </span><br><span class="line">ptr1-&gt;m_ptr = ptr1; <span class="comment">// ⭐m_ptr现在正在共享包含它自己的资源</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，当ptr1超出作用域时，它不会释放资源，因为资源的m_ptr正在共享资源。然后就没有人可以删除资源了(m_ptr永远不会超出作用域，所以它永远不会有机会)。因此，程序打印:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Resource acquired</span><br></pre></td></tr></table></figure><h1 id="std-weak-ptr来解决循环依赖问题"><a href="#std-weak-ptr来解决循环依赖问题" class="headerlink" title="std::weak_ptr来解决循环依赖问题"></a><strong>std::weak_ptr</strong>来解决循环依赖问题</h1><p><code>std::weak_ptr</code>是为了解决上面描述的“周期性所有权”问题而设计的。<code>std::weak_ptr</code>是一个观察者——它可以 像std::shared_ptr一样 观察和访问(或其他std::weak_ptrs)相同的对象，<strong>但它不被视为所有者。</strong></p><p>请记住，<strong>当一个std::shared指针超出作用域时，它只考虑其他std::shared_ptr是否共同拥有该对象。std: weak_ptr不算数!</strong></p><p>让我们使用std::weak_ptr来解决本节中刚开始的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // for std::shared_ptr and std::weak_ptr</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;Person&gt; m_partner; <span class="comment">// ⭐⭐⭐note: This is now a std::weak_ptr</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">Person(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name): m_name(name)</span><br><span class="line">&#123; </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_name &lt;&lt; <span class="string">" created\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Person()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_name &lt;&lt; <span class="string">" destroyed\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="title">partnerUp</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Person&gt; &amp;p1, <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Person&gt; &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!p1 || !p2)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">p1-&gt;m_partner = p2;</span><br><span class="line">p2-&gt;m_partner = p1;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p1-&gt;m_name &lt;&lt; <span class="string">" is now partnered with "</span> &lt;&lt; p2-&gt;m_name &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> lucy = <span class="built_in">std</span>::make_shared&lt;Person&gt;(<span class="string">"Lucy"</span>);</span><br><span class="line"><span class="keyword">auto</span> ricky = <span class="built_in">std</span>::make_shared&lt;Person&gt;(<span class="string">"Ricky"</span>);</span><br><span class="line"> </span><br><span class="line">partnerUp(lucy, ricky);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Lucy created</span><br><span class="line">Ricky created</span><br><span class="line">Lucy is now partnered with Ricky</span><br><span class="line">Ricky destroyed</span><br><span class="line">Lucy destroyed</span><br></pre></td></tr></table></figure><p>在功能上，它的工作方式几乎与有问题的示例相同。但是，现在当ricky超出范围时，它会看到没有其他std::shared_ptr指向“ricky”(来自“Lucy”的std::weak_ptr不计算)。因此，它将释放“Ricky”。露西也是如此。</p><h2 id="std-weak-ptr-的使用"><a href="#std-weak-ptr-的使用" class="headerlink" title="std::weak_ptr 的使用"></a>std::weak_ptr 的使用</h2><p>std::weak_ptr缺点是不能直接使用(<strong>它们没有操作符-&gt;</strong>)。</p><p>要使用std::weak_ptr，必须首先将其转换为std::shared_ptr。然后可以使用std::shared_ptr。</p><ul><li>要将std::weak_ptr转换为std::shared_ptr，可以使用<strong><code>lock()</code>成员函数</strong>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // for std::shared_ptr and std::weak_ptr</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;Person&gt; m_partner; <span class="comment">// note: This is now a std::weak_ptr</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">Person(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name) : m_name(name)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_name &lt;&lt; <span class="string">" created\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Person()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_name &lt;&lt; <span class="string">" destroyed\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="title">partnerUp</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Person&gt; &amp;p1, <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Person&gt; &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!p1 || !p2)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">p1-&gt;m_partner = p2;</span><br><span class="line">p2-&gt;m_partner = p1;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p1-&gt;m_name &lt;&lt; <span class="string">" is now partnered with "</span> &lt;&lt; p2-&gt;m_name &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Person&gt; <span class="title">getPartner</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_partner.lock(); &#125; <span class="comment">//⭐⭐⭐ use lock() to convert weak_ptr to shared_ptr</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> lucy = <span class="built_in">std</span>::make_shared&lt;Person&gt;(<span class="string">"Lucy"</span>);</span><br><span class="line"><span class="keyword">auto</span> ricky = <span class="built_in">std</span>::make_shared&lt;Person&gt;(<span class="string">"Ricky"</span>);</span><br><span class="line"> </span><br><span class="line">partnerUp(lucy, ricky);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">auto</span> partner = ricky-&gt;getPartner(); <span class="comment">// get shared_ptr to Ricky's partner</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ricky-&gt;getName() &lt;&lt; <span class="string">"'s partner is: "</span> &lt;&lt; partner-&gt;getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Lucy created</span><br><span class="line">Ricky created</span><br><span class="line">Lucy is now partnered with Ricky</span><br><span class="line">Ricky&#39;s partner is: Lucy</span><br><span class="line">Ricky destroyed</span><br><span class="line">Lucy destroyed</span><br></pre></td></tr></table></figure><p>我们不需要担心与std::shared_ptr变量“m_partner”的循环依赖关系，因为它只是函数内部的一个局部变量。它最终将在函数结束时超出作用域，引用计数将递减1。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><code>std::hared_ptr</code>可以在需要多个智能指针共享资源时使用。当最后一个<code>std::shared_ptr</code>超出作用域时，资源将被释放。</p><p><code>std::weak_ptr</code>可以在需要智能指针时使用，<strong>该指针可以查看和使用共享资源，但不参与该资源的所有权</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/智能指针“std：：shared_ptr”</title>
      <link href="/archives/96b73b83.html"/>
      <url>/archives/96b73b83.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/15-6-stdshared_ptr/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/15-6-stdshared_ptr/</a></p><hr><h1 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h1><ul><li><p><strong>智能指针<code>std::unique_ptr</code></strong>，<strong>旨在单独拥有和管理一种资源</strong>。</p></li><li><p>而，<strong>智能指针<code>std::shared_ptr</code></strong>，<strong>旨在解决需要多个智能指针共同拥有一个资源的情况。</strong></p><blockquote><p>也就是说，<strong>多个<code>std::shared_ptr</code>指向同一个资源是没有问题的</strong>。</p></blockquote><p><strong><code>std::shared_ptr</code> 位于头文件<code>&lt;memory&gt;</code> 之中</strong>（<code>std::unique_ptr</code>也在该头文件中）</p></li></ul><h2 id="当多个std-shared-ptr指向同一资源，使用“复制”"><a href="#当多个std-shared-ptr指向同一资源，使用“复制”" class="headerlink" title="当多个std::shared_ptr指向同一资源，使用“复制”"></a>当多个std::shared_ptr指向同一资源，使用“复制”</h2><p>在内部，<code>std::shared_ptr</code> 会跟踪共享资源的 <strong>std::shared_ptr的数量</strong>。<u>只要有至少一个<code>std::shared_ptr</code>指向该资源，该资源就不会被释放，即使单个<code>std::shared_ptr</code>被销毁。</u></p><p><strong>只有在这些众多指向同一资源的 std::shared_ptr 中的最后一个 超出其作用域（或者 被重新分配指向其他东西）时，这个资源才会被释放。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // for std::shared_ptr</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 分配一个资源对象，并让std::shared_ptr 拥有它</span></span><br><span class="line">Resource *res = <span class="keyword">new</span> Resource;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Resource&gt; <span class="title">ptr1</span><span class="params">(res)</span></span>;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Resource&gt; <span class="title">ptr2</span><span class="params">(ptr1)</span></span>; <span class="comment">// 使用复制初始化 使另一个std::shared_ptr指向相同的对象</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Killing one shared pointer\n"</span>;</span><br><span class="line">&#125; <span class="comment">// ptr2超出了范围，但是什么也没有发生</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Killing another shared pointer\n"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// ptr1超出了这里的范围，分配的资源被销毁</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Resource acquired</span><br><span class="line">Killing one shared pointer</span><br><span class="line">Killing another shared pointer</span><br><span class="line">Resource destroyed</span><br></pre></td></tr></table></figure><p>在上面的代码中，<strong>我们创建了一个动态 资源对象，并设置了一个名为ptr1的std::shared_ptr来管理它</strong>。</p><p>在嵌套块内部，我们使用复制初始化 (std::shared_ptr允许这样做，因为资源可以共享) 来创建第二个std::shared_ptr (ptr2)，它指向相同的资源。</p><ul><li><p>当ptr2超出范围时，资源不会被释放，因为ptr1仍然指向资源。</p></li><li><p>当ptr1超出范围时，ptr1注意到不再有std::shared_ptr管理资源，因此它释放资源。</p></li></ul><p><strong>注意，我们从第一个共享指针创建了第二个共享指针(使用复制初始化)。这是很重要的</strong>。考虑以下类似的方案:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // for std::shared_ptr</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Resource *res = <span class="keyword">new</span> Resource;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Resource&gt; <span class="title">ptr1</span><span class="params">(res)</span></span>;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Resource&gt; <span class="title">ptr2</span><span class="params">(res)</span></span>; <span class="comment">// ⭐直接从res创建ptr2(而不是ptr1)</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Killing one shared pointer\n"</span>;</span><br><span class="line">&#125; <span class="comment">// ptr2 goes out of scope here, and the allocated Resource is destroyed</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Killing another shared pointer\n"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// ptr1 goes out of scope here, and the allocated Resource is destroyed again</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Resource acquired</span><br><span class="line">Killing one shared pointer</span><br><span class="line">Resource destroyed</span><br><span class="line">Killing another shared pointer</span><br><span class="line">Resource destroyed</span><br></pre></td></tr></table></figure><p>这里的不同之处在于，我们分别创建了两个std::shared_ptr。<strong>因此，即使它们都指向相同的资源，它们也不知道对方的存在。（<a href="##独立创建两个指向相同资源的std::shared_ptr会出错">具体解释在下面</a>）</strong> 当ptr2超出范围时，它认为自己是资源的唯一所有者，并释放资源。当ptr1稍后超出范围时，它会进行相同的思考，并再次尝试删除资源。然后坏事发生了。</p><p><strong>幸运的是，当需要多个共享指针指向同一资源时，可以通过使用复制赋值或复制初始化轻松避免这种情况。</strong></p><blockquote><p><strong>规则:如果需要多个指向同一资源的std::shared_ptr，则始终复制一个现有的std::shared_ptr。</strong></p></blockquote><h1 id="std-make-shared"><a href="#std-make-shared" class="headerlink" title="std::make_shared"></a>std::make_shared</h1><p><strong>就像std::make_unique()可以用来在c++ 14中创建一个std::unique_ptr；</strong></p><p><strong><code>std::make_shared()</code>可以用来创建一个<code>std::shared_ptr</code>。</strong></p><blockquote><p><code>std::make_shared()</code>在c++ 11中可用。</p></blockquote><p>这是我们最初的例子，使用<code>std::make_shared()</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // for std::shared_ptr</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 分配一个Resource对象，并将其所有权 给std::shared_ptr</span></span><br><span class="line"><span class="keyword">auto</span> ptr1 = <span class="built_in">std</span>::make_shared&lt;Resource&gt;();</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> ptr2 = ptr1; <span class="comment">// 使用ptr1的复制初始化创建ptr2</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Killing one shared pointer\n"</span>;</span><br><span class="line">&#125; <span class="comment">// ptr2 goes out of scope here, but nothing happens</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Killing another shared pointer\n"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// ptr1 goes out of scope here, and the allocated Resource is destroyed</span></span><br></pre></td></tr></table></figure><p><strong>使用std::make_shared()的原因与std::make_unique()相同。</strong></p><ul><li><code>std::make_shared()</code>更简单、更安全 (但无法使用此方法直接创建指向同一资源的两个std::shared_ptr)。</li></ul><h1 id="std-shared-ptr实际上包含两个指针"><a href="#std-shared-ptr实际上包含两个指针" class="headerlink" title="std::shared_ptr实际上包含两个指针"></a><code>std::shared_ptr</code>实际上包含两个指针</h1><p><code>std::unique_ptr</code>，它在内部使用<strong>一个指针</strong>；</p><p>而<code>std::shared_ptr</code>，它在内部使用<strong>两个指针</strong>。</p><ul><li>一个指针指向<strong>被管理的资源</strong>。</li><li>其他的点指向一个“<strong>控制块”</strong>。它是一个动态分配的对象，跟踪一堆东西，<u>包括有多少std::shared_ptr指向资源。</u></li></ul><p>当通过std::shared_ptr的构造函数 创建std::shared_ptr时，将<u>分别</u>分配 托管对象(通常传入) 和 控制块(构造函数创建) 的内存。</p><p><strong>但是，在使用std::make_shared()时，可以将其优化为单个内存分配，从而提高性能。</strong></p><h2 id="独立创建两个指向相同资源的std-shared-ptr会出错"><a href="#独立创建两个指向相同资源的std-shared-ptr会出错" class="headerlink" title="独立创建两个指向相同资源的std::shared_ptr会出错"></a>独立创建两个指向相同资源的std::shared_ptr会出错</h2><p>这也解释了为什么独立地创建两个指向相同资源的std::shared_ptr会给我们带来麻烦。</p><ul><li><p>每个std::shared_ptr都有一个指向资源的指针。但是，每个std::shared_ptr将独立地分配它自己的控制块，<strong>这将表明它是唯一拥有该资源的指针。</strong></p></li><li><p>因此，当std::shared_ptr超出作用域时，它将释放资源，而没有意识到还有其他std::shared_ptr也试图管理该资源。</p></li></ul><p><strong>但是，当使用复制赋值克隆std::shared_ptr时，可以适当地更新控制块中的数据，以指示现在有额外的std::shared_ptr共同管理资源。</strong></p><h1 id="std-shared-ptr可以std-unique-ptr中创建"><a href="#std-shared-ptr可以std-unique-ptr中创建" class="headerlink" title="std::shared_ptr可以std::unique_ptr中创建"></a><code>std::shared_ptr</code>可以<code>std::unique_ptr</code>中创建</h1><p>一个<code>std::unique_ptr</code>可以通过一个特殊的<code>std::shared_ptr</code>构造函数转换成一个<code>std::shared_ptr</code>，这个构造函数接受一个<code>std::unique_ptr</code> r-value。</p><p><code>std::unique_ptr</code>的内容将被<strong>移动</strong>到<code>std::shared_ptr</code>。</p><p>但是，<strong>std::shared_ptr不能安全地转换为std::unique_ptr。</strong></p><p>这意味着，如果要创建一个将返回智能指针的函数，最好返回一个std::unique_ptr，并在适当的时候将其分配给一个std::shared_ptr。</p><h1 id="std-shared-ptr的危害"><a href="#std-shared-ptr的危害" class="headerlink" title="std::shared_ptr的危害"></a><code>std::shared_ptr</code>的危害</h1><p><code>std::shared_ptr</code>遇到了一些与<code>std::unique_ptr</code>相同的挑战：</p><ul><li>如果没有正确地处理std::shared_ptr (可能是因为它是动态分配的且从未删除，也可能是因为它是动态分配且从未删除的对象的一部分) 那么它所管理的资源也不会被释放。</li></ul><p>使用std::unique_ptr，您只需要担心一个智能指针被正确处理。</p><p>对于std::shared_ptr，您必须考虑所有这些问题。<strong>如果管理资源的std::shared_ptr中的任何一个没有被正确销毁，资源将不会被正确释放。</strong></p><h1 id="std-shared-ptr和数组"><a href="#std-shared-ptr和数组" class="headerlink" title="std::shared_ptr和数组"></a>std::shared_ptr和数组</h1><p>在c++ 14和更早的版本中，std::shared_ptr不支持管理数组，不应该用于管理C风格的数组。</p><p><strong>从c++ 17开始，std::shared_ptr就支持数组了</strong>。<strong>但是</strong>，从c++ 17开始，<strong>std::make_shared仍然缺乏对数组的适当支持</strong>，不应该用于创建共享数组。这可能会在c++ 20中得到解决。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>std::shared_ptr是为需要多个智能指针共同管理同一资源而设计的。当管理资源的最后一个std::shared_ptr被销毁时，资源将被释放。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/智能指针“std：：unique_ptr”</title>
      <link href="/archives/e8f15917.html"/>
      <url>/archives/e8f15917.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/15-5-stdunique_ptr/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/15-5-stdunique_ptr/</a></p><hr><p><strong>智能指针是一个管理动态分配对象的<u>类</u>。尽管智能指针可以提供其他特性，但智能指针的定义特征是它管理动态分配的资源，并确保在适当的时间(通常是当智能指针超出范围时)正确地清理动态分配的对象。</strong></p><p>因此，<strong>智能指针永远不应该自己动态分配</strong> (否则，智能指针可能没有被释放，这意味着它拥有的对象将不会被释放，从而导致内存泄漏)。</p><blockquote><p>通过在栈上分配智能指针(作为局部变量或类的组合成员)，我们可以保证当智能指针包含的函数或对象结束时，它将正确地超出作用域，确保智能指针拥有的对象被正确释放。</p></blockquote><p>c++ 11标准库附带了4个智能指针类:</p><ul><li><p><code>std::auto_ptr</code>(你不应该使用它——它在c++ 17中被删除了)，</p></li><li><p><code>std::unique_ptr</code>, ⭐</p></li><li><p><code>std::shared_ptr</code></p></li><li><p><code>std::weak_ptr</code>。</p></li></ul><p>其中，<code>std::unique_ptr</code>是使用最多的智能指针类，所以，就主要讲一下这个指针类。</p><h1 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a><code>std::unique_ptr</code></h1><blockquote><p><strong>在头文件 <code>&lt;memory&gt;</code> 中</strong></p></blockquote><p>在C++11中，<code>std::unique_ptr</code>是<code>std::auto_ptr</code> 的替代品。<strong>它应该用于管理任何不被多个对象共享的动态分配的对象。</strong></p><p>也就是说，<strong><code>std::unique_ptr</code>应该完全拥有它管理的对象，而不是与其他类共享该所有权。</strong></p><p>一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // for std::unique_ptr</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// allocate a Resource object and have it owned by std::unique_ptr</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Resource&gt; res&#123; <span class="keyword">new</span> Resource() &#125;; <span class="comment">//⭐</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// res goes out of scope here, and the allocated Resource is destroyed</span></span><br></pre></td></tr></table></figure><p><strong>因为<code>std::unique_ptr</code>是在这里的栈上分配的，所以它最终肯定会超出范围，当超出范围时，它将删除它正在管理的资源。</strong></p><h2 id="std-unique-ptr内置使用移动语义"><a href="#std-unique-ptr内置使用移动语义" class="headerlink" title="std::unique_ptr内置使用移动语义"></a><code>std::unique_ptr</code>内置使用移动语义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // for std::unique_ptr</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Resource&gt; res1&#123; <span class="keyword">new</span> Resource&#123;&#125; &#125;; <span class="comment">// Resource created here</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Resource&gt; res2&#123;&#125;; <span class="comment">// Start as nullptr</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"res1 is "</span> &lt;&lt; (<span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(res1) ? <span class="string">"not null\n"</span> : <span class="string">"null\n"</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"res2 is "</span> &lt;&lt; (<span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(res2) ? <span class="string">"not null\n"</span> : <span class="string">"null\n"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// res2 = res1; //无法编译: 因为std::unique_ptr 禁止复制赋值</span></span><br><span class="line">res2 = <span class="built_in">std</span>::<span class="built_in">move</span>(res1); <span class="comment">// res2假定为 所有者，res1设置为null</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Ownership transferred\n"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"res1 is "</span> &lt;&lt; (<span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(res1) ? <span class="string">"not null\n"</span> : <span class="string">"null\n"</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"res2 is "</span> &lt;&lt; (<span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(res2) ? <span class="string">"not null\n"</span> : <span class="string">"null\n"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// Resource 在res2超出作用域时被销毁</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Resource acquired</span><br><span class="line">res1 is not null</span><br><span class="line">res2 is null</span><br><span class="line">Ownership transferred</span><br><span class="line">res1 is null</span><br><span class="line">res2 is not null</span><br><span class="line">Resource destroyed</span><br></pre></td></tr></table></figure><p><strong>因为std::unique_ptr在设计时考虑到了移动语义，所以禁用了复制初始化和复制赋值。</strong></p><p><strong>如果要传输<code>std::unique_ptr</code>管理的内容，必须使用移动语义。</strong></p><blockquote><p>在上面的程序中，我们通过<code>std::move</code>(它将res1转换为r-value，这将触发一个 移动赋值，而不是一个复制赋值)来完成这个任务。</p></blockquote><h2 id="访问被管理的对象"><a href="#访问被管理的对象" class="headerlink" title="访问被管理的对象"></a>访问被管理的对象</h2><p><code>std::unique_ptr</code>有一个重载的<strong>操作符*</strong>和<strong>操作符-&gt;</strong>，<u>可以用来返回被管理的资源。</u></p><ul><li><strong>操作符*</strong>返回对托管资源的<strong>引用</strong>；</li><li><strong>操作符-&gt;</strong>返回一个<strong>指针</strong>。</li></ul><p>请记住，<code>std::unique_ptr</code>可能并不总是管理一个对象 —— <strong>这可能是因为它创建为空 (使用默认构造函数或传递nullptr作为参数)；也可能是因为它所管理的资源被移动到了另一个std::unique_ptr。</strong></p><p><strong>因此，在使用这两种操作符之前，我们应该检查std::unique_ptr是否确实有资源</strong>。</p><blockquote><p><strong><u>幸运的是，这很简单：<code>std::unique_ptr</code>有一个到bool的强制转换，如果<code>std::unique_ptr</code>正在管理一个资源，该转换将返回true。</u></strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // for std::unique_ptr</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line"><span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> Resource &amp;res)</span><br><span class="line">&#123;</span><br><span class="line">out &lt;&lt; <span class="string">"I am a resource\n"</span>;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Resource&gt; res&#123; <span class="keyword">new</span> Resource&#123;&#125; &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (res) <span class="comment">// 使用隐式强制转换为bool 以确保res包含资源</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *res &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print the Resource that res is owning⭐⭐⭐</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Resource acquired</span><br><span class="line">I am a resource</span><br><span class="line">Resource destroyed</span><br></pre></td></tr></table></figure><blockquote><p>注意：上面例子中的：<code>std::cout &lt;&lt; *res &lt;&lt; &#39;\n&#39;;</code>这一句，实际上为：</p><p><code>std::operator&lt;&lt;(operator&lt;&lt;(std::cout, res.operator*()), &#39;\n&#39;);</code></p><p><strong>也就是说，这里的操作符* 实际上是返回的是 引用。</strong></p></blockquote><p>在上面的程序中，我们使用重载操作符*获取std::unique_ptr res拥有的资源对象，然后将其发送到std::cout进行打印。</p><h2 id="std-unique-ptr和数组"><a href="#std-unique-ptr和数组" class="headerlink" title="std::unique_ptr和数组"></a><code>std::unique_ptr</code>和数组</h2><p>与std::auto_ptr不同，<strong><code>std::unique_ptr</code>足够智能，可以知道是使用标量删除还是数组删除，因此std::unique_ptr可以用于标量对象和数组。</strong></p><blockquote><p>但是，<strong>std::array或std::vector(或std::string )几乎总是比使用固定数组、动态数组或c风格的字符串的std::unique_ptr更好的选择。</strong></p></blockquote><h1 id="std-make-unique"><a href="#std-make-unique" class="headerlink" title="std::make_unique"></a><code>std::make_unique</code></h1><p>c++ 14附带了一个名为<code>std::make_unique()</code>的附加函数。这个模板函数<strong>构造</strong>一个模板类型的<strong>对象</strong>，并用传入函数的参数对其进行初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // for std::unique_ptr and std::make_unique</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_numerator&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> m_denominator&#123; <span class="number">1</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Fraction(<span class="keyword">int</span> numerator = <span class="number">0</span>, <span class="keyword">int</span> denominator = <span class="number">1</span>) :</span><br><span class="line">m_numerator&#123; numerator &#125;, m_denominator&#123; denominator &#125;</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> Fraction &amp;f1)</span><br><span class="line">&#123;</span><br><span class="line">out &lt;&lt; f1.m_numerator &lt;&lt; <span class="string">"/"</span> &lt;&lt; f1.m_denominator;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 用分子3和分母5创建一个动态分配的Fraction</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Fraction&gt; f1&#123; <span class="built_in">std</span>::make_unique&lt;Fraction&gt;(<span class="number">3</span>, <span class="number">5</span>) &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *f1 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 创建一个长度为4的Fraction的动态分配数组</span></span><br><span class="line"><span class="comment">// 在这里我们也可以使用自动类型推断来达到很好的效果</span></span><br><span class="line"><span class="keyword">auto</span> f2&#123; <span class="built_in">std</span>::make_unique&lt;Fraction[]&gt;(<span class="number">4</span>) &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f2[<span class="number">0</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3&#x2F;5</span><br><span class="line">0&#x2F;1</span><br></pre></td></tr></table></figure><p>使用std::make_unique()是可选的，但建议不要自己创建std::unique_ptr。这是因为使用std::make_unique的代码更简单，而且需要的输入也更少(与自动类型推断一起使用时)。此外，它还解决了一个<strong>异常安全问题</strong>，这个问题可能是由于c++没有指定函数参数的计算顺序而导致的。</p><blockquote><p><strong>使用std::make_unique()而不是创建std::unique_ptr并自己使用new</strong></p></blockquote><h2 id="更详细的看异常安全问题"><a href="#更详细的看异常安全问题" class="headerlink" title="更详细的看异常安全问题"></a>更详细的看异常安全问题</h2><p>对于那些想知道上面提到的“异常安全问题”是什么，这里是对这个问题的描述。</p><p>考虑这样一个表达:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">some_function(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> T), function_that_can_throw_exception());</span><br></pre></td></tr></table></figure><p>编译器在处理这个调用方面有很大的灵活性。它可以创建一个新的T，然后调用<code>function_that_can_throw_exception()</code>，然后创建<strong>std::unique_ptr</strong>来管理动态分配的T。<u>如果<code>function_that_can_throw_exception()</code>抛出异常，那么分配的T将不会被回收，因为执行回收的智能指针还没有创建。这导致了T被泄露。</u></p><p><strong>std::make_unique()</strong>不会遇到这个问题，<strong>因为对象T的创建和std::unique_ptr的创建都发生在std::make_unique()函数中，在这个函数中，执行顺序没有歧义。</strong></p><h1 id="从函数返回std-unique-ptr"><a href="#从函数返回std-unique-ptr" class="headerlink" title="从函数返回std::unique_ptr"></a>从函数返回<code>std::unique_ptr</code></h1><p><code>std::unique_ptr</code>可以安全地从一个函数返回值:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Resource&gt; <span class="title">createResource</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;Resource&gt;();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Resource&gt; ptr&#123; createResource() &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// do whatever</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，createResource()按值返回<code>std::unique_ptr</code>。</p><ul><li><p><strong>如果未将此值赋给任何值，则临时返回值将超出范围，资源将被清理。</strong></p></li><li><p>如果它被赋值 (如main()所示)，</p><ul><li>在c++ 14或更早的版本中，将使用move语义将资源从返回值转移到赋值的对象(在上面的示例ptr中)</li><li>而在c++ 17或更新版本中，将省略返回。</li></ul></li></ul><p><strong>这使得通过std::unique_ptr返回资源比返回原始指针安全得多!</strong></p><p><strong>通常，您不应该通过 指针 或 引用 返回std::unique_ptr(除非您有特定的强制理由)。</strong>,应该直接返回std::unique_ptr</p><h1 id="将std-unique-ptr传递给一个函数"><a href="#将std-unique-ptr传递给一个函数" class="headerlink" title="将std::unique_ptr传递给一个函数"></a>将<code>std::unique_ptr</code>传递给一个函数</h1><h2 id="获得传入参数的所有权"><a href="#获得传入参数的所有权" class="headerlink" title="获得传入参数的所有权"></a>获得传入参数的所有权</h2><p><strong>如果希望函数获得指针内容的所有权，请按<u>值</u>传递std::unique_ptr</strong>。注意，由于已经禁用了复制语义，因此需要使用<strong>std::move</strong>来实际传入变量（如果传入参数是左值时，需要）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // for std::unique_ptr</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line"><span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> Resource &amp;res)</span><br><span class="line">&#123;</span><br><span class="line">out &lt;&lt; <span class="string">"I am a resource\n"</span>;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">void takeOwnership(std::unique_ptr&lt;Resource&gt; res) ⭐</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (res)</span><br><span class="line">          <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *res &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125; <span class="comment">// the Resource is destroyed here</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ptr&#123; <span class="built_in">std</span>::make_unique&lt;Resource&gt;() &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//    takeOwnership(ptr); 这不起作用，需要使用移动语义⭐⭐</span></span><br><span class="line">    takeOwnership(<span class="built_in">std</span>::<span class="built_in">move</span>(ptr)); <span class="comment">// ok: use move semantics</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Ending program\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Resource acquired</span><br><span class="line">I am a resource</span><br><span class="line">Resource destroyed</span><br><span class="line">Ending program</span><br></pre></td></tr></table></figure><p><strong>注意</strong>，在这种情况下，Resource的所有权被转移到takeOwnership()，因此Resource在takeOwnership()的末尾而不是main()的末尾被销毁。</p><h2 id="不获得传入参数的所有权"><a href="#不获得传入参数的所有权" class="headerlink" title="不获得传入参数的所有权"></a>不获得传入参数的所有权</h2><p><strong>但是，在大多数情况下，您不希望函数取得资源的所有权</strong>。虽然可以通过<strong>引用传递</strong>std::unique_ptr(这将允许函数使用对象而不拥有该对象)，但是应该只在调用的函数可能更改或改变被管理的对象时才这样做。</p><p>相反，最好只传递资源本身(通过<strong>指针</strong>或<strong>引用</strong>传递，这取决于null是否为有效参数)。这允许函数不知道调用方是如何管理其资源的。<strong>要从std::unique_ptr获得原始资源指针，可以使用get()成员函数</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // for std::unique_ptr</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> Resource &amp;res)</span><br><span class="line">&#123;</span><br><span class="line">out &lt;&lt; <span class="string">"I am a resource\n"</span>;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 该函数只使用该资源，因此我们将接受指向该资源的指针，而不是对整个std::unique_ptr&lt; resource &gt;的引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useResource</span><span class="params">(Resource *res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (res)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *res &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> ptr&#123; <span class="built_in">std</span>::make_unique&lt;Resource&gt;() &#125;;</span><br><span class="line"> </span><br><span class="line">useResource(ptr.<span class="built_in">get</span>()); <span class="comment">// 注意:这里使用get()获取指向资源的指针</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Ending program\n"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// The Resource is destroyed here</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Resource acquired</span><br><span class="line">I am a resource</span><br><span class="line">Ending program</span><br><span class="line">Resource destroyed</span><br></pre></td></tr></table></figure><h1 id="std-unique-ptr-和-类"><a href="#std-unique-ptr-和-类" class="headerlink" title="std::unique_ptr 和 类"></a>std::unique_ptr 和 类</h1><p>当然，您可以使用std::unique_ptr<strong>作为类</strong>的组合<strong>成员</strong>。这样，<strong>您就不必担心类析构函数会不会删除动态内存，因为std::unique_ptr将在类对象被销毁时自动销毁</strong>。</p><p>但是，请注意，如果您的类对象是动态分配的，那么对象本身就有可能没有被正确释放，在这种情况下，即使使用智能指针也无济于事。</p><h1 id="滥用std-unique-ptr"><a href="#滥用std-unique-ptr" class="headerlink" title="滥用std:: unique_ptr"></a>滥用std:: unique_ptr</h1><p>有两种容易误用<code>std::unique_ptr</code>的方法，这两种方法都很容易避免。</p><ul><li><p><strong>首先，不要让多个类管理相同的资源。</strong>例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Resource *res&#123; <span class="keyword">new</span> Resource() &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Resource&gt; res1&#123; res &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Resource&gt; res2&#123; res &#125;;</span><br></pre></td></tr></table></figure><p><strong>虽然这在语法上是合法的</strong>，但是最终的结果是res1和res2都将尝试删除资源，这将导致未定义的行为。</p></li><li><p>其次，<strong>不要</strong>在std::unique_ptr中<strong>手动删除资源</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Resource *res&#123; <span class="keyword">new</span> Resource() &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Resource&gt; res1&#123; res &#125;;</span><br><span class="line"><span class="keyword">delete</span> res;</span><br></pre></td></tr></table></figure><p>如果这样做，那么std::unique_ptr将尝试删除已经删除的资源，再次导致未定义的行为。</p></li></ul><p><strong>注意，std::make_unique()可以防止上述两种情况在无意中发生。</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/std：：move</title>
      <link href="/archives/323fcdb7.html"/>
      <url>/archives/323fcdb7.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/15-4-stdmove/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/15-4-stdmove/</a></p><hr><p>一旦您开始更经常地使用move语义，<strong>您就会开始发现需要调用move语义的情况，但是您必须使用的对象是l-values，而不是r-values</strong>。以下面的swap函数为例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">myswap</span>(<span class="title">T</span>&amp; <span class="title">a</span>, <span class="title">T</span>&amp; <span class="title">b</span>) </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">  T tmp &#123; a &#125;; <span class="comment">// invokes copy constructor</span></span><br><span class="line">  a = b; <span class="comment">// invokes copy assignment</span></span><br><span class="line">  b = tmp; <span class="comment">// invokes copy assignment</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> x&#123; <span class="string">"abc"</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> y&#123; <span class="string">"de"</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x: "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"y: "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">myswap(x, y);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x: "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"y: "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入两个类型为T的对象(在本例中是std::string)，这个函数通过创建三个副本来交换它们的值。因此，这个程序打印:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x: abc</span><br><span class="line">y: de</span><br><span class="line">x: de</span><br><span class="line">y: abc</span><br></pre></td></tr></table></figure><p>正如我们上节课所示，复制的效率可能很低。这个版本的swap会复制3份。这会导致大量的字符串创建和销毁，这是缓慢的。</p><p>但是，这里没有必要进行复制。我们真正要做的是交换a和b的值，用3步就可以完成! <strong>因此，如果我们从复制语义切换到移动语义，我们可以使我们的代码更具有性能。</strong></p><blockquote><p>但是，<strong>这里的问题是，参数a和b是l-value引用，而不是r-value引用，所以我们没有办法调用移动构造函数和移动赋值运算符，来替换 复制构造函数和复制赋值</strong>。默认情况下，我们获得复制构造函数和复制赋值行为。我们该怎么办?</p></blockquote><h1 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h1><p><strong>在c++ 11中，<code>std::move</code>是一个标准的库函数，它的作用只有一个——将它的参数转换成r-value。</strong>我们可以向std::move传递一个l-value，它将返回一个r-value引用。<strong>std::move在头文件：<code>utility</code>中定义。</strong></p><p>下面是与上面相同的程序，但是使用了一个myswap()函数，<u>该函数使用std::move将我们的l-values转换成r-values，这样我们就可以调用移动语义</u>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt; // for std::move⭐</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">myswap</span>(<span class="title">T</span>&amp; <span class="title">a</span>, <span class="title">T</span>&amp; <span class="title">b</span>) </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">  T tmp &#123; <span class="built_in">std</span>::<span class="built_in">move</span>(a) &#125;; <span class="comment">// invokes move constructor⭐</span></span><br><span class="line">  a = <span class="built_in">std</span>::<span class="built_in">move</span>(b); <span class="comment">// invokes move assignment⭐</span></span><br><span class="line">  b = <span class="built_in">std</span>::<span class="built_in">move</span>(tmp); <span class="comment">// invokes move assignment⭐</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> x&#123; <span class="string">"abc"</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> y&#123; <span class="string">"de"</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x: "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"y: "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">myswap(x, y);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x: "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"y: "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x: abc</span><br><span class="line">y: de</span><br><span class="line">x: de</span><br><span class="line">y: abc</span><br></pre></td></tr></table></figure><p>这样更有效率。<strong>初始化tmp时，我们使用std::move将l-value变量x转换为r-value，而不是复制x。由于参数是r-value，因此调用move语义，并将x移动到tmp中。</strong></p><blockquote><p>通过多次交换，变量x的值被移动到y, y的值也被移动到x。</p></blockquote><h1 id="在std-vector中使用std-move"><a href="#在std-vector中使用std-move" class="headerlink" title="在std::vector中使用std::move"></a>在s<code>td::vector</code>中使用<code>std::move</code></h1><p>我们还可以<strong>在填充容器的元素时使用std::move</strong>，例如使用 l-value 填充std::vector。</p><p>在接下来的程序中，我们首先使用复制语义向 向量 添加一个元素。然后使用移动语义向向量添加一个元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt; // for std::move</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; v;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"Knock"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Copying str\n"</span>;</span><br><span class="line">v.push_back(str); <span class="comment">// calls l-value version of push_back, which copies str into the array element</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"str: "</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"vector: "</span> &lt;&lt; v[<span class="number">0</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nMoving str\n"</span>;</span><br><span class="line"> </span><br><span class="line">v.push_back(<span class="built_in">std</span>::<span class="built_in">move</span>(str)); <span class="comment">// calls r-value version of push_back, which moves str into the array element</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"str: "</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"vector:"</span> &lt;&lt; v[<span class="number">0</span>] &lt;&lt; <span class="string">' '</span> &lt;&lt; v[<span class="number">1</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Copying str</span><br><span class="line">str: Knock</span><br><span class="line"><span class="built_in">vector</span>: Knock</span><br><span class="line"></span><br><span class="line">Moving str</span><br><span class="line">str:  <span class="comment">//⭐⭐⭐</span></span><br><span class="line"><span class="built_in">vector</span>: Knock Knock</span><br></pre></td></tr></table></figure><ul><li>在第一种情况下，我们向push_back()传递一个<strong>l-value</strong>，因此它使用<strong>复制语义</strong>向向量添加一个元素。<u>由于这个原因，str中的值被保留了。</u></li><li>在第二种情况下，我们向push_back()传递了一个<strong>r-value</strong> (实际上是一个通过std::move转换的l值)，因此它使用move语义向向量添加一个元素。这更有效，<strong>因为向量元素可以窃取字符串的值，而不必复制它。在本例中，str为空。</strong></li></ul><p><strong>注意，在使用移动语义后，被使用的对象（在本例为str）中的数据会被窃取给 使用移动语义的对象。所以，移动语句执行之后，被使用的对象的值将不复存在。</strong></p><h1 id="std-move在什么地方比较有用？"><a href="#std-move在什么地方比较有用？" class="headerlink" title="std::move在什么地方比较有用？"></a>std::move在什么地方比较有用？</h1><ul><li><p>在对元素数组进行排序时，<code>std::move</code>也很有用。许多排序算法(如选择排序和冒泡排序)都是通过交换元素对来实现的。在以前的课程中，我们不得不求助于复制语义来进行交换。现在我们可以使用移动语义，这是更有效的。</p></li><li><p>如果我们希望将一个智能指针管理的内容移动到另一个智能指针，它也很有用。</p></li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>当我们想把 l-value 当作 r-value 来调用 移动语义 而不是 复制语义 时，可以使用<code>std::move</code>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/移动构造函数和移动赋值</title>
      <link href="/archives/68c36619.html"/>
      <url>/archives/68c36619.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/15-3-move-constructors-and-move-assignment/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/15-3-move-constructors-and-move-assignment/</a></p><hr><p>在这节课中，我们将深入了解c++ 11如何通过<strong>移动构造函数</strong>和<strong>移动赋值</strong>来解决这些问题。</p><h1 id="复制构造函数和复制赋值"><a href="#复制构造函数和复制赋值" class="headerlink" title="复制构造函数和复制赋值"></a>复制构造函数和复制赋值</h1><p><strong>复制构造函数</strong>用于通过复制同一个类的对象来初始化一个类。</p><p><strong>复制赋值</strong>用于将一个类复制到另一个现有类。</p><blockquote><p><strong>默认情况下，如果没有显式提供，c++将提供复制构造函数和复制赋值操作符。</strong></p><p>这些编译器提供的函数执行<strong>浅拷贝</strong>，这可能会给分配动态内存的类带来问题。</p></blockquote><p>因此，处理动态内存的类应该覆盖这些函数来执行<strong>深度复制</strong>。</p><p>让我们回到本章第一节课（<a href="https://www.yuque.com/longlongqin/pw9qpx/pn4iny）的Auto_ptr智能指针类的例子，让我们看看一个实现了复制构造函数和复制赋值运算符的版本，**它可以进行深度复制**，以及一个执行这些操作的示例程序" target="_blank" rel="noopener">https://www.yuque.com/longlongqin/pw9qpx/pn4iny）的Auto_ptr智能指针类的例子，让我们看看一个实现了复制构造函数和复制赋值运算符的版本，**它可以进行深度复制**，以及一个执行这些操作的示例程序</a>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Auto_ptr3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">T* m_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Auto_ptr3(T* ptr = <span class="literal">nullptr</span>)</span><br><span class="line">:m_ptr(ptr)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">~Auto_ptr3()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_ptr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Copy constructor</span></span><br><span class="line"><span class="comment">// Do deep copy of a.m_ptr to m_ptr（深度复制）</span></span><br><span class="line">Auto_ptr3(<span class="keyword">const</span> Auto_ptr3&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">m_ptr = <span class="keyword">new</span> T;</span><br><span class="line">*m_ptr = *a.m_ptr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Copy assignment</span></span><br><span class="line"><span class="comment">// Do deep copy of a.m_ptr to m_ptr（深度复制）</span></span><br><span class="line">Auto_ptr3&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Auto_ptr3&amp; a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Self-assignment detection</span></span><br><span class="line"><span class="keyword">if</span> (&amp;a == <span class="keyword">this</span>)</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Release any resource we're holding</span></span><br><span class="line"><span class="keyword">delete</span> m_ptr;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Copy the resource</span></span><br><span class="line">m_ptr = <span class="keyword">new</span> T;</span><br><span class="line">*m_ptr = *a.m_ptr;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *m_ptr; &#125;</span><br><span class="line">T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_ptr; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNull</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_ptr == <span class="literal">nullptr</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">Auto_ptr3&lt;Resource&gt; <span class="title">generateResource</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Auto_ptr3&lt;Resource&gt; <span class="title">res</span><span class="params">(<span class="keyword">new</span> Resource)</span></span>;</span><br><span class="line"><span class="keyword">return</span> res; <span class="comment">// this return value will invoke the copy constructor</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Auto_ptr3&lt;Resource&gt; mainres;</span><br><span class="line">mainres = generateResource(); <span class="comment">// this assignment will invoke the copy assignment</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个程序中，我们使用一个名为<code>generateResource()</code>的函数来创建一个封装了资源的智能指针，然后将其传递回函数main()。函数main()然后将其赋值给一个现有的Auto_ptr3对象。</p><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Resource acquired</span><br><span class="line">Resource acquired</span><br><span class="line">Resource destroyed</span><br><span class="line">Resource acquired</span><br><span class="line">Resource destroyed</span><br><span class="line">Resource destroyed</span><br></pre></td></tr></table></figure><p><strong>对于这样一个简单的程序来说，需要创建和销毁大量的资源!这是怎么回事？</strong>让我们仔细看看。在这个程序中有6个关键步骤(每个打印消息一个):</p><ul><li><p>在generateResource()内部，使用动态分配的资源创建并初始化局部变量res，这将导致第一个“Resource acquired”。</p></li><li><p>Res通过值返回到main()。我们在这里通过值返回，因为res是一个局部变量——它不能通过地址或引用返回，因为当generateResource()结束时res将被销毁。因此res被拷贝创建到一个临时对象中。因为我们的复制构造函数做了深度复制，所以在这里分配了一个新的资源，这将导致第二个“Resource acquired”。</p></li><li><p>Res超出范围，破坏最初创建的资源，从而导致第一个“Resource destroyed”。</p></li><li><p>临时对象通过复制分配被分配给mainres。由于我们的复制赋值也是深度复制，所以会分配一个新的资源，从而导致另一个“Resource acquired”。</p></li><li><p>赋值表达式结束，临时对象超出表达式范围并被销毁，导致“Resource destroyed”。</p></li><li><p>在main()的末尾，mainres超出范围，并显示最终的“Resource destroyed”。</p></li></ul><p>因此，简而言之，因为我们调用<strong>复制构造函数</strong>一次来将构造res复制到一个临时对象，而调用<strong>复制赋值</strong>一次来将临时对象复制到mainres，我们最终总共分配和销毁了3个单独的对象。</p><p>效率很低，但至少它不会崩溃!</p><h1 id="移动构造函数和移动赋值"><a href="#移动构造函数和移动赋值" class="headerlink" title="移动构造函数和移动赋值"></a>移动构造函数和移动赋值</h1><p>但是，使用<strong>移动语义</strong>，我们可以做得更好。</p><p>c++ 11定义了两个新的函数来服务于移动语义：<strong>移动构造函数、移动赋值</strong></p><ul><li><p><strong>复制构造函数</strong>和<strong>复制赋值</strong>的目的是将一个对象复制到另一个对象；</p><blockquote><p>它的参数要求：<strong>const l-value reference parameter</strong>（const 的左值引用 作为形参）</p></blockquote></li><li><p><strong>移动构造函数</strong>和<strong>移动赋值</strong>的目标是将资源的所有权从一个对象转移到另一个对象(这比复制要便宜得多)。</p><blockquote><p>它的参数要求：<strong>non-const r-value reference parameters</strong>（非const 的右值引用 作为形参）</p></blockquote></li></ul><p>这里是与上面相同的Auto_ptr3类，使用移动构造函数和移动赋值 运算符。</p><blockquote><p>为了进行比较，我们在深度复制复制构造函数和复制赋值操作符中留了一个。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Auto_ptr4</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">T* m_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Auto_ptr4(T* ptr = <span class="literal">nullptr</span>)</span><br><span class="line">:m_ptr(ptr)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">~Auto_ptr4()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_ptr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Copy constructor</span></span><br><span class="line"><span class="comment">// Do deep copy of a.m_ptr to m_ptr</span></span><br><span class="line">Auto_ptr4(<span class="keyword">const</span> Auto_ptr4&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">m_ptr = <span class="keyword">new</span> T;</span><br><span class="line">*m_ptr = *a.m_ptr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Move constructor⭐⭐⭐</span></span><br><span class="line"><span class="comment">// Transfer ownership of a.m_ptr to m_ptr</span></span><br><span class="line">Auto_ptr4(Auto_ptr4&amp;&amp; a)</span><br><span class="line">: m_ptr(a.m_ptr)</span><br><span class="line">&#123;</span><br><span class="line">a.m_ptr = <span class="literal">nullptr</span>; <span class="comment">// we'll talk more about this line below</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Copy assignment</span></span><br><span class="line"><span class="comment">// Do deep copy of a.m_ptr to m_ptr</span></span><br><span class="line">Auto_ptr4&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Auto_ptr4&amp; a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Self-assignment detection</span></span><br><span class="line"><span class="keyword">if</span> (&amp;a == <span class="keyword">this</span>)</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Release any resource we're holding</span></span><br><span class="line"><span class="keyword">delete</span> m_ptr;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Copy the resource</span></span><br><span class="line">m_ptr = <span class="keyword">new</span> T;</span><br><span class="line">*m_ptr = *a.m_ptr;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Move assignment⭐⭐⭐</span></span><br><span class="line"><span class="comment">// Transfer ownership of a.m_ptr to m_ptr</span></span><br><span class="line">Auto_ptr4&amp; <span class="keyword">operator</span>=(Auto_ptr4&amp;&amp; a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Self-assignment detection</span></span><br><span class="line"><span class="keyword">if</span> (&amp;a == <span class="keyword">this</span>)</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Release any resource we're holding</span></span><br><span class="line"><span class="keyword">delete</span> m_ptr;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Transfer ownership of a.m_ptr to m_ptr</span></span><br><span class="line">m_ptr = a.m_ptr;</span><br><span class="line">a.m_ptr = <span class="literal">nullptr</span>; <span class="comment">// we'll talk more about this line below</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *m_ptr; &#125;</span><br><span class="line">T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_ptr; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNull</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_ptr == <span class="literal">nullptr</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">Auto_ptr4&lt;Resource&gt; <span class="title">generateResource</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Auto_ptr4&lt;Resource&gt; <span class="title">res</span><span class="params">(<span class="keyword">new</span> Resource)</span></span>;</span><br><span class="line"><span class="keyword">return</span> res; <span class="comment">// this return value will invoke the move constructor</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Auto_ptr4&lt;Resource&gt; mainres;</span><br><span class="line">mainres = generateResource(); <span class="comment">// this assignment will invoke the move assignment</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移动构造函数和移动赋值操作符很简单。我们只是移动(窃取)源对象的资源，而不是将源对象(a)深度复制到隐式对象中。这涉及到将源指针浅复制到隐式对象中，然后将源指针设置为null。</p><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Resource acquired</span><br><span class="line">Resource destroyed</span><br></pre></td></tr></table></figure><p>这就简洁很多了。</p><p>程序的流程和以前完全一样。但是，这个程序不是调用复制构造函数和复制赋值操作符，<strong>而是调用移动构造函数和移动赋值操作符。再看得深一点:</strong></p><ul><li><p>在generateResource()内部，使用动态分配的资源创建并初始化局部变量res，这将导致第一个“Resource acquired”。</p></li><li><p>Res通过值返回到main()。Res被构造成一个临时对象，将存储在Res中的动态创建的对象传递给临时对象。我们将在下面讨论为什么会发生这种情况。</p></li><li><p>Res超出了范围。因为res不再管理指针(它被移动到临时指针)，所以这里没有什么有趣的事情发生。</p></li><li><p>临时对象 被移动赋值给mainres。这将 动态创建的对象 存储到 临时对象mainres 中。</p></li><li><p>赋值表达式结束，临时对象超出表达式作用域并被销毁。但是，因为临时不再管理指针(它被移动到mainres)，所以这里也没有什么有趣的事情发生。</p></li><li><p>在main()的末尾，mainres超出范围，并显示最终的“Resource destroyed”。</p></li></ul><h1 id="移动语义的背后"><a href="#移动语义的背后" class="headerlink" title="移动语义的背后"></a>移动语义的背后</h1><p>现在您已经有了足够的上下文来理解<strong>移动语义</strong>背后的关键见解。</p><ul><li><p>如果我们构造一个对象或者做一个赋值，参数是<strong>l-value</strong>，我们唯一能做的就是*<em>复制 *</em>l-value。我们不能假定改变l-value是安全的，因为它可能在以后的程序中再次使用。如果我们有一个表达式“a = b”，我们就不会希望b会以任何方式改变。</p></li><li><p>然而，如果我们构造一个对象或者做一个赋值，其中参数是<strong>r-value</strong>，<u>那么我们知道r-value只是某种临时对象</u>。与其复制它(这可能很昂贵)，我们可以简单地将它的资源(这很便宜)转移到我们正在构造或分配的对象。这样做是安全的，因为这个临时的表达式将在表达式的最后被销毁，所以我们知道它将永远不会再被使用!</p></li></ul><p>c++ 11，通过r-value引用，使我们能够在参数是r-value还是l-value时提供不同的行为，使我们能够更聪明、更有效地决定我们的对象应该如何行为。</p><h1 id="移动函数应该始终保持两个对象处于良好定义的状态"><a href="#移动函数应该始终保持两个对象处于良好定义的状态" class="headerlink" title="移动函数应该始终保持两个对象处于良好定义的状态"></a>移动函数应该始终保持两个对象处于良好定义的状态</h1><p>在上面的例子中，移动构造函数 和 移动赋值函数 都将<code>a.m_ptr</code>设置为<code>nullptr</code>。这似乎无关紧要——毕竟，<strong>如果“a”是一个临时的r-value，如果参数“a”无论如何都将被销毁，为什么还要做“清除”呢?</strong></p><ul><li>答案很简单：<strong>当“a”超出范围时，将调用a的析构函数，<code>a.m_ptr</code>将被删除。</strong> <strong>如果在此时，<code>a.m_ptr</code>仍然指向与<code>m_ptr</code>相同的对象，然后m_ptr将保留为空悬指针。当包含m_ptr的对象最终被使用(或销毁)时，我们将得到未定义的行为。</strong></li></ul><h1 id="由“值”返回的l-value-会自动用“移动”而不是“复制”"><a href="#由“值”返回的l-value-会自动用“移动”而不是“复制”" class="headerlink" title="由“值”返回的l-value 会自动用“移动”而不是“复制”"></a>由“值”返回的l-value 会自动用“移动”而不是“复制”</h1><p>在上面Auto_ptr4示例的<code>generateResource()</code>函数中，<strong>当变量res由值返回时，它将被移动而不是复制，即使res是一个l-value。</strong></p><p>c++规范有一个特殊的规则，<strong>该规则说，从函数按值返回的自动对象可以移动，即使它们是l-value。</strong></p><blockquote><p>这是有意义的，因为res将在函数的末尾被销毁! 我们还不如窃取它的资源，而不是制造一个昂贵且不必要的副本。</p></blockquote><p>虽然编译器可以移动l-value返回值，但是在某些情况下，它甚至可以通过完全省略复制来做得更好(这避免了复制或移动)。在这种情况下，既不调用复制构造函数，也不调用移动构造函数。</p><h1 id="禁用复制"><a href="#禁用复制" class="headerlink" title="禁用复制"></a>禁用复制</h1><p>在上面的Auto_ptr4类中，我们将 复制构造函数 和 赋值运算符 留作比较之用。</p><p>但在支持<strong>移动</strong>的类中，有时需要删除 复制构造函数 和 复制赋值函数，以确保不进行复制。</p><blockquote><p>在Auto_ptr类的情况下，我们不想复制我们的模板对象T——因为它很昂贵，而且不管T是什么类，都可能不支持复制!</p></blockquote><p>这是Auto_ptr的一个版本，支持移动语义，但不支持复制语义:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Auto_ptr5</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">T* m_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Auto_ptr5(T* ptr = <span class="literal">nullptr</span>)</span><br><span class="line">:m_ptr(ptr)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">~Auto_ptr5()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_ptr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Copy constructor -- no copying allowed!⭐</span></span><br><span class="line">Auto_ptr5(<span class="keyword">const</span> Auto_ptr5&amp; a) = <span class="keyword">delete</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Move constructor⭐⭐</span></span><br><span class="line"><span class="comment">// Transfer ownership of a.m_ptr to m_ptr</span></span><br><span class="line">Auto_ptr5(Auto_ptr5&amp;&amp; a)</span><br><span class="line">: m_ptr(a.m_ptr)</span><br><span class="line">&#123;</span><br><span class="line">a.m_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Copy assignment -- no copying allowed!⭐</span></span><br><span class="line">Auto_ptr5&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Auto_ptr5&amp; a) = <span class="keyword">delete</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Move assignment⭐⭐</span></span><br><span class="line"><span class="comment">// Transfer ownership of a.m_ptr to m_ptr</span></span><br><span class="line">Auto_ptr5&amp; <span class="keyword">operator</span>=(Auto_ptr5&amp;&amp; a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Self-assignment detection</span></span><br><span class="line"><span class="keyword">if</span> (&amp;a == <span class="keyword">this</span>)</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Release any resource we're holding</span></span><br><span class="line"><span class="keyword">delete</span> m_ptr;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Transfer ownership of a.m_ptr to m_ptr</span></span><br><span class="line">m_ptr = a.m_ptr;</span><br><span class="line">a.m_ptr = <span class="literal">nullptr</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *m_ptr; &#125;</span><br><span class="line">T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_ptr; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNull</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_ptr == <span class="literal">nullptr</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果试图<strong>按值</strong>向函数传递一个 <strong>Auto_ptr5类型的l-value</strong>，编译器会报错：初始化复制构造函数参数所需的复制构造函数已被删除。</p><blockquote><p>这很好，因为我们可能应该通过const l-value引用传递Auto_ptr5 !</p></blockquote><p><strong>Auto_ptr5是(最后)一个好的智能指针类</strong>。事实上，标准库包含一个非常类似的类(您应该使用它)，名为<strong><code>std::unique_ptr</code></strong>。我们将在本章稍后讨论std::unique_ptr。</p><h2 id="测试-使用“复制”和“移动”之间的性能差别"><a href="#测试-使用“复制”和“移动”之间的性能差别" class="headerlink" title="测试 使用“复制”和“移动”之间的性能差别"></a>测试 使用“复制”和“移动”之间的性能差别</h2><p>让我们看一下另一个<u>使用动态内存</u>的类: 一个简单的动态模板化数组。该类包含一个<strong>深度复制复制构造函数</strong>和<strong>复制赋值操作符</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">DynamicArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* m_array;</span><br><span class="line"><span class="keyword">int</span> m_length;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">DynamicArray(<span class="keyword">int</span> length)</span><br><span class="line">: m_array(<span class="keyword">new</span> T[length]), m_length(length)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">~DynamicArray()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] m_array;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Copy constructor(深度复制)</span></span><br><span class="line">DynamicArray(<span class="keyword">const</span> DynamicArray &amp;arr)</span><br><span class="line">: m_length(arr.m_length)</span><br><span class="line">&#123;</span><br><span class="line">m_array = <span class="keyword">new</span> T[m_length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_length; ++i)</span><br><span class="line">m_array[i] = arr.m_array[i];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Copy assignment（深度复制）</span></span><br><span class="line">DynamicArray&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> DynamicArray &amp;arr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (&amp;arr == <span class="keyword">this</span>)</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">delete</span>[] m_array;</span><br><span class="line"></span><br><span class="line">m_length = arr.m_length;</span><br><span class="line">m_array = <span class="keyword">new</span> T[m_length];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_length; ++i)</span><br><span class="line">m_array[i] = arr.m_array[i];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_length; &#125;</span><br><span class="line">T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) &#123; <span class="keyword">return</span> m_array[index]; &#125;</span><br><span class="line"><span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_array[index]; &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以使用 <a href="https://www.learncpp.com/cpp-tutorial/8-16-timing-your-code/" target="_blank" rel="noopener">8.16 – Timing your code</a>中的函数，来测试：深度复制、移动语义 这两者实现的程序之间的性能的差别。</p><p>具体测试代码：详见<a href="https://www.learncpp.com/cpp-tutorial/15-3-move-constructors-and-move-assignment/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/15-3-move-constructors-and-move-assignment/</a> 中的“<strong>Another example</strong>”板块。</p><p>比较两个程序的运行时，0.0056 / 0.00825559 = 67.8%。移动版本几乎快了33% !</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/右值引用</title>
      <link href="/archives/145edd42.html"/>
      <url>/archives/145edd42.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/15-2-rvalue-references/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/15-2-rvalue-references/</a></p><hr><p>回到第一章，我们提到了左值和右值，然后告诉你们不要太担心它们。在c++ 11之前，这是一个公平的建议。但是在c++ 11中理解移动语义需要重新审视这个主题。现在我们来做一下。</p><h1 id="左值与右值"><a href="#左值与右值" class="headerlink" title="左值与右值"></a>左值与右值</h1><p>尽管在它们的名字中有“value”这个词，<strong>l-values和r-values实际上并不是值的属性，而是表达式的属性。</strong></p><p>c++中的每个表达式都有两个属性:</p><ul><li><p><strong>类型</strong>(用于类型检查) 和 <strong>值类别</strong>(用于某些类型的语法检查，例如表达式的结果是否可以赋值)。</p><blockquote><p>在c++ 03和更早的版本中，l-值和r-值是仅有的两个可用的值类别。</p></blockquote></li></ul><p><strong>左值：</strong></p><p><strong>将l-value(也称为locator值)</strong>： 视为<strong>函数</strong>或<strong>对象</strong> (或计算结果 为函数或对象的<strong>表达式</strong>) 是最简单的。<strong>所有的左值都有指定的内存地址。</strong></p><p>当左值最初被定义时，它们被定义为“<strong>适合位于赋值表达式左侧的值</strong>”。</p><p>但是，后来，const关键字被添加到语言中，左值被分为两个子类别:</p><ul><li>可修改的左值(其值可被修改)；</li><li>不可修改的左值(其值不可被修改)，被const限定。</li></ul><p><strong>右值：</strong></p><p>把<strong>右值</strong>看作 <strong>“不是左值的所有东西”</strong> 是最简单的。</p><blockquote><p>这显然包括<strong>文字</strong>(例如<code>5</code>)、<strong>临时值</strong>(例如<code>x+1</code> ) 和<strong>匿名对象</strong>(例如 <code>Fraction(5,2)</code>)。</p></blockquote><p>右值通常针对它们的值进行计算，<strong>具有表达式作用域(</strong>在它们所在的表达式结束时死亡)，<strong>并且不能被赋值</strong>。</p><blockquote><p>这个<strong>不能被赋值规则</strong>是有意义的，因为赋值会对对象产生副作用。</p><ul><li>因为右值有表达式作用域，如果我们将一个值赋值给右值，这个右值会在 我们在下一个表达式中使用它时 <strong>超出作用域</strong>。</li><li>或者，<strong>我们必须在表达式中多次使用具有副作用的变量</strong>(到目前为止，您应该知道导致未定义行为的原因!)</li></ul></blockquote><h2 id="3个新的值类别"><a href="#3个新的值类别" class="headerlink" title="3个新的值类别"></a>3个新的值类别</h2><p>为了支持移动语义，c++ 11引入了3个新的值类别:</p><ul><li>pr-values；</li><li>x-values；</li><li>gl-values；</li></ul><blockquote><p>如果您感兴趣， <a href="https://en.cppreference.com/w/cpp/language/value_category" target="_blank" rel="noopener">cppreference.com</a> 提供了一个广泛的表达式列表，这些表达式适用于各种值类别，以及关于它们的更多详细信息。</p></blockquote><hr><h2 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h2><p>在c++ 11之前，只有一种类型的引用存在于c++中，因此它被称为“引用”。然而，<strong>在c++ 11中，它有时被称为l-value引用</strong>。<strong>左值引用只能用 可修改的左值 初始化。</strong></p><table><thead><tr><th align="left">L-value reference</th><th align="left">Can be initialized with</th><th align="left">Can modify</th></tr></thead><tbody><tr><td align="left">Modifiable l-values</td><td align="left">Yes</td><td align="left">Yes</td></tr><tr><td align="left">Non-modifiable l-values</td><td align="left">No</td><td align="left">No</td></tr><tr><td align="left">R-values</td><td align="left">No</td><td align="left">No</td></tr></tbody></table><p><strong>被const限定的L-value对象</strong> 引用 <strong>可以用 l-values和r-values 进行初始化</strong>。<u>但是，这些值不能修改</u>。</p><table><thead><tr><th align="left">L-value reference to const</th><th align="left">Can be initialized with</th><th align="left">Can modify</th></tr></thead><tbody><tr><td align="left">Modifiable l-values</td><td align="left">Yes</td><td align="left">No</td></tr><tr><td align="left">Non-modifiable l-values</td><td align="left">Yes</td><td align="left">No</td></tr><tr><td align="left">R-values</td><td align="left">Yes</td><td align="left">No</td></tr></tbody></table><p><strong>对const对象的L-value引用特别有用，因为它们允许我们将任何类型的参数</strong>(L-value或r-value)<strong>传递到函数中，而不需要复制参数。</strong></p><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p><strong>c++ 11添加了一种称为 r-value引用 的新引用类型。</strong></p><p>r-value引用 <strong>是一个被设计为只能使用 r-value 来初始化的引用。</strong></p><blockquote><p>左值引用 的定义使用<strong>一个</strong><code>&amp;</code>符号；</p><p>右值引用 的定义使用<strong>两个</strong><code>&amp;</code>符号；</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x&#123;<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> &amp;lref&#123;x&#125;; <span class="comment">//左值引用使用 左值x 来初始化</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rref&#123;<span class="number">5</span>&#125;; <span class="comment">//右值引用使用 右值5 来初始化</span></span><br></pre></td></tr></table></figure><p><strong>右值引用 不能使用 左值来初始化。</strong></p><table><thead><tr><th align="left">R-value reference</th><th align="left">Can be initialized with</th><th align="left">Can modify</th></tr></thead><tbody><tr><td align="left">Modifiable l-values</td><td align="left">No</td><td align="left">No</td></tr><tr><td align="left">Non-modifiable l-values</td><td align="left">No</td><td align="left">No</td></tr><tr><td align="left">R-values</td><td align="left">Yes</td><td align="left">Yes</td></tr></tbody></table><table><thead><tr><th align="left">R-value reference to const</th><th align="left">Can be initialized with</th><th align="left">Can modify</th></tr></thead><tbody><tr><td align="left">Modifiable l-values</td><td align="left">No</td><td align="left">No</td></tr><tr><td align="left">Non-modifiable l-values</td><td align="left">No</td><td align="left">No</td></tr><tr><td align="left">R-values</td><td align="left">Yes</td><td align="left">No</td></tr></tbody></table><p><strong>R-value引用有两个有用的属性。</strong></p><ul><li>首先，r-value引用 将 初始化它们的对象 的生命周期延长 ( 对const对象的l-value引用也可以做到这一点)。</li><li>非常量的右值引用 允许您修改它的右值!</li></ul><p>看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_numerator;</span><br><span class="line"><span class="keyword">int</span> m_denominator;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Fraction(<span class="keyword">int</span> numerator = <span class="number">0</span>, <span class="keyword">int</span> denominator = <span class="number">1</span>) :</span><br><span class="line">m_numerator&#123; numerator &#125;, m_denominator&#123; denominator &#125;</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> Fraction &amp;f1)</span><br><span class="line">&#123;</span><br><span class="line">out &lt;&lt; f1.m_numerator &lt;&lt; <span class="string">'/'</span> &lt;&lt; f1.m_denominator;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> &amp;&amp;rref&#123; Fraction&#123; <span class="number">3</span>, <span class="number">5</span> &#125; &#125;; <span class="comment">// r-value 引用一个 临时的Fraction</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// f1 的operator&lt;&lt; 绑定到临时的Fraction，不创建副本。</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rref &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// rref (and the temporary Fraction) goes out of scope here</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3&#x2F;5</span><br></pre></td></tr></table></figure><p><u>作为一个匿名对象的<code>Fraction(3, 5)</code> 通常会在定义它的表达式结束时超出范围。</u>但是，<strong>由于我们正在用它初始化一个r-value引用，它的生命周期被延长到块的末尾。</strong>然后我们可以使用r值引用来打印Fraction的值。</p><p>现在让我们看一个不那么直观的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> &amp;&amp;rref&#123; <span class="number">5</span> &#125;; <span class="comment">// 因为我们正在用文字常量初始化一个r-value引用，所以这里创建了一个值为5的临时引用</span></span><br><span class="line">    rref = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rref &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>虽然用一个文字值初始化一个r-value引用然后能够改变那个值看起来很奇怪，但是当用一个文字值初始化一个r-value引用时，一个文字值得临时值 将被构建，所以这个引用引用的是一个临时对象，而不是一个文字值。</p><blockquote><p>在上述两种方式中，右值引用都不常用。</p></blockquote><h1 id="右值引用作为函数参数"><a href="#右值引用作为函数参数" class="headerlink" title="右值引用作为函数参数"></a>右值引用作为函数参数</h1><p>R-value引用通常用作函数参数。当您希望对l-value和r-value参数有不同的行为时，这对于函数重载非常有用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;lref)</span> <span class="comment">// l-value arguments will select this function</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"l-value reference to const\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> &amp;&amp;rref)</span> <span class="comment">// r-value arguments will select this function</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"r-value reference\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x&#123; <span class="number">5</span> &#125;;</span><br><span class="line">fun(x); <span class="comment">// l-value argument calls l-value version of function</span></span><br><span class="line">fun(<span class="number">5</span>); <span class="comment">// r-value argument calls r-value version of function</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将打印*/</span></span><br><span class="line">l-value reference to <span class="keyword">const</span></span><br><span class="line">r-value reference</span><br></pre></td></tr></table></figure><p>你为什么要这么做?我们将在下一课中更详细地讨论这个问题。<strong>不用说，它是移动语义的重要组成部分。</strong></p><p>注意一个有趣的东西：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;ref&#123;<span class="number">4</span>&#125;;</span><br><span class="line">fun(ref);</span><br></pre></td></tr></table></figure><p>这实际会调用函数的<strong>l-value版本</strong>! 虽然虽然变量ref的类型是 r-value引用一个字面常量整数，<strong>但它实际上是一个l-value本身(所有命名变量都是这样)。</strong></p><p>造成这种混淆的原因是在两个不同的上下文中使用了“右值”这个词。我们可以这样想：</p><ul><li><p><strong>被命名的对象 是 左值</strong>；<strong>匿名对象 是 右值</strong>。</p></li><li><p>无论是 命名对象 还是 匿名对象的<u>类型</u> 与它本身是 左值还是右值 无关。</p></li></ul><p><u>所以，上面的<code>ref</code>被命名了（名字就是ref），所以 对象ref 是一个左值。</u>也就是说：它是一个 右值引用 的被命名的对象。</p><h1 id="返回一个右值引用"><a href="#返回一个右值引用" class="headerlink" title="返回一个右值引用"></a>返回一个右值引用</h1><p><strong>您几乎不应该返回一个r-value引用，同理，您几乎不应该返回一个l-value引用</strong>。<strong>在大多数情况下，当被引用的对象在函数结束时超出作用域时，您将返回一个挂起的引用</strong>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/智能指针与移动语义</title>
      <link href="/archives/cace6777.html"/>
      <url>/archives/cace6777.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/15-1-intro-to-smart-pointers-move-semantics/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/15-1-intro-to-smart-pointers-move-semantics/</a></p><hr><p>考虑一个函数，我们动态分配一个值:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Resource *ptr = <span class="keyword">new</span> Resource; <span class="comment">// Resource是一个结构体或者类</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管上面的代码看起来相当简单，但是很容易忘记释放ptr。<strong>即使您记得在函数结束时删除ptr，如果函数提前退出，也有许多方法可以不删除ptr</strong>。</p><ul><li><p>通过提前返回:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Resource *ptr = <span class="keyword">new</span> Resource;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter an integer: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 函数提前返回，ptr不会被删除!</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// do stuff with ptr here</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过抛出异常:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Resource *ptr = <span class="keyword">new</span> Resource;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter an integer: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">0</span>; <span class="comment">// 函数提前返回，ptr不会被删除!</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// do stuff with ptr here</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在上述两个程序中，执行早期的return或throw语句，导致函数终止而不删除变量ptr。因此，为变量ptr分配的内存现在会泄漏(并且在每次调用此函数并提前返回时将再次泄漏)。</p><p>本质上<strong>，这类问题的发生是因为指针变量本身没有内在的机制来清除。</strong></p><h1 id="智能指针类的拯救"><a href="#智能指针类的拯救" class="headerlink" title="智能指针类的拯救?"></a>智能指针类的拯救?</h1><p><strong>类最好的一点是，它们包含析构函数，当类的对象超出作用域时，析构函数会自动执行。</strong></p><p>因此，如果在构造函数中分配(或获取)内存，可以在析构函数中释放内存，并确保在销毁类对象时释放内存(不管它是否超出作用域、是否被显式删除等等)。</p><p>这是我们在 <a href="https://www.learncpp.com/cpp-tutorial/8-7-destructors/" target="_blank" rel="noopener">8.7 – Destructors</a>中讨论的RAII编程范例的核心。</p><p>那么我们可以使用一个类来帮助我们管理和清理指针吗?我们可以!</p><p>考虑这样一个类，它的唯一工作就是持有并“拥有”传递给它的指针，然后在类对象超出作用域时释放该指针。<strong>只要该类的对象仅作为局部变量创建，我们就可以保证该类将适当地超出作用域(不管我们的函数何时或如何终止)，并且所拥有的指针将被销毁。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Auto_ptr1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">T* m_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Pass in a pointer to "own" via the constructor</span></span><br><span class="line">Auto_ptr1(T* ptr=<span class="literal">nullptr</span>)</span><br><span class="line">:m_ptr(ptr)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The destructor will make sure it gets deallocated</span></span><br><span class="line">~Auto_ptr1()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_ptr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Overload dereference and operator-&gt; so we can use Auto_ptr1 like m_ptr.</span></span><br><span class="line">T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *m_ptr; &#125;</span><br><span class="line">T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_ptr; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// A sample class to prove the above works</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">    ~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123;<span class="function">Auto_ptr1&lt;Resource&gt; <span class="title">res</span><span class="params">(<span class="keyword">new</span> Resource)</span></span>; &#125; <span class="comment">// 注意这里的内存分配</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// ... 但不需要显式删除</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 还要注意，角括号中的资源不需要 * 符号，因为它是由模板提供的</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// res超出了这里的范围，并破坏了为我们分配的资源</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Resource acquired</span><br><span class="line">Resource destroyed</span><br></pre></td></tr></table></figure><p>考虑一下这个程序和类是如何工作的。</p><ul><li><p>首先，我们动态创建一个 Resource，并将其作为参数传递给模板化的Auto_ptr1类。从这一点开始，我们的Auto_ptr1变量res拥有这个Resource对象。（Auto_ptr1与m_ptr有一个复合关系。）</p></li><li><p>因为res被声明为一个局部变量，并且具有块作用域，所以当块结束时，它将超出作用域，并被销毁(不用担心忘记释放它)。</p></li><li><p>因为它是一个类，当它被销毁时，Auto_ptr1析构函数将被调用。这个析构函数将确保它所持有的资源指针被删除!</p></li><li><p>只要Auto_ptr1被定义为一个局部变量(具有自动持续时间，因此类名的“Auto”部分)，无论函数如何终止(即使它提前终止)，资源都将保证在声明它的块的末尾被销毁。</p></li></ul><p>这样的<strong>类</strong>称为<strong>智能指针</strong>。</p><p><strong>智能指针</strong>是一个复合类，用于管理动态分配的内存，并确保在智能指针对象超出作用域时删除内存。(与此相关的是，内置指针有时被称为<strong>“哑指针”</strong>，因为它们自己不能清理)。</p><p>现在让我们回到上面的someFunction()例子，并展示一个智能指针类如何解决我们的挑战:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Auto_ptr1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">T* m_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Pass in a pointer to "own" via the constructor</span></span><br><span class="line">Auto_ptr1(T* ptr=<span class="literal">nullptr</span>)</span><br><span class="line">:m_ptr(ptr)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The destructor will make sure it gets deallocated</span></span><br><span class="line">~Auto_ptr1()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_ptr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Overload dereference and operator-&gt; so we can use Auto_ptr1 like m_ptr.</span></span><br><span class="line">T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *m_ptr; &#125;</span><br><span class="line">T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_ptr; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// A sample class to prove the above works</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">    ~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hi!\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Auto_ptr1&lt;Resource&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> Resource)</span></span>; <span class="comment">// ptr now owns the Resource</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter an integer: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// the function returns early</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// do stuff with ptr here</span></span><br><span class="line">    ptr-&gt;sayHi();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    someFunction();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用户输入一个非零整数，上面的程序将打印:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Resource acquired</span><br><span class="line">Enter an integer: 1</span><br><span class="line">Hi</span><br><span class="line">Resource destroyed</span><br></pre></td></tr></table></figure><p>如果用户输入0，以上程序将提前终止，打印:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Resource acquired</span><br><span class="line">Enter an integer: <span class="number">0</span></span><br><span class="line">Resource destroyed</span><br></pre></td></tr></table></figure><p>注意，即使在用户输入0并且函数提前终止的情况下，资源仍然被正确释放。</p><p><strong>因为ptr变量是一个局部变量，所以当函数终止时ptr将被销毁(不管它如何终止)。因为Auto_ptr1析构函数将清理资源，所以我们确信资源将被正确清理。</strong></p><h2 id="一个关键的缺陷"><a href="#一个关键的缺陷" class="headerlink" title="一个关键的缺陷"></a>一个关键的缺陷</h2><p>Auto_ptr1类有一个严重的缺陷，隐藏在一些自动生成的代码后面。在进一步阅读之前，看看您是否能够识别它是什么。我们会等待……</p><p>Rather than tell you, we’ll show you. Consider the following program:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Same as above</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Auto_ptr1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">T* m_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Auto_ptr1(T* ptr=<span class="literal">nullptr</span>)</span><br><span class="line">:m_ptr(ptr)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Auto_ptr1()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_ptr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *m_ptr; &#125;</span><br><span class="line">T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_ptr; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Auto_ptr1&lt;Resource&gt; <span class="title">res1</span><span class="params">(<span class="keyword">new</span> Resource)</span></span>;</span><br><span class="line"><span class="function">Auto_ptr1&lt;Resource&gt; <span class="title">res2</span><span class="params">(res1)</span></span>; <span class="comment">// 或者，不初始化res2，然后赋值res2 = res1;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序打印:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Resource acquired</span><br><span class="line">Resource destroyed</span><br><span class="line">Resource destroyed</span><br></pre></td></tr></table></figure><p>您的程序很可能(但不一定)会在此时崩溃。现在看到问题了吗?</p><ul><li><strong>因为我们没有提供复制构造函数或赋值运算符，c++为我们提供了一个。</strong><u>它提供的函数只做浅拷贝</u>。因此，当我们用res1初始化res2时，Auto_ptr1变量都指向相同的资源。当res2超出范围时，它会删除资源，留下一个悬空指针给res1。当res1删除它的(已删除的)资源时，崩溃!</li></ul><h2 id="使用移动语句-Move-semantics-解决"><a href="#使用移动语句-Move-semantics-解决" class="headerlink" title="使用移动语句(Move semantics)解决"></a>使用移动语句(Move semantics)解决</h2><p><strong>如果不让我们的复制构造函数和赋值操作符复制指针(“复制语义”)，<u>而是将指针的所有权从源对象转移/移动到目标对象会怎么样</u>?</strong> 这是move语义背后的核心思想。</p><blockquote><p><strong>移动语义</strong> <strong>意味着该类将转移对象的所有权，而不是复制。</strong></p></blockquote><p>让我们更新我们的Auto_ptr1类，以展示如何做到这一点:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Auto_ptr2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">T* m_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Auto_ptr2(T* ptr=<span class="literal">nullptr</span>)</span><br><span class="line">:m_ptr(ptr)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Auto_ptr2()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_ptr;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 由移动语义 实现的复制构造函数</span></span><br><span class="line">Auto_ptr2(Auto_ptr2&amp; a) <span class="comment">// note: not const</span></span><br><span class="line">&#123;</span><br><span class="line">m_ptr = a.m_ptr; <span class="comment">// 将哑指针从源对象转移到本地对象</span></span><br><span class="line">a.m_ptr = <span class="literal">nullptr</span>; <span class="comment">// 确保该指针不再拥有源对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现移动语义的赋值运算符</span></span><br><span class="line">Auto_ptr2&amp; <span class="keyword">operator</span>=(Auto_ptr2&amp; a) <span class="comment">// note: not const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (&amp;a == <span class="keyword">this</span>)</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">delete</span> m_ptr; <span class="comment">// 确保我们首先释放目标已经持有的指针</span></span><br><span class="line">m_ptr = a.m_ptr; <span class="comment">// 然后将哑指针从源对象转移到本地对象</span></span><br><span class="line">a.m_ptr = <span class="literal">nullptr</span>; <span class="comment">// 确保该指针不再拥有源对象</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *m_ptr; &#125;</span><br><span class="line">T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_ptr; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNull</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_ptr == <span class="literal">nullptr</span>;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Auto_ptr2&lt;Resource&gt; <span class="title">res1</span><span class="params">(<span class="keyword">new</span> Resource)</span></span>;</span><br><span class="line">Auto_ptr2&lt;Resource&gt; res2; <span class="comment">// Start as nullptr</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"res1 is "</span> &lt;&lt; (res1.isNull() ? <span class="string">"null\n"</span> : <span class="string">"not null\n"</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"res2 is "</span> &lt;&lt; (res2.isNull() ? <span class="string">"null\n"</span> : <span class="string">"not null\n"</span>);</span><br><span class="line"> </span><br><span class="line">res2 = res1; <span class="comment">// res2 assumes ownership, res1 is set to null</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Ownership transferred\n"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"res1 is "</span> &lt;&lt; (res1.isNull() ? <span class="string">"null\n"</span> : <span class="string">"not null\n"</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"res2 is "</span> &lt;&lt; (res2.isNull() ? <span class="string">"null\n"</span> : <span class="string">"not null\n"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Resource acquired</span><br><span class="line">res1 is not null</span><br><span class="line">res2 is null</span><br><span class="line">Ownership transferred</span><br><span class="line">res1 is null</span><br><span class="line">res2 is not null</span><br><span class="line">Resource destroyed</span><br></pre></td></tr></table></figure><p><strong>注意，我们的重载操作符<code>=</code>将m_ptr的所有权从res1赋予给了res2!</strong> <strong>因此，我们不会得到指针的副本，所有东西都会被清理干净。</strong></p><h1 id="（智能指针的）std-auto-ptr及为什么要避免使用它"><a href="#（智能指针的）std-auto-ptr及为什么要避免使用它" class="headerlink" title="（智能指针的）std::auto_ptr及为什么要避免使用它"></a>（智能指针的）<code>std::auto_ptr</code>及为什么要避免使用它</h1><p>现在是讨论<code>std::auto_ptr</code>的合适时机。</p><p><strong><code>std::auto_ptr</code>是在c++ 98中引入的，它是c++对标准化智能指针的第一次尝试。<code>std::auto_ptr</code>选择 像Auto_ptr2类 一样实现move语义。</strong></p><p><u>但是，<code>std::auto_ptr</code>(以及我们的Auto_ptr2类)有很多问题，使得使用它很危险。</u></p><ul><li><p>首先，由于<code>std::auto_ptr</code>通过<strong>复制构造函数</strong>和<strong>赋值操作符(=)</strong>实现了<strong>移动语义</strong>，因此<u>按值</u>向函数传递<code>std::auto_ptr</code>将导致您的资源被移动到函数参数处 (并在函数参数超出作用域时在函数末尾销毁)。然后，当您从调用方访问auto_ptr参数时(没有意识到它已被传输和删除)，您突然取消了对空指针的引用。崩溃!</p></li><li><p>其次，<code>std::auto_ptr</code>总是使用非数组delete删除其内容。这意味着auto_ptr不能正确地处理动态分配的数组，<u>因为它使用了错误的重新分配类型</u>。更糟糕的是，它不能阻止您向它传递一个动态数组，然后它会错误地管理这个数组，从而导致内存泄漏。</p></li><li><p>最后，auto_ptr不能很好地处理标准库中的许多其他类，包括大多数容器和算法。<strong>这是因为这些标准库类假设当它们复制一个项时，它实际上是复制 而不是移动。</strong></p></li></ul><p>由于上述缺点，<strong><code>std::auto_ptr</code>在c++ 11中已经被弃用</strong>，不应该使用。事实上，<strong><code>std::auto_ptr</code>将作为c++ 17的一部分从标准库中完全删除!</strong></p><p>规则:<code>std::auto_ptr</code>是不推荐的，不应该使用。<strong>(推荐使用<code>std::unique_ptr</code>或<code>std::shared_ptr</code>)..</strong></p><h1 id="Moving-forward"><a href="#Moving-forward" class="headerlink" title="Moving forward"></a>Moving forward</h1><p>auto_ptr的设计的核心问题是，<strong>在c++ 11之前，c++语言根本没有机制来区分“复制语义”和“移动语义”。</strong>覆盖复制语义 来实现移动语义 会导致奇怪的边缘情况和意外的错误。例如，您可以编写res1 = res2，却不知道res2是否会被更改!</p><p>因此，<strong>在c++ 11中，“移动”的概念被正式定义，“移动语义”被添加到语言中，以正确区分复制和移动。</strong>既然我们已经为移动语义的用处做好了准备，我们将在本章的其余部分探索移动语义的主题。我们还将使用移动语义修复Auto_ptr2类。</p><p>在c++ 11中，<code>std::auto_ptr</code>已经被一堆其他类型的 “移动感知”智能指针 所取代：</p><ul><li><code>std::unique_ptr</code>,</li><li><code>std::weak_ptr</code>，</li><li>以及<code>std::shared_ptr</code>。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/异常的缺点和危险</title>
      <link href="/archives/263cd357.html"/>
      <url>/archives/263cd357.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/148-exception-dangers-and-downsides/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/148-exception-dangers-and-downsides/</a></p><hr><p>与几乎所有有利因素一样，例外也有一些潜在的不利因素。本文并不是全面的，只是指出在使用异常(或决定是否使用异常)时应该考虑的一些主要问题。</p><h1 id="清理资源"><a href="#清理资源" class="headerlink" title="清理资源"></a>清理资源</h1><p>新程序员在使用异常时遇到的最大问题之一是当异常发生时清理资源的问题。考虑下面的例子:</p><ol><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    openFile(filename);</span><br><span class="line">    writeFile(filename, data);</span><br><span class="line">    closeFile(filename);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (FileException &amp;exception)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to write to file: "</span> &lt;&lt; exception.what() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果WriteFile()失败并抛出一个FileException，会发生什么情况?</p><p>此时，我们已经打开了文件，现在控制流跳转到FileException处理程序，打印错误并退出。注意，该文件从未关闭过!这个例子应该改写如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    openFile(filename);</span><br><span class="line">    writeFile(filename, data);</span><br><span class="line">    closeFile(filename);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (FileException &amp;exception)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Make sure file is closed</span></span><br><span class="line">    closeFile(filename);</span><br><span class="line">    <span class="comment">// Then write error</span></span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to write to file: "</span> &lt;&lt; exception.what() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li></li></ol><p><strong>在处理动态分配的内存时</strong>，这种错误通常以另一种形式出现:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    Person *john &#123; <span class="keyword">new</span> Person(<span class="string">"John"</span>, <span class="number">18</span>, PERSON_MALE) &#125;;</span><br><span class="line">    processPerson(john);</span><br><span class="line">    <span class="keyword">delete</span> john;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (PersonException &amp;exception)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span>&lt;&lt; <span class="string">"Failed to process person: "</span> &lt;&lt; exception.what() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果processPerson()抛出异常，控制流将跳转到catch处理程序。结果，john再也没有被释放了!</p><p>这个示例比前一个稍微复杂一些——因为john是try块的本地对象，所以当try块退出时，它就超出了作用域。</p><blockquote><p>这意味着异常处理程序根本不能访问john(它已经被销毁了)，所以它无法释放内存。</p></blockquote><p>然而，有两种相对简单的方法来解决这个问题。</p><ul><li><p>首先，<strong>在try块外部声明john</strong>，这样当try块退出时，它就不会超出作用域:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Person *john = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    john &#123; <span class="keyword">new</span> Person(<span class="string">"John"</span>, <span class="number">18</span>, PERSON_MALE) &#125;;</span><br><span class="line">    processPerson(john);</span><br><span class="line">    <span class="keyword">delete</span> john;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (PersonException &amp;exception)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> john;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to process person: "</span> &lt;&lt; exception.what() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为john声明在try块之外，所以它可以在try块和catch处理程序中访问。这意味着catch处理程序可以正确地进行清理。</p></li><li><p>第二种方法是使用<strong>类的局部变量，该变量知道在超出作用域时如何清除自身</strong>(通常称为“<strong>智能指针</strong>”)。</p><blockquote><p>标准库提供了一个名为<strong><code>std::unique_ptr</code></strong>的类，可用于此目的。</p><p><strong><code>std::unique_ptr</code>是一个保存指针的模板类，当指针超出作用域时释放它。</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // for std::unique_ptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    Person *john &#123; <span class="keyword">new</span> Person(<span class="string">"John"</span>, <span class="number">18</span>, PERSON_MALE) &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Person&gt; upJohn &#123;john&#125;;  <span class="comment">// upJohn 现在拥有 john</span></span><br><span class="line">    ProcessPerson(john);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当upJohn超出范围时，它将删除john</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (PersonException &amp;exception)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to process person: "</span> &lt;&lt; exception.what() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="异常和析构函数"><a href="#异常和析构函数" class="headerlink" title="异常和析构函数"></a>异常和析构函数</h1><p>与构造函数不同，<strong>在构造函数中抛出异常是指示对象创建未成功的一种有用方法</strong>，<strong>但是异常不应该在析构函数中抛出。</strong></p><p>当栈展开过程中从析构函数引发异常时，会发生此问题。如果发生这种情况，编译器就会处于这样一种情况: <u>它不知道是继续 栈展开过程 还是 处理新的异常</u>。——最终的结果是您的程序将立即终止。</p><p><u>因此，最好的做法就是完全避免在析构函数中使用异常。而是将消息写入日志文件。</u></p><h1 id="性能方面"><a href="#性能方面" class="headerlink" title="性能方面"></a>性能方面</h1><p>异常情况确实会带来小小的性能代价<strong>。它们会增加可执行文件的大小，而且由于必须执行额外的检查，它们还可能导致运行速度变慢。</strong> <strong>然而，异常的主要性能损失是在实际抛出异常时发生的。在这种情况下，必须释放栈并找到适当的异常处理程序，这是一个相对昂贵的操作。</strong></p><p>需要注意的是，一些现代计算机架构支持一种称为零成本异常的异常模型。零成本异常(如果受支持)在非错误情况下没有额外的运行时成本(这是我们最关心的性能情况)。然而，在发现异常的情况下，它们会招致更大的性能消耗。</p><h1 id="什么情况下使用异常？"><a href="#什么情况下使用异常？" class="headerlink" title="什么情况下使用异常？"></a>什么情况下使用异常？</h1><p>当下列各项都为真时，最好使用异常处理:</p><ul><li>正在处理的错误可能只会偶尔发生。</li><li>严重的错误，并且执行无法继续。</li><li>错误不能在它发生的地方处理。</li><li>没有一种好的方法可以将错误代码返回给调用者。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/函数try块</title>
      <link href="/archives/2b44a8c.html"/>
      <url>/archives/2b44a8c.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/14-7-function-try-blocks/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/14-7-function-try-blocks/</a></p><hr><p>Try和catch块在大多数情况下都能很好地工作，但是有一种特殊情况下它们是不充分的。考虑下面的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A(<span class="keyword">int</span> x) : m_x(x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B(<span class="keyword">int</span> x) : A(x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// What happens if creation of A fails and we want to handle it here?</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">B <span class="title">b</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Oops\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，派生类B调用基类构造函数A，这会引发异常。因为对象b的创建已经放在try块中(在main()函数中)，如果A抛出异常，main的try块会捕捉到它。因此，这个程序打印:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Oops</span><br></pre></td></tr></table></figure><p>但如果我们想在B内部捕获异常呢？在调用B构造函数的主体之前，对基构造函数A的调用通过成员初始化列表进行。没有办法在它周围包装一个标准的try块。</p><p>在这种情况下，我们必须使用一个稍微修改过的try块，称为<strong>函数try块</strong>。</p><h1 id="函数try块"><a href="#函数try块" class="headerlink" title="函数try块"></a>函数try块</h1><p><strong>函数try块的设计允许您围绕整个函数体建立异常处理程序，而不是围绕一个代码块。</strong></p><p>函数try块的语法有点难描述，所以我们将通过例子来说明:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A(<span class="keyword">int</span> x) : m_x(x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B(<span class="keyword">int</span> x) <span class="keyword">try</span> : A(x) <span class="comment">// 注意这里添加了try关键字</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (...) <span class="comment">// 注意，这与函数本身处于同一缩进级别</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 成员初始化器列表或构造函数体中的异常在这里捕获</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Exception caught\n"</span>;</span><br><span class="line"><span class="comment">// 如果这里没有显式地抛出异常，则将隐式地重新抛出当前异常</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">B <span class="title">b</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Oops\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当这个程序运行时，它产生的输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception caught</span><br><span class="line">Oops</span><br></pre></td></tr></table></figure><p>让我们更详细地研究一下这个程序。</p><ul><li><p>首先，注意在成员初始化器列表之前添加了<strong>“try”关键字</strong>。<strong>这表明在该点之后 (直到函数结束) 的所有内容都应该在try块中考虑。</strong></p></li><li><p>其次，请注意，<strong>关联的catch块与整个函数的缩进级别相同</strong>。在try关键字和函数体末尾之间抛出的任何异常都可以在这里捕获。</p></li><li><p>最后，与普通的catch块不同，<strong>它允许您解析异常、抛出新异常或重新抛出现有异常，使用函数级try块，您必须抛出或重新抛出异常。</strong> 如果您没有显式地抛出一个新的异常，或者重新抛出当前的异常(使用throw关键字本身)，该异常将被隐式地重新抛出栈。</p></li></ul><p><strong>尽管函数级try块也可以用于非成员函数</strong>，但通常不会这样做，因为很少需要这样做。<strong>它们几乎只用于构造函数!</strong></p><h1 id="函数try块可以捕获基类和当前类的异常"><a href="#函数try块可以捕获基类和当前类的异常" class="headerlink" title="函数try块可以捕获基类和当前类的异常"></a>函数try块可以捕获基类和当前类的异常</h1><p><strong>在上面的例子中，如果A和B的构造函数都抛出一个异常，它将被B的构造函数周围的try块捕获。</strong></p><p>我们可以在下面的例子中看到，我们从类B而不是类A抛出一个异常:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A(<span class="keyword">int</span> x) : m_x(x)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B(<span class="keyword">int</span> x) <span class="keyword">try</span> : A(x) <span class="comment">// note addition of try keyword here</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= <span class="number">0</span>) <span class="comment">// 把这个从A移到B</span></span><br><span class="line"><span class="keyword">throw</span> <span class="number">1</span>; <span class="comment">// 这个也被移过来</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (...)</span><br><span class="line">&#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Exception caught\n"</span>;</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// If an exception isn't explicitly thrown here, the current exception will be implicitly rethrown</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">B <span class="title">b</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Oops\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception caught</span><br><span class="line">Oops</span><br></pre></td></tr></table></figure><h1 id="不要使用函数try块来清理资源"><a href="#不要使用函数try块来清理资源" class="headerlink" title="不要使用函数try块来清理资源"></a>不要使用函数try块来清理资源</h1><p><strong>当对象构造失败时，将不调用该类的析构函数。</strong></p><p>因此，您可能会试图使用一个 函数try块 来清理一个在失败之前已经部分分配了资源的类。但是，<u>引用失败对象的成员被认为是未定义的行为，因为在catch块执行之前对象是“死”的。</u> <strong>这意味着你不能在类后使用 函数try块 来清理。</strong></p><blockquote><p>如果您希望在类之后进行清理，<strong>请遵循清理抛出异常的类的标准规则</strong>（参见<a href="https://www.learncpp.com/cpp-tutorial/145-exceptions-classes-and-inheritance/" target="_blank" rel="noopener">14.5 – Exceptions, classes, and inheritance</a>的 “当构造函数失败时(When constructor fail)” 小节）</p></blockquote><p><strong>函数try主要用于在将异常传递到栈之前记录失败，或者更改抛出异常的类型。</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/重新抛出异常</title>
      <link href="/archives/9b640ff1.html"/>
      <url>/archives/9b640ff1.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/14-6-rethrowing-exceptions/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/14-6-rethrowing-exceptions/</a></p><hr><p>有时候，您可能会遇到这样的情况:</p><p>您想要捕获异常，但又不想(或有能力 )在捕获它的时候完全处理它。当您想要记录一个错误，但是将问题传递给调用者实际处理时，这是很常见的。</p><p>当函数可以使用返回代码时，这很简单。考虑下面的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Database* <span class="title">createDatabase</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        Database *d = <span class="keyword">new</span> Database(filename);</span><br><span class="line">        d-&gt;<span class="built_in">open</span>(); <span class="comment">// assume this throws an int exception on failure</span></span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">int</span> exception)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Database creation failed</span></span><br><span class="line">        <span class="comment">// Write an error to some global logfile</span></span><br><span class="line">        g_log.logError(<span class="string">"Creation of Database failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码片段中，函数的任务是创建数据库对象、打开数据库并返回数据库对象。在出现错误的情况下(例如传入了错误的文件名)，异常处理程序记录一个错误，然后合理地返回一个空指针。</p><p>现在考虑以下函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIntValueFromDatabase</span><span class="params">(Database *d, <span class="built_in">std</span>::<span class="built_in">string</span> table, <span class="built_in">std</span>::<span class="built_in">string</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(d);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> d-&gt;getIntValue(table, key); <span class="comment">// throws int exception on failure</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">int</span> exception)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Write an error to some global logfile</span></span><br><span class="line">        g_log.logError(<span class="string">"doSomethingImportant failed"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// However, we haven't actually handled this error</span></span><br><span class="line">        <span class="comment">// So what do we do here?</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个函数成功的情况下，它返回一个整数值——任何整数值都可以是一个有效值。</p><p>但是在getIntValue()出现问题的情况下又如何呢? 在这种情况下，getIntValue()将抛出一个整数异常，该异常将被getIntValueFromDatabase()中的catch块捕获，该块将记录错误。但是，我们如何告诉getIntValueFromDatabase()的调用者出错了呢? 与上面的例子不同，这里没有一个好的返回代码可以使用(因为任何整数返回值都可能是有效的)。</p><h1 id="抛出新异常"><a href="#抛出新异常" class="headerlink" title="抛出新异常"></a>抛出新异常</h1><p>一个明显的解决方案是抛出一个新的异常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIntValueFromDatabase</span><span class="params">(Database *d, <span class="built_in">std</span>::<span class="built_in">string</span> table, <span class="built_in">std</span>::<span class="built_in">string</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(d);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> d-&gt;getIntValue(table, key); <span class="comment">// throws int exception on failure</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">int</span> exception)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Write an error to some global logfile</span></span><br><span class="line">        g_log.logError(<span class="string">"doSomethingImportant failed"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">throw</span> <span class="string">'q'</span>; <span class="comment">// throw char exception 'q' up the stack to be handled by caller of getIntValueFromDatabase()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，程序从getIntValue()获取int异常，记录错误，然后用 char值’ q ‘ 抛出一个新的异常。虽然从catch块抛出异常看起来很奇怪，但这是允许的。</p><blockquote><p><strong>请记住，只有在try块中抛出的异常才有资格被捕获。</strong></p><p><strong>这意味着在catch块中抛出的异常不会被它所在的catch块捕获。相反，它将在堆栈上传播到调用者。</strong></p></blockquote><p><u>从catch块抛出的异常可以是任何类型的异常——它不需要与刚才捕获的异常相同的类型。</u></p><h1 id="重新抛出异常-错误的方式"><a href="#重新抛出异常-错误的方式" class="headerlink" title="重新抛出异常(错误的方式)"></a>重新抛出异常(错误的方式)</h1><p>另一个选项是重新抛出相同的异常。一种方法是这样做:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIntValueFromDatabase</span><span class="params">(Database *d, <span class="built_in">std</span>::<span class="built_in">string</span> table, <span class="built_in">std</span>::<span class="built_in">string</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(d);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> d-&gt;getIntValue(table, key); <span class="comment">// throws int exception on failure</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">int</span> exception)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Write an error to some global logfile</span></span><br><span class="line">        g_log.logError(<span class="string">"doSomethingImportant failed"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">throw</span> exception;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管这种方法有效，但也有一些缺点。</p><ul><li><p>首先，它不会抛出与捕获到的异常完全相同的异常——而是抛出一个经过<strong>复制</strong>初始化的变量异常<strong>副本</strong>。</p></li><li><p>尽管编译器可以自由地省略副本，但也有可能不这么做，因此这可能会降低性能。</p></li></ul><p>但值得注意的是，考虑下面的情况:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIntValueFromDatabase</span><span class="params">(Database *d, <span class="built_in">std</span>::<span class="built_in">string</span> table, <span class="built_in">std</span>::<span class="built_in">string</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(d);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> d-&gt;getIntValue(table, key); <span class="comment">// throws Derived exception on failure</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Base &amp;exception) <span class="comment">//⭐使用引用 传入</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Write an error to some global logfile</span></span><br><span class="line">        g_log.logError(<span class="string">"doSomethingImportant failed"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">throw</span> exception; <span class="comment">// Danger: this throws a Base object, not a Derived object</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在本例中，getIntValue()抛出一个派生对象，但是catch块正在捕获一个基引用。可以这样，因为我们知道我们可以有一个派生对象的基引用。</p><p>然而，当我们抛出异常时，抛出的异常是由变量exception复制初始化的。变量exception 是 基类型，因此复制初始化的异常 也是基类型(不是派生的!)</p><p>你可以在下面的程序中看到:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> Derived();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Base&amp; b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Caught Base b, which is actually a "</span>;</span><br><span class="line">            b.<span class="built_in">print</span>();</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">            <span class="keyword">throw</span> b; <span class="comment">// the Derived object gets sliced here</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Base&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Caught Base b, which is actually a "</span>;</span><br><span class="line">        b.<span class="built_in">print</span>();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Caught Base b, which is actually a Derived</span><br><span class="line">Caught Base b, which is actually a Base</span><br></pre></td></tr></table></figure><p>结果的第二行 表明Base实际上是一个Base而不是一个派生的事实 <strong>证明派生对象是被切片的</strong>。</p><h1 id="重新抛出异常-正确的方式"><a href="#重新抛出异常-正确的方式" class="headerlink" title="重新抛出异常(正确的方式)"></a>重新抛出异常(正确的方式)</h1><p>幸运的是，<strong>C++提供了一种方法来重新抛出与刚才捕获的异常完全相同的异常。</strong> 要做到这一点，<strong><u>只需使用catch块中的 throw关键字(没有关联的变量)</u></strong>，就像这样:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> Derived();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Base&amp; b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Caught Base b, which is actually a "</span>;</span><br><span class="line">            b.<span class="built_in">print</span>();</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">            <span class="keyword">throw</span>; <span class="comment">// ⭐⭐ 注意:我们现在在这里重新抛出对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Base&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Caught Base b, which is actually a "</span>;</span><br><span class="line">        b.<span class="built_in">print</span>();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Caught Base b, which is actually a Derived</span><br><span class="line">Caught Base b, which is actually a Derived ⭐</span><br></pre></td></tr></table></figure><p><strong>这个<code>throw</code>关键字看起来不会抛出任何特定的东西，实际上会重新抛出刚才捕获的异常。不需要创建副本，这意味着我们不必担心性能问题。</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/异常、类、继承</title>
      <link href="/archives/ee7242dc.html"/>
      <url>/archives/ee7242dc.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/145-exceptions-classes-and-inheritance/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/145-exceptions-classes-and-inheritance/</a></p><hr><h1 id="异常和成员函数"><a href="#异常和成员函数" class="headerlink" title="异常和成员函数"></a>异常和成员函数</h1><p>在本教程中，到目前为止，您只看到了非成员函数中使用的异常。但是，异常在成员函数中同样有用，在重载操作符中更是如此。考虑以下重载的[]运算符作为一个简单整数数组类的一部分:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; IntArray::<span class="keyword">operator</span>[](<span class="keyword">const</span> <span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_data[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管只要索引是有效的数组索引，这个函数就可以很好地工作，但是这个函数严重缺乏一些良好的错误检查。我们可以添加一个assert语句来确保索引是有效的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; IntArray::<span class="keyword">operator</span>[](<span class="keyword">const</span> <span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    assert (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; getLength());</span><br><span class="line">    <span class="keyword">return</span> m_data[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，如果用户传入一个无效索引，操作符[]将抛出一个int异常。虽然这对于向用户指出出错的地方很有用，但有时更好的做法是静默地失败，并让调用者知道出错的地方，以便他们可以适当地处理它。</p><p>我们也可以让它抛出异常：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; IntArray::<span class="keyword">operator</span>[](<span class="keyword">const</span> <span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= getLength())</span><br><span class="line">        <span class="keyword">throw</span> index;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> m_data[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="当构造函数失败"><a href="#当构造函数失败" class="headerlink" title="当构造函数失败"></a>当构造函数失败</h1><p>构造函数是异常在类中第二个有用的地方。</p><p>如果构造函数由于某种原因必须失败(例如，用户传入了无效的输入)，只需抛出一个异常来指示对象创建失败。</p><p>在这种情况下，<strong>对象的构造被中止，所有类成员(在构造函数执行之前已经创建并初始化的类成员)按照通常的方式被销毁。</strong></p><p>但是，永远不会调用类的<u>析构函数</u>(因为对象永远不会完成构造)。</p><p>这里有一个例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Member</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Member()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Member allocated some resources\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">~Member()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Member cleaned up\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_x;</span><br><span class="line">Member m_member;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A(<span class="keyword">int</span> x) : m_x(x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~A()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"~A\n"</span>; <span class="comment">// should not be called</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Oops\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Member allocated some resources</span><br><span class="line">Member cleaned up</span><br><span class="line">Oops</span><br></pre></td></tr></table></figure><p>在上面的程序中，<strong>当类A抛出异常时，A的所有成员都被销毁</strong>。这给了m_member一个机会来清理任何被分配的资源。</p><blockquote><p>这是RAII(引用:<a href="https://www.learncpp.com/cpp-tutorial/8-7-destructors/" target="_blank" rel="noopener">8.7 – Destructors</a>)被如此推崇的部分原因——即使在不正常的情况下，正确实现RAII的类应该能够在之后进行清理</p></blockquote><h1 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h1><p>使用基本数据类型(例如int)作为异常类型的一个主要问题是，它们本质上是模糊的。一个更大的问题是，当try块中有多个语句或函数调用时，如何消除异常含义的歧义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用上面的IntArray重载运算符[]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> *value = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="built_in">array</span>[index1] + <span class="built_in">array</span>[index2]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="keyword">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 我们在这里捕捉什么?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，如果我们捕获一个int异常，它真正告诉我们什么?</p><blockquote><p>是否有一个数组索引超出了界限?</p><p>操作符+是否导致整数溢出?</p><p>操作符new是否因为内存不足而失败?</p></blockquote><p>不幸的是，在这种情况下，没有简单的方法来消除歧义。虽然我们可以抛出const char*异常来解决识别错误的问题，但这仍然不能为我们提供以不同的方式处理不同来源的异常的能力。</p><p>解决这个问题的一种方法是使用<strong>异常类(exception class)</strong>。</p><blockquote><p><strong>异常类只是一个普通的类，它是专门设计来作为异常抛出的。</strong></p></blockquote><p>让我们设计一个简单的异常类与我们的IntArray类一起使用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayException</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> m_error;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">ArrayException(<span class="built_in">std</span>::<span class="built_in">string</span> error)</span><br><span class="line">: m_error(error)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getError</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_error.c_str(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> m_data[<span class="number">3</span>]; <span class="comment">// assume array is length 3 for simplicity</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">IntArray() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">3</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">const</span> <span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= getLength())</span><br><span class="line"><span class="keyword">throw</span> ArrayException(<span class="string">"Invalid index"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> m_data[index];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">IntArray <span class="built_in">array</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> value = <span class="built_in">array</span>[<span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ArrayException &amp;exception)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"An array exception occurred ("</span> &lt;&lt; exception.getError() &lt;&lt; <span class="string">")\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这样的类，我们可以让异常 返回发生的问题的描述，它提供了出错的上下文。由于ArrayException是它自己惟一的类型，所以我们可以专门捕获数组类抛出的异常，并根据需要将它们与其他异常区别对待。</p><p>注意，<strong>异常处理程序应该 通过引用 而不是通过值 来捕获类异常对象。</strong></p><blockquote><p>这可以防止编译器复制异常，当异常是一个类对象时，复制异常的代价可能很高；</p><p>并且在处理派生异常类时防止对象切片(稍后我们将讨论这个问题)。通常应该避免通过指针捕获异常，除非您有特定的理由这样做。</p></blockquote><h1 id="异常和继承"><a href="#异常和继承" class="headerlink" title="异常和继承"></a>异常和继承</h1><p>由于可以将类作为异常抛出，并且类可以从其他类派生，因此我们需要考虑<strong>当使用继承的类作为异常时会发生什么</strong>。 <strong>事实证明，异常处理程序不仅会匹配特定类型的类，<u>还会匹配从该特定类型派生的类!</u></strong></p><p>考虑下面的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> Derived();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Base &amp;base)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"caught Base"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Derived &amp;derived)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"caught Derived"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">caught Base</span><br></pre></td></tr></table></figure><p>发生了什么？</p><p>首先，如上所述，<strong>派生类将由基类型的处理程序捕获</strong>。</p><ul><li>因为Derived来自于Base，所以Derived是 is-a Base(它们有一个is-a关系)。</li><li>其次，当c++试图为引发的异常查找处理程序时，<strong>它按顺序执行</strong>。</li></ul><p>因此，c++做的第一件事就是检查 Base异常处理程序是否与 Derived异常匹配。因为Derived is-a Base，所以答案是yes，所以它执行 类型Base 的catch块! 在这种情况下，派生的catch块甚至从未经过测试。</p><p>为了让这个例子像预期的那样工作，我们需要颠倒catch块的顺序:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> Derived();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Derived &amp;derived) <span class="comment">//将两个catch语句顺序调换一下</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"caught Derived"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Base &amp;base)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"caught Base"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样， Derived的处理程序将首先捕获派生类型的对象(在Base的处理程序之前)。Base类型的对象将不匹配派生的处理程序(Derived is-a Base，但基不是派生的)，因此将在Base处理程序 “失败”。</p><p>规则:<strong>派生异常类的处理程序应该列在基类的处理程序之前。</strong></p><h1 id="std-exception"><a href="#std-exception" class="headerlink" title="std::exception"></a><code>std::exception</code></h1><p>标准库中的许多类和操作符在失败时抛出异常类。</p><blockquote><p>例如，</p><p>如果操作符new无法分配足够的内存，则会抛出std::bad_alloc。</p><p>dynamic_cast失败将抛出std::bad_cast。</p></blockquote><p>从c++ 17开始，可以抛出25个不同的异常类，在每个后续的语言标准中还会添加更多的异常类。</p><p>好消息是，<strong>所有这些异常类都派生自一个名为<code>std::exception</code>的类。</strong><u>exception是一个很小的接口类，设计用来<strong>作为</strong> c++标准库抛出的任何异常的<strong>基类</strong>。</u></p><p>大多数情况下，当标准库抛出异常时，我们并不关心它是一个糟糕的分配、一个糟糕的强制转换还是其他什么。我们只关心发生了灾难性的错误，现在我们的程序正在爆炸。</p><p>多亏了std::exception，我们可以设置一个异常处理程序来捕获std::exception类型的异常，最终我们将在一个地方捕获std::exception和所有(21+)派生异常。简单!</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt; // for std::exception</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // for this example</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 使用标准库的代码在这里</span></span><br><span class="line"><span class="comment">// 为了举例，我们将故意触发其中一个异常</span></span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">                s.resize(<span class="number">-1</span>); <span class="comment">// 将会触发std::length_error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个处理程序将捕获std::exception 和 所有派生 的异常</span></span><br><span class="line"><span class="keyword">catch</span> (<span class="built_in">std</span>::exception &amp;exception)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Standard exception: "</span> &lt;&lt; exception.what() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Standard exception: <span class="built_in">string</span> too <span class="keyword">long</span></span><br></pre></td></tr></table></figure><p>上面的例子应该很简单。值得注意的是，std::exception有一个名为what()的虚成员函数，它返回异常 的c风格字符串描述。</p><p>大多数派生类都<strong>重写</strong>what()函数来更改消息。</p><p>请注意，此字符串仅用于描述性文本——不要将其用于比较，因为它不能保证在编译器之间是相同的。</p><p>有时，我们希望以不同的方式处理特定类型的异常。在本例中，我们可以为该特定类型添加一个处理程序，并让所有其他的处理程序“落入”基处理程序。考虑:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 使用标准库的代码在这里</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// ：这个处理程序将在这里捕获std::length_error(以及由此派生的任何异常)</span></span><br><span class="line"><span class="keyword">catch</span> (<span class="built_in">std</span>::length_error &amp;exception)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"You ran out of memory!"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个处理程序将捕获 落入在这里的 std::exception(以及从它派生的任何异常)</span></span><br><span class="line"><span class="keyword">catch</span> (<span class="built_in">std</span>::exception &amp;exception)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Standard exception: "</span> &lt;&lt; exception.what() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，std::length_error类型的异常将被第一个处理程序捕获并在那里处理。类型std::exception和所有其他派生类的异常将由第二个处理程序捕获。</p><p><strong>这样的继承层次结构允许我们使用特定的处理程序来针对特定的派生异常类，或者使用基类处理程序来捕获整个异常层次结构。这允许我们在一定程度上控制我们想要处理的异常类型，同时确保我们不需要做太多的工作来捕获层次结构中的“其他所有内容”</strong></p><h1 id="直接使用标准异常"><a href="#直接使用标准异常" class="headerlink" title="直接使用标准异常"></a>直接使用标准异常</h1><p>没有任何东西会直接抛出std::exception，您也不应该这样做。</p><p>但是，如果标准库中的其他标准异常类能够充分代表您的需求，那么您可以随意抛出它们。您可以在 <a href="http://en.cppreference.com/w/cpp/error/exception" target="_blank" rel="noopener">cppreference</a>上找到所有标准异常的列表。</p><p><strong><code>std::runtime_error</code>(在头文件：<code>stdexcept</code>中) 是一个流行的选择，因为它有一个通用的名称，它的构造函数接受一个可定制的消息:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"Bad things happened"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// This handler will catch std::exception and all the derived exceptions too</span></span><br><span class="line"><span class="keyword">catch</span> (<span class="built_in">std</span>::exception &amp;exception)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Standard exception: "</span> &lt;&lt; exception.what() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Standard exception: Bad things happened</span><br></pre></td></tr></table></figure><h1 id="从std-exception派生您自己的类"><a href="#从std-exception派生您自己的类" class="headerlink" title="从std::exception派生您自己的类"></a>从<code>std::exception</code>派生您自己的类</h1><p>当然，您可以从<code>std::exception</code>派生自己的类，并覆盖<strong>虚what() const成员函数</strong>。下面是与上面相同的程序，ArrayException派生自std::exception:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt; // for std::exception</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayException</span>:</span> <span class="keyword">public</span> <span class="built_in">std</span>::exception</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> m_error;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">ArrayException(<span class="built_in">std</span>::<span class="built_in">string</span> error)</span><br><span class="line">: m_error(error)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// return the std::string as a const C-style string</span></span><br><span class="line"><span class="comment">//const char* what() const &#123; return m_error.c_str(); &#125; // pre-C++11 version</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> m_error.c_str(); &#125; <span class="comment">// C++11 version</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> m_data[<span class="number">3</span>]; <span class="comment">// assume array is length 3 for simplicity</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">IntArray() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">3</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">const</span> <span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= getLength())</span><br><span class="line"><span class="keyword">throw</span> ArrayException(<span class="string">"Invalid index"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> m_data[index];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">IntArray <span class="built_in">array</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> value = <span class="built_in">array</span>[<span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ArrayException &amp;exception) <span class="comment">// derived catch blocks go first</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"An array exception occurred ("</span> &lt;&lt; exception.what() &lt;&lt; <span class="string">")\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="built_in">std</span>::exception &amp;exception)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Some other std::exception occurred ("</span> &lt;&lt; exception.what() &lt;&lt; <span class="string">")\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="function">An <span class="built_in">array</span> exception <span class="title">occurred</span> <span class="params">(Invalid index)</span></span></span><br></pre></td></tr></table></figure><p><strong>在c++ 11中，虚函数what()被更新为带有说明符noexcept (这意味着函数本身承诺不抛出异常)。因此，在c++ 11和更高版本中，我们的重载应该也带有说明符noexcept。</strong></p><p>由您决定是创建自己的独立异常类、使用标准异常类，还是从std::exception派生自己的异常类。根据你的目标，所有的方法都是有效的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/未捕获异常、处理所有异常、异常说明符(noexcept)</title>
      <link href="/archives/f016036.html"/>
      <url>/archives/f016036.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/144-uncaught-exceptions-catch-all-handlers-and-exception-specifiers/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/144-uncaught-exceptions-catch-all-handlers-and-exception-specifiers/</a></p><hr><p>现在，您应该对异常如何工作有了一个合理的概念。在本课中，我们将介绍一些更有趣的异常情况。</p><h1 id="未捕获异常"><a href="#未捕获异常" class="headerlink" title="未捕获异常"></a>未捕获异常</h1><p><strong>在过去的几个例子中，有相当多的情况下，一个函数假设它的调用者 (或者调用栈上的另一个函数)将处理异常。</strong></p><p>在下面的例子中，mySqrt()假设有人会处理它抛出的异常——但是实际上如果没有人处理，会发生什么情况呢?</p><p>这是我们的平方根程序再次，减去在main()中的try块:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; // for sqrt() function</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// A modular square root function</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// If the user entered a negative number, this is an error condition</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0.0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">"Can not take sqrt of negative number"</span>; <span class="comment">// throw exception of type const char*</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Look ma, no exception handler!</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sqrt of "</span> &lt;&lt; x &lt;&lt; <span class="string">" is "</span> &lt;&lt; mySqrt(x) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，假设用户输入-4, mySqrt(-4)引发一个异常。函数mySqrt()不处理异常，因此程序 栈展开 并将控制返回到main()。但是这里也没有异常处理程序，所以main()终止。此时，我们刚刚终止了我们的应用程序!</p><p><strong>当main()因未处理的异常而终止时，操作系统通常会通知您发生了未处理的异常错误。</strong></p><blockquote><p>它如何做到这一点取决于操作系统，但可能性包括打印错误消息、弹出错误对话框或简单地崩溃。</p></blockquote><h1 id="处理所有异常-Catch-all-handlers"><a href="#处理所有异常-Catch-all-handlers" class="headerlink" title="处理所有异常(Catch-all handlers)"></a>处理所有异常(Catch-all handlers)</h1><p>现在我们发现自己陷入了一个难题: <strong>函数可能抛出任何数据类型的异常，如果没有捕获到异常，它将传播到程序的顶部并导致终止。</strong></p><p>既然有可能在不知道函数是如何实现的情况下调用函数(因此也不知道它们可能抛出的异常类型)，那么我们如何才能防止这种情况的发生呢?</p><ul><li><p>幸运的是，c++为我们提供了一种机制来捕获所有类型的异常。这就是所谓的“<strong>全部捕获（catch-all handler）</strong>”处理程序。</p><p><strong>catch-all handler</strong> 程序的工作原理与普通的catch块一样，<strong>只是它没有使用特定的类型来进行catch，而是使用省略号操作符(…) 作为要进行catch的类型。</strong></p><blockquote><p>如果您回想一下第7.14课 <a href="http://www.learncpp.com/cpp-tutorial/714-ellipses-and-why-to-avoid-them/" target="_blank" rel="noopener">ellipses and why to avoid them</a> 。在以前，<strong>省略号用于向函数传递任何类型的参数</strong>。</p></blockquote></li></ul><p>在此上下文中，它们表示任何数据类型的异常。这里有一个简单的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="number">5</span>; <span class="comment">// throw an int exception</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="keyword">double</span> x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"We caught an exception of type double: "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (...) <span class="comment">// catch-all handler</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"We caught an exception of an undetermined type\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为对于int类型没有特定的异常处理程序，所以<strong>catch-all handler</strong>会捕获这个异常。这个例子产生了以下结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">We caught an exception of an undetermined type</span><br></pre></td></tr></table></figure><p><strong>catch-all handler 应该放在catch块链的最后。</strong></p><blockquote><p>这是为了确保在异常处理程序存在的情况下，异常处理程序可以根据特定的数据类型捕获异常。</p></blockquote><blockquote><p>Visual Studio强制执行这个约束——我不确定是否其他编译器也这样做。(根据下面评论中的读者Lonami的观点，GCC也是如此)。</p></blockquote><h1 id="异常说明符：noexcept"><a href="#异常说明符：noexcept" class="headerlink" title="异常说明符：noexcept"></a>异常说明符：noexcept</h1><p>c++ 11增加了第四个异常说明符:<strong>noexcept</strong>。</p><p>Noexcept是一个异常说明符，<strong>用于指示函数不能抛出异常。</strong></p><ul><li>从语义上讲，它允许您一眼就看出一个函数不会抛出异常。</li><li>它还可能启用一些编译器优化。</li><li><strong>析构函数通常是隐式noexcept</strong>（因为它们不能抛出异常）</li><li>如果noexcept函数确实试图抛出异常，那么将调用std::terminate函数来终止应用程序。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/异常、函数、栈展开</title>
      <link href="/archives/7d1f8966.html"/>
      <url>/archives/7d1f8966.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/143-exceptions-functions-and-stack-unwinding/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/143-exceptions-functions-and-stack-unwinding/</a></p><hr><h1 id="在try块之外抛出-throw-异常"><a href="#在try块之外抛出-throw-异常" class="headerlink" title="在try块之外抛出(throw)异常"></a>在try块之外抛出(throw)异常</h1><p>在上一课的示例中，throw语句直接放在try块中。如果这是必要的，那么异常处理的作用将是有限的。</p><p>异常处理最有用的属性之一是，<strong>由于异常在抛出时向上传播栈的方式，抛出语句不必直接放在try块中。</strong><u>这允许我们以更加模块化的方式使用异常处理。</u>我们将通过重写前一课的平方根程序来演示这一点，以使用模块函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; // for sqrt() function</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// A modular square root function</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// If the user entered a negative number, this is an error condition</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0.0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">"Can not take sqrt of negative number"</span>; <span class="comment">// throw exception of type const char*</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> <span class="comment">// Look for exceptions that occur within try block and route to attached catch block(s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> d = mySqrt(x);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sqrt of "</span> &lt;&lt; x &lt;&lt; <span class="string">" is "</span> &lt;&lt; d &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span>* exception) <span class="comment">// catch exceptions of type const char*</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Error: "</span> &lt;&lt; exception &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个程序中，我们将检查异常并计算平方根的代码放入名为mySqrt()的模块函数中。然后我们在try块中调用这个mySqrt()函数。让我们来验证一下它是否仍然像预期的那样工作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter a number: -4</span><br><span class="line">Error: Can not take sqrt of negative number</span><br></pre></td></tr></table></figure><h2 id="栈的展开"><a href="#栈的展开" class="headerlink" title="栈的展开"></a>栈的展开</h2><blockquote><p>让我们回顾一下异常引发时的情况。</p><ul><li>首先，程序检查异常是否可以立即处理(这意味着它是在try块中抛出的)。如果没有，当前函数将被终止，程序将检查函数的调用者是否会处理异常。如果不能，它将终止调用者并检查调用者的调用者。（一层一层的寻找处理异常的代码）</li><li>每个函数按顺序终止，直到找到异常的处理程序；或者直到main()在不处理异常的情况下终止。这个过程称为<strong>栈的展开</strong>。</li></ul></blockquote><p>现在，让我们详细了解一下，当从mySqrt()中引发异常时，它是如何应用于这个程序的。</p><ul><li>首先，程序检查异常是否从函数中的try块中抛出。(在这个例子中，它不是。)</li><li>然后，栈开始展开。<ul><li>首先,mySqrt()终止，控件返回到main()。</li><li>程序现在检查我们是否在一个try块中。我们是，并且有一个const char*处理程序，所以异常由main()中的try块处理。</li></ul></li></ul><hr><p><strong>小结这个例子</strong></p><p>mySqrt()引发异常，但是main()中的try/catch块捕获并处理异常。或者，换句话说，try块不仅从try块中的语句捕捉异常，而且还从try块中调用的函数捕捉异常。</p><p>上面程序中最有趣的部分是<strong>mySqrt()函数可以抛出异常，但是这个异常不是立即出现在try块中!</strong> 这本质上意味着：mySqrt愿意说:“嘿，有个问题!，但不愿自己处理问题。本质上，它是将处理异常的责任委托给它的调用者 (相当于使用返回代码将处理错误的责任传递回函数的调用者)。</p><p>此时，有些人可能想知道为什么将错误传递回调用者是一个好主意。<strong>为什么不直接让MySqrt()处理它自己的错误呢?</strong></p><ul><li><p>答：问题是，不同的应用程序可能希望以不同的方式处理错误。</p><ul><li>控制台应用程序可能需要打印文本消息；</li><li>windows应用程序可能希望弹出一个错误对话框。</li><li>在一个应用程序中，这可能是一个致命错误，而在另一个应用程序中可能不是。</li></ul><p>通过将错误传递回栈，每个应用程序都可以以最适合它的上下文方式处理来自mySqrt()的错误!</p></li></ul><p>最终，这将使mySqrt()尽可能模块化，并且错误处理可以放在代码中模块化程度较低的部分。</p><h1 id="另一个栈展开的例子⭐"><a href="#另一个栈展开的例子⭐" class="headerlink" title="另一个栈展开的例子⭐"></a>另一个栈展开的例子⭐</h1><p>下面是另一个使用更大堆栈进行实际堆栈展开的示例。虽然这个程序很长，但它非常简单:main()调用first()、first()调用second()、second()、second()调用third()、third()调用last()和last()抛出异常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">last</span><span class="params">()</span> <span class="comment">// called by third()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Start last\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"last throwing int exception\n"</span>;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"End last\n"</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">third</span><span class="params">()</span> <span class="comment">// called by second()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Start third\n"</span>;</span><br><span class="line">    last();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"End third\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">second</span><span class="params">()</span> <span class="comment">// called by first()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Start second\n"</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        third();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(<span class="keyword">double</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"second caught double exception\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"End second\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">first</span><span class="params">()</span> <span class="comment">// called by main()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Start first\n"</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        second();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"first caught int exception\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">double</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"first caught double exception\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"End first\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Start main\n"</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        first();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main caught int exception\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"End main\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更详细地看一下这个程序，看看您是否可以找出在运行时打印的内容和不打印的内容。答案:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Start main</span><br><span class="line">Start first</span><br><span class="line">Start second</span><br><span class="line">Start third</span><br><span class="line">Start last</span><br><span class="line">last throwing int exception</span><br><span class="line">first caught int exception</span><br><span class="line">End first</span><br><span class="line">End main</span><br></pre></td></tr></table></figure><p>让我们看看在这种情况下会发生什么。</p><blockquote><p>所有“Start”语句的打印非常简单，不需要进一步解释。</p></blockquote><ul><li><p>函数last()打印“最后一次抛出int异常”，然后抛出一个int异常。这就是事情开始变得有趣的地方。</p></li><li><p><strong>因为last()本身不处理异常，栈开始展开</strong>。函数last()立即终止，控制权返回给调用方，即third()。</p></li><li><p>函数third()不处理任何异常，因此它立即终止，控制权返回到second()。</p></li><li><p>函数second()有一个try块，而对third()的调用在其中，因此程序尝试用一个适当的catch块来匹配异常。但是，这里没有int类型的异常处理程序，所以second()立即终止，控制权返回first()。注意，<strong>整数异常没有隐式转换为匹配处理double的catch块。</strong></p></li><li><p>函数first()也有一个try块，对second()的调用也在其中，因此程序会查看是否有一个用于int异常的catch处理程序。有!因此，first()处理异常，并打印“first caught int exception”。</p></li><li><p>因为现在已经处理了异常，所以控制通常在first()中的catch块的末尾继续。这意味着first()打印“End first”，然后正常终止。</p></li><li><p>控制权返回到main()。虽然main()有一个int的异常处理程序，但是我们的异常已经被first()处理了，所以main()中的catch块不会被执行。main()简单地打印“End main”，然后正常终止。</p></li></ul><p><strong>这个例子中有很多有趣的原则:</strong></p><ul><li><p>首先，<strong>函数的直接调用者抛出异常，如果不希望处理异常 则不必处理异常。</strong>在本例中，third()没有处理last()抛出的异常。它将该职责委托给栈上的一个调用者。</p></li><li><p>其次，<strong>如果try块没有针对抛出的异常类型的catch处理程序，那么就会发生栈解除，就好像根本没有try块一样。</strong>在本例中，second()也没有处理异常，因为它没有正确的catch块类型。</p></li><li><p>第三，<strong>一旦异常得到处理，控制流就会像正常情况一样从catch块的末尾开始</strong>。本例子中，这是通过first()处理错误，然后正常终止来演示的。当程序返回main()时，异常已经被抛出并处理了——main()甚至完全不知道存在异常!</p></li></ul><p>正如您所看到的，堆栈展开为我们提供了一些非常有用的行为——<strong>如果一个函数不想处理异常，它就不需要处理异常。</strong> <strong>异常将向上传播栈，直到找到愿意这样做的人!</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/基本的异常处理</title>
      <link href="/archives/b215c449.html"/>
      <url>/archives/b215c449.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/142-basic-exception-handling/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/142-basic-exception-handling/</a></p><hr><p>在<a href="http://www.learncpp.com/cpp-tutorial/151-the-need-for-exceptions/" target="_blank" rel="noopener">the need for exceptions</a>中，我们讨论了如何使用返回代码使控制流和错误流混合在一起，从而对两者进行约束。</p><p>**C++中的异常是使用三个相互关联的关键字实现的：</p><ul><li><p><strong><code>throw</code></strong></p></li><li><p><strong><code>try</code></strong></p></li><li><p><strong><code>catch</code></strong></p></li></ul><hr><h1 id="抛出-throw-异常"><a href="#抛出-throw-异常" class="headerlink" title="抛出(throw)异常"></a>抛出(<code>throw</code>)异常</h1><p>我们在现实生活中一直使用信号来记录特定事件的发生。例如，在美式橄榄球比赛中，如果一个球员犯规了，裁判就会把一面旗子扔到地上，然后用哨子宣布比赛结束。然后评估并执行惩罚。一旦处罚被处理好，比赛通常会恢复正常。</p><p><strong>在c++中，<code>throw</code>语句 用于指示发生了异常或错误情况(考虑抛出惩罚标志)</strong>。发出 异常已经发生的 信号 通常也称为<strong>引发（raising）异常</strong>。</p><p><strong>要使用throw语句，只需使用throw关键字，后面跟一个任意数据类型的值</strong>，用来表示发生了错误。通常，该值是一个错误代码、问题描述或自定义异常类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="number">-1</span>; <span class="comment">// 抛出一个文本整数值</span></span><br><span class="line"><span class="keyword">throw</span> ENUM_INVALID_INDEX; <span class="comment">//抛出一个枚举值</span></span><br><span class="line"><span class="keyword">throw</span> <span class="string">"Can not take square root of negative number"</span>; <span class="comment">//抛出一个c样式的字符串(const char*)</span></span><br><span class="line"><span class="keyword">throw</span> dX; <span class="comment">//抛出一个在此之前定义的double型变量</span></span><br><span class="line"><span class="keyword">throw</span> MyException(<span class="string">"Fatal Error"</span>); <span class="comment">//抛出 一个 类对象：MyException</span></span><br></pre></td></tr></table></figure><p>这些语句中的每一条都充当一个信号，表示需要处理的某种问题已经发生。</p><h1 id="寻找-try-异常"><a href="#寻找-try-异常" class="headerlink" title="寻找(try)异常"></a>寻找(<code>try</code>)异常</h1><p>抛出异常只是异常处理过程的一部分。让我们回到美式足球的比喻: 一旦裁判抛出了罚球，接下来会发生什么?球员们注意到处罚已经发生，于是停止比赛。足球比赛的正常秩序被打乱了。</p><p>在c++中，<strong>我们使用<code>try</code>关键字来定义一个 语句块(称为try块)</strong>。<strong>try块充当观察者，查找try块中的任何语句 抛出的任何异常。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//可能引发您想要处理的异常的语句请转到这里</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="number">-1</span>;  <span class="comment">//这是一个简单的抛出语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<strong>try块没有定义如何处理异常。它只是告诉程序，“嘿，如果try块中的任何语句抛出异常，抓住它!”</strong></p><h1 id="处理-catch-异常"><a href="#处理-catch-异常" class="headerlink" title="处理(catch)异常"></a>处理(<code>catch</code>)异常</h1><p>最后，美式足球的比喻到此结束: 在判罚结束，比赛停止后，裁判会对判罚进行评估并执行。换句话说，在恢复正常比赛之前，必须对点球进行处理。</p><p><strong>实际处理异常是catch块的工作</strong>。<strong><code>catch</code>关键字用于 定义处理<u>单个数据类型异常</u>的代码块(称为catch块)。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (<span class="keyword">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//处理一个int类型的异常</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt;<span class="string">"We caught an int exception with value"</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Try块和catch块一起工作——Try块检测Try块中的语句抛出的任何异常，并将它们送到到适当的catch块进行处理。<strong>一个try块必须有<u>至少</u>一个catch块紧跟着它，但是可以有多个catch块按顺序列出。</strong></p><p><strong>一旦try块捕获了异常并将其送到catch块进行处理，就会认为异常已被处理，并且在catch块之后执行将恢复正常。</strong></p><p>Catch参数的工作原理与函数参数一样，<u>在后续的Catch块中可以使用该参数</u>。</p><ul><li>基本类型的异常可以通过值捕获，</li><li>但是非基本类型的异常应该通过const引用捕获，以避免不必要的复制。</li></ul><p>就像函数一样，<strong>如果参数不在catch块中使用，变量名可以省略</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (<span class="keyword">double</span>) <span class="comment">//注意:没有变量名，因为我们在下面的catch块中没有使用它</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"We caught an exception of type double"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这可以防止编译器对未使用的变量发出警告。</p><hr><h1 id="throw-try-catch-一起使用"><a href="#throw-try-catch-一起使用" class="headerlink" title="throw, try,catch  一起使用"></a><code>throw</code>, <code>try</code>,<code>catch</code> 一起使用</h1><p>这里是一个完整的程序，使用抛出，尝试，和多个捕捉块:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 可能引发您想要处理的异常的语句请转到这里</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="number">-1</span>; <span class="comment">// here's a trivial example</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在上面的try块中抛出的任何int类型的异常都会被发送到这里</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"We caught an int exception with value: "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">double</span>) <span class="comment">// 没有变量名，因为我们没有在下面的catch块中使用异常本身</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在上面的try块中，任何类型为double抛出的异常都会被发送到这里</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"We caught an exception of type double"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;str) <span class="comment">// 通过const引用捕获类</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在上面的try块中抛出的任何std::string类型的异常都会被发送到这里</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"We caught an exception of type std::string"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Continuing on our merry way\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">We caught an <span class="keyword">int</span> exception with value <span class="number">-1</span></span><br><span class="line">Continuing on our merry way</span><br></pre></td></tr></table></figure><h1 id="异常处理小结"><a href="#异常处理小结" class="headerlink" title="异常处理小结"></a>异常处理小结</h1><p>异常处理实际上非常简单，以下两段涵盖了您需要记住的大部分内容:</p><ul><li>当抛出异常(使用<strong>throw</strong>)时，程序的执行立即跳转到最近的封闭<strong>try块</strong> (如果需要找到一个封闭的try块，则向上传播栈——下一课我们将更详细地讨论这个问题)。</li><li>如果连接到<strong>try块句柄</strong>的 任何<strong>catch处理程序</strong>出现这种类型的异常，则执行该处理程序，<u>并认为该异常已得到处理。</u></li></ul><ul><li><strong>如果没有合适的catch处理程序存在，程序的执行将传播到下一个封闭的try块。如果在程序结束之前找不到合适的catch处理程序，程序将失败并出现异常错误。</strong></li></ul><p>注意，<strong>当异常与catch块匹配时，编译器不会执行隐式转换或提升</strong>!</p><ul><li>例如，char异常将与int catch块不匹配。</li><li>一个int异常将不匹配一个浮点捕获块。</li><li>但是，<strong>将执行从派生类到其父类之一的转换</strong>。</li></ul><h2 id="异常会立即处理"><a href="#异常会立即处理" class="headerlink" title="异常会立即处理"></a>异常会立即处理</h2><p>下面是一个演示如何立即处理异常的简短程序:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> </span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">4.5</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"This never prints\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">double</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"We caught a double of value: "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">We caught a <span class="keyword">double</span> of value: <span class="number">4.5</span></span><br></pre></td></tr></table></figure><p>这个程序非常简单。情况是这样的:</p><ul><li>抛出（throw）语句是执行的第一个语句——这会引发double类型的异常。</li><li>执行立即移动到最近的封闭try块，这是这个程序中惟一的try块。</li><li>然后检查catch处理程序，以查看是否有匹配的处理程序。我们的异常类型是double，因此我们正在寻找类型为double的catch处理程序。我们有一个，所以它执行。</li></ul><p>注意：</p><p>“This never prints” 是永远不会被打印的，<strong>因为异常导致执行路径立即跳转到 double类型的异常处理程序。</strong></p><h2 id="一个更真实的例子"><a href="#一个更真实的例子" class="headerlink" title="一个更真实的例子"></a>一个更真实的例子</h2><p>让我们看一个不那么学术的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"math.h"</span> <span class="comment">// for sqrt() function</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> <span class="comment">//查找try块中发生的异常，并将异常送到附加的 catch块</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果用户输入了一个负数，这是一个错误条件</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0.0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"Can not take sqrt of negative number"</span>; <span class="comment">// 抛出const char*类型的异常</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 否则，打印答案</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sqrt of "</span> &lt;&lt; x &lt;&lt; <span class="string">" is "</span> &lt;&lt; <span class="built_in">sqrt</span>(x) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span>* exception) <span class="comment">// 捕获const char*类型的异常</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Error: "</span> &lt;&lt; exception &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，要求用户输入一个数字。</p><ul><li><p><u>如果输入的是正数</u>，则If语句不执行，不会抛出异常，并打印该数字的平方根。因为在这种情况下不会抛出异常，所以catch块中的代码永远不会执行。结果是这样的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter a number: 9</span><br><span class="line">The sqrt of 9 is 3</span><br></pre></td></tr></table></figure></li><li><p><u>如果用户输入一个负数</u>，我们抛出一个const char*类型的异常。因为我们在try块中，并且找到了匹配的异常处理程序，所以控件立即转移到const char*异常处理程序。其结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter a number: -4</span><br><span class="line">Error: Can not take sqrt of negative number</span><br></pre></td></tr></table></figure></li></ul><h2 id="什么是典型的-catch块"><a href="#什么是典型的-catch块" class="headerlink" title="什么是典型的 catch块"></a>什么是典型的 catch块</h2><p>如果一个异常被送到一个catch块，<strong>即使catch块是空的，它也被认为是“已处理”的。</strong></p><p>然而，通常您会希望您的catch块做一些有用的事情。当catch块捕获异常时，通常会做三件事情:</p><ul><li>首先，catch块可能会打印错误(输出到控制台或日志文件)。</li><li>其次，catch块可能会向调用者返回一个值或错误代码。</li><li>第三，catch块可能抛出另一个异常。因为catch块位于try块之外，所以在这种情况下，新抛出的异常不是由前一个try块处理的——而是由下一个封闭的try块处理的。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/异常处理</title>
      <link href="/archives/800f51f0.html"/>
      <url>/archives/800f51f0.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/141-the-need-for-exceptions/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/141-the-need-for-exceptions/</a></p><hr><p>在<a href="http://www.learncpp.com/cpp-tutorial/712-handling-errors-assert-cerr-exit-and-exceptions/" target="_blank" rel="noopener">handling errors</a>中，我们讨论了使用<code>assert()</code>、<code>cerr()</code>和<code>exit()</code>来处理错误的方法。然而，我们现在将讨论：exceptions</p><h1 id="当返回码失败时"><a href="#当返回码失败时" class="headerlink" title="当返回码失败时"></a>当返回码失败时</h1><p>在编写可重用代码时，错误处理是必要的。处理潜在错误的最常见方法之一是通过返回代码。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFirstChar</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="built_in">string</span>, <span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> stringlength&#123;str(<span class="built_in">string</span>)&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">std</span>::<span class="keyword">size_t</span> index = <span class="number">0</span>; index &lt; stringlength; ++index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">string</span>[index] == ch)</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数返回字符串中第一个匹配ch的字符的索引。如果找不到字符，函数将返回-1作为错误指示符。</p><p>这种方法的主要优点是非常简单。<strong>然而，使用返回码有一些缺点，在非平凡的情况下很快就会变得明显:</strong></p><ul><li><p><strong>首先，返回值可能是模糊的</strong>——如果一个函数返回-1，它是试图指示一个错误，还是实际上是一个有效的返回值? 如果不深入了解函数的本质，通常很难判断。</p></li><li><p><strong>其次，函数只能返回一个值，所以当需要同时返回函数结果和错误代码时，会发生什么情况</strong>?考虑以下功能:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(x)/y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数非常需要一些错误处理，因为如果用户传入0作为参数y，它会崩溃，但是它还需要返回x/y的结果。怎么能两全其美呢?</p><blockquote><p>最常见的答案是，<strong>结果或错误处理必须作为引用参数传递回去</strong>，这使得使用起来更不方便。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">bool</span> &amp;success)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        success = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    success = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(x)/y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> success;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> result = divide(<span class="number">5</span>,<span class="number">3</span>,success);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!success)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span>&lt;&lt;<span class="string">"An error occurred"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"The answer is "</span> &lt;&lt; result &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>第三，在可能出错的代码序列中，必须经常检查错误代码。考虑一下下面的代码片段，它涉及到解析一个文本文件，寻找应该存在的值:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ifstream <span class="title">setupIni</span><span class="params">(<span class="string">"setup.ini"</span>)</span></span>; <span class="comment">// open setup.ini for reading</span></span><br><span class="line">    <span class="comment">// If the file couldn't be opened (e.g. because it was missing) return some error enum</span></span><br><span class="line">    <span class="keyword">if</span> (!setupIni)</span><br><span class="line">        <span class="keyword">return</span> ERROR_OPENING_FILE;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Now read a bunch of values from a file</span></span><br><span class="line">    <span class="keyword">if</span> (!readIntegerFromFile(setupIni, m_firstParameter)) <span class="comment">// try to read an integer from the file</span></span><br><span class="line">        <span class="keyword">return</span> ERROR_READING_VALUE; <span class="comment">// Return enum value indicating value couldn't be read</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!readDoubleFromFile(setupIni, m_secondParameter)) <span class="comment">// try to read a double from the file</span></span><br><span class="line">        <span class="keyword">return</span> ERROR_READING_VALUE;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!readFloatFromFile(setupIni, m_thirdParameter)) <span class="comment">// try to read a float from the file</span></span><br><span class="line">        <span class="keyword">return</span> ERROR_READING_VALUE;</span><br></pre></td></tr></table></figure><p>我们还没有讨论文件访问，所以如果您不理解上面的工作原理，也不要担心——只需注意这样一个事实:每个调用都需要进行错误检查并返回给调用者。</p><p>现在想象一下，如果有20个不同类型的参数——<strong>您实际上是在检查一个错误并返回ERROR_READING_VALUE 20次!所有这些错误检查和返回值 使得确定函数要执行的操作更加难以识别。</strong></p></li><li><p>第四，<strong>返回代码不能很好地与构造函数混合</strong>。如果你在创建一个对象，构造函数里面的一些东西出了灾难性的错误，会发生什么？构造函数没有返回类型来返回状态指示器，并且通过引用参数返回一个状态指示器是混乱的，必须显式地检查。而且，即使这样做，仍然会创建对象，然后必须处理或释放对象。</p></li><li><p>最后，当向调用方返回错误代码时，调用方可能并不总是能够处理错误。如果调用者不想处理错误，它要么忽略它(在这种情况下，它将永远丢失)，要么将错误返回到调用它的函数。这可能是混乱的，并导致许多相同的问题上面提到。</p></li></ul><p>总之，<strong>返回代码的主要问题是错误处理代码最终复杂地链接到代码的正常控制流</strong>。这反过来又限制了代码的布局，以及如何合理地处理错误。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><strong>异常处理</strong>提供了一种机制，<strong>可以将错误或其他异常情况的处理与代码的典型控制流分离开来</strong>。这允许在特定情况下更自由地处理错误，减轻了返回代码造成的混乱(如果不是全部的话)。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/指针的局部模板专门化</title>
      <link href="/archives/db2a8c7a.html"/>
      <url>/archives/db2a8c7a.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/13-8-partial-template-specialization-for-pointers/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/13-8-partial-template-specialization-for-pointers/</a></p><hr><p>在 <a href="https://www.learncpp.com/cpp-tutorial/13-5-function-template-specialization/" target="_blank" rel="noopener">13.5 – Function template specialization</a>中，我们看了一个简单的模板化 Storage类:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Storage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T m_value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Storage(T value)</span><br><span class="line">    &#123;</span><br><span class="line">         m_value = value;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~Storage()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们指出，当模板参数T为char*类型时，该类会出现问题，这是因为构造函数中发生了浅拷贝/指针赋值。在那节课中，我们使用完整的模板专门化来创建char*类型的存储构造函数的专门化版本，它分配内存并创建m_value的实际深度副本。作为参考，这里是完全专门化的char*存储构造函数和析构函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 您需要包含上面示例中的Storage类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line">Storage&lt;<span class="keyword">char</span>*&gt;::Storage(<span class="keyword">char</span>* value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Figure out how long the string in value is</span></span><br><span class="line">    <span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (value[length] != <span class="string">'\0'</span>)</span><br><span class="line">        ++length;</span><br><span class="line">    ++length; <span class="comment">// +1 to account for null terminator</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Allocate memory to hold the value string</span></span><br><span class="line">    m_value = <span class="keyword">new</span> <span class="keyword">char</span>[length];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Copy the actual value string into the m_value memory we just allocated</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count &lt; length; ++count)</span><br><span class="line">        m_value[count] = value[count];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line">Storage&lt;<span class="keyword">char</span>*&gt;::~Storage()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] m_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这对于存储非常有效，但是其他指针类型(例如int*)又如何呢?很容易看出，如果T是任何指针类型，那么我们就会遇到构造函数执行指针赋值的问题，而不是创建被指向的元素的实际深度副本。</p><p><u>因为完全的模板专门化迫使我们完全解析模板类型，为了解决这个问题，我们必须为我们想要使用Storage的每个指针类型定义一个新的专门化构造函数(和析构函数)!</u> 这将导致大量重复的代码，正如您现在所知道的，这是我们希望尽可能避免的。</p><h1 id="指针的局部模板专门化"><a href="#指针的局部模板专门化" class="headerlink" title="指针的局部模板专门化"></a>指针的局部模板专门化</h1><h2 id="一次只复制一个值"><a href="#一次只复制一个值" class="headerlink" title="一次只复制一个值"></a>一次只复制一个值</h2><p>幸运的是，<strong>局部模板专门化</strong>为我们提供了一个方便的解决方案。在本例中，我们将使用<strong>类局部模板专门化来定义用于指针值的存储类的特殊版本</strong>。这个类被认为是部分专门化的，<u>因为我们告诉编译器它只用于指针类型，即使我们没有精确地指定底层类型。</u></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 您需要包含上面示例中的Storage类</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span>&lt;T*&gt; // 这是使用指针类型的 <span class="title">Storage</span>的部分专门化</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* m_value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Storage(T* value) <span class="comment">// for pointer type T</span></span><br><span class="line">    &#123;</span><br><span class="line">         <span class="comment">// 对于指针，我们将进行深度复制</span></span><br><span class="line">         m_value = <span class="keyword">new</span> T(*value); <span class="comment">// 它只复制一个值，而不是一个数组</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~Storage()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_value; <span class="comment">// 这里我们用的是标量delete，不是数组delete</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *m_value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这方面的一个例子是:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Declare a non-pointer Storage to show it works</span></span><br><span class="line"><span class="function">Storage&lt;<span class="keyword">int</span>&gt; <span class="title">myint</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">myint.<span class="built_in">print</span>();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Declare a pointer Storage to show it works</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">7</span>;</span><br><span class="line"><span class="function">Storage&lt;<span class="keyword">int</span>*&gt; <span class="title">myintptr</span><span class="params">(&amp;x)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 如果myintptr在x上做了一个指针赋值，</span></span><br><span class="line"><span class="comment">// 那么改变x也会改变myintptr</span></span><br><span class="line">x = <span class="number">9</span>;</span><br><span class="line">myintptr.<span class="built_in">print</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><p>当myintptr使用int* template参数定义时，编译器会看到我们已经定义了一个部分专用的模板类，它可以使用任何指针类型，并使用该模板实例化一个版本的 Storage。</p><p>该类的构造函数创建了参数x的<strong>深度副本</strong>。稍后，当我们将x更改为9时，将创建myintptr。m_value不受影响，因为它指向的是它自己的单独的值副本。</p><blockquote><p>如果部分模板专门化类不存在，myintptr将使用模板的普通(非部分专门化)版本。该类的构造函数执行一个浅复制指针赋值，这意味着myintptr。m_value和x将引用相同的地址。然后，当我们将x的值更改为9时，我们也会更改myintptr的值。</p></blockquote><h2 id="复制整个字符串"><a href="#复制整个字符串" class="headerlink" title="复制整个字符串"></a>复制整个字符串</h2><p>值得注意的是，因为这个部分专门化的存储类只为c风格的字符串分配一个值，所以只复制第一个字符。</p><p><strong>如果希望复制整个字符串，可以完全专门化char*类型的构造函数(和析构函数)。</strong> <strong>完全专门化的版本将优先于部分专门化的版本</strong>。</p><p>下面是一个示例程序，<u>它对指针使用部分专门化，对char*使用完全专门化</u>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 非指针的Storage类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Storage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T m_value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Storage(T value)</span><br><span class="line">&#123;</span><br><span class="line">m_value = value;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">~Storage()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 指针的Storage类的局部专门化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Storage</span>&lt;T*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* m_value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Storage(T* value)</span><br><span class="line">&#123;</span><br><span class="line">m_value = <span class="keyword">new</span> T(*value);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">~Storage()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_value;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *m_value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// char*类型的构造函数的完全专门化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line">Storage&lt;<span class="keyword">char</span>*&gt;::Storage(<span class="keyword">char</span>* value)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Figure out how long the string in value is</span></span><br><span class="line"><span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (value[length] != <span class="string">'\0'</span>)</span><br><span class="line">++length;</span><br><span class="line">++length; <span class="comment">// +1 to account for null terminator</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Allocate memory to hold the value string</span></span><br><span class="line">m_value = <span class="keyword">new</span> <span class="keyword">char</span>[length];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Copy the actual value string into the m_value memory we just allocated</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; length; ++count)</span><br><span class="line">m_value[count] = value[count];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// char*类型的析构函数的完全专门化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line">Storage&lt;<span class="keyword">char</span>*&gt;::~Storage()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] m_value;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// char*类型的打印功能的完全专门化</span></span><br><span class="line"><span class="comment">//如果没有这个，打印会调用Storage&lt;T*&gt;::print()，它只打印第一个元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> Storage&lt;<span class="keyword">char</span>*&gt;::<span class="built_in">print</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_value;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Declare a non-pointer Storage to show it works</span></span><br><span class="line"><span class="function">Storage&lt;<span class="keyword">int</span>&gt; <span class="title">myint</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">myint.<span class="built_in">print</span>();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Declare a pointer Storage to show it works</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">7</span>;</span><br><span class="line"><span class="function">Storage&lt;<span class="keyword">int</span>*&gt; <span class="title">myintptr</span><span class="params">(&amp;x)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// If myintptr did a pointer assignment on x,</span></span><br><span class="line"><span class="comment">// then changing x will change myintptr too</span></span><br><span class="line">x = <span class="number">9</span>;</span><br><span class="line">myintptr.<span class="built_in">print</span>();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Dynamically allocate a temporary string</span></span><br><span class="line"><span class="keyword">char</span> *name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">40</span>]&#123; <span class="string">"Alex"</span> &#125;; <span class="comment">// requires C++14</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// If your compiler isn't C++14 compatible, comment out the above line and uncomment these</span></span><br><span class="line"><span class="comment">//char *name = new char[40];</span></span><br><span class="line"><span class="comment">//strcpy(name, "Alex");</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Store the name</span></span><br><span class="line"><span class="function">Storage&lt; <span class="keyword">char</span>*&gt; <span class="title">myname</span><span class="params">(name)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Delete the temporary string</span></span><br><span class="line"><span class="keyword">delete</span>[] name;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Print out our name</span></span><br><span class="line">myname.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line">Alex</span><br></pre></td></tr></table></figure><p><strong>使用部分模板类专门化来创建类的 单独指针 和 非指针实现，当您希望类以完全透明的方式分别处理这两种情况时，这是非常有用的。</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/局部模板专门化</title>
      <link href="/archives/a3ee11a9.html"/>
      <url>/archives/a3ee11a9.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/137-partial-template-specialization/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/137-partial-template-specialization/</a></p><hr><p>本课和下一课是那些希望对c++模板有更深入了解的人的选读。局部模板专门化并不经常使用(但是在特定的情况下很有用)。</p><h1 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h1><p>让我们再看一下我们在前面的例子中使用的静态数组类:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">size</span>&gt; // <span class="title">size</span> <span class="title">is</span> <span class="title">the</span> <span class="title">expression</span> <span class="title">parameter</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">StaticArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// The expression parameter controls the size of the array</span></span><br><span class="line">    T m_array[<span class="built_in">size</span>]&#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T* <span class="title">getArray</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_array; &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_array[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该类接受两个模板参数，<strong>一个类型参数</strong>和<strong>一个表达式参数</strong>。</p><h2 id="实现打印整个数组"><a href="#实现打印整个数组" class="headerlink" title="实现打印整个数组"></a>实现打印整个数组</h2><p>现在，<u>假设我们要写一个函数来输出整个数组</u>。虽然我们可以将它作为一个成员函数来实现，但我们将它作为一个非成员函数来实现，因为它将使后续的例子更容易理解。</p><p>使用模板，我们可以这样写:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> <span class="built_in">size</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(StaticArray&lt;T, <span class="built_in">size</span>&gt; &amp;<span class="built_in">array</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count&#123; <span class="number">0</span> &#125;; count &lt; <span class="built_in">size</span>; ++count)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[count] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将使我们能够做到以下几点:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">size</span>&gt; // <span class="title">size</span> <span class="title">is</span> <span class="title">the</span> <span class="title">expression</span> <span class="title">parameter</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">StaticArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// The expression parameter controls the size of the array</span></span><br><span class="line">T m_array[<span class="built_in">size</span>]&#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">T* <span class="title">getArray</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_array; &#125;</span><br><span class="line"> </span><br><span class="line">T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_array[index];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> <span class="built_in">size</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(StaticArray&lt;T, <span class="built_in">size</span>&gt; &amp;<span class="built_in">array</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> count&#123; <span class="number">0</span> &#125;; count &lt; <span class="built_in">size</span>; ++count)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[count] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// declare an int array</span></span><br><span class="line">StaticArray&lt;<span class="keyword">int</span>, <span class="number">4</span>&gt; int4&#123;&#125;;</span><br><span class="line">int4[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">int4[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">int4[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">int4[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Print the array</span></span><br><span class="line"><span class="built_in">print</span>(int4);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p>虽然这是可行的，但它有一个设计缺陷。考虑以下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// declare a char array</span></span><br><span class="line">    StaticArray&lt;<span class="keyword">char</span>, <span class="number">14</span>&gt; char14&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">strcpy</span>(char14.getArray(), <span class="string">"Hello, world!"</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Print the array</span></span><br><span class="line">    <span class="built_in">print</span>(char14);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(我们在 <a href="https://www.learncpp.com/cpp-tutorial/66-c-style-strings/" target="_blank" rel="noopener">6.6 – C-style strings</a>学习了std::strcpy，如果你需要复习的话)</p><p>这个程序将编译、执行并生成以下值(或类似的值):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">H e l l o ,   w o r l d !</span><br></pre></td></tr></table></figure><p>对于非char类型，在每个数组元素之间放一个空格是有意义的，这样它们就不会一起运行。<u>但是，对于char类型，打印所有以c样式字符串运行的内容更有意义，而我们的print()函数并没有这样做</u>。</p><h2 id="如何修复"><a href="#如何修复" class="headerlink" title="如何修复?"></a>如何修复?</h2><h3 id="1、模板专门化"><a href="#1、模板专门化" class="headerlink" title="1、模板专门化"></a>1、模板专门化</h3><p>首先考虑使用模板专门化。<strong>完全模板专门化的问题是必须显式定义所有模板参数</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">size</span>&gt; // <span class="title">size</span> <span class="title">is</span> <span class="title">the</span> <span class="title">expression</span> <span class="title">parameter</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">StaticArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// The expression parameter controls the size of the array</span></span><br><span class="line">T m_array[<span class="built_in">size</span>]&#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">T* <span class="title">getArray</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_array; &#125;</span><br><span class="line"> </span><br><span class="line">T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_array[index];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> <span class="built_in">size</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(StaticArray&lt;T, <span class="built_in">size</span>&gt; &amp;<span class="built_in">array</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> count&#123; <span class="number">0</span> &#125;; count &lt; <span class="built_in">size</span>; ++count)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[count] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Override print() for fully specialized StaticArray&lt;char, 14&gt;</span></span><br><span class="line"><span class="comment">// 使用模板专门化，所以必须显式的定义所有模板参数。⭐⭐</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(StaticArray&lt;<span class="keyword">char</span>, <span class="number">14</span>&gt; &amp;<span class="built_in">array</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> count&#123; <span class="number">0</span> &#125;; count &lt; <span class="number">14</span>; ++count)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[count];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// declare a char array</span></span><br><span class="line">    StaticArray&lt;<span class="keyword">char</span>, <span class="number">14</span>&gt; char14&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">strcpy</span>(char14.getArray(), <span class="string">"Hello, world!"</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Print the array</span></span><br><span class="line">    <span class="built_in">print</span>(char14);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如您所见，我们现在为完全专门化的StaticArray提供了一个重载的打印函数。事实上,这种打印:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, world!</span><br></pre></td></tr></table></figure><h4 id="有隐患"><a href="#有隐患" class="headerlink" title="有隐患"></a>有隐患</h4><p>虽然这解决了使用StaticArray调用print()的问题，但它带来了另一个问题: <strong>使用完整的模板专门化意味着我们必须显式地定义这个函数将接受的数组的长度</strong>! 考虑下面的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// declare a char array</span></span><br><span class="line">    StaticArray&lt;<span class="keyword">char</span>, <span class="number">12</span>&gt; char12&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">strcpy</span>(char12.getArray(), <span class="string">"Hello, mom!"</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Print the array</span></span><br><span class="line">    <span class="built_in">print</span>(char12);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用char12调用 print()将调用 接受<code>StaticArray&lt;T, size&gt;</code>的print()版本，因为char12的类型是<code>StaticArray&lt;char, 12&gt;</code>，而我们重载的print()只有在传递<code>StaticArray&lt;char, 14&gt;</code>时才会被调用。</strong></p><p>虽然我们可以创建一个print()的副本来处理StaticArray，但是当我们调用数组大小为5或22的print()时会发生什么呢?我们需要复制每个不同数组大小的函数。这是多余的。</p><p><strong>显然，完全模板专门化在这里是一种限制性太强的解决方案。我们正在寻找的解决方案是：<u>局部模板专门化</u>。</strong></p><h3 id="2、局部模板专门化⭐⭐⭐"><a href="#2、局部模板专门化⭐⭐⭐" class="headerlink" title="2、局部模板专门化⭐⭐⭐"></a>2、局部模板专门化⭐⭐⭐</h3><p><strong>局部模板专门化允许我们专门化类</strong>(但不是单独的函数!)， <strong>其中一些(但不是所有)模板参数已被显式定义</strong>。</p><p>对于上面的挑战，理想的解决方案是让重载的打印函数使用char类型的StaticArray，但保留长度表达式参数模板，以便根据需要进行更改。局部模板专门化允许我们这样做!</p><p>下面是一个重载打印函数的例子，它使用了一个部分专门化的StaticArray:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// print()函数的重载，用于部分特殊的StaticArray&lt;char, size&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> <span class="built_in">size</span>&gt; <span class="comment">// size仍然是一个模板化的表达式参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(StaticArray&lt;<span class="keyword">char</span>, <span class="built_in">size</span>&gt; &amp;<span class="built_in">array</span>)</span> <span class="comment">// 我们在这里显式定义了char类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> count&#123; <span class="number">0</span> &#125;; count &lt; <span class="built_in">size</span>; ++count)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如您在这里看到的，<strong>我们已经明确声明这个函数只适用于char类型的StaticArray，但是size仍然是一个模板化的表达式参数，所以它适用于任何大小的char数组。</strong>就是这样!</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>注意，从c++ 14开始，<strong>部分模板专门化只能用于类，而不能用于函数模板(函数必须完全专门化)</strong>。我们的void print(StaticArray &amp;array)示例可以工作，因为print函数不是部分专门化的(<u>它只是使用了部分专门化的类参数的重载函数</u>)。</p><h1 id="成员函数的局部模板专门化"><a href="#成员函数的局部模板专门化" class="headerlink" title="成员函数的局部模板专门化"></a>成员函数的局部模板专门化</h1><h2 id="函数模板不能局部专门化"><a href="#函数模板不能局部专门化" class="headerlink" title="函数模板不能局部专门化"></a>函数模板不能局部专门化</h2><p>在处理成员函数时，对函数局部专门化的限制可能会导致一些挑战。例如，如果我们像这样定义StaticArray呢?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">size</span>&gt; // <span class="title">size</span> <span class="title">is</span> <span class="title">the</span> <span class="title">expression</span> <span class="title">parameter</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">StaticArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// The expression parameter controls the size of the array</span></span><br><span class="line">    T m_array[<span class="built_in">size</span>]&#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T* <span class="title">getArray</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_array; &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_array[index];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i&#123; <span class="number">0</span> &#125;; i &lt; <span class="built_in">size</span>; ++i)</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_array[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>print()现在是 <code>StaticArray&lt;T, int&gt;</code>类的成员函数。那么，当我们想要 部分专门化print()以使其工作方式不同时，会发生什么情况呢?你可以试试这个:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Doesn't work</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> <span class="built_in">size</span>&gt;</span><br><span class="line"><span class="keyword">void</span> StaticArray&lt;<span class="keyword">double</span>, <span class="built_in">size</span>&gt;::<span class="built_in">print</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i&#123; <span class="number">0</span> &#125;; i &lt; <span class="built_in">size</span>; ++i)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::scientific &lt;&lt; m_array[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不幸的是，这不起作用，因为我们试图部分专门化一个函数，这是不允许的。</p><h2 id="让整个类部分专门化"><a href="#让整个类部分专门化" class="headerlink" title="让整个类部分专门化"></a>让整个类部分专门化</h2><p>那么我们该如何解决这个问题呢?一个明显的方法是让整个类部分专门化:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">size</span>&gt; // <span class="title">size</span> <span class="title">is</span> <span class="title">the</span> <span class="title">expression</span> <span class="title">parameter</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">StaticArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// The expression parameter controls the size of the array</span></span><br><span class="line">T m_array[<span class="built_in">size</span>]&#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">T* <span class="title">getArray</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_array; &#125;</span><br><span class="line"> </span><br><span class="line">T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_array[index];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i&#123; <span class="number">0</span> &#125;; i &lt; <span class="built_in">size</span>; ++i)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_array[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//局部专门化 整个类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> <span class="built_in">size</span>&gt; <span class="comment">// size is the expression parameter</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticArray</span>&lt;double, size&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// The expression parameter controls the size of the array</span></span><br><span class="line"><span class="keyword">double</span> m_array[<span class="built_in">size</span>]&#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">double</span>* <span class="title">getArray</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_array; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">double</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_array[index];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i&#123; <span class="number">0</span> &#125;; i &lt; <span class="built_in">size</span>; ++i)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::scientific &lt;&lt; m_array[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// declare an integer array with room for 6 integers</span></span><br><span class="line">StaticArray&lt;<span class="keyword">int</span>, <span class="number">6</span>&gt; intArray&#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Fill it up in order, then print it</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> count&#123; <span class="number">0</span> &#125;; count &lt; <span class="number">6</span>; ++count)</span><br><span class="line">intArray[count] = count;</span><br><span class="line"> </span><br><span class="line">intArray.<span class="built_in">print</span>();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// declare a double buffer with room for 4 doubles</span></span><br><span class="line">StaticArray&lt;<span class="keyword">double</span>, <span class="number">4</span>&gt; doubleArray&#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> count&#123; <span class="number">0</span> &#125;; count &lt; <span class="number">4</span>; ++count)</span><br><span class="line">doubleArray[count] = (<span class="number">4.0</span> + <span class="number">0.1</span> * count);</span><br><span class="line"> </span><br><span class="line">doubleArray.<span class="built_in">print</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>虽然它可以工作，但这不是一个很好的解决方案，因为我们必须复制很多代码，从<code>StaticArray&lt;T, size&gt;</code>至 <code>StaticArray&lt;double, size&gt;</code></strong></p><h2 id="使用一个公共基类，使派生类模板局部专门化⭐⭐⭐"><a href="#使用一个公共基类，使派生类模板局部专门化⭐⭐⭐" class="headerlink" title="使用一个公共基类，使派生类模板局部专门化⭐⭐⭐"></a>使用一个公共基类，使派生类模板局部专门化⭐⭐⭐</h2><p>如果有办法在<code>StaticArray&lt;double, size&gt;</code>中 重用StaticArray&lt;T, size&gt;中的代码 。听起来像是<strong>继承</strong>的工作!</p><p>幸运的是，有一个变通方法，通过<strong>使用一个公共基类</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">size</span>&gt; // <span class="title">size</span>是表达式参数</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">StaticArray_Base</span>  //基类⭐</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">// The expression parameter controls the size of the array</span></span><br><span class="line">T m_array[<span class="built_in">size</span>]&#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">T* <span class="title">getArray</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_array; &#125;</span><br><span class="line"> </span><br><span class="line">T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_array[index];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i&#123; <span class="number">0</span> &#125;; i &lt; <span class="built_in">size</span>; ++i)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_array[i];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">virtual</span> ~StaticArray_Base() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//派生类1⭐</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">size</span>&gt; // <span class="title">size</span> <span class="title">is</span> <span class="title">the</span> <span class="title">expression</span> <span class="title">parameter</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">StaticArray</span>:</span> <span class="keyword">public</span> StaticArray_Base&lt;T, <span class="built_in">size</span>&gt; </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//派生类2⭐</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> <span class="built_in">size</span>&gt; <span class="comment">// size is the expression parameter</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticArray</span>&lt;double, size&gt;:</span> <span class="keyword">public</span> StaticArray_Base&lt;<span class="keyword">double</span>, <span class="built_in">size</span>&gt; <span class="comment">//注意这里的格式⭐</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i&#123; <span class="number">0</span> &#125;; i &lt; <span class="built_in">size</span>; ++i)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::scientific &lt;&lt; <span class="keyword">this</span>-&gt;m_array[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="comment">// note: The this-&gt; prefix in the above line is needed.</span></span><br><span class="line"><span class="comment">// See https://stackoverflow.com/a/6592617 or https://isocpp.org/wiki/faq/templates#nondependent-name-lookup-members for more info on why.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// declare an integer array with room for 6 integers</span></span><br><span class="line">StaticArray&lt;<span class="keyword">int</span>, <span class="number">6</span>&gt; intArray&#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Fill it up in order, then print it</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> count&#123; <span class="number">0</span> &#125;; count &lt; <span class="number">6</span>; ++count)</span><br><span class="line">intArray[count] = count;</span><br><span class="line"> </span><br><span class="line">intArray.<span class="built_in">print</span>();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// declare a double buffer with room for 4 doubles</span></span><br><span class="line">StaticArray&lt;<span class="keyword">double</span>, <span class="number">4</span>&gt; doubleArray&#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> count&#123; <span class="number">0</span> &#125;; count &lt; <span class="number">4</span>; ++count)</span><br><span class="line">doubleArray[count] = (<span class="number">4.0</span> + <span class="number">0.1</span> * count);</span><br><span class="line"> </span><br><span class="line">doubleArray.<span class="built_in">print</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这与上面的输出相同，但是具有明显较少的重复代码。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/类模板定制</title>
      <link href="/archives/dad59d93.html"/>
      <url>/archives/dad59d93.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/136-class-template-specialization/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/136-class-template-specialization/</a></p><hr><p>看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Storage8</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T m_array[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">const</span> T value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_array[index] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> T&amp; <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_array[index];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Storage8&lt;<span class="keyword">int</span>&gt; intStorage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; <span class="number">8</span>; ++count)</span><br><span class="line">intStorage.<span class="built_in">set</span>(count, count + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; <span class="number">8</span>; ++count)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; intStorage.<span class="built_in">get</span>(count) &lt;&lt; <span class="string">'\t'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">Storage8&lt;<span class="keyword">bool</span>&gt; boolStorage;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; <span class="number">8</span>; ++count)</span><br><span class="line">boolStorage.<span class="built_in">set</span>(count, count &amp; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; <span class="number">8</span>; ++count)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (boolStorage.<span class="built_in">get</span>(count) ? <span class="string">"true"</span> : <span class="string">"false"</span>) &lt;&lt; <span class="string">'\t'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">1</span>       <span class="number">2</span>       <span class="number">3</span>       <span class="number">4</span>       <span class="number">5</span>       <span class="number">6</span>       <span class="number">7</span>       <span class="number">8</span></span><br><span class="line"><span class="literal">false</span>   <span class="literal">true</span>    <span class="literal">true</span>    <span class="literal">true</span>    <span class="literal">false</span>   <span class="literal">true</span>    <span class="literal">true</span>    <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>虽然这个类是完全功能性的，但事实证明Storage8的实现比它需要的效率要低得多。<strong>因为所有的变量都必须有一个地址，并且CPU不能寻址任何小于一个字节的东西</strong>，所以所有的变量都必须至少有一个字节的大小。</p><p>存储bool类型的变量时浪费空间：</p><p>因此，bool类型的变量最终使用整个字节，<u>即使从技术上讲，它只需要一个位来存储它的真值或假值</u>! 因此，bool是1位有用的信息和7位浪费的空间。我们的 <code>Storage8&lt;bool&gt;</code>类，其中包含8个bools，即1个字节的有用信息 和7个字节的浪费空间。</p><p>如何解决？</p><ul><li>1、虽然我们<strong>可以创建一个全新的类</strong>来实现这一点，但是这样做有一个主要的缺点：我们必须给它起一个不同的名字。然后程序员必须记住Storage8是用于非bool类型的，而Storage8Bool(或者我们给新类起的任何名字)是用于bools的。我们宁愿避免不必要的复杂性。幸运的是，c++为我们提供了一个更好的方法:类模板专门化。</li></ul><ul><li>2、幸运的是，c++为我们提供了一个更好的方法：<strong>类模板专门化(Class template specialization)</strong>。</li></ul><h1 id="类模板专门化"><a href="#类模板专门化" class="headerlink" title="类模板专门化"></a>类模板专门化</h1><p><u>类模板专门</u> 化允许我们 <strong>专门化特定数据类型</strong> (或数据类型，如果有多个模板参数) <strong>的模板类</strong>。在本例中，我们将使用类模板专门化来编写一个自定义版本的Storage8，它将优先于通用的Storage8类。这类似于专门化函数优先于泛型模板函数。</p><p><strong>类模板专门化被视为完全独立的类</strong>，<u>即使它们是以与模板类相同的方式分配的</u>。</p><blockquote><p><strong>这意味着我们可以改变关于专门化类的任何事情，包括它的实现方式，甚至它公开的函数，就好像它是一个独立的类一样</strong>。</p></blockquote><p>这是我们的专门化类:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">template</span> &lt;&gt; <span class="comment">// 下面是一个 无参数模板 的模板类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage8</span>&lt;bool&gt; // <span class="title">we</span>'<span class="title">re</span> <span class="title">specializing</span> <span class="title">Storage8</span> <span class="title">for</span> <span class="title">bool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">// What follows is just standard class implementation details</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> m_data;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Storage8() : m_data(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">bool</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 找出我们正在设置/取消设置的位</span></span><br><span class="line"><span class="comment">// 这将在我们感兴趣的 bit加1</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> mask = <span class="number">1</span> &lt;&lt; index;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (value)  <span class="comment">// If we're setting a bit</span></span><br><span class="line">            m_data |= mask;  <span class="comment">// Use bitwise-or to turn that bit on</span></span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">// if we're turning a bit off</span></span><br><span class="line">            m_data &amp;= ~mask;  <span class="comment">// bitwise-and the inverse mask to turn that bit off</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Figure out which bit we're getting</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> mask = <span class="number">1</span> &lt;&lt; index;</span><br><span class="line">        <span class="comment">// bitwise-and to get the value of the bit we're interested in</span></span><br><span class="line">        <span class="comment">// Then implicit cast to boolean</span></span><br><span class="line">        <span class="keyword">return</span> (m_data &amp; mask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>首先，注意我们从<code>template&lt;&gt;</code>开始。template关键字 告诉编译器下面的内容是模板化的，而空尖括号表示没有任何模板参数。在本例中，没有任何模板参数，因为我们用特定的类型(bool)替换了唯一的模板参数(typename T)。</p></li><li><p>接下来，我们将<code>&lt;bool&gt;</code>添加到类名中，以表示我们正在专门化 Storage8类 的 bool版本。</p></li><li><p>所有其他更改都只是类实现细节。为了使用这个类，您不需要了解位逻辑是如何工作的(如果您想了解它，可以复习 <a href="https://www.learncpp.com/cpp-tutorial/bitwise-operators/" target="_blank" rel="noopener">O.2 – Bitwise operators</a>，但是需要复习一下位运算符是如何工作的)。</p></li></ul><blockquote><p>请注意，这个专门化类使用一个<strong>无符号字符(1字节)</strong>，而不是一个8个bools(8字节)的数组。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/函数模板定制</title>
      <link href="/archives/9a78acc3.html"/>
      <url>/archives/9a78acc3.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/13-5-function-template-specialization/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/13-5-function-template-specialization/</a></p><hr><p>当为给定类型实例化函数模板时，编译器将输出模板函数的副本，并将模板类型参数替换为变量声明中使用的实际类型。</p><p><strong>这意味着一个特定的函数对于每个实例类型都有相同的实现细节(只是使用不同的类型)。</strong>虽然大多数情况下，这正是您想要的，但是在某些情况下，为特定的数据类型实现略有不同的模板函数是有用的。</p><h1 id="成员函数模板的定制"><a href="#成员函数模板的定制" class="headerlink" title="成员函数模板的定制"></a>成员函数模板的定制</h1><p><strong>函数模板专定制</strong> (有时称为<strong>完整</strong>或<strong>显式函数模板专门化</strong>)，实现步骤比较简单：</p><ul><li>只需定义专门的函数 (<u>如果该函数是成员函数，<strong>则在类定义之外定义</strong></u>)，<strong>将模板类型替换为您希望为其重新定义函数的特定类型。</strong></li></ul><h2 id="例子1："><a href="#例子1：" class="headerlink" title="例子1："></a>例子1：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Storage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T m_value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Storage(T value)</span><br><span class="line">    &#123;</span><br><span class="line">         m_value = value;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~Storage()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Define some storage units</span></span><br><span class="line">    <span class="function">Storage&lt;<span class="keyword">int</span>&gt; <span class="title">nValue</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">Storage&lt;<span class="keyword">double</span>&gt; <span class="title">dValue</span><span class="params">(<span class="number">6.7</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Print out some values</span></span><br><span class="line">    nValue.<span class="built_in">print</span>();</span><br><span class="line">    dValue.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果此时，你想让浮点类型的数以 科学计数法 的形式打印，应该怎么做？——应该使相应的打印函数特殊化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="comment">//⭐⭐ 注意这里没有 模板类型参数</span></span><br><span class="line"><span class="keyword">void</span> Storage&lt;<span class="keyword">double</span>&gt;::<span class="built_in">print</span>() <span class="comment">//显式的将模板类型 替换为 我想要的类型</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::scientific &lt;&lt; m_value &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//函数主体也修改了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当编译器实例化<code>Storage&lt;double&gt;::print()</code>时，<strong>它会看到我们已经显式地定义了那个函数，它将使用我们定义的那个函数，而不是从泛型模板类中输出一个版本。</strong></p></blockquote><blockquote><p><strong><code>template &lt;&gt;</code>告诉编译器这是一个模板函数，但是没有模板参数</strong> (因为在本例中，我们显式地指定了所有类型)。一些编译器可能允许您省略它，但是最好包括它。</p></blockquote><h2 id="例子2："><a href="#例子2：" class="headerlink" title="例子2："></a>例子2：</h2><p>现在让我们看另一个模板专门化可能有用的例子。考虑一下，如果我们尝试使用带有数据类型char*的模板化 Storage类，会发生什么:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ：动态分配一个临时字符串</span></span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">string</span> = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">40</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Ask user for their name</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter your name: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; <span class="built_in">string</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Store the name</span></span><br><span class="line">    <span class="function">Storage&lt;<span class="keyword">char</span>*&gt; <span class="title">storage</span><span class="params">(<span class="built_in">string</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Delete the temporary string</span></span><br><span class="line">    <span class="keyword">delete</span>[] <span class="built_in">string</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Print out our value</span></span><br><span class="line">    storage.<span class="built_in">print</span>(); <span class="comment">// This will print garbage</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果显示，与打印用户输入的名称不同，storage.print()打印的是垃圾! 这是怎么回事?</p><ul><li><p>实例化char<em>类型的Storage时，Storage&lt;char\</em>&gt;的构造函数如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line">Storage&lt;<span class="keyword">char</span>*&gt;::Storage(<span class="keyword">char</span>* value)</span><br><span class="line">&#123;</span><br><span class="line">    m_value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>换句话说，<strong>这只是做一个指针赋值(浅拷贝)</strong>! 结果，<strong>m_value最终指向与string相同的内存位置。</strong>当我们删除main()中的字符串时，我们最终会删除m_value指向的值!因此，当我们试图打印那个值时，我们会得到垃圾。</p></li></ul><p>幸运的是，我们可以使用<strong>模板专门化</strong>来解决这个问题。<strong>我们希望构造函数复制输入的字符串</strong>，<strong>而不是复制指针</strong>。<u>因此，让我们为数据类型char*编写一个专门的构造函数</u>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="comment">//⭐⭐⭐</span></span><br><span class="line">Storage&lt;<span class="keyword">char</span>*&gt;::Storage(<span class="keyword">char</span>* value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//求value的长度</span></span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(value[length] != <span class="string">'\0'</span>)</span><br><span class="line">        ++length;</span><br><span class="line">    ++length;  <span class="comment">//+1 表示空终止符</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//分配内存来保存 value字符串</span></span><br><span class="line">    m_value = <span class="keyword">new</span> <span class="keyword">char</span>[length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> count=<span class="number">0</span>; count &lt; length; ++count) <span class="comment">//将实际的value字符串复制到我们刚刚分配的m_value内存中</span></span><br><span class="line">        m_value[count] = value[count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，当我们分配一个 Storage&lt;char*&gt;类型的变量时，将使用这个构造函数而不是默认的构造函数。结果，m_value将收到它自己的字符串副本。因此，当我们删除字符串时，m_value将不受影响。</p><blockquote><p>但是，这个类现在存在 <code>char*</code>类型的<strong>内存泄漏</strong>，因为当存储变量超出作用域时，m_value不会被删除。你可能已经猜到了<strong>，这也可以通过专门化 <code>Storage&lt;char*&gt;</code>析构函数</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line">Storage&lt;<span class="keyword">char</span>*&gt;::~Storage()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">delete</span>[] m_value;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>现在，当Storage类型的变量超出作用域时，在 专用构造函数中分配的内存将在 专用析构函数中删除。</p><h1 id="非成员函数模板的定制"><a href="#非成员函数模板的定制" class="headerlink" title="非成员函数模板的定制"></a>非成员函数模板的定制</h1><p><strong>尽管上面的例子都使用了成员函数，但是也可以用同样的方法专门化非成员模板函数。</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/非类型参数模板</title>
      <link href="/archives/388fba4a.html"/>
      <url>/archives/388fba4a.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/134-template-non-type-parameters/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/134-template-non-type-parameters/</a></p><hr><p>在前面的课程中，您已经学习了如何使用 模板类型参数 来创建与类型无关的函数和类。然而，模板类型参数并不是唯一可用的模板参数类型。模板类和函数可以使用另一种称为<strong>非类型参数模板</strong>的参数。</p><h1 id="非类型参数"><a href="#非类型参数" class="headerlink" title="非类型参数"></a>非类型参数</h1><p><strong>非类型参数模板</strong>是一种特殊类型的参数，<strong>它不替换类型，而是由值替换</strong>。<strong>非类型参数</strong>可以是以下任意一种:</p><ul><li><strong>具有整型或枚举的值</strong></li><li><strong>指向类对象的指针或引用</strong></li><li><strong>指向函数的指针或引用</strong></li><li><strong>指向类成员函数的指针或引用</strong></li><li><strong><code>std::nullptr_t</code></strong></li></ul><p>下面这个例子，我们创建类一个静态数组，使用了两个 类型参数：</p><ul><li>一个是：类型参数。它控制静态数组的数据类型。</li><li>一个是：非类型参数。他控制静态数组的长度。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">size</span>&gt; // <span class="title">size</span>是非类型参数</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">StaticArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 非类型参数控制数组的长度</span></span><br><span class="line">    T m_array[<span class="built_in">size</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T* <span class="title">getArray</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_array[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 说明如何在类外部定义具有非类型参数的类的函数 ⭐⭐⭐</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">size</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>* <span class="title">StaticArray</span>&lt;T, size&gt;:</span>:getArray()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_array;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//⭐ declare an integer array with room for 12 integers</span></span><br><span class="line">    StaticArray&lt;<span class="keyword">int</span>, <span class="number">12</span>&gt; intArray;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Fill it up in order, then print it backwards</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count &lt; <span class="number">12</span>; ++count)</span><br><span class="line">        intArray[count] = count;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">11</span>; count &gt;= <span class="number">0</span>; --count)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; intArray[count] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//⭐ declare a double buffer with room for 4 doubles</span></span><br><span class="line">    StaticArray&lt;<span class="keyword">double</span>, <span class="number">4</span>&gt; doubleArray;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count &lt; <span class="number">4</span>; ++count)</span><br><span class="line">        doubleArray[count] = <span class="number">4.4</span> + <span class="number">0.1</span>*count;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count &lt; <span class="number">4</span>; ++count)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; doubleArray[count] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">11 10 9 8 7 6 5 4 3 2 1 0</span><br><span class="line">4.4 4.5 4.6 4.7</span><br></pre></td></tr></table></figure><p>关于上面的例子，<strong>值得注意的是我们不需要动态分配m_array成员变量!</strong></p><p>这是因为对于StaticArray类 的任何给定实例，<u>size实际上都是常量</u>。例如，如果实例化为：<code>StaticArray&lt;int, 12&gt;</code>，编译器将大小替换为12。因此m_array的类型是int[12]，可以静态分配。</p><p>标准库类<code>std::array</code>就是用的这个功能。当您分配一个<code>std::array</code>时，int是一个类型参数，而5是一个非类型参数!</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/模板类</title>
      <link href="/archives/3bfe5978.html"/>
      <url>/archives/3bfe5978.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/133-template-classes/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/133-template-classes/</a></p><hr><p>在<a href="https://www.learncpp.com/cpp-tutorial/106-container-classes/" target="_blank" rel="noopener">10.6 – Container classes</a>中，您学习了如何使用复合来实现包含其他类的多个实例的类。作为这种容器的一个例子，我们研究了IntArray类。下面是该类的一个简化示例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> INTARRAY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTARRAY_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_length&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> *m_data&#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">    IntArray(<span class="keyword">int</span> length)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(length &gt; <span class="number">0</span>);</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="keyword">int</span>[length]&#123;&#125;;</span><br><span class="line">        m_length = length;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// We don't want to allow copies of IntArray to be created.</span></span><br><span class="line">    IntArray(<span class="keyword">const</span> IntArray&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    IntArray&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> IntArray&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"> </span><br><span class="line">    ~IntArray()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Erase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">        <span class="comment">// We need to make sure we set m_data to 0 here, otherwise it will</span></span><br><span class="line">        <span class="comment">// be left pointing at deallocated memory!</span></span><br><span class="line">        m_data = <span class="literal">nullptr</span>;</span><br><span class="line">        m_length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; m_length);</span><br><span class="line">        <span class="keyword">return</span> m_data[index];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_length; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>虽然这个类提供了一种创建整数数组的简单方法，但是如果我们想要创建一个双精度数组呢?使用传统的编程方法，我们必须创建一个全新的类!下面是DoubleArray的一个例子，它是一个数组类，用于保存double。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DOUBLEARRAY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DOUBLEARRAY_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_length&#123;&#125;;</span><br><span class="line">    <span class="keyword">double</span> *m_data&#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">    DoubleArray(<span class="keyword">int</span> length)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(length &gt; <span class="number">0</span>);</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="keyword">double</span>[length]&#123;&#125;;</span><br><span class="line">        m_length = length;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    DoubleArray(<span class="keyword">const</span> DoubleArray&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    DoubleArray&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> DoubleArray&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"> </span><br><span class="line">    ~DoubleArray()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Erase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">        <span class="comment">// We need to make sure we set m_data to 0 here, otherwise it will</span></span><br><span class="line">        <span class="comment">// be left pointing at deallocated memory!</span></span><br><span class="line">        m_data = <span class="literal">nullptr</span>;</span><br><span class="line">        m_length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">double</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; m_length);</span><br><span class="line">        <span class="keyword">return</span> m_data[index];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_length; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>尽管代码清单很长，但您会注意到这两个类几乎完全相同!实际上，惟一的实质性区别是所包含的数据类型(int和double)。您可能已经猜到了，这是另一个可以充分利用模板的领域，从而使我们不必创建绑定到特定数据类型的类。</p><h1 id="使用模板类"><a href="#使用模板类" class="headerlink" title="使用模板类"></a>使用模板类</h1><p>创建模板类的工作方式与创建模板函数的工作方式几乎相同，因此我们将通过示例继续。这是我们的数组类，模板版本:</p><p><code>Array.h</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ARRAY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAY_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_length&#123;&#125;;</span><br><span class="line">    T *m_data&#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">    Array(<span class="keyword">int</span> length)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(length &gt; <span class="number">0</span>);</span><br><span class="line">        m_data = <span class="keyword">new</span> T[length]&#123;&#125;;</span><br><span class="line">        m_length = length;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Array(<span class="keyword">const</span> Array&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Array&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Array&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"> </span><br><span class="line">    ~Array()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Erase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">        <span class="comment">// 我们需要确保我们在这里设置m_data为0，否则它会 指向释放了的内存!!</span></span><br><span class="line">        m_data = <span class="literal">nullptr</span>;</span><br><span class="line">        m_length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; m_length);</span><br><span class="line">        <span class="keyword">return</span> m_data[index];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 模板函数getLength() 的定义在下面</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> <span class="keyword">const</span></span>; </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 定义在类外部的成员函数需要它们自己的模板声明⭐</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">Array</span>&lt;T&gt;:</span>:getLength() <span class="keyword">const</span> <span class="comment">// 注意类名是Array&lt;T&gt;，不是Array⭐</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>正如您所看到的，这个版本与IntArray版本几乎完全相同，<strong>只是我们添加了模板声明，并将所包含的数据类型从int更改为T。</strong></p><blockquote><p>注意：</p><p>注意，<u>我们还在类声明之外定义了getLength()函数。这并不是必须的</u>，但是由于语法的原因，新程序员在第一次尝试这样做时通常会出错，所以下面的例子很有启发意义。<strong>在类声明之外声明的每个模板化成员函数都需要自己的模板声明。另外，请注意模板化数组类的名称是Array<t>，而不是array</t></strong>——array将引用一个名为array的类的非模板化版本。</p></blockquote><p>这里是一个简短的例子使用上述模板 array类:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Array.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Array&lt;<span class="keyword">int</span>&gt; <span class="title">intArray</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line"><span class="function">Array&lt;<span class="keyword">double</span>&gt; <span class="title">doubleArray</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> count&#123; <span class="number">0</span> &#125;; count &lt; intArray.getLength(); ++count)</span><br><span class="line">&#123;</span><br><span class="line">intArray[count] = count;</span><br><span class="line">doubleArray[count] = count + <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> count&#123; intArray.getLength() - <span class="number">1</span> &#125;; count &gt;= <span class="number">0</span>; --count)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; intArray[count] &lt;&lt; <span class="string">'\t'</span> &lt;&lt; doubleArray[count] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">11</span>     <span class="number">11.5</span></span><br><span class="line"><span class="number">10</span>     <span class="number">10.5</span></span><br><span class="line"><span class="number">9</span>       <span class="number">9.5</span></span><br><span class="line"><span class="number">8</span>       <span class="number">8.5</span></span><br><span class="line"><span class="number">7</span>       <span class="number">7.5</span></span><br><span class="line"><span class="number">6</span>       <span class="number">6.5</span></span><br><span class="line"><span class="number">5</span>       <span class="number">5.5</span></span><br><span class="line"><span class="number">4</span>       <span class="number">4.5</span></span><br><span class="line"><span class="number">3</span>       <span class="number">3.5</span></span><br><span class="line"><span class="number">2</span>       <span class="number">2.5</span></span><br><span class="line"><span class="number">1</span>       <span class="number">1.5</span></span><br><span class="line"><span class="number">0</span>       <span class="number">0.5</span></span><br></pre></td></tr></table></figure><h2 id="模板类的实例化方法与模板函数相同"><a href="#模板类的实例化方法与模板函数相同" class="headerlink" title="模板类的实例化方法与模板函数相同"></a>模板类的实例化方法与模板函数相同</h2><p><strong>模板类的实例化方式与模板函数相同</strong>——<strong>编译器根据需要 模板化一个副本，用 用户输入的实际数据类型替换 模板参数，然后编译该副本。如果您从未使用过模板类，编译器甚至不会编译它。</strong></p><h2 id="板类确实是c-最好和最有用的特性之一"><a href="#板类确实是c-最好和最有用的特性之一" class="headerlink" title="板类确实是c++最好和最有用的特性之一"></a>板类确实是c++最好和最有用的特性之一</h2><p>模板类是实现容器类的理想对象，因为让容器跨各种数据类型工作是非常理想的，而模板允许您在不复制代码的情况下这样做。虽然语法很难看，错误消息也很隐晦，但是模板类确实是c++最好和最有用的特性之一。</p><h1 id="标准库中的模板类"><a href="#标准库中的模板类" class="headerlink" title="标准库中的模板类"></a>标准库中的模板类</h1><p>现在我们已经介绍了模板类，您应该理解<code>std::vector&lt;int&gt;</code>是什么意思了——std::vector实际上是一个模板类，int是模板的类型参数。标准库中有很多预定义的模板类可供您使用。我们将在后面的章节中讨论这些。</p><h1 id="分解模板类"><a href="#分解模板类" class="headerlink" title="分解模板类"></a>分解模板类</h1><p><strong>模板不是类，也不是函数——它是用于创建类或函数的模板。</strong></p><p>因此，它的工作方式与普通函数或类不太一样。在大多数情况下，这不是什么大问题。然而，有一个方面通常会给开发人员带来问题。</p><h2 id="为什么要分解"><a href="#为什么要分解" class="headerlink" title="为什么要分解"></a>为什么要分解</h2><p>对于<u>非模板类</u>，通常的过程是<strong>将类定义放在头文件中(.h)</strong>，<strong>将成员函数定义放在相同名字的代码文件中(.cpp)。</strong>通过这种方式，类的源代码(.cpp)被编译为一个单独的项目文件。</p><p><u>但是，对于模板，这是行不通的</u>。考虑以下:</p><p><code>Array.h</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ARRAY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAY_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_length&#123;&#125;;</span><br><span class="line">    T* m_data&#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">    Array(<span class="keyword">int</span> length)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(length &gt; <span class="number">0</span>);</span><br><span class="line">        m_data = <span class="keyword">new</span> T[length]&#123;&#125;;</span><br><span class="line">        m_length = length;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Array(<span class="keyword">const</span> Array&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Array&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Array&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"> </span><br><span class="line">    ~Array()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Erase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line"> </span><br><span class="line">        m_data = <span class="literal">nullptr</span>;</span><br><span class="line">        m_length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; m_length);</span><br><span class="line">        <span class="keyword">return</span> m_data[index];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> <span class="keyword">const</span></span>; </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>Array.cpp</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Array.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">Array</span>&lt;T&gt;:</span>:getLength() <span class="keyword">const</span> <span class="comment">// note class name is Array&lt;T&gt;, not Array</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Array.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Array&lt;<span class="keyword">int</span>&gt; <span class="title">intArray</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line"><span class="function">Array&lt;<span class="keyword">double</span>&gt; <span class="title">doubleArray</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> count&#123; <span class="number">0</span> &#125;; count &lt; intArray.getLength(); ++count)</span><br><span class="line">&#123;</span><br><span class="line">intArray[count] = count;</span><br><span class="line">doubleArray[count] = count + <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> count&#123; intArray.getLength() - <span class="number">1</span> &#125;; count &gt;= <span class="number">0</span>; --count)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; intArray[count] &lt;&lt; <span class="string">'\t'</span> &lt;&lt; doubleArray[count] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序将编译，但导致链接器错误:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unresolved external symbol &quot;public: int __thiscall Array::getLength(void)&quot; (?GetLength@?$Array@H@@QAEHXZ)</span><br></pre></td></tr></table></figure><p>为了让编译器使用模板，<strong>它必须同时看到 模板定义(不仅仅是一个声明) 和 用于实例化模板的模板类型</strong>。</p><blockquote><p>还要记住，C++单独编译文件。<strong>当 Array.h 被包含在main中时，模板类定义 被复制到main.cpp中。</strong></p></blockquote><p>当编译器看到我们需要两个模板实例，<code>Array&lt;int&gt;</code> 和 <code>Array&lt;double&gt;</code>，它将实例化它们，<strong>并将它们编译为main.cpp的一部分。</strong></p><p><u>但是，当单独编译<code>Array.cpp</code>时，它会忘记我们需要一个<code>Array&lt;int&gt;</code> 和 <code>Array&lt;double&gt;</code>，这样模板函数就不会被实例化。</u></p><p>因此，我们得到一个链接器错误，因为编译器找不到<code>Array&lt;int&gt;::getLength()</code>或<code>Array&lt;double&gt;::getLength()</code>的定义。</p><h2 id="分解方法"><a href="#分解方法" class="headerlink" title="分解方法"></a>分解方法</h2><p>有很多方法可以解决这个问题。</p><ul><li><p><strong>将模板类的.h 与 .cpp 文件中的代码 全部放在 .h文件中。</strong></p><blockquote><p>这是我们的首选解决方案，除非编译或链接时间 开始成为问题。</p></blockquote></li></ul><p>这样，当您#include头部时，所有的模板代码都将在一个位置。这个解决方案的优点是它很简单。</p><p>这里的<strong>缺点</strong>是，如果模板类在很多地方使用，您将会得到模板类的许多本地副本，这会增加编译和链接的时间(链接器应该删除重复的定义，因此它不应该使您的可执行文件膨胀)。</p><ul><li><p><strong>将<code>xxx.cpp</code>文件重命名为<code>xxx.inl</code></strong></p><p>如果您认为将Array.cpp代码放到Array.h头文件中会使头文件太长/混乱<strong>，那么可以使用另一种方法</strong>：</p><ol><li><strong>将<code>Array.cpp</code>重命名为<code>Array.inl</code>(<code>.inl</code>代表内联)，</strong></li><li><strong>然后在<code>Array.h</code>中的底部 <code>#include &quot;Array.inl&quot;</code></strong>。</li></ol></li></ul><p>这将产生与将所有代码放入头中相同的结果，但有助于保持更简洁。</p><ul><li><strong>在main.cpp文件中，包含模板类的.cpp文件，即<code>#include &quot;xxx.cpp&quot;</code></strong></li></ul><p>但是我们<strong>不推荐</strong>这个方法，因为这是#include的非标准用法。</p><ul><li><p><strong>三文件法</strong></p><blockquote><p>这个方法更有效，但是需要维护每个程序的templates.cpp文件。</p></blockquote><ul><li><strong>将模板类的定义放在<code>.h</code>文件中；</strong></li><li><strong>将模板类的成员函数的定义放在<code>.cpp</code>文件中；</strong></li><li><strong>最后你添加第三个文件(假设叫<code>templates.cpp</code>)，它包含了你需要的所有实例化类</strong>。</li></ul><p><strong>然后在<code>main.cpp</code>中包含<code>#include &quot;templates.cpp&quot;</code></strong>。</p></li></ul><p>如，下面展示了一个添加的第三个文件：</p><p><code>templates.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 确保可以看到完整的数组模板定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Array.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Array.cpp"</span> <span class="comment">//我们在这里打破了最佳实践，但只是在这个地方</span></span></span><br><span class="line"><span class="comment">// 在这里包含您需要的其他.h和.cpp模板定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Array</span>&lt;int&gt;;</span>  <span class="comment">//⭐显式实例化模板Array&lt;int&gt;</span></span><br><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Array</span>&lt;double&gt;;</span> <span class="comment">//⭐显式实例化模板Array&lt;double&gt;</span></span><br><span class="line"><span class="comment">//在这里实例化其他模板</span></span><br></pre></td></tr></table></figure><p>“模板类”命令使编译器显式实例化模板类。</p><p>在上面的例子中，编译器会在<code>template .cpp</code>中 模板印刷出<code>Array&lt;int&gt;</code> 和 <code>Array&lt;double&gt;</code>。因为templates.cpp在我们的项目中，这个将会被编译。然后可以从其他地方链接这些函数。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/函数模板实例化</title>
      <link href="/archives/28492eb.html"/>
      <url>/archives/28492eb.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/132-function-template-instances/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/132-function-template-instances/</a></p><hr><p>我们有必要简要了解一下模板函数是如何在c++中实现的，因为将来的课程将以这些概念为基础。</p><h1 id="函数模板实例"><a href="#函数模板实例" class="headerlink" title="函数模板实例"></a>函数模板实例</h1><p><strong>事实证明，c++并没有直接编译模板函数。</strong></p><p>相反，在编译时<strong>，当编译器遇到对模板函数的调用时，它复制模板函数并用实际类型替换模板类型参数。</strong> 具有实际类型的函数称为<strong>函数模板实例</strong>。</p><p>让我们看一下这个过程的一个例子。</p><ul><li><p>首先，我们有一个模板函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 这是模板参数声明</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> T&amp; <span class="title">max</span><span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译程序时，编译器遇到一个调用模板函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i&#123; <span class="built_in">max</span>(<span class="number">3</span>, <span class="number">7</span>) &#125;; <span class="comment">// calls max(int, int)</span></span><br></pre></td></tr></table></figure><p>编译器会说，“哦，我们要调用max(int, int)” <strong>编译器复制函数模板并创建模板实例max(int, int)</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">max</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x, <span class="keyword">const</span> <span class="keyword">int</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x&gt;y) ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这现在是一个可以被编译成机器语言的“普通函数”。</strong></p><p>现在，让我们在稍后的代码中使用不同的类型再次调用max():</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d&#123;<span class="built_in">max</span>(<span class="number">6.34</span>, <span class="number">18.523</span>) &#125;; <span class="comment">// calls max(double, double)</span></span><br></pre></td></tr></table></figure><p>c++自动创建一个模板实例：max(double，double):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">double</span>&amp; <span class="title">max</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; x, <span class="keyword">const</span> <span class="keyword">double</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x&gt;y) ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编译它。</p></li></ul><p>编译器足够聪明，<u>知道它只需要为每组惟一类型参数(每个文件) 创建一个模板实例。</u></p><p>还有，<u>如果您创建了一个模板函数，但是没有调用它，那么将不会创建任何模板实例。</u></p><h1 id="操作符、函数调用和函数模板"><a href="#操作符、函数调用和函数模板" class="headerlink" title="操作符、函数调用和函数模板"></a>操作符、函数调用和函数模板</h1><p>模板函数可以使用<strong>内置类型</strong>(例如char、int、double等)和<strong>类</strong>。</p><blockquote><p>但是我们需要注意：</p><p>当编译器编译模板实例时，它像普通函数一样编译它。<strong>在普通函数中，必须定义与类型一起使用的任何操作符或函数调用，否则将得到编译器错误。</strong></p></blockquote><p>类似地，<strong><u>模板函数中的任何 操作符或函数调用 都必须</u>为实例化函数模板的任何类型 <u>定义</u></strong>。</p><p>让我们更详细地看看这个：</p><ul><li><p>首先，我们将创建一个简单的类:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cents</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_cents;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cents(<span class="keyword">int</span> cents)</span><br><span class="line">        : m_cents&#123; cents &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>现在，让我们看看当我们尝试调用带有Cents类的模板化max()函数时会发生什么:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//  这是模板参数声明</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> T&amp; <span class="title">max</span><span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cents</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_cents;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cents(<span class="keyword">int</span> cents)</span><br><span class="line">        : m_cents&#123; cents &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cents nickle&#123; <span class="number">5</span> &#125;;</span><br><span class="line">    Cents dime&#123; <span class="number">10</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    Cents bigger&#123; <span class="built_in">max</span>(nickle, dime) &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c++将为max()创建一个模板实例，看起来像这样:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Cents&amp; <span class="title">max</span><span class="params">(<span class="keyword">const</span> Cents &amp;x, <span class="keyword">const</span> Cents &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后它会尝试编译这个函数。看到问题了吗?</p><p>c++不能计算x &gt; y，因为x和y是 Cents 类对象，编译器不知道如何比较它们。因此，<u>这将产生一个编译错误</u>，如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1&gt;c:\consoleapplication1\main.cpp(4): error C2676: binary &#39;&gt;&#39;: &#39;const Cents&#39; does not define this operator or a conversion to a type acceptable to the predefined operator</span><br><span class="line">1&gt;  c:\consoleapplication1\main.cpp(23): note: see reference to function template instantiation &#39;const T &amp;max(const T &amp;,const T &amp;)&#39; being compiled</span><br><span class="line">1&gt;          with</span><br><span class="line">1&gt;          [</span><br><span class="line">1&gt;              T&#x3D;Cents</span><br><span class="line">1&gt;          ]</span><br></pre></td></tr></table></figure><p><strong>顶部的错误消息指出了这样一个事实: 对于Cents类，没有重载操作符<code>&gt;</code>。</strong></p><p><strong>底部的错误指出了引发错误的模板化函数调用，以及模板化参数的类型。</strong></p></li></ul><p><strong>要解决这个问题，只需重载任何我们希望使用max()的类的<code>&gt;</code>操作符:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cents</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_cents;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cents(<span class="keyword">int</span> cents)</span><br><span class="line">        : m_cents&#123; cents &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> Cents &amp;c1, <span class="keyword">const</span> Cents &amp;c2) <span class="comment">//重载操作符 &gt; ，从而模板实例中可以使用该重载操作符&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (c1.m_cents &gt; c2.m_cents);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>现在c++将知道当x和y是Cents类的对象时，如何比较x &gt; y ! 因此，我们的max()函数现在将处理两个类型为Cents的对象。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/函数模板</title>
      <link href="/archives/454c1de9.html"/>
      <url>/archives/454c1de9.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/131-function-templates/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/131-function-templates/</a></p><hr><p>在前几章中，您已经学习了如何编写函数和类，这些函数和类有助于使程序更容易编写、更安全、更易于维护。虽然函数和类是有效编程的强大而灵活的工具，但在某些情况下，它们也可能有一些限制，因为c++要求指定所有参数的类型。</p><p>例如，假设您想编写一个函数来计算两个数字的最大值。你可以这样做:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数对于整数非常有用。当您意识到max()函数需要使用double时，会发生什么? <u>传统上，解决方法是重载max()函数，并创建一个使用双精度浮点数的新版本:</u></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">max</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，max()的双版本实现的代码与max()的int版本完全相同! 事实上，这个实现适用于所有不同的类型:char、int、double ! 但是，<u>因为c++要求您使变量具有特定的类型，所以您必须为希望使用的每种类型编写一个函数。</u></p><p>必须为同一个函数指定不同的“风格”，其中惟一改变的是参数的类型，这可能会成为维护上的麻烦和时间上的浪费，而且也违反了一般的编程准则，即尽可能减少重复的代码。<strong>如果我们可以编写max()的一个版本，它可以处理任何类型的参数，这不是很好吗?</strong></p><p>欢迎来到<strong>模板</strong>的世界。</p><h1 id="什么是函数模板"><a href="#什么是函数模板" class="headerlink" title="什么是函数模板?"></a>什么是函数模板?</h1><blockquote><p>如果你在字典中查找“template”这个词，你会发现它的定义与以下内容类似:“模板是一种模型，用作创建类似对象的模式”。</p></blockquote><p>在c++中，<strong>函数模板是作为创建其他类似函数的模式的函数</strong>。</p><p>函数模板背后的基本思想是：</p><p><strong>创建一个函数，而不必指定某些或所有变量的确切类型</strong>。<strong>我们使用占位符类型定义函数，称为模板类型参数</strong>。一旦我们使用这些占位符类型创建了一个函数，我们就有效地创建了一个<strong>“函数模板”</strong>。</p><p><strong>当您调用一个模板函数时</strong>，<u>编译器会“模板化”出模板的一个副本，用函数调用中的参数中的实际变量类型替换占位符类型</u> !使用这种方法，编译器可以从一个模板创建多个函数的“风格”! 在下一课中，我们将更详细地了解这个过程。</p><h1 id="在C-中创建函数模板"><a href="#在C-中创建函数模板" class="headerlink" title="在C++中创建函数模板"></a>在C++中创建函数模板</h1><p>此时，您可能想知道如何在c++中实际创建函数模板。事实证明，这并没有那么难。</p><blockquote><p>让我们再来看看max()的int版本:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，有3个地方使用了特定的类型: 参数<u>x、y和 返回值</u> 都指定它们必须是整数。<strong>要创建函数模板，我们将用占位符类型替换这些特定类型。</strong></p><p><u>在这种情况下，因为我们只有一种类型需要替换(int)，所以我们只需要一个模板类型参数。</u></p></blockquote><p><u>您可以为占位符类型命名几乎任何您想要的名称，只要它不是保留字</u>。然而，<strong>在c++中，习惯上将模板类型命名为字母T(“Type”的缩写)。</strong></p><p>​ 这是我们的新函数与占位符类型:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T x, T y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个好的开始——但是，它不会编译，因为编译器不知道“T”是什么!</p><p>为了实现这一点，我们需要告诉编译器两件事:⭐⭐</p><ul><li>第一，这是一个模板定义，</li><li>第二，T是一个占位符类型。</li></ul><p>我们可以在一行中完成这两件事，使用所谓的<strong>模板参数声明( template parameter declaration)</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 这是模板参数声明  (在这里可以使用⭐ typename  或者 class)</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T x, T y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，让我们稍微仔细看看模板参数声明：</p><ul><li><p>我们从开始于：<strong>关键字<code>template</code></strong></p><blockquote><p>这告诉编译器，接下来的内容将是一个<strong>模板参数列表</strong>。我们<strong>将所有参数放在尖括号中(<code>&lt;&gt;</code>)。</strong></p><p><strong>要创建模板类型参数，请使用关键字<code>typename</code>或<code>class</code></strong>。</p><blockquote><p>这两个关键字在上下文中没有区别，所以使用哪个关键字取决于您自己。注意，如果使用class关键字，传入的类型实际上不必是一个类(它可以是一个基本变量、指针或其他匹配的东西)。</p></blockquote></blockquote></li><li><p>然后命名您的类型(<strong>通常为“T”</strong>)。</p></li></ul><p><strong>如果模板函数使用多个模板类型参数</strong>，它们可以用<strong>逗号</strong>分隔:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="comment">// template function here</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>对于使用不止一种类型</strong>的，<strong>通常会看到它们被命名为“T1”和“T2”，或者其他单个大写字母的名称，例如“S”。</strong></p></blockquote><p>最后一点注意:</p><p>因为传入T类型的函数参数可以是一个<strong>类类型</strong>，<strong>通过值传递类通常不是一个好主意，所以最好让模板函数的参数和返回类型引用:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">const T&amp; max(const T&amp; x, const T&amp; y) ⭐</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用函数模板"><a href="#使用函数模板" class="headerlink" title="使用函数模板"></a>使用函数模板</h1><p>使用函数模板非常简单——您可以像使用其他函数一样使用它。这里是一个完整的程序使用我们的模板函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">const</span> T&amp; <span class="title">max</span><span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="built_in">max</span>(<span class="number">3</span>, <span class="number">7</span>); <span class="comment">// returns 7</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">double</span> d = <span class="built_in">max</span>(<span class="number">6.34</span>, <span class="number">18.523</span>); <span class="comment">// returns 18.523</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">max</span>(<span class="string">'a'</span>, <span class="string">'6'</span>); <span class="comment">// returns 'a'</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">18.523</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure><p>注意，所有这三个对max()的调用都有不同类型的参数! 因为我们调用了具有3种不同类型的函数，所以编译器将使用模板定义来创建该函数的3个不同版本：</p><ul><li>一个带有int参数(名为：<code>max&lt;int&gt;</code>)，</li><li>一个具有double参数(名为：<code>max&lt;double&gt;</code>)，</li><li>一个带有char参数(名为：<code>max&lt;char&gt;</code>)。</li></ul><p>注意，<strong>只要编译器能够从参数类型推断出模板类型，就不需要在函数名中显式地指定模板类型(例如max<int>的<int>部分)。</int></int></strong></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>1、</p><p>正如您所看到的，模板函数可以节省大量时间，因为您只需要编写一个函数，而且它可以与许多不同的类型一起工作。</p><p>一旦您习惯了编写函数模板，您就会发现编写它们实际上并不比编写具有实际类型的函数花费更多的时间。</p><p>模板函数减少了代码维护，因为重复的代码明显减少。</p><p>最后，模板函数可以更安全，因为当您需要函数处理新类型时，不需要手动复制函数和更改类型 !</p><p>2、</p><p>模板函数确实有一些缺点，如果我们不提它们，那就太不小心了：</p><ul><li><p>首先，一些较老的编译器没有很好的支持 模板。</p><blockquote><p>然而，这个缺点不再像以前那样是个大问题。</p></blockquote></li><li><p>其次，模板函数通常会产生看起来很疯狂的错误消息，比普通函数更难破译。</p></li><li><p>第三，<strong>模板函数会增加编译时间和代码大小</strong>，因为单个模板可能会“实现”并在许多文件中重新编译(有很多方法可以解决这个问题)。</p></li></ul><p><u>然而，与模板为您的编程工具包带来的强大和灵活性相比，这些缺陷是相当小的!</u></p><hr><p>注意:</p><ul><li><p>标准库已经提供了模板化的max()函数(在头文件<code>algorithm</code>中)，所以你不需要自己写(除非你想写)。</p><blockquote><p>如果您确实编写了自己的版本，请注意<strong>，如果您使用语句“<code>using namespace std;</code>”，可能会出现命名冲突，因为编译器将无法判断您是想要max()版本还是std::max()版本。</strong></p></blockquote></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/使用操作符“《”打印继承类</title>
      <link href="/archives/1639a92e.html"/>
      <url>/archives/1639a92e.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/12-10-printing-inherited-classes-using-operator/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/12-10-printing-inherited-classes-using-operator/</a></p><hr><p>考虑以下使用虚拟函数的程序:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Base() &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base"</span>;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Derived() &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Derived d;</span><br><span class="line">Base &amp;b = d;</span><br><span class="line">b.<span class="built_in">print</span>(); <span class="comment">// will call Derived::print()</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到目前为止，您应该已经熟悉了这样一个事实: <strong>b.print()将调用Derived::print()(因为b指向一个派生类对象，Base::print()是一个虚函数，而Derived::print()是一个覆盖函数)。</strong></p><p>虽然调用这样的成员函数来执行输出是可以的，但是这种类型的函数不能很好地与std::cout混合使用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Derived d;</span><br><span class="line">Base &amp;b = d;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b is a "</span>;</span><br><span class="line">        b.<span class="built_in">print</span>(); <span class="comment">// 混乱，我们必须中断打印语句来调用这个函数</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这节课中，我们将学习如何使用继承重写运算符&lt;&lt;，这样我们就可以像预期的那样使用运算符&lt;&lt;，就像这样:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b is a "</span> &lt;&lt; b &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// much better</span></span><br></pre></td></tr></table></figure><h1 id="操作符-lt-lt-的挑战"><a href="#操作符-lt-lt-的挑战" class="headerlink" title="操作符&lt;&lt;的挑战"></a>操作符<code>&lt;&lt;</code>的挑战</h1><p>让我们从重载运算符&lt;&lt;开始，以典型的方式:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Base() &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base"</span>;  &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp;out, <span class="keyword">const</span> Base &amp;b)</span><br><span class="line">        &#123;</span><br><span class="line">            out &lt;&lt; <span class="string">"Base"</span>;</span><br><span class="line">            <span class="keyword">return</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Derived() &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived"</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp;out, <span class="keyword">const</span> Derived &amp;d)</span><br><span class="line">        &#123;</span><br><span class="line">            out &lt;&lt; <span class="string">"Derived"</span>;</span><br><span class="line">            <span class="keyword">return</span> out;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    Derived d;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这里不需要虚拟函数解析，这个程序像我们期望的那样工作，并打印:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base</span><br><span class="line">Derived</span><br></pre></td></tr></table></figure><p>现在，考虑以下main()函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    Base &amp;bref = d;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; bref &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Base</span><br></pre></td></tr></table></figure><p><strong>这可能不是我们所期望的。这是因为我们的操作符&lt;&lt;处理基对象的版本不是virtual，所以std::cout &lt;&lt; bref调用操作符&lt;&lt;处理基对象而不是派生对象的版本。</strong></p><p>这就是挑战所在。</p><h2 id="我们可以让运算符-lt-lt-virtual吗-——不可以"><a href="#我们可以让运算符-lt-lt-virtual吗-——不可以" class="headerlink" title="我们可以让运算符&lt;&lt; virtual吗?——不可以"></a>我们可以让运算符<code>&lt;&lt;</code> virtual吗?——不可以</h2><p>如果这个问题是操作符&lt;&lt;不是虚的，我们不能简单地让它成为虚的吗?</p><p>答案是：<strong>不可以</strong>。这有很多原因。</p><ul><li><p>首先，<strong>只有成员函数可以被虚拟化</strong>——这是有意义的，因为只有类可以从其他类继承，而且没有办法<strong>重写（覆盖）</strong>类之外的函数 (<strong>可以重载</strong>非成员函数，但<strong>不能覆盖</strong>它们)。</p><blockquote><p>因为我们通常将操作符&lt;&lt;作为 friend 实现，<strong>而friend不被认为是成员函数，所以操作符&lt;&lt;的friend版本不适合虚拟化。</strong>(为了回顾为什么我们用这种方式实现运算符&lt;&lt;，请重温 <a href="https://www.learncpp.com/cpp-tutorial/94-overloading-operators-using-member-functions/" target="_blank" rel="noopener">9.4 – Overloading operators using member functions</a>)。</p></blockquote></li><li><p>其次，即使我们可以虚拟化运算符&lt;&lt;，也存在这样的问题: <code>Base::operator&lt;&lt;</code>和<code>Derived::operator&lt;&lt;</code> 的函数参数是不同的 (基版本将接受 一个 Base参数，派生版本将接受一个 Derived参数)。</p><p>因此，<strong>派生版本不会被认为是基本版本的覆盖，因此不适合进行虚函数解析。</strong></p></li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>事实证明，答案非常简单。</p><ul><li><p>首先，我们像往常一样在基类中将操作符&lt;&lt;设置为friend。但是，我们不让操作符<code>&lt;&lt;</code>自己打印，而是将此职责委托 给一个可以虚拟化的普通成员函数!</p><blockquote><p>看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Base() &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这是重载运算符&lt;&lt;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp;out, <span class="keyword">const</span> Base &amp;b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 将打印责任委托给 成员函数print()</span></span><br><span class="line"><span class="keyword">return</span> b.<span class="built_in">print</span>(out);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 我们将依赖于成员函数print()来进行实际的打印</span></span><br><span class="line"><span class="comment">// 因为print是一个普通的成员函数，所以它可以被虚拟化</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::ostream&amp; <span class="title">print</span><span class="params">(<span class="built_in">std</span>::ostream&amp; out)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">out &lt;&lt; <span class="string">"Base"</span>;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Derived() &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 面是处理派生情况的覆盖 print函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::ostream&amp; <span class="title">print</span><span class="params">(<span class="built_in">std</span>::ostream&amp; out)</span> <span class="keyword">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">out &lt;&lt; <span class="string">"Derived"</span>;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base b;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">Derived d;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// 注意，即使没有显式处理派生对象的操作符&lt;&lt;，也可以这样做</span></span><br><span class="line"> </span><br><span class="line">Base &amp;bref = d;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; bref &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base</span><br><span class="line">Derived</span><br><span class="line">Derived</span><br></pre></td></tr></table></figure><hr><p><strong>让我们更详细地研究一下。</strong></p><ul><li><p>首先，在基类Base中，我们调用操作符&lt;&lt;，它调用虚函数print()。因为我们的基引用参数指向一个基对象，b.print()解析为Base::print()，它执行打印。没什么特别的。</p></li><li><p>在派生的情况下，编译器首先查看是否存在 接受派生对象的操作符&lt;&lt;。没有，因为我们没有定义。接下来，编译器查看是否存在 接受基对象的操作符&lt;&lt;。有。所以编译器隐式地将我们的派生对象<strong>向上转换</strong>为一个 <strong>Base&amp;</strong> 并调用这个函数(我们可以自己做这个向上转换，但是编译器在这方面很有帮助）。然后，这个函数调用virtual print()，它解析为Derived::print().。</p><blockquote><p>注意，<strong>我们不需要为每个派生类定义运算符&lt;&lt;</strong> ! 处理基对象的版本 对于基对象和从基派生的任何类都可以很好地工作!</p></blockquote></li><li><p>第三种情况是前两种情况的混合。</p><p>首先，编译器将变量bref与接受 基的操作符&lt;&lt;匹配。 调用我们的 虚print()函数，由于基引用实际上指向一个派生对象，因此解析为Derived::print()。</p></li></ul></blockquote></li></ul><p>问题解决。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/动态强制类型转换</title>
      <link href="/archives/d7910ce1.html"/>
      <url>/archives/d7910ce1.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/12-9-dynamic-casting/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/12-9-dynamic-casting/</a></p><hr><p>早在<a href="https://www.learncpp.com/cpp-tutorial/explicit-type-conversion-casting-and-static-cast/" target="_blank" rel="noopener">6.16 – Explicit type conversion (casting) and static_cast</a>中，我们研究了强制转换的概念，以及使用static_cast将变量从一种类型转换为另一种类型。</p><p>在这节课中，我们将继续研究另一种类型的转换: <strong>dynamic_cast</strong>。</p><h1 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h1><p>在处理多态性时，您经常会遇到这样的情况: 您有一个指向基类的指针，但是您想要访问一些只存在于派生类中的信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> m_value;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Base(<span class="keyword">int</span> value)</span><br><span class="line">: m_value(value)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> ~Base() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Derived(<span class="keyword">int</span> value, <span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">: Base(value), m_name(name)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">Base* <span class="title">getObject</span><span class="params">(<span class="keyword">bool</span> bReturnDerived)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bReturnDerived)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Derived(<span class="number">1</span>, <span class="string">"Apple"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Base(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base *b = getObject(<span class="literal">true</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 如何在只有基指针的情况下打印派生对象的名称?</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">delete</span> b;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个程序中，函数getObject()总是返回一个基指针，但是这个指针可以指向基指针，也可以指向派生的对象。在指针指向派生对象的情况下，我们如何调用Derived::getName()?</p><ul><li><p>一种方法是将一个虚函数添加到名为getName()的基函数中(因此我们可以使用一个基指针/引用来调用它，并将其动态解析为::getName())。</p><blockquote><p>但是如果你用一个实际指向基对象的基指针/引用来调用这个函数，它会返回什么呢?没有任何有意义的价值。此外，我们可能会用那些实际上只应该是派生类关注的东西来污染基类。</p></blockquote></li><li><p>我们知道c++将<strong>隐式</strong>地允许您将派生的指针转换为基指针(事实上，getObject()就是这样做的)。这个过程有时被称为<strong>向上转换(upcasting)</strong>。</p><p>但是，<strong>如果有一种方法可以将基指针转换回派生指针呢</strong>? 然后，我们可以直接使用该指针调用Derived::getName()，而完全不需要担心虚函数的解析问题。</p><blockquote><p>有，那就是动态类型转换：<strong>dynamic_cast</strong></p></blockquote></li></ul><h2 id="什么是dynamic-cast"><a href="#什么是dynamic-cast" class="headerlink" title="什么是dynamic_cast"></a>什么是dynamic_cast</h2><p><strong>c++提供了一个名为<code>dynamic_cast</code>的转换操作符</strong>，可用于 将即指针转换回 派生指针。</p><p>尽管动态强制转换有一些不同的功能，但到目前为止，<strong>动态强制转换最常见的用途是将基类指针转换为派生类指针。</strong>——这个过程称为<strong>向下转换(downcasting)</strong>。</p><p>使用dynamic_cast的工作原理与使用static_cast一样。下面是我们的例子main()，使用dynamic_cast将我们的基指针转换回派生指针:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *b = getObject(<span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用动态强制转换将基指针转换为派生指针</span></span><br><span class="line">    Derived *d = <span class="keyword">dynamic_cast</span>&lt;Derived*&gt;(b);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"The name of the Derived is: "</span> &lt;&lt; d-&gt;getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The name of the Derived is: Apple</span><br></pre></td></tr></table></figure><h1 id="动态强制类型转换会失败"><a href="#动态强制类型转换会失败" class="headerlink" title="动态强制类型转换会失败"></a>动态强制类型转换会失败</h1><p>上面的例子是可行的，因为b实际上指向一个派生的对象，所以将b转换成一个派生的指针是成功的。</p><p>然而，我们做了一个相当危险的假设: b指向一个派生对象。<u>如果b不是指向一个派生对象呢</u>?</p><blockquote><p>通过将参数getObject()从true更改为false，可以很容易地测试这一点。</p></blockquote><p>在这种情况下，getObject()将返回一个指向基对象的基指针。当我们试图将dynamic_cast转换为派生类型时，<u>它将失败，因为转换无法进行。</u></p><p><strong>如果dynamic_cast失败，转换的结果将是一个<u>空指针</u>。</strong></p><p>因为我们还没有检查空指针结果，所以我们访问了d-&gt;getName()，它将尝试取消对空指针的引用，从而导致未定义的行为(可能导致崩溃)。</p><p><strong>为了使这个程序安全，我们需要确保dynamic_cast的结果确实成功:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base *b = getObject(<span class="literal">true</span>);</span><br><span class="line"> </span><br><span class="line">        Derived *d = <span class="keyword">dynamic_cast</span>&lt;Derived*&gt;(b); <span class="comment">// 使用动态强制转换将基指针转换为派生指针</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (d) <span class="comment">// 确保d是非空指针</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The name of the Derived is: "</span> &lt;&lt; d-&gt;getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">delete</span> b;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，由于dynamic_cast在 <u>运行时</u> 执行一些 一致性检查(以确保可以进行转换)，使用dynamic_cast确实会导致性能损失。</strong></p><h2 id="其他使用dynamic-cast失败的情况"><a href="#其他使用dynamic-cast失败的情况" class="headerlink" title="其他使用dynamic_cast失败的情况"></a>其他使用<code>dynamic_cast</code>失败的情况</h2><ul><li><p>具有 受保护 或 私有 继承的。</p></li><li><p>对于没有声明或继承任何虚函数(因此没有虚表)的类。</p></li><li><p>在涉及 虚拟基类 的某些情况下(有关这些情况的示例以及如何解决它们，请参见下面链接)。</p><blockquote><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/dynamic-cast-operator?redirectedfrom=MSDN&amp;view=vs-2019" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/cpp/cpp/dynamic-cast-operator?redirectedfrom=MSDN&amp;view=vs-2019</a></p></blockquote></li></ul><h1 id="用static-cast进行向下转换"><a href="#用static-cast进行向下转换" class="headerlink" title="用static_cast进行向下转换"></a>用<code>static_cast</code>进行向下转换</h1><p>事实证明，向下转换也可以用static_cast完成。主要的区别是static_cast不执行运行时类型检查，来确保您所做的操作是有意义的。</p><p><strong>这使得使用static_cast更快，但更危险</strong>。如果将 Base* 强制转换为Derived* ，即使基指针没有指向派生对象，它也会“成功”。当您试图访问产生的派生指针(实际上是指向基对象)时，这将导致未定义的行为。</p><p><u>如果您绝对确定向下强制转换的指针将成功，那么使用static_cast是可以接受的</u>。<strong>确保您知道所指向的对象类型的一种方法是使用虚函数</strong>。这里有一种方法(不是很好，因为它使用了一个全局变量):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 类标识符</span></span><br><span class="line"><span class="keyword">enum</span> ClassID</span><br><span class="line">&#123;</span><br><span class="line">BASE,</span><br><span class="line">DERIVED</span><br><span class="line"><span class="comment">// Others can be added here later</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> m_value;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Base(<span class="keyword">int</span> value)</span><br><span class="line">: m_value(value)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">virtual</span> ~Base() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> ClassID <span class="title">getClassID</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> BASE; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Derived(<span class="keyword">int</span> value, <span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">: Base(value), m_name(name)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> ClassID <span class="title">getClassID</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> DERIVED; &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">Base* <span class="title">getObject</span><span class="params">(<span class="keyword">bool</span> bReturnDerived)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bReturnDerived)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Derived(<span class="number">1</span>, <span class="string">"Apple"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Base(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base *b = getObject(<span class="literal">true</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (b-&gt;getClassID() == DERIVED)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 我们已经证明了b指向一个派生的对象，所以这应该总是成功的</span></span><br><span class="line">Derived *d = <span class="keyword">static_cast</span>&lt;Derived*&gt;(b);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The name of the Derived is: "</span> &lt;&lt; d-&gt;getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">delete</span> b;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最好还是使用dynamic-cast"><a href="#最好还是使用dynamic-cast" class="headerlink" title="最好还是使用dynamic_cast"></a>最好还是使用<code>dynamic_cast</code></h2><p>但是，如果您要经历实现这一点的所有困难( 并且要为调用虚函数和处理结果付出代价 )，<strong>那么最好只使用dynamic_cast。</strong></p><h1 id="dynamic-cast和引用"><a href="#dynamic-cast和引用" class="headerlink" title="dynamic_cast和引用"></a>dynamic_cast和引用</h1><p>尽管上面所有的例子都显示了指针的动态转换(这更常见)，<strong>dynamic_cast也可以与引用一起使用</strong>。这类似于dynamic_cast处理指针的方式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> m_value;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Base(<span class="keyword">int</span> value)</span><br><span class="line">: m_value(value)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">virtual</span> ~Base() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Derived(<span class="keyword">int</span> value, <span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">: Base(value), m_name(name)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">apple</span><span class="params">(<span class="number">1</span>, <span class="string">"Apple"</span>)</span></span>; </span><br><span class="line">    Base &amp;b = apple; <span class="comment">//使用引用而不是指针进行动态转换</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 我们可以通过d访问Derived::getName</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The name of the Derived is: "</span> &lt;&lt; d.getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>因为c++没有“空引用”，dynamic_cast在失败时不能返回空引用</strong>。<strong>相反，如果引用的dynamic_cast失败，则抛出std::bad_cast类型的异常</strong>。我们将在本教程的后面讨论异常。</p><h1 id="dynamic-cast-与-static-cast-的比较"><a href="#dynamic-cast-与-static-cast-的比较" class="headerlink" title="dynamic_cast 与 static_cast 的比较"></a><code>dynamic_cast</code> 与 <code>static_cast</code> 的比较</h1><p>新程序员有时会对何时使用static_cast和dynamic_cast感到困惑。答案很简单:</p><ul><li>使用static_cast，<strong>除非是向下强制转换，在这种情况下，dynamic_cast通常是更好的选择</strong>。</li><li>但是，您还应该考虑完全避免强制转换，只使用虚函数。</li></ul><h1 id="向下转换vs虚函数"><a href="#向下转换vs虚函数" class="headerlink" title="向下转换vs虚函数"></a>向下转换vs虚函数</h1><p>有些开发人员认为dynamic_cast是邪恶的，并且是一个糟糕的类设计的象征。相反，这些程序员认为应该使用虚拟函数。</p><p>一般来说，<strong>使用虚函数比向下强制转换更可取</strong>。</p><p>然而，<strong>有时向下转换是更好的选择:</strong></p><ul><li>当您不能修改基类来添加虚函数时(例如，因为基类是标准库的一部分)</li><li>当您需要访问特定于派生类的内容时(例如，仅存在于派生类中的访问函数)</li></ul><p>当向基类添加虚函数没有意义时(例如，基类返回的值不合适)。如果您不需要实例化基类，那么使用<strong>纯虚函数</strong>可能是一种选择。</p><h1 id="关于dynamic-cast和RTTI的警告"><a href="#关于dynamic-cast和RTTI的警告" class="headerlink" title="关于dynamic_cast和RTTI的警告"></a>关于dynamic_cast和RTTI的警告</h1><p>运行时类型信息(RTTI)是c++的一个特性，它在<strong>运行时</strong>公开有关对象数据类型的信息。<strong>dynamic_cast利用了这个功能。</strong></p><p><strong>由于RTTI有相当大的空间性能成本，一些编译器允许您关闭RTTI作为优化。如果这样做，dynamic_cast将无法正常工作。</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/对象切片</title>
      <link href="/archives/c1cd5bf1.html"/>
      <url>/archives/c1cd5bf1.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/12-8-object-slicing/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/12-8-object-slicing/</a></p><hr><p>让我们回到之前看的一个例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value&#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(<span class="keyword">int</span> value)</span><br><span class="line">        : m_value&#123; value &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Base"</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">int</span> value)</span><br><span class="line">        : Base&#123; value &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Derived"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived&#123; <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"derived is a "</span> &lt;&lt; derived.getName() &lt;&lt; <span class="string">" and has value "</span> &lt;&lt; derived.getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    Base &amp;ref&#123; derived &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ref is a "</span> &lt;&lt; ref.getName() &lt;&lt; <span class="string">" and has value "</span> &lt;&lt; ref.getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    Base *ptr&#123; &amp;derived &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ptr is a "</span> &lt;&lt; ptr-&gt;getName() &lt;&lt; <span class="string">" and has value "</span> &lt;&lt; ptr-&gt;getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，ref引用和ptr指向derived，<strong>它有一个基部分和一个派生部分</strong>。<strong>因为ref和ptr是Base类型的，ref和ptr只能看到derived的Base部分——derived的derived部分仍然存在，但是不能通过ref或ptr看到</strong>。</p><p><strong>然而，通过使用虚函数，我们可以访问最派生的函数版本</strong>。因此，上面的程序打印:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">derived is a Derived and has value 5</span><br><span class="line">ref is a Derived and has value 5</span><br><span class="line">ptr is a Derived and has value 5</span><br></pre></td></tr></table></figure><h1 id="对象切片"><a href="#对象切片" class="headerlink" title="对象切片"></a>对象切片</h1><p>但是，如果不设置基引用或指向派生对象的指针，<strong>而是简单地将派生对象分配给基对象</strong>，会发生什么情况呢?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived&#123; <span class="number">5</span> &#125;;</span><br><span class="line">    Base base&#123; derived &#125;; <span class="comment">// what happens here?</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"base is a "</span> &lt;&lt; base.getName() &lt;&lt; <span class="string">" and has value "</span> &lt;&lt; base.getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记住，导函数有基部和导函数部。<strong>当我们将派生对象分配给基对象时，只复制派生对象的基部分。派生部分则不是</strong>。</p><p>在上面的示例中，<u>base接收派生的基本部分的副本，但不接收派生部分的副本</u>。<strong>这个衍生的部分已经被有效地“切掉”了。</strong>因此，<strong><u>将派生类对象 <em>赋值</em> 给基类对象</u> 称为对象切片(或简称为切片)。</strong></p><blockquote><p>因为变量base没有派生部分，所以base.getName()解析为base::getName()。</p><p>上面的例子打印:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base is a Base and has value 5</span><br></pre></td></tr></table></figure></blockquote><hr><ul><li><p>认真使用，切片可以是良性的。</p></li><li><p>然而，如果使用不当，切片可能会以许多不同的方式导致意想不到的结果。</p></li></ul><p>让我们来研究一下其中的一些情况：</p><h2 id="切片和函数"><a href="#切片和函数" class="headerlink" title="切片和函数"></a>切片和函数</h2><p>现在，你可能觉得上面的例子有点傻。毕竟，为什么要把派生赋给base呢?你可能不会。然而，切片更可能在函数中意外发生。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printName</span><span class="params">(<span class="keyword">const</span> Base base)</span> <span class="comment">// 注意:base是通过值传递的，而不是引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a "</span> &lt;&lt; base.getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个非常简单的函数，带有一个通过值传递的const基对象参数。如果我们这样调用这个函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived d&#123; <span class="number">5</span> &#125;;</span><br><span class="line">    printName(d); <span class="comment">// 糟糕，没有意识到这是 在调用端按值传递的</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在编写这个程序时，您可能没有注意到base是一个值参数，而不是引用<strong>。因此，当调用printName(d)时，我们可能期望base.getName()调用虚拟化函数getName()并打印“I am a Derived”，但实际情况并非如此。相反，派生对象d被切片，只有基部分被复制到基参数中。当base.getName()执行时，即使已经虚拟化了getName()函数，也没有类的派生部分需要解析</strong>。因此，这个程序打印:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I am a Base</span><br></pre></td></tr></table></figure></blockquote><p>在这种情况下，很明显发生了什么，但是如果您的函数实际上没有打印任何像这样的标识信息，跟踪错误可能会很困难。</p><p>当然，<strong><u>通过将函数参数设置为引用而不是按值传递</u>，可以很容易地避免这里的切片</strong>(这也是为什么按引用传递类而不是按值传递类是一个好主意的另一个原因)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printName</span><span class="params">(<span class="keyword">const</span> Base &amp;base)</span> <span class="comment">// 注意:base现在通过引用传递</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a "</span> &lt;&lt; base.getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived d&#123; <span class="number">5</span> &#125;;</span><br><span class="line">    printName(d);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">I am a Derived</span><br></pre></td></tr></table></figure><h2 id="切片-vector"><a href="#切片-vector" class="headerlink" title="切片 vector"></a>切片 <code>vector</code></h2><p>然而，新程序员在使用切片时遇到的另一个问题是试图使用<strong><code>std::vector</code></strong>实现多态性。考虑以下程序:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Base&gt; v&#123;&#125;;</span><br><span class="line">v.push_back(Base&#123; <span class="number">5</span> &#125;); <span class="comment">// add a Base object to our vector</span></span><br><span class="line">v.push_back(Derived&#123; <span class="number">6</span> &#125;); <span class="comment">// add a Derived object to our vector</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Print out all of the elements in our vector</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; element : v)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a "</span> &lt;&lt; element.getName() &lt;&lt; <span class="string">" with value "</span> &lt;&lt; element.getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I am a Base with value 5</span><br><span class="line">I am a Base with value 6</span><br></pre></td></tr></table></figure><p>与前面的示例类似，因为std::vector被声明为Base类型的向量，当派生(6)添加到该向量时，它被切片。</p><blockquote><p>修复这个问题有点困难。许多新程序员尝试创建一个std::vector对象的引用，像这样:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Base&amp;&gt; v&#123;&#125;;</span><br></pre></td></tr></table></figure><p>不幸的是，这无法编译。<strong>std::vector的元素必须是可赋值的，而引用不能被重新赋值(只能初始化)。</strong></p></blockquote><h3 id="解决办法：指针向量"><a href="#解决办法：指针向量" class="headerlink" title="解决办法：指针向量"></a>解决办法：指针向量</h3><p>解决这个问题的一种方法是<strong>创建一个指针向量:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Base*&gt; v&#123;&#125;;</span><br><span class="line"></span><br><span class="line">Base b&#123; <span class="number">5</span> &#125;; <span class="comment">// b和d不能是匿名对象</span></span><br><span class="line">Derived d&#123; <span class="number">6</span> &#125;;</span><br><span class="line"> </span><br><span class="line">v.push_back(&amp;b); <span class="comment">// add a Base object to our vector</span></span><br><span class="line">v.push_back(&amp;d); <span class="comment">// add a Derived object to our vector</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Print out all of the elements in our vector</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* element : v)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a "</span> &lt;&lt; element-&gt;getName() &lt;&lt; <span class="string">" with value "</span> &lt;&lt; element-&gt;getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I am a Base with value 5</span><br><span class="line">I am a Derived with value 6</span><br></pre></td></tr></table></figure><p>对此有几点评论。</p><ul><li>首先，nullptr现在是一个有效的选项，这可能是可取的，也可能是不可取的。</li><li>其次，现在必须处理指针语义，这可能会很麻烦。但好处是，这也允许动态内存分配的可能性，如果您的对象可能超出范围，那么动态内存分配将非常有用。</li></ul><h2 id="The-Frankenobject"><a href="#The-Frankenobject" class="headerlink" title="The Frankenobject"></a>The Frankenobject</h2><p>在上面的例子中，我们已经看到了由于派生类被切割而导致错误结果的情况。现在让我们来看另一种危险的情况，即派生对象仍然存在 !</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived d1&#123; <span class="number">5</span> &#125;;</span><br><span class="line">    Derived d2&#123; <span class="number">6</span> &#125;;</span><br><span class="line">    Base &amp;b&#123; d2 &#125;;</span><br><span class="line"> </span><br><span class="line">    b = d1; <span class="comment">// this line is 有问题</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的前三行非常简单。创建两个派生对象，并设置第二个对象的基引用。</p><p>第四行是误入歧途的地方：因为b指向d2，我们又把d1赋值给b，你可能会认为结果是d1会被复制到d2中。</p><ul><li>如果b是一个派生的的话，那它是对的。</li><li>但是b是一个基类，<strong>c++为类提供的操作符=在默认情况下不是虚拟的。</strong>因此，只有d1的<strong>基部分</strong>被复制到d2中。</li></ul><p>结果，你会发现d2现在有了：</p><ul><li>基底部分是d1</li><li>衍生部分是d2。</li></ul><p>在这个特殊的例子中，这不是问题(因为派生类没有自己的数据)，但是在大多数情况下，您只是创建了一个Frankenobject</p><blockquote><p><strong>Frankenobject</strong>：由多个对象的部分组成</p></blockquote><p>更糟糕的是，没有简单的方法来防止这种情况的发生 (除了尽可能避免这样的赋值)。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>尽管c++支持通过对象切片将派生对象分配给基对象，但通常情况下，这可能只会造成麻烦，<strong>您通常应该尽量避免切片</strong>。</p><p>方法：<strong>确保您的函数参数是引用(或指针)，并且在涉及到派生类时尽量避免任何类型的按值传递。</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/虚拟基类</title>
      <link href="/archives/f7358229.html"/>
      <url>/archives/f7358229.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/128-virtual-base-classes/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/128-virtual-base-classes/</a></p><hr><p>上一章，在<a href="https://www.learncpp.com/cpp-tutorial/117-multiple-inheritance/" target="_blank" rel="noopener">11.7 – Multiple inheritance</a>中，我们停止了对“钻石问题”的讨论。在本节中，我们将继续讨论。</p><h1 id="钻石的问题"><a href="#钻石的问题" class="headerlink" title="钻石的问题"></a>钻石的问题</h1><p>下面是我们从上节课(和一些构造函数)中得到的例子，演示了菱形问题:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PoweredDevice</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    PoweredDevice(<span class="keyword">int</span> power)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"PoweredDevice: "</span> &lt;&lt; power &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scanner</span>:</span> <span class="keyword">public</span> PoweredDevice</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Scanner(<span class="keyword">int</span> scanner, <span class="keyword">int</span> power)</span><br><span class="line">        : PoweredDevice(power)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Scanner: "</span> &lt;&lt; scanner &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span>:</span> <span class="keyword">public</span> PoweredDevice</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Printer(<span class="keyword">int</span> printer, <span class="keyword">int</span> power)</span><br><span class="line">        : PoweredDevice(power)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Printer: "</span> &lt;&lt; printer &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Copier</span>:</span> <span class="keyword">public</span> Scanner, <span class="keyword">public</span> Printer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Copier(<span class="keyword">int</span> scanner, <span class="keyword">int</span> printer, <span class="keyword">int</span> power)</span><br><span class="line">        : Scanner(scanner, power), Printer(printer, power)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>尽管你可能希望得到这样的继承图:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="http://www.learncpp.com/images/CppTutorial/Section11/PoweredDevice.gif" alt="img"></p><p>如果您要创建一个copy类对象，在默认情况下，您将得到PoweredDevice类的两个副本——一个来自Printer，另一个来自Scanner。它的结构如下:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="http://www.learncpp.com/images/CppTutorial/Section11/PoweredDevice2.gif" alt="img"></p><p>我们可以创建一个简短的例子，将在行动中显示这一点:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Copier <span class="title">copier</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就产生了以下结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PoweredDevice: 3</span><br><span class="line">Scanner: 1</span><br><span class="line">PoweredDevice: 3</span><br><span class="line">Printer: 2</span><br></pre></td></tr></table></figure><p>如你所见，PoweredDevice构建了两次。</p><p>虽然这通常是需要的，但有时您可能只希望扫描仪和打印机共享PoweredDevice的一个副本。</p><h1 id="虚拟基类"><a href="#虚拟基类" class="headerlink" title="虚拟基类"></a>虚拟基类</h1><p>要<strong>共享</strong>基类，只需在派生类的继承列表中插入“<code>virtual</code>”关键字即可。这创建了所谓的<strong>虚基类，这意味着只有一个基对象。</strong></p><p><strong>基对象在继承树中的所有对象之间共享，并且只构造一次。</strong></p><p>下面是一个例子(为了简单，没有构造函数)，展示了如何使用virtual关键字创建一个共享基类:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PoweredDevice</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scanner</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> PoweredDevice</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> PoweredDevice</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Copier</span>:</span> <span class="keyword">public</span> Scanner, <span class="keyword">public</span> Printer</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，当您创建复印机类对象时，您将仅为每个复印机获得一个PoweredDevice副本，该副本将由扫描仪和打印机共享。</p><blockquote><p>然而，这又导致了一个问题:如果扫描仪和打印机共享一个PoweredDevice基类，谁负责创建它?</p><p><strong>答案是 Copier</strong>。Copier 构造函数 负责创建PoweredDevice。</p><p>因此，这是第一次 允许Copier直接调用 非直的接父类 的构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PoweredDevice</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    PoweredDevice(<span class="keyword">int</span> power)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"PoweredDevice: "</span> &lt;&lt; power &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scanner</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> PoweredDevice <span class="comment">// 注意:PoweredDevice现在是一个虚拟基类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Scanner(<span class="keyword">int</span> scanner, <span class="keyword">int</span> power)</span><br><span class="line">        : PoweredDevice(power) <span class="comment">// 创建扫描对象需要这一行，但在本例中忽略了这一行</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Scanner: "</span> &lt;&lt; scanner &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> PoweredDevice <span class="comment">// 注意:PoweredDevice现在是一个虚拟基类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Printer(<span class="keyword">int</span> printer, <span class="keyword">int</span> power)</span><br><span class="line">        : PoweredDevice(power) <span class="comment">// 创建扫描对象需要这一行，但在本例中忽略了这一行</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Printer: "</span> &lt;&lt; printer &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Copier</span>:</span> <span class="keyword">public</span> Scanner, <span class="keyword">public</span> Printer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Copier(<span class="keyword">int</span> scanner, <span class="keyword">int</span> printer, <span class="keyword">int</span> power)</span><br><span class="line">        : PoweredDevice(power), <span class="comment">// PoweredDevice是在这里构建的</span></span><br><span class="line">        Scanner(scanner, power), Printer(printer, power)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Copier <span class="title">copier</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PoweredDevice: 3</span><br><span class="line">Scanner: 1</span><br><span class="line">Printer: 2</span><br></pre></td></tr></table></figure><p>如您所见，PoweredDevice只构造一次。</p></blockquote><p>有一些细节，如果我们不提，那就是我们的疏忽：</p><ul><li><p>首先，虚基类总是在非虚基类<strong>之前</strong>创建，这确保了所有的基 都在它们的派生类之前创建。</p></li><li><p>其次，注意Scanner 和 Printer的构造函数仍然有对PoweredDevice构造函数的调用。</p><blockquote><p>当创建一个copy实例时，这些构造函数调用被简单地忽略，因为copier负责创建PoweredDevice。</p><p>但是，如果我们要创建一个Scanner或Printer的实例，将使用那些构造函数调用，并应用常规继承规则。</p></blockquote></li><li><p>第三，如果一个类继承了一个或多个具有虚父类的类，那么<strong>最派生</strong>的类负责构造虚基类。</p><blockquote><p>在本例中，copier继承了Printer和Scanner，它们都有一个PoweredDevice虚拟基类。</p><p><strong>copier是最派生的类，负责创建PoweredDevice。</strong></p><blockquote><p>注意，即使在单个继承情况下也是如此: 如果copy是从Printer单独继承的，而Printer实际上是从PoweredDevice继承的，那么copier<u>仍然</u>负责创建PoweredDevice。</p></blockquote></blockquote></li><li><p>第四，<strong>所有继承虚基类的类都将有一个虚表</strong> (即使它们通常没有虚表) ，<u>因此它们的大小会增大 一个指针的大小。</u></p></li></ul><p><strong>因为Scanner and Printer 实际上是从PoweredDevice派生出来的，所以Copier将只作为一个PoweredDevice子对象</strong>。</p><p>Scanner and Printer 都需要知道如何找到那个单独的PoweredDevice子对象，这样它们就可以访问它的成员(因为它们毕竟是从它派生出来的)。</p><blockquote><p>这通常是通过一些虚表 魔法来完成的(它实际上将每个子类的偏移量存储到PoweredDevice子对象中)。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/纯虚函数、抽象基类、接口类</title>
      <link href="/archives/82369fbe.html"/>
      <url>/archives/82369fbe.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/126-pure-virtual-functions-abstract-base-classes-and-interface-classes/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/126-pure-virtual-functions-abstract-base-classes-and-interface-classes/</a></p><hr><h1 id="纯虚-抽象-函数与-抽象基类"><a href="#纯虚-抽象-函数与-抽象基类" class="headerlink" title="纯虚(抽象)函数与 抽象基类"></a>纯虚(抽象)函数与 抽象基类</h1><blockquote><h1 id="Pure-virtual-functions：纯虚函数"><a href="#Pure-virtual-functions：纯虚函数" class="headerlink" title="Pure virtual functions：纯虚函数"></a>Pure virtual functions：纯虚函数</h1></blockquote><p>到目前为止，我们编写的所有虚函数都有一个主体(定义)。<strong>但是，c++允许您创建一种特殊的虚函数，称为纯虚函数(或抽象函数)，它完全没有实体!</strong></p><p><strong>一个纯虚函数只是作为一个占位符，它将被派生类重新定义。</strong></p><p><strong>要创建一个纯虚函数，而不是为函数定义一个主体，我们只需将函数赋值为0。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">sayHi</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Hi"</span>; &#125; <span class="comment">// a normal non-virtual function    </span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Base"</span>; &#125; <span class="comment">// a normal virtual function</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 编译错误:无法将非虚函数设置为0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>当我们向类添加一个纯虚函数时，我们实际上是在说，“实现这个函数取决于派生类”。</strong></p><p>使用纯虚函数有两个主要的结果:</p><ul><li><p>首先，任何带有一个或多个纯虚函数的类都变成了一个<strong>抽象基类</strong>，这意味着它不能被实例化!</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//考虑一下如果我们可以创建一个Base实例会发生什么:</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base base; <span class="comment">// 我们不能实例化一个抽象基类⭐，但是为了举例说明，假设这是允许的</span></span><br><span class="line">    base.getValue(); <span class="comment">// what would this do?</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为没有getValue()的定义，那么base.getValue()解析成什么呢?</p></blockquote></li><li><p>其次，任何派生类都必须为这个函数定义一个主体，否则这个派生类也会被认为是一个抽象基类。</p></li></ul><h2 id="一个纯虚函数的例子"><a href="#一个纯虚函数的例子" class="headerlink" title="一个纯虚函数的例子"></a>一个纯虚函数的例子</h2><p>让我们看一个纯虚函数的例子。在前一课中，我们编写了一个简单的动物基类，并从中派生了一个Cat类。这是我们留下的代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//我们使这个构造函数受保护，因为</span></span><br><span class="line">    <span class="comment">//我们不希望人们直接创建动物对象，但是我们仍然希望派生类能够使用它。</span></span><br><span class="line">    Animal(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : m_name(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">speak</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"???"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cat(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : Animal(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">speak</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Meow"</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们通过使构造函数受保护来阻止人们分配Animal类型的对象。然而，这样做有两个问题:</p><ul><li>构造函数仍然可以从派生类中访问，这使得实例化一个Animal对象成为可能。</li><li>仍然可以创建不重新定义函数speak()的派生类。</li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cow</span>:</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cow(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : Animal(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// We forgot to redefine speak</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Cow <span class="title">cow</span><span class="params">(<span class="string">"Betsy"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cow.getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; cow.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Betsy says ???</span><br></pre></td></tr></table></figure><p>发生了什么事? 我们忘记了重新定义函数speak()，因此cow.Speak()解析为Animal.speak()，这不是我们想要的。</p><p><strong>更好的解决方法是使用纯虚函数:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> // 这个动物是一个抽象基类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Animal(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : m_name(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 注意，speak现在是一个纯虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里有几点需要注意。</p><ul><li><p>speak()现在是一个纯虚函数。这意味着Animal现在是一个抽象基类，不能被实例化。</p><blockquote><p>因此，我们不再需要使构造函数为protected(尽管它不会造成伤害)。</p></blockquote></li><li><p>其次，因为我们的Cow类派生自Animal，<u>但是我们没有定义Cow::speak()， 所以Cow也是一个抽象基类</u>。现在，当我们试图编译这段代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cow</span>:</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cow(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : Animal(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// We forgot to redefine speak</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Cow <span class="title">cow</span><span class="params">(<span class="string">"Betsy"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cow.getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; cow.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会给我们一个警告，因为Cow是一个抽象基类，我们不能创建抽象基类的实例:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Test.cpp(141) : error C2259: 'Cow' : cannot instantiate abstract class due to following members:</span><br><span class="line">        C:Test.cpp(128) : see declaration of 'Cow'</span><br><span class="line">C:\Test.cpp(141) : warning C4259: 'const char *__thiscall Animal::speak(void)' : pure virtual function was not defined</span><br></pre></td></tr></table></figure><p>这告诉我们，只有当Cow为speak()提供了一个主体时，我们才能够实例化Cow。</p></li></ul><p>修改后的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cow</span>:</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cow(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : Animal(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">speak</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Moo"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Cow <span class="title">cow</span><span class="params">(<span class="string">"Betsy"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cow.getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; cow.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Betsy says Moo</span><br></pre></td></tr></table></figure><p><strong>当我们想要将一个函数放入基类中，但只有派生类知道它应该返回什么时，纯虚函数是有用的。纯虚函数使基类无法实例化，派生类被迫在实例化这些函数之前定义它们。这有助于确保派生类不会忘记重新定义基类所期望的函数。</strong></p><h1 id="带有主体的纯虚函数"><a href="#带有主体的纯虚函数" class="headerlink" title="带有主体的纯虚函数"></a>带有主体的纯虚函数</h1><p>事实证明，我们可以定义具有肉体的纯虚函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> // 这个<span class="title">Animal</span>是一个抽象基类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Animal(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : m_name(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// The = 0 表示这个函数是纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Animal::speak</span><span class="params">()</span>  <span class="comment">// 即使它有身体</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"buzz"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，speak()仍然被认为是一个纯虚函数(因为“= 0”，即使已经给了它一个主体)，Animal仍然被认为是一个抽象基类(因此不能被实例化)。</p><p>任何继承自Animal的类都需要为speak()提供自己的定义，否则也会被认为是一个抽象基类。</p><blockquote><p>当为纯虚函数提供正文时，<strong>必须单独提供正文(不是内联的)。</strong></p></blockquote><hr><p>当您希望基类为函数提供默认实现，但仍然强制任何派生类提供它们自己的实现时，此范例非常有用。<strong>但是，如果派生类对基类提供的默认实现感到满意，它可以直接调用基类实现。例如：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> // <span class="title">This</span> <span class="title">Animal</span> <span class="title">is</span> <span class="title">an</span> <span class="title">abstract</span> <span class="title">base</span> <span class="title">class</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Animal(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : m_name(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// note that speak is a pure virtual function</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Animal::speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"buzz"</span>; <span class="comment">// some default implementation</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dragonfly</span>:</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dragonfly(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : Animal(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">speak</span><span class="params">()</span> <span class="comment">//⭐ 个类不再是抽象的，因为我们定义了这个函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Animal::speak(); <span class="comment">// 使用Animal的默认实现i</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Dragonfly <span class="title">dfly</span><span class="params">(<span class="string">"Sally"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; dfly.getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; dfly.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Sally says buzz</span><br></pre></td></tr></table></figure><p>这种功能并不常用。</p><h1 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h1><blockquote><p><strong>Interface classes</strong> ： 接口类</p></blockquote><p>接口类是一个<strong>没有成员变量的类</strong>，其中<strong>所有的函数都是纯虚的</strong>!</p><blockquote><p>换句话说，<strong>该类纯粹是一个定义，没有实际的实现</strong>。</p></blockquote><p>当您想定义派生类必须实现的功能，但将派生类如何实现该功能的细节完全留给派生类时，接口是有用的。</p><p><strong>接口类通常以I开头。</strong></p><p>下面是一个示例接口类:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IerrorLog</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">openLog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">closeLog</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">writeError</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *errorMessage)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个虚析构函数，假设我们删除一个IErrorLog指针，</span></span><br><span class="line">    <span class="comment">// 这样就可以调用正确的派生析构函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~IErrorLog() &#123;&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>从IErrorLog继承的任何类必须为所有三个函数提供实现，以便实例化</strong>。</p><blockquote><p>您可以派生一个名为<strong>FileErrorLog</strong>的类，其中：</p><ul><li>openLog()打开磁盘上的文件，</li><li>closeLog()关闭文件，</li><li>writeError()将消息写入文件。</li></ul><p>您可以派生另一个名为<strong>ScreenErrorLog</strong>的类，</p><p>其中openLog()和closeLog()什么都不做，writeError()在屏幕上的弹出消息框中打印消息。</p><p>现在，假设您需要编写一些使用错误日志的代码。<strong>如果您编写的代码中直接包含了FileErrorLog或ScreenErrorLog，那么您实际上是在使用这种错误日志(至少在不重新编写程序的情况下)</strong>。例如，下面的函数有效地迫使mySqrt()的调用者使用FileErrorLog，这可能是他们想要的，也可能不是。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; // for sqrt()</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">double</span> value, FileErrorLog &amp;<span class="built_in">log</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0.0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>.writeError(<span class="string">"Tried to take square root of value less than 0"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现这个函数的一个更好的方法是使用IErrorLog:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; // for sqrt()</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">double</span> value, IErrorLog &amp;<span class="built_in">log</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0.0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>.writeError(<span class="string">"Tried to take square root of value less than 0"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，<strong>调用者可以传入任何符合IErrorLog接口的类</strong>。⭐</p><ul><li>如果他们希望错误转移到文件中，他们可以传入FileErrorLog的实例。</li><li>如果他们想让它显示在屏幕上，他们可以传入一个ScreenErrorLog实例。</li><li>或者，如果他们想做一些您甚至没有想到的事情，比如在出现错误时向某人发送电子邮件，他们可以从IErrorLog(例如EmailErrorLog)派生一个新类并使用它的一个实例!</li></ul><p>通过使用IErrorLog，您的函数变得更加独立和灵活。</p></blockquote><p><strong>不要忘记为您的接口类包含一个虚析构函数，以便在删除指向接口的指针时调用适当的派生析构函数。</strong></p><h1 id="纯虚函数与虚表"><a href="#纯虚函数与虚表" class="headerlink" title="纯虚函数与虚表"></a>纯虚函数与虚表</h1><p>抽象类仍然有虚表，因为如果有指向抽象类的指针或引用，仍然可以使用虚表。纯虚函数的虚表条目通常要么包含一个空指针，要么指向一个泛型函数，<u>如果没有提供覆盖，这个泛型函数会输出一个错误(有时这个函数被命名为_purecall)。</u></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/虚表及隐藏的指针(__vptr)</title>
      <link href="/archives/71c91a8.html"/>
      <url>/archives/71c91a8.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/125-the-virtual-table/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/125-the-virtual-table/</a></p><hr><h1 id="虚表"><a href="#虚表" class="headerlink" title="虚表"></a>虚表</h1><p><strong>为了实现虚函数，c++使用了一种特殊的后期绑定形式，称为虚表</strong>。</p><p><strong>虚表是用于以 动态/后期绑定方式 解析函数调用 的函数的查找表</strong>。</p><blockquote><p>虚表有时使用其他名称：虚函数表、调度表、….</p><p>“vtable”, “virtual function table”, “virtual method table”, or “dispatch table”.</p></blockquote><hr><p>虚表实际上非常简单，虽然用文字描述有点复杂。</p><ul><li><p>首先，每个使用虚函数的类 (或派生自使用虚函数的类) 都有自己的<strong>虚表</strong>。</p><blockquote><p>这个表只是编译器在编译时设置的一个<u>静态数组</u>。</p></blockquote><p>虚表包含一个条目，记录了：每个虚函数可以被调用的类的对象。这个表中的每个条目都是一个函数指针，指向该类可访问的<strong>派生程度最高</strong>的函数。</p></li><li><p>其次，编译器还向基类添加了一个<strong>隐藏指针，我们称之为 <code>*__vptr</code></strong>。<code>*__vptr</code>在创建类实例时设置(自动)，以便它指向该类的虚表。</p><blockquote><p><em>this指针，它实际上是编译器用来解析自引用的*</em>函数参数**</p><p><code>*__vptr</code>：是一个真实的指针，它使分配的每个类对象的大小增加一个指针。<strong>这也意味着<code>*__vptr</code>是由派生类继承的，这一点很重要。</strong></p></blockquote></li></ul><p>到目前为止，你可能对这些东西是如何组合在一起的感到困惑，所以让我们看一个简单的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为这里有3个类，编译器将设置<strong>3个虚表</strong>: 一个用于Base，一个用于D1，一个用于D2。</p><h1 id="隐藏指针"><a href="#隐藏指针" class="headerlink" title="隐藏指针"></a>隐藏指针</h1><p>编译器还向使用虚函数的最基类添加一个<strong>隐藏指针</strong>。虽然编译器会自动这样做，我们会把它放在下一个例子，只是为了显示它是在哪里添加的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FunctionPointer *__vptr;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当创建一个类对象时，<code>*__vptr</code>被设置为指向该类的虚表。例如：</p><ul><li>当创建了一个Base类型的对象时，<code>*__vptr</code>被设置为指向Base的虚表。</li><li>当构造D1或D2类型的对象时，<code>*__vptr</code>被设置为分别指向D1或D2的虚表。</li></ul><h1 id="虚表如何生成的？"><a href="#虚表如何生成的？" class="headerlink" title="虚表如何生成的？"></a>虚表如何生成的？</h1><p>现在，让我们讨论一下这些虚拟表是如何填写的。因为这里只有两个虚函数，每个虚表将有两个条目(一个用于function1()，另一个用于function2())。<strong>请记住，当这些虚表被填满时，每个条目都填满了该类类型的对象可以调用的派生程度最高的函数</strong>。</p><ul><li><p><strong>基类</strong>对象的虚表很简单。Base类型的对象只能访问Base的成员。Base不能访问D1或D2函数。因此，function1的入口指向Base::function1()，而function2的入口指向Base::function2()。</p></li><li><p>D1的虚表稍微复杂一些。类型D1的对象可以访问D1和Base的成员。但是，D1已经覆盖了function1()，使得D1::function1()比Base::function1()更派生。因此，function1的条目指向D1::function1()。D1没有覆盖function2()，因此function2的条目将指向Base::function2()。</p></li><li><p>D2的虚表类似于D1，除了function1的条目指向Base::function1()，而function2的条目指向D2::function2()。</p></li></ul><p>就像下面这个图显示的一样：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="http://www.learncpp.com/images/CppTutorial/Section12/VTable.gif" alt="img"></p><p>尽管这个图看起来有点疯狂，但它确实非常简单: <strong>每个类中的* vptr指向该类的虚表。</strong> <strong>虚表中的条目指向该类的函数对象的派生程度最高的版本。</strong></p><hr><h1 id="通过例子理解虚表与隐藏指针"><a href="#通过例子理解虚表与隐藏指针" class="headerlink" title="通过例子理解虚表与隐藏指针"></a>通过例子理解虚表与隐藏指针</h1><ol><li><p>考虑一下当我们创建一个D1类型的对象时会发生什么:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D1 d1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为d1是D1对象，d1将它的<code>*__vptr</code> 指向为d1虚表。</p></li><li><p>现在，让我们设置一个指向D1的基指针:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D1 d1;</span><br><span class="line">    Base *dPtr = &amp;d1;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，因为dPtr是一个基指针，所以它只指向d1的基部分。但是，还要注意，<code>*__vptr</code>位于类的基部分，因此dPtr可以访问这个指针。</p><p>最后，请注意<code>dPtr-&gt;__vptr</code>指向D1虚表! <strong>因此，即使dPtr的类型是Base，它仍然可以访问D1的虚拟表(通过 __vptr)。</strong></p></li><li><p>那么，当我们尝试调用<code>dPtr-&gt;function1()</code>时会发生什么呢?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D1 d1;</span><br><span class="line">    Base *dPtr = &amp;d1;</span><br><span class="line">    dPtr-&gt;function1();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先，程序认识到<code>function1()</code>是一个虚函数。</p></li><li><p>其次，程序使用dPtr-&gt; vptr来访问D1的虚拟表。</p></li><li><p>第三，查找function1()调用D1的虚表的版本。</p><blockquote><p>这已经设置为D1::function1()。因此，dPtr-&gt;function1()解析为D1::function1()!</p></blockquote></li></ul></li></ol><p><strong>通过使用这些表，编译器和程序能够确保函数调用解析到适当的虚函数，即使您只使用一个指针或对基类的引用!</strong></p><h1 id="调用虚函数比调用非虚函数慢"><a href="#调用虚函数比调用非虚函数慢" class="headerlink" title="调用虚函数比调用非虚函数慢"></a>调用虚函数比调用非虚函数慢</h1><p>1、</p><p>调用虚函数比调用非虚函数慢，原因如下:</p><ul><li>首先，我们必须使用<code>*__vptr</code>来访问适当的虚表。</li><li>其次，我们必须为虚表建立索引，以找到要调用的正确函数。只有这样我们才能调用这个函数。</li><li>开始调用函数</li></ul><p>因此，我们必须执行3个操作来找到要调用的函数，而不是对普通的间接函数调用执行2个操作，或者对直接函数调用执行1个操作。然而，对于现代计算机来说，这些额外的时间通常是微不足道的。</p><p>2、</p><p>同样需要提醒的是，任何使用虚函数的类都有一个<code>__vptr</code>，因此它使分配的每个类对象的大小增加一个指针。虚拟函数非常强大，但是它们也有性能代价。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/早起绑定与后期绑定</title>
      <link href="/archives/bc3a234a.html"/>
      <url>/archives/bc3a234a.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/124-early-binding-and-late-binding/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/124-early-binding-and-late-binding/</a></p><hr><h1 id="C-程序执行时CPU的工作"><a href="#C-程序执行时CPU的工作" class="headerlink" title="C++程序执行时CPU的工作"></a>C++程序执行时CPU的工作</h1><p>在这节课和下节课中，我们将进一步了解虚拟函数是如何实现的。虽然这些信息对于有效地使用虚拟函数并不是严格必需的，但是它很有趣。不过，你可以把这两部分都当作可选阅读。</p><p>当一个c++程序被执行时，它按顺序执行，从main()的顶部开始。当遇到函数调用时，执行点会跳转到被调用函数的开头。CPU是如何做到这一点的?</p><ul><li>编译程序时，<strong>编译器将c++程序中的每条语句转换成一行或多行机器语言。</strong>机器语言的每一行都有它自己的唯一顺序地址。这对于函数来说没有什么不同——当遇到一个函数时，它被转换成机器语言并给出下一个可用的地址。因此，每个函数都以唯一的地址结束。</li></ul><h1 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h1><p><strong><u>绑定</u>是指用于将标识符 (如变量和函数名) 转换为地址的过程</strong>。虽然绑定同时用于变量和函数，<u>但在本节课中，我们将重点讨论函数绑定。</u></p><h2 id="早期绑定"><a href="#早期绑定" class="headerlink" title="早期绑定"></a>早期绑定</h2><blockquote><p><strong>早期绑定（也称为静态绑定）</strong>：表示编译器(或链接器) 能够直接将 标识符名称(如函数或变量名) 与 机器地址 相关联。</p><p><strong>因此，当编译器(或链接器)遇到一个函数调用时，它会用一条机器语言指令替换该函数调用，该指令告诉CPU跳转到函数的地址。</strong></p></blockquote><p>编译器遇到的大多数函数调用都是直接的函数调用。<strong>直接函数调用</strong>是直接调用函数的语句。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printValue</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printValue(<span class="number">5</span>); <span class="comment">// 这是一个直接的函数调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u>直接的函数调用可以使用称为<strong>早期绑定</strong>的进程来解决</u>。让我们看看一个使用早期绑定的简单计算器程序:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subtract</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter another number: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; y;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> op;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter an operation (0=add, 1=subtract, 2=multiply): "</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">    &#125; <span class="keyword">while</span> (op &lt; <span class="number">0</span> || op &gt; <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (op)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 直接使用早期绑定调用目标函数</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: result = add(x, y); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: result = subtract(x, y); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: result = multiply(x, y); <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The answer is: "</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为add()、subtract()和multiply()都是直接的函数调用，编译器将使用早期绑定来解析add()、subtract()和multiply()函数调用。</p><p>编译器将用一条机器语言指令替换add()函数调用，这条指令告诉CPU跳转到add()函数的地址。对于subtract() 和 multiply()同样适用。</p><h2 id="后期绑定"><a href="#后期绑定" class="headerlink" title="后期绑定"></a>后期绑定</h2><p>在某些程序中，直到<strong>运行时</strong>(程序运行时)才知道将调用哪个函数。这称为<strong>后期绑定(或动态绑定)。</strong></p><p><strong>在c++中，获得后期绑定的一种方法是使用函数指针</strong>。</p><blockquote><p>简单回顾一下函数指针，<strong>函数指针 是一种指向函数而不是变量的指针。</strong></p><p>函数指针指向的函数 可以使用指针上的 函数调用操作符(<strong><code>()</code></strong>)来调用。</p></blockquote><p>例如，下面的代码调用add()函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个函数指针，使它指向 add函数</span></span><br><span class="line">    <span class="keyword">int</span> (*pFcn)(<span class="keyword">int</span>, <span class="keyword">int</span>) = add;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pFcn(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// add 5 + 3</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过函数指针调用函数也称为间接函数调用。下面的计算器程序在功能上与上面的计算器例子相同，<u>除了它使用了一个函数指针而不是直接的函数调用</u>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subtract</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter another number: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; y;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> op;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter an operation (0=add, 1=subtract, 2=multiply): "</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">    &#125; <span class="keyword">while</span> (op &lt; <span class="number">0</span> || op &gt; <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 创建一个名为pFcn的函数指针(是的，语法很难看)</span></span><br><span class="line">    <span class="keyword">int</span> (*pFcn)(<span class="keyword">int</span>, <span class="keyword">int</span>) = <span class="literal">nullptr</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 设置pFcn指向用户选择的函数</span></span><br><span class="line">    <span class="keyword">switch</span> (op)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: pFcn = add; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: pFcn = subtract; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: pFcn = multiply; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 以x和y作为参数，调用pFcn指向的函数</span></span><br><span class="line"><span class="comment">// 这使用了后期绑定</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The answer is: "</span> &lt;&lt; pFcn(x, y) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在本例中，我们没有直接调用add()、subtract()或multiply()函数，而是将pFcn设置为指向我们希望调用的函数。然后通过指针调用函数。</p><p>编译器无法使用早期绑定来解析调用pFcn(x, y)的函数，因为它无法判断在编译时pFcn将指向哪个函数!</p><hr><h1 id="对比早期绑定、后期绑定"><a href="#对比早期绑定、后期绑定" class="headerlink" title="对比早期绑定、后期绑定"></a>对比早期绑定、后期绑定</h1><ul><li><p>后期绑定的效率稍低一些，因为它涉及额外的间接级别。使用后期绑定，程序必须读取指针中保存的地址，然后跳转到该地址。这涉及一个额外的步骤，使它稍微慢一些。但是，后期绑定的优点是它比早期绑定更灵活，因为直到运行时才需要决定调用哪个函数。</p></li><li><p>通过早期绑定，CPU可以直接跳转到函数的地址。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/虚拟析构函数</title>
      <link href="/archives/6a3f4577.html"/>
      <url>/archives/6a3f4577.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/123-virtual-destructors-virtual-assignment-and-overriding-virtualization/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/123-virtual-destructors-virtual-assignment-and-overriding-virtualization/</a></p><hr><h1 id="虚拟虚构函数"><a href="#虚拟虚构函数" class="headerlink" title="虚拟虚构函数"></a>虚拟虚构函数</h1><p>尽管c++为您的类提供了一个默认的析构函数(如果您自己不提供的话)，<strong>但有时您会希望提供自己的析构函数(特别是当类需要释放内存时)</strong>。</p><p><strong>如果要处理继承，应该始终将析构函数设为虚</strong>。</p><h2 id="当父类的析构函数是非virtual"><a href="#当父类的析构函数是非virtual" class="headerlink" title="当父类的析构函数是非virtual"></a>当父类的析构函数是非virtual</h2><p>考虑下面的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~Base() <span class="comment">// note: not virtual</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Calling ~Base()\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* m_array;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">int</span> length)</span><br><span class="line">    &#123;</span><br><span class="line">        m_array = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~Derived() <span class="comment">// note: not virtual (your compiler may warn you about this)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Calling ~Derived()\n"</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] m_array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived *derived &#123; <span class="keyword">new</span> Derived(<span class="number">5</span>) &#125;;</span><br><span class="line">    Base *base &#123; derived &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为base是一个基指针，所以在删除base时，程序会查看基析构函数是否是虚的。它不是，所以它假设它只需要调用基析构函数。我们可以从上面的例子中看出这一点:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calling ~Base()</span><br></pre></td></tr></table></figure><h2 id="当父类的析构函数是virtual"><a href="#当父类的析构函数是virtual" class="headerlink" title="当父类的析构函数是virtual"></a>当父类的析构函数是virtual</h2><p>但是，我们确实希望delete函数调用 Derived的析构函数(它将依次调用Base的析构函数)，否则m_array将不会被删除。<strong>我们通过使基类的析构函数为虚</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base() <span class="comment">// note: virtual</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Calling ~Base()\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* m_array;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">int</span> length)</span><br><span class="line">    &#123;</span><br><span class="line">        m_array = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">virtual</span> ~Derived() <span class="comment">// note: virtual</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Calling ~Derived()\n"</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] m_array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived *derived &#123; <span class="keyword">new</span> Derived(<span class="number">5</span>) &#125;;</span><br><span class="line">    Base *base &#123; derived &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Calling ~Derived()</span><br><span class="line">Calling ~Base()</span><br></pre></td></tr></table></figure><h2 id="无论何时处理继承，都应该显式的使析构函数为虚函数"><a href="#无论何时处理继承，都应该显式的使析构函数为虚函数" class="headerlink" title="无论何时处理继承，都应该显式的使析构函数为虚函数"></a>无论何时处理继承，都应该显式的使析构函数为虚函数</h2><p>与普通的虚成员函数一样，<strong>如果基类函数是虚的，则所有派生重写都将被视为虚的，而不管它们是否被指定为virtual</strong>。没有必要创建一个空的派生类析构函数来将它标记为虚的。</p><h1 id="虚拟分配"><a href="#虚拟分配" class="headerlink" title="虚拟分配"></a>虚拟分配</h1><p>可以使赋值运算符为virtual。然而，与析构函数的情况不同，虚拟化总是一个好主意，虚拟化赋值操作符实际上打开了一个充满蠕虫的包，并进入了本教程范围之外的一些高级主题。因此，为了简单起见，我们建议您暂时不要使用虚拟任务。</p><h2 id="忽视虚拟化"><a href="#忽视虚拟化" class="headerlink" title="忽视虚拟化"></a>忽视虚拟化</h2><p>很少会忽略函数的虚拟化。例如，考虑以下代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Base"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Derived"</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在某些情况下，您可能需要一个指向派生对象的基指针来调用<code>Base::getName()</code>，而不是<code>Derived::getName()</code>。要做到这一点，<strong>只需使用范围解析操作符</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived;</span><br><span class="line">    Base &amp;base &#123; derived &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用Base::GetName()而不是虚拟化的Derived::GetName()</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; base.Base::getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能不会经常用到它，但知道它至少是可能的是件好事。</p><h1 id="我们应该让所有析构函数都是虚的吗"><a href="#我们应该让所有析构函数都是虚的吗" class="headerlink" title="我们应该让所有析构函数都是虚的吗?"></a>我们应该让所有析构函数都是虚的吗?</h1><p>这是新程序员常问的问题。如上例所述，如果基类析构函数没有标记为虚函数，那么如果程序员稍后删除指向派生对象的基类指针，程序就有内存泄漏的风险。避免这种情况的一种方法是将所有析构函数标记为虚函数。但是你应该吗?</p><p><strong>很容易说yes，这样您以后就可以将任何类用作基类——但是这样做会带来性能损失(向您的类的每个实例添加一个虚指针)。所以你必须平衡成本和你的意图。</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/说明符：override、final 及 协变返回类型</title>
      <link href="/archives/f30af5b2.html"/>
      <url>/archives/f30af5b2.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/12-2a-the-override-and-final-specifiers-and-covariant-return-types/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/12-2a-the-override-and-final-specifiers-and-covariant-return-types/</a></p><hr><p>为了解决继承的一些常见问题，c++ 11在c++中添加了两个特殊的标识符:<strong>override和 final</strong>。</p><blockquote><p>注意，这些标识符不是关键字——它们是在特定上下文中具有特殊意义的普通标识符。</p></blockquote><p>虽然final并不是经常使用，但是override是一个非常好的补充，您应该经常使用它。</p><p>在这节课中，我们将看一下这两种情况，以及<strong>虚函数重写</strong> 返回类型必须匹配的规则的一个例外。</p><h1 id="override说明符"><a href="#override说明符" class="headerlink" title="override说明符"></a>override说明符</h1><p>正如我们在前一课中提到的，派生类虚函数<strong>只有在其签名和返回类型完全匹配时</strong>才被认为是<strong>重写</strong>。这可能会导致无意的问题：<strong>原本打算覆盖的函数实际上并不是这样</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName1</span><span class="params">(short <span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125; <span class="comment">// note: parameter is a short int</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName2</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125; <span class="comment">// note: function is const</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">B b;</span><br><span class="line">A &amp;rBase = b;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rBase.getName1(<span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rBase.getName2(<span class="number">2</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">A</span><br><span class="line">A</span><br></pre></td></tr></table></figure><p>因为rBase是A 引用对B对象的引用，所以这里的目的是使用虚函数来访问B::getName1()和B::getName2()。</p><ul><li><p>但是，因为B::getName1()接受一个不同的参数(一个短整型而不是一个整型)，所以它不被认为是对a::getName1()的覆盖。</p></li><li><p>更狡猾的是，因为B::getName2()是const，而A::getName2()不是，B::getName2()不被认为是对A::getName2()的覆盖。</p></li></ul><blockquote><p>在这个特殊的例子中，因为A和B只是打印它们的名字，很容易看出我们把重写搞砸了，并且调用了错误的虚函数。但是，在更复杂的程序中，函数有未打印的行为或返回值，这样的问题很难调试。</p></blockquote><p>为了帮助解决函数的重写问题，c++ 11引入了重写说明符(<strong>override specifier</strong>)。</p><p><strong>重写说明符可以应用于任何重写函数</strong>，<u>方法是将说明符放在const要去的相同位置</u>。</p><blockquote><p><strong>如果函数没有覆盖基类函数(或应用于非虚函数)，编译器会将该函数标记为错误。</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName3</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//编译错误，函数不是覆盖(因为函数的形参与父类中的不一样)</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName1</span><span class="params">(short <span class="keyword">int</span> x)</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125;</span><br><span class="line">    <span class="comment">//编译错误，函数不是覆盖(因为这个函数与父类中相应的函数不能完全平匹配，它多了一个 const)</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName2</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125;</span><br><span class="line">    <span class="comment">//好的，该函数是重写A::getName3(int)</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName3</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序产生了两个编译错误:</p><ul><li>一个用于B::getName1()，</li><li>另一个用于B::getName2()，</li></ul><p>因为它们都没有覆盖先前的函数。</p><p>而B::getName3()会覆盖A::getName3()，因此不会为该行产生错误。</p><hr><h2 id="使用override说明符不会导致性能损失"><a href="#使用override说明符不会导致性能损失" class="headerlink" title="使用override说明符不会导致性能损失"></a>使用override说明符不会导致性能损失</h2><p><strong>使用覆盖说明符不会导致性能损失，而且它有助于避免意外错误</strong>。因此，我们强烈建议在您编写的每个虚函数重写中使用它，以确保您确实重写了您认为已经重写的函数。</p><h1 id="final说明符"><a href="#final说明符" class="headerlink" title="final说明符"></a>final说明符</h1><p>在某些情况下，<strong>您可能不希望别人能够重写一个虚函数，或者从一个类继承。</strong></p><p><strong>final说明符 可以用来告诉编译器强制执行它。如果用户试图覆盖已指定为final的函数或类，编译器将给出一个编译错误。</strong></p><h2 id="限制用户重写"><a href="#限制用户重写" class="headerlink" title="限制用户重写"></a>限制用户重写</h2><p>在我们想要限制用户重写函数的情况下，最终说明符( <strong>final specifier</strong>) 的位置与override specifier的位置相同，就像这样:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 注意在后面的行中使用final说明符——这使得这个函数不再是可覆盖的</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> <span class="keyword">override</span> <span class="keyword">final</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125; <span class="comment">// okay, overrides A::getName()</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">"C"</span>; &#125; <span class="comment">// compile error: overrides B::getName(), which is final</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的代码中，B::getName()覆盖了A::getName()，这是可以的。但是B::getName()有final 的说明符，这意味着对该函数的任何进一步重写都应该被认为是一个错误。确实，C::getName()试图覆盖B::getName() (这里的override说明符不相关，只是为了更好的实践)，所以编译器会给出一个编译错误。</p><h2 id="限制从该类继承"><a href="#限制从该类继承" class="headerlink" title="限制从该类继承"></a>限制从该类继承</h2><p>在我们想要防止从类继承的情况下，最后的说明符在类名后面应用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="title">final</span> :</span> <span class="keyword">public</span> A <span class="comment">// 注意这里的 final说明符的使用</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B <span class="comment">//⭐ compile error: cannot inherit from final class</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">"C"</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的例子中，类B被声明为final。因此，当C试图从B继承时，编译器会给出一个编译错误。</p><h1 id="协变返回类型"><a href="#协变返回类型" class="headerlink" title="协变返回类型"></a>协变返回类型</h1><p>在一种特殊情况下，派生类虚函数重写 可能具有与基类不同的<strong>返回类型</strong>，<strong>但仍然被认为是匹配重写</strong>。<strong>如果虚函数的返回类型是<u>指针</u>或对类的<u>引用</u>，则重写函数可以返回指针或对派生类的引用。这些被称为协变返回类型。</strong></p><p>这里有一个例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 这个版本的getThis()返回一个指向基类的指针</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Base* <span class="title">getThis</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"called Base::getThis()\n"</span>; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printType</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"returned a Base\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//通常，重写函数必须返回与基函数类型相同的对象</span></span><br><span class="line"><span class="comment">// 但是，因为Derived是从Base派生的，所以可以返回Derived*而不是Base*</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Derived* <span class="title">getThis</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"called Derived::getThis()\n"</span>;  <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printType</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"returned a Derived\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Derived d;</span><br><span class="line">Base *b = &amp;d;</span><br><span class="line">d.getThis()-&gt;printType(); <span class="comment">// 调用Derived::getThis()，返回Derived*，再调用Derived::printType</span></span><br><span class="line">b-&gt;getThis()-&gt;printType(); <span class="comment">//调用Derived::getThis(), 返回Base*, 再调用 Base::printType</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="function">called <span class="title">Derived::getThis</span><span class="params">()</span></span></span><br><span class="line"><span class="function">returned a Derived</span></span><br><span class="line"><span class="function">called <span class="title">Derived::getThis</span><span class="params">()</span></span></span><br><span class="line"><span class="function">returned a Base</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，一些较老的编译器(例如Visual Studio 6)不支持协变返回类型。</p></blockquote><p>关于协变返回类型有一个有趣的注意: <strong>c++不能动态选择类型，所以您总是会得到与所调用函数的基版本相匹配的类型。</strong></p><hr><p>在上面的例子中，我们首先调用<code>d.getThis()</code>。由于d是派生的，因此调用了<code>Derived::getThis()</code>，它返回一个Derived*。然后使用这个Derived* 调用非虚函数<code>Derived::printType()</code>。</p><p>有趣的情况是： 然后调用<code>b-&gt;getThis()</code>。变量b是一个指向派生对象的Base指针。<code>Base::getThis()</code>是虚函数，因此调用了<code>Derived::getThis()</code>。虽然<code>Derived::getThis()</code>返回一个Derived*，因为函数的基版本返回一个Base*，返回的Derived*向上转换为Base*。因此，调用<code>Base::printType()</code>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/虚函数和多态性</title>
      <link href="/archives/aba94da5.html"/>
      <url>/archives/aba94da5.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/122-virtual-functions/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/122-virtual-functions/</a></p><hr><blockquote><p>虚函数可用于解决的问题，详情请看：</p></blockquote><p>在前面关于<a href="http://www.learncpp.com/cpp-tutorial/121-pointers-and-references-to-the-base-class-of-derived-objects/" target="_blank" rel="noopener">pointers and references to the base class of derived objects</a>中，我们看了一些例子，其中使用基类的指针或引用有可能简化代码。<strong>但是，在每种情况下，我们都会遇到这样的问题: 基指针或引用只能调用函数的基版本，而不能调用派生版本。</strong></p><p>下面是这种行为的一个简单例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Base"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Derived"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived;</span><br><span class="line">    Base &amp;rBase&#123; derived &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rBase is a "</span> &lt;&lt; rBase.getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这节课中，我们将展示如何使用虚函数来解决这个问题。</p><h1 id="虚函数和多态性"><a href="#虚函数和多态性" class="headerlink" title="虚函数和多态性"></a>虚函数和多态性</h1><p><strong>虚函数</strong>是一种特殊类型的函数，当调用虚函数时，解析为存在于基类和派生类之间的函数的<u>最派生版本</u>。这种能力称为<strong>多态性</strong>。</p><blockquote><p>例如，A继承于B，B继承于C。如果从类A中调用一个虚函数，那么该函数会解析为离A<strong>最近的虚函数</strong>。</p></blockquote><p>如果派生函数具有相同的签名 (名称、参数类型以及是否为const)并返回类型作为该函数的基本版本，则将该函数视为<strong>匹配</strong>。这样的函数称为<strong>覆盖</strong>。</p><h2 id="第一个例子："><a href="#第一个例子：" class="headerlink" title="第一个例子："></a>第一个例子：</h2><p><strong>要使函数成为虚函数，只需将“virtual”关键字放在函数声明之前。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Base"</span>; &#125; <span class="comment">// note addition of virtual keyword</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Derived"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived;</span><br><span class="line">    Base &amp;rBase&#123; derived &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rBase is a "</span> &lt;&lt; rBase.getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">rBase is a Derived</span><br></pre></td></tr></table></figure><p>因为rBase是对派生对象的基部分的引用，所以在计算rBase.getName()时，它通常会解析为Base::getName()。<strong>但是，Base::getName()是虚的</strong>，<u>它告诉程序去查看在Base和派生之间是否还有其他派生版本的函数可用。在本例中，它将解析为 Derived::getName()!</u></p><blockquote><p>本例中，引用的对象derived是 Derived类，使用哪个虚函数？ 我们就从Derived类开始 在这个继承树形层级结构中，找到离Derived类最近的那个虚函数。—在这个例子中就是Derived类中的那个虚函数版本（因为它离Derived类最近呀。）</p></blockquote><h2 id="第二个例子："><a href="#第二个例子：" class="headerlink" title="第二个例子："></a>第二个例子：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"C"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"D"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C c;</span><br><span class="line">    A &amp;rBase&#123; c &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rBase is a "</span> &lt;&lt; rBase.getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*你认为这个程序会输出什么?*/</span></span><br><span class="line">rBase is a C</span><br></pre></td></tr></table></figure><p><em>：</em>让我们看看它是如何工作的。</p><ul><li><p>首先，我们实例化一个C类对象。</p></li><li><p>rBase是一个引用，我们将其设置为引用C对象的一部分 的 A。</p></li><li><p>最后，我们调用rBase.getName()。getName()的计算结果是A::getName()。</p><blockquote><p>但是，<strong>A::getName() 是虚的</strong>，<strong>因此编译器将调用A和C之间最派生的匹配</strong>。</p><p>在本例中，就是C::getName()。<strong>注意，它不会调用D::getName()，因为我们的原始对象是C，而不是D，所以只考虑A和C之间的函数。</strong></p></blockquote></li></ul><h1 id="使用virtual关键字"><a href="#使用virtual关键字" class="headerlink" title="使用virtual关键字"></a>使用<code>virtual</code>关键字</h1><p><strong>如果一个函数被标记为<code>virtual</code>，那么所有匹配的覆盖也被认为是虚函数，即使它们没有显式地标记为虚函数。</strong></p><blockquote><p>也就是说，如果父类A的某个函数被标记为<code>virtual</code>，以A为基类的派生类中的 相匹配的该函数的覆盖，就算不显式的标记该函数为<code>virtual</code>，它仍然是一个虚函数。</p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//父类中该函数被标记为 virtual</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Base"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//该派生类 对该函数的覆盖 没有显式的标记它为 virtual，但它仍然是虚函数</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Derived"</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>但是，在派生函数上使用关键字virtual并没有什么害处，它可以提醒您，该函数是一个虚函数，而不是一个普通的函数。<u>因此，在派生类中对虚拟化函数使用virtual关键字通常是一个好主意，尽管这并不是严格必需的。</u></p><h1 id="虚函数的返回类型"><a href="#虚函数的返回类型" class="headerlink" title="虚函数的返回类型"></a>虚函数的返回类型</h1><p>在正常情况下，<strong>虚函数的返回类型</strong> 及 <strong>其覆盖</strong> 必须匹配。考虑下面的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">5</span>; &#125; <span class="comment">//int</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">6.78</span>; &#125; <span class="comment">//double</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>在这种情况下，<code>Derived::getValue()</code> 不被认为是<code>Base::getValue()</code>的匹配覆盖 (它被认为是一个完全独立的函数)。</strong></p><blockquote><p>因为<code>Derived::getValue()</code>与<code>Base::getValue()</code>的返回类型不一样：一个为int，一个为double</p></blockquote><h1 id="不要从构造函数或析构函数调用虚函数"><a href="#不要从构造函数或析构函数调用虚函数" class="headerlink" title="不要从构造函数或析构函数调用虚函数"></a>不要从构造函数或析构函数调用虚函数</h1><p>这是另一个陷阱，经常抓住不知情的新程序员。不应该从构造函数或析构函数调用虚函数。为什么?</p><ul><li><p><strong>请记住，在创建派生类时，首先构造基部分。</strong>如果从基类构造函数调用虚函数，但类的派生部分还没有创建，它将无法调用函数的派生版本，因为派生函数没有要处理的派生对象。<strong>在C++中，它将调用基类版本。</strong></p></li><li><p>析构函数也存在类似的问题。如果在基类析构函数中调用虚函数，<strong>它将始终解析为函数的基类版本，因为类的派生部分已经被销毁。</strong></p></li></ul><p><strong>规则:永远不要从构造函数或析构函数调用虚函数</strong></p><h1 id="虚函数的缺点"><a href="#虚函数的缺点" class="headerlink" title="虚函数的缺点"></a>虚函数的缺点</h1><p>既然大多数情况下你希望函数是虚的，为什么不让所有的函数都是虚的呢?</p><p>答案是：</p><ul><li><strong>因为它的效率很低</strong>——解析一个虚函数调用要比解析一个常规函数调用花费更长的时间。</li><li>此外，<strong>编译器还必须为每个具有一个或多个虚函数的类对象分配一个额外的指针</strong>。我们将在本章以后的课程中更多地讨论这个问题。</li></ul><h1 id="——补充——"><a href="#——补充——" class="headerlink" title="——补充——-"></a>——补充——-</h1><p>多态性(polymorphism)可以简单地概括为“一个接口，多种方法”，它是面向对象编程领域的核心概念。</p><p>多态性指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。C++支持两种多态性：编译时多态性，运行时多态性。</p><ol><li>编译时多态性（静态多态）：通过重载函数实现：先期联编 early binding</li><li>运行时多态性（动态多态）：通过虚函数实现 ：滞后联编 late binding</li></ol><p>C++运行时多态性是通过虚函数来实现的，虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖(Override)，或者称为重写。</p><p>多态与非多态的实质区别就是函数地址是早绑定还是晚绑定。如果函数的调用，在编译器编译期间就可以确定函数的调用地址，并生产代码，是静态的，就是说地址是早绑定的。而如果函数调用的地址不能在编译器期间确定，需要在运行时才确定，这就属于晚绑定。</p><p>多态的目的：封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了“接口重用”。也即，不论传递过来的究竟是类的哪个对象，函数都能够通过同一个接口调用到适应各自对象的实现方法。</p><p>多态最常见的用法就是声明基类类型的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法。如果没有使用虚函数的话，即没有利用C++多态性，则利用基类指针调用相应的函数的时候，将总被限制在基类函数本身，而无法调用到子类中被重写过的函数。因为没有多态性，函数调用的地址将是固定的，因此将始终调用到同一个函数，这就无法实现“一个接口，多种方法”的目的了。</p><h2 id="需要注意："><a href="#需要注意：" class="headerlink" title="需要注意："></a>需要注意：</h2><ol><li>只有类的成员函数才能声明为虚函数，虚函数仅适用于有继承关系的类对象。普通函数不能声明为虚函数。</li><li>静态成员函数不能是虚函数，因为静态成员函数不受限于某个对象。</li><li>内联函数（inline）不能是虚函数，因为内联函数不能在运行中动态确定位置。</li><li>构造函数不能是虚函数。</li><li>析构函数可以是虚函数，而且建议声明为虚函数。</li></ol><h2 id="重写-vs-重载："><a href="#重写-vs-重载：" class="headerlink" title="重写 vs 重载："></a>重写 vs 重载：</h2><p>重写可以有两种，直接重写成员函数和重写虚函数，只有重写了虚函数的才能算作是体现了C++多态性。而重载则是允许有多个同名的函数，而这些函数的参数列表不同，允许参数个数不同，参数类型不同，或者两者都不同。编译器会根据这些函数的不同列表，将同名的函数的名称做修饰，从而生成一些不同名称的预处理函数，来实现同名函数调用时的重载问题。但这并没有体现多态性。</p><h2 id="隐藏："><a href="#隐藏：" class="headerlink" title="隐藏："></a>隐藏：</h2><p>除了重载与覆盖（重写），C++还有隐藏。隐藏是指派生类的函数屏蔽了与其同名的基类函数。隐藏规则如下：</p><ol><li>如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual 关键字，基类的函数将被隐藏（注意别与重载混淆，重载是在同一个类中发生）。</li><li>如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆，覆盖有virtual关键字）。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Base::f(float)"</span>&lt;&lt; x &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">float</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Base::g(float)"</span>&lt;&lt; x &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">(<span class="keyword">float</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Base::h(float)"</span>&lt;&lt; x &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//子类与基类函数同名，有virtual关键字，运行时多态</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Derived::f(float)"</span>&lt;&lt; x &lt;&lt;<span class="built_in">endl</span>;   <span class="comment">//多态、覆盖</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//子类与基类函数同名，且无virtual关键字，隐藏</span></span><br><span class="line">        <span class="comment">//参数不同的隐藏</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Derived::g(int)"</span>&lt;&lt; x &lt;&lt;<span class="built_in">endl</span>;     <span class="comment">//隐藏</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//参数相同的隐藏</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">(<span class="keyword">float</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Derived::h(float)"</span>&lt;&lt; x &lt;&lt;<span class="built_in">endl</span>;   <span class="comment">//隐藏</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Derived d;        <span class="comment">//子类对象</span></span><br><span class="line">Base *pb = &amp;d;    <span class="comment">//基类类型指针，指向子类对象</span></span><br><span class="line">Derived *pd = &amp;d; <span class="comment">//子类类型指针，指向子类对象</span></span><br><span class="line"><span class="comment">// Good : behavior depends solely on type of the object</span></span><br><span class="line">pb-&gt;f(<span class="number">3.14f</span>);   <span class="comment">// Derived::f(float) 3.14  调用子类方法，多态</span></span><br><span class="line">pd-&gt;f(<span class="number">3.14f</span>);   <span class="comment">// Derived::f(float) 3.14  调用自己方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Bad : behavior depends on type of the pointer</span></span><br><span class="line">pb-&gt;g(<span class="number">3.14f</span>);   <span class="comment">// Base::g(float)  3.14 </span></span><br><span class="line">pd-&gt;g(<span class="number">3.14f</span>);   <span class="comment">// Derived::g(int) 3 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Bad : behavior depends on type of the pointer</span></span><br><span class="line">pb-&gt;h(<span class="number">3.14f</span>);   <span class="comment">// Base::h(float) 3.14</span></span><br><span class="line">pd-&gt;h(<span class="number">3.14f</span>);   <span class="comment">// Derived::h(float) 3.14</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有virtual才可能发生多态现象，不发生多态（无virtual）调用就按原类型调用 。</p><p>上面的程序中：</p><p>（1）函数Derived::f(float)覆盖了Base::f(float)，发生多态重写（覆盖）。</p><p>（2）函数Derived::g(int)隐藏了Base::g(float)，而不是重载。</p><p>（3）函数Derived::h(float)隐藏了Base::h(float)，而不是覆盖。</p><p>总结为：在基类与子类函数名相同的前提下，根据参数是否相同、是否具有vritual关键字，可分为4种情况：</p><ol><li>参数相同、有virtual关键字：多态重写；</li><li>参数相同、无virtual关键字：隐藏；与重写区分。</li><li>参数不同、有virtual关键字：隐藏；与重载区分。</li><li>参数不同、无virtual关键字：隐藏；与重载区分。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/指向派生对象的基类的指针和引用</title>
      <link href="/archives/66c8de20.html"/>
      <url>/archives/66c8de20.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/121-pointers-and-references-to-the-base-class-of-derived-objects/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/121-pointers-and-references-to-the-base-class-of-derived-objects/</a></p><hr><p>在前一章中，您学习了如何使用继承从现有类派生新类的所有知识。在本章中，我<strong>们将重点讨论继承最重要和最强大的方面之一——虚拟函数。</strong></p><p>但是在我们讨论什么是虚函数之前，让我们先来设置为什么需要它们。</p><blockquote><p>在 <a href="http://www.learncpp.com/cpp-tutorial/113-order-of-construction-of-derived-classes/" target="_blank" rel="noopener">construction of derived classes</a>中，<strong>您了解了在创建派生类时，它由多个部分组成：一部分是继承的类；另一部分是它本身。</strong></p></blockquote><p>例如，这里有一个简单的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(<span class="keyword">int</span> value)</span><br><span class="line">        : m_value&#123; value &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Base"</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">int</span> value)</span><br><span class="line">        : Base&#123; value &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::string_view <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Derived"</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValueDoubled</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_value * <span class="number">2</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们创建一个派生对象时，它包含一个基类Base 部分(<strong>首先构造</strong>) 和 一个派生Derived部分<strong>(其次构造</strong>)。请记住，继承意味着两个类之间存在一个is-a关系。因为 派生的is-a 基，<strong>所以派生的包含基部分是合适的。</strong></p><h1 id="指针、引用和派生类"><a href="#指针、引用和派生类" class="headerlink" title="指针、引用和派生类"></a>指针、引用和派生类</h1><p>这应该是相当直观的，我们可以设置派生指针和引用的派生对象:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived&#123; <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"derived is a "</span> &lt;&lt; derived.getName() &lt;&lt; <span class="string">" and has value "</span> &lt;&lt; derived.getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    Derived &amp;rDerived&#123; derived &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rDerived is a "</span> &lt;&lt; rDerived.getName() &lt;&lt; <span class="string">" and has value "</span> &lt;&lt; rDerived.getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    Derived *pDerived&#123; &amp;derived &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"pDerived is a "</span> &lt;&lt; pDerived-&gt;getName() &lt;&lt; <span class="string">" and has value "</span> &lt;&lt; pDerived-&gt;getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指向派生类对象的基类指针与引用"><a href="#指向派生类对象的基类指针与引用" class="headerlink" title="指向派生类对象的基类指针与引用"></a>指向派生类对象的基类指针与引用</h2><p>然而，由于Derived有一个基部分，<strong>一个更有趣的问题是c++是否会让我们设置一个基指针或引用到一个派生的对象。事实证明，我们可以!</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived&#123; <span class="number">5</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面的也是合理的</span></span><br><span class="line">    Base &amp;rBase &#123;derived&#125;;</span><br><span class="line">    Base *pBase &#123;&amp;deriverd&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"derived is a "</span> &lt;&lt; derived.getName() &lt;&lt; <span class="string">" and has value "</span> &lt;&lt; derived.getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rBase is a "</span> &lt;&lt; rBase.getName() &lt;&lt; <span class="string">" and has value "</span> &lt;&lt; rBase.getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"pBase is a "</span> &lt;&lt; pBase-&gt;getName() &lt;&lt; <span class="string">" and has value "</span> &lt;&lt; pBase-&gt;getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为rBase和pBase是一个基类的引用和指针，所以它们只能看到基类的成员(或者基类继承的任何类)。</p><p>因此，即使<code>Derived::getName()</code> 的阴影(隐藏)<code>Base::getName()</code>的派生对象，基指针/引用不能看到<code>Derived::getName()</code>。</p><p>因此，它们调用<code>Base::getName()</code>，这就是为什么rBase和pBase报告说它们是基而不是派生的。</p><blockquote><p><strong>注意，这也意味着不可能使用rBase或pBase调用<code>Derived::getValueDoubled()</code>。他们看不到任何衍生的东西。</strong></p></blockquote><hr><p>另一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们使这个构造函数受保护，因为</span></span><br><span class="line"><span class="comment">//我们不希望人们直接创建动物对象，</span></span><br><span class="line"><span class="comment">//但是我们仍然希望派生类能够使用它。</span></span><br><span class="line">Animal(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name) : m_name &#123;name&#125;</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::string_view <span class="title">speak</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"???"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Cat(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name) : Animal&#123;name&#125;</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::string_view <span class="title">speak</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Meow"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Dog(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name) : Animal&#123;name&#125;</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::string_view <span class="title">speak</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Woof"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">Cat cat&#123; <span class="string">"Freed"</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"cat is named "</span> &lt;&lt; cat.getName() &lt;&lt; <span class="string">", and it says"</span></span><br><span class="line">&lt;&lt; cat.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">Dog dog&#123; <span class="string">"HeiHu"</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"dog is named "</span> &lt;&lt; dog.getName() &lt;&lt; <span class="string">", and it says "</span></span><br><span class="line">&lt;&lt; dog.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">Animal* pAnimal&#123; &amp;cat &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"pAnimal is named "</span> &lt;&lt; pAnimal-&gt;getName() &lt;&lt; <span class="string">", and it says "</span></span><br><span class="line">&lt;&lt; pAnimal-&gt;speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">pAnimal = &amp;dog;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"pAnimal is named "</span> &lt;&lt; pAnimal-&gt;getName() &lt;&lt; <span class="string">", and it says "</span> </span><br><span class="line">&lt;&lt; pAnimal-&gt;speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">cat is named Fred, <span class="keyword">and</span> it says Meow</span><br><span class="line">dog is named Garbo, <span class="keyword">and</span> it says Woof</span><br><span class="line">pAnimal is named Fred, <span class="keyword">and</span> it says ???</span><br><span class="line">pAnimal is named Garbo, <span class="keyword">and</span> it says ???</span><br></pre></td></tr></table></figure><p>我们在这里看到了同样的问题。因为pAnimal是一个动物指针，所以它只能看到类的动物部分。<strong>因此，pAnimal-&gt;speak()调用Animal::speak()，而不是Dog:: speak()或Cat::speak()函数。</strong></p><hr><h2 id="用于指向基类的指针和引用"><a href="#用于指向基类的指针和引用" class="headerlink" title="用于指向基类的指针和引用"></a>用于指向基类的指针和引用</h2><p>现在你可能会说，“上面的例子看起来有点傻。当我可以使用派生对象时，为什么要设置一个指针或引用来指向派生对象的基类?“事实证明，有相当多的理由。</p><ul><li><p>首先，假设您想编写一个函数来打印动物的名字和声音。<strong>如果不使用指向基类的指针，就必须使用重载函数来编写它</strong>，如下所示:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">report</span><span class="params">(<span class="keyword">const</span> Cat &amp;cat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cat.getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; cat.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">report</span><span class="params">(<span class="keyword">const</span> Dog &amp;dog)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; dog.getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; dog.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难，但是想想如果我们有30种不同的动物而不是2种，会发生什么。你必须写30个几乎相同的函数!另外，如果你添加了一种新的动物，你也必须为它写一个新的函数。考虑到唯一真正的区别是参数的类型，这是一个巨大的时间浪费。</p><p>然而，因为Cat 和 Dog 派生于 Animal，Cat 和 Dog 有一个Animal的部分。因此，我们应该能够这样做是有意义的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">report</span><span class="params">(<span class="keyword">const</span> Animal &amp;rAnimal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rAnimal.getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; rAnimal.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将允许我们传入任何派生自Animal的类，甚至是我们在编写函数之后创建的类! 不是每个派生类都有一个函数，而是有一个函数可以处理所有从Animal派生的类!</p><p>当然，问题是，因为rAnimal是一个 Animal 引用，所以rAnimal.speak()将调用Animal::speak()，而不是speak()的派生版本。</p></li><li><p>其次，假设您有3只猫和3只狗，您希望将它们放在一个数组中，以便于访问。因为数组只能保存一种类型的对象，没有指针或对基类的引用，所以必须为每个派生类型创建不同的数组，如下所示:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cat cats[]&#123; &#123; <span class="string">"Fred"</span> &#125;, &#123; <span class="string">"Misty"</span> &#125;, &#123; <span class="string">"Zeke"</span> &#125; &#125;;</span><br><span class="line">    Dog dogs[]&#123; &#123; <span class="string">"Garbo"</span> &#125;, &#123; <span class="string">"Pooky"</span> &#125;, &#123; <span class="string">"Truffle"</span> &#125; &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cat : cats)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cat.getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; cat.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;dog : dogs)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; dog.getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; dog.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，考虑一下如果你有30种不同的动物会发生什么。你需要30个数组，每种动物一个!</p><p>然而，因为猫和狗都来自于动物，我们应该能够做这样的事情是有道理的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cat fred&#123; <span class="string">"Fred"</span> &#125;;</span><br><span class="line">    Cat misty&#123; <span class="string">"Misty"</span> &#125;;</span><br><span class="line">    Cat zeke&#123; <span class="string">"Zeke"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    Dog garbo&#123; <span class="string">"Garbo"</span> &#125;;</span><br><span class="line">    Dog pooky&#123; <span class="string">"Pooky"</span> &#125;;</span><br><span class="line">    Dog truffle&#123; <span class="string">"Truffle"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 设置一个指向animals的 指针数组，并将这些指针设置为指向我们的Cat和Dog对象</span></span><br><span class="line">    Animal *animals[]&#123; &amp;fred, &amp;garbo, &amp;misty, &amp;pooky, &amp;truffle, &amp;zeke &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> animal : animals)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; animal-&gt;getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; animal-&gt;speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然他们可编译，可执行时，不幸的是，数组“animals”的每个元素都是指向动物的指针，这意味着animals[iii]-&gt;speak()将调用Animal::speak()，而不是我们想要的speak()的派生类版本。</p><p><strong>虽然这两种技术都可以节省我们大量的时间和精力，但它们都有相同的问题。指向基类的指针或引用调用函数的基版本，而不是派生版本。如果有什么方法可以让这些基指针调用函数的派生版本而不是基版本就好了……</strong> -————虚函数</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/多重继承</title>
      <link href="/archives/38f967fd.html"/>
      <url>/archives/38f967fd.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/117-multiple-inheritance/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/117-multiple-inheritance/</a></p><hr><h1 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h1><p>到目前为止，我们介绍的所有继承示例都是<strong>单继承——也就是说，每个继承的类都有且只有一个父类</strong>。</p><p>然而，<strong>c++提供了进行多重继承的能力。多重继承使派生类能够从多个父类继承成员</strong>。</p><p>假设，假设我们想要编写一个程序来跟踪一群老师。老师是一个人，同时也是一个雇员(如果为自己工作，他们就是自己的雇主)。</p><blockquote><p>多重继承可用于创建教师类，该类继承Person和Employee的属性。</p></blockquote><p><strong>要使用多重继承，只需指定每个基类(就像在单继承中一样)，中间用逗号分隔。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="http://www.learncpp.com/images/CppTutorial/Section11/PersonTeacher.gif" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="built_in">std</span>::<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">        : m_name(name), m_age(age)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_age; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_employer;</span><br><span class="line">    <span class="keyword">double</span> m_wage;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Employee(<span class="built_in">std</span>::<span class="built_in">string</span> employer, <span class="keyword">double</span> wage)</span><br><span class="line">        : m_employer(employer), m_wage(wage)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">getEmployer</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_employer; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getWage</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_wage; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Teacher publicly inherits Person and Employee</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>:</span> <span class="keyword">public</span> Person, <span class="keyword">public</span> Employee  <span class="comment">//⭐记得用 逗号 隔开</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">     <span class="keyword">int</span> m_teachesGrade;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Teacher(<span class="built_in">std</span>::<span class="built_in">string</span> name, <span class="keyword">int</span> age, <span class="built_in">std</span>::<span class="built_in">string</span> employer, <span class="keyword">double</span> wage, <span class="keyword">int</span> teachesGrade)</span><br><span class="line">        : Person(name, age), Employee(employer, wage), m_teachesGrade(teachesGrade)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="多重继承的问题"><a href="#多重继承的问题" class="headerlink" title="多重继承的问题"></a>多重继承的问题</h1><p>虽然多重继承看起来像是单继承的简单扩展，但是多重继承引入了很多问题，这些问题会显著增加程序的复杂性，使它们成为维护的梦魇。让我们来看看这些情况。</p><ul><li>首先，<strong>当多个基类包含具有相同名称的函数时，可能会导致歧义</strong>。例如:</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">USBDevice</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">long</span> m_id;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    USBDevice(<span class="keyword">long</span> id)</span><br><span class="line">        : m_id(id)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getID</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_id; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkDevice</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">long</span> m_id;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NetworkDevice(<span class="keyword">long</span> id)</span><br><span class="line">        : m_id(id)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getID</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_id; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WirelessAdapter</span>:</span> <span class="keyword">public</span> USBDevice, <span class="keyword">public</span> NetworkDevice</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    WirelessAdapter(<span class="keyword">long</span> usbId, <span class="keyword">long</span> networkId)</span><br><span class="line">        : USBDevice(usbId), NetworkDevice(networkId)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">WirelessAdapter <span class="title">c54G</span><span class="params">(<span class="number">5442</span>, <span class="number">181742</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c54G.getID(); <span class="comment">// Which getID() do we call?⭐</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译<code>c54G.getID()</code>时，编译器会查看WirelessAdapter是否包含一个名为<code>getID()</code>的函数。它没有。</p><p>然后编译器查看父类中是否有一个名为getID()的函数。看到问题了吗? <u>问题是，c54G实际上包含两个getID()函数:一个继承自USBDevice，另一个继承自NetworkDevice。</u></p><p>因此，这个函数调用是不明确的，如果尝试编译它，您将收到一个编译器错误。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>但是，有一种方法可以解决这个问题: <strong>您可以显式地指定要调用的版本</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">WirelessAdapter <span class="title">c54G</span><span class="params">(<span class="number">5442</span>, <span class="number">181742</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c54G.USBDevice::getID(); <span class="comment">//⭐</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这个解决方法非常简单，但是当您的类继承了从其他类本身继承的4或6个基类时，您可以看到事情会变得多么复杂。随着继承更多的类，命名冲突的可能性呈指数级增加，并且每一个命名冲突都需要显式地解决。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/改变继承的成员的访问级别 及 隐藏继承自父类的成员</title>
      <link href="/archives/c4d17f90.html"/>
      <url>/archives/c4d17f90.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/11-6b-hiding-inherited-functionality/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/11-6b-hiding-inherited-functionality/</a></p><hr><h1 id="更改-继承成员的访问级别"><a href="#更改-继承成员的访问级别" class="headerlink" title="更改 继承成员的访问级别"></a>更改 继承成员的访问级别</h1><p><strong>C++使我们能够在派生类中更改继承成员的访问说明符。这是通过使用<code>using</code>来声明 (限定作用域的)基类成员 在派生类的新访问说明符下 更改其访问权限。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(<span class="keyword">int</span> value)</span><br><span class="line">        : m_value(value)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printValue</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_value; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>因为<code>Base::printValue()</code>已经被声明为 protected，所以它只能被Base或它的派生类调用。</p></blockquote><p>让我们定义一个派生类，<strong>它将printValue() 在该派生类中的访问说明符更改为public</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">int</span> value)</span><br><span class="line">        : Base(value)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Base::printValue 之前被继承为受保护的，所以公众没有权限访问</span></span><br><span class="line">    <span class="comment">// 但我们通过 using声明 将其改为pubic</span></span><br><span class="line">    <span class="keyword">using</span> Base::printValue; <span class="comment">// note: 没有小括号⭐</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这意味着这个代码将工作:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">derived</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// printValue is public in Derived, so this is okay</span></span><br><span class="line">    derived.printValue(); <span class="comment">// prints 7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li><p>首先，您<strong>只能</strong>更改派生类通常能够访问的基本成员的访问说明符。因此，<strong>永远不能将基成员的访问说明符从private更改为protected或public，因为派生类不能访问基类的私有成员。</strong></p></li><li><p>其次，从c++ 11开始，using声明 是改变访问级别的首选方法。但是，您也可以通过使用“访问声明”来更改访问级别。这与using声明方法的工作方式相同，<u>但是省略了“using”关键字。</u></p><blockquote><p>这种重新定义访问的<u>访问声明</u>方式现在被认为是不赞成的，但是您可能会看到使用这种模式的旧代码，因此值得了解。</p></blockquote></li></ul><h1 id="将功能隐藏起来"><a href="#将功能隐藏起来" class="headerlink" title="将功能隐藏起来"></a>将功能隐藏起来</h1><p><strong>在c++中，除了修改源代码外，不可能从基类中删除或限制功</strong>能。</p><p>但是，在派生类中，可以隐藏基类中存在的函数，这样就不能通过派生类访问它。<strong>这可以通过更改相关的 访问说明符来完成。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_value;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">using</span> Base::m_value;  <span class="comment">//⭐将Base类中的 (public)成员变量m_value 的访问属性修改为private</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Derived(<span class="keyword">int</span> value)</span><br><span class="line"><span class="comment">// 我们不能初始化m_value，因为它是一个基类的 成员(基类 必须初始化它)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 但我们可以给它赋值</span></span><br><span class="line">m_value = value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Derived <span class="title">derived</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 因为m_value已经被重新定义为private，所以下面的代码不能用</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; derived.m_value; <span class="comment">//✖</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这允许我们获取设计糟糕的基类，并将其数据封装在我们的派生类中。或者，与其公开继承Base的成员并通过覆盖它的访问说明符使m_value私有，我们可以私有的继承Base，这将首先导致所有的Base成员被私有继承。</p><hr><p><strong>你也可以在派生类中 将成员函数标记为delete，这确保了它们不能通过派生对象被调用</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">26</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">28</span></span><br><span class="line"><span class="number">29</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="number">31</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">33</span></span><br><span class="line"><span class="number">34</span></span><br><span class="line"><span class="number">35</span></span><br><span class="line"><span class="number">36</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_value;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Base(<span class="keyword">int</span> value)</span><br><span class="line">: m_value(value)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Derived(<span class="keyword">int</span> value)</span><br><span class="line">: Base(value)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>= <span class="keyword">delete</span>; <span class="comment">//⭐ mark this function as inaccessible</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Derived <span class="title">derived</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// The following won't work because getValue() has been deleted!</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; derived.getValue();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们将getValue()函数标记为deleted。这意味着当我们试图调用函数的派生版本时，编译器会发出警告。</p><p><u>注意，getValue()的基本版本仍然是可访问的</u>。这意味着派生对象仍然可以访问getValue()，<strong>方法是先将派生对象向上转换为基对象</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Derived <span class="title">derived</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 我们仍然可以通过基类访问 在派生类中删除的函数</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;Base&gt;(derived).getValue(); <span class="comment">//⭐</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/调用 继承函数和覆盖行为</title>
      <link href="/archives/cedb49a3.html"/>
      <url>/archives/cedb49a3.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/11-6a-calling-inherited-functions-and-overriding-behavior/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/11-6a-calling-inherited-functions-and-overriding-behavior/</a></p><hr><p>默认情况下，派生类继承基类中定义的所有行为。在本节课中，我们将更详细地研究如何选择成员函数，以及如何利用它来更改派生类中的行为。</p><h1 id="调用基类函数"><a href="#调用基类函数" class="headerlink" title="调用基类函数"></a>调用基类函数</h1><p>当使用派生类对象调用成员函数时，<strong>编译器首先查看该成员是否存在于派生类中。如果没有，它就开始遍历继承链并检查成员是否在任何父类中定义。它使用找到的第一个。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(<span class="keyword">int</span> value)</span><br><span class="line">        : m_value(value)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">identify</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a Base\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">int</span> value)</span><br><span class="line">        : Base(value)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">base</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    base.identify();</span><br><span class="line"> </span><br><span class="line">    <span class="function">Derived <span class="title">derived</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line">    derived.identify();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">I am a Base</span><br><span class="line">I am a Base</span><br></pre></td></tr></table></figure><p>当derived.identify()被调用时，编译器会查看Derived类中是否定义了identify()函数。它没有。然后它开始查找继承的类(在本例中是Base)。Base定义了一个identify()函数，所以它使用这个函数。换句话说，使用Base::identify()是因为派生的Derived::identify()不存在。</p><h1 id="重定义行为-重新定义父类中的函数"><a href="#重定义行为-重新定义父类中的函数" class="headerlink" title="重定义行为(重新定义父类中的函数)"></a>重定义行为(重新定义父类中的函数)</h1><p>但是，如果我们在派生类中定义了Derived::identify()，那么就会使用它。</p><p>这意味着我们可以通过在派生类中重新定义这个函数，来让函数以不同的方式工作!</p><p><strong>要修改基类中定义的函数在派生类中的工作方式，只需重新定义派生类中的函数。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">int</span> value)</span><br><span class="line">        : Base(value)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Here's our modified function</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">identify</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a Derived\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是与上面相同的例子，使用新的Derived::Identify()函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">base</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    base.identify();</span><br><span class="line"> </span><br><span class="line">    <span class="function">Derived <span class="title">derived</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line">    derived.identify();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I am a Base</span><br><span class="line">I am a Derived</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>注意，<strong>在派生类中重新定义函数时，派生函数不会继承基类中同名函数的访问说明符</strong>。它使用在派生类中定义的访问说明符。<strong>因此，在基类中定义为private的函数可以在派生类中重新定义为public，反之亦然!</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived "</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Derived derived;</span><br><span class="line">derived.<span class="built_in">print</span>(); <span class="comment">// calls derived::print(), which is public</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="添加功能到现有的父类函数中"><a href="#添加功能到现有的父类函数中" class="headerlink" title="添加功能到现有的父类函数中"></a>添加功能到现有的父类函数中</h1><p><strong>有时我们并不想完全替换基类函数，而是希望向它添加额外的功能</strong>。在上面的例子中，注意派生的::identify()完全隐藏了Base::identify()! 这可能不是我们想要的<u>。可以让我们的派生函数调用同名函数的基本版本(以便重用代码)，然后向它添加额外的功能。</u></p><blockquote><p><strong>要让派生函数调用同名的基函数，只需执行一个普通的函数调用，但在函数前面加上作用域限定符(基类的名称和两个冒号)。</strong>下面的示例重新定义了Derived::identify()，因此它首先调用Base::identify()，然后执行它自己的附加操作。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">int</span> value)</span><br><span class="line">        : Base(value)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">identify</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Base::identify(); <span class="comment">// call Base::identify() first</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a Derived\n"</span>; <span class="comment">// then identify ourselves</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="为什么需要使用范围解析操作符"><a href="#为什么需要使用范围解析操作符" class="headerlink" title="为什么需要使用范围解析操作符(::)?"></a>为什么需要使用范围解析操作符(::)?</h2><p>如果我们像这样定义了Derived::identify():</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">int</span> value)</span><br><span class="line">        : Base(value)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">identify</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        identify(); <span class="comment">// Note: no scope resolution!</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a Derived"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>没有范围解析限定符的调用函数identify()将默认为当前类中的identify()，它实际上看起来是这种形式： Derived::identify()。</strong>这将导致Derived::identify()调用自身，这将导致无限循环!</p><h1 id="在派生类调用基类的友元函数"><a href="#在派生类调用基类的友元函数" class="headerlink" title="在派生类调用基类的友元函数"></a>在派生类调用基类的友元函数</h1><p>当我们试图在派生类调用基类的友元函数时，比如操作符&lt;&lt;，可能会遇到一点小麻烦。因为基类的friend函数实际上不是基类的一部分，<u>所以使用范围解析限定符不起作用</u>。相反，我们需要一种方法使我们的派生类暂时看起来像基类，这样就可以调用函数的正确版本。</p><blockquote><p><strong>幸运的是，使用static_cast很容易做到这一点</strong>。</p></blockquote><p>这里有一个例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_value;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Base(<span class="keyword">int</span> value)</span><br><span class="line">: m_value(value)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (<span class="built_in">std</span>::ostream &amp;out, <span class="keyword">const</span> Base &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">out &lt;&lt; <span class="string">"In Base\n"</span>;</span><br><span class="line">out &lt;&lt; b.m_value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Derived(<span class="keyword">int</span> value)</span><br><span class="line">: Base(value)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (<span class="built_in">std</span>::ostream &amp;out, <span class="keyword">const</span> Derived &amp;d)</span><br><span class="line">&#123;</span><br><span class="line">out &lt;&lt; <span class="string">"In Derived\n"</span>;</span><br><span class="line"><span class="comment">// static_cast派生到一个基对象, so we call the right version of operator&lt;&lt;</span></span><br><span class="line">out &lt;&lt; <span class="keyword">static_cast</span>&lt;Base&gt;(d);  <span class="comment">//⭐</span></span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Derived <span class="title">derived</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; derived;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">In derived <span class="comment">//先运行 “out &lt;&lt; "In Derived\n";”</span></span><br><span class="line">In base <span class="comment">//然后调用 基类Base中的友元函数</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><p>因为Derived类 派生自 Base类，<strong>所以我们可以将派生对象转换为基，这样就可以调用使用基的操作符&lt;&lt;的适当版本。</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/继承中的访问标识符</title>
      <link href="/archives/664c52ef.html"/>
      <url>/archives/664c52ef.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/115-inheritance-and-access-specifiers/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/115-inheritance-and-access-specifiers/</a></p><hr><h1 id="private、public、protected"><a href="#private、public、protected" class="headerlink" title="private、public、protected"></a><code>private</code>、<code>public</code>、<code>protected</code></h1><ul><li><p><strong><code>private</code></strong>：私有成员只能由同一类或 friends 的成员函数访问。这意味着派生类不能直接访问基类的私有成员!</p><blockquote><p><strong>当类中的成员没有显式的给定 访问说明符，C++则默认其为：<code>private</code></strong></p></blockquote></li><li><p><strong><code>public</code></strong>：任何人都可以访问公共成员</p></li></ul><h2 id="protected受保护的访问说明符"><a href="#protected受保护的访问说明符" class="headerlink" title="protected受保护的访问说明符"></a><code>protected</code>受保护的访问说明符</h2><p>在处理继承类时，事情会变得有点复杂。</p><p>c++有一个我们还没有讨论的第三个访问说明符：<strong><code>protected</code>，因为它只在继承上下文中有用</strong>。</p><p><strong>受保护的访问说明符允许成员所属的类、朋友类和派生类访问成员</strong>。<strong>但是，受保护成员不能从类外部访问。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_public; <span class="comment">// can be accessed by anybody</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_protected; <span class="comment">// can be accessed by Base members, friends, and derived classes</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_private; <span class="comment">// can only be accessed by Base members and friends (but not derived classes)</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived()</span><br><span class="line">    &#123;</span><br><span class="line">        m_public = <span class="number">1</span>; <span class="comment">// allowed: can access public base members from derived class</span></span><br><span class="line">        m_protected = <span class="number">2</span>; <span class="comment">// allowed: can access protected base members from derived class</span></span><br><span class="line">        m_private = <span class="number">3</span>; <span class="comment">// not allowed: can not access private base members from derived class</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base base;</span><br><span class="line">    base.m_public = <span class="number">1</span>; <span class="comment">// allowed: can access public members from outside class</span></span><br><span class="line">    base.m_protected = <span class="number">2</span>; <span class="comment">//⭐ not allowed: can not access protected members from outside class</span></span><br><span class="line">    base.m_private = <span class="number">3</span>; <span class="comment">// not allowed: can not access private members from outside class</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，您可以看到受保护的基本成员<code>m_protected</code>可由派生类Derived直接访问，而不是由公共访问。</p><h3 id="何时使用受保护的访问说明符"><a href="#何时使用受保护的访问说明符" class="headerlink" title="何时使用受保护的访问说明符?"></a>何时使用受保护的访问说明符?</h3><p>基类中的<code>protected</code>属性的成员，派生类可以直接访问该成员。<strong>这意味着，如果您以后更改了关于protected属性的任何内容(类型、值的含义等等)，您可能需要同时更改基类和所有派生类。</strong></p><p>因此，当您(或您的团队)是从您自己的类派生出来的，并且派生类的数量是合理的时，使用受保护的访问说明符是最有用的。<strong>这样，如果您对基类的实现进行了更改，并且因此需要对派生类进行更新，那么您可以自己进行更新(并且更新不会永远进行，因为派生类的数量是有限的)。</strong></p><hr><p><strong>将成员设为私有可以提供更好的封装，并将派生类与对基类的更改隔离开来</strong>。但是，构建一个公共或受保护的接口来支持公共 和/或 派生类所需的所有访问方法或功能也是有成本的。这是额外的工作，可能不值得，除非您期望其他人是从您的类派生出来的，或者您有大量的派生类，更新它们的成本将非常昂贵。</p><h1 id="不同种类的继承及其对访问的影响"><a href="#不同种类的继承及其对访问的影响" class="headerlink" title="不同种类的继承及其对访问的影响"></a>不同种类的继承及其对访问的影响</h1><p>首先，类从其他类继承有三种不同的方法:public、protected和private。</p><p>要做到这一点，只需指定在选择要继承的类时想要的访问类型:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inherit from Base publicly</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pub</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Inherit from Base protectedly</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pro</span>:</span> <span class="keyword">protected</span> Base</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Inherit from Base privately</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pri</span>:</span> <span class="keyword">private</span> Base</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Def</span>:</span> Base <span class="comment">// Defaults to private inheritance</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>如果不选择继承类型，c++默认为私有继承(就像如果不指定其他类型，成员默认为私有访问)</strong></p><p>这给了我们9种组合:3种成员访问说明符(公共、私有和受保护)，以及3种继承类型(公共、私有和受保护)。</p><p>它们之间有什么区别呢? 简而言之，当成员被继承时，继承成员的访问说明符可能会根据使用的继承类型而改变(仅在派生类中)。换句话说，<strong>基类中为公有或受保护的成员可能会更改派生类中的访问说明符。</strong></p><p>当我们逐步分析这些例子时，请记住以下规则:</p><ul><li>一个类总是可以访问它自己的(非继承的)成员。</li><li>公共访问类的成员基于它正在访问的类的访问说明符。</li><li>类根据从父类继承的访问说明符访问继承的成员。这取决于所使用的访问说明符和继承类型。</li></ul><h2 id="公有继承"><a href="#公有继承" class="headerlink" title="公有继承"></a>公有继承</h2><p><strong>公有继承</strong>是目前最常用的继承类型。事实上，您很少会看到或使用其他类型的继承，所以您的主要关注点应该是理解这一部分。幸运的是，公共继承也是最容易理解的。<strong>当您公开继承基类时，</strong></p><ul><li><strong>继承的公共成员保持为public</strong>；</li><li><strong>继承的受保护成员保持为protected。</strong>；</li><li><strong>继承的私有成员保持不可访问，因为它们在基类中是私有的。</strong></li></ul><table><thead><tr><th align="left">Access specifier in base class</th><th align="left">Access specifier when inherited publicly</th></tr></thead><tbody><tr><td align="left">Public</td><td align="left">Public</td></tr><tr><td align="left">Protected</td><td align="left">Protected</td></tr><tr><td align="left">Private</td><td align="left">Inaccessible</td></tr></tbody></table><h2 id="保护继承"><a href="#保护继承" class="headerlink" title="保护继承"></a>保护继承</h2><p><strong>受保护继承</strong>是最不常见的继承方法。它几乎从未被使用过，除非在非常特殊的情况下。有了受保护的继承，</p><ul><li><strong>公共成员</strong>和<strong>受保护的成员</strong>就得到了保护；</li><li>而<strong>私有成员</strong>则无法访问。</li></ul><p>因为这种形式的继承非常罕见，我们就跳过这个例子，用一个表格总结一下:</p><table><thead><tr><th align="left">Access specifier in base class</th><th align="left">Access specifier when inherited protectedly</th></tr></thead><tbody><tr><td align="left">Public</td><td align="left">Protected</td></tr><tr><td align="left">Protected</td><td align="left">Protected</td></tr><tr><td align="left">Private</td><td align="left">Inaccessible</td></tr></tbody></table><h2 id="私有继承"><a href="#私有继承" class="headerlink" title="私有继承"></a>私有继承</h2><p>使用<strong>私有继承</strong>，<strong>基类的所有成员都继承为私有</strong>。</p><ul><li>这意味着私有成员保持私有；</li><li>受保护 和 公共成员变 为私有。</li></ul><p>注意，<u>这并不影响派生类访问从父类继承的成员的方式</u>。它只影响试图通过派生类访问这些成员的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_public;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_protected;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_private;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pri</span>:</span> <span class="keyword">private</span> Base <span class="comment">// note: private inheritance</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Private inheritance means:</span></span><br><span class="line">    <span class="comment">// Public inherited members become private (so m_public is treated as private)</span></span><br><span class="line">    <span class="comment">// Protected inherited members become private (so m_protected is treated as private)</span></span><br><span class="line">    <span class="comment">// Private inherited members stay inaccessible (so m_private is inaccessible)</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Pri()</span><br><span class="line">    &#123;</span><br><span class="line">        m_public = <span class="number">1</span>; <span class="comment">// okay: m_public is now private in Pri</span></span><br><span class="line">        m_protected = <span class="number">2</span>; <span class="comment">// okay: m_protected is now private in Pri</span></span><br><span class="line">        m_private = <span class="number">3</span>; <span class="comment">// not okay: derived classes can't access private members in the base class</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Outside access uses the access specifiers of the class being accessed.</span></span><br><span class="line">    <span class="comment">// In this case, the access specifiers of base.</span></span><br><span class="line">    Base base;</span><br><span class="line">    base.m_public = <span class="number">1</span>; <span class="comment">// okay: m_public is public in Base</span></span><br><span class="line">    base.m_protected = <span class="number">2</span>; <span class="comment">// not okay: m_protected is protected in Base</span></span><br><span class="line">    base.m_private = <span class="number">3</span>; <span class="comment">// not okay: m_private is private in Base</span></span><br><span class="line"> </span><br><span class="line">    Pri pri;</span><br><span class="line">    pri.m_public = <span class="number">1</span>; <span class="comment">// not okay: m_public is now private in Pri</span></span><br><span class="line">    pri.m_protected = <span class="number">2</span>; <span class="comment">// not okay: m_protected is now private in Pri</span></span><br><span class="line">    pri.m_private = <span class="number">3</span>; <span class="comment">// not okay: m_private is inaccessible in Pri</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以表格形式总结:</p><table><thead><tr><th align="left">Access specifier in base class</th><th align="left">Access specifier when inherited privately</th></tr></thead><tbody><tr><td align="left">Public</td><td align="left">Private</td></tr><tr><td align="left">Protected</td><td align="left">Private</td></tr><tr><td align="left">Private</td><td align="left">Inaccessible</td></tr></tbody></table><p>当派生类与基类没有明显关系，但在内部使用基类实现时，私有继承可能非常有用。在这种情况下，我们可能不希望基类的公共接口通过派生类的对象公开(如果我们公开继承)。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>访问说明符、继承类型 和 派生类 相互作用的方式会引起很多混淆。尽可能多地尝试和澄清事情:</p><ul><li>首先，<strong>类(和friend )总是可以访问它自己的非继承成员</strong>。<strong>访问说明符只影响外部人员和派生类是否可以访问这些成员。</strong></li><li>其次，当派生类继承成员时，这些成员可能会更改派生类中的访问说明符。<strong>但这并不影响派生类自己的(非继承的)成员(它们有自己的访问说明符)</strong>。<strong>它只影响外部人员和派生自派生类的类是否可以访问这些继承的成员。</strong></li><li>最后要注意的是，尽管在上面的例子中，我们只展示了使用成员变量的例子，<strong>但是这些访问规则对所有成员都适用(例如，在类中声明的成员函数和类型)。</strong></li></ul><p>下面是所有访问说明符和继承类型组合的表:</p><table><thead><tr><th align="left">Access specifier in base class</th><th align="left">Access specifier when inherited publicly</th><th align="left">Access specifier when inherited privately</th><th align="left">Access specifier when inherited protectedly</th></tr></thead><tbody><tr><td align="left">Public</td><td align="left">Public</td><td align="left">Private</td><td align="left">Protected</td></tr><tr><td align="left">Protected</td><td align="left">Protected</td><td align="left">Private</td><td align="left">Protected</td></tr><tr><td align="left">Private</td><td align="left">Inaccessible</td><td align="left">Inaccessible</td><td align="left">Inaccessible</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/派生类的构造函数及初始化</title>
      <link href="/archives/f3aa0b39.html"/>
      <url>/archives/f3aa0b39.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/114-constructors-and-initialization-of-derived-classes/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/114-constructors-and-initialization-of-derived-classes/</a></p><hr><p>我们将深入了解构造函数在派生类初始化中的作用。为此，我们将继续使用我们在前一课中开发的简单的基类和派生类:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_id;</span><br><span class="line"> </span><br><span class="line">    Base(<span class="keyword">int</span> id=<span class="number">0</span>)</span><br><span class="line">        : m_id&#123; id &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_id; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> m_cost;</span><br><span class="line"> </span><br><span class="line">    Derived(<span class="keyword">double</span> cost=<span class="number">0.0</span>)</span><br><span class="line">        : m_cost&#123; cost &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getCost</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_cost; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>对于<strong>非派生类</strong>，构造函数只需要担心自己的成员。例如，考虑Base。我们可以像这样创建一个基对象:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base base&#123; <span class="number">5</span> &#125;; <span class="comment">// use Base(int) constructor</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是实例化base时实际发生的情况:</p><ol><li>为base 留出内存</li><li>调用适当的base的 构造函数</li><li>初始化列表 初始化变量</li><li>构造函数的主体执行</li><li>控件返回给调用方</li></ol></li><li><p>对于<strong>派生类</strong>，事情稍微复杂一些:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived&#123; <span class="number">1.3</span> &#125;; <span class="comment">// use Derived(double) constructor</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是实例化派生类时实际发生的情况:</p><ol><li>为derived 留出内存 (足够用于基部分和派生部分)</li><li>调用适当的Derived的 构造函数</li><li><strong>首先使用适当的 基构造函数 构造 基对象。如果没有指定基构造函数，则使用默认构造函数。</strong></li><li>初始化列表 初始化变量</li><li>构造函数的主体执行</li><li>控件返回给调用方</li></ol></li></ul><p>这种情况 与 非继承情况 之间的唯一真正区别是，<strong>在派生构造函数可以执行任何实质性操作之前，首先调用<u>基</u>构造函数</strong>。<strong>基构造函数设置对象的基部分，将控件返回给派生构造函数，并允许派生构造函数完成其工作。</strong></p><h1 id="初始化基类成员"><a href="#初始化基类成员" class="headerlink" title="初始化基类成员"></a>初始化基类成员</h1><p>我们的<strong>派生类</strong>当前的一个<u>缺点</u>是：当我们创建一个派生对象时，<strong>没有方法初始化m_id</strong>。如果我们想在创建派生对象时<strong>同时设置m_cost</strong> (来自对象的派生部分)<strong>和 m_id</strong> (来自对象的基本部分)，<u>该怎么办?</u></p><h2 id="错误的初始化"><a href="#错误的初始化" class="headerlink" title="错误的初始化"></a>错误的初始化</h2><blockquote><p>新程序员经常尝试解决这个问题如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> m_cost;</span><br><span class="line"> </span><br><span class="line">    Derived(<span class="keyword">double</span> cost=<span class="number">0.0</span>, <span class="keyword">int</span> id=<span class="number">0</span>)</span><br><span class="line">        <span class="comment">// does not work</span></span><br><span class="line">        : m_cost&#123; cost &#125;, m_id&#123; id &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getCost</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_cost; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是一个很好的尝试，而且几乎是正确的想法。我们<strong>确实需要向构造函数中添加另一个参数，否则c++将无法知道我们想要初始化m_id为什么值。</strong></p><p>但是，<strong>c++<u>不允许</u>类在构造函数的初始化列表中<u>初始化继承的成员变量</u></strong>。<strong>换句话说，变量的值只能在该变量所在的那个类的 构造函数的初始化列表中设置。</strong></p><blockquote><p>为啥会有这个限制？</p><p><strong>答案与const和引用变量有关</strong>。考虑一下如果m_id是常量会发生什么。因为const变量必须在创建时用一个值初始化，所以基类构造函数必须在创建变量时设置它的值。但是，当基类构造函数完成时，派生类构造函数的初始化列表就会执行。然后，每个派生类都有机会初始化该变量，可能会更改其值!通过将变量的初始化限制在这些变量所属的类的构造函数中，c++确保所有变量只初始化一次。</p></blockquote><p>最终的结果是上面的例子不起作用<strong>，因为m_id是从Base继承的，并且只有非继承的变量可以在初始化列表中初始化。</strong></p></blockquote><blockquote><p>但是，继承的变量仍然可以在构造函数体中<strong>使用赋值</strong>来更改它们的值。因此，新程序员也经常这样做:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> m_cost;</span><br><span class="line"> </span><br><span class="line">    Derived(<span class="keyword">double</span> cost=<span class="number">0.0</span>, <span class="keyword">int</span> id=<span class="number">0</span>)</span><br><span class="line">        : m_cost&#123; cost &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        m_id = id; <span class="comment">//⭐</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getCost</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_cost; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然这在这种情况是可行的，但是如果m_id是一个const或一个引用，它就不能工作(因为const值和引用必须在构造函数的初始化列表中初始化)。</p><p>它的效率也很低，因为m_id被赋值两次: 一次在基类构造函数的初始化列表中，一次在派生类构造函数的主体中。</p><p>最后，如果基类在构造过程中需要访问这个值，该怎么办?它没有办法访问它，因为它在派生构造函数执行之前是不设置的(基本上是最后执行)。</p></blockquote><h2 id="正确初始化"><a href="#正确初始化" class="headerlink" title="正确初始化"></a>正确初始化</h2><p>那么，当创建派生类对象时，我们如何正确初始化m_id呢?</p><blockquote><p>在到目前为止的所有示例中，当我们实例化一个派生类对象时，基类部分已经使用默认的基构造函数创建。为什么它总是使用默认的基构造函数? 因为我们从来没有让它使用其他的构造函数。</p></blockquote><p>幸运的是，<strong>C++允许我们显式地选择将调用哪个基类构造函数! 要做到这一点，<u>只需在派生类的初始化列表中添加对基类构造函数的调用</u>:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> m_cost;</span><br><span class="line"> </span><br><span class="line">    Derived(<span class="keyword">double</span> cost=<span class="number">0.0</span>, <span class="keyword">int</span> id=<span class="number">0</span>)</span><br><span class="line">        : Base&#123; id &#125;, <span class="comment">// ⭐Call Base(int) constructor with value id!</span></span><br><span class="line">            m_cost&#123; cost &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getCost</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_cost; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>现在，当我们执行这个代码时:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived&#123; <span class="number">1.3</span>, <span class="number">5</span> &#125;; <span class="comment">// use Derived(double, int) constructor</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Id: "</span> &lt;&lt; derived.getId() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Cost: "</span> &lt;&lt; derived.getCost() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Id: <span class="number">5</span></span><br><span class="line">Cost: <span class="number">1.3</span></span><br></pre></td></tr></table></figure><p>基类构造函数base (int) 将用于初始化m_id为 5，派生类构造函数将用于初始化m_cost为1.3 !</p><hr><p>更详细的细节：</p><ol><li>分配用于派生（derived ）的内存。</li><li>调用<code>Derived(double, int)</code>构造函数，其中cost = 1.3, id = 5</li><li>编译器会查看我们是否需要一个特定的基类构造函数。我们有! 因此它调用id = 5的Base(int)。</li><li>基类构造函数 初始化列表 将m_id设置为5</li><li>基类构造函数body执行，它什么也不做</li><li>基类构造函数返回</li><li>派生类构造函数初始化列表将m_cost设置为1.3</li><li>派生类构造函数body执行，它什么也不做</li><li>派生类构造函数返回</li></ol></blockquote><p>这看起来有点复杂，但实际上非常简单。所发生的一切就是<strong>派生构造函数调用特定的基构造函数来初始化对象的基部分</strong>。因为m_id位于对象的基部分中，所以基构造函数是惟一可以初始化该值的构造函数。</p><hr><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>注意，<strong>在派生构造函数初始化列表中调用 基构造函数 的位置并不重要——因为 基构造函数 总是先执行。</strong></p><h1 id="现在可以让我们的成员私有-private"><a href="#现在可以让我们的成员私有-private" class="headerlink" title="现在可以让我们的成员私有(private)"></a>现在可以让我们的成员私有(<code>private</code>)</h1><p>既然知道了如何初始化基类成员，<u>就不需要保持成员变量为公共</u>。<strong>我们再次将成员变量设为私有，这是应该的。</strong></p><blockquote><p>简单回顾一下，<strong>任何人都可以访问公共成员</strong>。</p><p><strong>私有成员只能由同一类的成员函数访问</strong>。注意，<strong>这意味着派生类不能直接访问基类的私有成员</strong> ! <strong>派生类将需要使用访问函数来访问基类的私有成员</strong>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// our member is now private</span></span><br><span class="line">    <span class="keyword">int</span> m_id;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(<span class="keyword">int</span> id=<span class="number">0</span>)</span><br><span class="line">        : m_id&#123; id &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_id; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// our member is now private</span></span><br><span class="line">    <span class="keyword">double</span> m_cost;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">double</span> cost=<span class="number">0.0</span>, <span class="keyword">int</span> id=<span class="number">0</span>)</span><br><span class="line">        : Base&#123; id &#125;, <span class="comment">// Call Base(int) constructor with value id!</span></span><br><span class="line">            m_cost&#123; cost &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getCost</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_cost; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived&#123; <span class="number">1.3</span>, <span class="number">5</span> &#125;; <span class="comment">// use Derived(double, int) constructor</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Id: "</span> &lt;&lt; derived.getId() &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//⭐通过访问函数访问私有成员</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Cost: "</span> &lt;&lt; derived.getCost() &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//⭐通过访问函数访问私有成员</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="派生类被销毁时调用析构函数的顺序"><a href="#派生类被销毁时调用析构函数的顺序" class="headerlink" title="派生类被销毁时调用析构函数的顺序"></a>派生类被销毁时调用析构函数的顺序</h1><p>当一个派生类被销毁时，<strong><u>每个析构函数都以相反的构造顺序被调用</u>。</strong></p><p>也就是说，我们派生类在被创建时，<strong>构造函数</strong>的调用顺序是：</p><ul><li>先调用 最基类的构造函数—-&gt; 子类的构造函数 —-&gt;子类的子类的构造函数—-&gt;….—–&gt;最后调用 最子类的构造函数。</li></ul><p>在销毁派生类时，<strong>析构函数</strong>调用的顺序：</p><ul><li>首先调用 最子类的析构函数—-&gt;….———&gt;最后调用 最基类的析构函数</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/派生类的构造顺序</title>
      <link href="/archives/64f81817.html"/>
      <url>/archives/64f81817.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/113-order-of-construction-of-derived-classes/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/113-order-of-construction-of-derived-classes/</a></p><hr><p>首先，让我们引入一些新类来帮助我们阐明一些重要的观点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_id;</span><br><span class="line"> </span><br><span class="line">    Base(<span class="keyword">int</span> id=<span class="number">0</span>)</span><br><span class="line">        : m_id(id)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_id; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> m_cost;</span><br><span class="line"> </span><br><span class="line">    Derived(<span class="keyword">double</span> cost=<span class="number">0.0</span>)</span><br><span class="line">        : m_cost(cost)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getCost</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_cost; &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在本例中，Derived类 是从 Base类 派生的。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="http://www.learncpp.com/images/CppTutorial/Section11/DerivedBase.gif" alt="img"></p><p>因为Derived 继承了Base的函数和变量，所以可以假设 Base的成员被<strong>复制</strong>到派生的。<strong>然而，事实并非如此</strong>。<strong>相反，我们可以将派生类考虑为两个部分的类:一个部分Derived，一个部分Base。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="http://www.learncpp.com/images/CppTutorial/Section11/DerivedBaseCombined.gif" alt="img"></p><p>当我们实例化一个普通(非派生)类时会发生什么:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base base;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Base是一个非派生类，因为它不从任何其他类继承。</span></span><br><span class="line"><span class="comment">//c++为Base分配内存，然后调用Base的默认构造函数来进行初始化。</span></span><br></pre></td></tr></table></figure><p>现在让我们看看当我们实例化一个派生类时会发生什么:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当我们实例化一个Derived实例时，首先构造了Derived的 基部分(使用基默认构造函数)。一旦基本部分完成，派生部分 就被构造(使用派生的默认构造函数)。在这一点上，没有更多的派生类，所以我们完成了。</span></span><br></pre></td></tr></table></figure><h1 id="派生类的构造顺序"><a href="#派生类的构造顺序" class="headerlink" title="派生类的构造顺序"></a>派生类的构造顺序</h1><p>如上所述，<u>派生实际上包括两部分</u>: <strong>基础部分 和 派生部分</strong>。当c++构造派生对象时，它是分阶段进行的。</p><ul><li>首先，首先构造<strong>最基本的类</strong>(在继承树的顶部)。</li><li>然后按顺序构造每个<strong>子类</strong>，直到最后构造 <strong>最子类</strong>(在继承树的底部)。</li></ul><p>用一个程序来说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_id;</span><br><span class="line"> </span><br><span class="line">    Base(<span class="keyword">int</span> id=<span class="number">0</span>)</span><br><span class="line">        : m_id(id)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_id; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> m_cost;</span><br><span class="line"> </span><br><span class="line">    Derived(<span class="keyword">double</span> cost=<span class="number">0.0</span>)</span><br><span class="line">        : m_cost(cost)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getCost</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_cost; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Instantiating Base\n"</span>;</span><br><span class="line">    Base cBase;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Instantiating Derived\n"</span>;</span><br><span class="line">    Derived cDerived;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Instantiating Base</span><br><span class="line">Base</span><br><span class="line">Instantiating Derived</span><br><span class="line">Base</span><br><span class="line">Derived</span><br><span class="line"><span class="comment">//可以看到，当我们构造派生函数时，首先构造派生函数的基部分。</span></span><br><span class="line"><span class="comment">//这是有道理的:从逻辑上讲，没有父元素，子元素就不能存在。</span></span><br><span class="line"><span class="comment">//这也是一种安全的方法:子类经常使用来自父类的变量和函数，但是父类对子类一无所知。</span></span><br><span class="line"><span class="comment">//实例化父类首先确保在创建派生类并准备使用它们时已经初始化了这些变量。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/c++中的基本继承</title>
      <link href="/archives/6a59a953.html"/>
      <url>/archives/6a59a953.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/112-basic-inheritance-in-c/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/112-basic-inheritance-in-c/</a></p><hr><p>C++中的继承发生在类之间。在继承(is-a)关系中，<u>被继承的类</u>称为<strong>父类</strong>、<strong>基类</strong>或<strong>超类</strong>，<u>继承的类</u>称为<strong>子类</strong>、<strong>派生类</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://raw.githubusercontent.com/longlongqin/CDN-for-HEXO_BLOG/pig_bed/20200512235550.gif" alt="img"></p><p>在上面的图中，Fruit是父类，Apple和Banana都是子类。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://raw.githubusercontent.com/longlongqin/CDN-for-HEXO_BLOG/pig_bed/20200512235555.gif" alt="img"></p><p>在这个图中，Triangle既是一个子类(to Shape)，又是一父类 (to Right Triangle)。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/继承</title>
      <link href="/archives/1adb63dd.html"/>
      <url>/archives/1adb63dd.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/111-introduction-to-inheritance/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/111-introduction-to-inheritance/</a></p><hr><p>与通过组合和连接其他对象来创建新对象的对象组合不同，<strong>继承涉及通过直接获取其他对象的属性和行为来创建新对象，然后扩展或专门化它们。</strong></p><blockquote><p>就像C++继承了C语言的许多特性，C语言是c++的基础，而C语言又继承了它之前的编程语言的许多特性。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/使用stdinitializer_list初始化类</title>
      <link href="/archives/cf35c829.html"/>
      <url>/archives/cf35c829.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/10-7-stdinitializer_list/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/10-7-stdinitializer_list/</a></p><hr><p>当编译器看到初始化器列表时，<strong>它会自动将其转换成<code>std::initializer_list</code>类型的对象</strong>。因此，如果我们创建一个接受std::initializer_list参数的构造函数，我们可以使用初始化器列表作为输入来创建对象。</p><p><strong><code>std::initializer_list</code>在头文件<code>&lt;initializer_list&gt;</code></strong></p><h1 id="关于std-initializer-list，有一些事情需要了解"><a href="#关于std-initializer-list，有一些事情需要了解" class="headerlink" title="关于std::initializer_list，有一些事情需要了解"></a>关于<code>std::initializer_list</code>，有一些事情需要了解</h1><ul><li><p>与<code>std::array</code>或<code>std::vector</code>非常类似，<strong>您必须告诉<code>std::initializer_list</code>列表中的数据类型（在尖括号中表示 类型）</strong>。</p><blockquote><p>如：<code>std::initializer_list&lt;int&gt;</code>或<code>std::initializer_list&lt;std::string&gt;</code></p></blockquote></li><li><p><code>std::initializer_list</code>有一个(命名错误<strong>)size()函数</strong>，<strong>它返回列表中的元素<u>数量</u></strong>。当我们需要知道传入的列表的长度时，这是很有用的。</p></li></ul><h1 id="使用std-initializer-list创建一个-构造函数"><a href="#使用std-initializer-list创建一个-构造函数" class="headerlink" title="使用std::initializer_list创建一个 构造函数"></a>使用<code>std::initializer_list</code>创建一个 构造函数</h1><p>让我们看看如何使用一个构造函数来更新IntArray类，这个构造函数采用<strong><code>std::initializer_list</code></strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt; // for assert()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt; // for std::initializer_list</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_length&#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> *m_data&#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">IntArray() = <span class="keyword">default</span>;</span><br><span class="line"> </span><br><span class="line">IntArray(<span class="keyword">int</span> length) :</span><br><span class="line">m_length&#123; length &#125;,</span><br><span class="line">m_data&#123; <span class="keyword">new</span> <span class="keyword">int</span>[length]&#123;&#125; &#125;</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">IntArray(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>) : <span class="comment">//⭐ 允许通过 列表初始化 来初始化IntArray</span></span><br><span class="line">IntArray(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">list</span>.<span class="built_in">size</span>())) <span class="comment">// 使用委托构造函数设置初始数组</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 现在从列表中初始化我们的数组</span></span><br><span class="line"><span class="keyword">int</span> count&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> element : <span class="built_in">list</span>)</span><br><span class="line">&#123;</span><br><span class="line">m_data[count] = element;</span><br><span class="line">++count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">~IntArray()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] m_data;</span><br><span class="line"><span class="comment">// 我们不需要在这里设置m_data为null或m_length为0，因为对象将在这个函数之后立即销毁</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">IntArray(<span class="keyword">const</span> IntArray&amp;) = <span class="keyword">delete</span>; <span class="comment">// 避免浅拷贝</span></span><br><span class="line">IntArray&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> IntArray&amp; <span class="built_in">list</span>) = <span class="keyword">delete</span>; <span class="comment">// 避免浅拷贝</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">assert(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; m_length);</span><br><span class="line"><span class="keyword">return</span> m_data[index];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_length; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">IntArray <span class="built_in">array</span>&#123; <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span> &#125;; <span class="comment">//⭐ initializer list</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> count&#123; <span class="number">0</span> &#125;; count &lt; <span class="built_in">array</span>.getLength(); ++count)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[count] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>现在，让我们更详细地探讨这个问题的工作原理：</p><p>这是我们的IntArray构造函数，它接受<code>std::initializer_list&lt;int&gt;</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IntArray(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>): <span class="comment">// allow IntArray to be initialized via list initialization</span></span><br><span class="line">IntArray(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">list</span>.<span class="built_in">size</span>())) <span class="comment">// use delegating constructor to set up initial array</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Now initialize our array from the list</span></span><br><span class="line"><span class="keyword">int</span> count&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> element : <span class="built_in">list</span>)</span><br><span class="line">&#123;</span><br><span class="line">m_data[count] = element;</span><br><span class="line">++count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>第一行：如上所述，<strong>我们<u>必须</u>使用尖括号来表示我们在列表中期望的元素类型</strong>。在这种情况下，因为这是一个IntArray，我们希望列表用int来填充，注意我们没有通过const引用来传递列表。很像<code>std::string_view</code>，<code>std::initializer_list</code>是非常轻量级的，而且<strong>拷贝往往比间接拷贝更便宜。</strong></p></li><li><p>第二行：<strong>我们通过委托构造函数将IntArray的内存分配委托给另一个构造函数</strong>(以减少冗余代码)。另一个构造函数需要知道数组的长度，因此我们传递给它list.size()，它包含列表中的元素数量。<u>注意，list.size()返回一个size_t(它是无符号的)，所以我们需要在这里转换为一个有符号的int</u>。</p><blockquote><p>我们使用直接初始化，而不是大括号初始化，因为大括号初始化更喜欢列表构造函数。虽然构造函数会得到正确的解析，但是如果我们不想使用list构造函数，使用直接初始化来初始化类会更安全。</p></blockquote></li><li><p>构造函数的主体：用于将列表中的元素<strong>复制</strong>到我们的IntArray类中。</p><blockquote><p>由于一些无法解释的原因，<strong><code>std::initializer_list</code>不提供通过下标(operator[])访问列表元素的功能。标准委员会已多次注意到这一遗漏，但从未处理过。</strong></p><p>但是，有一些简单的方法可以解决缺少下标的问题。<strong>最简单的方法是在这里使用for-each循环</strong>。for-each循环遍历初始化列表中的每个元素，我们可以手动将这些元素复制到内部数组中。</p></blockquote></li></ul><p>注意：</p><p><strong>初始化器列表总是优先选择匹配的initializer_list构造函数</strong>。所以，下面的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntArray <span class="built_in">array</span> &#123; <span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure><p>将匹配<code>IntArray(std::initializer_list)</code>，而不是<code>IntArray(int)</code>。如果想在定义initializer_list构造函数之后匹配IntArray(int)，则需要使用 复制初始化 或 直接初始化。</p><h1 id="使用std-initializer-list赋值类"><a href="#使用std-initializer-list赋值类" class="headerlink" title="使用std::initializer_list赋值类"></a>使用<code>std::initializer_list</code>赋值类</h1><p>您还可以使用<code>std::initializer_list</code>来为类分配新值，<strong>方法是重载赋值操作符以获取std::initializer_list参数</strong>。这与上面的工作原理类似。我们将在下面的测试解决方案中展示一个如何做到这一点的例子。</p><blockquote><p>注意，<strong>如果您实现一个构造函数，该构造函数采用std::initializer_list</strong>，那么您应该确保至少执行以下操作之一:</p><ul><li>提供重载的列表赋值操作符</li><li>提供适当的 深拷贝 复制赋值操作符</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小测试：使用上面的IntArray类，实现一个重载赋值运算符，它接受初始化器列表。</span></span><br><span class="line"><span class="comment">//的解决方案</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt; // for assert()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt; // for std::initializer_list</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_length &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> *m_data &#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">IntArray() = <span class="keyword">default</span>;</span><br><span class="line"> </span><br><span class="line">IntArray(<span class="keyword">int</span> length) :</span><br><span class="line">m_length&#123; length &#125;,</span><br><span class="line">m_data&#123; <span class="keyword">new</span> <span class="keyword">int</span>[length]&#123;&#125; &#125;</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">IntArray(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>) : <span class="comment">// allow IntArray to be initialized via list initialization</span></span><br><span class="line">IntArray(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">list</span>.<span class="built_in">size</span>())) <span class="comment">// use delegating constructor to set up initial array</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Now initialize our array from the list</span></span><br><span class="line"><span class="keyword">int</span> count&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> element : <span class="built_in">list</span>)</span><br><span class="line">&#123;</span><br><span class="line">m_data[count] = element;</span><br><span class="line">++count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">~IntArray()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] m_data;</span><br><span class="line"><span class="comment">// we don't need to set m_data to null or m_length to 0 here, since the object will be destroyed immediately after this function anyway</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">IntArray(<span class="keyword">const</span> IntArray&amp;) = <span class="keyword">delete</span>; <span class="comment">// to avoid shallow copies</span></span><br><span class="line">IntArray&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> IntArray&amp; <span class="built_in">list</span>) = <span class="keyword">delete</span>; <span class="comment">// to avoid shallow copies</span></span><br><span class="line"> </span><br><span class="line">IntArray&amp; <span class="keyword">operator</span>=(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>) <span class="comment">//⭐</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// If the new list is a different size, reallocate it</span></span><br><span class="line"><span class="keyword">int</span> length&#123; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">list</span>.<span class="built_in">size</span>()) &#125;;</span><br><span class="line"><span class="keyword">if</span> (length != m_length)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] m_data;</span><br><span class="line">m_length = length;</span><br><span class="line">m_data = <span class="keyword">new</span> <span class="keyword">int</span>[length]&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Now initialize our array from the list</span></span><br><span class="line"><span class="keyword">int</span> count&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> element : <span class="built_in">list</span>)</span><br><span class="line">&#123;</span><br><span class="line">m_data[count] = element;</span><br><span class="line">++count;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">assert(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; m_length);</span><br><span class="line"><span class="keyword">return</span> m_data[index];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_length; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">IntArray <span class="built_in">array</span> &#123; <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span> &#125;; <span class="comment">// initializer list</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> count&#123; <span class="number">0</span> &#125;; count &lt; <span class="built_in">array</span>.getLength(); ++count)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[count] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">array</span> = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span> &#125;; <span class="comment">//⭐</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> count&#123; <span class="number">0</span> &#125;; count &lt; <span class="built_in">array</span>.getLength(); ++count)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[count] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/容器类</title>
      <link href="/archives/2ef705db.html"/>
      <url>/archives/2ef705db.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/106-container-classes/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/106-container-classes/</a></p><hr><p>在现实生活中，我们总是使用容器。你的早餐麦片装在一个盒子里，书里的书页装在封面和封皮里，你可以把任何数量的东西装在车库里的容器里。如果没有容器，使用这些对象就会非常不方便。</p><p>类似地，<strong>容器类(container class)</strong>是设计来容纳和组织另一种类型 (另一种类或基本类型) 的多个实例的类。有许多不同种类的容器类，每种容器类在其使用中都有各种优点、缺点和限制。</p><p>到目前为止，<strong>在编程中最常用的容器是数组</strong>，您已经看到了许多这样的例子。<strong>虽然c++有内置的数组功能，但程序员通常会使用数组容器类(std::array或std::vector)，因为它们提供了额外的好处。</strong></p><blockquote><p>与内置数组不同，<strong>数组容器类</strong>通常提供动态调整大小(添加或删除元素时)，在传递给函数时记住它们的大小，并执行边界检查。这不仅使数组容器类比普通数组更方便，而且更安全。</p></blockquote><h1 id="良好的容器将包括以下功能"><a href="#良好的容器将包括以下功能" class="headerlink" title="良好的容器将包括以下功能"></a>良好的容器将包括以下功能</h1><p><strong>容器类</strong>通常实现一个相当标准化的最小功能集。大多数定义良好的容器将包括以下功能:</p><ul><li>创建一个空容器(通过构造函数)</li><li>在容器中插入一个新对象</li><li>从容器中删除对象</li><li>报告容器中当前对象的数量</li><li>清空容器中所有的对象</li><li>提供对存储对象的访问</li><li>对元素排序(可选)</li></ul><p>有时候，某些容器类会忽略某些功能。例如，数组容器类经常省略插入和删除函数，因为它们很慢，而且类设计器不希望鼓励使用它们。</p><p>容器类实现成员关系。例如，数组的元素是数组的成员(属于)。注意，<u>我们使用的是传统意义上的“member-of”，而不是c++类成员的意义。</u></p><h1 id="容器的类型"><a href="#容器的类型" class="headerlink" title="容器的类型"></a>容器的类型</h1><p>容器类通常有两种不同的种类：</p><ul><li><strong>Value containers</strong>：存储它们所持有的对象的副本的 <a href="http://www.learncpp.com/cpp-tutorial/102-composition/" target="_blank" rel="noopener">compositions</a>（这样就可以负责创建和销毁这些副本）。</li><li><strong>Reference containers</strong>：存储指向其他对象的指针或引用的<a href="http://www.learncpp.com/cpp-tutorial/103-aggregation/" target="_blank" rel="noopener">aggregations</a> （因此不负责这些对象的创建或销毁）</li></ul><p>不像在现实生活中，容器可以保存任何类型的对象。<strong>在c++中，容器通常只保存一种类型的数据</strong>。</p><p>例如，如果你有一个整数数组，它将只保存整数。与其他一些语言不同，许多c++容器不允许任意混合类型。如果需要容器来保存整数和双精度数，通常需要编写两个单独的容器(或者使用模板，这是c++的一个高级特性)。尽管容器的使用受到限制，但它们非常有用，并且使编程更容易、更安全</p><h1 id="数组容器类"><a href="#数组容器类" class="headerlink" title="数组容器类"></a>数组容器类</h1><p>在这个例子中，<strong>我们将从头开始编写一个整数数组类</strong>，它实现了容器应该具有的大多数常见功能。这个数组类将是一个<strong>值容器（value container）</strong>，它将保存它组织的元素的<strong>副本</strong>。顾名思义，该容器将保存一个整数数组，类似于std::vector。</p><p>创建过程详情请看：</p><p><a href="https://www.learncpp.com/cpp-tutorial/106-container-classes/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/106-container-classes/</a> 的“<strong>An array container class</strong>”</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/类的拷贝初始化</title>
      <link href="/archives/5b8eb091.html"/>
      <url>/archives/5b8eb091.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/9-12-copy-initialization/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/9-12-copy-initialization/</a></p><hr><h1 id="避免直接使用拷贝初始化"><a href="#避免直接使用拷贝初始化" class="headerlink" title="避免直接使用拷贝初始化"></a>避免直接使用拷贝初始化</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_numerator;</span><br><span class="line">    <span class="keyword">int</span> m_denominator;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Default constructor</span></span><br><span class="line">    Fraction(<span class="keyword">int</span> numerator=<span class="number">0</span>, <span class="keyword">int</span> denominator=<span class="number">1</span>) :</span><br><span class="line">        m_numerator(numerator), m_denominator(denominator)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(denominator != <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> Fraction &amp;f1);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> Fraction &amp;f1)</span><br><span class="line">&#123;</span><br><span class="line">out &lt;&lt; f1.m_numerator &lt;&lt; <span class="string">"/"</span> &lt;&lt; f1.m_denominator;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Fraction six = Fraction(<span class="number">6</span>); </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; six;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种形式的拷贝初始化的工作原理是和下面的形式的工作原理一样:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Fraction <span class="title">six</span><span class="params">(Fraction(<span class="number">6</span>))</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>在<a href="https://www.yuque.com/longlongqin/pw9qpx/qnrfq8" target="_blank" rel="noopener">“拷贝构造函数”</a>中，了解到这会同时调用 Fraction(int, int) 和 Fraction拷贝构造函数 (出于性能原因，可能会省略)。</p><p>但是，由于不能保证省略(在c++ 17之前，这种情况下省略是必须的)，<strong>所以最好避免拷贝类的初始化，而使用统一的初始化。</strong></p></blockquote><h1 id="其他地方使用拷贝初始化"><a href="#其他地方使用拷贝初始化" class="headerlink" title="其他地方使用拷贝初始化"></a>其他地方使用拷贝初始化</h1><p>还有一些其他地方使用了复制初始化，但其中两个值得明确地提到。当<strong>按值传递</strong>或<strong>返回类</strong>时，使用拷贝初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_numerator;</span><br><span class="line"><span class="keyword">int</span> m_denominator;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Default constructor</span></span><br><span class="line">    Fraction(<span class="keyword">int</span> numerator=<span class="number">0</span>, <span class="keyword">int</span> denominator=<span class="number">1</span>) :</span><br><span class="line">        m_numerator(numerator), m_denominator(denominator)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(denominator != <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Copy constructor</span></span><br><span class="line">Fraction(<span class="keyword">const</span> Fraction &amp;copy) :</span><br><span class="line">m_numerator(copy.m_numerator), m_denominator(copy.m_denominator)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// no need to check for a denominator of 0 here since copy must already be a valid Fraction</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Copy constructor called\n"</span>; <span class="comment">// just to prove it works</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> Fraction &amp;f1);</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getNumerator</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_numerator; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setNumerator</span><span class="params">(<span class="keyword">int</span> numerator)</span> </span>&#123; m_numerator = numerator; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> Fraction &amp;f1)</span><br><span class="line">&#123;</span><br><span class="line">out &lt;&lt; f1.m_numerator &lt;&lt; <span class="string">"/"</span> &lt;&lt; f1.m_denominator;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Fraction <span class="title">makeNegative</span><span class="params">(Fraction f)</span> <span class="comment">// ideally we should do this by const reference</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f.setNumerator(-f.getNumerator());</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Fraction <span class="title">fiveThirds</span><span class="params">(<span class="number">5</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; makeNegative(fiveThirds);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*运行结果*/</span></span><br><span class="line">Copy constructor called</span><br><span class="line">Copy constructor called</span><br><span class="line"><span class="number">-5</span>/<span class="number">3</span></span><br></pre></td></tr></table></figure><p>第一个复制构造函数调用 <strong>发生在 fiveThirds作为参数传递给makeNegative()参数f的时候。</strong></p><p>第二个调用<strong>发生在makeNegative()的返回值被传递回main()的时候。</strong></p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/重载“下标”操作符</title>
      <link href="/archives/1f338417.html"/>
      <url>/archives/1f338417.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/98-overloading-the-subscript-operator/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/98-overloading-the-subscript-operator/</a></p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_list[<span class="number">10</span>]&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IntList <span class="built_in">list</span>&#123;&#125;;</span><br><span class="line">    <span class="comment">// how do we access elements from m_list?</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>因为m_list成员变量是私有的，我们不能直接从变量列表中访问它</strong>。这意味着我们无法直接获取或设置m_list数组中的值。那么我们如何获取或将元素放入我们的列表中呢?</p><p>答：</p><p>重载<code>[]</code>操作符</p><h1 id="重载-操作符必须使用成员函数"><a href="#重载-操作符必须使用成员函数" class="headerlink" title="重载[]操作符必须使用成员函数"></a>重载<code>[]</code>操作符必须使用成员函数</h1><p>在这种情况下，更好的解决方案是重载下标操作符([])，以允许访问m_list的元素。<strong>下标操作符的重载必须使用成员函数版</strong>。</p><p>重载运算符<code>[]</code>函数总是接受<strong>一个</strong>参数: 用户在硬括号之间放置的下标。</p><blockquote><p>在IntList的例子中，我们希望用户传入一个整数索引，并返回一个整数值作为结果。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_list[<span class="number">10</span>]&#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>&amp; IntList::<span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_list[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，每当我们在类的对象上使用下标操作符([])时，编译器将从m_list成员变量返回相应的元素!这允许我们直接获取和设置m_list的值:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IntList <span class="built_in">list</span>&#123;&#125;;</span><br><span class="line">    <span class="built_in">list</span>[<span class="number">2</span>] = <span class="number">3</span>; <span class="comment">// set a value</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">list</span>[<span class="number">2</span>] &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// get a value</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>从语法和理解的角度来看，这都很简单。 <strong>当list[2]计算时，编译器首先检查是否有重载的运算符[] 函数。如果有，它将方括号(本例中为2)中的值作为参数传递给函数。</strong></p><h1 id="为什么操作符-返回引用"><a href="#为什么操作符-返回引用" class="headerlink" title="为什么操作符[]返回引用"></a>为什么操作符<code>[]</code>返回引用</h1><p>让我们仔细看看<code>list[2] = 3</code>是如何计算的。</p><p>因为下标运算符具有比赋值运算符更高的优先级，所以<code>list[2]</code>首先计算。<code>list[2]</code>调用操作符<code>[]</code>，我们定义它来返回对<code>list.m_list[2]</code>的引用。因为操作符[]返回一个引用，所以它返回实际的<code>list.m_list[2]</code>数组元素。我们的部分求值表达式变成 <code>list.m_list[2] = 3</code>，这是一个简单的整数赋值。</p><p>在<a href="https://www.learncpp.com/cpp-tutorial/introduction-to-variables/" target="_blank" rel="noopener">1.3 – Introduction to variables</a>中，您了解到<strong>赋值语句左边的任何值都必须是l-value</strong>(它是一个具有实际内存地址的变量)。</p><blockquote><p>因为运算符<code>[]</code>的结果可以在赋值语句的左边使用 (例如list[2] = 3)，所以运算符<code>[]</code>的返回值必须是l-value。</p></blockquote><p><strong>事实证明，引用总是l-value，因为您只能引用具有内存地址的变量</strong>。所以通过返回一个引用，编译器就会确信我们返回的是一个l-value。</p><hr><h2 id="当操作符-按值-而不是按引用返回整数时"><a href="#当操作符-按值-而不是按引用返回整数时" class="headerlink" title="当操作符[]按值 而不是按引用返回整数时"></a>当操作符<code>[]</code>按值 而不是按引用返回整数时</h2><p>考虑一下如果operator[] <strong>按值</strong> 而不是 <strong>按引用返回整数</strong> 会发生什么？</p><p><code>list[2]</code>将调用操作符<code>[]</code>，它将<strong>返回<code>list.m_list[2]</code>的值</strong>。（例如，如果m_list[2]的值为6，操作符[]将返回值6。）<code>list[2] = 3</code>将会被执行为<code>6=3</code>这毫无意义! 如果你尝试这样做，c++编译器会抱怨:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:VCProjectsTest.cpp(386) : error C2106: &#39;&#x3D;&#39; : left operand must be l-value</span><br></pre></td></tr></table></figure><h1 id="处理const对象"><a href="#处理const对象" class="headerlink" title="处理const对象"></a>处理const对象</h1><p>在上面的IntList例子中，操作符[]是非const的，我们可以使用它作为一个l-value来改变非const对象的状态。但是，如果我们的IntList对象是const呢?</p><p>在这种情况下，<u>我们将不能调用运算符[]的非const版本，因为这将允许我们潜在地<strong>更改</strong>const<strong>对象的状态</strong>。</u></p><p>好消息是，我们可以分别定义运算符[]的非const版本和const版本。非const版本将与非const对象一起使用，而const版本与const对象一起使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_list[<span class="number">10</span>]&#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;; <span class="comment">// give this class some initial state for this example</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="keyword">operator</span>[] (<span class="keyword">int</span> index);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="keyword">operator</span>[] (<span class="keyword">int</span> index) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span>&amp; IntList::<span class="keyword">operator</span>[] (<span class="keyword">int</span> index) <span class="comment">// 对于非const对象: 可用于赋值</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_list[index];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; IntList::<span class="keyword">operator</span>[] (<span class="keyword">int</span> index) <span class="keyword">const</span> <span class="comment">// 对于const对象:只能用于访问</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_list[index];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IntList <span class="built_in">list</span>&#123;&#125;;</span><br><span class="line">    <span class="built_in">list</span>[<span class="number">2</span>] = <span class="number">3</span>; <span class="comment">// okay: calls non-const version of operator[]</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">list</span>[<span class="number">2</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">const</span> IntList clist&#123;&#125;;</span><br><span class="line">    clist[<span class="number">2</span>] = <span class="number">3</span>; <span class="comment">// compile error: calls const version of operator[], which returns a const reference.  不能用于赋值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; clist[<span class="number">2</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="指向对象的指针和重载操作符-不能混淆"><a href="#指向对象的指针和重载操作符-不能混淆" class="headerlink" title="指向对象的指针和重载操作符[]不能混淆"></a>指向对象的指针和重载操作符[]不能混淆</h1><p>如果试图在指向对象的指针上调用operator[]， c++会假定您正在尝试为该类型的对象数组建立索引。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt; // for assert()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_list[<span class="number">10</span>]&#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="keyword">operator</span>[] (<span class="keyword">int</span> index);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span>&amp; IntList::<span class="keyword">operator</span>[] (<span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    assert(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="number">10</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> m_list[index];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IntList *<span class="built_in">list</span>&#123; <span class="keyword">new</span> IntList&#123;&#125; &#125;;</span><br><span class="line">    <span class="built_in">list</span> [<span class="number">2</span>] = <span class="number">3</span>; <span class="comment">//错误:这将假设我们正在访问 IntLists数组中的索引为2的元素</span></span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">list</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们不能将整数赋给IntList，所以这将无法编译。然而，如果分配一个整数是有效的，这将编译并运行，结果是未定义的。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://raw.githubusercontent.com/longlongqin/CDN-for-HEXO_BLOG/pig_bed/20200510230939.png" alt=""></p><hr><p><strong>确保您没有试图在指向对象的指针上调用重载操作符[]。</strong></p><p>正确的语法应该是<strong>先取消对指针的引用</strong>(确保使用括号，因为运算符[]的优先级高于运算符<em>)，*</em>然后调用运算符[]**:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IntList *<span class="built_in">list</span>&#123; <span class="keyword">new</span> IntList&#123;&#125; &#125;;</span><br><span class="line">    (*<span class="built_in">list</span>)[<span class="number">2</span>] = <span class="number">3</span>; <span class="comment">// get our IntList object, then call overloaded operator[]</span></span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">list</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数参数可以不是整数"><a href="#函数参数可以不是整数" class="headerlink" title="函数参数可以不是整数"></a>函数参数可以不是整数</h1><p>如上所述，C++将用户在中括号之间键入的内容作为参数传递给重载函数。在大多数情况下，这将是一个整数值。然而，这并不是必需的——事实上，您可以定义重载运算符[]取一个任意类型的值。您可以定义重载的运算符[]来接受double、std::string或其他任何您喜欢的内容。</p><p>一个荒谬但是可以说明事实的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stupid</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span>[] (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; index);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//重载运算符[]来打印一些东西是没有意义的</span></span><br><span class="line"><span class="comment">//但是这是显示函数参数可以是非整数的最简单的方法</span></span><br><span class="line"><span class="keyword">void</span> Stupid::<span class="keyword">operator</span>[] (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; index)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; index;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Stupid stupid&#123;&#125;;</span><br><span class="line">stupid[<span class="string">"Hello, world!"</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure><p>重载操作符[]以获取std::string参数，在编写某些类型的类时非常有用，例如那些使用单词作为索引的类。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>通常重载下标运算符，以提供对类中包含的数组(或其他类似结构)中的单个元素的直接访问。因为字符串通常是作为字符数组实现的，所以操作符[]通常是在字符串类中实现的，以允许用户访问字符串的单个字符。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/操作符重载</title>
      <link href="/archives/a193c39a.html"/>
      <url>/archives/a193c39a.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/91-introduction-to-operator-overloading/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/91-introduction-to-operator-overloading/</a></p><hr><p>在 <a href="https://www.learncpp.com/cpp-tutorial/76-function-overloading/" target="_blank" rel="noopener">7.6 – Function overloading</a>中，您学习了函数重载，它提供了一种机制来创建和解析同名的多个函数的函数调用，只要每个函数有一个惟一的函数原型。</p><p>在c++中，操作符被实现原理与函数相似。通过在操作符函数上使用函数重载，可以定义自己的操作符版本，这些操作符可以处理不同的数据类型(包括您编写的类)。使用函数重载来重载操作符称为<strong>操作符重载</strong>。</p><h1 id="当计算包含运算符的表达式时，编译器使用以下规则"><a href="#当计算包含运算符的表达式时，编译器使用以下规则" class="headerlink" title="当计算包含运算符的表达式时，编译器使用以下规则"></a>当计算包含运算符的表达式时，编译器使用以下规则</h1><ul><li>如果所有操作数都是基本数据类型，编译器将调用一个内置例程(如果存在)。如果不存在，编译器将产生一个编译器错误。</li><li>如果所有操作数是用户数据类型(例如，您的一个类或枚举类型)，编译器将查看该类型是否具有可调用的匹配重载操作符函数。如果找不到，它将尝试将一个或多个用户定义的类型操作数转换为基本数据类型，以便使用匹配的内置操作符(通过重载的类型转换，我们将在本章后面介绍)。如果失败，则会产生编译错误。</li></ul><h1 id="操作符重载的限制是什么"><a href="#操作符重载的限制是什么" class="headerlink" title="操作符重载的限制是什么?"></a>操作符重载的限制是什么?</h1><ul><li><p>首先，C++中几乎所有现有的运算符都可能被重载。例外情况有:</p><p>条件(<code>? :</code>)、<code>sizeof</code>、scope(<code>::)</code>、成员选择器(<code>.</code>)、成员指针选择器(<code>.*</code>)、<code>typeid</code>和转<code>换操作符</code>。</p></li><li><p>其次，您只能重载现有的操作符。不能创建新操作符或重命名现有操作符。例如，您不能创建运算符**来做指数运算。</p></li><li><p>第三，<strong>重载操作符中的至少一个操作数必须是用户定义的类型</strong>。这意味着不能重载加法运算符来处理一个整数和一个双精度数。但是，您可以重载plus操作符来处理整数和Mystring。</p></li><li><p>第四，<strong>不可能更改操作符支持的操作数的数量</strong>。</p></li><li><p>最后，<strong>所有操作符都保持它们的默认优先级和结合性</strong>(无论它们用于什么用途)，并且这是不可更改的。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/匿名对象</title>
      <link href="/archives/b2f816aa.html"/>
      <url>/archives/b2f816aa.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/814-anonymous-objects/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/814-anonymous-objects/</a></p><hr><p>在某些情况下，我们只需要一个临时变量。例如，考虑以下情况:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = x + y;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数<code>add()</code>中，请注意sum变量实际上仅用作临时占位符变量。它的作用不大——相反，<strong>它的唯一功能是将表达式的结果转换为返回值。</strong></p><h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><p>实际上，有一种更简单的方法可以使<strong>用匿名对象</strong>来编写<code>add()</code>函数。</p><p><strong>匿名对象本质上是一个没有名称的值。因为它们没有名称，所以除了它们被创建的地方之外，没有其他方法来引用它们。</strong></p><p>因此，<strong>它们具有“表达式范围”，这意味着它们是在一个表达式中创建、计算和销毁的。</strong></p><p>下面是使用匿名对象重写的add()函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y; <span class="comment">// an anonymous object is created to hold and return the result of x + y</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当表达式<code>x + y</code>求值时，<strong>结果被放在一个匿名对象中</strong>。然后，通过值将匿名对象的<strong>副本</strong>返回给调用者，并销毁匿名对象。</p><p>我们也可以在函数中使用它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printValue</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printValue(<span class="number">5</span> + <span class="number">3</span>); <span class="comment">//匿名对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在本例中，计算表达式5 + 3以生成结果8，该结果放在匿名对象中。然后将这个匿名对象的<strong>副本</strong>传递给printValue()函数 (该函数打印值8)，然后销毁该对象。</p><h1 id="匿名类对象"><a href="#匿名类对象" class="headerlink" title="匿名类对象"></a>匿名类对象</h1><p>尽管我们前面的例子使用了内置的数据类型，但是也可以构造我们自己的类类型的匿名对象。这是通过创建像普通对象一样的对象来完成的，但是省略了变量名。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Cents <span class="title">cents</span><span class="params">(<span class="number">5</span>)</span></span>; <span class="comment">// normal variable</span></span><br><span class="line">Cents(<span class="number">7</span>); <span class="comment">// anonymous object</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，<code>Cents(7)</code>将创建一个匿名Cents对象，用值7初始化它，然后销毁它。</p><p>在这种情况下，这对我们没有什么好处。所以，让我们来看一个例子，它可以很好地使用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main()函数将传递一个Cents对象(名为cents)给函数print()。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cents</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_cents;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cents(<span class="keyword">int</span> cents) &#123; m_cents = cents; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCents</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_cents; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> Cents &amp;cents)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cents.getCents() &lt;&lt; <span class="string">" cents"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Cents <span class="title">cents</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="built_in">print</span>(cents);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们可以通过使用匿名对象来简化这个程序:</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cents</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_cents;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cents(<span class="keyword">int</span> cents) &#123; m_cents = cents; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCents</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_cents; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> Cents &amp;cents)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cents.getCents() &lt;&lt; <span class="string">" cents"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(Cents(<span class="number">6</span>)); <span class="comment">// ⭐Note: Now we're passing an anonymous Cents value</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 cents</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>在c++中，<strong>匿名对象</strong>主要用于传递或返回值，而不需要创建大量临时变量。动态分配的内存也是匿名执行的 (这就是为什么它的地址必须分配给一个指针，否则我们将无法引用它)。</p><p>同样值得注意的是，<strong>因为匿名对象具有表达式作用域，所以它们只能使用一次</strong>。如果需要在多个表达式中引用一个值，应该使用命名变量。</p><hr><p>注意: 一些编译器，例如Visual Studio，将允许您设置对匿名对象的非const引用。<strong>这是非标准行为。</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/友元函数与类</title>
      <link href="/archives/e16eef53.html"/>
      <url>/archives/e16eef53.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/813-friend-functions-and-classes/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/813-friend-functions-and-classes/</a></p><hr><h1 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h1><p><strong>友元函数</strong>是一个可以访问类的<strong>私有</strong>成员的函数，就像它是该类的成员一样。</p><blockquote><p>除此之外，友元函数就像一个普通函数。</p></blockquote><p>友元函数可以是一个：</p><ul><li><strong>普通函数</strong>，</li><li>也可以是<strong>另一个类的成员函数</strong>。</li></ul><p>声明一个友元函数：</p><ul><li><p>只需在函数原型前使用<code>friend</code>关键字即可成为该类的好友。</p><blockquote><p><strong>在类的<code>private</code>还是 <code>public</code> 声明friend函数并不重要。</strong></p></blockquote></li></ul><hr><p>一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Accumulator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Accumulator() &#123; m_value = <span class="number">0</span>; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; m_value += value; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使reset()函数成为该类的friend⭐ [声明]</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">(Accumulator &amp;accumulator)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//reset()现在是Accumulator类的一个friend ⭐ [定义]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(Accumulator &amp;accumulator)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//可以访问Accumulator对象的私有数据</span></span><br><span class="line">    accumulator.m_value = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Accumulator acc;</span><br><span class="line">    acc.add(<span class="number">5</span>);</span><br><span class="line">    reset(acc);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>reset()</code>不是Accumulator类的成员，所以<code>reset()</code>通常不能访问<code>Accumulator</code>的私有成员。<strong>但是，因为Accumulator明确地声明了这个reset()函数是类的朋友，所以reset()函数被赋予了对Accumulator私有成员的访问权。</strong></p><blockquote><p>注意：</p><p>我们必须传递一个Accumulator<strong>对象</strong>给reset()。<strong>这是因为reset()不是一个成员函数。</strong>它没有<code>*this</code>指针，也没有要使用的Accumulator对象，除非给定一个。</p></blockquote><h1 id="同一个函数可成为多个类的友元函数"><a href="#同一个函数可成为多个类的友元函数" class="headerlink" title="同一个函数可成为多个类的友元函数"></a>同一个函数可成为多个类的友元函数</h1><p>一个函数可以同时是多个类的朋友。例如，考虑下面的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Humidity</span>;</span>  <span class="comment">//这是一个类原型，它告诉编译器我们将在将来定义一个名为Humidity的类。</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temperature</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_temp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Temperature(<span class="keyword">int</span> temp=<span class="number">0</span>) &#123; m_temp = temp; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">printWeather</span><span class="params">(<span class="keyword">const</span> Temperature &amp;temperature, <span class="keyword">const</span> Humidity &amp;humidity)</span></span>; <span class="comment">//⭐</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Humidity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_humidity;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Humidity(<span class="keyword">int</span> humidity=<span class="number">0</span>) &#123; m_humidity = humidity; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">printWeather</span><span class="params">(<span class="keyword">const</span> Temperature &amp;temperature, <span class="keyword">const</span> Humidity &amp;humidity)</span></span>; <span class="comment">//⭐</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printWeather</span><span class="params">(<span class="keyword">const</span> Temperature &amp;temperature, <span class="keyword">const</span> Humidity &amp;humidity)</span> <span class="comment">//⭐</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The temperature is "</span> &lt;&lt; temperature.m_temp &lt;&lt;</span><br><span class="line">       <span class="string">" and the humidity is "</span> &lt;&lt; humidity.m_humidity &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Humidity <span class="title">hum</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Temperature <span class="title">temp</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    printWeather(temp, hum);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h1><p>也可以使整个类成为另一个类的friend。<strong>这使得friend类的所有成员都可以访问另一个类的私有成员</strong>。这里有一个例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_nValue;</span><br><span class="line">    <span class="keyword">double</span> m_dValue;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Storage(<span class="keyword">int</span> nValue, <span class="keyword">double</span> dValue)</span><br><span class="line">    &#123;</span><br><span class="line">        m_nValue = nValue;</span><br><span class="line">        m_dValue = dValue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 让 类Display 成为 类Storage 的friend ⭐</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Display</span>;</span> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Display</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> m_displayIntFirst;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Display(<span class="keyword">bool</span> displayIntFirst) &#123; m_displayIntFirst = displayIntFirst; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">displayItem</span><span class="params">(<span class="keyword">const</span> Storage &amp;storage)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_displayIntFirst)</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; storage.m_nValue &lt;&lt; <span class="string">" "</span> &lt;&lt; storage.m_dValue &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// display double first</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; storage.m_dValue &lt;&lt; <span class="string">" "</span> &lt;&lt; storage.m_nValue &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Storage <span class="title">storage</span><span class="params">(<span class="number">5</span>, <span class="number">6.7</span>)</span></span>;</span><br><span class="line">    <span class="function">Display <span class="title">display</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">display</span>.displayItem(storage);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li><p>上面例子中，虽然 Display类 是 Storage类 的friend，<strong>但是Display没有直接访问Storage对象的<code>*this</code>指针。</strong></p></li><li><p>虽然 Display类 是 Storage类 的friend，但这并不意味着 Storage类 也是是 Display类 的friend。（如果想让这两个类互为friend，你必须在各自类中声明出来。）</p></li><li><p>如果 类A 是 类B 的friend，而 类B是 类C 的friend，那并不意味着 类A是 类C 的friend。</p></li></ul><h1 id="友元成员函数"><a href="#友元成员函数" class="headerlink" title="友元成员函数"></a>友元成员函数</h1><p>您可以使单个成员函数成为friend，而不是使整个类成为friend。除了使用包含<code>className::</code>前缀的成员函数名(例如Display::displayItem)之外，这与将普通函数作为friend类似。</p><p>但是我们还需要注意：</p><ul><li><strong>为了使成员函数成为friend，编译器必须看到friend成员函数所在类的完整定义(而不仅仅是一个向前声明)。</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span>;</span> <span class="comment">// 提前声明 class Storage</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Display</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">bool</span> m_displayIntFirst;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Display(<span class="keyword">bool</span> displayIntFirst) &#123; m_displayIntFirst = displayIntFirst; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displayItem</span><span class="params">(<span class="keyword">const</span> Storage &amp;storage)</span></span>; <span class="comment">// 此声明行需要前面的 提前声明</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span> //类<span class="title">Storage</span> 的完整定义</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_nValue;</span><br><span class="line"><span class="keyword">double</span> m_dValue;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Storage(<span class="keyword">int</span> nValue, <span class="keyword">double</span> dValue)</span><br><span class="line">&#123;</span><br><span class="line">m_nValue = nValue;</span><br><span class="line">m_dValue = dValue;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//使Display::displayItem成员函数成为</span></span><br><span class="line"><span class="comment">//Storage类 的friend(需要查看类Display的完整声明，如下所示)</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Display::displayItem</span><span class="params">(<span class="keyword">const</span> Storage&amp; storage)</span></span>; <span class="comment">//声明</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//现在我们可以定义Display::displayItem，它需要查看 类Storage 的完整定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Display::displayItem</span><span class="params">(<span class="keyword">const</span> Storage &amp;storage)</span>  <span class="comment">//定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_displayIntFirst)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; storage.m_nValue &lt;&lt; <span class="string">" "</span> &lt;&lt; storage.m_dValue &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// display double first</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; storage.m_dValue &lt;&lt; <span class="string">" "</span> &lt;&lt; storage.m_nValue &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Storage <span class="title">storage</span><span class="params">(<span class="number">5</span>, <span class="number">6.7</span>)</span></span>;</span><br><span class="line">    <span class="function">Display <span class="title">display</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">display</span>.displayItem(storage);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在一切都编译正确:</p><ul><li>1、提前声明 类Storage 足以满足 Display类中 <code>Display::displayItem()</code>的声明；</li><li>2、Display类 的完整的定义 满足 <code>Display::displayItem()</code> 作为Storage 的friend；</li><li>3、类Storage 的完整定义 满足 成员函数<code>Display::displayItem()</code> 的定义。</li></ul><p>如果这有点令人困惑，请参阅上面程序中的注释。</p><blockquote><p>也就是说：</p><p>A类 的成员函数<code>fun</code> 要成为 B类 的友元函数：</p><p>则：</p><p>1、A类的定义 必须出现在 B类的定义之前 之前；</p><blockquote><p>将特定成员函数作为朋友需要<strong>首先看到成员函数所在的类的完整定义</strong></p></blockquote><p>2、我们需要将 友元函数<code>fun</code>的声明 与 定义 分开进行。</p></blockquote><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>友元函数 或 友元类 是一个函数 或 类，它们可以访问另一个类的私有成员，就像它是这个类的成员一样。</p><p>请注意，将特定成员函数作为朋友需要<strong>首先看到成员函数的类的完整定义。</strong></p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/静态成员变量</title>
      <link href="/archives/bab62969.html"/>
      <url>/archives/bab62969.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/812-static-member-functions/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/812-static-member-functions/</a></p><hr><h1 id="回顾关键字static"><a href="#回顾关键字static" class="headerlink" title="回顾关键字static"></a>回顾关键字<code>static</code></h1><p>在<a href="http://www.learncpp.com/cpp-tutorial/43-file-scope-and-the-static-keyword/" target="_blank" rel="noopener">file scope and the static keyword</a>中，您了解到<strong>静态变量保留它们的值，即使在它们超出作用域之后也不会被销毁</strong>。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">generateID</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_id&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> ++s_id;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; generateID() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; generateID() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; generateID() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>当应用于<strong>全局变量</strong>时，static关键字还有另一个含义——它为全局变量提供了<strong>内部链接</strong> (这限制了它们在定义它们的文件之外被看到/使用)。因为通常会避免全局变量，所以静态关键字在这种功能中不经常使用。</p><h1 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h1><p>c++在应用于类时引入了static关键字的另外两种用途:<strong>静态成员变量</strong>和<strong>静态成员函数</strong>。幸运的是，这些用途相当简单。本节课我们将讨论静态成员变量，下节课我们将讨论静态成员函数。</p><p>可以使用static关键字使类的成员变量变为静态。<strong>与普通成员变量不同，静态成员变量由类的所有对象共享</strong>。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_value; <span class="comment">//⭐</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> Something::s_value&#123; <span class="number">1</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Something first;</span><br><span class="line">    Something second;</span><br><span class="line"> </span><br><span class="line">    first.s_value = <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; first.s_value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; second.s_value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="静态成员不与类对象相关联"><a href="#静态成员不与类对象相关联" class="headerlink" title="静态成员不与类对象相关联"></a>静态成员不与类对象相关联</h2><p>尽管您可以通过类的对象访问静态成员 (如上面例子中first.s_value和second.s_value）。</p><p><u>但是，即使没有实例化类的对象，<strong>静态成员仍然存在! 就像全局变量一样，它们在程序启动时创建，在程序结束时销毁。</strong></u></p><p>因此，<strong>最好认为静态成员属于类本身，而不是类的对象</strong>。因为<code>s_value</code>独立于任何类对象而存在，所以可以使用类名和范围解析操作符(在本例中是<code>Something::s_value</code>)直接访问它:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> s_value; <span class="comment">//声明静态成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Something::s_value&#123; <span class="number">1</span> &#125;; <span class="comment">//定义静态成员变量 (在下面会讨论)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注意: 我们没有实例化任何类型的对象</span></span><br><span class="line"></span><br><span class="line">Something::s_value = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Something::s_value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码片段中，<strong><code>s_value</code>是通过类名引用的，而不是通过对象引用的。</strong>注意，我们甚至还没有实例化类型为Something的对象，但是我们仍然能够访问和使用Something::s_value。这是访问静态成员的首选方法。</p><h2 id="定义和初始化静态成员变量"><a href="#定义和初始化静态成员变量" class="headerlink" title="定义和初始化静态成员变量"></a>定义和初始化静态成员变量</h2><p>当我们在一个类中声明一个静态成员变量时，我们是在告诉编译器一个静态成员变量的存在，而不是实际定义它(很像一个向前声明)。</p><p>因为静态成员变量不是单个类对象的一部分(它们与全局变量的处理方式类似，并在程序启动时初始化)，<strong>所以必须在<u>全局范围</u>（类外部）内<u>显式</u>地定义静态成员。</strong></p><blockquote><p>在上面的例子中，我们是这样做的:</p><p><code>int Something::s_value{ 1 }; // defines the static member variable</code></p><p>这一行有两个目的:</p><ul><li>它<strong>实例化</strong>静态成员变量(就像一个全局变量)，</li><li>并选择性地初始化它。在本例中，我们提供初始值1。<strong>如果没有提供初始值设定项，c++会将值初始化为0。</strong></li></ul></blockquote><p>注意，<strong>这个静态成员定义不受访问控制的约束</strong>: <strong>即使在类中声明为private(或protected)，也可以定义和初始化值。</strong></p><hr><ul><li><p>如果类是在.h文件中定义的，那么静态成员定义通常放在类的相关代码文件中(例如Something.cpp)。</p></li><li><p>如果类是在.cpp文件中定义的，<u>静态成员定义通常直接放在类的下面</u>。<strong>不要将静态成员定义放在头文件中</strong>(很像全局变量，<strong>如果该头文件被包含多次，您将得到多个定义，这将导致编译错误</strong>)。</p></li></ul><h2 id="静态成员变量的内联初始化"><a href="#静态成员变量的内联初始化" class="headerlink" title="静态成员变量的内联初始化"></a>静态成员变量的内联初始化</h2><p>上面有一些捷径。下面情况，静态成员可以直接在 类定义<strong>中</strong> 被初始化：</p><ul><li><p>第一，当<u>静态</u>成员是<strong>const 整型</strong> (就包括<strong>char和bool</strong>) 或 <strong>const enum</strong>时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Whatever</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> s_value &#123;<span class="number">4</span>&#125;; <span class="comment">//静态const int可以直接声明和初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第二，<strong>静态的constexpr成员</strong> 可以在类定义中初始化:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Whatever</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> s_value &#123;<span class="number">2.2</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 3&gt; s_array&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h1><p>原文：<a href="https://www.learncpp.com/cpp-tutorial/812-static-member-functions/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/812-static-member-functions/</a></p><hr><p>在 <a href="https://www.learncpp.com/cpp-tutorial/811-static-member-variables/" target="_blank" rel="noopener">8.11 – Static member variables</a>中，您了解到静态成员变量是属于<strong>类的成员变量</strong>，<strong>而不是类的对象</strong>。</p><ul><li><p><strong>如果静态成员变量是<u>公共的</u>，我们可以使用类名和范围解析操作符直接访问它们。</strong></p></li><li><p>但是如果静态成员变量是私有的呢？考虑下面的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_value;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> Something::s_value&#123; <span class="number">1</span> &#125;; <span class="comment">//初始化器，这是可以的，即使s_value是私有的，因为它是一个定义</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// how do we access Something::s_value since it is private?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u>在这种情况下，我们不能直接从main()访问<code>Something::s_value</code>，因为它是私有的。</u></p><p>通常我们通过公共成员函数访问私有成员。虽然我们可以创建一个普通的公共成员函数来访问s_value，但是我们需要实例化一个类类型的对象来使用这个函数! 我们可以做得更好。我们也可以让函数保持静态。</p></li></ul><p><strong>与静态成员变量一样，静态成员函数不附加到任何特定对象</strong>。下面是上面静态成员函数访问器的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s_value; &#125; <span class="comment">// 静态成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> Something::s_value&#123; <span class="number">1</span> &#125;; <span class="comment">// initializer</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Something::getValue() &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//⭐</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为静态成员函数没有附加到特定的对象，所以可以使用<strong>类名</strong>和<strong>范围解析操作符(<code>::</code>)</strong>直接调用它们。与静态成员变量一样，也可以通过类 类型的对象调用它们，但不建议这样做。</p><h2 id="静态成员函数没有-this指针"><a href="#静态成员函数没有-this指针" class="headerlink" title="静态成员函数没有*this指针"></a>静态成员函数没有<code>*this</code>指针</h2><p>静态成员函数有两个有趣的特性值得注意。</p><ul><li><p>首先，因为静态成员函数没有附加到对象上，所以它们没有<code>this</code>指针! ——this指针总是指向成员函数正在处理的对象。静态成员函数不处理对象，因此不需要此指针。</p></li><li><p>其次，静态成员函数可以<strong>直接</strong>访问其他静态成员 (变量或函数)，但<strong>不能访问非静态成员</strong>。——这是因为非静态成员必须属于一个类对象，而静态成员函数没有可以使用的类对象!</p></li></ul><hr><h2 id="静态成员函数也可以在类声明之外定义"><a href="#静态成员函数也可以在类声明之外定义" class="headerlink" title="静态成员函数也可以在类声明之外定义"></a>静态成员函数也可以在类声明之外定义</h2><p>静态成员函数也可以在类声明之外定义。这与普通成员函数的工作方式相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDGenerator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_nextID; <span class="comment">// 这是一个静态成员的声明</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNextID</span><span class="params">()</span></span>; <span class="comment">// 这是一个静态函数的声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是类外部的 静态成员的定义。注意，**在这里不需要使用static关键字**。</span></span><br><span class="line"><span class="keyword">int</span> IDGenerator::s_nextID&#123; <span class="number">1</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IDGenerator::getNextID</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s_nextID++; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count&#123; <span class="number">0</span> &#125;; count &lt; <span class="number">5</span>; ++count)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The next ID is: "</span> &lt;&lt; IDGenerator::getNextID() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">The next ID is: <span class="number">1</span></span><br><span class="line">The next ID is: <span class="number">2</span></span><br><span class="line">The next ID is: <span class="number">3</span></span><br><span class="line">The next ID is: <span class="number">4</span></span><br><span class="line">The next ID is: <span class="number">5</span></span><br></pre></td></tr></table></figure><p>注意，因为这个类中的所有数据和函数都是静态的，所以我们不需要实例化这个类的对象来使用它的功能! 该类利用一个静态成员变量来保存下一个要分配的ID的值，并提供一个静态成员函数来返回该ID并对其进行递增。</p><h2 id="c-不支持静态构造函数"><a href="#c-不支持静态构造函数" class="headerlink" title="c++不支持静态构造函数"></a>c++不支持静态构造函数</h2><p>如果您可以通过构造函数初始化普通成员变量，那么通过扩展，您应该能够通过静态构造函数初始化静态成员变量，这是有意义的。尽管一些现代语言确实支持静态构造函数，<strong>但遗憾的是c++不是其中之一。</strong></p><p>如果可以直接初始化静态变量，则不需要构造函数: <u>我们可以直接在定义点初始化静态成员变量(即使它是私有的)</u>。我们在上面的IDGenerator示例中执行此操作。这是另一个例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; s_mychars;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; MyClass::s_mychars&#123; <span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>, <span class="string">'o'</span>, <span class="string">'u'</span> &#125;; <span class="comment">// 在定义点初始化静态变量</span></span><br></pre></td></tr></table></figure><hr><p>如果初始化 静态成员变量 需要执行代码(例如，循环)，那么有许多不同的、有些笨拙的方法可以做到这一点。<strong>一种处理所有变量的方法，不管是否是静态的，都是使用一个lambda并立即调用它。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; s_mychars;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; Myclass::s_mychars&#123;</span><br><span class="line">  []&#123; </span><br><span class="line">      <span class="comment">// 在lambda内部，我们可以声明另一个向量并使用循环。</span></span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; v&#123;&#125;;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">char</span> ch&#123; <span class="string">'a'</span> &#125;; ch &lt;= <span class="string">'z'</span>; ++ch)</span><br><span class="line">      &#123;</span><br><span class="line">          v.push_back(ch);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> v; </span><br><span class="line">  &#125;() <span class="comment">// 马上调用lambda</span></span><br></pre></td></tr></table></figure><hr><h1 id="使用静态成员要小心"><a href="#使用静态成员要小心" class="headerlink" title="使用静态成员要小心"></a>使用静态成员要小心</h1><p>使用<strong>所有成员都是静态</strong>的类时要小心。尽管这种“<strong>纯静态类</strong>”(也称为“单状态”)可能很有用，但它们也有一些潜在的缺点。</p><ul><li><p>首先，因为所有静态成员只实例化一次，所以不可能有一个纯静态类的多个副本 (在 不克隆类并重命名它的情况下)。例如，如果您需要两个独立的IDGenerator对象，这对于单个纯静态类来说是不可能的。</p></li><li><p>第二，在关于全局变量的课程中，您了解到全局变量是危险的，因为任何一段代码都可能改变全局变量的值，并最终破坏另一段看起来不相关的代码。对于纯静态类也是如此。因为所有成员都属于类(而不是类的对象)，<strong>而且类声明通常具有全局作用域</strong>，所以<strong>纯静态类本质上相当于 在全局可访问的命名空间中声明函数和全局变量，具有全局变量所具有的所有必需的缺点。</strong></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/常量类对象及成员函数</title>
      <link href="/archives/156886df.html"/>
      <url>/archives/156886df.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/810-const-class-objects-and-member-functions/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/810-const-class-objects-and-member-functions/</a></p><hr><p>在 <a href="https://www.learncpp.com/cpp-tutorial/const-constexpr-and-symbolic-constants/" target="_blank" rel="noopener">4.13 – Const, constexpr, and symbolic constants</a>中，您学习了基本数据类型(int, double, char，等等)可以通过const关键字变为静态，并且所有<strong>Const变量必须在创建时初始化。</strong></p><p>在const基本数据类型的情况下，可以通过复制、直接或统一初始化来进行初始化:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> value1 = <span class="number">5</span>; <span class="comment">// copy initialization</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">value2</span><span class="params">(<span class="number">7</span>)</span></span>; <span class="comment">// direct initialization</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> value3 &#123; <span class="number">9</span> &#125;; <span class="comment">// uniform initialization (C++11)</span></span><br></pre></td></tr></table></figure><h1 id="常量类"><a href="#常量类" class="headerlink" title="常量类"></a>常量类</h1><p>类似地，实例化的类对象也可以通过使用const关键字 来生成const<strong>。初始化是通过类构造函数完成的:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Date date1; <span class="comment">// initialize using default constructor</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> Date <span class="title">date2</span><span class="params">(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">16</span>)</span></span>; <span class="comment">// initialize using parameterized constructor</span></span><br><span class="line"><span class="keyword">const</span> Date date3 &#123; <span class="number">2020</span>, <span class="number">10</span>, <span class="number">16</span> &#125;; <span class="comment">// initialize using parameterized constructor (C++11)</span></span><br></pre></td></tr></table></figure><p>一旦通过构造函数初始化了const类对象，任何修改对象成员变量的尝试都是不允许的，因为这会违反对象的const属性。</p><blockquote><p>“修改”既包括直接<strong>更改成员变量</strong>(如果它们是公共的)，也包括<strong>调用设置成员变量值的成员函数。</strong></p></blockquote><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value;</span><br><span class="line"> </span><br><span class="line">    Something(): m_value(<span class="number">0</span>) &#123; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; m_value = value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_value ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Something something; <span class="comment">// calls default constructor</span></span><br><span class="line"> </span><br><span class="line">    something.m_value = <span class="number">5</span>; <span class="comment">//✖ compiler error: violates const</span></span><br><span class="line">    something.setValue(<span class="number">5</span>); <span class="comment">//✖ compiler error: violates const</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h1><h2 id="const类对象只能显式地调用const成员函数"><a href="#const类对象只能显式地调用const成员函数" class="headerlink" title="const类对象只能显式地调用const成员函数"></a>const类对象只能<u>显式</u>地调用const成员函数</h2><p>请看下面的语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; something.getValue();</span><br></pre></td></tr></table></figure><p>也许令人惊讶的是，<strong>这也会导致一个编译错误</strong>，即使<code>getValue()</code>不做任何改变成员变量的事情!</p><p>结果是，<strong>const类对象只能<u>显式</u>地调用const成员函数</strong>，而<code>getValue()</code>没有被标记为const成员函数。</p><hr><h2 id="书写格式"><a href="#书写格式" class="headerlink" title="书写格式"></a>书写格式</h2><p><strong>const成员函数</strong>是一个成员函数，它保证<strong>不会</strong>： <strong>修改对象</strong>或 <strong>调用任何非const成员函数</strong>(因为它们可能修改对象)。</p><h3 id="常量成员函数-在类定义之中-定义"><a href="#常量成员函数-在类定义之中-定义" class="headerlink" title="常量成员函数 在类定义之中 定义"></a>常量成员函数 在类定义之中 定义</h3><blockquote><p>要使getValue()成为const成员函数，我们<strong>只需将const关键字添加到函数原型中，在参数列表之后，但在函数体之前</strong>:</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value;</span><br><span class="line"> </span><br><span class="line">    Something(): m_value(<span class="number">0</span>) &#123; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resetValue</span><span class="params">()</span> </span>&#123; m_value = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; m_value = value; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> m_value;&#125; </span><br><span class="line">    <span class="comment">//⭐注意:const关键字添加在参数列表之后，但是在函数体之前</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="常量成员函数-在类定义之外-定义"><a href="#常量成员函数-在类定义之外-定义" class="headerlink" title="常量成员函数 在类定义之外 定义"></a>常量成员函数 在类定义之外 定义</h3><p>对于定义在类定义之外的成员函数，<strong>必须在 类定义中的函数原型 和 函数定义上 使用const关键字:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value;</span><br><span class="line"> </span><br><span class="line">    Something(): m_value(<span class="number">0</span>) &#123; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resetValue</span><span class="params">()</span> </span>&#123; m_value = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; m_value = value; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">//⭐ 注意这里添加了const关键字</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Something::getValue</span><span class="params">()</span> <span class="keyword">const</span> <span class="comment">// ⭐这里也添加关键字const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>此外，<strong>任何试图更改成员变量或调用非const成员函数 的 const成员函数 都会导致编译器错误。</strong>例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value ;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resetValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; m_value = <span class="number">0</span>; &#125; <span class="comment">// 编译错误, const成员函数不能修改成员变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="构造函数不能是const"><a href="#构造函数不能是const" class="headerlink" title="构造函数不能是const"></a>构造函数不能是const</h1><p>注意，<strong>构造函数不能标记为const。这是因为构造函数需要能够初始化它们的成员变量</strong>，而const构造函数则不能这样做。因此，不允许const构造函数。</p><h1 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h1><p>尽管实例化const类对象是创建const对象的一种方法<strong>，但更常见的方法是通过const引用将一个对象传递给一个函数</strong>。</p><hr><blockquote><p>在关于 <a href="http://www.learncpp.com/cpp-tutorial/73-passing-arguments-by-reference/" target="_blank" rel="noopener">passing arguments by reference</a>中，我们讨论了通过const引用而不是通过值传递类参数的优点。</p><p>总而言之，通过值传递类参数会导致生成类的副本(这比较慢)——大多数时候，我们不需要副本，<strong>对原始参数的引用可以很好地工作，而且更有性能，因为它避免了不必要的副本。</strong></p></blockquote><p>我们通常使用引用const，以确保函数不会在不经意间更改参数，并允许函数处理r-value(例如文字)，<u>这些r-value可以作为const引用传递，但不能作为非const引用</u>。</p><h2 id="不能在const对象上调用非const成员函数"><a href="#不能在const对象上调用非const成员函数" class="headerlink" title="不能在const对象上调用非const成员函数"></a>不能在const对象上调用非const成员函数</h2><p>您能找出以下代码的错误吗?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_year;</span><br><span class="line">    <span class="keyword">int</span> m_month;</span><br><span class="line">    <span class="keyword">int</span> m_day;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Date(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span><br><span class="line">    &#123;</span><br><span class="line">        setDate(year, month, day);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDate</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_year = year;</span><br><span class="line">        m_month = month;</span><br><span class="line">        m_day = day;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getYear</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_year; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMonth</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_month; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDay</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_day; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDate</span><span class="params">(<span class="keyword">const</span> Date &amp;date)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; date.getYear() &lt;&lt; <span class="string">"/"</span> &lt;&lt; date.getMonth() &lt;&lt; <span class="string">"/"</span> &lt;&lt; date.getDay() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Date <span class="title">date</span><span class="params">(<span class="number">2016</span>, <span class="number">10</span>, <span class="number">16</span>)</span></span>;</span><br><span class="line">    printDate(date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是，在<code>printDate</code>函数内部，date被视为一个const对象。使用这个常量 date，我们<u>调用函数<code>getYear()</code>、<code>getMonth()</code>和<code>getDay()</code>，它们都是非const的</u>。<strong>因为我们不能在const对象上调用非const成员函数，这将导致编译错误。</strong></p><ul><li><p>解决方法：使getYear()、getMonth()和getDay()这些函数成为 const:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_year;</span><br><span class="line">    <span class="keyword">int</span> m_month;</span><br><span class="line">    <span class="keyword">int</span> m_day;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Date(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span><br><span class="line">    &#123;</span><br><span class="line">        setDate(year, month, day);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// setDate() cannot be const, modifies member variables</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDate</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_year = year;</span><br><span class="line">        m_month = month;</span><br><span class="line">        m_day = day;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// The following getters can all be made const⭐</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getYear</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_year; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMonth</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_month; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDay</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_day; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h1 id="重载const和非const函数"><a href="#重载const和非const函数" class="headerlink" title="重载const和非const函数"></a>重载const和非const函数</h1><p>最后，虽然不经常这样做，<strong>但有可能重载一个函数，使其具有同一个函数的const和非const版本:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_value;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Something(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;value=<span class="string">""</span>) &#123; m_value= value; &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ⭐用于const对象的getValue()</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> m_value;&#125; <span class="comment">//⭐⭐⭐</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ⭐用于非const对象的getValue()</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="title">getValue</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_value;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><code>const std::string&amp; getValue() const {return m_value;}</code></p><ul><li><p><strong>最左边</strong>的const是函数返回类型的一部分，<strong>表示返回了一个const引用。</strong></p></li><li><p><strong>最右边</strong>的const表示成员函数<u>自身是const</u>。<strong>这意味着它不会改变对象的状态，并且可以被const类的对象调用。</strong></p></li></ul></blockquote><p>函数的const版本将在任何const对象上调用，而非const版本将在任何非const对象上调用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Something something;</span><br><span class="line">something.getValue() = <span class="string">"Hi"</span>; <span class="comment">// calls non-const getValue();</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> Something something2;</span><br><span class="line">something2.getValue(); <span class="comment">// calls const getValue();    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用const和非const版本的函数重载通常是在返回值需要在稳定性上有所不同时完成的。在上面的例子中：</p><ul><li><p>getValue()的非const版本将只与非const对象一起工作，但是更加灵活，因为我们可以使用它来读写m_value(通过分配字符串“Hi”来完成)。</p></li><li><p>getValue()的const版本<strong>既可以使用const对象，也可以使用非const对象</strong>，但是返回一个const引用，以确保我们不能修改const对象的数据。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/类的代码与头文件</title>
      <link href="/archives/8605edc6.html"/>
      <url>/archives/8605edc6.html</url>
      
        <content type="html"><![CDATA[<h1 id="在类定义之外定义成员函数"><a href="#在类定义之外定义成员函数" class="headerlink" title="在类定义之外定义成员函数"></a>在类定义之外定义成员函数</h1><p>随着类变得越来越长、越来越复杂，<strong>在类中包含所有成员函数定义</strong>会使类更难管理和使用。使用一个已经编写好的类只需要了解它的公共接口(公共成员函数)，而不需要了解类的底层工作方式。成员函数实现的细节只是一个障碍。</p><p>幸运的是，<strong>c++提供了一种将类的“声明”部分与“实现”部分分离的方法</strong>。</p><blockquote><p><strong>这是通过在类定义之外定义类成员函数来实现的。</strong></p><p>要做到这一点，只需定义类的成员函数，就像它们是普通函数一样，<strong>但是要使用范围解析操作符(::)将类名作为函数的前缀(与名称空间相同)。</strong></p></blockquote><hr><p>一个例子：</p><blockquote><p>请注意，这些函数的原型仍然存在于类定义中，但是实际的实现已经移到了类定义之外</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_year;</span><br><span class="line">    <span class="keyword">int</span> m_month;</span><br><span class="line">    <span class="keyword">int</span> m_day;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Date(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetDate</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getYear</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_year; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMonth</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_month; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDay</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> m_day; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Date constructor</span></span><br><span class="line">Date::Date(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span><br><span class="line">&#123;</span><br><span class="line">    SetDate(year, month, day);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Date member function</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Date::SetDate</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_month = month;</span><br><span class="line">    m_day = day;</span><br><span class="line">    m_year = year;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="将类定义放在头文件中"><a href="#将类定义放在头文件中" class="headerlink" title="将类定义放在头文件中"></a>将类定义放在头文件中</h1><p>在有关头文件的课程中 (<a href="http://www.learncpp.com/cpp-tutorial/19-header-files/" target="_blank" rel="noopener">header files</a>) ，您了解到可以将<strong>函数声明放在头文件</strong>中，以便在多个文件甚至多个项目中使用这些函数。</p><p><strong>类定义也可以放在头文件中</strong>，以便于在多个文件或多个项目中重用。</p><blockquote><p>传统上，类定义放在与类同名的头文件中，类外部定义的成员函数放在与类同名的.cpp文件中。</p></blockquote><p>如：</p><p>Date.h:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DATE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATE_H</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_year;</span><br><span class="line">    <span class="keyword">int</span> m_month;</span><br><span class="line">    <span class="keyword">int</span> m_day;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Date(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetDate</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getYear</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_year; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMonth</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_month; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDay</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> m_day; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>Date.cpp:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Date.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Date constructor</span></span><br><span class="line">Date::Date(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span><br><span class="line">&#123;</span><br><span class="line">    SetDate(year, month, day);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Date member function</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Date::SetDate</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_month = month;</span><br><span class="line">    m_day = day;</span><br><span class="line">    m_year = year;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，任何其他想要使用Date类的头文件或代码文件都可以简单地<code>#include &quot;Date.h&quot;</code>。注意，data .cpp还需要编译到任何使用Date.h的项目中，以便链接器知道如何实现Date。</p><h2 id="在头文件中定义类是否违反了one-definition规则"><a href="#在头文件中定义类是否违反了one-definition规则" class="headerlink" title="在头文件中定义类是否违反了one-definition规则?"></a>在头文件中定义类是否违反了one-definition规则?</h2><p>这是不应该的。如果您的头文件具有适当的头保护，则不应该在同一个文件中多次包含类定义。</p><p><u>类型(包括类)</u><strong>不受</strong>one-definition规则的约束，该规则规定每个程序只能有一个定义。因此，在多个代码文件中包含类定义并没有问题(如果有的话，类也没有多大用处)。</p><h2 id="在头文件中定义成员函数是否违反了one-definition规则"><a href="#在头文件中定义成员函数是否违反了one-definition规则" class="headerlink" title="在头文件中定义成员函数是否违反了one-definition规则?"></a>在头文件中定义成员函数是否违反了one-definition规则?</h2><ul><li>视情况而定。在类定义<strong>中</strong> 定义的成员函数被认为是<strong>隐式内联</strong>的。内联函数不受one-definition规则中每个程序的一个定义的约束。<strong>这意味着在类定义本身内部定义普通的成员函数(例如访问函数)是没有问题的。</strong></li></ul><ul><li><p>在类定义<strong>之外</strong>定义的成员函数<strong>被视为普通函数</strong>，并且受一个定义规则中每个程序部分的一个定义的约束。</p><p>因此，这些函数应该在代码文件(.cpp)中定义，而不是在头文件中定义。唯一的例外是模板函数，我们将在以后的章节中讨论。</p></li></ul><h2 id="应该在头文件和cpp文件中定义什么，在类定义的内部-和-外部-定义什么"><a href="#应该在头文件和cpp文件中定义什么，在类定义的内部-和-外部-定义什么" class="headerlink" title="应该在头文件和cpp文件中定义什么，在类定义的内部 和 外部 定义什么?"></a>应该在头文件和cpp文件中定义什么，在类定义的内部 和 外部 定义什么?</h2><p>您可能会试图将所有成员函数定义<strong>放入类内的头文件中</strong>。虽然这将编译，但这样做有几个缺点：</p><ul><li><p>首先，如上所述，这会使类定义变得混乱。</p></li><li><p>类中定义的函数是隐式内联的。对于从许多地方调用的大型函数，这会使代码膨胀。</p></li><li><p>第三，如果您更改了<strong>头文件</strong>的代码，那么您需要重新编译包含该头文件的每个文件。</p><blockquote><p>这可能会产生连锁反应，一个微小的更改就会导致整个程序需要重新编译(这可能很慢)。</p><hr></blockquote><p>(但是，你<strong>更改.cpp文件，编译器只会重新编译改动过的 .cpp文件</strong>)</p></li></ul><hr><p>因此，我们建议如下:</p><ul><li>对于 仅在一个通常不重用的文件 中使用的类，直接在使用它们的单个.cpp文件中定义它们。</li><li>对于在多个文件中使用的类，或者用于一般重用的类，请在与类同名的.h文件中定义它们。</li><li>普通成员函数(普通构造函数或析构函数、访问函数等)可以<strong>在类<u>中</u>定义</strong>。</li><li>非普通成员函数应该在与类同名的<strong>.cpp文件中定义</strong>。</li></ul><h2 id="成员函数的默认参数应该在类定义中声明-头文件中"><a href="#成员函数的默认参数应该在类定义中声明-头文件中" class="headerlink" title="成员函数的默认参数应该在类定义中声明(头文件中)"></a>成员函数的默认参数应该在类定义中声明(头文件中)</h2><p>成员函数的默认参数应该在类定义中声明(在头文件中)，在那里任何人都可以看到#includes 这个头文件。</p><h1 id="库"><a href="#库" class="headerlink" title="库"></a>库</h1><p><strong>分离类定义和类实现对于可用于扩展程序的库非常常见</strong>。</p><p>在您的整个程序中，你已经#included 许多标准的库，如iostream, string, vector, array等等。您的程序需要头文件的声明，以便编译器验证您正在编写的程序在语法上是正确的。</p><blockquote><p>注意，您不需要添加 iostream.cpp, string.cpp, vector.cpp, or array.cpp 到你的程序中。</p></blockquote><p>但是，<strong>属于c++标准库的类的实现包含在一个预编译文件中</strong>，该文件在<strong>链接阶段</strong>被链接进来。你永远看不到代码。</p><hr><p>除了一些开源软件(同时提供.h和.cpp文件)之外，<strong>大多数第三方库只提供头文件和预编译的库文件</strong>。这有几个原因：</p><ul><li>链接预编译的库比每次需要时重新编译要快；</li><li>预编译库的单个副本可以被许多应用程序共享，而编译后的代码被编译到使用它的每个可执行文件中(增大文件大小)。</li><li>知识产权原因(您不希望别人窃取您的代码)。</li></ul><p>将您自己的文件分隔为声明(头文件)和实现(代码文件)不仅是一种良好的形式，而且还使创建您自己的自定义库更加容易。创建自己的库超出了本教程的范围，但是将声明和实现分离是这样做的先决条件。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/隐藏的“this”指针</title>
      <link href="/archives/7d6924a1.html"/>
      <url>/archives/7d6924a1.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/8-8-the-hidden-this-pointer/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/8-8-the-hidden-this-pointer/</a></p><hr><p>新的面向对象程序员经常问的一个关于类的问题是，“<strong>当一个成员函数被调用时，c++如何跟踪它被调用的对象?”</strong></p><p>答案是：<strong>C++使用了一个名为“this”的隐藏指针!</strong> 让我们更详细地看看“this”。</p><p>下面是一个简单的类，它保存一个整数并提供一个构造函数和访问函数。<strong>注意，不需要析构函数，因为c++可以为我们清理整数成员变量</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_id;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Simple(<span class="keyword">int</span> id)</span><br><span class="line">    &#123;</span><br><span class="line">        setID(id);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setID</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123; m_id = id; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getID</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_id; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是一个使用这个类的示例程序:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Simple <span class="title">simple</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    simple.setID(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; simple.getID() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>当我们调用<code>simple.setID(2);</code>时，c++知道<code>setID()</code>函数应该对simple对象进行操作，<code>m_id</code>实际上指的是<code>simple.m_id</code>。让我们研究一下这背后的机制。</p><h1 id="隐藏的-this指针"><a href="#隐藏的-this指针" class="headerlink" title="隐藏的*this指针"></a>隐藏的<code>*this</code>指针</h1><p>看看上面例子中的代码行:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">simple.setID(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>尽管对<code>setID()</code>函数的调用<u>看起来</u>只有一个参数，但<u>实际上</u>它有两个! 在编译时，编译器将转换<code>simple.setID(2);</code>为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setID(&amp;simple, <span class="number">2</span>); <span class="comment">//注意，simple已经从一个对象前缀 更改为一个函数参数!</span></span><br></pre></td></tr></table></figure><p>注意，这现在只是一个标准的函数调用，</p><blockquote><p>而 simple对象 (以前是一个对象前缀) <strong>现在通过 地址传递 作为函数的参数。</strong></p></blockquote><hr><p><strong>但这只是答案的一半。</strong></p><blockquote><p><strong>由于函数调用现在添加了一个新的的参数，因此需要修改成员函数定义，以接受(并使用)这个参数作为参数</strong>。因此，有以下成员函数:</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setID</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123; m_id = id; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被转换为：⭐</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setID</span><span class="params">(Simple* <span class="keyword">const</span> <span class="keyword">this</span>, <span class="keyword">int</span> id)</span> </span>&#123;<span class="keyword">this</span>-&gt;m_id = id;&#125;</span><br></pre></td></tr></table></figure><hr><p>当编译器编译一个普通成员函数时，它会隐式地向函数添加一个名为“this”的新参数。<strong>this指针</strong>是一个隐藏的<strong>const指针</strong>，<u>它保存成员函数所调用的对象的地址。</u></p><hr><p><strong>还有一个细节要处理</strong>。</p><p>在成员函数内部，还需要更新任何类成员(函数和变量)，以便它们引用调用成员函数的对象。这很容易做到，只要在每一个前面加上<strong>“this -&gt;”</strong>就可以了。</p><blockquote><p>因此，在<code>setID()</code>函数体中，<strong>m_id</strong>(它是一个类成员变量)被转换为<strong>this-&gt;m_id</strong>。因此，当“this”指向simple的地址时， <strong>this-&gt;m_id</strong>将解析为<strong>simple. m_id</strong>。</p></blockquote><h2 id="综上所述："><a href="#综上所述：" class="headerlink" title="综上所述："></a>综上所述：</h2><ol><li>当我们调用<code>simple.setID(2)</code>，编译器实际上调用 <code>setID(&amp;simple, 2)</code></li><li>在<code>setID()</code>中，“this”指针保存了 对象simple 的地址。</li><li><code>setID()</code>中的任何成员变量都以“<code>this-&gt;</code>”作为前缀。所以当我们说m_id = id时，编译器实际上是在执行<code>this-&gt;m_id = id</code>，在本例中将 <code>simple.m_id</code> 转换为 <code>id</code>。</li></ol><p>好消息是，所有这些都是自动发生的，不管你是否记得它是如何工作的。您需要记住的是，<strong>所有普通成员函数都有一个“this”指针，该指针指向函数所调用的对象。</strong></p><h1 id="“this”总是指向被操作的对象"><a href="#“this”总是指向被操作的对象" class="headerlink" title="“this”总是指向被操作的对象"></a>“this”总是指向被操作的对象</h1><p>新程序员有时会对存在多少“this”指针感到困惑。</p><p><strong>每个成员函数都有一个“this”指针参数，该参数被设置为正在操作的对象的地址</strong>。请看:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Simple <span class="title">A</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="comment">// this = &amp;A 在 Simple 构造函数的内部</span></span><br><span class="line">    <span class="function">Simple <span class="title">B</span><span class="params">(<span class="number">2</span>)</span></span>; <span class="comment">// this = &amp;B 在 Simple 构造函数的内部</span></span><br><span class="line">    A.setID(<span class="number">3</span>); <span class="comment">// this = &amp;A 在成员函数 setID 的内部</span></span><br><span class="line">    B.setID(<span class="number">4</span>); <span class="comment">// this = &amp;B 在成员函数 setID 的内部</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，“this”指针交替保存对象A或B的地址，这取决于我们是否在对象A或B上调用了成员函数。</p><hr><h1 id="“this”是一个参数，它存放于栈中"><a href="#“this”是一个参数，它存放于栈中" class="headerlink" title="“this”是一个参数，它存放于栈中"></a>“this”是一个参数，它存放于栈中</h1><p><strong>因为“this”只是一个函数参数，它不会向您的类添加任何内存使用</strong> (只会添加到成员函数调用，因此该参数在函数执行时在<strong>栈</strong>上运行)。</p><h1 id="显式地引用“this”"><a href="#显式地引用“this”" class="headerlink" title="显式地引用“this”"></a>显式地引用“this”</h1><p>大多数时候，您不需要显式地引用“this”指针。但是，在某些情况下这样做是有用的:</p><blockquote><p>首先，如果你有一个构造函数(或成员函数)，它有一个与成员变量同名的参数，你可以使用“this”来消除它们的歧义:</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Something(<span class="keyword">int</span> data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;data = data; <span class="comment">// this-&gt;data是成员变量，data是本地参数</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>请注意，我们的构造函数接受同名的参数作为成员变量。在本例中，“data”指的是参数，“this-&gt;data”指的是成员变量。虽然这是可接受的编码实践，但我们发现在所有<strong>成员变量名上使用“m_”前缀</strong>提供了更好的解决方案，它完全防止了重复的名称!</p><p>有些开发人员喜欢显式地将这个-&gt;添加到所有类成员中。我们建议您避免这样做，因为这样做会降低代码的可读性，并且没有什么好处。<strong>使用<code>m_</code>前缀是区分成员变量和非成员(本地)变量的一种更具可读性的方法。</strong></p><h2 id="链接成员函数"><a href="#链接成员函数" class="headerlink" title="链接成员函数"></a>链接成员函数</h2><p>其次，有时让类成员函数返回它正在处理的对象作为返回值是有用的。</p><p><strong>这样做的主要原因是允许将一系列成员函数“链接”在一起</strong>，这样就可以在同一个对象上调用多个成员函数!</p><p>其实你已经这样做了很长时间了。考虑下面这个常见的示例，在这个示例中，您使用std::cout输出了多于一位的文本:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, "</span> &lt;&lt; userName;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的代码，std::cout是一个对象，而操作符&lt;&lt;是操作该对象的成员函数。编译器像这样计算上面的代码片段:</span></span><br><span class="line">(<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, "</span>) &lt;&lt; userName;</span><br></pre></td></tr></table></figure><p>首先，操作符&lt;&lt; 使用std::cout和字符串文字“Hello，”将“Hello”打印到控制台。但是，由于这是表达式的一部分，操作符&lt;&lt;也需要返回一个值(或void)。如果操作符&lt;&lt;返回void，您将得到以下结果:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">void</span>) &lt;&lt; userName;</span><br><span class="line"><span class="comment">//这显然没有任何意义(并且编译器会抛出一个错误)。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//相反，操作符&lt;&lt;返回 *this，在这个上下文中是std::cout对象。</span></span><br><span class="line"><span class="comment">//这样，在第一个运算符&lt;&lt;被求值后，我们得到:</span></span><br><span class="line">(<span class="built_in">std</span>::<span class="built_in">cout</span>) &lt;&lt; userName;</span><br></pre></td></tr></table></figure><p>这样，我们只需要指定对象一次(在本例中是std::cout)，每个函数调用都会将其传递给下一个要使用的函数，从而允许我们将多个命令链接在一起。</p><hr><p>我们可以自己实现这种行为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Calc() &#123;m_value = <span class="number">0</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; m_value += value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; m_value -= value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mult</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; m_value *= value; &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果你想加5，减3，再乘以4，你必须这样做:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Calc calc;</span><br><span class="line">    calc.add(<span class="number">5</span>); <span class="comment">// returns void</span></span><br><span class="line">    calc.sub(<span class="number">3</span>); <span class="comment">// returns void</span></span><br><span class="line">    calc.mult(<span class="number">4</span>); <span class="comment">// returns void</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; calc.getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>但是</strong>，如果我们让每个函数返回*this，我们可以将这些调用链接在一起。以下是新版本的Calc与“链”功能:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Calc() &#123; m_value = <span class="number">0</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Calc&amp; <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;m_value += value; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">    <span class="function">Calc&amp; <span class="title">sub</span><span class="params">(<span class="keyword">int</span> vaule)</span> </span>&#123;m_value -= value; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">    <span class="function">Calc&amp; <span class="title">mult</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; m_value *= value; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gerValue</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_value;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意，add()、sub()和mult()现在返回*this。因此，这使我们能够做到以下几点:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Calc calc;</span><br><span class="line">    calc.add(<span class="number">5</span>).sub(<span class="number">3</span>).mult(<span class="number">4</span>);  <span class="comment">//⭐</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; calc.getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>我们已经有效地将三行压缩成一个表达式! 让我们仔细看看它是<strong>如何工作的</strong>。</p><ul><li><p>首先，<code>calc.add(5)</code>被调用。</p><blockquote><p>它给<code>m_value.add ()</code>增加5，然后返回<code>*this</code>，它只是calc的一个引用。<strong>因此，calc将是后续计算中使用的对象。</strong></p></blockquote></li><li><p>然后，<code>calc.sub(3)</code>被执行。</p><blockquote><p>从m_value中减去3，再次返回calc。</p></blockquote></li><li><p>最后，执行<code>calc.mult(4)</code></p><blockquote><p>将<code>m_value</code>乘以4，然后返回calc。（它没有进一步使用，因此被忽略。）</p></blockquote></li></ul><p>由于每个函数在执行时都会修改calc，所以calc的m_value现在包含值((((0 + 5)- 3)* 4)，即8。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>“this”指针是隐式添加到任何<u>非静态成员函数</u>的隐藏参数。大多数情况下，您不需要直接访问它。</p><p>但是如果需要，您可以访问它。值得注意的是“this”是一个<strong>const指针</strong>——即，<strong>您可以更改它所指向的底层对象的<u>值</u>，但是您<u>不能让它指向其他对象</u>!</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/析构函数</title>
      <link href="/archives/db2095e5.html"/>
      <url>/archives/db2095e5.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/8-7-destructors/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/8-7-destructors/</a></p><p><strong>析构函数(Destructors)</strong>是另一种特殊的类成员函数，<strong>它在类的对象被销毁时执行</strong>。</p><blockquote><p><strong>构造函数的设计目的是初始化类</strong>；而<strong>析构函数的设计目的是帮助清理类</strong>。</p></blockquote><hr><p>当一个对象通常超出作用域，或者使用delete关键字显式删除动态分配的对象时，会自动调用类析构函数(如果存在的话)，以便在从内存中删除对象之前进行任何必要的清理。</p><p><strong>对于简单的类 (那些只初始化普通成员变量值的类)，不需要析构函数</strong>，因为c++会自动为您清理内存。</p><p>然而,如果你的类对象持有任何资源 (如动态内存,或处理的文件或数据库) ,或者如果你需要做任何维护对象被摧毁之前, <strong>析构函数是完美的地方，因为它通常是发生在对象被销毁之前的最后一件事。</strong></p><h1 id="析构函数的命名"><a href="#析构函数的命名" class="headerlink" title="析构函数的命名"></a>析构函数的命名</h1><p>和构造函数一样，析构函数也有特定的命名规则：</p><ul><li>析构函数必须具有与类相同的名称，前面有一个波浪号(~)。</li><li>析构函数<strong>不能</strong>接受参数。</li><li>析构函数<strong>没有</strong>返回类型。</li></ul><p>注意，<strong>规则2意味着每个类只能存在一个析构函数</strong>，因为没有重载析构函数的方法（因为它们不能根据参数彼此区分。）</p><hr><p>通常，<u>您<strong>不应该</strong>显式地调用析构函数(因为当对象被销毁时，会自动调用它)</u>，因为很少有需要多次清理对象的情况。</p><p>然而，析构函数可以安全地调用其他成员函数，因为对象直到析构函数执行后才会被销毁。</p><p>来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">IntArray(<span class="keyword">int</span> length) <span class="comment">//构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">assert(length &gt; <span class="number">0</span>);</span><br><span class="line">m_array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt;(length)]&#123;&#125;;</span><br><span class="line">m_length = length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~IntArray() <span class="comment">//析构函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//动态删除我们之前分配的数组</span></span><br><span class="line"><span class="keyword">delete</span>[] m_array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_array[index] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_array[index];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getlength</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span>* m_array;</span><br><span class="line"><span class="keyword">int</span> m_length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">IntArray arr&#123; <span class="number">10</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> count&#123; <span class="number">0</span> &#125;; count &lt; arr.getlength(); count++)</span><br><span class="line">&#123;</span><br><span class="line">arr.setValue(count, count + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The value of element 5 is: "</span> &lt;&lt; arr.getValue(<span class="number">5</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">//类ar在这里被销毁，所以，析构函数~IntArray() 在这里被调用</span></span><br></pre></td></tr></table></figure><p>在第一行，我们实例化一个名为ar的新IntArray类对象，并传入一个长度为10的值。它调用构造函数，构造函数动态地为数组成员分配内存。我们必须在这里使用动态分配，因为在编译时我们不知道数组的长度是多少(调用者决定)。</p><p>在main()的末尾，ar超出了范围。这将导致调用~IntArray()析构函数，它将删除我们在构造函数中分配的数组!</p><h1 id="进一步看构造、析构-函数被调用的时间"><a href="#进一步看构造、析构-函数被调用的时间" class="headerlink" title="进一步看构造、析构 函数被调用的时间"></a>进一步看构造、析构 函数被调用的时间</h1><p>如前所述，在创建对象时调用构造函数，在销毁对象时调用析构函数。在下面的例子中，我们在构造函数和析构函数中使用<code>std::cout</code>语句来说明这一点:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_nID;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Simple(<span class="keyword">int</span> nID)</span><br><span class="line">        : m_nID&#123; nID &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Constructing Simple "</span> &lt;&lt; nID &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~Simple()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Destructing Simple"</span> &lt;&lt; m_nID &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getID</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_nID; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 在栈上分配一个Simple</span></span><br><span class="line">    Simple simple&#123; <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; simple.getID() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 动态分配一个Simple</span></span><br><span class="line">    Simple *pSimple&#123; <span class="keyword">new</span> Simple&#123; <span class="number">2</span> &#125; &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pSimple-&gt;getID() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 我们动态地分配了pSimple，所以我们必须删除它。</span></span><br><span class="line">    <span class="comment">//⭐【不推荐】请看下面的RAII中的讲解:"规则: 如果您的类动态分配内存，请使用RAII范型，不要动态分配类的对象 "</span></span><br><span class="line">    <span class="keyword">delete</span> pSimple;  <span class="comment">//在这里调用了析构函数</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// simple goes out of scope here  再次调用析构函数</span></span><br></pre></td></tr></table></figure><p>这个程序产生以下结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Constructing Simple 1</span><br><span class="line">1</span><br><span class="line">Constructing Simple 2</span><br><span class="line">2</span><br><span class="line">Destructing Simple 2</span><br><span class="line">Destructing Simple 1</span><br></pre></td></tr></table></figure><p>注意，“Simple 1”在“Simple 2”之后被销毁<strong>，因为我们在函数结束之前删除了pSimple，而Simple直到main()结束才被销毁。</strong></p><hr><p><strong>全局变量</strong>在main()之前构造，在main()之后销毁。</p><h1 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h1><p>*<em>RAII(资源获取即初始化) *</em>是一种编程技术，通过自动持续时间(例如，非动态分配的对象)将资源使用绑定到对象的生存期。</p><p>在c++中，RAII是通过具有 构造函数 和 析构函数 的<strong>类</strong>实现的。</p><p>资源 (如内存、文件或数据库句柄等) <u>通常是在对象的构造函数中获得的</u>(不过如果有意义的话，也可以在创建对象之后获得)。然后，可以在对象处于活动状态时使用该资源。当对象被销毁时，资源在析构函数中释放。</p><p><strong>RAII的主要优点</strong>是它有助于防止资源泄漏(例如内存未释放)，因为所有资源持有对象都被自动清除。</p><hr><p>本课顶部的<code>IntArray类</code>是一个实现RAII的类的例子——在构造函数中实现分配，在析构函数中实现释放。</p><p><code>std::string</code>和<code>std::vector</code>是标准库中遵循RAII的类的示例——动态内存在初始化时获得，在销毁时自动清除。</p><blockquote><p>规则:<strong>如果您的类动态分配内存，请使用RAII范型，不要动态分配类的对象</strong></p></blockquote><h1 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h1><p>正如您所看到的，<strong>当构造函数和析构函数一起使用时，您的类可以在它们自己之后初始化和清理，而程序员不需要做任何特殊的工作</strong>! 这减少了出错的可能性，并使类更易于使用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/函数功能重叠--委托函数</title>
      <link href="/archives/8dd10d3c.html"/>
      <url>/archives/8dd10d3c.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/8-6-overlapping-and-delegating-constructors/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/8-6-overlapping-and-delegating-constructors/</a></p><hr><h1 id="Overlapping"><a href="#Overlapping" class="headerlink" title="Overlapping"></a>Overlapping</h1><h2 id="含有重叠功能的构造函数"><a href="#含有重叠功能的构造函数" class="headerlink" title="含有重叠功能的构造函数"></a>含有重叠功能的构造函数</h2><p>当实例化一个新对象时，对象的构造函数被C++编译器隐式地调用。拥有多个具有重叠功能的构造函数的类并不少见。考虑以下类别:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该类有两个构造函数:一个默认构造函数和一个接受整数的构造函数。因为构造函数的“执行代码”部分是两个构造函数都需要的，所以代码在每个构造函数中重复。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// code to do A</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Foo(<span class="keyword">int</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// code to do A</span></span><br><span class="line">        <span class="comment">// code to do B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>正如您(希望)已经了解到的，尽可能避免出现重复的代码，所以让我们来看看解决这个问题的一些方法。</p><h2 id="解决重叠功能部分"><a href="#解决重叠功能部分" class="headerlink" title="解决重叠功能部分"></a>解决重叠功能部分</h2><h3 id="显而易见的解决方案在c-11之前是行不通的"><a href="#显而易见的解决方案在c-11之前是行不通的" class="headerlink" title="显而易见的解决方案在c++ 11之前是行不通的"></a>显而易见的解决方案在c++ 11之前是行不通的</h3><ol><li><p>最明显的解决方案是让Foo(int)构造函数调用Foo()构造函数来执行A部分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// code to do A</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Foo(<span class="keyword">int</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        Foo(); <span class="comment">// 使用上面的构造函数执行A(不起作用)</span></span><br><span class="line">        <span class="comment">// code to do B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>或者是这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// code to do A</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Foo(<span class="keyword">int</span> value): Foo() <span class="comment">// use the above constructor  to do A (在C++11之前，是行不通的)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// code to do B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>然而，对于预c++ 11编译器，如果您试图让一个构造函数调用另一个构造函数，<strong>它通常会编译，但它不会像您所期望的那样工作</strong>，并且您可能会花费很长时间试图找出原因，即使使用调试器也是如此。</p><blockquote><p>可能的一种解释：在C++ 11之前，从另一个构造函数显式地调用另一个构造函数 将创建一个临时对象，使用构造函数初始化临时对象，然后丢弃它，保持原始对象不变。</p></blockquote><h3 id="使用单独的函数"><a href="#使用单独的函数" class="headerlink" title="使用单独的函数"></a>使用单独的函数</h3><p><strong>C++ 允许构造函数调用类中的 <u>非构造函数</u>。但要注意，<u>非构造函数使用的任何成员都已经初始化了</u>。</strong>尽管您可能会试图将代码从第一个构造函数复制到第二个构造函数，但是有重复的代码会使您的类更难于理解，维护起来也更麻烦。<strong>此问题的最佳解决方案是创建一个非构造函数来执行公共初始化，并让两个构造函数都调用该函数。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// code to do A</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo()</span><br><span class="line">    &#123;</span><br><span class="line">        DoA();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Foo(<span class="keyword">int</span> nValue)</span><br><span class="line">    &#123;</span><br><span class="line">        DoA();</span><br><span class="line">        <span class="comment">// code to do B</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过这种方式，代码重复率被保持到最小。</p><hr><h4 id="将初始化部分代码分离出来"><a href="#将初始化部分代码分离出来" class="headerlink" title="将初始化部分代码分离出来"></a>将初始化部分代码分离出来</h4><p>您可能会发现自己处于这样一种情况:</p><p><strong>您想要编写一个成员函数来重新初始化一个类，使其返回默认值</strong>。</p><p>由于您可能已经有一个这样的构造函数，所以您可能会尝试从您的成员函数中调用构造函数。然而，试图直接调用构造函数通常会导致意外行为。许多开发人员只是简单地从初始化函数的构造函数中复制代码，这可以工作，但是会导致重复的代码。</p><p>在这种情况下，<strong>最好的解决方案是将代码从构造函数移到新函数中，并让构造函数调用该函数来完成初始化数据的工作:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo()</span><br><span class="line">    &#123;</span><br><span class="line">        Init();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Foo(<span class="keyword">int</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        Init();</span><br><span class="line">        <span class="comment">// do something with value</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// code to init Foo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>包含一个<code>Init()</code>函数是相当常见的，该函数将成员变量初始化为其默认值，然后让每个构造函数在执行特定于参数的任务<strong>之前</strong>调用<code>Init()</code>函数。这将最小化代码重复，并允许您在任何地方显式地调用<code>Init()</code>。</p><blockquote><p>一个小警告:</p><p>在使用<code>Init()</code>函数和 动态分配内存时要小心。因为<code>Init()</code>函数可以由任何人在任何时候调用，所以在调用<code>Init()</code>时，动态分配的内存可能已经分配，也可能还没有分配。</p><p>要注意适当地处理这种情况——这可能有点令人困惑，因为非空指针可以是动态分配的内存，也可以是未初始化的指针!</p></blockquote><h1 id="在c-11中委托构造函数"><a href="#在c-11中委托构造函数" class="headerlink" title="在c++ 11中委托构造函数"></a>在c++ 11中委托构造函数</h1><p>从c++ 11开始，<strong>允许构造函数调用其他构造函数</strong>。这个过程称为<strong>委托构造函数</strong>(或构<strong>造函数链</strong>)。</p><p>要让一个构造函数调用另一个构造函数，只需调用成员初始化器列表中的构造函数。在这种情况下，直接调用另一个构造函数是可以接受的。应用到我们上面的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//code to do A</span></span><br><span class="line">    &#125;</span><br><span class="line">    Foo(<span class="keyword">int</span> value) : Foo() <span class="comment">//使用 默认构造函数Foo() 来执行A</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//code to do B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>正如您所期望的那样。<strong>确保从成员初始化器列表调用构造函数，而不是在构造函数的主体中调用。</strong></p><p>下面是另一个使用委托构造函数来减少冗余代码的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_id;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Employee(<span class="keyword">int</span> id=<span class="number">0</span>; <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name=<span class="string">""</span>)</span><br><span class="line">        : m_id(id), m_name(name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Employee "</span> &lt;&lt; m_name &lt;&lt; <span class="string">" created.\n"</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用委托构造函数来最小化冗余代码</span></span><br><span class="line">     Employee(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name) : Employee(<span class="number">0</span>, name) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个类有两个构造函数，其中一个委托给Employee(int, const std::string &amp;)。通过这种方式，冗余代码的数量被最小化(我们只需要编写一个构造函数体，而不是两个)。</p><h2 id="附加说明"><a href="#附加说明" class="headerlink" title="附加说明"></a>附加说明</h2><p>关于委托构造函数的一些附加说明。</p><ul><li>首先，委托给另一个构造函数的构造函数本身不允许执行任何成员初始化。所以你的构造函数可以委托或初始化，<strong>但不能同时委托和初始化</strong>。</li><li>其次，一个构造函数可以委托给另一个构造函数，后者再委托给第一个构造函数。这形成了一个无限循环，并将导致您的程序运行堆栈空间和崩溃。<strong>可以通过确保所有构造函数都解析为非委托的构造函数来避免这种情况。</strong></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/非静态成员初始化</title>
      <link href="/archives/4635f066.html"/>
      <url>/archives/4635f066.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-programming/8-5b-non-static-member-initialization/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-programming/8-5b-non-static-member-initialization/</a></p><hr><p>当编写一个具有多个构造函数的类(大多数构造函数)时，必须为每个构造函数中的所有成员指定默认值，这会导致代码冗余。<strong>如果更新成员的默认值，则需要修改每个构造函数</strong>。</p><p>从c++ 11开始，可以直接给<strong>普通的类成员变量(那些不使用static关键字的变量)</strong>一个默认的初始值:</p><blockquote><p>注意，使用非静态成员初始化 来 初始化成员 需要使用<strong>等号</strong>或<strong>大括号(统一)初始化器</strong>，但是<strong>直接初始化表（即，使用小括号）单在这里不起作用</strong>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//给这些普通的类成员变量(那些不使用static关键字的变量)一个默认的初始值:</span></span><br><span class="line">    <span class="comment">//注意：你可以用：“=” 或 “大括号(统一初始化)”</span></span><br><span class="line">    <span class="comment">//   但是，"直接初始化(即，使用小括号)" 在这里是不能用的。⭐</span></span><br><span class="line">    <span class="keyword">double</span> m_length&#123; <span class="number">1.0</span> &#125;; <span class="comment">// m_length has a default value of 1.0</span></span><br><span class="line">    <span class="keyword">double</span> m_width&#123; <span class="number">1.0</span> &#125;; <span class="comment">// m_width has a default value of 1.0</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"length: "</span> &lt;&lt; m_length &lt;&lt; <span class="string">", width: "</span> &lt;&lt; m_width &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rectangle x&#123;&#125;; <span class="comment">// x.m_length = 1.0, x.m_width = 1.0</span></span><br><span class="line">    x.<span class="built_in">print</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">length: <span class="number">1.0</span>, <span class="built_in">width</span>: <span class="number">1.0</span></span><br></pre></td></tr></table></figure><p>非静态成员初始化 (也称为类内成员初始化) 为您的成员变量提供默认值，<strong>如果构造函数没有为成员本身提供初始化值(通过成员初始化列表)，则构造函数将使用这些值。</strong></p><hr><h1 id="构造函数仍然决定可以创建什么类型的对象"><a href="#构造函数仍然决定可以创建什么类型的对象" class="headerlink" title="构造函数仍然决定可以创建什么类型的对象"></a>构造函数仍然决定可以创建什么类型的对象</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_length&#123; <span class="number">1.0</span> &#125;;</span><br><span class="line">    <span class="keyword">double</span> m_width&#123; <span class="number">1.0</span> &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//注意:本例中没有提供默认构造函数</span></span><br><span class="line">    Rectangle(<span class="keyword">double</span> length, <span class="keyword">double</span> <span class="built_in">width</span>)</span><br><span class="line">        : m_length&#123; length &#125;, m_width&#123; <span class="built_in">width</span> &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// m_length and m_width 由构造函数初始化(不使用默认值)</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"length: "</span> &lt;&lt; m_length &lt;&lt; <span class="string">", width: "</span> &lt;&lt; m_width &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rectangle x&#123;&#125;; <span class="comment">//✖，将不会被编译。因为不存在默认的构造函数，所以不能用这种形式。（即使成员有默认的初始化值，但是它不是默认的构造函数提供的）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>尽管我们为所有成员提供了默认值，但是没有提供默认构造函数，所以我们无法创建没有参数的Rectangle对象。</strong></p><h1 id="构造函数的初始化器列表-优先于-默认初始值"><a href="#构造函数的初始化器列表-优先于-默认初始值" class="headerlink" title="构造函数的初始化器列表 优先于 默认初始值"></a>构造函数的初始化器列表 优先于 默认初始值</h1><p><strong>如果提供了默认初始值，同时也提供了 构造函数通过成员初始化器列表初始化成员，则成员初始化器列表优先</strong>。下面的例子说明了这一点:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_length&#123; <span class="number">1.0</span> &#125;;</span><br><span class="line">    <span class="keyword">double</span> m_width&#123; <span class="number">1.0</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Rectangle(<span class="keyword">double</span> length, <span class="keyword">double</span> <span class="built_in">width</span>)</span><br><span class="line">        : m_length&#123; length &#125;,</span><br><span class="line">          m_width&#123; <span class="built_in">width</span> &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//m_length and m_width 由构造函数初始化(不使用默认值)</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     Rectangle(<span class="keyword">double</span> length)</span><br><span class="line">        : m_length&#123; length &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// m_length 由构造函数初始化.</span></span><br><span class="line">        <span class="comment">// m_width's 使用默认的值(1.0)</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"length: "</span> &lt;&lt; m_length &lt;&lt; <span class="string">", width: "</span> &lt;&lt; m_width &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rectangle x&#123; <span class="number">2.0</span>, <span class="number">3.0</span> &#125;;</span><br><span class="line">    x.<span class="built_in">print</span>();</span><br><span class="line">    </span><br><span class="line">    Rectangle y&#123; <span class="number">4.0</span> &#125;;</span><br><span class="line">    y.<span class="built_in">print</span>();  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">length: <span class="number">2.0</span>, <span class="built_in">width</span>: <span class="number">3.0</span></span><br><span class="line">length: <span class="number">4.0</span>, <span class="built_in">width</span>: <span class="number">1.0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/构造函数</title>
      <link href="/archives/781f4530.html"/>
      <url>/archives/781f4530.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/85-constructors/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/85-constructors/</a></p><hr><p>当一个类（或结构体）的所有成员都是<code>public</code>时，我们可以使用：</p><ul><li>初始化列表（initialization list ）</li><li>或者，统一初始化（uniform initialization）</li></ul><p>来初始化这个类（或结构体）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_x;</span><br><span class="line">    <span class="keyword">int</span> m_y;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo foo1 = &#123; <span class="number">4</span>, <span class="number">5</span> &#125;; <span class="comment">// initialization list</span></span><br><span class="line">    Foo foo2 &#123; <span class="number">6</span>, <span class="number">7</span> &#125;; <span class="comment">// uniform initialization</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是<strong>，一旦我们将任何成员变量设为私有，我们就不能再以这种方式初始化类了。</strong>这是有意义的:如果你不能直接访问一个变量(因为它是私有的)，讲道理你是不能够直接初始化它。</p><p>那么我们如何用私有成员变量初始化一个类呢? <strong>答案是通过构造函数。</strong></p><h1 id="构造函数-Constructor"><a href="#构造函数-Constructor" class="headerlink" title="构造函数(Constructor)"></a>构造函数(<strong>Constructor</strong>)</h1><p><strong>构造函数是</strong>一种特殊的 类成员函数，在实例化该类的对象时自动调用。</p><p><strong>构造函数</strong>通常<u>用于</u>初始化类的成员变量，使其具有适当的默认值或用户提供的值，或执行使用类所需的任何设置步骤(例如打开文件或数据库)。</p><p>与普通成员函数不同，构造函数有特定的<strong>命名规则</strong>：</p><ol><li>构造函数必须具有与类相同的名字(使用相同的大小写)</li><li>构造函数没有返回类型(甚至不是void)</li></ol><hr><h1 id="默认的构造函数"><a href="#默认的构造函数" class="headerlink" title="默认的构造函数"></a>默认的构造函数</h1><p><u>不接受参数</u>的构造函数 (或所有参数都有默认值的构造函数) 称为<strong>默认构造函数</strong>。</p><p>如果没有提供 <u>用户提供的初始化值</u>，则调用默认构造函数。</p><p>一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_numerator;</span><br><span class="line">    <span class="keyword">int</span> m_denominator;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Fraction() <span class="comment">// default constructor</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_numerator = <span class="number">0</span>;</span><br><span class="line">        m_denominator = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumerator</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_numerator;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDenominator</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_denominator;&#125;</span><br><span class="line">    <span class="keyword">double</span> getValue &#123;<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(m_numerator) / m_denominator; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Fraction frac; <span class="comment">//由于没有实参，所以会默认调用Fraction()</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; frac.getNumerator() &lt;&lt; <span class="string">"/"</span> &lt;&lt; frac.getDenominator() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">0</span>/<span class="number">1</span></span><br></pre></td></tr></table></figure><p>上面例子中，因为我们正在实例化一个没有参数的Fraction类型的对象，所以在为该对象分配内存之后，将立即调用默认构造函数，并初始化我们的对象。</p><blockquote><p>注意，我们的numerator和denominator是用默认构造函数中设置的值初始化的! 如果没有默认的构造函数，numerator和denominator就会有垃圾值，直到我们显式地为它们分配合理的值，或者通过其他方法初始化它们(记住: 默认情况下不会初始化基本变量)。</p></blockquote><hr><h1 id="接收参数的构造函数"><a href="#接收参数的构造函数" class="headerlink" title="接收参数的构造函数"></a>接收参数的构造函数</h1><p>虽然默认构造函数对于确保用合理的默认值初始化类非常有用。</p><p><u>但通常我们希望类的实例具有我们提供的特定值</u>。幸运的是，<u>还可以用参数声明构造函数。</u>下面是一个构造函数的例子，它使用两个整数参数来初始化分子和分母:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_numerator;</span><br><span class="line"><span class="keyword">int</span> m_denominator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Fraction() <span class="comment">// default constructor</span></span><br><span class="line">&#123;</span><br><span class="line">m_numerator = <span class="number">0</span>;</span><br><span class="line">m_denominator = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带有两个形参的构造函数，其中一个形参有默认的值⭐</span></span><br><span class="line">Fraction(<span class="keyword">int</span> numerator, <span class="keyword">int</span> denominator = <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">assert(denominator != <span class="number">0</span>);</span><br><span class="line">m_numerator = numerator;</span><br><span class="line">m_denominator = denominator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNumerator</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_numerator; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDenominator</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_denominator; &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(m_numerator) / m_denominator; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意，我们现在有<strong>两个构造函数</strong>:</p><ul><li>一个是默认情况下调用的默认构造函数，</li><li>另一个是接受两个参数的构造函数。</li></ul><p>由于<u>函数重载</u>，这两个构造函数可以在同一个类中和平共处。实际上，只要每个构造函数都有唯一的签名 (参数的数量和类型)， 就可以定义任意数量的构造函数。</p><h2 id="如何使用带有参数的构造函数"><a href="#如何使用带有参数的构造函数" class="headerlink" title="如何使用带有参数的构造函数"></a>如何使用带有参数的构造函数</h2><p>我们可以直接使用 括号 或 直接初始化:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fraction fiveThirds&#123; <span class="number">5</span>, <span class="number">3</span> &#125;; <span class="comment">// 使用大括号 initialization, calls Fraction(int, int)【推荐⭐】</span></span><br><span class="line"><span class="function">Fraction <span class="title">threeQuarters</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>; <span class="comment">// 直接初始化, also calls Fraction(int, int)</span></span><br></pre></td></tr></table></figure><p>注意，<strong>我们给了构造函数的第二个参数一个默认值</strong>，<u>所以下面的操作也是合法</u>的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fraction six&#123; <span class="number">6</span> &#125;; <span class="comment">// calls Fraction(int, int) constructor, 第二个参数使用默认值</span></span><br></pre></td></tr></table></figure><hr><h1 id="在类中使用“-”来复制初始化（C-11之前）"><a href="#在类中使用“-”来复制初始化（C-11之前）" class="headerlink" title="在类中使用“=”来复制初始化（C++11之前）"></a>在类中使用“=”来复制初始化（C++11之前）</h1><p>本节只在您使用<strong>比c++ 11更老的标准</strong>时才有意义。</p><p>与基本变量非常相似，也可以使用复制初始化来初始化类:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fraction six = Fraction&#123; <span class="number">6</span> &#125;; <span class="comment">// Copy initialize a Fraction, will call Fraction(6, 1)</span></span><br><span class="line">Fraction seven = <span class="number">7</span>; <span class="comment">//复制初始化一个Fraction。编译器将尝试找到一种方法将7转换成Fraction，这将调用分数(7,1)构造函数。</span></span><br></pre></td></tr></table></figure><blockquote><p>但是，我们建议您<strong>避免对类进行这种形式的初始化</strong>，因为它的效率可能比较低。虽然直接初始化、统一初始化和复制初始化与基本类型的工作方式相同，但是复制初始化与类的工作方式不同(尽管最终结果通常相同)。我们将在以后的章节中更详细地探讨这些差异</p></blockquote><h1 id="减少构造函数的个数"><a href="#减少构造函数的个数" class="headerlink" title="减少构造函数的个数"></a>减少构造函数的个数</h1><p>在上面的Fraction类的 <u>双</u>构造函数 声明中，默认构造函数实际上有些多余。我们可以将这个类简化如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_numerator;</span><br><span class="line">    <span class="keyword">int</span> m_denominator;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Default constructor</span></span><br><span class="line">    Fraction(<span class="keyword">int</span> numerator=<span class="number">0</span>, <span class="keyword">int</span> denominator=<span class="number">1</span>) <span class="comment">//⭐</span></span><br><span class="line">    &#123;</span><br><span class="line">        assert(denominator != <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">        m_numerator = numerator;</span><br><span class="line">        m_denominator = denominator;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumerator</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_numerator; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDenominator</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_denominator; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(m_numerator) / m_denominator; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>尽管这个构造函数仍然是一个默认的构造函数，但是现在它已经被定义为可以接受 一个 或 两个 用户提供的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Fraction zero; <span class="comment">// will call Fraction(0, 1)</span></span><br><span class="line">Fraction zero&#123;&#125;; <span class="comment">// will call Fraction(0, 1)</span></span><br><span class="line">Fraction six&#123; <span class="number">6</span> &#125;; <span class="comment">// will call Fraction(6, 1)</span></span><br><span class="line">Fraction fiveThirds&#123; <span class="number">5</span>, <span class="number">3</span> &#125;; <span class="comment">// will call Fraction(5, 3)</span></span><br></pre></td></tr></table></figure><h1 id="隐式生成的默认构造函数"><a href="#隐式生成的默认构造函数" class="headerlink" title="隐式生成的默认构造函数"></a>隐式生成的默认构造函数</h1><p><strong>如果你的类没有构造函数，c++会自动为你生成一个public的默认构造函数。</strong>这有时被称为<u>隐式构造函数(或隐式生成的构造函数)</u>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_year;</span><br><span class="line">    <span class="keyword">int</span> m_month;</span><br><span class="line">    <span class="keyword">int</span> m_day;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用户没有提供构造函数，编译器将会生成一个默认的构造函数（即，不带参数的构造函数）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个特殊的隐式构造函数允许我们创建一个没有参数的Date对象，但是不初始化任何成员(因为所有的成员都是基本类型，它们在创建时不会初始化)。</p><blockquote><p>如果Date有自己是类类型的成员，例如std::string，那么这些成员的构造函数将被自动调用。</p></blockquote><p>看一个例子：（为了确保成员变量得到初始化，我们可以在它们的声明中初始化它们。）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_year&#123; <span class="number">1900</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> m_month&#123; <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> m_day&#123; <span class="number">1</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>虽然你看不到隐式生成的构造函数，但你可以证明它的存在:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_year&#123; <span class="number">1900</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> m_month&#123; <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> m_day&#123; <span class="number">1</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// No constructor provided, so C++ creates a public default constructor for us</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Date date&#123;&#125;; <span class="comment">// calls implicit constructor⭐</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="当类中有任何显式构造函数，则不会提供隐式构造函数"><a href="#当类中有任何显式构造函数，则不会提供隐式构造函数" class="headerlink" title="当类中有任何显式构造函数，则不会提供隐式构造函数"></a>当类中有任何显式构造函数，则不会提供隐式构造函数</h2><p>如果您的类有任何其他构造函数，则不会提供隐式生成的构造函数。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_year&#123; <span class="number">1900</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> m_month&#123; <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> m_day&#123; <span class="number">1</span> &#125;;  </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    Date(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day) <span class="comment">// normal non-default constructor</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_year = year;</span><br><span class="line">        m_month = month;</span><br><span class="line">        m_day = day;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">//由于上面已经有了一个显式的构造函数，所以就不会再提供隐式的构造函数了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Date date&#123;&#125;; <span class="comment">//错误:不能实例化对象，因为默认构造函数不存在，编译器也不会再生成默认构造函数（因为有显式的构造函数）</span></span><br><span class="line">    </span><br><span class="line">    Date today&#123; <span class="number">2020</span>, <span class="number">1</span>, <span class="number">19</span> &#125;; <span class="comment">// today is initialized to Jan 19th, 2020</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="显式的添加默认构造函数"><a href="#显式的添加默认构造函数" class="headerlink" title="显式的添加默认构造函数"></a>显式的添加默认构造函数</h1><p>要允许构造一个<strong>没有参数</strong>的<code>Date</code>，可以：</p><ul><li>向构造函数添加默认参数，</li><li>添加一个空的默认构造函数，</li><li>或者<strong>显式地添加一个默认构造函数。</strong>【推荐⭐】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_year&#123; <span class="number">1900</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> m_month&#123; <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> m_day&#123; <span class="number">1</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//告诉编译器创建一个默认构造函数，即使还有用户提供其他的构造函数。</span></span><br><span class="line">    Date() = <span class="keyword">default</span>; <span class="comment">//注意这个default⭐</span></span><br><span class="line"> </span><br><span class="line">    Date(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day) <span class="comment">// normal non-default constructor</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_year = year;</span><br><span class="line">        m_month = month;</span><br><span class="line">        m_day = day;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Date date&#123;&#125;; <span class="comment">// date is initialized to Jan 1st, 1900</span></span><br><span class="line">    Date today&#123; <span class="number">2020</span>, <span class="number">10</span>, <span class="number">14</span> &#125;; <span class="comment">// today is initialized to Oct 14th, 2020</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>使用<code>= default</code></strong>与添加一个空主体的默认构造函数几乎是一样的。唯一的区别是<code>= default</code>允许我们安全地初始化成员变量，即使它们没有初始化器:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Date() = <span class="keyword">default</span>; <span class="comment">//显示的默认构造函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// note: 成员声明中没有初始化</span></span><br><span class="line"><span class="keyword">int</span> m_year;</span><br><span class="line"><span class="keyword">int</span> m_month;</span><br><span class="line"><span class="keyword">int</span> m_day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//用户提供的空的构造函数</span></span><br><span class="line">Date2();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// note: 成员声明中没有初始化</span></span><br><span class="line"><span class="keyword">int</span> m_year;</span><br><span class="line"><span class="keyword">int</span> m_month;</span><br><span class="line"><span class="keyword">int</span> m_day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Date today&#123;&#125;; <span class="comment">//将会是：0, 0, 0 ⭐</span></span><br><span class="line">Date2 tommorrow&#123;&#125;; <span class="comment">//tommorrow 的成员没有初始化⭐</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="类包含类"><a href="#类包含类" class="headerlink" title="类包含类"></a>类包含类</h1><p>一个类可以包含其他类作为成员变量。默认情况下，在构造外部类时，成员变量将调用它们的默认构造函数。这发生在构造函数体执行之前。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A m_a; <span class="comment">// B contains A as a member variable</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure><p>在构造变量b时，调用b()构造函数。在执行构造函数体<strong>之前</strong>，<code>m_a</code>被初始化 (它需要调用class A的构造函数来初始化)，这个打印“A”。然后，返回到B构造函数，并执行B构造函数的主体。</p><blockquote><p>当你考虑它时，这是有意义的，<strong>因为B()构造函数可能想要使用变量m_a——所以m_a最好先初始化!</strong></p></blockquote><h2 id="类类型-class-type-的成员会被初始化"><a href="#类类型-class-type-的成员会被初始化" class="headerlink" title="类类型(class-type)的成员会被初始化"></a>类类型(class-type)的成员会被初始化</h2><p>与前一节中最后一个示例的不同之处在于<code>m_a</code>是一个<strong>类类型</strong>。<strong>即使我们没有显式地初始化类类型成员，它们也会被初始化。</strong></p><h1 id="构造函数重点"><a href="#构造函数重点" class="headerlink" title="构造函数重点"></a>构造函数重点</h1><ul><li><p>许多新程序员对<strong>构造函数是否创建对象</strong>感到困惑。它们不是——<strong>编译器在构造函数调用<u>之前</u>为对象设置内存分配。</strong></p></li><li><p>构造函数实际上有两个用途。</p><ul><li>首先，构造函数决定谁可以创建对象。也就是说<strong>，只有在找到匹配的构造函数时才能创建类的对象。</strong></li><li>其次，构造函数可以用来初始化对象。构造函数是否进行初始化取决于程序员。从语法上来说，构造函数完全不进行初始化是有效的(构造函数的作用仍然是允许创建对象，如上所述)。</li></ul></li><li><p>最后，<strong>构造函数只在创建对象时用于初始化</strong>。您<strong>不应该</strong>尝试<strong>调用构造函数来重新初始化现有对象</strong>。虽然它可以编译，但结果不是您想要的(相反，编译器将创建一个临时对象，然后丢弃它)。</p></li></ul><hr><h1 id="————————————–"><a href="#————————————–" class="headerlink" title="————————————–"></a>————————————–</h1><h1 id="构造函数的成员初始化器列表"><a href="#构造函数的成员初始化器列表" class="headerlink" title="构造函数的成员初始化器列表"></a>构造函数的成员初始化器列表</h1><p>原文：<a href="https://www.learncpp.com/cpp-tutorial/8-5a-constructor-member-initializer-lists/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/8-5a-constructor-member-initializer-lists/</a></p><hr><p>c++提供了一种通过<strong>成员初始化列表</strong>(通常称为“成员初始化列表”)来初始化类成员变量的方法 (而不是在它们创建之后给它们赋值)。</p><blockquote><p>不要将它们与我们可以用来为数组赋值的类似命名的初始化器列表混淆。</p><hr><p>在 <a href="https://www.learncpp.com/cpp-tutorial/variable-assignment-and-initialization/" target="_blank" rel="noopener">1.4 – Variable assignment and initialization</a>中，您了解了可以通过三种方式初始化变量:</p><ul><li>复制；</li><li>直接；</li><li>和统一初始化。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = <span class="number">1</span>; <span class="comment">//拷贝初始化</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">value2</span> <span class="params">(<span class="number">2.2</span>)</span></span>; <span class="comment">//直接吃石化</span></span><br><span class="line"><span class="keyword">char</span> value3 &#123;<span class="string">'c'</span>&#125;;  <span class="comment">//统一初始化</span></span><br></pre></td></tr></table></figure><p>在类中使用初始化列表 几乎与<strong>直接初始化</strong>或<strong>统一初始化</strong>相同。</p></blockquote><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.我们之前是这样写的：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_value1;</span><br><span class="line"><span class="keyword">double</span> m_value2;</span><br><span class="line"><span class="keyword">char</span> m_value3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Something()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 这些都是赋值，不是初始化</span></span><br><span class="line">m_value1 = <span class="number">1</span>;</span><br><span class="line">m_value2 = <span class="number">2.2</span>;</span><br><span class="line">m_value3 = <span class="string">'c'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"><span class="comment">//2.现在来改进（使用初始化列表）：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_value1;</span><br><span class="line"><span class="keyword">double</span> m_value2;</span><br><span class="line"><span class="keyword">char</span> m_value3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Something() : m_value1&#123; <span class="number">1</span> &#125;, m_value2&#123; <span class="number">2</span> &#125;, m_value3&#123; <span class="string">'c'</span> &#125;<span class="comment">//⭐</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 这里就不再需要赋值了</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>成员初始化器列表被插入到构造函数参数之后。<strong>它以冒号(:)开头</strong>，<strong>然后列出要初始化的每个变量以及该变量的值</strong>，<strong>中间用逗号分隔</strong>，<u>最后没有分号</u>。⭐</p><hr><p>注意，我们不再需要在构造函数体中执行赋值，因为初始化器列表将替换该功能。还要注意，初始化器列表不是以分号结束的。</p><h2 id="当用户传入初始值时"><a href="#当用户传入初始值时" class="headerlink" title="当用户传入初始值时"></a>当用户传入初始值时</h2><p>当然，当我们允许调用者传入初始值时，构造函数更有用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value1;</span><br><span class="line">    <span class="keyword">double</span> m_value2;</span><br><span class="line">    <span class="keyword">char</span> m_value3;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Something(<span class="keyword">int</span> value1, <span class="keyword">double</span> value2, <span class="keyword">char</span> value3=<span class="string">'c'</span>)</span><br><span class="line">        : m_value1&#123; value1 &#125;, m_value2&#123; value2 &#125;, m_value3&#123; value3 &#125; <span class="comment">//⭐ directly initialize our member variables</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// No need for assignment here</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Something("</span> &lt;&lt; m_value1 &lt;&lt; <span class="string">", "</span> &lt;&lt; m_value2 &lt;&lt; <span class="string">", "</span> &lt;&lt; m_value3 &lt;&lt; <span class="string">")\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Something something&#123; <span class="number">1</span>, <span class="number">2.2</span> &#125;; <span class="comment">// value1 = 1, value2=2.2, value3 gets default value 'c'</span></span><br><span class="line">    something.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Something(<span class="number">1</span>, <span class="number">2.2</span>, c)</span><br></pre></td></tr></table></figure><p>注意，<strong>您可以使用默认参数来提供一个默认值，以防用户没有传入一个值。</strong></p><h2 id="初始化const变量"><a href="#初始化const变量" class="headerlink" title="初始化const变量"></a>初始化const变量</h2><p>面是一个拥有const成员变量的类的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m_value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    something() : m_value&#123;<span class="number">5</span>&#125; <span class="comment">//✔。直接初始化我们的const成员变量</span></span><br><span class="line">    &#123;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是可行的，因为我们<strong>可以初始化const变量 (但不能赋值给它们!)</strong></p><h2 id="使用成员初始化器列表初始化数组成员"><a href="#使用成员初始化器列表初始化数组成员" class="headerlink" title="使用成员初始化器列表初始化数组成员"></a>使用成员初始化器列表初始化数组成员</h2><p>一个有数组成员的类:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m_array[<span class="number">5</span>];</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>在C++ 11之前</strong>，你只能通过一个成员初始化列表使一个数组成员 <strong>归零:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m_array[<span class="number">5</span>];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    something() : m_array&#123;&#125;</span><br><span class="line">    &#123;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从C++11开始，你可以完全初始化一个成员数组 使用统一初始化:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m_array[<span class="number">5</span>];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    something() : m_array&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; <span class="comment">//使用统一初始化来初始化我们的成员数组</span></span><br><span class="line">    &#123;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="初始化在其他类中定义的成员变量"><a href="#初始化在其他类中定义的成员变量" class="headerlink" title="初始化在其他类中定义的成员变量"></a>初始化在其他类中定义的成员变量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> x) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"A "</span>&lt;&lt;x&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A m_a;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    B(<span class="keyword">int</span> y) : m_a &#123;y<span class="number">-1</span>&#125;  <span class="comment">//调用 A(int)构造函数 初始化成员m_a</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b&#123;<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">A <span class="number">4</span></span><br><span class="line">B <span class="number">5</span></span><br></pre></td></tr></table></figure><p>构造变量b时，使用值5调用 b(int)构造函数。在该构造函数体执行之前，m_a先被初始化 用值4调用A(int)构造函数，即打印“A 4”。<em>：</em>然后，将结果返回到B构造函数，并执行B构造函数的主体，打印“B 5”。</p><h2 id="格式化初始化器列表"><a href="#格式化初始化器列表" class="headerlink" title="格式化初始化器列表"></a>格式化初始化器列表</h2><p>在如何格式化初始化器列表方面，c++提供了很大的灵活性，这实际上取决于您想如何继续。但这里有一些建议:</p><ul><li><p>如果初始化器列表和函数名在同一行，那么把所有东西都放在一行就可以了:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value1;</span><br><span class="line">    <span class="keyword">double</span> m_value2;</span><br><span class="line">    <span class="keyword">char</span> m_value3;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    something() : m_value1&#123; <span class="number">1</span> &#125;, m_value2&#123; <span class="number">2.2</span> &#125;, m_value3&#123; <span class="string">'c'</span> &#125; <span class="comment">// everything on one line</span></span><br><span class="line">    &#123;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>如果初始化器列表与函数名不在同一行，那么在下一行应该是缩进的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value1;</span><br><span class="line">    <span class="keyword">double</span> m_value2;</span><br><span class="line">    <span class="keyword">char</span> m_value3;    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    something(<span class="keyword">int</span> value1, <span class="keyword">double</span> value2, <span class="keyword">char</span> value3=<span class="string">'c'</span>) <span class="comment">//这一行上已经有很多东西了</span></span><br><span class="line">        : m_value1&#123; value1 &#125;, m_value2&#123; value2 &#125;, m_value3&#123; value3 &#125;  <span class="comment">//所以，我们可以把剩下的内容缩进到下一行</span></span><br><span class="line">    &#123;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>如果所有的初始值设定项都不在一行中(或者初始值设定项不是普通的)，那么你可以把它们隔开，每行一个:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value1;</span><br><span class="line">    <span class="keyword">double</span> m_value2;</span><br><span class="line">    <span class="keyword">char</span> m_value3;</span><br><span class="line">    <span class="keyword">float</span> m_value4;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    something(<span class="keyword">int</span> value1, <span class="keyword">double</span> value2, <span class="keyword">char</span> value3=<span class="string">'c'</span>, <span class="keyword">float</span> value4=<span class="number">34.6f</span>)  <span class="comment">//这一行上已经有很多东西了</span></span><br><span class="line">        : m_value1&#123; value1 &#125;, <span class="comment">//一行一个，每行末尾有一个逗号</span></span><br><span class="line">        m_value2&#123; value2 &#125;,</span><br><span class="line">        m_value3&#123; value3 &#125;,</span><br><span class="line">        m_value4&#123; value4 &#125; </span><br><span class="line">    &#123;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="初始化器列表顺序"><a href="#初始化器列表顺序" class="headerlink" title="初始化器列表顺序"></a>初始化器列表顺序</h2></li></ul><p>可能令人惊讶的是，初始化器列表中的变量 <u>没有</u> 按照初始化程序列表中指定的顺序初始化。相反，它们是按照在类中声明它们的顺序初始化的。</p><p>为取得最佳效果，应遵循以下建议:</p><ul><li>不要以这样的方式初始化成员变量，即它们依赖于首先初始化的其他成员变量 (换句话说，确保您的成员变量将正确初始化，即使初始化顺序不同)。</li><li>在初始化器列表中以与在类中声明变量相同的顺序初始化变量。只要遵循前面的建议，这并不是严格要求的，但是如果您不这样做，并且打开了所有警告（自己对警告级别的设置），那么编译器可能会给您一个警告。</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>成员初始化器列表允许我们初始化成员，而不是给它们赋值。</strong></p><p>这是初始化那些在初始化时需要值的成员 (如const或引用成员) 的<strong>唯一方法</strong>，</p><p>而且它比在构造函数体中赋值更有性能。<strong>成员初始化器列表既适用于基本类型，也适用于本身就是类的成员。</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/访问函数及封装</title>
      <link href="/archives/1459e5c7.html"/>
      <url>/archives/1459e5c7.html</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要将成员变量设为私有"><a href="#为什么要将成员变量设为私有" class="headerlink" title="为什么要将成员变量设为私有?"></a>为什么要将成员变量设为私有?</h1><p>在前一课中，我们提到类成员变量通常是私有的。学习面向对象编程的开发人员通常很难理解为什么要这样做。为了回答这个问题，让我们从一个类比开始。</p><p>在现代生活中，我们可以使用许多电子设备。你的电视有一个遥控器，你可以用它来开/关电视。你开车(或踏板车)去上班。你用智能手机拍照。这三样东西都使用一个常见的模式: 它们提供了一个简单的界面供您使用(按钮、方向盘等)来执行操作。</p><p>然而，这些设备实际上是如何操作的对你来说是隐藏的。当你按下遥控器上的按钮时，你不需要知道它在做什么来和你的电视交流。当你踩下汽车的油门踏板时，你不需要知道内燃机是如何使车轮转动的。当你拍照时，你不需要知道传感器如何将光线收集到像素化的图像中。</p><p><strong>这种接口和实现的分离非常有用，因为它允许我们在不了解对象如何工作的情况下使用对象。这极大地降低了使用这些对象的复杂性，并增加了我们能够与之交互的对象的数量。</strong></p><p>出于类似的原因，<strong>实现 和 接口的分离 在编程中也很有用。</strong></p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>在面向对象编程中，<strong>封装(也称为信息隐藏)</strong>是这样一个过程：</p><p>它将对象实现的细节隐藏起来，不让对象的用户看到。相反，对象的用户通过公共接口访问对象。通过这种方式，用户可以使用对象，而不必了解它是如何实现的。</p><p><strong>在c++中，我们通过访问说明符来实现封装。</strong>通常，<strong>类的所有成员变量都是私有的(隐藏实现细节)</strong>，<strong>而大多数成员函数是公共的(为用户公开接口)。</strong>虽然要求类的用户使用公共接口似乎比直接提供对成员变量的公共访问更麻烦，但这样做实际上提供了大量有用的好处，有助于鼓励类的可重用性和可维护性。</p><blockquote><p>注意:“封装”一词有时也用来指将数据和处理该数据的函数打包在一起。我们更倾向于称之为面向对象编程。</p></blockquote><h2 id="封装的好处"><a href="#封装的好处" class="headerlink" title="封装的好处"></a>封装的好处</h2><ul><li>封装类更容易使用，并降低了程序的复杂性</li><li>封装类有助于保护您的数据和防止误用</li><li>封装类更容易调试</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/匿名函数</title>
      <link href="/archives/5ded0966.html"/>
      <url>/archives/5ded0966.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/introduction-to-lambdas-anonymous-functions/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/introduction-to-lambdas-anonymous-functions/</a></p><p><strong>匿名函数：lambdas（anonymous functions）</strong></p><hr><p>考虑一下我们在之前课程中介绍的这段代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">containsNut</span><span class="params">(<span class="built_in">std</span>::string_view str)</span> <span class="comment">// static 是指在这个上下文中的内部链接</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// std::string_view::find returns std::string_view::npos if it doesn't find</span></span><br><span class="line">  <span class="comment">// the substring. Otherwise it returns the index where the substring occurs</span></span><br><span class="line">  <span class="comment">// in str.</span></span><br><span class="line">  <span class="keyword">return</span> (str.<span class="built_in">find</span>(<span class="string">"nut"</span>) != <span class="built_in">std</span>::string_view::npos);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::string_view, 4&gt; arr&#123; <span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"walnut"</span>, <span class="string">"lemon"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// std::find_if takes a pointer to a function</span></span><br><span class="line">  <span class="keyword">auto</span> found&#123; <span class="built_in">std</span>::find_if(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), containsNut) &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (found == arr.<span class="built_in">end</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"No nuts\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Found "</span> &lt;&lt; *found &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Found walnut</span><br></pre></td></tr></table></figure><p>其实这个可以被改进：</p><p>这里问题的根源是<code>std::find_if</code>要求我们给它传递一个函数指针。</p><h1 id="函数不能嵌套"><a href="#函数不能嵌套" class="headerlink" title="函数不能嵌套"></a>函数不能嵌套</h1><p>因此，我们必须定义一个<strong>只会使用一次的函数</strong>，它必须有一个名称，并且必须放在全局范围内(<strong>因为函数不能嵌套</strong>!)这个函数也很短，从一行代码就比从名称和注释更容易看出它的功能。</p><h1 id="使用匿名函数"><a href="#使用匿名函数" class="headerlink" title="使用匿名函数"></a>使用匿名函数</h1><p><strong>匿名函数表达式 (也称为lambda 或 closure ) 允许我们在另一个函数中定义匿名函数。</strong> <strong>嵌套</strong>很重要，因为它允许我们避免命名空间命名污染，并尽可能在使用它的地方定义函数(提供额外的上下文)。</p><p>lambdas的语法是c++中比较奇怪的东西之一，需要一点时间来适应<strong>。Lambdas的形式是</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[ captureClause ] ( parameters ) -&gt; returnType</span><br><span class="line">&#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不需要"captureClause"句和"parameters"，则它们都可以为空。</span></span><br><span class="line"><span class="comment">//"return type"是可选的。如果省略它，将使用auto(即，使用类型推断来确定返回类型)。</span></span><br><span class="line"><span class="comment">//虽然我们前面已经注意到，应该避免对函数返回类型进行类型推断，但是在这个上下文中，使用这种类型推断是可以的(因为这些函数通常都是非常琐碎的)。</span></span><br></pre></td></tr></table></figure><p>还要注意，<strong>lambdas没有名称</strong>，所以我们不需要提供名称。</p><p>这意味着一个普通的lambda定义是这样的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  []() &#123;&#125;; <span class="comment">// defines a lambda with no captures, no parameters, and no return type</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>重新写上面的那段代码（使用匿名函数）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::string_view, 4&gt; arr&#123; <span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"walnut"</span>, <span class="string">"lemon"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Define the function right where we use it.</span></span><br><span class="line">  <span class="keyword">auto</span> found&#123; <span class="built_in">std</span>::find_if(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(),</span><br><span class="line">                           [](<span class="built_in">std</span>::string_view str) <span class="comment">// here's our lambda, no capture clause⭐</span></span><br><span class="line">                           &#123;</span><br><span class="line">                             <span class="keyword">return</span> (str.<span class="built_in">find</span>(<span class="string">"nut"</span>) != <span class="built_in">std</span>::string_view::npos);</span><br><span class="line">                           &#125;) &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (found == arr.<span class="built_in">end</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"No nuts\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Found "</span> &lt;&lt; *found &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就像函数指针的情况，并产生一个相同的结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Found walnut</span><br></pre></td></tr></table></figure><hr><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>注意我们的 匿名函数 与我们的 <code>containsNut</code>函数 是多么的相似：</p><p>它们都具有相同的参数和函数体。lambda没有captureClause（捕获子句）(我们将在下一课中解释捕获子句是什么)，因为它不需要捕获子句。我们在lambda中省略了末尾的返回类型(为了简洁)，但是因为是操作符 != 返回一个bool，我们的lambda也将返回一个bool。</p><h1 id="匿名函数的类型"><a href="#匿名函数的类型" class="headerlink" title="匿名函数的类型"></a>匿名函数的类型</h1><p>在上面的例子中，我们在需要的地方定义了一个lambda。这种对lambda的使用有时被称为<strong>函数文字（function literal）</strong>。</p><p>但是上面的例子中的匿名函数的可读性很差。</p><p>就像我们可以用一个文字值(或函数指针)初始化一个变量以供以后使用一样，<strong>我们也可以用一个lambda定义初始化一个lambda变量，然后再使用它。</strong></p><p>比如：（在下面的代码段中，我们使用<code>std::all_of</code>来检查数组中的所有元素是否为偶数:）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们必须读lambda来理解发生了什么。(Bad)</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::all_of (<span class="built_in">array</span>.<span class="built_in">begin</span>(), <span class="built_in">array</span>.<span class="built_in">end</span>(), [] (<span class="keyword">int</span> i) &#123;<span class="keyword">return</span> ((i%<span class="number">2</span>) == <span class="number">0</span>);&#125;);</span><br></pre></td></tr></table></figure><p>我们可以改善可读性的这个如下:[推荐⭐]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相反，我们可以将lambda存储在指定的变量中，并将其传递给函数。</span></span><br><span class="line"><span class="keyword">auto</span> isEven&#123;</span><br><span class="line">    [] (<span class="keyword">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ((i%<span class="number">2</span>) == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::ll_of(<span class="built_in">array</span>.<span class="built_in">begin</span>(), <span class="built_in">array</span>.<span class="built_in">end</span>(), isEven);</span><br><span class="line"><span class="comment">//注意最后一行读起来有多好:“返回数组中的所有元素是否为偶数”</span></span><br></pre></td></tr></table></figure><h2 id="匿名函数的类型到底是什么？"><a href="#匿名函数的类型到底是什么？" class="headerlink" title="匿名函数的类型到底是什么？"></a>匿名函数的类型到底是什么？</h2><p>但是上面的匿名函数<code>isEven</code>到底是什么呢？</p><p>答：</p><p>事实证明，<strong>lambdas没有一个我们可以明确使用的类型。当我们写一个lambda时，编译器会生成一个唯一的类型，但是不暴露给我们。</strong></p><hr><p><strong>虽然我们不知道lambda的类型，但是有几种方法可以存储用于post-definition（后定义？？？）的lambda</strong>。<u>如果lambda有一个空的捕获子句</u>，我们可以使用下面三种方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//⭐1：一个常规的函数指针。只对 空捕获句子(capture clause) 有效。</span></span><br><span class="line">    <span class="keyword">double</span> (*addNumbers1) (doubel, <span class="keyword">double</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        [] (<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (a+b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    addNumbers1(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//⭐2： Using std::function。也可适用于匿名函数的capture clause非空的情况(下一课会讲)。</span></span><br><span class="line">    <span class="built_in">std</span>::function addNumbers2 <span class="comment">//注意：在C++17之前，应该这样写：std::function&lt;double(double, double)&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        [] (<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="keyword">return</span> (a+b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    addNumbers2(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//⭐3：使用auto。存储lambda的实际类型。</span></span><br><span class="line">    <span class="keyword">auto</span> addNumbers3</span><br><span class="line">    &#123;</span><br><span class="line">        [] (<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (a+b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    addNumbers3(<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用lambda实际类型的惟一方法是使用auto</strong>。<strong>auto还具有</strong><u>与std::function 相比</u><strong>没有开销的优点。</strong></p><h2 id="适用std-function而不适用auto的情况"><a href="#适用std-function而不适用auto的情况" class="headerlink" title="适用std::function而不适用auto的情况"></a>适用<code>std::function</code>而不适用<code>auto</code>的情况</h2><p>不幸的是，我们不能总是使用auto。</p><p><strong>在实际的lambda未知的情况下</strong>(例如，因为我们将lambda作为参数传递给一个函数，调用者决定将传递什么lambda)，我们不能使用auto。在这种情况下，应该使用std::function。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#incldue <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们不知道fn会是什么。std::function与常规函数和lambdas一起工作。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">repeat</span><span class="params">(<span class="keyword">int</span> repetitions, <span class="keyword">const</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt;&amp; fn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i&#123; <span class="number">0</span> &#125;; i &lt; repetitions; ++i )</span><br><span class="line">        fn(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    repeat(<span class="number">3</span>, [] (<span class="keyword">int</span> i) &#123;<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">'\n'</span>;&#125; );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><hr><h1 id="匿名函数其实不是真正的函数"><a href="#匿名函数其实不是真正的函数" class="headerlink" title="匿名函数其实不是真正的函数"></a>匿名函数其实不是真正的函数</h1><p>实际上，<strong>lambdas不是函数</strong></p><blockquote><p><strong>(这也是它们为什么在“函数不能嵌套”的规定下，可以使用的原因)。</strong></p></blockquote><p>它们是一种特殊的物体，叫做<strong>函子(functor)</strong>。<strong>函子是包含重载运算符() 的对象，使其可以像函数一样调用。</strong></p><hr><h1 id="泛型的匿名函数（generic-lambdas）"><a href="#泛型的匿名函数（generic-lambdas）" class="headerlink" title="泛型的匿名函数（generic lambdas）"></a>泛型的匿名函数（generic lambdas）</h1><p>在大多数情况下，lambda参数的工作原理与常规函数参数相同。</p><p>一个值得注意的例外是，因为c++ 14允许我们使用auto作为参数（注意:在c++ 20中，常规函数也可以使用auto作为参数）。</p><p><strong>当一个lambda有一个或多个<u>auto参数</u>时，编译器将从对lambda的调用中推断出需要哪些参数类型。</strong></p><hr><p>因为具有一个或多个auto参数的lambdas可以处理各种类型的数据，所以它们被称为<strong>generic lambdas</strong>。</p><p>看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span> months&#123; <span class="comment">//C++17之前，使用：std::array&lt;const char*, 12&gt;</span></span><br><span class="line"><span class="string">"January"</span>,</span><br><span class="line"><span class="string">"February"</span>,</span><br><span class="line"><span class="string">"March"</span>,</span><br><span class="line"><span class="string">"April"</span>,</span><br><span class="line"><span class="string">"May"</span>,</span><br><span class="line"><span class="string">"June"</span>,</span><br><span class="line"><span class="string">"July"</span>,</span><br><span class="line"><span class="string">"August"</span>,</span><br><span class="line"><span class="string">"September"</span>,</span><br><span class="line"><span class="string">"October"</span>,</span><br><span class="line"><span class="string">"November"</span>,</span><br><span class="line"><span class="string">"December"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//搜索以相同字母开头的连续两个月。</span></span><br><span class="line"><span class="keyword">auto</span> samelatter&#123; <span class="built_in">std</span>::adjacent_find(months.<span class="built_in">begin</span>(), months.<span class="built_in">end</span>(),</span><br><span class="line">[](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b)</span><br><span class="line">&#123;<span class="keyword">return</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>]); &#125;</span><br><span class="line">) &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确保找到两个月的时间。</span></span><br><span class="line"><span class="keyword">if</span> (samelatter != months.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//std::next返回sameLetter之后的下一个迭代器</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;*samelatter &lt;&lt; <span class="string">" and "</span> &lt;&lt;*<span class="built_in">std</span>::next(samelatter)</span><br><span class="line">&lt;&lt; <span class="string">" start with the same letter\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">June <span class="keyword">and</span> July start with the same letter</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们使用auto类型的参数通过 const引用 来捕获字符串。</p><blockquote><p>因为<strong>所有的字符串类型都允许通过 操作符[] 访问它们各自的字符</strong>，所以我们不需要关心用户是否传入了<u>std::string</u>、<u>c风格的字符串</u>或<u>其他内容</u>。这允许我们写一个可以接受任何这些的lambda，意味着如果我们在几个月后改变类型，我们就不必重写lambda了。</p></blockquote><p>然而，有些情况auto，不是最好的选择：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span> months&#123; <span class="comment">// pre-C++17 use std::array&lt;const char*, 12&gt;</span></span><br><span class="line">    <span class="string">"January"</span>,</span><br><span class="line">    <span class="string">"February"</span>,</span><br><span class="line">    <span class="string">"March"</span>,</span><br><span class="line">    <span class="string">"April"</span>,</span><br><span class="line">    <span class="string">"May"</span>,</span><br><span class="line">    <span class="string">"June"</span>,</span><br><span class="line">    <span class="string">"July"</span>,</span><br><span class="line">    <span class="string">"August"</span>,</span><br><span class="line">    <span class="string">"September"</span>,</span><br><span class="line">    <span class="string">"October"</span>,</span><br><span class="line">    <span class="string">"November"</span>,</span><br><span class="line">    <span class="string">"December"</span></span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Count how many months consist of 5 letters</span></span><br><span class="line">  <span class="keyword">auto</span> fiveLetterMonths&#123; <span class="built_in">std</span>::count_if(months.<span class="built_in">begin</span>(), months.<span class="built_in">end</span>(),</span><br><span class="line">                                       [](<span class="built_in">std</span>::string_view str) &#123; <span class="comment">//⭐</span></span><br><span class="line">                                         <span class="keyword">return</span> (str.length() == <span class="number">5</span>);</span><br><span class="line">                                       &#125;) &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"There are "</span> &lt;&lt; fiveLetterMonths &lt;&lt; <span class="string">" months with 5 letters\n"</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">There are <span class="number">2</span> months with <span class="number">5</span> letters</span><br></pre></td></tr></table></figure><p>在本例中，使用auto将会推断出const char<em>的类型。*</em>c风格的字符串不容易使用(除了使用运算符[])**。</p><p>在本例中，<strong>我们倾向于显式地将参数定义为std::string_view</strong>，这使我们能够更轻松地处理底层数据(例如，我们可以询问string视图的长度，即使用户传入的是c风格的数组)。</p><h2 id="泛型lambda和静态变量"><a href="#泛型lambda和静态变量" class="headerlink" title="泛型lambda和静态变量"></a>泛型lambda和静态变量</h2><p><strong>需要注意的一件事是，一个独一无二的匿名函数将会(被)auto解析为不同的类型。</strong></p><p>下面的例子展示了一个泛型lambda如何变成两个不同的lambda:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//打印一个值并计算 @print被调用的次数。</span></span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">print</span></span><br><span class="line">    &#123;</span><br><span class="line">        [] (<span class="keyword">auto</span> value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">int</span> callcount &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; callcount++&lt;&lt; <span class="string">": "</span> &lt;&lt; value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"hello"</span>); <span class="comment">// 0: hello</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"world"</span>); <span class="comment">// 1: world</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>); <span class="comment">// 0: 1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>); <span class="comment">// 1: 2</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span> (<span class="string">"ding dong"</span>); <span class="comment">// 2: ding dong</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">0</span>: hello</span><br><span class="line"><span class="number">1</span>: world</span><br><span class="line"><span class="number">0</span>: <span class="number">1</span></span><br><span class="line"><span class="number">1</span>: <span class="number">2</span></span><br><span class="line"><span class="number">2</span>: ding dong</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们定义了一个lambda，然后使用两个不同的参数 (一个字符串文字参数 和 一个整数参数)来调用它。这将生成lambda的两个不同版本 (一个带有字符串文字参数，另一个带有整数参数)。</p><blockquote><p>大多数时候，这是无关紧要的。但是，请注意，<strong>如果泛型lambda使用静态持续时间变量，那么这些变量不会在生成的lambda之间共享。</strong></p></blockquote><p>我们可以在上面的示例中看到这一点，其中每个类型(字符串和整数)都有自己的惟一计数!</p><p>虽然我们只写了一次lambda，但是生成了两个lambda，每个lambda都有自己的callCount版本。<u>为了在两个生成的lambda之间共享一个计数器，我们必须在lambda之外定义一个变量</u>。现在，这意味着即使在函数外部也要定义变量。在上面的例子中，这意味着添加一个全局变量。在下一课中讨论lambda捕获之后，我们将能够避免全局变量。</p><h1 id="返回类型推导和跟踪返回类型"><a href="#返回类型推导和跟踪返回类型" class="headerlink" title="返回类型推导和跟踪返回类型"></a>返回类型推导和跟踪返回类型</h1><p>如果使用返回类型推断，则lambda的返回类型是从lambda内部的<code>return</code>语句中推导出来的。如果使用返回类型推断，lambda中的所有返回语句必须返回相同的类型(否则编译器将不知道选择哪一个)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> divide&#123; [](<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">bool</span> bInteger) &#123; <span class="comment">// 注意:没有指定的返回类型</span></span><br><span class="line">    <span class="keyword">if</span> (bInteger)</span><br><span class="line">      <span class="keyword">return</span> x / y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(x) / y; <span class="comment">// 错误:返回类型与以前的返回类型不匹配</span></span><br><span class="line">  &#125; &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; divide(<span class="number">3</span>, <span class="number">2</span>, <span class="literal">true</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; divide(<span class="number">3</span>, <span class="number">2</span>, <span class="literal">false</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将产生一个编译错误：</p><p>因为第一个返回语句(int)的返回类型 与 第二个返回语句(double)的返回类型不匹配。</p><p>如何解决呢？</p><p>在我们返回不同类型的情况下，我们有两个选项:</p><ol><li><strong>显式强制转换以使所有返回类型匹配；</strong></li><li><strong>显式地为lambda指定返回类型，并让编译器进行隐式转换。【推荐⭐】</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//注意：显式指定此值将返回一个double</span></span><br><span class="line">    <span class="keyword">auto</span> divide &#123;</span><br><span class="line">        [] (<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">bool</span> bInteger) -&gt;<span class="keyword">double</span> <span class="comment">//⭐</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (bInteger)</span><br><span class="line">                <span class="keyword">return</span> x/y; <span class="comment">// 将做一个隐式转换为double</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(x) / y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; divide(<span class="number">3</span>, <span class="number">2</span>, <span class="literal">true</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; divide(<span class="number">3</span>, <span class="number">2</span>, <span class="literal">false</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就像上面一样，如果您决定更改返回类型，<strong>您(通常)只需要更改lambda的返回类型，而不需要触及lambda主体。</strong></p><h1 id="——————————"><a href="#——————————" class="headerlink" title="——————————"></a>——————————</h1><h1 id="Lambda-captures"><a href="#Lambda-captures" class="headerlink" title="Lambda captures"></a>Lambda captures</h1><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/lambda-captures/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/lambda-captures/</a></p><hr><h2 id="Capture-clauses-and-capture-by-value"><a href="#Capture-clauses-and-capture-by-value" class="headerlink" title="Capture clauses and capture by value"></a>Capture clauses and capture by value</h2><p>现在，让我们修改nut示例，让用户选择要搜索的子字符串。这并不像你想象的那么直观。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::string_view, 4&gt; arr&#123; <span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"walnut"</span>, <span class="string">"lemon"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 询问用户要搜索什么。</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"search for: "</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> search&#123;&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; search;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">auto</span> found&#123; <span class="built_in">std</span>::find_if(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [](<span class="built_in">std</span>::string_view str) &#123;</span><br><span class="line">    <span class="comment">// 搜索@search而不是“nut”。</span></span><br><span class="line">    <span class="keyword">return</span> (str.<span class="built_in">find</span>(search) != <span class="built_in">std</span>::string_view::npos); <span class="comment">// 错误:search 在此范围内不可访问</span></span><br><span class="line">  &#125;) &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (found == arr.<span class="built_in">end</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Not found\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Found "</span> &lt;&lt; *found &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码无法编译。</p><p>与嵌套块不同的是，外层块中定义的任何标识符都可以在嵌套块的范围内访问，<strong>而</strong>lambdas只能访问特定类型的标识符:</p><ul><li>全局标识符、</li><li>编译时已知的实体</li><li>具有静态存储持续时间的实体。</li></ul><p>search不满足这些要求，所以lambda看不到它<strong>。这就是capture clause的作用。</strong></p><h2 id="capture-clause"><a href="#capture-clause" class="headerlink" title="capture clause"></a>capture clause</h2><p><strong>capture clause(捕获子句)</strong> 用于(间接地)为lambda提供对周围范围中可用变量（这些变量是它通常无法访问的）的访问，</p><p><strong>我们所需要做的就是在lambda中列出我们想要访问的实体，作为捕获子句的一部分</strong>。在这种情况下，我们想给我们的lambda访问变量search的值，所以我们把它添加到捕获子句:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">26</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">28</span></span><br><span class="line"><span class="number">29</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="number">31</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::string_view, 4&gt; arr&#123; <span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"walnut"</span>, <span class="string">"lemon"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"search for: "</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> search&#123;&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; search;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Capture @search                                vvvvvv⭐</span></span><br><span class="line">  <span class="keyword">auto</span> found&#123; <span class="built_in">std</span>::find_if(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [search](<span class="built_in">std</span>::string_view str) &#123;</span><br><span class="line">    <span class="keyword">return</span> (str.<span class="built_in">find</span>(search) != <span class="built_in">std</span>::string_view::npos);</span><br><span class="line">  &#125;) &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (found == arr.<span class="built_in">end</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Not found\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Found "</span> &lt;&lt; *found &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">search <span class="keyword">for</span>: nana</span><br><span class="line">Found banana</span><br></pre></td></tr></table></figure><h2 id="那么捕捉到底是如何工作的呢"><a href="#那么捕捉到底是如何工作的呢" class="headerlink" title="那么捕捉到底是如何工作的呢?"></a>那么捕捉到底是如何工作的呢?</h2><p>虽然上面例子中的lambda看起来像是直接访问main的搜索变量的值，但实际情况并非如此。<strong>Lambdas的外观和功能可能与嵌套块类似，但它们的工作方式略有不同(</strong>这一点很重要)。</p><p><strong>当执行lambda定义时，对于lambda捕获的每个变量，在lambda中创建该变量的克隆(具有相同的名称)。此时，这些克隆的变量是从同名的外部作用域变量初始化的。</strong></p><p>因此，在上面的例子中，当创建lambda对象时，lambda获得它自己的克隆变量<code>search</code>。这个克隆的<code>search</code>与main的<code>search</code>有相同的值，所以它的行为就像我们访问main的<code>search</code>，但我们没有。</p><blockquote><p>虽然这些克隆的变量具有相同的名称，<strong>但它们不一定具有与原始变量相同的类型</strong>。</p></blockquote><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>虽然lambdas看起来像函数，但它们实际上是可以像函数一样调用的对象(这些被称为<strong>functor</strong>——我们将在以后的课程中讨论如何从头创建自己的functor)。</p><p>当<strong>编译器</strong>遇到一个lambda定义时，它会为该lambda创建一个自定义对象定义。每个捕获的变量都成为该对象的数据成员。</p><p>在<strong>运行时</strong>，当遇到lambda定义时，将<u>实例化lambda对象</u>，并在此时初始化lambda的成员。</p><h2 id="捕获默认的const值"><a href="#捕获默认的const值" class="headerlink" title="捕获默认的const值"></a>捕获默认的const值</h2><p>默认情况下，变量由const值捕获。</p><p><strong>这意味着在创建lambda时，lambda捕获外部作用域变量的常量副本，也就是说不允许lambda修改它们。</strong></p><p>在下面的示例中，我们捕获变量ammo并尝试递减它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ammo&#123;<span class="number">10</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义一个lambda并将其存储在一个名为“shoot”的变量中。</span></span><br><span class="line">    <span class="keyword">auto</span> shoot&#123;</span><br><span class="line">        [ammo]() &#123;</span><br><span class="line">            <span class="comment">//✖，缴获的ammo为const copy。</span></span><br><span class="line">            --ammo;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Pew! "</span> &lt;&lt; ammo &lt;&lt; <span class="string">" shot(s) left.\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用lambda</span></span><br><span class="line">    shoot();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ammo &lt;&lt; <span class="string">" shot(s) left\n"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，当我们捕获ammo时，在lambda中创建了一个具有相同名称和值的新const变量。我们不能修改它，因为它是const，这会导致编译错误。</p><h2 id="捕获可变-mutable-的值"><a href="#捕获可变-mutable-的值" class="headerlink" title="捕获可变(mutable)的值"></a>捕获可变(mutable)的值</h2><p>为了允许对值捕获的变量进行修改，我们可以将lambda<strong>标记为<code>mutable</code>。</strong></p><blockquote><p><strong>关键字<code>mutable</code>会除去 从值捕获的所有变量 的<code>const</code>限定。</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ammo&#123; <span class="number">10</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">auto</span> shoot&#123;</span><br><span class="line">      <span class="comment">//在参数列表之后添加了mutable。</span></span><br><span class="line">      [ammo]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">          <span class="comment">//我们现在可以修改ammo了</span></span><br><span class="line">          --ammo;</span><br><span class="line">           <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Pew! "</span> &lt;&lt; ammo &lt;&lt; <span class="string">" shot(s) left.\n"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  shoot();</span><br><span class="line">  shoot();</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ammo &lt;&lt; <span class="string">" shot(s) left\n"</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Pew! <span class="number">9</span> shot(s) left.</span><br><span class="line">Pew! <span class="number">8</span> shot(s) left.</span><br><span class="line"><span class="number">10</span> shot(s) left  <span class="comment">//真正的ammo的值是没有变的。</span></span><br></pre></td></tr></table></figure><p>虽然现在可以编译，但是还是有逻辑上面的错误，什么错误呢？</p><p>就是：当我们呢调用匿名函数(<code>shoot()</code>)，这个匿名函数捕获一个<code>ammo</code>的副本。当匿名函数对<code>ammo</code>进行递减（由10到9到8），<strong>它递减的是<code>ammo</code>的副本，而不是真正的<code>ammo</code></strong>（如何修改本真的ammo呢？就是利用“引用”来捕获）</p><p>注意：<code>ammo</code>的值在对lambda的调用中保持不变!</p><h2 id="通过“引用”-捕获"><a href="#通过“引用”-捕获" class="headerlink" title="通过“引用” 捕获"></a>通过“引用” 捕获</h2><p>就像函数可以改变通过引用传递的参数的值一样，我们也可以通过<strong>引用</strong>捕获变量<strong>来允许lambda改变参数的值。</strong>(所以，<strong>使用引用捕获，将不再需要<code>mutable</code></strong>)</p><p>为了通过引用捕获变量，我们在捕获的变量名之前加上一个<strong>&amp;</strong>符号。</p><p>与被值捕获的变量不同，<strong>被引用捕获的变量是非const的</strong>，除非它们捕获的变量是const。</p><blockquote><p><strong>当您通常希望通过引用将参数传递给函数时(例如，对于非基本类型)，应该首选通过引用捕获而不是通过值捕获。</strong></p></blockquote><hr><p>这是上面的代码，修改为通过引用来捕获ammo:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ammo</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> shoot&#123;</span><br><span class="line">        <span class="comment">////我们不再需要mutable</span></span><br><span class="line">        [&amp;ammo]() &#123; <span class="comment">// &amp;ammo是指通过引用来捕获ammo</span></span><br><span class="line">            <span class="comment">//这里改变ammo会影响 main's 中的ammo</span></span><br><span class="line">            --ammo;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Pew! "</span> &lt;&lt; ammo &lt;&lt; <span class="string">" shot(s) left.\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  shoot();</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ammo &lt;&lt; <span class="string">" shot(s) left\n"</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Pew! <span class="number">9</span> shot(s) left.</span><br><span class="line"><span class="number">9</span> shot(s) left</span><br></pre></td></tr></table></figure><h2 id="捕获多个变量"><a href="#捕获多个变量" class="headerlink" title="捕获多个变量"></a>捕获多个变量</h2><p>可以通过用<strong>逗号分隔</strong>多个变量来捕获它们。这可以包括由<strong>值</strong>或<strong>引用</strong>捕获的变量组合:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> health&#123; <span class="number">33</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> armor&#123; <span class="number">100</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;CEnemy&gt; enemies&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过值 捕获 health、armor；通过引用捕获enemies</span></span><br><span class="line">[health, armor, &amp;enemies]()&#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="默认捕获"><a href="#默认捕获" class="headerlink" title="默认捕获"></a>默认捕获</h2><p>显式地列出想要捕获的变量可能会很麻烦。如果您修改您的lambda，您可能会忘记添加或删除捕获的变量。</p><p><strong>幸运的是，我们可以利用编译器的帮助来自动生成需要捕获的变量列表</strong>。</p><hr><p><strong>默认捕获</strong>(也称<strong>capture-default</strong>) 捕获lambda中提到的所有变量。<strong>如果使用默认捕获，则不捕获lambda中未提到的变量。</strong></p><ul><li><p>若要按<strong>值</strong>捕获所有使用的变量，请使用<strong>=</strong>的捕获值。</p></li><li><p>若要通过<strong>引用</strong>捕获所有使用的变量，请使用<strong>&amp;</strong>的捕获值。</p></li></ul><p>看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span> areas&#123; <span class="number">100</span>, <span class="number">25</span>, <span class="number">121</span>, <span class="number">40</span>, <span class="number">56</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span>&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter width and height: "</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; <span class="built_in">width</span> &gt;&gt; <span class="built_in">height</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">auto</span> found&#123; <span class="built_in">std</span>::find_if(areas.<span class="built_in">begin</span>(), areas.<span class="built_in">end</span>(),</span><br><span class="line">                           [=](<span class="keyword">int</span> knownArea) &#123; <span class="comment">// will default capture width and height by value</span></span><br><span class="line">                             <span class="keyword">return</span> (<span class="built_in">width</span> * <span class="built_in">height</span> == knownArea); <span class="comment">// because they're mentioned here</span></span><br><span class="line">                           &#125;) &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (found == areas.<span class="built_in">end</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I don't know this area :(\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Area found :)\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认捕获可以与普通捕获混合使用。我们可以通过值捕获一些变量，通过引用捕获另一些变量，但是每个变量只能捕获一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> health&#123; <span class="number">33</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> armor&#123; <span class="number">100</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;CEnemy&gt; enemies&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据值 捕获health和armor，根据引用捕获enemies。</span></span><br><span class="line">[health, armor, &amp;enemies]()&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过引用来捕获enemie，通过值来捕获其他的一切。</span></span><br><span class="line">[=, &amp;enemies]()&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过引用来捕获其他的一切，通过值来捕获armor。</span></span><br><span class="line">[&amp;, armor]()&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*下面是一些非法的*/</span></span><br><span class="line"><span class="comment">//1.我们已经说过，我们想通过引用来捕获所有信息。✖</span></span><br><span class="line">[&amp;, &amp;armor]()&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.我们已经说过，我们希望通过值来捕获一切。✖</span></span><br><span class="line">[=, armor]()&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.armor出现两次。✖</span></span><br><span class="line">[armor, &amp;health, &amp;armor]() &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.默认捕获必须是捕获组中的第一个元素。✖</span></span><br><span class="line">[armor, &amp;]()&#123;&#125;; -----应该是--》[ &amp;, armor]()&#123;&#125;;</span><br></pre></td></tr></table></figure><h1 id="在lambda-capture中定义新变量"><a href="#在lambda-capture中定义新变量" class="headerlink" title="在lambda-capture中定义新变量"></a>在lambda-capture中定义新变量</h1><p>有时，我们希望通过轻微的修改来捕获一个变量，或者声明一个只在lambda作用域内可见的新变量。</p><p>我们可以通过<strong>在lambda-capture中定义一个变量<u>而不指定它的类型</u>来做到这一点。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span> areas&#123; <span class="number">100</span>, <span class="number">25</span>, <span class="number">121</span>, <span class="number">40</span>, <span class="number">56</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span>&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter width and height: "</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; <span class="built_in">width</span> &gt;&gt; <span class="built_in">height</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 我们存储areas，但用户输入宽度和高度。</span></span><br><span class="line">  <span class="comment">// 我们需要先计算出面积，然后才能搜索它。</span></span><br><span class="line">  <span class="keyword">auto</span> found&#123; <span class="built_in">std</span>::find_if(areas.<span class="built_in">begin</span>(), areas.<span class="built_in">end</span>(),</span><br><span class="line">                           <span class="comment">// 声明一个仅对lambda可见的新变量(userarea)</span></span><br><span class="line">                           <span class="comment">// userarea的类型被自动推断为int</span></span><br><span class="line">                           [userArea&#123; <span class="built_in">width</span> * <span class="built_in">height</span> &#125;](<span class="keyword">int</span> knownArea) &#123;</span><br><span class="line">                             <span class="keyword">return</span> (userArea == knownArea);</span><br><span class="line">                           &#125;) &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (found == areas.<span class="built_in">end</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I don't know this area :(\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Area found :)\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当定义了lambda时，<code>userArea</code>只计算一次。计算的区域存储在lambda对象中，对于每个调用都是相同的。如果lambda是可变的，并且修改了在捕获中定义的变量，则原始值将被覆盖。</p><h2 id="空悬的捕获变量"><a href="#空悬的捕获变量" class="headerlink" title="空悬的捕获变量"></a>空悬的捕获变量</h2><p>变量在定义lambda的地方被捕获。如果被引用捕获的变量在lambda之前被销毁，lambda将保留一个悬空引用。</p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个lambda</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">makeWalrus</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 通过引用捕获name并返回lambda。</span></span><br><span class="line">    <span class="keyword">return</span> [&amp;]()&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">"I am a walrus, my name is "</span>&lt;&lt;name &lt;&lt;<span class="string">'\n'</span>; <span class="comment">//未定义行为</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个新的walrus，它的名字叫做Roofus.</span></span><br><span class="line">    <span class="comment">// sayName是makeWalrus返回的lambda。</span></span><br><span class="line">    <span class="keyword">auto</span> sayName &#123;makeWalrus(<span class="string">"Roofus"</span>)&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用makeWalrus返回的 lambda函数。</span></span><br><span class="line">    sayName();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对<code>makeWalrus</code>的调用将从字符串文本“Roofus”创建一个临时<code>std::string</code>。在<code>makeWalrus</code> 中的lambda 通过引用捕获了这个临时字符串。当返回<code>makeWalrus</code>时，临时字符串被销毁，但是lambda依然在引用它。然后当我们调用<code>sayName</code>，就会访问到这个空悬的引用，于是就造成了未定义行为。</p><blockquote><p>注意，<strong>如果按值将<code>name</code>传递给<code>makeWalrus</code>，也会发生这种情况。</strong></p></blockquote><hr><p>warning:</p><p><strong>通过引用捕获变量时要格外小心，特别是使用默认的引用捕获时。捕获的变量必须比lambda存在的时间长。</strong></p><hr><p>未完待续~~：<strong>Unintended copies of mutable lambdas</strong></p><blockquote><p>目前，本节剩下部分先不看。2020-05-07 22:26:38</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/省略号(以及为啥避免使用他)</title>
      <link href="/archives/5844b406.html"/>
      <url>/archives/5844b406.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/714-ellipsis-and-why-to-avoid-them/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/714-ellipsis-and-why-to-avoid-them/</a></p><hr><p>在我们目前看到的所有函数中，必须提前知道函数将使用的参数的数量(即使它们有默认值)。</p><p>但是，在某些情况下，<strong>能够向函数传递 可变数量的参数 是很有用的</strong>。c++提供了一种特殊的说明符，称为 <strong>ellipsis(省略号)</strong> (又名 <strong>“…”</strong> )，它允许我们精确地执行此操作。</p><p>使用省略号的函数采用以下形式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return_type function_name(argument_list, ...)</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>argument_list</code>：是一个或多个常规函数参数。</strong>(注意，使用省略号的函数必须至少有一个非省略号参数。) 传递给函数的任何参数都必须首先匹配</p></li><li><p><strong>省略号：</strong>（是由三个点组成）。必须总是函数中的最后一个参数。</p><blockquote><p>但是从概念上来说，<strong>把省略号看作一个数组是很有用的，这个数组包含的参数超出argument_list中的参数。</strong></p></blockquote></li></ul><hr><p>一个例子：</p><p>假设我们要写一个函数来计算一堆整数的平均值。我们会这样做:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdarg&gt; // needed to use ellipsis</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略号必须是最后一个参数</span></span><br><span class="line"><span class="comment">// count是我们传递了多少额外的参数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findAverage</span><span class="params">(<span class="keyword">int</span> count, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们通过va_list⭐访问省略号，因此我们声明一个</span></span><br><span class="line">va_list <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们使用va_start⭐初始化va_list。</span></span><br><span class="line"><span class="comment">//第一个参数是要初始化的列表，第二个参数是最后一个非省略号参数</span></span><br><span class="line">va_start(<span class="built_in">list</span>, count);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环遍历所有省略号参数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> arg = <span class="number">0</span>; arg &lt; count; ++arg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//我们使用va_arg⭐从我们的省略号中获取参数</span></span><br><span class="line"><span class="comment">// 第一个参数是我们正在使用的va_list</span></span><br><span class="line"><span class="comment">// 第二个参数是  参数的类型</span></span><br><span class="line">sum += va_arg(<span class="built_in">list</span>, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//完成后清除va_list ⭐</span></span><br><span class="line">va_end(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sum / count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; findAverage(<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; findAverage(<span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>) &lt;&lt; <span class="string">'\n'</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3.5</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/命令行参数</title>
      <link href="/archives/dcba50cd.html"/>
      <url>/archives/dcba50cd.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/714-ellipsis-and-why-to-avoid-them/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/714-ellipsis-and-why-to-avoid-them/</a></p><hr><p>在 <a href="http://www.learncpp.com/cpp-tutorial/04-introduction-to-development/" target="_blank" rel="noopener">0.4 – introduction to development</a>，中我们学习了：当我们编译和链接我们的程序时：</p><ul><li>编译器会产生一个可执行文件；</li><li>当程序运行时，执行从main()函数的顶部开始。</li></ul><p>截止到现在，我们都是这样声明一个<code>main()</code>函数的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>注意，<code>main()</code>的这个版本不接受任何参数。</p><p>然而，许多程序需要某种类型的输入才能使用。例如，假设您正在编写一个名为Thumbnail的程序，它读取一个图像文件，然后生成一个缩略图(图像的较小版本)。Thumbnail如何知道要读取和处理的图像? 用户必须有某种方式告诉程序打开哪个文件。为此，您可以采用以下方法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Program: Thumbnail</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter an image filename to create a thumbnail for: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> filename &#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;filename;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//open image file</span></span><br><span class="line">    <span class="comment">//create thumbnail</span></span><br><span class="line">    <span class="comment">//output thumbnail</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，这种方法有一个潜在的问题。每次程序运行时，程序都会等待用户输入。如果您从命令行手动运行此程序一次，这可能不是问题。但在其他情况下可能会出现问题，比如希望在许多文件上运行这个程序，或者让另一个程序运行这个程序。</p><p>让我们进一步研究这些情况。</p><p>考虑这样一种情况，您希望为给定目录中的所有图像文件创建缩略图。你会怎么做呢?只要目录中有图像，您就可以多次运行这个程序，手工输入每个文件名。然而，如果有数百个图像，这可能需要一整天!这里的一个很好的解决方案是编写一个程序，循环遍历目录中的每个文件名，为每个文件调用一次Thumbnail。</p><blockquote><p>现在考虑这样一种情况，您正在运行一个网站，您希望让您的网站在用户每次向您的网站上传图像时创建一个缩略图。这个程序不接受来自web的输入，那么在这种情况下，上传者如何输入文件名呢? 这里的一个很好的解决方案是让您的web服务器在上传后自动调用Thumbnail。</p></blockquote><p>在这两种情况下，我们确实需要一种方法，让外部程序在启动Thumbnail时将文件名作为输入传递给我们的Thumbnail程序，而不是让Thumbnail等待用户在启动后输入文件名。</p><h1 id="Command-line-arguments"><a href="#Command-line-arguments" class="headerlink" title="Command line arguments"></a>Command line arguments</h1><p><strong>命令行参数</strong>是可选的字符串参数，在程序启动时由操作系统传递给程序。</p><p>然后程序可以使用它们作为输入(或忽略它们)。</p><p>与函数参数为函数提供向另一个函数提供输入的方法非常相似，命令行参数为用户或程序 提供向程序提供输入的方法。</p><h1 id="传递命令行参数"><a href="#传递命令行参数" class="headerlink" title="传递命令行参数"></a>传递命令行参数</h1><p><strong>可执行程序</strong>可以通过按名称调用命令行来运行。</p><blockquote><p>例如，要在Windows机器上运行位于C:驱动器根目录中的可执行文件“WordCount”，您可以输入以下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;WordCount</span><br></pre></td></tr></table></figure></blockquote><p>为了将命令行参数传递给WordCount，我们只需在 可执行文件名称 后面列出命令行参数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;WordCount Myfile.txt</span><br></pre></td></tr></table></figure><p>现在，当WordCount执行时，Myfile.txt将作为命令行参数提供。</p><p>当然，一个程序可以有多个命令行参数，用空格分隔:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;WordCount Myfile.txt Myotherfile.txt</span><br></pre></td></tr></table></figure><h2 id="IDE中输入命令行参数的方法"><a href="#IDE中输入命令行参数的方法" class="headerlink" title="IDE中输入命令行参数的方法"></a>IDE中输入命令行参数的方法</h2><p>在microsoftvisual Studio中：</p><ol><li><p>在“解决方案资源管理器”中右键单击项目，然后选择“属性”。</p></li><li><p>打开“配置属性”树目录，选择“调试”。</p></li><li><p>在右侧窗格中，有一行称为“命令参数”。</p><blockquote><p>您可以在那里输入命令行参数进行测试，当您运行它时，它们将自动传递给您的程序。</p></blockquote></li></ol><h1 id="使用命令行参数"><a href="#使用命令行参数" class="headerlink" title="使用命令行参数"></a>使用命令行参数</h1><p>既然您已经知道了如何为程序提供命令行参数，那么下一步就是从我们的c++程序中访问它们。</p><p>为此，我们使用了与以前不同的main()形式。这种新形式的main()有两个参数(按照惯例命名为<strong>argc和argv</strong>):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span>  <span class="comment">//【推荐】</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//上面的其实是等价的，但是我们推荐第一种，因为它便于理解</span></span></span><br></pre></td></tr></table></figure><ul><li><p><strong><code>argc</code>：</strong>是一个整数参数，<strong>包含传递给程序的参数数的数目</strong>。argc将至少为1，因为第一个参数始终是程序本身的名称。</p><blockquote><p>其中：<strong>argc = argument count</strong></p></blockquote></li><li><p><strong><code>argv</code>：</strong>是实际的参数值存储的地方。argv实际上只是一个c风格字符串数组。这个数组的<u>长度是argc。</u></p><blockquote><p>其中：<strong>argv = argument values</strong>，尽管它的专有名称是”argument vectors”</p></blockquote></li></ul><p>看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Program: test</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"There are "</span> &lt;&lt; argc &lt;&lt; <span class="string">" arguments:\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Loop through each argument and print its number and value</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count&#123; <span class="number">0</span> &#125;; count &lt; argc; ++count)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="string">" "</span> &lt;&lt; argv[count] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://raw.githubusercontent.com/longlongqin/CDN-for-HEXO_BLOG/pig_bed/20200506222415.png" alt=""></p><p>我们似乎没有给这个程序添加命令行参数，那我们就按照添加方法添加一下吧：（添加了3个命令行参数）</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://raw.githubusercontent.com/longlongqin/CDN-for-HEXO_BLOG/pig_bed/20200506223150.png" alt="image-20200506223143830"></p><p>现在再来运行一下：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://raw.githubusercontent.com/longlongqin/CDN-for-HEXO_BLOG/pig_bed/20200506223709.png" alt="image-20200506223704193"></p><hr><p>参数0是当前正在运行的程序的<strong>路径和名称</strong>。在本例中，参数1和2和3是我们传入的3个命令行参数。</p><h1 id="处理数值类型的命令行参数"><a href="#处理数值类型的命令行参数" class="headerlink" title="处理数值类型的命令行参数"></a>处理数值类型的命令行参数</h1><p><strong>命令行参数总是作为字符串传递，即使提供的值本质上是数值型的</strong>。</p><p>若要将命令行参数用作数字，必须将其从字符串转换为数字。不幸的是，C++使这一点比它应该做到的更加困难。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt; // for std::stringstream</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; // for std::exit()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 在某些操作系统上，argv[0]可能以空字符串结束，而不是程序的名称。</span></span><br><span class="line"><span class="comment">// 我们将根据argv[0]是否为空来调节我们的响应。</span></span><br><span class="line"><span class="keyword">if</span> (argv[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Usage: "</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">" &lt;number&gt;"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Usage: &lt;program name&gt; &lt;number&gt;"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//设置一个名为convert的stringstream变量，使用argv[1]的输入进行初始化</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> convert&#123; argv[<span class="number">1</span>] &#125;; <span class="comment">//⭐</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> myint&#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (!(convert &gt;&gt; myint)) <span class="comment">// 执行转换(这里的‘&gt;&gt;’是提取操作符⭐)</span></span><br><span class="line">myint = <span class="number">0</span>; <span class="comment">// 如果转换失败，将myint设置为默认值</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Got integer: "</span> &lt;&lt; myint &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*假设我们设置了一个命令行参数：567, 那么结果为：*/</span></span><br><span class="line">Got integer: <span class="number">567</span></span><br></pre></td></tr></table></figure><p>⭐注意：在上面的<code>std::stringstream</code>它的工作原理和<code>std::cin</code>非常相似。在本例中，我们使用argv[1]的值初始化它，因此，我们可以使用<strong>操作符<code>&gt;&gt;</code>来提取</strong>整型变量的值(与std::cin相同)。</p><hr><h1 id="操作系统首先解析命令行参数"><a href="#操作系统首先解析命令行参数" class="headerlink" title="操作系统首先解析命令行参数"></a>操作系统首先解析命令行参数</h1><p>当您在命令行输入一些内容(或从IDE运行程序)时，操作系统负责适当 地转换和路 由该请求。</p><p>这不仅涉及运行可执行文件，<strong>还涉及解析任何参数</strong>，以确定应该如何处理和传递给应用程序。</p><p>通常，<strong>操作系统对 双引号 和 反斜杠 等特殊字符 的处理有特殊的规则。</strong></p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;包含下面的命令行参数</span><br><span class="line">MyArgs Hello world!</span><br></pre></td></tr></table></figure><p>如果打印命令行参数，则为：(原文中的路径)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">There are 3 arguments:</span><br><span class="line">0 C:\MyArgs</span><br><span class="line">1 Hello</span><br><span class="line">2 world!</span><br></pre></td></tr></table></figure><ul><li><p>通常，<strong>双引号中的字符串被认为是一个字符串的整体:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyArgs &quot;Hello world!&quot;</span><br></pre></td></tr></table></figure><p>prints:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">There are 2 arguments:</span><br><span class="line">0 C:\MyArgs</span><br><span class="line">1 Hello world!</span><br></pre></td></tr></table></figure></li><li><p>如果你想包含一个<strong>文字双引号，你必须反斜杠双引号</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyArgs \&quot;Hello world!\&quot;</span><br></pre></td></tr></table></figure><p>prints:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">There are 3 arguments:</span><br><span class="line">0 C:\MyArgs</span><br><span class="line">1 &quot;Hello</span><br><span class="line">2 world!&quot;</span><br></pre></td></tr></table></figure></li></ul><hr><p>小结：</p><p>命令行参数为用户或其他程序在启动时向程序传递输入数据提供了一种很好的方式。</p><p>考虑将程序在启动时需要的任何输入数据用于操作命令行参数。如果没有传递命令行，您总是可以检测到这一点并请求用户输入。这样，你的程序可以以任何一种方式运行。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/处理假设性错误</title>
      <link href="/archives/ff8fbe02.html"/>
      <url>/archives/ff8fbe02.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/712-handling-errors-assert-cerr-exit-and-exceptions/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/712-handling-errors-assert-cerr-exit-and-exceptions/</a></p><hr><p>既然您已经知道了假设错误通常发生在什么地方，那么让我们讨论一下在它们发生时处理它们的不同方法。没有处理错误的最佳方法——这实际上取决于问题的性质以及问题是否可以修复。</p><p>以下是一些典型的方法:</p><ol><li><p>悄悄地跳过代码，这取决于假设<strong>是有效的</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printString</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cstring)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Only print if cstring is non-null</span></span><br><span class="line">    <span class="keyword">if</span> (cstring)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cstring;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，如果cstring为null，则不打印任何内容。我们跳过了依赖于cstring非空的代码。如果被跳过的语句不是关键语句，并且不影响程序逻辑，那么这可能是一个不错的选择。这样做的主要挑战是调用者或用户无法识别出错的地方。</p></li><li><p>如果我们在一个函数中，<strong>返回一个错误代码</strong>给调用者，让调用者处理这个问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// assume the array only holds positive values</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getArrayValue</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, <span class="number">10</span>&gt; &amp;<span class="built_in">array</span>, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// use if statement to detect violated assumption</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">array</span>.<span class="built_in">size</span>()))</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// return error code to caller</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">array</span>[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，如果调用者传入一个无效的索引，函数将返回-1 (返回一个枚举值会更好)。</p></li><li><p>如果我们想<strong>立即终止程序</strong>，可以使用头文件<code>&lt;cstdlib&gt;</code>中的<code>exit</code>函数向操作系统返回错误代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; // for std::exit()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getArrayValue</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, <span class="number">10</span>&gt; &amp;<span class="built_in">array</span>, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// use if statement to detect violated assumption</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">array</span>.<span class="built_in">size</span>()))</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">exit</span>(<span class="number">2</span>); <span class="comment">// terminate program and return error number 2 to OS</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">array</span>[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u>如果调用者传入一个无效的索引，这个程序将立即终止</u>(没有错误消息)，并将错误代码2传递给操作系统。</p></li><li><p>如果用户输入了无效的输入，<strong>请用户再次输入该输入</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> hello&#123; <span class="string">"hello, world!"</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span>  <span class="comment">//主要是这个do &#123;&#125;while()循环</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"enter an index: "</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; index;</span><br><span class="line"><span class="comment">//处理用户输入非整数的情况</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">cin</span>.fail())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">clear</span>(); <span class="comment">// 重置任何错误标志</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>); <span class="comment">//忽略输入缓冲区中的任何字符</span></span><br><span class="line"></span><br><span class="line">index = <span class="number">-1</span>; <span class="comment">// 确保index有一个无效的值，这样循环就不会终止</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">continue</span>; <span class="comment">//这个continue看起来无关紧要，但是它明确地表示了终止这个循环迭代的意图……</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//……以防我们后面添加更多东西</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(hello.<span class="built_in">size</span>())); <span class="comment">//处理用户输入的整数超出范围的情况</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Letter #"</span> &lt;&lt; index &lt;&lt; <span class="string">" is "</span> &lt;&lt; hello[index] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***********************************************/</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>cerr</code>是另一种专门用于打印错误消息的机制。<code>cerr</code>是一个输出流(就像cout)，它在中定义。通常，<code>cerr</code>在屏幕上写错误消息(就像cout一样)，但是它也可以单独重定向到一个文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printString</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cstring)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Only print if cstring is non-null</span></span><br><span class="line">    <span class="keyword">if</span> (cstring)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cstring;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"function printString() received a null parameter"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们不仅跳过了错误行，还记录了一个错误，以便用户稍后可以确定为什么程序没有按预期执行。</p></li><li><p>如果在某种图形环境中工作(例如MFC, SDL, QT, etc…)。通常是弹出一个带有错误代码的消息框，然后终止程序。</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/函数重载</title>
      <link href="/archives/6c7b6feb.html"/>
      <url>/archives/6c7b6feb.html</url>
      
        <content type="html"><![CDATA[<p><strong>函数重载</strong>是C++的一个特性，<strong>它允许我们创建具有相同名称的多个函数</strong>，它们的形参需要是不同的。</p><p>具体内容请查看原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/76-function-overloading/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/76-function-overloading/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/内联函数</title>
      <link href="/archives/738b4cec.html"/>
      <url>/archives/738b4cec.html</url>
      
        <content type="html"><![CDATA[<p>函数的一个主要缺点是每次调用函数时，都会出现一定数量的性能开销。这是因为CPU必须存储它正在执行的当前指令的地址(这样它就知道以后要返回到哪里)以及其他寄存器，所有的函数参数都必须创建并赋值，程序必须转移到一个新的位置。就地编写的代码要快得多。</p><p>对于大型和/或执行复杂任务的函数，与函数运行所需的时间相比，函数调用的开销通常是微不足道的。然而，对于小的、常用的函数，执行<strong>函数调用所需的时间</strong>通常比实际执行函数代码所需的时间多得多。这可能导致严重的性能损失。</p><hr><p>c++提供了一种将函数的优点与就地编写代码的速度相结合的方法: <strong>内联函数</strong>。<code>inline</code>关键字用于请求编译器将函数视为内联函数。</p><p>当编译器编译您的代码时，所有内联函数都在适当的位置展开——也就是说，函数调用被替换为函数本身内容的副本，从而消除了函数调用的开销!</p><p><strong>缺点是</strong>，因为内联函数在每个函数调用时都被就地展开，这会使编译后的代码变得更大，特别是当内联函数很长或者有很多对内联函数的调用时。</p><hr><p>请看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? y : x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">min</span>(<span class="number">5</span>, <span class="number">6</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">min</span>(<span class="number">3</span>, <span class="number">2</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序调用函数<code>min()</code>两次，导致函数调用开销多了两次。<strong>因为<code>min()</code>是一个很短的函数，它是内联的最佳选择:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&gt;y ? y : x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，当程序编译<code>main()</code>时，它将创建机器码，就好像main()是这样写的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (<span class="number">5</span> &gt; <span class="number">6</span> ? <span class="number">6</span> : <span class="number">5</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (<span class="number">3</span> &gt; <span class="number">2</span> ? <span class="number">2</span> : <span class="number">3</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这将执行得快一些，代价是编译后的代码稍微大一些。</strong></p><p><strong>由于存在代码膨胀的可能性，内联函数最适合短函数(例如，不超过几行)，</strong>这些短函数通常在循环内部调用，并且不进行分支。</p><p>还要注意，<strong><code>inline</code>关键字只是一个建议——如果您试图内联一个冗长的函数，编译器很可能会忽略您对内联函数的请求。</strong></p><h1 id="现代编译器会自动设为内联函数"><a href="#现代编译器会自动设为内联函数" class="headerlink" title="现代编译器会自动设为内联函数"></a>现代编译器会自动设为内联函数</h1><p>最后，现代编译器现在非常擅长自动内联函数——在大多数情况下比人类做得更好。即使没有将函数标记为内联函数，编译器也会将它认为会导致性能提高的内联函数标记为内联函数。因此，在大多数情况下，并不需要特别使用<code>inline</code>关键字。让编译器为您处理内联函数。</p><p><strong>所以，不需要手动去设置，编译器会智能的自动帮我们将适当的函数设置为内联函数。</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/按值传递</title>
      <link href="/archives/6b668399.html"/>
      <url>/archives/6b668399.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h1><p>原文：</p><blockquote><p><a href="https://www.learncpp.com/cpp-tutorial/introduction-to-functions/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/introduction-to-functions/</a></p><p><a href="https://www.learncpp.com/cpp-tutorial/introduction-to-function-parameters-and-arguments/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/introduction-to-function-parameters-and-arguments/</a></p></blockquote><p>当你读一本书的时候，突然有人给你打电话。然后你就用“书签”夹在当前阅读位置，去接电话。等你电话接完，再回到你放书签的那个地方继续读书。</p><p><strong>函数调用(function call)</strong>是一个表达式。它告诉CPU中断当前函数并在这里“放一个书签”，然后执行另一个函数(就是函数调用中提及的那个函数)。当调用结束后，CPU就返回到“书签”的位置，然后再继续执行。</p><blockquote><p><strong>caller</strong>：发起函数调用的函数叫做caller；</p><p><strong>callee(called function)</strong>：被调用的函数叫做callee(called function)。</p></blockquote><p><strong>int main()的返回值</strong>：</p><p>在int main()函数最后，会有返回值，这个值是返回到操作系统的，为了让操作系统知道这个程序执行成功与否。main函数的返回值，有一个特定名字叫做：<strong>status code （状态码）</strong></p><blockquote><p>一般 <code>return 0;</code> 表示程序执行成功。</p><p>返回非零值，表示程序执行错误。</p></blockquote><h2 id="C-规定，main函数必须是int型"><a href="#C-规定，main函数必须是int型" class="headerlink" title="C++规定，main函数必须是int型"></a>C++规定，main函数必须是int型</h2><p>C++标准中规定的：main函数的返回值应该定义为int类型。</p><p>对于”void main(void);”这种错误形式，虽然在一些编译器中可以通过编译(如vc6)，但并非所有的编译器都支持。</p><p>main()函数的原型是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char **argv, char **env)</span><br></pre></td></tr></table></figure><h1 id="实参的值不会被函数改动"><a href="#实参的值不会被函数改动" class="headerlink" title="实参的值不会被函数改动"></a>实参的值不会被函数改动</h1><blockquote><p>原文：<a href="https://www.learncpp.com/cpp-tutorial/72-passing-arguments-by-value/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/72-passing-arguments-by-value/</a></p></blockquote><p>默认情况下，无指针的实参是按值传递的。</p><p>当实参是“<strong>按值传递</strong>”时，实参的值会被复制到函数的形参中。所以，<strong>原来的实参的值是不会被函数改动的。</strong></p><h1 id="函数参数求值的顺序"><a href="#函数参数求值的顺序" class="headerlink" title="函数参数求值的顺序"></a>函数参数求值的顺序</h1><p>在C++中，没有规定实参匹配的顺序（顺序：从左→右，还是从右→左），因为匹配顺序不重要。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someFunction(a(), b()); <span class="comment">// a() or b() may be called first</span></span><br></pre></td></tr></table></figure><p>是从右→左，还是从右→左：<strong>取决于a()和b()的功能</strong>。</p><p>如果你想要规定谁先的话，你可以显示的规定匹配顺序，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> avar&#123; a() &#125;; <span class="comment">// a() will always be called first</span></span><br><span class="line"><span class="keyword">int</span> bvar&#123; b() &#125;; <span class="comment">// b() will always be called second</span></span><br><span class="line"> </span><br><span class="line">someFunction(avar, bvar); <span class="comment">// it doesn't matter whether avar or bvar are copied first because they are just values</span></span><br></pre></td></tr></table></figure><h1 id="按值传递的优劣"><a href="#按值传递的优劣" class="headerlink" title="按值传递的优劣"></a>按值传递的优劣</h1><h2 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h2><ul><li><p>通过值传递的参数可以是变量(例如x)、文字(例如6)、表达式(例如x+1)、结构和类以及枚举数。换句话说，几乎任何事情。</p></li><li><p>被调用的函数不会改变<strong>实参</strong>，这可以防止副作用。</p></li></ul><h2 id="短处"><a href="#短处" class="headerlink" title="短处"></a>短处</h2><ul><li>复制struct和class会导致严重的性能损失，特别是在多次调用函数的情况下。</li></ul><h1 id="按值传递的使用时机"><a href="#按值传递的使用时机" class="headerlink" title="按值传递的使用时机"></a>按值传递的使用时机</h1><p><strong>使用时机：</strong></p><ul><li>当传递基本数据类型和枚举数时，且函数不需要修改实参。</li></ul><p><strong>不适用情况：</strong></p><ul><li>在传递struct或类时(包括std::array、std::vector和std::string)。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>test your code</title>
      <link href="/archives/5937092e.html"/>
      <url>/archives/5937092e.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapterL</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h1 id="标准库-algorithms的介绍"><a href="#标准库-algorithms的介绍" class="headerlink" title="标准库 algorithms的介绍"></a>标准库 <a href="https://en.cppreference.com/w/cpp/algorithm" target="_blank" rel="noopener">algorithms</a>的介绍</h1><p>由于搜索、计数和排序是如此常见的操作，c++标准库提供了一组函数，只需几行代码就可以完成这些任务。</p><p>此外，这些标准库函数经过了预先测试，它们是高效的，可以处理各种不同的容器类型，并且许多还支持并行化(将多个CPU线程用于同一任务以更快地完成它的能力)。</p><p>算法库中提供的功能大致可分为三类:</p><ul><li><p><strong>检查器</strong>——用于<strong>查看</strong>(但不修改)容器中的数据。例如搜索和计数。</p></li><li><p><strong>修改序列</strong>——用于<strong>修改</strong>容器中的数据的<strong>顺序</strong>。例如排序和变换。</p></li><li><p><strong>辅助器</strong>——用于根据数据成员的值生成结果。示例包括将值相乘的对象，或者确定元素对的排序顺序的对象。</p></li></ul><p>更多关于 <a href="https://en.cppreference.com/w/cpp/algorithm" target="_blank" rel="noopener">algorithms</a> 。</p><hr><p>注：<strong>在库“<code>algorithm</code>”中所有函数都使用了迭代器</strong>。</p><hr><h1 id="使用std-fine按值查找元素"><a href="#使用std-fine按值查找元素" class="headerlink" title="使用std::fine按值查找元素"></a>使用<code>std::fine</code>按值查找元素</h1><p><a href="https://en.cppreference.com/w/cpp/algorithm/find" target="_blank" rel="noopener"><code>std::find</code></a> 用于找出 给定值 在容器中第一次的出现。</p><p>它有三个参数：</p><ol><li>序列中起始元素的迭代器；</li><li>序列中结束元素的迭代器；</li><li>要搜索的值</li></ol><p>它的返回值：</p><ul><li>如果找到了与要搜索值相匹配的迭代器，就返回指向这个元素的迭代器；</li><li>如果没找到，就返回容器的末端的迭代器。</li></ul><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span> arr&#123; <span class="number">13</span>, <span class="number">90</span>, <span class="number">99</span>, <span class="number">5</span>, <span class="number">40</span>, <span class="number">80</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a value to search for and replace with: "</span>;  </span><br><span class="line">  <span class="keyword">int</span> search&#123;&#125;;</span><br><span class="line">  <span class="keyword">int</span> replace&#123;&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; search &gt;&gt; replace;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Input validation omitted</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// std::find returns an iterator pointing to the found element (or the end of the container)</span></span><br><span class="line">  <span class="comment">// we'll store it in a variable, using type inference to deduce the type of</span></span><br><span class="line">  <span class="comment">// the iterator (since we don't care)</span></span><br><span class="line">  <span class="keyword">auto</span> found&#123; <span class="built_in">std</span>::<span class="built_in">find</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), search) &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Algorithms that don't find what they were looking for return the end iterator.</span></span><br><span class="line">  <span class="comment">// We can access it by using the end() member function.</span></span><br><span class="line">  <span class="keyword">if</span> (found == arr.<span class="built_in">end</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not find "</span> &lt;&lt; search &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Override the found element.</span></span><br><span class="line">    *found = replace;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i : arr)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sample run when the element is found</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter a value to search for and replace with: 5 234</span><br><span class="line">13 90 99 234 40 80</span><br></pre></td></tr></table></figure><p>Sample run when the element isn’t found</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Enter a value to search for and replace with: 0 234</span><br><span class="line">Could not find 0</span><br><span class="line">13 90 99 5 40 80</span><br></pre></td></tr></table></figure><hr><h1 id="使用std-find-if查找与某个条件匹配的元素"><a href="#使用std-find-if查找与某个条件匹配的元素" class="headerlink" title="使用std::find_if查找与某个条件匹配的元素"></a>使用<code>std::find_if</code>查找与某个条件匹配的元素</h1><p>有时，我们想要查看容器中是否有匹配某些条件的值(例如，包含特定<strong>子字符串</strong>的字符串)，而不是确切的值。</p><p><code>std::find_if</code>函数的工作方式与<code>std::find</code>类似，但它不传递要搜索的值，而是传入一个可调用的对象（如：函数的指针）检查是否找到匹配项。</p><ul><li><p><code>std::find_if</code>将为每个元素调用这个函数，直到找到匹配的元素，则返回该元素对应的迭代器；</p></li><li><p>当没有匹配成功时，返回容器的最后一个迭代器；</p></li></ul><p>下面是一个例子，我们使用std::find_if来检查是否有<strong>包含子字符串“nut”的元素</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Our function will return true if the element matches</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsNut</span><span class="params">(<span class="built_in">std</span>::string_view str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// std::string_view::find returns std::string_view::npos if it doesn't find</span></span><br><span class="line">  <span class="comment">// the substring. Otherwise it returns the index where the substring occurs</span></span><br><span class="line">  <span class="comment">// in str.</span></span><br><span class="line">  <span class="keyword">return</span> (str.<span class="built_in">find</span>(<span class="string">"nut"</span>) != <span class="built_in">std</span>::string_view::npos);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::string_view, 4&gt; arr&#123; <span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"walnut"</span>, <span class="string">"lemon"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Scan our array to see if any elements contain the "nut" substring</span></span><br><span class="line">  <span class="keyword">auto</span> found&#123; <span class="built_in">std</span>::find_if(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), containsNut) &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (found == arr.<span class="built_in">end</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"No nuts\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Found "</span> &lt;&lt; *found &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Found walnut  <span class="comment">//walnut这个字符串包含子串“nut”</span></span><br></pre></td></tr></table></figure><h1 id="使用std-count和std-count-if来计算出现的次数"><a href="#使用std-count和std-count-if来计算出现的次数" class="headerlink" title="使用std::count和std::count_if来计算出现的次数"></a>使用<code>std::count</code>和<code>std::count_if</code>来计算出现的次数</h1><ul><li><p><code>std::cout</code>搜索”一个元素”的所有出现情况。</p></li><li><p><code>std::count_if</code>搜索”一个满足条件的元素”的所有出现情况。</p></li></ul><p>在下面的例子中，我们将计算有多少元素包含子字符串“nut”:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsNut</span><span class="params">(<span class="built_in">std</span>::string_view str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (str.<span class="built_in">find</span>(<span class="string">"nut"</span>) != <span class="built_in">std</span>::string_view::npos);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::string_view, 5&gt; arr&#123; <span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"walnut"</span>, <span class="string">"lemon"</span>, <span class="string">"peanut"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">auto</span> nuts&#123; <span class="built_in">std</span>::count_if(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), containsNut) &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Counted "</span> &lt;&lt; nuts &lt;&lt; <span class="string">" nut(s)\n"</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Counted <span class="number">2</span> nut(s)</span><br></pre></td></tr></table></figure><h1 id="使用std-sort来定制排序"><a href="#使用std-sort来定制排序" class="headerlink" title="使用std::sort来定制排序"></a>使用<code>std::sort</code>来定制排序</h1><p>我们以前使用<code>std::sort</code>按升序对数组排序，但是<code>std::sort</code>可以做得更多。</p><p><code>std::sort</code>可以让我们：<strong>它接受一个函数作为它的第三个参数，允许我们按照自己的喜好进行排序。</strong></p><p>该函数接受两个参数进行比较：</p><ul><li>如果第一个参数的顺序应该排在第二个参数之前，则返回true。</li></ul><blockquote><p>默认情况下，<code>std::sort</code>按升序排列元素。</p></blockquote><p>让我们使用<code>std::sort</code>来使用一个名为”greater”的自定义比较函数对数组进行倒序排序:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">greater</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Order @a before @b if @a is greater than @b.</span></span><br><span class="line">  <span class="keyword">return</span> (a &gt; b);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span> arr&#123; <span class="number">13</span>, <span class="number">90</span>, <span class="number">99</span>, <span class="number">5</span>, <span class="number">40</span>, <span class="number">80</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Pass greater to std::sort</span></span><br><span class="line">  <span class="built_in">std</span>::sort(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), greater);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i : arr)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">99</span> <span class="number">90</span> <span class="number">80</span> <span class="number">40</span> <span class="number">13</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>小技巧：</p><p>因为按降序排序是很常见的，所以c++也为它提供了一个自定义类型(名为<code>std::greater</code>，在头文件<code>&lt;functional&gt;</code>中)。在上面的例子中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们呢可以将下面语句：</span></span><br><span class="line"><span class="built_in">std</span>::sort(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), greater); <span class="comment">// call our custom greater function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//替换为：</span></span><br><span class="line"><span class="built_in">std</span>::sort(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="built_in">std</span>::greater&#123;&#125;); <span class="comment">// use the standard library greater comparison</span></span><br><span class="line">  <span class="comment">// Before C++17, we had to specify the element type when we create std::greater</span></span><br><span class="line"><span class="built_in">std</span>::sort(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;&#123;&#125;); <span class="comment">// use the standard library greater comparison</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*注意*/</span></span><br><span class="line"><span class="built_in">std</span>::greater&#123;&#125;的大&#123;&#125;需要花括号，因为它不是一个可调用的函数。</span><br><span class="line">它是一个类型，为了使用它，我们需要实例化该类型的对象。花括号实例化该类型的匿名对象(然后将其作为参数传递给<span class="built_in">std</span>::sort)。</span><br></pre></td></tr></table></figure><h1 id="使用std-for-each对容器的所有元素执行特定操作"><a href="#使用std-for-each对容器的所有元素执行特定操作" class="headerlink" title="使用std::for_each对容器的所有元素执行特定操作"></a>使用<code>std::for_each</code>对容器的所有元素执行特定操作</h1><p><code>std::for_each</code>接受一个列表作为输入，并对每个元素应用一个自定义函数。当我们希望对列表中的每个元素执行相同的操作时，这很有用。</p><p>下面是一个例子，我们使用<code>std::for_each</code>来加倍数组中的所有数字:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doubleNumber</span><span class="params">(<span class="keyword">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  i *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span> arr&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::for_each(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), doubleNumber);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i : arr)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代</title>
      <link href="/archives/80469b0c.html"/>
      <url>/archives/80469b0c.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapterL</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h1 id="遍历数组的集中方法"><a href="#遍历数组的集中方法" class="headerlink" title="遍历数组的集中方法"></a>遍历数组的集中方法</h1><p>在编程中，遍历数据数组(或其他结构)是一件很常见的事情。到目前为止，我们已经介绍了许多不同的实现方法:</p><ul><li>使用循环和索引(for循环和while循环)，</li><li>使用指针和指针算法，</li><li>以及基于范围的for循环</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//在支持C++17时，可以使用：</span></span><br><span class="line">    <span class="comment">//std::array data&#123; 0, 1, 2, 3, 4, 5, 6 &#125;;//类型自动推断为std::array&lt;int, 7&gt;   </span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,7&gt; data&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> length length&#123;<span class="built_in">std</span>::<span class="built_in">size</span>(data)&#125;; <span class="comment">//同样需要在C++17中才可以使用</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// while循环显式索引</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> index&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (index != length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; data[index] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        ++index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// for循环显式索引</span></span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; length; ++index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; data[index] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//带有指针的for循环(注意:ptr不能是const，因为我们需要对它递增)</span></span><br><span class="line">    <span class="comment">/*使用指针和指针运算进行循环是冗长的，而且可能会使不了解指针运算规则的读者感到困惑。</span></span><br><span class="line"><span class="comment">    指针运算也只有在元素在内存中是连续的情况下才有效(这对于数组是正确的，但是对于其他类型</span></span><br><span class="line"><span class="comment">    的容器，例如list、tree和map，则不是正确的)。*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ptr &#123;&amp;data[<span class="number">0</span>]&#125;; ptr!=(&amp;data[<span class="number">0</span>]+length); ++ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;*ptr&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//基于范围的for循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i; data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;i&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们只使用索引来访问元素，那么使用索引进行循环比需要的类型更多。它也只有在容器(例如<code>array</code>)提供对元素的直接访问时才有效(数组可以这样做，但是其他类型的容器，如<code>list</code>则不行)。</p><p><strong>基于范围的for循环</strong>更有趣一些，因为遍历容器的机制是隐藏的——但是，它们仍然适用于各种不同的结构(数组、列表、树、映射等等)。它们是如何工作的?<strong>他们使用迭代器</strong>。</p><h1 id="迭代器-iterator"><a href="#迭代器-iterator" class="headerlink" title="迭代器(iterator)"></a>迭代器(iterator)</h1><p><strong>迭代器是一个设计用来遍历容器的对象</strong>(例如数组中的值、字符串中的字符)，<strong>提供对每个元素的访问。</strong></p><p>容器可以提供不同种类的迭代器。例如，一个数组容器可能提供：</p><ul><li>一个按正向顺序遍历数组的正向迭代器，</li><li>以及一个按反向顺序遍历数组的反向迭代器。</li></ul><p>因为c++迭代器通常使用相同的接口进行遍历 (操作符++移动到下一个元素) 和访问 (操作符*访问当前元素)，所以我们可以使用一致的方法迭代各种不同的容器类型。</p><h1 id="指针作为迭代器"><a href="#指针作为迭代器" class="headerlink" title="指针作为迭代器"></a>指针作为迭代器</h1><p>最简单的迭代器是指针，它(使用指针运算)对内存中<strong>顺序存储</strong>的数据起作用。让我们重新访问一个简单的数组遍历使用指针和指针运算:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span> data &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">begin</span>&#123;&amp;data[<span class="number">0</span>]&#125;;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意，它指向最后一个元素之外的一个点</span></span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">end</span> &#123;<span class="built_in">begin</span> + <span class="built_in">std</span>::<span class="built_in">size</span>(data)&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//带有指针的for循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ptr&#123;<span class="built_in">begin</span>&#125;; ptr != <span class="built_in">end</span>; ++ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *ptr &lt;&lt; <span class="string">' '</span>; <span class="comment">// 解引用 to get value of current element</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p>注意：</p><p>你可能会这样做：</p><p><code>int* end {&amp;array[std::size(array)]};</code></p><p>但是者<strong>会造成未定义行为</strong>，因为<code>array[std::size(array)]</code>会<strong>访问</strong>数组最后的一个元素的下一个元素。(因为 <code>std::size(array)</code>计算数组大小，但是要记得数组下标是从0开始的呀。)</p><h1 id="标准库中的迭代器"><a href="#标准库中的迭代器" class="headerlink" title="标准库中的迭代器"></a>标准库中的迭代器</h1><p>迭代是如此常见的操作，以至于<strong>所有标准库容器都提供了对迭代的直接支持</strong>。它不需要计算我们自己的开始点和结束点，我们<strong>可以通过函数<code>begin()</code>和<code>end()</code>简单地向容器请求<u>开始点</u>和<u>结束点</u></strong>:</p><blockquote><p>注意：函数``begin()<code>和</code>end()`得到的是 开始 和 结束的位置（即，得到的是一个<strong>地址</strong>）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span> , 3&gt; a&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//向我们的数组请求开始和结束点(通过begin()和end()成员函数)。</span></span><br><span class="line">    <span class="keyword">auto</span> bengin&#123;<span class="built_in">array</span>.<span class="built_in">begin</span>()&#125;;</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">end</span> &#123;<span class="built_in">array</span>.<span class="built_in">end</span>()&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p&#123;<span class="built_in">begin</span>&#125;; p!=<span class="built_in">end</span>; ++p)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="string">' '</span>; <span class="comment">// 解引用 to get value of current element.</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="头文件-lt-iterator-gt-中的std-begin、-std-end"><a href="#头文件-lt-iterator-gt-中的std-begin、-std-end" class="headerlink" title="头文件&lt;iterator&gt;中的std::begin、 std::end"></a>头文件<code>&lt;iterator&gt;</code>中的<code>std::begin</code>、 <code>std::end</code></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt; // For std::begin and std::end⭐</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span> <span class="built_in">array</span>&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Use std::begin and std::end to get the begin and end points.</span></span><br><span class="line">  <span class="keyword">auto</span> <span class="built_in">begin</span>&#123; <span class="built_in">std</span>::<span class="built_in">begin</span>(<span class="built_in">array</span>) &#125;; <span class="comment">//⭐</span></span><br><span class="line">  <span class="keyword">auto</span> <span class="built_in">end</span>&#123; <span class="built_in">std</span>::<span class="built_in">end</span>(<span class="built_in">array</span>) &#125;; <span class="comment">//⭐</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> p&#123; <span class="built_in">begin</span> &#125;; p != <span class="built_in">end</span>; ++p) <span class="comment">// ++ to move to next element</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="string">' '</span>; <span class="comment">// dereference to get value of current element</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基于范围的for循环的begin-、end"><a href="#基于范围的for循环的begin-、end" class="headerlink" title="基于范围的for循环的begin()、end()"></a>基于范围的for循环的<code>begin()</code>、<code>end()</code></h1><ul><li>所有具有<code>begin()</code>和<code>end()</code>成员函数的类型，</li><li>或者可以与<code>std::begin</code>和<code>std::end</code>一起使用的类型，</li></ul><p>都可以在基于范围的for循环中使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,3&gt; <span class="built_in">array</span>&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// This does exactly the same as the loop we used before.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i : <span class="built_in">array</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⭐在后台，基于范围的for循环<strong>调用</strong>要遍历的类型的<code>begin()</code>和<code>end()</code>。</p><ul><li><p><strong><code>std::array</code></strong>为什么可以在基于范围的for循环中使用？</p><p>答：因为<code>std::array</code>中含有<code>begin()</code>和<code>end()</code>成员函数，所以他可以在基于范围的for循环中使用。</p></li><li><p><strong>c风格的固定数组</strong>可以与<code>std::begin</code>和<code>std::end</code>函数一起使用，因此我们也可以使用基于范围的for循环遍历它们。</p></li><li><p><strong>动态数组</strong>不可以在基于范围的for循环中使用？</p><p>答：是的，因为它们没有<code>std::end</code>函数(<strong>因为类型信息不包含数组的长度</strong>)。</p></li></ul><h1 id="迭代器失效-空悬迭代器"><a href="#迭代器失效-空悬迭代器" class="headerlink" title="迭代器失效(空悬迭代器)"></a>迭代器失效(空悬迭代器)</h1><p>就像指针和引用一样，如果 迭代的元素更改了地址 或 被销毁 时迭代器会被“悬空”。当这种情况发生时，我们说迭代器已经失效。访问无效的迭代器会产生未定义的行为。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>std::vector</title>
      <link href="/archives/40d82c05.html"/>
      <url>/archives/40d82c05.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapterP</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h1 id="介绍std-vector"><a href="#介绍std-vector" class="headerlink" title="介绍std::vector"></a>介绍<code>std::vector</code></h1><p>在c++ 03中引入的<code>std::vector</code>提供了处理自身内存管理的<strong>动态</strong>数组功能。这意味着您可以创建在运行时设置长度的数组，而不必使用new和delete显式地分配和释放内存。</p><p><strong>它在头文件 <code>&lt;vector&gt;</code>中</strong></p><h1 id="声明及初始化std-vector"><a href="#声明及初始化std-vector" class="headerlink" title="声明及初始化std::vector"></a>声明及初始化<code>std::vector</code></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不需要在初始化时指定长度</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array2 = &#123;<span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span> &#125;; <span class="comment">//使用初始化器列表初始化数组</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array3 = &#123;<span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span> &#125;; <span class="comment">//使用统一的初始化来初始化数组(c++ 11开始)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从C++17开始，类型也可以省略</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span> array4 &#123;<span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span> &#125;; <span class="comment">//推导出std::vector&lt; int &gt;</span></span><br></pre></td></tr></table></figure><p>🐖：您不需要在<strong>编译时</strong>包含数组长度。这是因为<code>std::vector</code>将根据请求为其内容动态分配内存。</p><h1 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h1><p>就像<code>std::array</code>一样，你可以使用 <strong>操作符<code>[]</code>(没有边界检测)</strong> 或者 <strong>函数<code>at()</code>(与边界检测功能)</strong> 来访问数组元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>[<span class="number">6</span>] = <span class="number">2</span>;    <span class="comment">// no bounds checking</span></span><br><span class="line"><span class="built_in">array</span>.at(<span class="number">7</span>) = <span class="number">3</span>; <span class="comment">// does bounds checking</span></span><br></pre></td></tr></table></figure><h2 id="C-11中为std-vector赋值"><a href="#C-11中为std-vector赋值" class="headerlink" title="C++11中为std::vector赋值"></a>C++11中为<code>std::vector</code>赋值</h2><p>从c++ 11开始，您还可以使用<strong>初始化器列表</strong>为<code>std::vector</code>赋值:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span> = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;; <span class="comment">// okay, array length is now 5</span></span><br><span class="line"><span class="built_in">array</span> = &#123; <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span> &#125;; <span class="comment">// okay, array length is now 3</span></span><br></pre></td></tr></table></figure><p>在这种情况下，vector将自调整大小以匹配提供的元素数量。</p><h1 id="自我清理可以防止内存泄漏"><a href="#自我清理可以防止内存泄漏" class="headerlink" title="自我清理可以防止内存泄漏"></a>自我清理可以防止内存泄漏</h1><p>当vector 超出它所在的范围时，它会自动释放它所控制的内存。这不仅方便(不用手动清楚除)，而且还可以<strong>防止内存泄漏</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//看一个例子</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">(<span class="keyword">bool</span> earlyExit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *<span class="built_in">array</span> &#123;<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>] &#123; <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span> &#125; &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(earlyExit)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//其他代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span>[] <span class="built_in">array</span>; <span class="comment">//never called</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果earlyExit被设置为true，那么就不会执行delete语句，也就是说该内存不会被释放，就会发生内存泄漏</span></span><br></pre></td></tr></table></figure><p>但是，如果数组是<code>std::vector</code>，则不会发生这种情况，<strong>因为一旦数组超出作用域，内存就会被释放(不管函数是否提前退出)。这使得<code>std::vector</code>比您自己分配内存要安全得多。</strong></p><h1 id="vector记得它的长度"><a href="#vector记得它的长度" class="headerlink" title="vector记得它的长度"></a>vector记得它的长度</h1><p>不像内置的动态数组，它们不知道它们所指向的数组的长度，<strong><code>std::vector</code>跟踪它的长度</strong>。我们<strong>可以通过<code>size()</code>函数求出vector的长度:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLength</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The length is: "</span> &lt;&lt; <span class="built_in">array</span>.<span class="built_in">size</span>() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span> <span class="built_in">array</span> &#123; <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    printLength(<span class="built_in">array</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：与<code>std::array</code>一样，<code>size()</code>返回嵌套类型size_type的值(上面例子中的完整类型是<code>std::vector::size_type</code>)，它是一个<strong>无符号整数。</strong></p><h1 id="调整vector数组"><a href="#调整vector数组" class="headerlink" title="调整vector数组"></a>调整vector数组</h1><p>调整内置动态分配数组的长度非常复杂。调整<code>std::vector</code>的大小非常简单，只需要调用<strong><code>resize()</code>函数</strong>一样简单:</p><blockquote><p>注意：</p><ul><li>当我们调整向量的大小时，现有的元素值将被保留!</li><li>新元素初始化为类型的默认值(对于整数为0)。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span> <span class="built_in">array</span> &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">array</span>.resize(<span class="number">5</span>); <span class="comment">//将其长度设置为5⭐</span></span><br><span class="line">    </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The length is: "</span> &lt;&lt; <span class="built_in">array</span>.<span class="built_in">size</span>() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : <span class="built_in">array</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">The length is: <span class="number">5</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><hr><p>调整vector的长度的代价很高，所以尽可能的少调整他们的长度。</p><h1 id="bool类型的压缩"><a href="#bool类型的压缩" class="headerlink" title="bool类型的压缩"></a>bool类型的压缩</h1><p>类型为bool的<code>std::vector</code>有一个特殊的实现，它将把8个布尔值压缩成一个字节! 这是在幕后发生的，不会改变您使用<code>std::vector</code>的方式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="built_in">array</span> &#123; <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">true</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The length is: "</span> &lt;&lt; <span class="built_in">array</span>.<span class="built_in">size</span>() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : <span class="built_in">array</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">The length is: <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>如何理解“8布尔值为一个字节”这句话。数组的最大长度是255还是我理解错了?</p><p>答：如果没有专门化，向量的每个元素将占用’ sizeof(bool) ‘字节。这浪费了很多空间，因为bool不是假就是真，所以bool只能容纳一个位。1个字节是8位，所以我们可以在1个字节中存储8个内存，这意味着我们可以存储8倍于元素数量的元素，而不需要使用更多的内存。</p><p>（也就是说：<code>std::vector</code>的数组存储bool类型的值时，每一个值只占一个bit。）</p><blockquote><p>而这实现的机制是在由<code>std::vector</code>的设计者实现的，我们不用管</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>std::array</title>
      <link href="/archives/c9c6ad08.html"/>
      <url>/archives/c9c6ad08.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapterP</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><p>在之前的文章中，已经提到了：</p><ul><li><strong>“固定长度数组”</strong>：当传入函数参数时它会退化为指针，失去数组长度信息，；</li><li><strong>“动态数组”</strong>：动态数组的释放问题；</li></ul><p>为了解决这些问题，<strong>c++标准库包含了简化数组管理的功能:<code>std::array</code>和<code>std::vector</code></strong>。这节课我们将学习std::array，下节课我们将学习std::vector。</p><h1 id="介绍std-array"><a href="#介绍std-array" class="headerlink" title="介绍std::array"></a>介绍<code>std::array</code></h1><ul><li><p>在c++ 11中引入的<code>std::array</code>提供了<strong>在传递给函数时不会退化的固定数组功能</strong>。</p></li><li><p><code>std::array</code>是在<strong>命名空间std</strong>中的头文件<code>&lt;array&gt;</code>中定义的。</p></li></ul><h1 id="声明一个std-array变量"><a href="#声明一个std-array变量" class="headerlink" title="声明一个std::array变量"></a>声明一个<code>std::array</code>变量</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span> , 3&gt; myarray; <span class="comment">//声明一个整型数组，它的长度为3</span></span><br></pre></td></tr></table></figure><p>就像普通的固定长度数组一样，<strong><code>std::array</code>定义的数组的长度也必须是“编译时常量”</strong></p><h1 id="std-array的初始化"><a href="#std-array的初始化" class="headerlink" title="std::array的初始化"></a><code>std::array</code>的初始化</h1><p>可以使用<strong>“初始化器列表”</strong> 或者 <strong>“统一初始化”</strong></p><h2 id="初始化器列表"><a href="#初始化器列表" class="headerlink" title="初始化器列表"></a>初始化器列表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; myarray = &#123;<span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure><h2 id="统一初始化"><a href="#统一初始化" class="headerlink" title="统一初始化"></a>统一初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; myarray &#123;<span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure><h2 id="注意：初始化时不能省略数组长度"><a href="#注意：初始化时不能省略数组长度" class="headerlink" title="注意：初始化时不能省略数组长度"></a>注意：初始化时不能省略数组长度</h2><p>不像内置的固定数组，<code>std::array</code>初始化数组时，<strong>不能省略数组长度</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,&gt; myarray&#123;<span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>&#125;; <span class="comment">//✖，需要显式的输入数组长度</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;  myarray&#123;<span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>&#125;; <span class="comment">//✖，需要显式的输入数组长度</span></span><br></pre></td></tr></table></figure><h3 id="在C-17中，是可以的"><a href="#在C-17中，是可以的" class="headerlink" title="在C++17中，是可以的"></a>在C++17中，是可以的</h3><p>但是，由于<strong>c++ 17，允许省略类型和大小</strong>。<strong>只有在数组显式初始化的情况下，才可以同时忽略它们，但不能忽略其中一个。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span> myarray &#123;<span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>&#125;; <span class="comment">//The type is deduced to std::array&lt;int, 5&gt;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span> myArray &#123; <span class="number">9.7</span>, <span class="number">7.31</span> &#125;; <span class="comment">// The type is deduced to std::array&lt;double, 2&gt;</span></span><br></pre></td></tr></table></figure><h1 id="对std-array数组赋值"><a href="#对std-array数组赋值" class="headerlink" title="对std::array数组赋值"></a>对<code>std::array</code>数组赋值</h1><p>可以使用<strong>初始化器列表</strong>向数组赋值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; myarray;</span><br><span class="line">myarray = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;; <span class="comment">// okay</span></span><br><span class="line">myarray = &#123; <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span> &#125;; <span class="comment">// okay, elements 3 and 4 are set to zero!</span></span><br><span class="line">myarray = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;; <span class="comment">// ✖, too many elements in initializer list!</span></span><br></pre></td></tr></table></figure><h1 id="边界检查-使用at-函数"><a href="#边界检查-使用at-函数" class="headerlink" title="边界检查(使用at()函数)"></a>边界检查(使用<code>at()</code>函数)</h1><p>与内置的固定数组一样，下标操作符不执行任何边界检查。如果提供了无效的索引，可能会发生不好的事情。</p><p>但是，<code>std::array</code>提供了第二种<strong>访问</strong>数组元素的方法：<strong>使用函数<code>at()</code></strong>。<u>它带有检测边界的功能。</u></p><blockquote><p>第一种 就是普通的数组访问形式</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span> myArray &#123; <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line">myArray.at(<span class="number">1</span>) = <span class="number">6</span>; <span class="comment">// array element 1 valid, sets array element 1 to value 6</span></span><br><span class="line">myArray.at(<span class="number">9</span>) = <span class="number">10</span>; <span class="comment">// array element 9 is invalid, will throw an error</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，调用<code>array.at(1)</code>检查以确保数组元素1是有效的，<strong>因为它是有效的，所以它返回对数组元素1的引用。</strong></p><p>然后我们给它赋值6。但是，对array.at(9)的调用失败，因为数组元素9超出了数组的界限。<code>at()</code>函数不是返回一个引用，而是抛出一个错误来终止程序</p><blockquote><p>(注意:它实际上抛出了一个std::out_of_range类型的异常——我们在第15章讨论了异常)。</p></blockquote><hr><p>因为它执行边界检查，所以<code>at()</code>比操作符<code>[]</code>慢(但更安全)。</p><h1 id="std-array的数组会自动清理"><a href="#std-array的数组会自动清理" class="headerlink" title="std::array的数组会自动清理"></a><code>std::array</code>的数组会自动清理</h1><p><strong>当<code>std::array</code>数组超出作用域时，它会自己清理，所以不需要做任何手动清理</strong>。</p><h1 id="数组大小（使用函数size-）"><a href="#数组大小（使用函数size-）" class="headerlink" title="数组大小（使用函数size()）"></a>数组大小（使用函数<code>size()</code>）</h1><p><code>size()</code>函数可以用来检索std::数组的长度:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span> myArray &#123; <span class="number">9.0</span>, <span class="number">7.2</span>, <span class="number">5.4</span>, <span class="number">3.6</span>, <span class="number">1.8</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"length: "</span> &lt;&lt; myArray.<span class="built_in">size</span>() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">length: <span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="函数size-在函数调用中也能工作"><a href="#函数size-在函数调用中也能工作" class="headerlink" title="函数size()在函数调用中也能工作"></a>函数<code>size()</code>在函数调用中也能工作</h2><p>因为<code>std::array</code>在传递给函数时不会衰减为指针，所以<code>size()</code>函数即使在函数中调用也可以工作:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLength</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">double</span>, <span class="number">5</span>&gt; &amp;myArray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"length: "</span> &lt;&lt; myArray.<span class="built_in">size</span>() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span> myArray &#123; <span class="number">9.0</span>, <span class="number">7.2</span>, <span class="number">5.4</span>, <span class="number">3.6</span>, <span class="number">1.8</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    printLength(myArray);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">length: <span class="number">5</span></span><br></pre></td></tr></table></figure><h1 id="函数传递时使用引用传递"><a href="#函数传递时使用引用传递" class="headerlink" title="函数传递时使用引用传递"></a>函数传递时使用引用传递</h1><p>还要注意，<strong>我们通过“引用”或“const 引用” 将<code>std::array</code> 数组传入函数参数。这是为了防止编译器在将std::数组传递给函数时(出于性能原因)复制<code>std::array</code>。</strong></p><h1 id="std-array的排序（用std-sort）"><a href="#std-array的排序（用std-sort）" class="headerlink" title="std::array的排序（用std::sort）"></a><code>std::array</code>的排序（用<code>std::sort</code>）</h1><p>您可以使用<code>std::sort</code>(在头文件<code>&lt;algorithm&gt;</code>中)对<code>std::array</code>进行排序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;  //for std::sort</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span> myArray &#123; <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::sort(myArray.<span class="built_in">begin</span>(), myArray.<span class="built_in">end</span>()); <span class="comment">//由小到达排序</span></span><br><span class="line">    <span class="comment">//std::sort(myArray.rbegin(), myArray.rend()); // 由大到小排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> number : myArray)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;number&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><h1 id="手动索引数组-通过size-type"><a href="#手动索引数组-通过size-type" class="headerlink" title="手动索引数组(通过size_type)"></a>手动索引数组(通过<code>size_type</code>)</h1><p>看下面一个例子，它错哪里了？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; myArray =&#123; <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Iterate through the array and print the value of the elements</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i&#123; <span class="number">0</span> &#125;; i &lt; myArray.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; myArray[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：由于“有符号” 与 “无符号” 的冲突。</p><ul><li><p><strong>“<code>siez()</code>函数”</strong> 和 <strong>“数组的索引参数(在操作符<code>[]</code>中)”</strong> 的类型叫做<strong>：<code>size_type</code></strong></p><blockquote><p><strong><code>size_type</code>：</strong>由c++标准定义为<strong>无符号整数类型</strong>。</p></blockquote></li><li><p>我们的循环计数器/索引(变量i)是一个<strong>有符号整数</strong>。</p></li></ul><p>因此，在上面代码中的：<code>i &lt; myArray.size()</code> 与 <code>myArray[i]</code> 都出现了类型不匹配问题。</p><h2 id="siez-type是局部类型"><a href="#siez-type是局部类型" class="headerlink" title="siez_type是局部类型"></a><code>siez_type</code>是局部类型</h2><p>非常有趣的是，<code>size_type</code>不是一个全局类型(像int或std::size_t)。相反，<strong>它是在<code>std::array</code>的定义 中定义的(c++允许嵌套类型)。</strong></p><p>这意味着，当我们想要使用size_type时，我们必须在它前面加上完整的数组类型(在这方面，可以将<code>std::array</code>看作一个名称空间)。<strong>在上面的例子中，全前缀的“size_type”类型是<code>std::array::size_type</code>!</strong></p><p>所以，上面代码的正确写法为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; myArray =&#123; <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//std::array&lt;int,5&gt;::size_type 是函数size()的返回类型</span></span><br><span class="line">    <span class="comment">//因为std::array::size_type是std::size_t的别名（由上文可知），</span></span><br><span class="line">    <span class="comment">//所以，可以使用std::size_t来替换std::array::size_type（我这里就不替换了）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, <span class="number">5</span>&gt;::size_type i&#123; <span class="number">0</span> &#125;; i &lt; myArray.<span class="built_in">size</span>(); ++i)</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; myArray[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="避免手动索引数组"><a href="#避免手动索引数组" class="headerlink" title="避免手动索引数组"></a>避免手动索引数组</h2><p>更好的解决方案是首先避免对<code>std::array</code>进行手动索引。相反，如果可能的话，<strong>使用<a href="https://www.yuque.com/longlongqin/pw9qpx/na1me0#HYMtn" target="_blank" rel="noopener">基于范围的for循环</a>(或迭代器)。</strong></p><h1 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h1><p>当然std::array并不局仅仅限于<strong>数字</strong>作为元素的。可以在常规数组中使用的所有类型都可以在<code>std::array</code>中使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">House</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> number&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> stories&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> roomsPerStory&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;House, 3&gt; houses&#123;&#125;; <span class="comment">//⭐</span></span><br><span class="line"> </span><br><span class="line">    houses[<span class="number">0</span>] = &#123; <span class="number">13</span>, <span class="number">4</span>, <span class="number">30</span> &#125;;</span><br><span class="line">    houses[<span class="number">1</span>] = &#123; <span class="number">14</span>, <span class="number">3</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    houses[<span class="number">2</span>] = &#123; <span class="number">15</span>, <span class="number">3</span>, <span class="number">40</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; house : houses)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"House number "</span> &lt;&lt; house.number</span><br><span class="line">                  &lt;&lt; <span class="string">" has "</span> &lt;&lt; (house.stories * house.roomsPerStory)</span><br><span class="line">                  &lt;&lt; <span class="string">" rooms\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">House number <span class="number">13</span> has <span class="number">120</span> rooms</span><br><span class="line">House number <span class="number">14</span> has <span class="number">30</span> rooms</span><br><span class="line">House number <span class="number">15</span> has <span class="number">120</span> rooms</span><br></pre></td></tr></table></figure><h2 id="错误的初始化"><a href="#错误的初始化" class="headerlink" title="错误的初始化"></a>错误的初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Doesn't work.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;House, 3&gt; houses&#123;</span><br><span class="line">    &#123; <span class="number">13</span>, <span class="number">4</span>, <span class="number">30</span> &#125;,</span><br><span class="line">    &#123; <span class="number">14</span>, <span class="number">3</span>, <span class="number">10</span> &#125;,</span><br><span class="line">    &#123; <span class="number">15</span>, <span class="number">3</span>, <span class="number">40</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正确的初始化"><a href="#正确的初始化" class="headerlink" title="正确的初始化"></a>正确的初始化</h2><blockquote><p>注：⭐结构体数组的初始化还是不太明白，等后面再继续完善⭐</p><p>—–2020-05-02 10:39:32</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">House</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> number&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> stories&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> roomsPerStory&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    House value[<span class="number">3</span>]&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// With braces, this works.⭐（正确的初始化）</span></span><br><span class="line">    Array houses&#123;</span><br><span class="line">        &#123; &#123; <span class="number">13</span>, <span class="number">4</span>, <span class="number">30</span> &#125;, &#123; <span class="number">14</span>, <span class="number">3</span>, <span class="number">10</span> &#125;, &#123; <span class="number">15</span>, <span class="number">3</span>, <span class="number">40</span> &#125; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; house : houses.value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"House number "</span> &lt;&lt; house.number</span><br><span class="line">                  &lt;&lt; <span class="string">" has "</span> &lt;&lt; (house.stories * house.roomsPerStory)</span><br><span class="line">                  &lt;&lt; <span class="string">" rooms\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><code>std::array</code>是内置固定数组的一个很好的替代品。它是有效的，因为它不比内置的固定数组使用更多的内存。</p><p>唯一的缺点<code>std::array</code>在内置的固定数组是一个略微尴尬的语法,<strong>你必须显式地指定数组长度(编译器不会为你计算它的初始化,除非你还省略了类型</strong>)，</p><p>所以，一般建议使用<code>std::array</code>来替代内置类型的固定长度数组。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指向指针的指针与动态多维数组</title>
      <link href="/archives/5937092e.html"/>
      <url>/archives/5937092e.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapterP</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h1 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h1><p><strong>表示保存另一个指针地址的指针。</strong></p><p>一个普通的指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr; <span class="comment">//指向整数的指针，一个星号</span></span><br></pre></td></tr></table></figure><p>指向指针的指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> **ptr; <span class="comment">//一个指向整型的指针，两个星号</span></span><br></pre></td></tr></table></figure><hr><h2 id="“指向指针的指针”的解引用"><a href="#“指向指针的指针”的解引用" class="headerlink" title="“指向指针的指针”的解引用"></a>“指向指针的指针”的解引用</h2><p>指向指针的指针的工作方式与普通指针一样—可以对它解引用以检访问它指向的值。</p><ul><li>由于指向指针的指针的值是另一个指针的<strong>地址</strong>，所以<u>第一次</u>解引用后 访问的值 是一个地址；</li><li>你还可以再一次的 解引用，<u>第二次</u>的解引用之后 访问的就是一个值（不再是地址了）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *ptr = &amp;value;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *ptr; <span class="comment">//解引用指向int类型的指针ptr，来访问该int值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> **ptrptr = &amp;ptr;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; **ptrptr; </span><br><span class="line"><span class="comment">//第一个解引用获取指向int的指针，第二个解引用获取int值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="不可以将“指向指针的指针”直接指向值"><a href="#不可以将“指向指针的指针”直接指向值" class="headerlink" title="不可以将“指向指针的指针”直接指向值"></a>不可以将“指向指针的指针”直接指向值</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> **ptrptr = &amp;&amp;value; </span><br><span class="line"><span class="comment">//✖，因为取地址符(&amp;)需要的是 左值(l-value)，但是 &amp;value 是一个 右值(r-value)</span></span><br></pre></td></tr></table></figure><h2 id="“指向指针的指针”可以被设置为null"><a href="#“指向指针的指针”可以被设置为null" class="headerlink" title="“指向指针的指针”可以被设置为null"></a>“指向指针的指针”可以被设置为null</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> **ptrptr = <span class="literal">nullptr</span>; <span class="comment">////在c++ 11之前使用0</span></span><br></pre></td></tr></table></figure><hr><h1 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h1><p>指针的指针有几个用途。最常见的用法是<strong>动态分配指针数组</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* <span class="built_in">array</span> = <span class="keyword">new</span> <span class="keyword">int</span>*[<span class="number">10</span>]; <span class="comment">//分配一个有10个int型指针数组</span></span><br></pre></td></tr></table></figure><blockquote><p>这就像一个标准的动态分配数组，除了数组元素的类型是“<strong>指向整型的指针</strong>”，而不是 <strong>整数</strong>。</p></blockquote><h2 id="二维动态数组的分配"><a href="#二维动态数组的分配" class="headerlink" title="二维动态数组的分配"></a>二维动态数组的分配</h2><p>指针到指针的另一个常见用法是用于：<strong>动态分配多维数组</strong></p><blockquote><p>固定长度的二维数组的声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>][<span class="number">5</span>];</span><br></pre></td></tr></table></figure></blockquote><p>二维动态数组的分配有点复杂。你第一时间可能会想到这样写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> **<span class="built_in">array</span> = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][<span class="number">5</span>]; <span class="comment">//✖。</span></span><br></pre></td></tr></table></figure><p>正确方式：这里有两个可能的解决方案。</p><h3 id="1、最右边的数组维度是编译时常量"><a href="#1、最右边的数组维度是编译时常量" class="headerlink" title="1、最右边的数组维度是编译时常量"></a>1、最右边的数组维度是编译时常量</h3><ul><li><p>当<strong><u>最右边</u>的数组维度是编译时常量</strong>，可以这样做:</p><blockquote><p>最右边的数组维度是编译时常量：比如：a[ ] [5]，它数组中最右边的维度是确定的（5）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*<span class="built_in">array</span>)[<span class="number">5</span>] = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">10</span>][<span class="number">5</span>];</span><br><span class="line"><span class="comment">//小括号不能少，因为优先级的关系呀</span></span><br></pre></td></tr></table></figure><p>在C++11及之后，<strong>更推荐使用<code>auto</code>类型：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> <span class="built_in">array</span> = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][<span class="number">5</span>];</span><br></pre></td></tr></table></figure></li></ul><h3 id="2、最右边的数组的维度不是编译时常量时"><a href="#2、最右边的数组的维度不是编译时常量时" class="headerlink" title="2、最右边的数组的维度不是编译时常量时"></a>2、最右边的数组的维度不是编译时常量时</h3><ul><li><p>当最右边的数组的维度不是编译时常量时，就比较复杂了，我们需要：</p><ul><li>首先，我们分配一个指针数组；</li><li>然后，我们遍历指针数组并为每个数组元素分配一个动态数组。</li></ul><blockquote><p>我们的动态二维数组是一个动态一维数组的动态一维数组。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> **<span class="built_in">array</span> = <span class="keyword">new</span> <span class="keyword">int</span>*[<span class="number">10</span>]; <span class="comment">//分配一个包含10个整型指针的数组——这些是我们的行</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="built_in">array</span>[i] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];  <span class="comment">//这是我们的列</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><hr><p>注意，<strong>因为每个数组列是独立动态分配的，所以每一行的列数可以不一样呀：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> **<span class="built_in">array</span> = <span class="keyword">new</span> <span class="keyword">int</span>*[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">array</span>[i] = <span class="keyword">new</span> <span class="keyword">int</span>[i+<span class="number">1</span>];  <span class="comment">//这是我们的列（⭐这里的每一行的列数都不一样）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="释放动态二维数组"><a href="#释放动态二维数组" class="headerlink" title="释放动态二维数组"></a>释放动态二维数组</h4><p>使用这种方法释放一个动态分配的二维数组也需要一个循环:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    <span class="keyword">delete</span>[] <span class="built_in">array</span>[i];</span><br><span class="line"><span class="keyword">delete</span>[] <span class="built_in">array</span>; <span class="comment">//这需要放在最后</span></span><br></pre></td></tr></table></figure><p>注意，我们删除数组的顺序与创建它的顺序相反(<strong>首先是元素，然后是数组本身</strong>)。</p><blockquote><p>如果我们先删除数组，再去删除数组元素时，<strong>会导致未定义行为</strong>。因为我们在删除数组元素时必须访问数组，才知道每个数组元素。但是此时，我们早已经删除了数组，就会发生未定义行为。</p></blockquote><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>我们建议避免使用指针到指针，除非没有其他可用的选项，因为它们使用起来很复杂，而且有潜在的危险。使用普通指针来解引用空指针或悬空指针是非常容易的—使用指针来解引用指针是非常容易的，因为您必须执行两次解引用才能获得底层的值!</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>void 指针</title>
      <link href="/archives/f482f5a8.html"/>
      <url>/archives/f482f5a8.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapterP</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h2 id="void指针的声明"><a href="#void指针的声明" class="headerlink" title="void指针的声明"></a>void指针的声明</h2><p><strong>void指针</strong>，也称为“<strong>泛型指针</strong>”。</p><p>是指针的一种特殊类型，<strong>它可以指向任何数据类型的对象</strong>!</p><p>void指针像普通指针一样声明，<strong>使用<code>void</code>关键字作为指针的类型</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *ptr;</span><br></pre></td></tr></table></figure><h2 id="void指针可以指向任何数据类型的对象"><a href="#void指针可以指向任何数据类型的对象" class="headerlink" title="void指针可以指向任何数据类型的对象:"></a>void指针可以指向任何数据类型的对象:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nValue;</span><br><span class="line"><span class="keyword">float</span> fValue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">something sValue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *ptr;</span><br><span class="line">ptr = &amp;nValue; <span class="comment">//✔</span></span><br><span class="line">ptr = &amp;fValue; <span class="comment">//✔</span></span><br><span class="line">ptr = &amp;sValue; <span class="comment">//✔</span></span><br></pre></td></tr></table></figure><h2 id="void指针不能被-解引用"><a href="#void指针不能被-解引用" class="headerlink" title="void指针不能被 解引用"></a>void指针不能被 解引用</h2><p><strong>但是，因为<code>void</code>指针不知道它所指向的对象的类型，所以不能直接解引用！</strong></p><p><strong>相反，<code>void</code>指针必须先显式地转换为另一种指针类型，然后才能解引用。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value &#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">void</span> *voidPtr &#123;&amp;value&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//⭐✖，void指针 不能 解引用</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *voidPtr &lt;&lt; <span class="string">'\n'</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//⭐✔，我们可以将void指针 类型转换为 其他指针类型(这里是 int型指针)，</span></span><br><span class="line"><span class="keyword">int</span> *intPtr &#123;<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(voidPtr)&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *intPtr; <span class="comment">////然后就可以 解引用 了</span></span><br></pre></td></tr></table></figure><h2 id="一个明显的问题"><a href="#一个明显的问题" class="headerlink" title="一个明显的问题"></a>一个明显的问题</h2><p>当void指针不知道指向什么，我们如何转换类型，<strong>这取决于程序猿的设定</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    INT,</span><br><span class="line">    FLOAT,</span><br><span class="line">    CSTRING</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printValue</span><span class="params">(<span class="keyword">void</span> *ptr, Type type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//转换为整型指针 并 解引用</span></span><br><span class="line">        <span class="keyword">case</span> Type::INT:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;* <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(ptr)&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">     <span class="comment">//转换为float指针 并 解引用</span></span><br><span class="line">        <span class="keyword">case</span> Type::FLOAT:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;* <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>*&gt;(ptr)&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//转换为char指针  但 没有解引用⭐</span></span><br><span class="line">        <span class="keyword">case</span> Type::CSTRING:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;  <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(ptr)&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">        <span class="comment">//std::cout知道将char*作为c风格的字符串</span></span><br><span class="line">        <span class="comment">//如果我们要解引用的话，那就只会打印ptr所指向的单个字符</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nValue&#123; <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">float</span> fValue&#123; <span class="number">7.5f</span> &#125;;</span><br><span class="line">    <span class="keyword">char</span> szValue[]&#123; <span class="string">"Mollie"</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    printValue(&amp;nValue, Type::INT);</span><br><span class="line">    printValue(&amp;fValue, Type::FLOAT);</span><br><span class="line">    printValue(&amp;szValue, Type::CSTRING);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://raw.githubusercontent.com/longlongqin/CDN-for-HEXO_BLOG/pig_bed/20200501172041.png" alt="image-20200501171859945"></p><blockquote><p>如果，我们将第26行改为：<code>std::cout &lt;&lt;* static_cast&lt;char*&gt;(ptr)&lt;&lt;&#39;\n&#39;;</code>（即，让它 解引用）。</p><p>结果：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://raw.githubusercontent.com/longlongqin/CDN-for-HEXO_BLOG/pig_bed/20200501172049.png" alt="image-20200501172026127"></p><p>可以看到：如果我们要解引用的话，那就只会打印<code>ptr</code>所指向的单个字符</p></blockquote><h2 id="void指针可以指向空值-nullptr"><a href="#void指针可以指向空值-nullptr" class="headerlink" title="void指针可以指向空值(nullptr)"></a>void指针可以指向空值(nullptr)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *ptr&#123;<span class="literal">nullptr</span>&#125;;</span><br></pre></td></tr></table></figure><h2 id="void指针不能做指针运算"><a href="#void指针不能做指针运算" class="headerlink" title="void指针不能做指针运算"></a>void指针不能做指针运算</h2><p><strong>因为指针运算需要知道 指针指向的对象的大小，但是void指针就不知道它指向的是什么。</strong>所以void指针不能做指针运算（如：++，–）</p><h2 id="不存在void引用"><a href="#不存在void引用" class="headerlink" title="不存在void引用"></a>不存在void引用</h2><p>因为一个“void reference”的类型是“<strong><code>void &amp;</code></strong>”,但是它不知道它引用的值的类型。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="1-除非必要，否则避免使用void指针"><a href="#1-除非必要，否则避免使用void指针" class="headerlink" title="1.除非必要，否则避免使用void指针"></a>1.除非必要，否则避免使用void指针</h3><p>通常，<strong>除非绝对必要，否则避免使用void指针是一个好主意</strong>，因为它们有效地允许您避免类型检查。这允许您在不经意间做一些毫无意义的事情，而编译器也不会抱怨。例如，以下内容是有效的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//承接上面那段函数</span></span><br><span class="line"><span class="keyword">int</span> nValue&#123; <span class="number">5</span> &#125;;</span><br><span class="line">printValue(&amp;nValue, Type::CSTRING);</span><br></pre></td></tr></table></figure><p>它的结果是未知的，在我的电脑上，结果为：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://raw.githubusercontent.com/longlongqin/CDN-for-HEXO_BLOG/pig_bed/20200501173336.png" alt="image-20200501173230056"></p><hr><h3 id="2-void指针与null指针的区别"><a href="#2-void指针与null指针的区别" class="headerlink" title="2.void指针与null指针的区别"></a>2.void指针与null指针的区别</h3><ul><li><p><strong>void指针</strong>：</p><ul><li><p>是一个指针，它可以指向任何类型的对象，但不知道它指向什么类型的对象。</p></li><li><p>空指针必须被显式地转换成另一种确切的类型的指针才能 解引用。</p></li></ul></li><li><p><strong>null指针</strong>：</p><ul><li>空指针是不指向地址的指针。</li></ul></li></ul><p><strong>void指针</strong>可以是一个<strong>null指针</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过指针或引用访问结构体成员</title>
      <link href="/archives/7e63bcda.html"/>
      <url>/archives/7e63bcda.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapterP</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><p>众所周知，通常有一个<strong>指向结构(或类)的指针或引用</strong>。如前所述，您可以使用<strong>成员选择操作符(.)</strong>来选择结构体的成员:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line">Person person; <span class="comment">// define a person</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//person.age = 5;</span></span><br></pre></td></tr></table></figure><p>这个语法也适用于 引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line">Person person; <span class="comment">// define a person</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用对结构体的引用来选择成员</span></span><br><span class="line">Person &amp;ref = person;</span><br><span class="line">ref.age = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>但是，对于指针，您需要先解引用指针的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line">Person person; <span class="comment">// define a person</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用指向结构体的指针进行成员选择</span></span><br><span class="line">Person *ptr = &amp;person;</span><br><span class="line">(*ptr).age = <span class="number">5</span>; <span class="comment">//加小括号是必要的的，因为优先级的关系</span></span><br></pre></td></tr></table></figure><ul><li><p>c++提供了第二个成员选择操作符<strong>(-&gt;)</strong>，<strong>用于从指针进行成员选择</strong>。以下两行是相等的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*ptr).age = <span class="number">5</span>;</span><br><span class="line">ptr-&gt;age = <span class="number">5</span>;  <span class="comment">//当使用指针来访问其成员时，推荐这种语法</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>引用与const</title>
      <link href="/archives/960f81eb.html"/>
      <url>/archives/960f81eb.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapterP</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h2 id="引用const值"><a href="#引用const值" class="headerlink" title="引用const值"></a>引用const值</h2><p>就像可以声明指向const值的指针一样，也可以声明对const值的引用。这是通过使用const关键字声明引用来实现的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ref = value; <span class="comment">//ref是对const值的引用</span></span><br></pre></td></tr></table></figure><p>对const值的引用通常被简称为<strong>const引用</strong>，尽管这确实导致了一些与指针不一致的命名法。</p><h2 id="初始化对const值的引用"><a href="#初始化对const值的引用" class="headerlink" title="初始化对const值的引用"></a>初始化对const值的引用</h2><p>对非const值的引用，只能用非const l-value 初始化；</p><p>⭐而对const值的引用，可以用 “<strong>非const l-value</strong>”、“<strong>constl-value</strong>”、“<strong>r-value</strong>”来初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ref1 = x; <span class="comment">//✔，x是一个  非const l-value</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> y =<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ref2 =y;  <span class="comment">//✔，y是一个const l-value</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ref3 = <span class="number">19</span>; <span class="comment">//✔，19是一个 r-value</span></span><br></pre></td></tr></table></figure><h2 id="对const值的引用可以引用非const变量"><a href="#对const值的引用可以引用非const变量" class="headerlink" title="对const值的引用可以引用非const变量"></a>对const值的引用可以引用非const变量</h2><p>就像指向 const值 的指针一样，<strong>对const值的引用可以引用非const变量</strong>。</p><blockquote><p>其实就是说：不管你这个值原来是const值，还是 非const值。只用看我这个“引用”（或者 “指针”）是不是 对const值的引用（或者：是不是指向const值），如果是，那么不管你原来的值是不是const值，在我引用（指针指向）之后，我都把它看成是const值。</p></blockquote><blockquote><p>关于如何判断一个引用是否引用的是const值，的方法类似于指针中的方法：</p><p><strong>就是看那个表示引用的符号“&amp;”的左边，如果左边带有关键字const，那么它就是引用的const值。</strong></p></blockquote><h2 id="对r-value的引用延长了引用值的生存期"><a href="#对r-value的引用延长了引用值的生存期" class="headerlink" title="对r-value的引用延长了引用值的生存期"></a>对r-value的引用延长了引用值的生存期</h2><p>通常r-value具有表达式作用域<strong>，这意味着在创建它们的表达式结束时销毁这些值。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="number">2</span>+<span class="number">3</span>;  <span class="comment">//2+3 的结果是 r-value 5，它会在该条语句结束时，被销毁</span></span><br></pre></td></tr></table></figure><p>但是，当使用r-value 初始化<strong>对const值的引用</strong>时，r-value的生存期将被延长为 <strong>引用的生存期。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dothing</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;ref = <span class="number">2</span>+<span class="number">3</span>; </span><br><span class="line"><span class="comment">//通常，2+3的结果具有表达式作用域，并在语句结束时销毁.</span></span><br><span class="line"><span class="comment">//但是因为 2+3的结果现在已经被绑定到一个 对const值的引用  上面了，</span></span><br><span class="line"><span class="comment">//所这个r-value的生命周期被延长了</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ref; <span class="comment">//我们在这还可以用它</span></span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">//当const引用终止时，r-value的生存期被延长到这里</span></span><br></pre></td></tr></table></figure><h2 id="const值的引用作为函数参数"><a href="#const值的引用作为函数参数" class="headerlink" title="const值的引用作为函数参数"></a>const值的引用作为函数参数</h2><p>用作函数参数的引用也可以是常量。这允许我们在<strong>不复制实参</strong>的情况下访问参数，同时保证函数不会改变被引用的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ref是传入参数的const引用，而不是副本</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changN</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;ref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ref = <span class="number">6</span>; <span class="comment">//✖，因为ref是 const</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>const值的引用作为函数参数很有用。因为const值的引用，可以是：</p><ul><li>non-const l-value</li><li>const l-value</li><li>a literal</li><li>表达式的结果</li></ul><p>所以，上面这四种可以通过 const值的引用 被传入函数参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printIt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a =<span class="number">1</span>;</span><br><span class="line">    printIt(a);  <span class="comment">//非const l-value</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    printIt(b);  <span class="comment">//const l-value</span></span><br><span class="line">    </span><br><span class="line">    printIt(<span class="number">3</span>);  <span class="comment">//字面常量 r-value</span></span><br><span class="line">    </span><br><span class="line">    printIt(<span class="number">2</span>+b);  <span class="comment">//表达式 r-value</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>1、为了避免不必要的、代价昂贵的复制，通常应该通过(const)引用传递</p><ul><li>非指针</li><li>非 基本数据类型(int、double等)的变量。（如structs等，可通过 引用 传入函数）</li></ul><p>2、基本数据类型应该通过<strong>值传递</strong>，当函数需要更改它们时，才使用 引用 传入函数。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>引用变量</title>
      <link href="/archives/fa14c975.html"/>
      <url>/archives/fa14c975.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapterP</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><p>目前为止我们已经讲过两种基本变量类型：</p><ul><li>普通变量，直接保存值。</li><li>指针，它持有另一个值的地址(或null)，可以解引用以获取它们指向的地址的值。</li></ul><p>现在，我们就来讲一下C++中的第三种基本类型：<strong>引用(Reference)</strong></p><h2 id="引用的概念"><a href="#引用的概念" class="headerlink" title="引用的概念"></a>引用的概念</h2><p><strong>reference（引用）</strong>是C++变量的一个类型，<strong>它充当另一个对象或值的别名</strong>。</p><h3 id="C-支持三种种引用"><a href="#C-支持三种种引用" class="headerlink" title="C++支持三种种引用"></a>C++支持三种种引用</h3><ol><li><strong>引用 非const值</strong>（通常简称“<strong>reference</strong>”，或 <strong>non-const reference</strong>）</li><li><strong>引用 const值</strong>（通常叫做：<strong>const reference</strong>）</li><li>C++11增添了 <strong>r-value reference</strong></li></ol><h2 id="引用非const值"><a href="#引用非const值" class="headerlink" title="引用非const值"></a>引用非const值</h2><p>引用(对非const值的引用) 是<strong>通过引用 “类型” 和”变量名”之间的<code>&amp;</code>来声明的</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value &#123;<span class="number">5</span>&#125;; <span class="comment">//普通变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面写法都是一样的的效果</span></span><br><span class="line"><span class="keyword">int</span> &amp; ref&#123;value&#125;; <span class="comment">//引用变量值</span></span><br><span class="line"><span class="keyword">int</span>&amp; ref&#123;value&#125;;</span><br><span class="line"><span class="keyword">int</span> &amp;ref&#123;value&#125;;</span><br></pre></td></tr></table></figure><h3 id="引用作为别名"><a href="#引用作为别名" class="headerlink" title="引用作为别名"></a>引用作为别名</h3><p>引用的作用通常与它们所引用的值相同。在这个意义上，<strong>引用充当被引用对象的别名</strong>。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x&#123;<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;y&#123;x&#125;; <span class="comment">//y是x的引用</span></span><br><span class="line"><span class="keyword">int</span> &amp;z&#123;y&#125;; <span class="comment">//z也是x的引用</span></span><br></pre></td></tr></table></figure><p>上面的代码片段。设置或获取x、y或z的值将做相同的事情(那就是设置或获取<strong>x的值</strong>)。</p><p>看一看引用的实际应用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value &#123;<span class="number">5</span>&#125;; <span class="comment">//普通的int型变量</span></span><br><span class="line">    <span class="keyword">int</span> &amp;ref&#123;value&#125;; <span class="comment">//引用变量value</span></span><br><span class="line">    </span><br><span class="line">    value = <span class="number">6</span>; <span class="comment">//变量value 的值现在是6</span></span><br><span class="line">    ref = <span class="number">7</span>; <span class="comment">//变量value 的值现在是7</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;value&lt;&lt;<span class="string">'\n'</span>; <span class="comment">//结果为7</span></span><br><span class="line">    ++ref;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;value&lt;&lt;<span class="string">'\n'</span>; <span class="comment">//结果为8</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//看一看：value 和 ref的地址</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; &amp;value;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; &amp;ref;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">006F</span>FD30</span><br><span class="line"><span class="number">006F</span>FD30</span><br></pre></td></tr></table></figure><p>在上面的例子中，ref和value被视为是相同的。(可以看到ref和value的地址都是一样的)。</p><h2 id="l-values-and-r-values"><a href="#l-values-and-r-values" class="headerlink" title="l-values and r-values"></a>l-values and r-values</h2><blockquote><p>l-values and r-values：<strong>左值</strong> 与 <strong>右值</strong></p></blockquote><h3 id="左值"><a href="#左值" class="headerlink" title="左值"></a>左值</h3><p>在C++中，<strong>变量</strong>是<strong>l-value（左值）</strong>的一种类型；左值是一个<strong>有地址</strong>的值(在内存中)。</p><p>因为所有的<strong>变量</strong>都<strong>有地址</strong>，所以所有的变量都<strong>是左值</strong>。</p><p>之所以称为<strong>l-value</strong>，是因为<strong>l-value</strong>是<strong>赋值语句左边惟一的值</strong>。当我们赋值时，赋值操作符的左边必须是<strong>I-value</strong>。</p><blockquote><p>所以，像这种句子： <code>5 = 6;</code>将会造成编译错误，因为5不是I-value。字面值5是没有地址的（即，它不在内存中）。</p></blockquote><p>当一个<strong>I-value</strong>被赋值时，该内存地址的当前值将被覆盖。</p><h3 id="右值"><a href="#右值" class="headerlink" title="右值"></a>右值</h3><p>与<strong>l-value</strong>相反的是<strong>r-value</strong>。<strong>r-value</strong>是一个非<strong>l-value</strong>的表达式。</p><blockquote><p><strong>r-value</strong>的例子有字面值(比如<code>5</code>，结果是5)和非<strong>l-value</strong>的表达式(比如 <code>2 + x</code>)。</p></blockquote><p>下面是一些例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> y; <span class="comment">//将y定义为一个整型变量</span></span><br><span class="line">y=<span class="number">4</span>;<span class="comment">//4 的结果是4，然后赋值给y</span></span><br><span class="line">y=<span class="number">2</span>+<span class="number">5</span>;  <span class="comment">//2+5 的结果是7，然后赋值给y</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x; <span class="comment">//将x定义为一个整型变量</span></span><br><span class="line">x=y;<span class="comment">//y的值是7(之前的值)，然后赋值给x。</span></span><br><span class="line">x=x;<span class="comment">//x的结果是7，然后赋值给x(没用!)</span></span><br><span class="line">x=x+<span class="number">1</span>;  <span class="comment">//x + 1 的结果等于8，然后赋值给x。</span></span><br></pre></td></tr></table></figure><h4 id="分析：x-x-1"><a href="#分析：x-x-1" class="headerlink" title="分析：x=x+1"></a>分析：<code>x=x+1</code></h4><p><code>x=x+1;</code>这个语句看起来很迷糊。</p><ul><li><p>赋值操作符“=” 左边的“x”是一个I-value（有地址的变量）；</p></li><li><p>赋值操作符“=” 右边的“x”是一个r-value，它将被计算并生成一个值（这里生成的值为7）。</p></li></ul><p>当c++对上述语句求值时，它的计算结果为:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">7</span> + <span class="number">1</span>; <span class="comment">//这样就比较清晰了</span></span><br></pre></td></tr></table></figure><p>其实，可以分析为：</p><p>在赋值操作符“=”的<strong>左侧</strong>，<strong>必须有表示内存地址的内容(例如变量)。</strong></p><p>赋值操作符“=”的<strong>右侧 的所有内容都将被计算以生成一个值。</strong></p><h2 id="引用必须被初始化"><a href="#引用必须被初始化" class="headerlink" title="引用必须被初始化"></a>引用必须被初始化</h2><p>创建引用时必须初始化:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value &#123;<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;a &#123;value&#125;; <span class="comment">//有效的引用，初始化为变量value</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;b; <span class="comment">//无效，因为没有被初始化</span></span><br></pre></td></tr></table></figure><p><strong>不像指针可以持有空值，没有空引用这样的东西。</strong></p><h3 id="引用-非const值-只能被初始化为非const-的左值"><a href="#引用-非const值-只能被初始化为非const-的左值" class="headerlink" title="引用 非const值 只能被初始化为非const 的左值"></a>引用 非const值 只能被初始化为非const 的左值</h3><p>对非const值的引用<strong>只能用非const l-value 初始化</strong>。不能使用<strong>const l-value</strong>或<strong>r-value</strong>初始化它们。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x&#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;a&#123;x&#125;; <span class="comment">//✔，因为x是一个非常量的左值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;b&#123;x+<span class="number">1</span>&#125;; <span class="comment">//✖，因为"x+1"是一个右值（它没有地址的）⭐</span></span><br><span class="line"><span class="keyword">int</span> &amp;d&#123;<span class="number">6</span>&#125;;   <span class="comment">//✖，因为6是一个右值⭐</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> y&#123;<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> &amp;c&#123;y&#125;;    <span class="comment">//✖，因为y是一个 常量左值（**const l-value**）⭐</span></span><br></pre></td></tr></table></figure><h2 id="引用不能被重新分配"><a href="#引用不能被重新分配" class="headerlink" title="引用不能被重新分配"></a>引用不能被重新分配</h2><p><strong>初始化后，不能将引用更改为引用另一个变量</strong>。考虑以下片段:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value1&#123;<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> value2&#123;<span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;a&#123;value1&#125;; <span class="comment">//✔，ref现在是value1的别名</span></span><br><span class="line"></span><br><span class="line">ref = vlaue2; <span class="comment">//注意⭐：这里value2其实是一个右值。执行这个语句：就是将value2的值赋给value1。.  而不是将引用重新分配称为变量value2的别名呀~~~</span></span><br></pre></td></tr></table></figure><p>为了说明上面的那个语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; //std::sort</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123; <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> y&#123; <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x原来的值是："</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;a&#123; x &#125;;</span><br><span class="line">    a = y;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"引用a的值是："</span> &lt;&lt; a&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x现在的值为："</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"因为引用‘a’是x的别名，a的值改变，所以x的值也会被改变"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://raw.githubusercontent.com/longlongqin/CDN-for-HEXO_BLOG/pig_bed/20200430231138.png" alt="1"></p><h2 id="引用作为函数参数"><a href="#引用作为函数参数" class="headerlink" title="引用作为函数参数"></a>引用作为函数参数</h2><p>在<a href="http://www.learncpp.com/cpp-tutorial/6-8-pointers-and-arrays/" target="_blank" rel="noopener">6.8 – Pointers and arrays</a> 中，我们讨论了如何将指针参数传递给函数，使函数可以取消对指针的引用，<strong>从而直接修改参数的值。</strong></p><p>引用在这方面的工作类似。<strong>由于“引用”参数作为参数的别名，使用“引用”参数的函数可以修改传入的参数:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ref是传入参数的 引用，而不是副本</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeN</span> <span class="params">(<span class="keyword">int</span> &amp;ref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ref = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n&#123;<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    changeN(n); <span class="comment">//注意，这个参数不需要作为引用</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span>  ⭐这里n的值变了呀</span><br></pre></td></tr></table></figure><p>当实参n被传递给函数时，<strong>函数参数ref被设置为参数n的引用</strong>。</p><h2 id="使用引用将c风格的数组传递给函数"><a href="#使用引用将c风格的数组传递给函数" class="headerlink" title="使用引用将c风格的数组传递给函数"></a>使用引用将c风格的数组传递给函数</h2><p>c风格数组最恼人的问题之一是，在大多数情况下，当求值时，<strong>它们会退化为指针</strong>。</p><p>但是，如果通过引用传递c样式的数组，则不会发生这种退化。</p><blockquote><p>请注意，为了使其工作，<strong>您需要显式地在参数中定义数组大小</strong>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意:您需要在函数声明中指定数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printElements</span><span class="params">(<span class="keyword">int</span> (&amp;arr)[<span class="number">4</span>]  )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果不支持C++17时，请改下面的语句（https://www.yuque.com/longlongqin/pw9qpx/dhwiyd#31df8e7e）</span></span><br><span class="line">    <span class="keyword">int</span> length &#123;<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">std</span>::<span class="built_in">size</span>(arr))&#125;; <span class="comment">//我们可以这样做，因为数组不会退化为指针</span></span><br><span class="line"><span class="comment">//数组退化为指针可参考（https://www.yuque.com/longlongqin/pw9qpx/pmqm1f#Oaepi）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i&#123;<span class="number">0</span>&#125;; i&lt;length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;arr[i]&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[]&#123; <span class="number">99</span>, <span class="number">20</span>, <span class="number">14</span>, <span class="number">80</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    printElements(arr);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用和指针"><a href="#引用和指针" class="headerlink" title="引用和指针"></a>引用和指针</h2><p>引用和指针之间有一种有趣的关系——<strong>引用就像一个指针，在被访问时被隐式地解引用</strong>(引用通常由编译器使用指针在内部实现)。从而得出以下结论:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value &#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> ptr &#123;&amp;value&#125;;</span><br><span class="line"><span class="keyword">int</span> &amp;ref &#123;value&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以看到：下面两个语句是相同的：</span></span><br><span class="line">*ptr = <span class="number">5</span>;</span><br><span class="line">ref = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>由于必须将引用初始化为有效的对象(不能为空)，并且一旦设置就不能更改，因此使用引用通常比使用指针安全得多(因为没有取消引用空指针的风险)。</p><p>如果给定的任务可以通过引用或指针来解决，那么通常应该首选引用。指针应该只在引用不足的情况下使用(比如动态分配内存)。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>引用</strong>允许我们为其他对象或值定义<strong>别名</strong>。对<strong>非const值</strong>的引用只能用<strong>非const l-value</strong>初始化。<strong>引用初始化后不能重新分配（也就是它初始化之后，就一直是那个变量的别名）</strong>。</p><p><strong>当我们想要修改参数的值时</strong>，或者<strong>当我们想要避免对参数进行昂贵的复制时</strong>，引用通常被用作函数参数。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针与const</title>
      <link href="/archives/d0ade39e.html"/>
      <url>/archives/d0ade39e.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapterP</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><em>注：此文中的类型以int为例，当然也可以换成其他类型，如：double…..</em></p><h2 id="非const指针"><a href="#非const指针" class="headerlink" title="非const指针"></a>非const指针</h2><h3 id="1、int-ptr"><a href="#1、int-ptr" class="headerlink" title="1、int *ptr"></a>1、<code>int *ptr</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *ptr = &amp;value; <span class="comment">//类型转换错误。✖</span></span><br><span class="line"><span class="comment">//不能将“const int”类型（&amp;value）转换为“int *”（ptr）</span></span><br></pre></td></tr></table></figure><p>这很容易理解，假设上面片段可以编译成功。那也就是说，我们可以解引用这个非const的指针来改变这个值。这将会与const变量本质冲突（const的变量的值是不可以更改的）。</p><h3 id="2、const-int-ptr"><a href="#2、const-int-ptr" class="headerlink" title="2、const int *ptr"></a>2、<code>const int *ptr</code></h3><p>若要声明指向const值的指针，请在<strong>数据类型之前使用const</strong>关键字:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> value = <span class="number">5</span>; <span class="comment">//一个int类型的变量value（值为5），value是"const int"</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *ptr = &amp;value; <span class="comment">//✔，ptr是一个非const的指针，它指向一个“const int”</span></span><br><span class="line">*ptr = <span class="number">6</span>;  <span class="comment">//不允许，我们不能改变一个常量值</span></span><br></pre></td></tr></table></figure><p>在这里，不允许通过解引用指针 来改变value的值。<em>ptr是一个非const的指针，它指向一个“const int”</em> 就说明了，指针指向的是常量值，不能改变的奥</p><h4 id="指向const-int-的指针，也可以指向非常量变量"><a href="#指向const-int-的指针，也可以指向非常量变量" class="headerlink" title="指向const int 的指针，也可以指向非常量变量"></a>指向const int 的指针，也可以指向非常量变量</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = <span class="number">5</span>; <span class="comment">//value 不是常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *ptr = &amp;value; <span class="comment">//这样也是可以的</span></span><br></pre></td></tr></table></figure><p>我们可以这样想：</p><p><strong>一个指向const变量的指针</strong>在<strong>通过该指针访问</strong>该变量时将该变量<strong>视为常量</strong>，<strong>而不管变量最初是否定义为const(即，与变量最初是否为const无关)。</strong></p><blockquote><p>因为指向const值的<strong>指针</strong>不是const本身(<strong>它只是指向一个const值</strong>)，<strong>所以可以将指针重定向到指向其他值:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *ptr = &amp;value1; <span class="comment">// ptr points to a const int</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> value2 = <span class="number">6</span>;</span><br><span class="line">ptr = &amp;value2; <span class="comment">// ✔, ptr now points at some other const int</span></span><br></pre></td></tr></table></figure></blockquote><p>当指向const int 的指针，它指向非const变量时：</p><ul><li><strong>不可以</strong>通过 <strong>解引用该指针 来改变该非常量变量的值</strong>；</li><li><strong>但可以</strong>通过 <strong>直接对通过 变量的标识符 来改变该非常量变量的值</strong>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以</span></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *ptr = &amp;value;</span><br><span class="line">value = <span class="number">6</span>; <span class="comment">//✔。因为当通过非const标识符（value是非const的标识符）访问时，</span></span><br><span class="line"><span class="comment">//该值是非const的（所以我们可以直接通过变量的标识符来改变其值）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不可以</span></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *ptr = &amp;value; <span class="comment">// ptr points to a "const int"</span></span><br><span class="line">*ptr = <span class="number">6</span>; <span class="comment">// ✖。因为指针ptr将其值视为常量，因此通过ptr更改值是不合法的</span></span><br></pre></td></tr></table></figure><hr><h2 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a>const指针</h2><p>const指针是指<strong>初始化后</strong>其值（即，它指向的地址）不能改变的指针。</p><blockquote><p>也就是说，const指针：</p><ul><li>只不过是该指针的值（它的值就是一个地址）不能被改变。（即，它只能指向初始化时给定的变量）</li><li>但是，它指向变量的值是可以被修改的。</li></ul></blockquote><h3 id="声明const指针"><a href="#声明const指针" class="headerlink" title="声明const指针"></a>声明const指针</h3><p>要声明一个const指针，<strong>请在”星号”和”指针名称”之间使用const关键字</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> ptr = &amp;value;</span><br></pre></td></tr></table></figure><p><strong>与普通的const变量一样，const指针必须在声明时初始化为一个值</strong></p><p><strong>这意味着const指针总是指向相同的地址</strong>。</p><blockquote><p>在上述情况下，ptr将始终指向value的地址(直到ptr goes out of scope并被销毁)。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a =<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> b =<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> ptr = &amp;a; <span class="comment">//✔，这个const指针被初始化为变量a的地址；</span></span><br><span class="line"></span><br><span class="line">ptr = &amp;b;  <span class="comment">//✖，因为指针ptr是const。所以它一旦被初始化之后，该指针的值（它指向的地址）就不能被改变。</span></span><br></pre></td></tr></table></figure><p>但是，由于所指向的<strong>值</strong>仍然是非const的，所以可以通过解引用 const指针的来更改所指向的值:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> ptr = &amp;value; <span class="comment">// ptr will always point to value</span></span><br><span class="line">*ptr = <span class="number">6</span>; <span class="comment">// ✔，因为ptr指向的是一个非const的int型变量</span></span><br></pre></td></tr></table></figure><h3 id="指向Const值的const指针"><a href="#指向Const值的const指针" class="headerlink" title="指向Const值的const指针"></a>指向Const值的const指针</h3><p>我们可以把它差分成两部分：</p><ul><li>首先是一个 const指针（假如是int类型，变量标识符为a）：<code>int * const a;</code>(将这一部分看成大写字母A)</li><li>然后是一个const的值：<code>const A</code> —–&gt;<strong><code>const int * const a;</code></strong></li></ul><p>也就是在：类型（type）之前 和 变量名之前 使用关键字<code>const</code> 来声明一个指向Const值的const指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> ptr = &amp;value;</span><br></pre></td></tr></table></figure><p>注意：</p><p>指向const值的const指针<strong>不能设置为指向另一个地址</strong>，<strong>它所指向的值也不能通过指针进行更改。</strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>《请记住：const类型的变量（不管是指针还是正常变量）的<strong>声明与初始化是在一起完成的</strong>。》</p><p>总而言之，你只需要记住4条规则，它们都很符合逻辑:</p><ol><li><p><strong>一个非const指针可以被重定向到其他地址。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value1 =<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *ptr1 = &amp;value1; <span class="comment">//是 非const指针。（它指向的是非const变量的地址）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> value2 =<span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *ptr2 = &amp;value2;<span class="comment">//也是 非const指针。（不过它指向的是 const变量的地址）</span></span><br></pre></td></tr></table></figure></li><li><p><strong>一个const指针在初始化之后，它指向的地址就不能被改变了。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> ptr =&amp;value; <span class="comment">//是 const指针。（它指向的是非const变量的地址）</span></span><br></pre></td></tr></table></figure></li><li><p><strong>指向非const值的指针可以更改它所指向的值。但是这些指针不能指向一个常量(const)值。</strong></p></li><li><p><strong>指向const值的const指针将该值视为const(即使它不是)，因此不能更改它所指向的值。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1️⃣指向const值的指针将该值视为const(该值不是const)</span></span><br><span class="line"><span class="keyword">int</span> value1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> ptr1 = &amp;value; <span class="comment">//ptr是一个指向const值的const指针，</span></span><br><span class="line"><span class="comment">//所以，它指向的这个value1的值是不能被改变的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2️⃣指向const值的指针将该值视为const(该值是const)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> value2 = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> ptr2 = &amp;value2; <span class="comment">//同样指针ptr2指向的value2的值也不能被改变</span></span><br></pre></td></tr></table></figure></li></ol><hr><p>保持声明语法的正确性是很有挑战性的。只要记住<strong>指针指向的值的类型总是在最左边</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *ptr1 = &amp;value; <span class="comment">//ptr1指向“const int”,这是一个指向const值的指针。</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> ptr2 = &amp;value; <span class="comment">//ptr2指向“int”,这是一个指向非const值的const指针。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> ptr3 = &amp;value; <span class="comment">//ptr3指向“const int” ,这是一个指向const值的const指针</span></span><br></pre></td></tr></table></figure><h3 id="图示："><a href="#图示：" class="headerlink" title="图示："></a>图示：</h3><blockquote><p>突然想到：</p><p>1、若要声明指向const值的指针，请在<strong>数据类型之前使用const</strong>关键字。（如下图的①、③）</p><p>2、下面的①、②、③都可以<strong>指向 “非const 值”；</strong></p><p>3、<strong>是否可以通过指针的解引用来改变指针所指向的值</strong>。需要看该指针指向的值 是“const int” 还是 “int”？</p><ul><li>如果是“const int”，那就不能 解引用指针 去改变它所指向的值。</li><li>如果是“int”，那就可以。</li></ul><p>4、一个<strong>指向const变量的指针</strong>在通过该指针访问该变量时将该变量<strong>视为常量(const)</strong>，而不管变量最初是否定义为const (即，与变量最初是否为const无关)。</p><p>5、当<strong>指向“const int” 的指针</strong>，它指向非const变量时：</p><ul><li><strong>不可以</strong>通过 <strong>解引用该指针 来改变该非常量变量的值</strong>；</li><li><strong>但可以</strong>通过 <strong>直接对通过 变量的标识符 来改变该非常量变量的值</strong>。</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://raw.githubusercontent.com/longlongqin/CDN-for-HEXO_BLOG/pig_bed/20200430172652.jpg" alt="IMG_20200430_172308"></p><p><strong>再次提醒：本文只是以“int”类型来作为说明，我们可以换成其他类型，如：double等等</strong></p><h3 id="用一个程序来说明："><a href="#用一个程序来说明：" class="headerlink" title="用一个程序来说明："></a>用一个程序来说明：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/************非const的变量***************/</span></span><br><span class="line">    <span class="keyword">int</span> value1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> value2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> value3 = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> value4 = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">int</span> *ptr1 = &amp;value1;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *ptr2 = &amp;value2;</span><br><span class="line">    <span class="keyword">int</span> * <span class="keyword">const</span> ptr3 = &amp;value3;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> ptr4 = &amp;value4;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过指针的解引用，改变变量的值</span></span><br><span class="line">    *ptr1 = <span class="number">10</span>;</span><br><span class="line">    *ptr2 = <span class="number">20</span>;  <span class="comment">//✖，因为ptr2是非const指针（它指向“const int”，即，它指向的值不可以通过解引用指针被改变）</span></span><br><span class="line">    *ptr3 = <span class="number">30</span>;  </span><br><span class="line">    *ptr4 = <span class="number">40</span>;  <span class="comment">//✖，因为ptr4它指向“const int”（是const指针），但是value是“int”.类型不匹配</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/************const的变量***************/</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> value5 = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> value6 = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> value7 = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> value8 = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *ptr5 = &amp;value5; <span class="comment">//✖，非const指针（它指向“int”），所以不能指向“const int”的值value5</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *ptr6 = &amp;value6;</span><br><span class="line">    <span class="keyword">int</span> * <span class="keyword">const</span> ptr7 = &amp;value7; <span class="comment">//✖，const指针（它指向“int”）,但是value7 是“const int”。所以不匹配</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> ptr8 = &amp;value8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//防止在visual studio 软件中闪退</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针与数组</title>
      <link href="/archives/13ba6384.html"/>
      <url>/archives/13ba6384.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapterL</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h2 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h2><p>误区：在c++中，一个常见的谬误是认为数组和指向数组的指针是相同的。</p><p>真实情况是：</p><p>在下面例子中，数组的类型为：<code>int[5]</code>；数组的“值”就是数组的元素。</p><p>指向数组的指针的类型为：<code>int*</code>；它的值是数组第一个元素的地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>]&#123; <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// print address of the array's first element</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Element 0 has address: "</span> &lt;&lt; &amp;<span class="built_in">array</span>[<span class="number">0</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// print the value of the pointer the array decays to</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The array decays to a pointer holding address: "</span> &lt;&lt; <span class="built_in">array</span> &lt;&lt; '\n';</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*结果*/</span><br><span class="line">Element 0 has address: 0042FD5C</span><br><span class="line">The <span class="built_in">array</span> decays to a pointer holding address: 0042FD5C</span><br></pre></td></tr></table></figure><blockquote><p>array decays to a pointer：数组在某些情况下将<strong>退化</strong>为<strong>指针</strong></p><p>注意：数组退化为指针时，它是指向第一个元素的指针。</p></blockquote><h2 id="解引用数组"><a href="#解引用数组" class="headerlink" title="解引用数组"></a>解引用数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>]&#123; <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// dereferencing an array returns the first element (element 0)</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *<span class="built_in">array</span>; <span class="comment">// will print 9!</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span> name[]&#123; <span class="string">"Jason"</span> &#125;; <span class="comment">// C-style string (also an array)</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *name &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// will print 'J'⭐</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，我们并不是真正的解引用数组本身。</p><p>真实情况是：数组(类型为<code>int[5]</code>)被隐式转换为指针(类型为<code>int *</code>)，<strong>我们其实是解引用这个指针来获得指针所在的内存地址的值(数组第一个元素的值)。</strong></p></blockquote><h2 id="指定一个指针指向数组"><a href="#指定一个指针指向数组" class="headerlink" title="指定一个指针指向数组"></a>指定一个指针指向数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>]&#123; <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *<span class="built_in">array</span> &lt;&lt; '\n'; // will <span class="built_in">print</span> 9</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> *ptr&#123; <span class="built_in">array</span> &#125;;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *ptr &lt;&lt; '\n'; // will <span class="built_in">print</span> 9</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组退化为一个指针(类型为<code>int*</code>)，我们的指针(类型也是<code>int*</code>)也有相同的类型。</p><h2 id="指针与定长数组的区别"><a href="#指针与定长数组的区别" class="headerlink" title="指针与定长数组的区别"></a>指针与定长数组的区别</h2><h3 id="使用sizeof-的区别"><a href="#使用sizeof-的区别" class="headerlink" title="使用sizeof()的区别"></a>使用<code>sizeof()</code>的区别</h3><p>当在固定数组上使用时，<strong>sizeof返回整个数组的大小(数组长度*元素大小)。</strong></p><p>在指针上使用时，<strong>sizeof返回内存地址的大小(以字节为单位)。</strong>下面的程序说明了这一点:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#Include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>] &#123; <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="keyword">sizeof</span>(<span class="built_in">array</span>) &lt;&lt;<span class="string">'\n'</span>; <span class="comment">//：打印sizeof(int) *数组大小</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> *ptr &#123;<span class="built_in">array</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="keyword">sizeof</span>(ptr)&lt;&lt;<span class="string">'\n'</span>; <span class="comment">// 将打印指针的大小</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="使用取地址操作符-amp-的区别"><a href="#使用取地址操作符-amp-的区别" class="headerlink" title="使用取地址操作符(&amp;)的区别"></a>使用取地址操作符(&amp;)的区别</h3><p><strong>获取指针的地址会得到指针变量的内存地址</strong>。</p><p><strong>获取数组地址将返回一个指向整个数组的指针</strong>。这个指针也指向数组的第一个元素，但是类型信息不同(在上面的例子中，是int(*)[5])。你不太可能需要用到这个。</p><h2 id="————————————–"><a href="#————————————–" class="headerlink" title="————————————–"></a>————————————–</h2><h2 id="指针的运算与数组的索引"><a href="#指针的运算与数组的索引" class="headerlink" title="指针的运算与数组的索引"></a>指针的运算与数组的索引</h2><h3 id="指针的-、"><a href="#指针的-、" class="headerlink" title="指针的+、-"></a>指针的+、-</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value&#123; <span class="number">7</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> *ptr&#123; &amp;value &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ptr &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ptr+<span class="number">1</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ptr+<span class="number">2</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ptr+<span class="number">3</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">0012F</span>F7C</span><br><span class="line"><span class="number">0012F</span>F80</span><br><span class="line"><span class="number">0012F</span>F84</span><br><span class="line"><span class="number">0012F</span>F88</span><br></pre></td></tr></table></figure><p>注意：注意，</p><p><code>ptr + 1</code>并不返回ptr之后的内存地址，而是ptr所指向类型的<strong>下一个对象的内存地址</strong>。</p><blockquote><p>如果ptr指向一个整数(假设为4个字节)，ptr + 3表示ptr之后有3个整数(12个字节)。</p><p>如果ptr指向一个1字节的字符，ptr + 3表示ptr之后有3个字符(3字节)。</p></blockquote><p>在计算指针算术表达式的结果时，<strong>编译器总是将整数操作数乘以所指向对象的大小</strong>。这叫做<strong>缩放</strong>。</p><blockquote><p>就像上面的例子一样。每个地址相差4 (7C + 4 = 80 in hexadecimal)。这是因为在作者的机器上一个整数是4字节。</p></blockquote><h3 id="数组在内存中按顺序排列"><a href="#数组在内存中按顺序排列" class="headerlink" title="数组在内存中按顺序排列"></a>数组在内存中按顺序排列</h3><p>通过取地址符(&amp;)我们可以看到数组在内存中是按顺序排列的。也就是说，元素0、1、2、…按顺序都是相邻的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostram&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] &#123;<span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Element 0 is at address: "</span> &lt;&lt; &amp;<span class="built_in">array</span>[<span class="number">0</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Element 1 is at address: "</span> &lt;&lt; &amp;<span class="built_in">array</span>[<span class="number">1</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Element 2 is at address: "</span> &lt;&lt; &amp;<span class="built_in">array</span>[<span class="number">2</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Element 3 is at address: "</span> &lt;&lt; &amp;<span class="built_in">array</span>[<span class="number">3</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Element <span class="number">0</span> is at address: <span class="number">0041F</span>E9C</span><br><span class="line">Element <span class="number">1</span> is at address: <span class="number">0041F</span>EA0</span><br><span class="line">Element <span class="number">2</span> is at address: <span class="number">0041F</span>EA4</span><br><span class="line">Element <span class="number">3</span> is at address: <span class="number">0041F</span>EA8</span><br><span class="line"><span class="comment">//注意，每个内存地址之间相隔4个字节，这是作者机器上的整数大小。</span></span><br></pre></td></tr></table></figure><h3 id="数组的"><a href="#数组的" class="headerlink" title="数组的+"></a>数组的+</h3><p>数组的+和指针的运算相似：</p><blockquote><p>向数组添加1应该指向数组的第二个元素(元素1)。如下所示：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> <span class="built_in">array</span> []&#123; <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line"> </span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; &amp;<span class="built_in">array</span>[<span class="number">1</span>] &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print memory address of array element 1</span></span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>+<span class="number">1</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print memory address of array pointer + 1 </span></span><br><span class="line"> </span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[<span class="number">1</span>] &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// prints 7</span></span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *(<span class="built_in">array</span>+<span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// prints 7 (note the 小括号 required here)</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子证明：</p><p>中括号操作符([ ]) ，就是<strong>先将其转化为指针的加法</strong>，<strong>然后对指针解引用(就是访问其指向内存的值)</strong>。</p><blockquote><p>如： <code>array[n]</code> 就等同于 <code>*(array+n)</code></p></blockquote><h3 id="使用指针遍历数组"><a href="#使用指针遍历数组" class="headerlink" title="使用指针遍历数组"></a>使用指针遍历数组</h3><p>我们可以使用指针和指针运算来遍历数组。（虽然这个不常用，但是这里只是告诉你可以这样用）</p><blockquote><p><strong>使用下标通常更容易阅读和更少的错误倾向</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针</title>
      <link href="/archives/73608288.html"/>
      <url>/archives/73608288.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapterP</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h2 id="介绍指针"><a href="#介绍指针" class="headerlink" title="介绍指针"></a>介绍指针</h2><p>在<a href="http://www.learncpp.com/cpp-tutorial/13-a-first-look-at-variables/" target="_blank" rel="noopener">1.3 – a first look at variables</a>中，我们讲到：</p><p><strong>变量</strong>：是保存值的一段<strong>内存的</strong><u>名称</u>。当我们的程序实例化一个变量时，一个空闲内存地址被自动分配给这个变量。我们赋给该变量的任何值都存储在这个内存地址中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************/</span></span><br><span class="line"><span class="comment">/*当CPU执行这条语句时，会从RAM中留出一块内存。</span></span><br><span class="line"><span class="comment">为了便于举例，假设变量x被分配了内存位置140。</span></span><br><span class="line"><span class="comment">当程序在表达式或语句中看到变量x时，</span></span><br><span class="line"><span class="comment">它知道应该在内存位置140中查找该值。*/</span></span><br></pre></td></tr></table></figure><p>变量的好处是我们不需要担心分配了什么特定的内存地址。我们只是根据给定的标识符引用变量，编译器将这个名称转换为适当分配的内存地址。</p><h3 id="取地址操作符-amp"><a href="#取地址操作符-amp" class="headerlink" title="取地址操作符(&amp;)"></a>取地址操作符(&amp;)</h3><p>取地址操作符(&amp;)：允许我们查看分配给变量的内存地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print the value of variable x</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; &amp;x &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print the memory address of variable x</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">0027F</span>EA0</span><br></pre></td></tr></table></figure><h3 id="解引用操作符"><a href="#解引用操作符" class="headerlink" title="解引用操作符(*)"></a>解引用操作符(*)</h3><blockquote><p><strong>Dereferencing pointers</strong></p></blockquote><p>解引用操作符(*)：允许我们访问特定地址的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print the value of variable x</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; &amp;x &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print the memory address of variable x</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *(&amp;x) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">/// print the value at the memory address of variable x (parenthesis not required, but make it easier to read)</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">0027F</span>EA0</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><hr><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p><strong>指针是一个变量</strong>，<strong>它将一个内存地址作为其值</strong>。</p><h3 id="声明一个指针"><a href="#声明一个指针" class="headerlink" title="声明一个指针"></a>声明一个指针</h3><p>指针变量的声明与普通变量一样，只是数据类型和变量名之间有一个<strong>星号(*)</strong>。注意，这个星号不是间接寻址操作符。它是指针声明语法的一部分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1️⃣星号* 紧跟在变量名之前</span></span><br><span class="line"><span class="keyword">int</span> *iPtr; <span class="comment">// a pointer to an integer value</span></span><br><span class="line"><span class="keyword">double</span> *dPtr; <span class="comment">// a pointer to a double value</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//2️⃣ 星号* 紧跟在类型之后</span></span><br><span class="line"><span class="keyword">int</span>* iPtr2; <span class="comment">// also valid syntax (acceptable, but not favored)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3️⃣星号* 在类型与变量名之间</span></span><br><span class="line"><span class="keyword">int</span> * iPtr3; <span class="comment">// also valid syntax (but don't do this)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//注意，定义指针时，每个指针变量前面都需要有*</span></span><br><span class="line"><span class="keyword">int</span> *iPtr4, *iPtr5; <span class="comment">// declare two pointers to integer variables</span></span><br></pre></td></tr></table></figure><p>因此，在声明变量时，我们建议在变量名旁边加上星号（即，推荐1️⃣）。</p><hr><p>当从一个函数返回一个指针时，在返回类型旁边加上星号会更清楚:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//这表明函数返回的是int*类型的值，而不是int类型的值。</span></span><br></pre></td></tr></table></figure><hr><h4 id="声明时不初始化"><a href="#声明时不初始化" class="headerlink" title="声明时不初始化"></a>声明时不初始化</h4><p>就像普通的变量一样，指针在<strong>声明</strong>时是不初始化的。<strong>如果没有使用值初始化，它们将包含垃圾。</strong></p><hr><h3 id="为指针赋值"><a href="#为指针赋值" class="headerlink" title="为指针赋值"></a>为指针赋值</h3><p>由于指针只包含<strong>地址</strong>，当我们为指针赋值时，<strong>该值必须是地址</strong>。使用指针最常见的方法之一是让指针保存另一个变量的地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> v = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *ptr = &amp;v; <span class="comment">// initialize ptr with address of variable v</span></span><br></pre></td></tr></table></figure><p>上面代码片段，就像下面的图所显示的一样：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="http://www.learncpp.com/images/CppTutorial/Section6/6-Pointer.png" alt="img"></p><p>指针的名字就是从这里来的——ptr保存变量值的地址，所以我们说ptr“指向”v。</p><hr><h4 id="指针的类型必须与被指向的变量的类型相匹配"><a href="#指针的类型必须与被指向的变量的类型相匹配" class="headerlink" title="指针的类型必须与被指向的变量的类型相匹配:"></a>指针的类型必须与被指向的变量的类型相匹配:</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> iValue = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">double</span> dValue = <span class="number">7.0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> *iPtr = &amp;iValue; <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">double</span> *dPtr = &amp;dValue; <span class="comment">// ok</span></span><br><span class="line">iPtr = &amp;dValue; <span class="comment">// wrong -- int pointer cannot point to the address of a double variable</span></span><br><span class="line">dPtr = &amp;iValue; <span class="comment">// wrong -- double pointer cannot point to the address of an int variable</span></span><br></pre></td></tr></table></figure><h4 id="c-也不允许直接分配文字内存地址给指针"><a href="#c-也不允许直接分配文字内存地址给指针" class="headerlink" title="c++也不允许直接分配文字内存地址给指针:"></a>c++也不允许直接分配文字内存地址给指针:</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr = <span class="number">5</span>; <span class="comment">//这是因为指针只能保存地址，而整数literal 5没有内存地址。</span></span><br><span class="line"><span class="comment">//如果您尝试这样做，编译器将告诉您它不能将整数转换为整数指针。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> *dPtr = <span class="number">0x0012FF7C</span>; <span class="comment">//不可以，编译器将会视为赋值整数文字</span></span><br></pre></td></tr></table></figure><h3 id="取地址操作符-amp-返回指针"><a href="#取地址操作符-amp-返回指针" class="headerlink" title="取地址操作符(&amp;)返回指针"></a>取地址操作符(&amp;)返回指针</h3><p>值得注意的是取地址操作符(&amp;)并没有将其操作数的地址作为文字返回。相反，<strong>它返回一个包含操作数地址的<u>指针</u></strong>，该操作数的类型是从参数中派生出来的(例如，获取一个int类型的地址将返回它的地址到一个int型的指针中)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">x</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(&amp;x).name();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 结果（在vs2013中）*/</span></span><br><span class="line"><span class="keyword">int</span> *</span><br></pre></td></tr></table></figure><h3 id="指针的声明与解引用指针"><a href="#指针的声明与解引用指针" class="headerlink" title="指针的声明与解引用指针"></a>指针的声明与解引用指针</h3><blockquote><p>解引用指针：<strong>Dereferencing pointers</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;<span class="comment">//声明一个整型指针</span></span><br><span class="line">p= &amp;a;     <span class="comment">//p指向了a的地址 （&amp;取地址）</span></span><br><span class="line"><span class="comment">//上面两句=下面这一句：</span></span><br><span class="line"><span class="keyword">int</span> *p= &amp;a;     <span class="comment">//定义一个整型指针  p    并且p指向了a的地址     （&amp;取地址）</span></span><br><span class="line"></span><br><span class="line">*p=<span class="number">10</span>;        <span class="comment">//解引用， 即 给a赋值10；</span></span><br><span class="line"></span><br><span class="line">p=&amp;b;        <span class="comment">// p指向了 b的地址</span></span><br><span class="line"></span><br><span class="line">*p=<span class="number">200</span>;     <span class="comment">//解引用， 即 给b赋值200；</span></span><br></pre></td></tr></table></figure><p>解引用中的 “*”的作用是引用指针指向的变量值，引用其实就是引用该变量的地址，”解”就是把该地址对应的东西解开，解出来，就像打开一个包裹一样，那就是该变量的值了，所以称为”解引用”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; &amp;value; <span class="comment">// prints address of value</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value; <span class="comment">// prints contents of value</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> *ptr = &amp;value; <span class="comment">// ptr points to value</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ptr; <span class="comment">// prints address held in ptr, which is &amp;value</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *ptr; <span class="comment">// dereference ptr (get the value that ptr is pointing to)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">0012F</span>F7C</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">0012F</span>F7C</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>这就是指针必须有类型的原因</strong>。如果没有类型，指针就不知道在解引用时如何解释它所指向的内容。</p><p><strong>这也是为什么指针的类型和赋值给它的变量地址必须匹配的原因</strong>。如果他们不这样做，当指针被解引用时，它会将bits误读为另一种类型。</p><h3 id="指针的大小"><a href="#指针的大小" class="headerlink" title="指针的大小"></a>指针的大小</h3><p><strong>指针的大小取决于可执行文件的编译体系结构</strong>——32位可执行文件使用32位内存地址——因此，32位机器上的指针是32位(4字节)。对于64位的可执行文件，指针应该是64位(8字节)。<strong>请注意，这是固定的，与指针的类型无关。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *chPtr; <span class="comment">// chars are 1 byte</span></span><br><span class="line"><span class="keyword">int</span> *iPtr; <span class="comment">// ints are usually 4 bytes</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nX, nY, nZ;</span><br><span class="line">&#125;;</span><br><span class="line">Something *somethingPtr; <span class="comment">// Something is probably 12 bytes</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(chPtr) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// prints 4</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(iPtr) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// prints 4</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(somethingPtr) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// prints 4</span></span><br></pre></td></tr></table></figure><p>可以看到，指针的大小总是相同的。这是因为指针只是一个内存地址，而访问给定机器上的内存地址所需的比特数总是恒定的。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组、字符串、指针和引用</title>
      <link href="/archives/122ff534.html"/>
      <url>/archives/122ff534.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapterP</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h2 id="P6-1-定长数组（Ⅰ）"><a href="#P6-1-定长数组（Ⅰ）" class="headerlink" title="P6.1 定长数组（Ⅰ）"></a><a href="https://www.learncpp.com/cpp-tutorial/61-arrays-part-i/" target="_blank" rel="noopener">P6.1 定长数组（Ⅰ）</a></h2><p><strong>数组长度</strong>：</p><p>在数组变量声明中，我们使用方括号( <strong>[ ]</strong> )告诉编译器这是一个数组变量(而不是普通的变量)，以及要分配多少变量(称为<strong>数组长度</strong>)。</p><p><strong>固定长度的数组</strong>：</p><p><strong>固定数组</strong>(也称为<strong>固定长度数组</strong>或<strong>固定大小数组</strong>)是在<strong>编译时</strong>长度已知的数组。当testScore被实例化时，编译器将分配30个整数。</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> testScore[<span class="number">30</span>]; <span class="comment">// allocate 30 integer variables in a fixed array</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="数组元素和下标"><a href="#数组元素和下标" class="headerlink" title="数组元素和下标"></a>数组元素和下标</h3><p>数组中的每个变量都称为<strong>元素</strong>。元素没有自己单独的名称。</p><p>为了访问数组的各个元素，我们使用<strong>数组名</strong>、<strong>下标操作符([])</strong>和一个称为<strong>下标</strong>(或<strong>索引</strong>)的参数，它告诉编译器我们需要哪个元素。</p><p><em>重要提示:与我们通常从1开始计数的日常生活不同，*</em>在c++中，数组总是从0开始计数!***</p><hr><h3 id="由结构体构成的数组"><a href="#由结构体构成的数组" class="headerlink" title="由结构体构成的数组"></a>由结构体构成的数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">width</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Rectangle rects[<span class="number">5</span>]; <span class="comment">// declare an array of 5 Rectangle</span></span><br></pre></td></tr></table></figure><p>要访问数组元素的struct成员，<strong>首先</strong>选择你想要的数组元素，<strong>然后</strong>使用成员选择操作符( . )来选择你想要的struct成员：<code>rects[0].length = 24;</code></p><h3 id="数组下标（详细）"><a href="#数组下标（详细）" class="headerlink" title="数组下标（详细）"></a>数组下标（详细）</h3><p><strong>在c++中，数组下标必须始终是整数类型</strong>。这包括char、short、int、long、long long等等，奇怪的是，bool(其中false的索引为0,true的索引为1). 数组下标可以是一个文字值、一个变量(常量或非常量)，或者一个计算结果为整数类型的表达式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>]; <span class="comment">// declare an array of length 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// using a literal (constant) index:</span></span><br><span class="line"><span class="built_in">array</span>[<span class="number">1</span>] = <span class="number">7</span>; <span class="comment">// ok</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// using an enum (constant) index</span></span><br><span class="line"><span class="keyword">enum</span> Animals</span><br><span class="line">&#123;</span><br><span class="line">    ANIMAL_CAT = <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">array</span>[ANIMAL_CAT] = <span class="number">4</span>; <span class="comment">// ok</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// using a variable (non-constant) index:</span></span><br><span class="line">short index = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">array</span>[index] = <span class="number">7</span>; <span class="comment">// ok</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// using an expression that evaluates to an integer index:</span></span><br><span class="line"><span class="built_in">array</span>[<span class="number">1</span>+<span class="number">2</span>] = <span class="number">7</span>; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><h3 id="定长数组的声明"><a href="#定长数组的声明" class="headerlink" title="定长数组的声明"></a>定长数组的声明</h3><p>在<u>声明</u><strong>固定数组</strong>时，数组的长度(方括号之间)必须是<strong>编译时常量（compile-time）</strong>。这是因为在编译时必须知道固定数组的长度。这里有一些不同的方法来声明固定数组:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// using a literal constant</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>]; <span class="comment">// Ok</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// using a macro symbolic constant</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAY_LENGTH 5</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[ARRAY_LENGTH]; <span class="comment">// Syntactically okay, but don't do this</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// using a symbolic constant</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> arrayLength = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[arrayLength]; <span class="comment">// Ok</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// using an enumerator</span></span><br><span class="line"><span class="keyword">enum</span> ArrayElements</span><br><span class="line">&#123;</span><br><span class="line">    MAX_ARRAY_LENGTH = <span class="number">5</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[MAX_ARRAY_LENGTH]; <span class="comment">// Ok</span></span><br></pre></td></tr></table></figure><p>注意，<strong>非常量变量</strong>或<strong>运行时常量（runtime constants）</strong>不能使用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//using a non-const variable</span></span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;length;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[length]; <span class="comment">//不行，length 不是编译时常量!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// using a runtime const variable</span></span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> length =temp; <span class="comment">//length的值直到运行时才知道，所以这是一个运行时常量，而不是编译时常量!</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[length]; <span class="comment">//不可以</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，在最后两种情况下，应该会产生一个错误，因为长度不是编译时常数。一些编译器可能允许这些类型的数组(为了C99的兼容性)，但是根据c++标准，它们是无效的，不应该在c++程序中使用。</p></blockquote><h3 id="关于动态数组的说明"><a href="#关于动态数组的说明" class="headerlink" title="关于动态数组的说明"></a>关于动态数组的说明</h3><p>因为固定数组在编译时分配了内存，这就引入了两个限制:</p><ul><li>固定数组的长度不能基于用户输入或运行时计算的其他值。</li><li>固定数组的长度是固定的，不能改变。</li></ul><p>在许多情况下，这些限制是有问题的。幸运的是，c++支持第二种类型的数组，称为<strong>动态数组</strong>。动态数组的长度可以在运行时设置，也可以更改其长度。但是，动态数组的实例化要复杂一些，因此我们将在本章的后面部分介绍它们。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>固定数组</strong>提供了一种简单的方法来分配和使用相同类型的多个变量，只要在编译时知道数组的长度即可。</p><hr><h2 id="P6-2-定长数组（Ⅱ）"><a href="#P6-2-定长数组（Ⅱ）" class="headerlink" title="P6.2 定长数组（Ⅱ）"></a><a href="https://www.learncpp.com/cpp-tutorial/62-arrays-part-ii/" target="_blank" rel="noopener">P6.2 定长数组（Ⅱ）</a></h2><p>c++通过使用<strong>初始化器列表</strong>提供了一种更方便的方法来初始化整个数组。下面的例子是等价的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> prime[<span class="number">5</span>] = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span> &#125;; <span class="comment">// use initializer list to initialize the fixed array【推荐】</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> prime[<span class="number">5</span>]; <span class="comment">// hold the first 5 prime numbers【不推荐】</span></span><br><span class="line">    prime[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">    prime[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">    prime[<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line">    prime[<span class="number">3</span>] = <span class="number">7</span>;</span><br><span class="line">    prime[<span class="number">4</span>] = <span class="number">11</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="零值初始化"><a href="#零值初始化" class="headerlink" title="零值初始化"></a>零值初始化</h3><p>当列表中的初始化器比数组所能容纳的少，那么，其余的元素会被初始化为0。（或者将0转换为非整数基本类型的任何值——例如0.0转换为double）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>] = &#123; <span class="number">7</span>, <span class="number">4</span>, <span class="number">5</span> &#125;; <span class="comment">// only initialize first 3 elements</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[<span class="number">0</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[<span class="number">1</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[<span class="number">2</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[<span class="number">3</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[<span class="number">4</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize all elements to 0</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>] = &#123; &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Initialize all elements to 0.0</span></span><br><span class="line"><span class="keyword">double</span> <span class="built_in">array</span>[<span class="number">5</span>] = &#123; &#125;;</span><br></pre></td></tr></table></figure><p><strong>从c++ 11开始，应该使用统一的初始化语法:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> prime[<span class="number">5</span>] &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span> &#125;; <span class="comment">//使用统一初始化来初始化固定数组,</span></span><br><span class="line"><span class="comment">//注意这个语法中没有等号</span></span><br></pre></td></tr></table></figure><h3 id="省略长度"><a href="#省略长度" class="headerlink" title="省略长度"></a>省略长度</h3><p>如果使用初始化器列表初始化一个固定的元素数组，编译器可以为您计算出数组的长度，您可以省略显式声明数组的长度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;; <span class="comment">// 显式的 define length of the array</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;; <span class="comment">// let initializer list set length of the array</span></span><br></pre></td></tr></table></figure><h3 id="数组和枚举"><a href="#数组和枚举" class="headerlink" title="数组和枚举"></a>数组和枚举</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> StudentsNames&#123;</span><br><span class="line">    qin, <span class="comment">//0</span></span><br><span class="line">    zhi, <span class="comment">//1</span></span><br><span class="line">    Long,<span class="comment">//2</span></span><br><span class="line">    student_num, <span class="comment">//3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> testScores[student_num]; <span class="comment">//allocate 3 integers</span></span><br><span class="line">    testScores[qin] = <span class="number">76</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组和枚举类"><a href="#数组和枚举类" class="headerlink" title="数组和枚举类"></a>数组和枚举类</h3><p><strong>枚举类不会隐式的将枚举器转换为整数</strong>，所以如果你尝试以下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentNames</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    KENNY, <span class="comment">// 0</span></span><br><span class="line">    KYLE, <span class="comment">// 1</span></span><br><span class="line">    STAN, <span class="comment">// 2</span></span><br><span class="line">    BUTTERS, <span class="comment">// 3</span></span><br><span class="line">    CARTMAN, <span class="comment">// 4</span></span><br><span class="line">    WENDY, <span class="comment">// 5</span></span><br><span class="line">    MAX_STUDENTS <span class="comment">// 6</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> testScores[StudentNames::MAX_STUDENTS]; <span class="comment">// allocate 6 integers</span></span><br><span class="line">    testScores[StudentNames::STAN] = <span class="number">76</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>你会得到一个编译错误</strong>。</p><p><strong>解决：</strong></p><blockquote><p>这可以通过使用<code>static_cast</code>将枚举数转换为整数来解决:</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> testScores[<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(StudentNames::MAX_STUDENTS)]; <span class="comment">// allocate 6 integers</span></span><br><span class="line">    testScores[<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(StudentNames::STAN)] = <span class="number">76</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>改进：</strong></p><blockquote><p>在命名空间中使用标准的<code>enum</code>可能更好:</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">nmaespace studentName</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">enum</span> studentnames</span><br><span class="line">&#123;</span><br><span class="line">KENNY, <span class="comment">// 0</span></span><br><span class="line">        KYLE, <span class="comment">// 1</span></span><br><span class="line">        STAN, <span class="comment">// 2</span></span><br><span class="line">        BUTTERS, <span class="comment">// 3</span></span><br><span class="line">        CARTMAN, <span class="comment">// 4</span></span><br><span class="line">        WENDY, <span class="comment">// 5</span></span><br><span class="line">        MAX_STUDENTS <span class="comment">// 6</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> testScores[studentName::MAX_STUDENTS];</span><br><span class="line">    testScores[StudentNames::STAN] = <span class="number">76</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将数组传递给函数"><a href="#将数组传递给函数" class="headerlink" title="将数组传递给函数"></a>将数组传递给函数</h3><p><strong>传递数组给函数</strong> VS <strong>传递普通的变量给函数</strong> 的区别：</p><ul><li>传递数组给函数：当通过值传递一个普通变量时，c++将参数的值复制到函数参数中。<strong>因为参数是副本，所以更改参数的值并不会更改原始参数的值</strong>。</li><li>传递数组给函数：当一个数组被传递给一个函数时，c++不会复制一个数组。而是传递实际的数组。<strong>这样做的副作用是允许函数直接改变数组元素的值</strong>!</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//传递普通参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">passValue</span><span class="params">(<span class="keyword">int</span> value)</span> <span class="comment">// value is a copy of the argument</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    value = <span class="number">99</span>; <span class="comment">// so changing it here won't change the value of the argument</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//传递数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">passArray</span><span class="params">(<span class="keyword">int</span> prime[<span class="number">5</span>])</span> <span class="comment">// prime is the actual array</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    prime[<span class="number">0</span>] = <span class="number">11</span>; <span class="comment">// so changing it here will change the original argument!</span></span><br><span class="line">    prime[<span class="number">1</span>] = <span class="number">7</span>;</span><br><span class="line">    prime[<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line">    prime[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">    prime[<span class="number">4</span>] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"before passValue: "</span> &lt;&lt; value &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    passValue(value);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"after passValue: "</span> &lt;&lt; value &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> prime[<span class="number">5</span>] = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"before passArray: "</span> &lt;&lt; prime[<span class="number">0</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; prime[<span class="number">1</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; prime[<span class="number">2</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; prime[<span class="number">3</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; prime[<span class="number">4</span>] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    passArray(prime);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"after passArray: "</span> &lt;&lt; prime[<span class="number">0</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; prime[<span class="number">1</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; prime[<span class="number">2</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; prime[<span class="number">3</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; prime[<span class="number">4</span>] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">before passValue: <span class="number">1</span></span><br><span class="line">after passValue: <span class="number">1</span> （普通变量不会被修改）</span><br><span class="line">before passArray: <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">11</span></span><br><span class="line">after passArray: <span class="number">11</span> <span class="number">7</span> <span class="number">5</span> <span class="number">3</span> <span class="number">2</span>  （数组会被修改）</span><br></pre></td></tr></table></figure><p>注意<strong>：如果你想确保一个函数不修改数组元素传递给它，你可以对数组使用<code>const</code>:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// even though prime is the actual array, within this function it should be treated as a constant</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">passArray</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> prime[<span class="number">5</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// so each of these lines will cause a 编译错误!</span></span><br><span class="line">    prime[<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">    prime[<span class="number">1</span>] = <span class="number">7</span>;</span><br><span class="line">    prime[<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line">    prime[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">    prime[<span class="number">4</span>] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sizeof和数组"><a href="#sizeof和数组" class="headerlink" title="sizeof和数组"></a><code>sizeof</code>和数组</h3><p>可以对数组使用sizeof操作符，它将返回数组的总大小（<strong>数组长度乘以元素大小</strong>）</p><blockquote><p>注意，<strong>由于c++将数组传递给函数的方式，对于已传递给函数的数组，这将无法正常工作!</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSize</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="built_in">array</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// prints the size of a pointer, not the size of the array!(将数组传递给函数，它显示的大小只是数组的指针（我的vs2013中，指针大小为4byte）)</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="built_in">array</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// will print the size of the array（没有传递给函数，所以会正常显示数组的大小）</span></span><br><span class="line">    printSize(<span class="built_in">array</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="comment">//在我的vs2013中，int是4byte，int指针是4byte</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>指针大小与类型无关</strong></p><p><strong>数组大小≠数组长度</strong>；数组大小 = 数组长度*元素大小</p></blockquote><hr><h3 id="在c-17之前确定一个固定数组的长度"><a href="#在c-17之前确定一个固定数组的长度" class="headerlink" title="在c++ 17之前确定一个固定数组的长度"></a>在c++ 17之前确定一个固定数组的长度</h3><p>我们可以通过 整个数组的大小 除以 数组元素的大小 来确定一个固定数组的长度:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; //for std::cout</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"The array has: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]) &lt;&lt; <span class="string">" elements\n"</span>;</span><br><span class="line">    <span class="comment">//sizeof(array[0])是元素的大小</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">The <span class="built_in">array</span> has <span class="number">8</span> elements</span><br></pre></td></tr></table></figure><h3 id="在c-17-c-20中确定一个固定数组的长度"><a href="#在c-17-c-20中确定一个固定数组的长度" class="headerlink" title="在c++ 17/ c++ 20中确定一个固定数组的长度"></a>在c++ 17/ c++ 20中确定一个固定数组的长度</h3><p>在c++ 17中，更好的选择是<strong>使用<code>std::size()</code>函数，它是在头文件<code>&lt;iterator&gt;</code>中。</strong></p><blockquote><p>如果您试图在<strong>传递给函数</strong>的固定数组上使用它，则会导致编译器错误!注意，<strong>std::size返回一个无符号值。</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // for std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt; // for std::size</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The array has: "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">size</span>(<span class="built_in">array</span>) &lt;&lt; <span class="string">" elements\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">The <span class="built_in">array</span> has <span class="number">8</span> elements</span><br></pre></td></tr></table></figure><hr><p>在c++ 20中，<code>std::ssize</code>甚至更可取，因为它返回一个带符号的值。</p><hr><p>小结：</p><ul><li><strong>如果你的编译器是c++ 17/ c++ 20的能力，那么你可以使用<code>std::size</code> (c++ 17)或者<code>std::ssize</code>(c++ 20)来进行数组长度的确定。</strong></li></ul><h2 id="P6-4-使用选择排序对数组排序"><a href="#P6-4-使用选择排序对数组排序" class="headerlink" title="P6.4 使用选择排序对数组排序"></a>P6.4 使用选择排序对数组排序</h2><h3 id="数组元素交换"><a href="#数组元素交换" class="headerlink" title="数组元素交换"></a>数组元素交换</h3><p>在C++标准库中，提供了元素值的交换函数：<code>std::swap()</code>在头文件<code>algorithm</code>中（如果是C++11，则在头文件<code>utility</code>中）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // for std::swap, use &lt;utility&gt; instead if C++11</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123; <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> y&#123; <span class="number">4</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Before swap: x = "</span> &lt;&lt; x &lt;&lt; <span class="string">", y = "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::swap(x, y); <span class="comment">// swap the values of x and y</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"After swap:  x = "</span> &lt;&lt; x &lt;&lt; <span class="string">", y = "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Before swap: x = <span class="number">2</span>, y = <span class="number">4</span></span><br><span class="line">After swap:  x = <span class="number">4</span>, y = <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="在c-中的选择排序"><a href="#在c-中的选择排序" class="headerlink" title="在c++中的选择排序"></a>在c++中的选择排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // for std::swap, use &lt;utility&gt; instead if C++11</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> length&#123; <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[length]&#123; <span class="number">30</span>, <span class="number">50</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">40</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Step through each element of the array</span></span><br><span class="line"><span class="comment">// (except the last one, which will already be sorted by the time we get there)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> startIndex&#123; <span class="number">0</span> &#125;; startIndex &lt; length - <span class="number">1</span>; ++startIndex)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// smallestIndex is the index of the smallest element we’ve encountered this iteration</span></span><br><span class="line"><span class="comment">// Start by assuming the smallest element is the first element of this iteration</span></span><br><span class="line"><span class="keyword">int</span> smallestIndex&#123; startIndex &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Then look for a smaller element in the rest of the array</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> currentIndex&#123; startIndex + <span class="number">1</span> &#125;; currentIndex &lt; length; ++currentIndex)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// If we've found an element that is smaller than our previously found smallest</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[currentIndex] &lt; <span class="built_in">array</span>[smallestIndex])</span><br><span class="line"><span class="comment">// then keep track of it</span></span><br><span class="line">smallestIndex = currentIndex;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// smallestIndex is now the smallest element in the remaining array</span></span><br><span class="line">                <span class="comment">// swap our start element with our smallest element (this sorts it into the correct place)</span></span><br><span class="line"><span class="built_in">std</span>::swap(<span class="built_in">array</span>[startIndex], <span class="built_in">array</span>[smallestIndex]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Now that the whole array is sorted, print our sorted array as proof it works</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> index&#123; <span class="number">0</span> &#125;; index &lt; length; ++index)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[index] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="std-sort-C-中自带排序函数"><a href="#std-sort-C-中自带排序函数" class="headerlink" title="std::sort(C++中自带排序函数)"></a>std::sort(C++中自带排序函数)</h3><blockquote><p>默认情况下，<code>std::sort</code>按升序排序，使用操作符<code>&lt;</code>来比较元素对，并在必要时交换它们(很像上面的选择排序示例)。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // for std::sort</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt; // for std::size</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[]&#123; <span class="number">30</span>, <span class="number">50</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">40</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::sort(<span class="built_in">std</span>::<span class="built_in">begin</span>(<span class="built_in">array</span>), <span class="built_in">std</span>::<span class="built_in">end</span>(<span class="built_in">array</span>));</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i&#123; <span class="number">0</span> &#125;; i &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">std</span>::<span class="built_in">size</span>(<span class="built_in">array</span>)); ++i)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P6-5-多维数组"><a href="#P6-5-多维数组" class="headerlink" title="P6.5 多维数组"></a>P6.5 多维数组</h2><p>数组的元素可以是任何数据类型，包括数组。数组的数组称为<strong>多维数组</strong>。</p><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">3</span>][<span class="number">5</span>]; <span class="comment">// a 3-element array of 5-element arrays</span></span><br></pre></td></tr></table></figure><p>在二维数组中，可以方便地将第一个(左)下标视为<strong>行</strong>，第二个(右)下标视为<strong>列</strong>。这叫做行-主序。在概念上，上述二维数组的布局如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0][0]  [0][1]  [0][2]  [0][3]  [0][4] &#x2F;&#x2F; row 0</span><br><span class="line">[1][0]  [1][1]  [1][2]  [1][3]  [1][4] &#x2F;&#x2F; row 1</span><br><span class="line">[2][0]  [2][1]  [2][2]  [2][3]  [2][4] &#x2F;&#x2F; row 2</span><br></pre></td></tr></table></figure><h4 id="二维数组初始化"><a href="#二维数组初始化" class="headerlink" title="二维数组初始化"></a>二维数组初始化</h4><ul><li>要初始化一个二维数组，最简单的方法是使用嵌套大括号，每组数字代表一行:</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">3</span>][<span class="number">5</span>]</span><br><span class="line">&#123;</span><br><span class="line">  &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;, <span class="comment">// row 0</span></span><br><span class="line">  &#123; <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;, <span class="comment">// row 1</span></span><br><span class="line">  &#123; <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span> &#125; <span class="comment">// row 2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>当然你也可以省略左(行)下标。注意，如果想省略下标，<strong>你只能省略左(行)下标，而右(列)下标不允许省略。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[][<span class="number">5</span>]  <span class="comment">//只能省略左(行)下标  ✔</span></span><br><span class="line">&#123;</span><br><span class="line">  &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;,</span><br><span class="line">  &#123; <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;,</span><br><span class="line">  &#123; <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[][]   <span class="comment">//不能省略右(列)下标  ✖</span></span><br><span class="line">&#123;</span><br><span class="line">  &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;,</span><br><span class="line">  &#123; <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;,</span><br><span class="line">  &#123; <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="多维数组（大于2维）"><a href="#多维数组（大于2维）" class="headerlink" title="多维数组（大于2维）"></a>多维数组（大于2维）</h3><p>多维数组可以大于二维。这是一个三维数组的声明:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">1</span>][<span class="number">2</span>][<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>使用初始化器列表很难以任何直观的方式初始化三维数组，<strong>因此通常最好将数组初始化为0，并使用嵌套循环显式地分配值。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C风格字符串</title>
      <link href="/archives/21aba888.html"/>
      <url>/archives/21aba888.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapterL</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h2 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h2><p>在<a href="http://www.learncpp.com/cpp-tutorial/4-4b-an-introduction-to-stdstring/" target="_blank" rel="noopener">4.4b – An introduction to std::string</a>的介绍中，我们将字符串定义为连续字符的集合，比如“Hello, world!”字符串是我们在c++中处理文本的主要方式，而std::string使在c++中处理字符串变得很容易。</p><p>现代c++支持<strong>两种</strong>不同类型的字符串:</p><ul><li>std::string(作为标准库的一部分)和</li><li>C风格的字符串(从C语言继承而来)。原来std::string是使用c风格的字符串实现的。</li></ul><p>在这节课中，我们将进一步了解c风格的字符串。</p><p>c风格的字符串只是一个使用<strong>空终止符(null terminator)</strong>的<strong>字符数组</strong>。</p><blockquote><p><strong>空终止符</strong>是一个特殊字符(<code>&#39; \0 &#39;</code>， ascii码为 0)</p></blockquote><hr><p>C风格字符串，<strong>只需声明一个<code>char</code>数组，并初始化它的字符串文字:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> myString[]&#123; <span class="string">"string"</span> &#125;;</span><br><span class="line"><span class="comment">//虽然“string”只有6个字母，但c++会自动为我们在字符串的末尾添加一个空终止符</span></span><br><span class="line"><span class="comment">//(我们自己不需要包含它)。因此，myString实际上是一个长度为7的数组!</span></span><br></pre></td></tr></table></figure><p>下面我们来证明它的实际长度：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt; // for std::size(如果不支持C++17，就不用加该头文件)</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> myString[]&#123; <span class="string">"string"</span> &#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> length&#123; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">std</span>::<span class="built_in">size</span>(myString)) &#125;;</span><br><span class="line"><span class="comment">// 如果你的编译器不支持C++17，请使用下面语句来替换</span></span><br><span class="line"><span class="comment">//  const int length&#123; sizeof(myString) / sizeof(myString[0]) &#125;; </span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; myString&lt;&lt; <span class="string">" has "</span> &lt;&lt; length &lt;&lt; <span class="string">" characters.\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index&#123; <span class="number">0</span> &#125;; index &lt; length; ++index)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(myString[index]) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="built_in">string</span> has <span class="number">7</span> characters.</span><br><span class="line"><span class="number">115</span> <span class="number">116</span> <span class="number">114</span> <span class="number">105</span> <span class="number">110</span> <span class="number">103</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p>该0是已附加到字符串末尾的空终止符的ASCII代码。</p></blockquote><p><strong>需要注意的重要一点是，C风格的字符串遵循与数组相同的所有规则。这意味着您可以在创建时初始化字符串，但不能在此之后使用赋值操作符为其赋值!</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> myString[]&#123; <span class="string">"string"</span> &#125;; <span class="comment">// ok</span></span><br><span class="line">myString = <span class="string">"rope"</span>; <span class="comment">// not ok!</span></span><br></pre></td></tr></table></figure><p><strong>但是你可以改变它字符串数组中的单个字符：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> myString[]&#123; <span class="string">"string"</span> &#125;; </span><br><span class="line">myString[<span class="number">0</span>] = <span class="string">'q'</span>;   <span class="comment">//这样是可以的</span></span><br></pre></td></tr></table></figure><h3 id="覆盖字符串的空终止符"><a href="#覆盖字符串的空终止符" class="headerlink" title="覆盖字符串的空终止符"></a>覆盖字符串的空终止符</h3><p>在打印c风格的字符串时，<code>std::cout</code>将打印字符，<strong>直到遇到空终止符为止</strong>。</p><p>如果您意外地覆盖了一个字符串中的null结束符(例如，通过向<code>myString[6]</code>分配一些内容)，您不仅会获得字符串中的所有字符，而且std::cout将继续打印相邻内存插槽中的所有内容，<strong>直到它刚好碰到一个0!</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>]&#123; <span class="string">"Alex"</span> &#125;; <span class="comment">// only use 5 characters (4 letters + null terminator)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"My name is: "</span> &lt;&lt; name &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在本例中，将打印字符串“Alex”，std::cout将在null结束符处停止。数组中的其余字符将被忽略。</span></span><br></pre></td></tr></table></figure><h3 id="C-style与std-cin"><a href="#C-style与std-cin" class="headerlink" title="C-style与std::cin"></a>C-style与<code>std::cin</code></h3><p>当我们不知道一个字符串将会有多长。在这种情况下，我们可以声明一个大于我们需要的数组:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">255</span>]; <span class="comment">// declare array large enough to hold 255 characters</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter your name: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"You entered: "</span> &lt;&lt; name &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种输入字符串的方法，不好。因为，我们不能阻止用户输入字符串的长度，即使它输入超过255，我们也不能阻止用户。</p><blockquote><p>比如：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="D:%5CBLOG_QZL%5CBlog3%5Csource_posts%5CC&C++%5Cupload%5Cimage-20200428153347057.png" alt="image-20200428153347057"></p><p>我故意输入超过3个字符，结果会是怎样的呢？</p><blockquote><p>结果就是即使超过了原本字符串数组的长度，还是会全部打印出来：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="D:%5CBLOG_QZL%5CBlog3%5Csource_posts%5CC&C++%5Cupload%5Cimage-20200428153501507.png" alt="image-20200428153501507"></p></blockquote><h4 id="改进：std-cin-getline"><a href="#改进：std-cin-getline" class="headerlink" title="改进：std::cin.getline"></a><strong>改进</strong>：<code>std::cin.getline</code></h4><p>推荐使用：<code>std::cin.getline( 字符串数组名字, 字符串数组长度)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">255</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"enter your name:"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.getline(name, <span class="built_in">std</span>::<span class="built_in">size</span>(name)); <span class="comment">//这里还是需要支持C++17才能这样用的</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"You entered: "</span> &lt;&lt; name &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个对cingetline()的调用将把最多254个字符读入<code>name</code>(为 空结束符 留出空间!) 任何多余的字符都将被丢弃。这样，我们保证不会溢出数组!</p><h3 id="操纵c风格的字符串-include-lt-cstring-gt"><a href="#操纵c风格的字符串-include-lt-cstring-gt" class="headerlink" title="操纵c风格的字符串(#include &lt;cstring&gt;)"></a>操纵c风格的字符串(#include &lt;cstring&gt;)</h3><p>在<code>cstring</code>头文件中，c++提供了许多函数来操作C风格的字符串：</p><h4 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy()"></a>strcpy()</h4><p>strcpy()允许将一个字符串复制到另一个字符串：<code>std::strcpy(dest, source)</code></p><blockquote><p>注意，如果目的字符串<code>dest</code>长度小于将要复制的字符串的长度，会发生溢出。</p></blockquote><p>许多程序员建议使用<code>strncpy()</code>，它允许您指定缓冲区的大小，并确保不会发生溢出。不幸的是，strncpy()不能确保字符串以null结尾，这仍然为数组溢出留下了大量空间。</p><h4 id="strcpy-s-【改进】"><a href="#strcpy-s-【改进】" class="headerlink" title="strcpy_s() 【改进】"></a>strcpy_s() 【改进】</h4><p>在C++中，使用<code>strcp_s()</code>更安全。它添加了一个参数来确定目标字符串的大小。<code>strcpy_s(dest, number, source);</code></p><p>但是，并不是所有的编译器都支持这个函数，要使用它，您必须使用整数值1定义<code>__STDC_WANT_LIB_EXT1__</code>。</p><blockquote><p>即：<code>#define __STDC_WANT_LIB_EXT1__ 1</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __STDC_WANT_LIB_EXT1__ 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; // for strcpy_s</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> source[]&#123; <span class="string">"Copy this!"</span> &#125;;</span><br><span class="line">    <span class="keyword">char</span> dest[<span class="number">5</span>]; <span class="comment">// note that the length of dest is only 5 chars!</span></span><br><span class="line">    strcpy_s(dest, <span class="number">5</span>, source); <span class="comment">// A runtime error will occur in debug mode</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; dest &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="strlcpy-【再改进】"><a href="#strlcpy-【再改进】" class="headerlink" title="strlcpy() 【再改进】"></a>strlcpy() 【再改进】</h4><p>因为<code>strcpy_s()</code>不是所有编译器都支持。所以，<code>strlcpy()</code> 是一个更好的选择。</p><blockquote><p>因为它是非标准的，所以没有包含在许多编译器中。它也有自己的一套问题。简而言之，<strong>如果您需要复制c风格的字符串，这里没有普遍推荐的解决方案</strong>。</p></blockquote><hr><h4 id="strlen-：返回字符串长度"><a href="#strlen-：返回字符串长度" class="headerlink" title="strlen()：返回字符串长度"></a>strlen()：返回字符串长度</h4><p>此函数返回c样式字符串的<strong>长度</strong>(<strong>不包含空终止符</strong>)：（不是返回该字符串数组全部的长度，而是只返回已存入字符的长度）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>] &#123;<span class="string">"Alex"</span>&#125;; <span class="comment">//// only use 5 characters (4 letters + null terminator)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"My name is: "</span> &lt;&lt; name &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">" has "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">strlen</span>(name) &lt;&lt; <span class="string">" letters.\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">" has "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">size</span>(name) &lt;&lt; <span class="string">" characters in the array.\n"</span>; <span class="comment">// use sizeof(name) / sizeof(name[0]) if not C++17 capable</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">My name is: Alex</span><br><span class="line">Alex has <span class="number">4</span> letters. (不包含终止符)</span><br><span class="line">Alex has <span class="number">20</span> characters in the <span class="built_in">array</span>.</span><br></pre></td></tr></table></figure><hr><p>注意：<code>strlen()</code>、<code>std::size()</code>的区别：</p><ul><li><p>strlen()打印<strong>null结束符之前的字符数</strong>，</p></li><li><p>size() C++17 . sizeof(name) / sizeof(name[0]) 不支持C++17的写法</p><p><strong>返回整个数组的大小</strong>，不管里面是什么。</p></li></ul><hr><h4 id="其他函数："><a href="#其他函数：" class="headerlink" title="其他函数："></a>其他函数：</h4><p><code>strcat()</code>——将一个字符串追加到另一个字符串(危险)</p><p><code>strncat()</code>——将一个字符串追加到另一个字符串(使用缓冲区检查长度)</p><p><code>strcmp()</code>——比较两个字符串(如果相等则返回0)</p><p><code>strncmp()</code>——比较两个字符串到特定数目的字符(如果相等，则返回0)</p><hr><h3 id="Don’t-use-C-style-strings"><a href="#Don’t-use-C-style-strings" class="headerlink" title="Don’t use C-style strings"></a>Don’t use C-style strings</h3><p>了解c风格的字符串很重要，因为它们在很多代码中都有使用。然而，现在我们已经解释了它们的工作原理，<strong>我们将建议您尽可能地避免使用它们</strong>! 除非您有特定的、令人信服的理由来使用c样式的字符串，<strong>否则应该使用std::string(在头文件 &lt;string&gt; 中定义)。<code>std::string</code></strong>更容易，更安全，更灵活。</p><p>在极少数情况下，您确实需要使用固定的缓冲区大小和c风格的字符串(例如，对于内存有限的设备)。<strong>我们建议使用经过良好测试的第三方字符串库</strong>，即<strong>std::string_view</strong>，这将在下一课中介绍。</p><h4 id="用std-string-view替代C-style-字符串"><a href="#用std-string-view替代C-style-字符串" class="headerlink" title="用std::string_view替代C-style 字符串"></a>用<code>std::string_view</code>替代C-style 字符串</h4><hr><h2 id="std-string-view"><a href="#std-string-view" class="headerlink" title="std::string_view"></a>std::string_view</h2><p>之前，讲的<a href="##C风格字符串">C风格字符串</a>（<a href="https://www.learncpp.com/cpp-tutorial/66-c-style-strings/" target="_blank" rel="noopener">原文链接</a>），以及使用它们的危险。c风格的字符串速度很快，但是它们不像<code>std::string</code>那样容易使用和安全。</p><p>但是<code>std::string</code>(我们在 <a href="https://www.learncpp.com/cpp-tutorial/4-4b-an-introduction-to-stdstring/" target="_blank" rel="noopener">S.4.4b – An introduction to std::string</a>（也就是本文开头的<a href="https://www.yuque.com/longlongqin/pw9qpx/fmzy0d#acbe9355" target="_blank" rel="noopener">介绍<code>std::string</code></a>）的介绍中已经介绍过了)也有它自己的缺点，尤其是涉及到const字符串时。</p><h3 id="std-string会修改const的字符串"><a href="#std-string会修改const的字符串" class="headerlink" title="std::string会修改const的字符串"></a>std::string会修改const的字符串</h3><p>看下面一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> <span class="built_in">text</span>[]&#123; <span class="string">"hello"</span> &#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> str&#123; <span class="built_in">text</span> &#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> more&#123; str &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">text</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; str &lt;&lt; <span class="string">' '</span> &lt;&lt; more &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">hello hello hello</span><br></pre></td></tr></table></figure><p>在内部，main将字符串“hello”复制3次，结果得到4个副本。首先是字符串文字“hello”，它在编译时已知，并存储在二进制文件中。当我们创建char[]时，会创建一个副本。接下来的两个std::string对象分别创建该字符串的一个副本。</p><p><strong>因为std::string被设计为可修改的</strong>，<strong>所以每个std::string必须包含其自身的字符串副本，以便可以修改给定的std::string而不影响任何其他std::string对象。</strong></p><p><strong>所以，即使，是 const std::string，也是会被修改的。</strong></p><hr><h3 id="std-string-view-1"><a href="#std-string-view-1" class="headerlink" title="std::string_view"></a>std::string_view</h3><p>想象一下你房子里的一扇窗户，看着停在街上的一辆车。你可以透过窗户看到那辆车，但你不能触摸或移动那辆车。你的窗口只是提供了一个汽车的视图，这是一个完全独立的对象。</p><p><strong>c++ 17引入了另一种使用字符串的方法，<code>std::string_view</code>，它位于头文件<code>&lt;string_view&gt;</code>中。</strong></p><blockquote><p>与<code>std::string</code>不同的是，<code>std::string_view</code>保存了自己的字符串副本，它提供了在其他地方定义的字符串的视图。</p></blockquote><p>修改上面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::string_view <span class="built_in">text</span>&#123;<span class="string">"hello"</span>&#125;; <span class="comment">// view the text "hello", which is stored in the binary</span></span><br><span class="line">    <span class="built_in">std</span>::string_view str&#123; <span class="built_in">text</span> &#125;; <span class="comment">// view of the same "hello"</span></span><br><span class="line">    <span class="built_in">std</span>::string_view more&#123; str &#125;; <span class="comment">// view of the same "hello"</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">text</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; str &lt;&lt; <span class="string">' '</span> &lt;&lt; more &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">hello hello hello</span><br></pre></td></tr></table></figure><p>这两个例子结果相同。但是此例子不再创建字符串“hello”的副本。当我们复制<code>std::string_view</code>时，新的<code>std::string_view</code>观察到的字符串与复制自<code>std::string_view</code>的字符串相同。</p><hr><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p><code>string_view</code>不仅速度快，而且有许多我们从std::string中了解到的函数。</p><hr><h4 id="string-view没有创建字符串的副本"><a href="#string-view没有创建字符串的副本" class="headerlink" title="string_view没有创建字符串的副本"></a><code>string_view</code>没有创建字符串的副本</h4><p>因为<code>std::string_view</code>并不创建字符串的副本，如果我们更改所查看的字符串，则更改将反映在<code>std::string_view</code>中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> arr[]&#123; <span class="string">"Gold"</span> &#125;;</span><br><span class="line">  <span class="built_in">std</span>::string_view str&#123; arr &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// Gold</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Change 'd' to 'f' in arr </span></span><br><span class="line">  arr[<span class="number">3</span>] = <span class="string">'f'</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// Golf</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们修改了arr，但是str似乎也在改变。这是因为：<strong>这是因为arr和str共享它们的字符串。</strong></p><hr><h4 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h4><ul><li><p>尽量使用<code>std::string_view</code> 来替代C风格字符串。</p></li><li><p>对于<strong>只读字符串</strong>，最好使用<code>std::string_view</code>而不是std::string，除非您已经使用了std::string。</p></li></ul><h3 id="std-string-view的修改函数"><a href="#std-string-view的修改函数" class="headerlink" title="std::string_view的修改函数"></a>std::string_view的修改函数</h3><p>回到我们的窗户类比，考虑一个有窗帘的窗户。我们可以关闭左边或右边的窗帘来减少我们能看到的东西。我们不改变外面的东西，我们只是减少可见的面积。</p><p>类似地，std::string_view包含一些函数，这些函数允许我们操作字符串的视图。这允许我们在不修改所查看的字符串的情况下更改视图。</p><p>这函数就是：</p><ul><li><code>remove_prefix</code>：从视图<strong>左</strong>侧删除字符</li><li><code>remove_suffix</code>：从视图<strong>右</strong>侧删除字符。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; //for std::strlen</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::string_view str&#123;<span class="string">"peach"</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Ignore the first characters.</span></span><br><span class="line">    str.remove_prefix(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Ignore the last 2 characters.</span></span><br><span class="line">    str.remove_suffix(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Peach</span><br><span class="line">each</span><br><span class="line">ea</span><br></pre></td></tr></table></figure><p><strong>与真正的窗帘不同，std::string_view不能打开备份。一旦你改变了可见区域，你就回不去了</strong>(有些技巧我们不会去做)。</p><h3 id="std-string-view与非空终止的字符串"><a href="#std-string-view与非空终止的字符串" class="headerlink" title="std::string_view与非空终止的字符串"></a>std::string_view与非空终止的字符串</h3><p>与C-style字符串和std::string 不同，<strong><code>std::string_view</code>的字符串是不使用空终止符来标记字符串的结束。相反，它知道字符串的结束位置，因为它跟踪字符串的长度。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt; // For std::size</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// No null-terminator.</span></span><br><span class="line">  <span class="keyword">char</span> vowels[]&#123; <span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>, <span class="string">'o'</span>, <span class="string">'u'</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// vowels isn't null-terminated. We need to pass the length manually.</span></span><br><span class="line">  <span class="comment">// Because vowels is an array, we can use std::size to get its length.</span></span><br><span class="line">  <span class="built_in">std</span>::string_view str&#123; vowels, <span class="built_in">std</span>::<span class="built_in">size</span>(vowels) &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// This is safe. std::cout knows how to print std::string_views.</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">aeiou</span><br></pre></td></tr></table></figure><h3 id="所有制的问题"><a href="#所有制的问题" class="headerlink" title="所有制的问题"></a>所有制的问题</h3><p>作为一个视图，std::string_view的生存期独立于它所查看的字符串的生存期。如果所查看的字符串超出其生命周期范围，那么std::string_view没有什么要观察的，访问它会导致未定义的行为。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::string_view <span class="title">askForName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"what's your name?\n"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用std::string，因为std::cin需要修改它。</span></span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> str&#123;&#125;;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 我们将切换到std::string_view，仅用于演示目的。</span></span><br><span class="line"><span class="comment">// 如果你已经有一个std::string，没有理由切换到std:: string_view。</span></span><br><span class="line"><span class="built_in">std</span>::string_view view&#123;str&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello "</span> &lt;&lt; view &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> view; </span><br><span class="line">&#125; <span class="comment">// str消失了，str创建的字符串也消失了。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">std</span>::string_view view&#123; askForName() &#125;;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// view is observing a string that already died.</span></span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Your name is "</span> &lt;&lt; view &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// Undefined behavior</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">What<span class="number">'</span>s your name?</span><br><span class="line">nascardriver</span><br><span class="line">Hello nascardriver</span><br><span class="line">Your name is �P@�P@ （因为这里访问的时候，view已经“死了”）</span><br></pre></td></tr></table></figure><h3 id="将std-string-view转换为std-string"><a href="#将std-string-view转换为std-string" class="headerlink" title="将std::string_view转换为std::string"></a>将std::string_view转换为std::string</h3><p>string_view不会隐式地转换为std::string，但是可以显式地转换为:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::string_view sv&#123; <span class="string">"balloon"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  sv.remove_suffix(<span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// print(sv); // compile error: won't implicitly convert</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> str&#123; sv &#125;; <span class="comment">// explicit conversion</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">print</span>(str); <span class="comment">// okay</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">print</span>(<span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(sv)); <span class="comment">// okay</span></span><br><span class="line">   </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">ball</span><br><span class="line">ball</span><br></pre></td></tr></table></figure><h3 id="将std-string-view转换为c风格的字符串"><a href="#将std-string-view转换为c风格的字符串" class="headerlink" title="将std::string_view转换为c风格的字符串"></a>将std::string_view转换为c风格的字符串</h3><p>一些旧的函数(如旧的strlen函数)仍然期望c风格的字符串。要将std::string_view转换为c风格的字符串，我们可以首先将其转换为std::string:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::string_view sv&#123; <span class="string">"balloon"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  sv.remove_suffix(<span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Create a std::string from the std::string_view</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> str&#123; sv &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Get the null-terminated C-style string.</span></span><br><span class="line">  <span class="keyword">auto</span> szNullTerminated&#123; str.c_str() &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Pass the null-terminated string to the function that we want to use.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">" has "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">strlen</span>(szNullTerminated) &lt;&lt; <span class="string">" letter(s)\n"</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">ball has <span class="number">4</span> letter(s)</span><br></pre></td></tr></table></figure><p>但是，每次我们希望将std::string_view作为c风格的字符串传递时，创建一个std::string是非常消耗资源的，因此应该尽可能避免这种情况。</p><h3 id="data-函数"><a href="#data-函数" class="headerlink" title="data()函数"></a>data()函数</h3><p><strong>可以使用data()函数访问std::string_view所查看的字符串，该函数返回一个c风格的字符串。</strong>这提供了对正在查看的字符串(作为c字符串)的快速访问。</p><blockquote><p><strong>但是它也应该只在std::string_view的视图没有被修改</strong>(例如通过remove_prefix或remove_suffix)<strong>并且被查看的字符串以null结尾的情况下使用</strong>。</p></blockquote><p>在下面的例子中，std::strlen不知道std::string_view是什么，所以我们需要传递它str.data():</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; // For std::strlen</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::string_view str&#123; <span class="string">"balloon"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// We use std::strlen because it's simple, this could be any other function</span></span><br><span class="line">  <span class="comment">// that needs a null-terminated string.</span></span><br><span class="line">  <span class="comment">// It's okay to use data() because we haven't modified the view, and the</span></span><br><span class="line">  <span class="comment">// string is null-terminated.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">strlen</span>(str.data()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">balloon</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><p>当修改了std::string_view之后，data()并不总是做我们希望它做的事情。下面的例子演示了在修改视图后访问data()时会发生什么:【所以，此时不建议使用data()函数】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::string_view str&#123; <span class="string">"balloon"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Remove the "b"</span></span><br><span class="line">  str.remove_prefix(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// remove the "oon"</span></span><br><span class="line">  str.remove_suffix(<span class="number">3</span>);</span><br><span class="line">  <span class="comment">// Remember that the above doesn't modify the string, it only changes</span></span><br><span class="line">  <span class="comment">// the region that str is observing.</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">" has "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">strlen</span>(str.data()) &lt;&lt; <span class="string">" letter(s)\n"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"str.data() is "</span> &lt;&lt; str.data() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"str is "</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，这不是我们想要的，这是试图访问已修改的std::string_view的数据()的结果。在访问data()时，有关字符串的长度信息将丢失。std::strlen和std::cout不断地从底层字符串中读取字符，直到它们找到空终止符，也就是“balloon”的结尾。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>std::cin（输入）</title>
      <link href="/archives/a4b39f57.html"/>
      <url>/archives/a4b39f57.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red>std::cin（输入）</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><p>我们可以使用<code>std::cin</code>来输入文本；因为文本输入是自由格式的(用户可以输入任何内容)，所以用户很容易输入不需要的内容。</p><p>在编写程序时，您应该始终考虑用户将如何(无意中或以其他方式)滥用您的程序。一个编写良好的程序可以预测用户将如何滥用它，并优雅地处理这些情况，或者在一开始就防止它们发生(如果可能的话)。一个能很好地处理错误情况的程序是<strong>robust(健壮的)</strong>。</p><p>在本节课中，我们将专门研究用户通过<code>std::cin</code>输入无效文本的方法，并向您展示处理这些情况的一些不同方法。</p><h2 id="std-cin-buffers-and-extraction"><a href="#std-cin-buffers-and-extraction" class="headerlink" title="std::cin, buffers, and extraction"></a>std::cin, buffers, and extraction</h2><p>为了讨论<code>std::cin</code>和操作符<code>&gt;&gt;</code>是如何失败的，首先需要了解一下它们是如何工作的。</p><p>当我们使用操作符<code>&gt;&gt;</code>来获取用户的输入，然后将该输入放进一个变量中，这个过程叫做：<strong>extraction(提取)</strong>。此时操作符<code>&gt;&gt;</code>也就叫做 <strong>提取操作符</strong>。</p><hr><h3 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h3><p>当用户响应提取操作输入数据时，该数据被放置在<code>std::cin</code>中的<strong>buffer（缓冲区)</strong>中。</p><blockquote><p>一个<strong>buffer</strong>(也称：<strong>data buffer</strong>)：<u>就是</u>在数据从一个地方移动到另一个地方时用来临时存储数据的<u>一块内存</u>。</p></blockquote><p>所以，在这里的缓冲区就<u>用来</u> 当用户输入的内容还没有被提取到变量中时 <u>保存它</u>。</p><p>当你使用提取操作符时，会发生以下过程：</p><ul><li>如果在输入缓冲区中已经有数据，那么这个数据是准备被提取的；</li><li>如果输入缓冲区中没有数据，那么要求用户输入数据以进行提取(大多数情况下都是这样)。当用户回车时，一个’ \n ‘字符将被放入输入缓冲区。</li><li>操作符<code>&gt;&gt;</code> 会从输入缓冲区提取尽可能多的数据到变量中(会忽略的空白字符，如空格、制表符或’ \n ‘。)</li><li>不能提取缓冲区中留给下一次提取的数据。</li></ul><hr><ol><li><p><strong>提取数据成功</strong></p><p><strong>只要在输入缓冲区中提取到一个字符就算成功</strong>。那些剩下的不符合本次提取的数据会留着下一次提取。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比如用户输入：5a 给变量x;</span></span><br><span class="line"><span class="comment">//将提取5，并将其转换为整数，赋值给变量x，“a\n”将留在输入流中进行下一次提取。</span></span><br></pre></td></tr></table></figure></li><li><p><strong>提取数据失败</strong></p><p>如果输入数据与要提取的变量的类型不匹配，则提取失败。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果用户输入“b”，提取将失败，因为“b”不能提取为整数变量。</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="输入验证"><a href="#输入验证" class="headerlink" title="输入验证"></a>输入验证</h3><p>检查用户输入是否符合程序期望的过程称为<strong>input validation(输入验证)</strong>。</p><p>进行输入验证有三种基本方法:</p><ul><li>内联(作为用户类型)<ul><li>首先防止用户输入无效的输入。</li></ul></li><li>输入后(在用户输入之后)<ul><li>让用户在字符串中输入他们想要的任何内容，然后验证该字符串是否正确，如果正确，则将该字符串转换为最终的变量类型。</li><li>让用户输入他们想要的任何东西，让std::cin和操作符&gt;&gt;尝试提取它，并处理错误情况。</li></ul></li></ul><p>一些图形用户界面和高级文本界面将允许您在用户输入时验证输入(逐个字符)。一般来说，程序员提供一个验证函数，该函数接受用户目前输入的输入，如果输入有效则返回true，否则返回false。每当用户按下一个键时，都会调用这个函数。如果验证函数返回true，则接受用户刚刚按下的键。如果验证函数返回false，则丢弃用户刚刚输入的字符(并且不显示在屏幕上)。<strong>不幸的是，std::cin不支持这种类型的验证。</strong></p><p>由于字符串对可以输入什么字符没有任何限制，所以提取一定会成功(但是请记住，std::cin在第一个非前导空格字符处停止提取)。一旦输入了一个字符串，程序就可以解析该字符串，看看它是否有效。<strong>然而，解析字符串并将字符串输入转换为其他类型(例如数字)可能会很困难，所以这只在极少数情况下才会完成。</strong></p><p><strong>大多数情况下，我们让std::cin和提取操作符<code>&gt;&gt;</code>来做这个工作。在这种方法下，我们让用户输入他们想要的任何东西，让std::cin和操作符&gt;&gt;尝试提取它，如果它失败了，就编写程序处理它们。</strong></p><h4 id="一个例子："><a href="#一个例子：" class="headerlink" title="一个例子："></a>一个例子：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getDouble</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a double value: "</span>;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getOperator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter one of the following: +, -, *, or /: "</span>;</span><br><span class="line">    <span class="keyword">char</span> op;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">    <span class="keyword">return</span> op;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printResult</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">char</span> op, <span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="string">'+'</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" + "</span> &lt;&lt; y &lt;&lt; <span class="string">" is "</span> &lt;&lt; x + y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'-'</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" - "</span> &lt;&lt; y &lt;&lt; <span class="string">" is "</span> &lt;&lt; x - y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'*'</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" * "</span> &lt;&lt; y &lt;&lt; <span class="string">" is "</span> &lt;&lt; x * y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'/'</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" / "</span> &lt;&lt; y &lt;&lt; <span class="string">" is "</span> &lt;&lt; x / y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = getDouble();</span><br><span class="line">    <span class="keyword">char</span> op = getOperator();</span><br><span class="line">    <span class="keyword">double</span> y = getDouble();</span><br><span class="line"> </span><br><span class="line">    printResult(x, op, y);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>用户正常输入</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Enter a double value: 5</span><br><span class="line">Enter one of the following: +, -, *, or &#x2F;: *</span><br><span class="line">Enter a double value: 7</span><br><span class="line">5 * 7 is 35</span><br></pre></td></tr></table></figure></li><li><p><strong>用户输入无效文本</strong></p><ul><li><p><strong>1. 输入提取成功，但输入对程序没有意义</strong>(例如，输入“k”作为你的数学运算符)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Enter a double value: 5</span><br><span class="line">Enter one of the following: +, -, *, or &#x2F;: k</span><br><span class="line">Enter a double value: 7</span><br></pre></td></tr></table></figure><p><strong>解决办法</strong>：增加判断用户输入是否符合预期值的代码，当不符合时，重新输入：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getOperator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) <span class="comment">// Loop until user enters a valid input</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter one of the following: +, -, *, or /: "</span>;</span><br><span class="line">        <span class="keyword">char</span> op;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Check whether the user entered meaningful input</span></span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">'+'</span> || op == <span class="string">'-'</span> || op == <span class="string">'*'</span> || op == <span class="string">'/'</span>)    </span><br><span class="line">            <span class="keyword">return</span> op; <span class="comment">// return it to the caller</span></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// otherwise tell the user what went wrong</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Oops, that input is invalid.  Please try again.\n"</span>;</span><br><span class="line">    &#125; <span class="comment">// and try again</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>2. 提取成功，但是有额外的输入</strong></p><p>如：<code>Enter a double value: 5*7</code></p><p>运行结果是：(程序打印正确的答案，但格式却一团糟。这是为什么呢？)</p><blockquote><p>当用户输入“5*7”作为输入时，该输入将进入缓冲区。然后操作符&gt;&gt;将5提取到变量x中，在缓冲区中留下“*7\n”。接下来，程序输出“<code>Enter one of the following: +, -, *, or /:</code>”。但是，当调用提取操作符时，它会看到“*7\n”在缓冲区中等待提取，因此它使用该操作符而不是询问用户更多的输入。因此，它提取“*”字符，在缓冲区中留下“7\n”。</p><p>在要求用户输入另一个双精度值之后，缓冲区中的“7”被提取出来，而不需要询问用户。<strong>由于用户从未有机会输入其他数据并按下回车键(导致换行)</strong>，所以输出提示将一起运行在同一行上，即使输出是正确的。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter a double value: 5*7</span><br><span class="line">Enter one of the following: +, -, *, or &#x2F;: Enter a double value: 5 * 7 is 35</span><br></pre></td></tr></table></figure><p><strong>解决办法：</strong>使用<code>std::cin.ignore(32767, &#39;\n&#39;);</code></p><p>关于<code>cin.jgnore(32767 , &#39;\n&#39;);</code>的详细解释：<a href="https://www.yuque.com/longlongqin/pw9qpx/uap4n0#km6jq" target="_blank" rel="noopener">https://www.yuque.com/longlongqin/pw9qpx/uap4n0#km6jq</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getDouble</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a double value: "</span>;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="number">32767</span>, <span class="string">'\n'</span>); <span class="comment">// clear (up to 32767) characters out of the buffer until a '\n' character is removed</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>3. 提取失败</strong></p><p>如：<code>Enter a double value: a</code></p><p>运行结果：</p><blockquote><p>当用户输入“a”时，该字符被放置在缓冲区中。然后，操作符&gt;&gt;尝试将’ a ‘提取到变量x中，该变量的类型为double。由于’ a ‘不能被转换成double，所以操作符&gt;&gt;不能进行提取。此时会发生两件事:’ a ‘留在缓冲区中，std::cin进入“failure mode(故障模式)”。</p><p>一旦进入“故障模式”，未来的输入提取请求将以静悄悄的失败。因此，在我们的计算器程序中，输出提示仍然打印，但是任何进一步提取的请求都会被忽略。程序简单地运行到最后，然后终止(不打印结果，因为我们从来没有读过有效的数学运算)。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter a double value: a</span><br><span class="line">Enter one of the following: +, -, *, or &#x2F;: Enter a double value:</span><br></pre></td></tr></table></figure><p>解决方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">cin</span>.fail()) <span class="comment">// has a previous extraction failed? ⭐</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// yep, so let's handle the failure</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">clear</span>(); <span class="comment">// put us back in 'normal' operation mode ⭐</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="number">32767</span>,<span class="string">'\n'</span>); <span class="comment">// and remove the bad input</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>现在将这三种错误的解决办法结合起来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getDouble</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) <span class="comment">// Loop until user enters a valid input</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a double value: "</span>;</span><br><span class="line">        <span class="keyword">double</span> x;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">cin</span>.fail()) <span class="comment">// has a previous extraction failed? ⭐3</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// yep, so let's handle the failure</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">clear</span>(); <span class="comment">// put us back in 'normal' operation mode ⭐3</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="number">32767</span>,<span class="string">'\n'</span>); <span class="comment">// and remove the bad input ⭐2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// else our extraction succeeded</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="number">32767</span>, <span class="string">'\n'</span>); <span class="comment">// clear (up to 32767) characters out of the buffer until a '\n' character is removed ⭐2</span></span><br><span class="line">            <span class="keyword">return</span> x; <span class="comment">// so return the value we extracted</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：</em></p><blockquote><p>在C++11之前，如果这个变量已经被初始化过，那么失败的提取不会修改被提取到的变量的初始值。</p><p>在C++11及之后，由<strong>输入无效</strong>而导致提取失败将导致变量初始化为零。(0初始化意味着变量被设置为0, 0.0，” “，或者0转换为该类型的任何值。)</p></blockquote><ul><li><p><strong>4. 提取成功，但是提取的值溢出</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">int16_t</span> x &#123; <span class="number">0</span> &#125;; <span class="comment">// x is 16 bits, holds from -32768 to 32767</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number between -32768 and 32767: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">int16_t</span> y &#123; <span class="number">0</span> &#125;; <span class="comment">// y is 16 bits, holds from -32768 to 32767</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter another number between -32768 and 32767: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; y;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum is: "</span> &lt;&lt; x + y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果输入的数过大，会发生什么呢？（比如输入40000）*/</span></span><br><span class="line">Enter a number between <span class="number">-32768</span> <span class="keyword">and</span> <span class="number">32767</span>: <span class="number">40000</span></span><br><span class="line">Enter another number between <span class="number">-32768</span> <span class="keyword">and</span> <span class="number">32767</span>: The sum is: <span class="number">32767</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>std::cin</code>会立即进入“故障模式”，但也会将最接近的范围内值赋给变量。因此，x的赋值为32767。跳过其他输入，让y的初始值为0。我们可以使用与<strong>提取失败</strong>相同的方法来处理这种错误。</p><blockquote><p><em>注</em></p><p>在c++ 11之前，失败的提取不会修改被提取到的变量。这意味着如果一个变量没有初始化，那么在失败的提取情况下，它将保持未初始化状态。(比如y，这里它会保持初始值0)</p><p>从c++ 11开始，<strong>超过范围(out-of-range)</strong>时失败的提取将导致变量被设置为最接近的范围内值。</p></blockquote></li></ul></li></ul><hr><p>在我的vs2013中，测试上面的代码，得到的结果是：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://raw.githubusercontent.com/longlongqin/CDN-for-HEXO_BLOG/pig_bed/20200426155848.png" alt="image-20200426155834334"></p><p>这说明我的“故障模式”下，变量将会被初始化为0</p><h4 id="修改后的例子："><a href="#修改后的例子：" class="headerlink" title="修改后的例子："></a>修改后的例子：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getDouble</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) <span class="comment">// Loop until user enters a valid input</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a double value: "</span>;</span><br><span class="line">        <span class="keyword">double</span> x;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Check for failed extraction</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">cin</span>.fail()) <span class="comment">// has a previous extraction failed?</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// yep, so let's handle the failure</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">clear</span>(); <span class="comment">// put us back in 'normal' operation mode</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="number">32767</span>,<span class="string">'\n'</span>); <span class="comment">// and remove the bad input</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Oops, that input is invalid.  Please try again.\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="number">32767</span>,<span class="string">'\n'</span>); <span class="comment">// remove any extraneous input</span></span><br><span class="line"> </span><br><span class="line">            <span class="comment">// the user can't enter a meaningless double value, so we don't need to worry about validating that</span></span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getOperator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) <span class="comment">// Loop until user enters a valid input</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter one of the following: +, -, *, or /: "</span>;</span><br><span class="line">        <span class="keyword">char</span> op;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Chars can accept any single input character, so no need to check for an invalid extraction here</span></span><br><span class="line"> </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="number">32767</span>,<span class="string">'\n'</span>); <span class="comment">// remove any extraneous input</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Check whether the user entered meaningful input</span></span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">'+'</span> || op == <span class="string">'-'</span> || op == <span class="string">'*'</span> || op == <span class="string">'/'</span>)    </span><br><span class="line">            <span class="keyword">return</span> op; <span class="comment">// return it to the caller</span></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// otherwise tell the user what went wrong</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Oops, that input is invalid.  Please try again.\n"</span>;</span><br><span class="line">    &#125; <span class="comment">// and try again</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printResult</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">char</span> op, <span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="string">'+'</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" + "</span> &lt;&lt; y &lt;&lt; <span class="string">" is "</span> &lt;&lt; x + y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'-'</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" - "</span> &lt;&lt; y &lt;&lt; <span class="string">" is "</span> &lt;&lt; x - y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'*'</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" * "</span> &lt;&lt; y &lt;&lt; <span class="string">" is "</span> &lt;&lt; x * y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'/'</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" / "</span> &lt;&lt; y &lt;&lt; <span class="string">" is "</span> &lt;&lt; x / y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// Being robust means handling unexpected parameters as well, even though getOperator() guarantees op is valid in this particular program</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Something went wrong: printResult() got an invalid operator."</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = getDouble();</span><br><span class="line">    <span class="keyword">char</span> op = getOperator();</span><br><span class="line">    <span class="keyword">double</span> y = getDouble();</span><br><span class="line"> </span><br><span class="line">    printResult(x, op, y);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在编写程序时，要考虑用户如何误用程序，特别是在文本输入方面。对于文本输入的每个点，请考虑:</p><ul><li>提取是否失败？</li><li>用户是否会输入比预期更多的文本？</li><li>用户是否会输入没有意义的文本？</li><li>用户是否会输出溢出的值？</li></ul><p>您可以使用<strong>if语句和布尔逻辑</strong>来测试输入是否是预期的和有意义的。</p><h3 id="修复提取失败-amp-溢出"><a href="#修复提取失败-amp-溢出" class="headerlink" title="修复提取失败&amp;溢出"></a>修复提取失败&amp;溢出</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">cin</span>.fail()) <span class="comment">// has a previous extraction failed or overflowed?</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// yep, so let's handle the failure</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">clear</span>(); <span class="comment">// put us back in 'normal' operation mode</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="number">32767</span>,<span class="string">'\n'</span>); <span class="comment">// and remove the bad input</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="清除额外的输入"><a href="#清除额外的输入" class="headerlink" title="清除额外的输入"></a>清除额外的输入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="number">32767</span>,<span class="string">'\n'</span>); <span class="comment">// and remove the bad input</span></span><br></pre></td></tr></table></figure><hr><p>最后，如果原始输入无效，使用循环要求用户重新输入输入。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/------</title>
      <link href="/archives/3f9a28c4.html"/>
      <url>/archives/3f9a28c4.html</url>
      
        <content type="html"><![CDATA[<p>原文：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LearnCpp chapter8</title>
      <link href="/archives/c812a74c.html"/>
      <url>/archives/c812a74c.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red>LearnCpp-chapter8</red></p></center><center><red>https://www.learncpp.com</red></center><p>未完待续~~</p><a id="more"></a><h2 id="8-1-介绍面向对象编程"><a href="#8-1-介绍面向对象编程" class="headerlink" title="8.1 介绍面向对象编程"></a>8.1 介绍面向对象编程</h2><center><red>Object-oriented programming (OOP)</red></center><p>在 <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-variables/" target="_blank" rel="noopener">1.3 – Introduction to variables</a>中，我们在c++中将<strong>一个对象定义为“一段可用来存储值的内存”。</strong>具<strong>有名称的对象称为变量。</strong></p><p>在传统编程中(我们在此之前一直在做的工作)，程序基本上是计算机的指令列表，这些指令定义数据(通过对象)，然后处理数据(通过语句和函数)。数据和处理该数据的函数是独立的实体，它们组合在一起以产生所需的结果。由于这种分离，传统的编程通常不能提供对现实的非常直观的表示。</p><p>由程序员以适当的方式管理和连接 <strong>属性(变量)</strong>和<strong>行为(函数)</strong>，这就致使代码变成这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driveTo(you, work);</span><br></pre></td></tr></table></figure><h3 id="什么是面向对象编程？"><a href="#什么是面向对象编程？" class="headerlink" title="什么是面向对象编程？"></a>什么是面向对象编程？</h3><p>和许多事物一样，它可能最容易通过类比来理解。看看你的周围–你看到的每一个地方都是<strong>object</strong>：书籍、建筑物、食物，甚至你自己。</p><p><strong>object</strong>有两个主要的部分：</p><ol><li>（<strong>properties</strong>）<strong>相关属性的列表</strong>（e.g. weight, color, size, solidity, shape, etc…）</li><li>（<strong>behavior</strong>）<strong>这些属性能表现出的一些行为</strong>（e.g. being opened, making something else hot, etc…）</li></ol><p>这些<strong>属性</strong>和<strong>行为</strong>是不可分割的。</p><hr><p>Object-oriented programming (OOP) 为我们提供了创建对象的能力，这些对象将属性和行为绑定到一个自包含的、可重用的包中。这导致代码看起来更像这样:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you.driveto(work);</span><br></pre></td></tr></table></figure><blockquote><p>这不仅读起来更清晰，还使主语(您)和被调用的行为(在某处驾驶)更清晰。</p><p><strong>不是专注于编写函数，而是专注于定义具有定义良好的行为集的对象</strong>。<strong>这就是为什么这个范例被称为“面向对象”。</strong></p></blockquote><hr><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>这允许以更模块化的方式编写程序，这使它们更容易编写和理解，还提供了更高程度的<strong>代码可重用性</strong>。</p><p>这些对象还提供了一种 <strong>通过允许我们定义如何与对象交互以及如何与其他对象交互，来更直观的方式来处理数据。</strong></p><blockquote><p>请注意，OOP并没有取代传统的编程方法。相反，它在编程工具带中为您提供了额外的工具，以便在需要时管理复杂性。</p></blockquote><h4 id="object"><a href="#object" class="headerlink" title="object"></a>object</h4><p>请注意，<strong>术语“object”被稍微重载了一些</strong>，这导致了一些混淆。<strong>在传统编程中，对象是用来存储值的一块内存</strong>。<strong>在面向对象编程中，“对象”意味着它包含 传统编程意义上的对象，又是属性和行为的组合。</strong>从现在开始，当我们使用“对象”这个术语时，我们将在面向对象的意义上引用“对象”。</p><h2 id="8-2-类-amp-类成员"><a href="#8-2-类-amp-类成员" class="headerlink" title="8.2 类&amp;类成员"></a>8.2 类&amp;类成员</h2><p>虽然C++提供一些基本的数据类型（e.g. char, int, long, float, double, etc…），它们可以解决一些简单的问题。</p><p>但是在解决复杂问题的时候这些基本数据类型就不够用了。</p><blockquote><p>C++也提供：<strong>允许用户自定义数据类型</strong>，如之前学的： <strong><a href="http://www.learncpp.com/cpp-tutorial/45-enumerated-types/" target="_blank" rel="noopener">enumerated types</a></strong>、<a href="http://www.learncpp.com/cpp-tutorial/47-structs/" target="_blank" rel="noopener"><strong>structs</strong></a></p></blockquote><p>在C++，中<code>class</code>与 <code>struct</code>本质上相同。如下面的两个是等价的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DateStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_year;</span><br><span class="line">    <span class="keyword">int</span> m_month;</span><br><span class="line">    <span class="keyword">int</span> m_day;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>注意，惟一显著的区别是<code>public:</code>关键字在类中</p></blockquote><p><strong>类(和结构体)定义就像一个蓝图——它们描述结果对象的样子，但是它们实际上并不创建对象</strong>。<u>要实际创建类的对象，必须定义该类类型的变量:</u></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DateClass today &#123; <span class="number">2020</span>, <span class="number">10</span>, <span class="number">14</span> &#125;; <span class="comment">// declare a variable of class DateClass</span></span><br></pre></td></tr></table></figure><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p>除了保存数据，类(和结构)还可以包含函数! 在类内部定义的函数称为<strong>成员函数</strong> (有时也称为<strong>方法</strong>)。</p><h4 id="成员函数-amp-非成员函数"><a href="#成员函数-amp-非成员函数" class="headerlink" title="成员函数&amp;非成员函数"></a>成员函数&amp;非成员函数</h4><p>eg：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非成员函数：函数不能调用定义在它下面的函数(没有前向声明):</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// You can't call y() from here unless the compiler has already seen a forward declaration for y()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数：成员函数没有这个限制</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">x</span><span class="params">()</span> </span>&#123;y()&#125; ;<span class="comment">// okay to call y() here, even though y() isn't defined until later in this class</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">y</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成员类型"><a href="#成员类型" class="headerlink" title="成员类型"></a>成员类型</h3><p>除了成员变量和成员函数外，类还可以具有<strong>成员类型</strong>或<strong>嵌套类型</strong>(包括<strong>类型别名</strong>)。在下面的例子中，我们创建了一个计算器，如果需要，我们可以快速地更改它所使用的数字类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vertor&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">number_t</span> = <span class="keyword">int</span>; <span class="comment">//这是一个嵌套类型的别名</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">number_t</span>&gt; m_result&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">number_t</span> <span class="title">add</span> <span class="params">(<span class="keyword">number_t</span> a, <span class="keyword">number_t</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//auto的原理就是根据后面的值，来自己推测前面的类型是什么。</span></span><br><span class="line">        <span class="keyword">auto</span> result &#123;a+b&#125;;</span><br><span class="line">        m_result.push_back (result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Calculator calculator &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; calculator.add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这样的上下文中，<strong>类名</strong>实际上充当嵌套类型的<strong>，命名空间</strong>。在类内部，我们只需要引用number_t。在类之外，我们可以通过Calculator::number_t访问类型。</p><hr><h3 id="关于C-中的struct的说明"><a href="#关于C-中的struct的说明" class="headerlink" title="关于C++中的struct的说明"></a>关于C++中的struct的说明</h3><p>在C语言中，<strong>结构体只能保存数据</strong>，<strong>没有成员函数</strong>。但是咋C++中，两者都可以有。</p><p>经过考虑，他决定他们应该有一个统一的规则集。因此，<strong>虽然我们使用class关键字编写了上述程序，但我们可以使用struct关键字。</strong></p><p>所以，建议：</p><blockquote><p><strong>对只包含数据的结构使用struct关键字</strong>。<strong>对同时具有数据和函数的对象使用class关键字。</strong></p></blockquote><h2 id="8-3-访问说明符-piblicVS-private"><a href="#8-3-访问说明符-piblicVS-private" class="headerlink" title="8.3 访问说明符 piblicVS private"></a>8.3 访问说明符 <code>piblic</code>VS <code>private</code></h2><p><strong>public</strong>：<code>class</code>和<code>struct</code>的public member 可以在 它们的外部访问；</p><blockquote><p><strong>由关键字<code>struct</code>构成的数据类型，默认是public。</strong></p></blockquote><p><strong>private</strong>：只能被类的其他成员访问；</p><blockquote><p><strong>由<code>class</code>构成的数据类型，默认是private。</strong></p></blockquote><hr><p><strong>通常，成员变量通常是<code>private</code>的，而成员函数通常是<code>public</code>的。</strong></p><p>eg：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DateStruct</span> // <span class="title">members</span> <span class="title">are</span> <span class="title">public</span> <span class="title">by</span> <span class="title">default</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> month; <span class="comment">// public by default, can be accessed by anyone</span></span><br><span class="line">    <span class="keyword">int</span> day; <span class="comment">// public by default, can be accessed by anyone</span></span><br><span class="line">    <span class="keyword">int</span> year; <span class="comment">// public by default, can be accessed by anyone</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DateStruct date;</span><br><span class="line">    date.month = <span class="number">10</span>;</span><br><span class="line">    date.day = <span class="number">14</span>;</span><br><span class="line">    date.year= <span class="number">2020</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateClass</span> // <span class="title">members</span> <span class="title">are</span> <span class="title">private</span> <span class="title">by</span> <span class="title">default</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m_month; <span class="comment">// private by default, can only be accessed by other members</span></span><br><span class="line">    <span class="keyword">int</span> m_day; <span class="comment">// private by default, can only be accessed by other members</span></span><br><span class="line">    <span class="keyword">int</span> m_year; <span class="comment">// private by default, can only be accessed by other members</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DateClass date;</span><br><span class="line">    date.m_month = <span class="number">10</span>; <span class="comment">// error</span></span><br><span class="line">    date.m_day = <span class="number">14</span>; <span class="comment">// error</span></span><br><span class="line">    date.m_year = <span class="number">2020</span>; <span class="comment">// error</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类的<strong>public member</strong>通常被看作 <strong>public interface（公共接口）</strong>：因为只有public mebmber才可以在类外部被访问，但是public member可以直接访问类中的private和protected的成员。<strong>所以利用public member 可以间接访问类的private和protected的成员。</strong></p><hr>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnCpp chapterL</title>
      <link href="/archives/9f7a1269.html"/>
      <url>/archives/9f7a1269.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red>LearnCpp-chapterL</red></p></center><center><red>https://www.learncpp.com</red></center><p>未完待续~~</p><a id="more"></a><h2 id="L5-1-控制流"><a href="#L5-1-控制流" class="headerlink" title="L5.1 控制流"></a>L5.1 控制流</h2><p>当程序运行时，CPU开始从<code>mian()</code>函数执行，然后执行它里面的语句，最后结束于<code>main()</code>函数结尾。</p><p>CPU执行语句的顺序叫做：<strong>程序执行路径(execution path)</strong>。</p><h3 id="停止-halt"><a href="#停止-halt" class="headerlink" title="停止(halt)"></a>停止(halt)</h3><p>但程序运行并不总是将<code>main()</code>函数中的语句全部执行。它可以被停止。在C++中，可以使用<strong>头文件<code>cstdlib</code>中的<code>std::exit()</code>函数</strong>，来终止程序。</p><blockquote><p><code>exit</code>函数接受一个整数参数，该参数作为std::exit代码返回给操作系统，这与main()的返回值非常相似。</p></blockquote><p>eg:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; //for std::exit()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//code here to do any kind of cleanup required</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    cleanup();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">//程序在此结束，并且向操作系统返回0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//所以下面的语句将不会执行</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="number">2</span>&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>，<code>std::exit()</code>无论从哪个函数调用(甚至是<code>main</code>以外的函数)都可以工作。还要注意，<code>std::exit()</code>使用最少的清理立即终止程序。所以，在使用<code>std::exit()</code>之前，您应该考虑是否需要进行任何手动清理(例如将用户的游戏保存到磁盘)。</p><blockquote><p>通常，<code>std::exit()</code>用于在发生灾难性的、不可恢复的错误时立即终止程序。</p></blockquote><h2 id="L5-1-if语句"><a href="#L5-1-if语句" class="headerlink" title="L5.1 if语句"></a>L5.1 if语句</h2><p>最基本的条件分支就是 <strong>if 语句</strong>。</p><h3 id="隐式的块"><a href="#隐式的块" class="headerlink" title="隐式的块"></a>隐式的块</h3><p>我们需要注意，隐式的块中的一些陷阱，</p><h4 id="陷阱1："><a href="#陷阱1：" class="headerlink" title="陷阱1："></a>陷阱1：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">6</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为上面的x是在一个块中被定义的(这个块没有显式的写出来，但它确实是一个块)</span></span><br></pre></td></tr></table></figure><p>上面这个程序会出错，原因：（这将无法编译，编译器将生成标识符<code>x</code>未定义的错误）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面的程序和这个程序相等。这个程序将块显式的表示出来了</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">    &#125; <span class="comment">// x destroyed here</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">6</span>;</span><br><span class="line">    &#125; <span class="comment">// x destroyed here</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x; <span class="comment">// x isn't defined here</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="陷阱2："><a href="#陷阱2：" class="headerlink" title="陷阱2："></a>陷阱2：</h4><p>程序1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= <span class="number">20</span>)</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">"is between 10 and 20\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// attached to outer if statement</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">"is less than 10\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序2：（去掉大括号）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">10</span>)</span><br><span class="line">    <span class="comment">//删除大括号</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt;= <span class="number">20</span>)</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">"is between 10 and 20\n"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// attached to outer if statement</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">"is less than 10\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序1和2是否一样呢？</p><p>答：不一样。程序1中的最后的else语句是与第一个if语句匹配；程序2中的最后的else语句是与它最近的if语句匹配。</p><h3 id="if中的初始化语句"><a href="#if中的初始化语句" class="headerlink" title="if中的初始化语句"></a>if中的初始化语句</h3><p>如果需要在If语句中使用变量，而不是在If语句之外，<strong>那么可以在条件之前使用init语句</strong>(在C++17中添加的）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> firstname&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> lastname&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"First name: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; firstName;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Last name: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; lastName;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">std</span>::<span class="built_in">string</span> fullname &#123;firsstname + <span class="string">' '</span> + lastname&#125;; fullname.length()&gt;<span class="number">20</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; '"'&lt;&lt;fullname &lt;&lt;'\" is to long \n';</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"your name is: "</span> &lt;&lt;fullname;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量<code>fullname</code>在整个if语句中是可以访问的。</p><h2 id="L5-2-switch语句"><a href="#L5-2-switch语句" class="headerlink" title="L5.2 switch语句"></a>L5.2 switch语句</h2><p>C++ 中 <strong>switch</strong> 语句的语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> constant-expression  :</span><br><span class="line">       statement(s);</span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">// 可选的</span></span><br><span class="line">    <span class="keyword">case</span> constant-expression  :</span><br><span class="line">       statement(s);</span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">// 可选的</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 您可以有任意数量的 case 语句</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">// 可选的</span></span><br><span class="line">       statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>switch</strong> 语句必须遵循下面的规则：</p><ul><li><p><strong>switch</strong> 语句中的 <strong>expression</strong> 必须是一个<strong>integral type(整数类型)或浮点类型</strong>，或者是一个 class 类型，其中 class 有一个单一的转换函数将其转换为整型或枚举类型。</p><blockquote><p><strong>整数类型</strong>有：<code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>long long</code>, or <code>enum</code></p><p>注意，<strong>在C/C++中，char是属于整数类型的</strong>。</p></blockquote></li><li><p>在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。</p></li><li><p>case 的 <strong>constant-expression</strong> 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。</p></li><li><p>当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 <strong>break</strong> 语句为止。</p></li><li><p>当遇到 <strong>break</strong> 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。</p></li><li><p>不是每一个 case 都需要包含 <strong>break</strong>。如果 case 语句不包含 <strong>break</strong>，控制流将会 <em>继续</em> 后续的 case，直到遇到 break 为止。</p></li><li><p>一个 <strong>switch</strong> 语句可以有一个可选的 <strong>default</strong> case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 <strong>break</strong> 语句不是必需的。</p></li></ul><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><h4 id="在case语句中有、无-break-的效果"><a href="#在case语句中有、无-break-的效果" class="headerlink" title="在case语句中有、无 break 的效果"></a>在case语句中有、无 break 的效果</h4><p>在 switch 语句中，每个 case 语句的结尾不要忘记添加 break 语句，否则将导致多个分支重叠。当然，除非有意使多个分支重叠，这样可以免去 break 语句。下面我们来看一个实际示例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有break</span></span><br><span class="line"><span class="keyword">switch</span> (<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// Does not match</span></span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// skipped</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// Match!</span></span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// Execution begins here</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// This is also executed</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">4</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// This is also executed</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">5</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// This is also executed</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**结果******/</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line"><span class="comment">//无break</span></span><br><span class="line"><span class="keyword">switch</span> (<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// Does not match</span></span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// skipped</span></span><br><span class="line">   <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// Match!</span></span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// Execution begins here</span></span><br><span class="line">   <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// This is also executed</span></span><br><span class="line">   <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">4</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// This is also executed</span></span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">5</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// This is also executed</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******结果***********/</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="case语句中变量的声明-amp-定义"><a href="#case语句中变量的声明-amp-定义" class="headerlink" title="case语句中变量的声明&amp;定义"></a>case语句中变量的声明&amp;定义</h3><p><strong>你可以在switch语句中声明变量(但不能够初始化)</strong>。在case之前或之后均可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a; <span class="comment">// okay, declaration is allowed before the case labels</span></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">5</span>; <span class="comment">// illegal, initialization is not allowed before the case labels</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">int</span> y; <span class="comment">// okay, declaration is allowed within a case</span></span><br><span class="line">        y = <span class="number">4</span>; <span class="comment">// okay, 这个是赋值(不是初始化)</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        y = <span class="number">5</span>; <span class="comment">// okay, y was declared above, so we can use it here too</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">int</span> z = <span class="number">4</span>; <span class="comment">// illegal, 不能再这里面对变量初始化</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"default case"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为在switch语句中，不存在隐式的块。所以，在switch语句内，所有语句的范围都一样(存在于switch的内部)。所以，在case 1：声明的变量y，可以在case 2：中被访问</p></blockquote><blockquote><p>但是，不允许直接在case标签下面初始化变量，这会导致编译错误。这是因为<strong>初始化变量需要执行（声明语句不会执行）</strong>，而包含初始化的case语句可能不会执行!</p><hr><p><strong>但是我们可以在case块中，初始化变量：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    &#123; <span class="comment">// note addition of block here</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">4</span>; <span class="comment">// okay, variables can be initialized inside a block inside a case</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"default case"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><hr><h2 id="L5-4-goto-语句"><a href="#L5-4-goto-语句" class="headerlink" title="L5.4 goto 语句"></a>L5.4 goto 语句</h2><p>goto语句是一个控制流语句，它使CPU跳到代码中的另一个位置。这个位置是通过使用<strong>statement label（语句标签）</strong>来标识的。</p><p>eg:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; // for sqrt() function</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">tryAgain: <span class="comment">// this is a statement label</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a non-negative number"</span>; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0.0</span>)</span><br><span class="line">        <span class="keyword">goto</span> tryAgain; <span class="comment">// this is the goto statement</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sqrt of "</span> &lt;&lt; x &lt;&lt; <span class="string">" is "</span> &lt;&lt; <span class="built_in">sqrt</span>(x) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果用户输入的数是负数，那它会一直<code>goto</code>到这个语句标签，直到你输入一个合格的非负数。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LearnCpp-chapterL/image-20200423100210785.png" alt="image-20200423100210785"></p></blockquote><hr><h3 id="陷阱："><a href="#陷阱：" class="headerlink" title="陷阱："></a>陷阱：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">goto</span> skip; <span class="comment">// invalid forward jump</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">skip:</span><br><span class="line">    x += <span class="number">3</span>; <span class="comment">// what would this even evaluate to?</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们不能这样使用 语句标签。因为我们跳转到标签语句<code>skip</code>中时，程序还没执行到<code>int x = 5;</code>这个语句。所以，会报错：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LearnCpp-chapterL/image-20200423101450792.png" alt="image-20200423101450792"></p><p>如何改正：</p><p>我们可以让<code>int x=5;</code>这个语句放在 <code>goto skip;</code>语句之前，就可以了。</p><hr><h3 id="不建议使用goto语句"><a href="#不建议使用goto语句" class="headerlink" title="不建议使用goto语句"></a>不建议使用goto语句</h3><p>goto的主要问题是，它允许程序员任意地在执行点上跳转。因此很难理解这种代码的逻辑。</p><h2 id="L5-7-for语句"><a href="#L5-7-for语句" class="headerlink" title="L5.7 for语句"></a>L5.7 for语句</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形式</span></span><br><span class="line"><span class="keyword">for</span> (init-statement; condition-expression; <span class="built_in">end</span>-expression)</span><br><span class="line">   statement</span><br></pre></td></tr></table></figure><h3 id="多重声明"><a href="#多重声明" class="headerlink" title="多重声明"></a>多重声明</h3><p>有时for循环需要多个变量。当这种情况发生时，程序员可以使用<strong>逗号操作符</strong>来分配(在init-statement中)或更改(在end-statement中)多个变量的值:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> iii&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> jjj&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (iii = <span class="number">0</span>, jjj = <span class="number">9</span>; iii &lt; <span class="number">10</span>; ++iii, --jjj)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iii &lt;&lt; <span class="string">' '</span> &lt;&lt; jjj &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更常用的写法是：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> iii&#123;<span class="number">0</span>&#125;, jjj&#123;<span class="number">9</span>&#125;; iii&lt;<span class="number">10</span>; ++iii, --jjj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;iii &lt;&lt;<span class="string">' '</span> &lt;&lt;jjj &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="L5-8-break-和-continue"><a href="#L5-8-break-和-continue" class="headerlink" title="L5.8 break 和 continue"></a>L5.8 break 和 continue</h2><h3 id="break与return"><a href="#break与return" class="headerlink" title="break与return"></a>break与return</h3><ul><li>break语句是终止<code>switch</code>语句 或者 其他循环语句，然后继续执行该语句下面的语句。</li><li>return语句终止循环所在的整个函数，并在调用函数的地方继续执行。</li></ul><p>请看下面例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">breakOrReturn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) <span class="comment">// infinite loop</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter 'b' to break or 'r' to return: "</span>;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'b'</span>)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// execution will continue at the first statement beyond the loop</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'r'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// return will cause the function to immediately return to the caller (in this case, main())</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// breaking the loop causes execution to resume here</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"We broke out of the loop\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> returnValue&#123; breakOrReturn() &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Function breakOrReturn returned "</span> &lt;&lt; returnValue &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p><code>continue</code>语句提供了一种方便的方法来跳转到当前迭代（当前这一层循环）的循环体的末尾。当我们想要提前终止当前的迭代时，这是很有用的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> count&#123; <span class="number">0</span> &#125;; count  &lt; <span class="number">20</span>; ++count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// if the number is divisible by 4, skip this iteration</span></span><br><span class="line">    <span class="keyword">if</span> ((count % <span class="number">4</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">// jump to end of loop body</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// If the number is not divisible by 4, keep going</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">------------------------------------------------------ </span><br><span class="line"><span class="comment">// The continue statement jumps to here</span></span><br><span class="line">------------------------------------------------------</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnCpp chapterP</title>
      <link href="/archives/67343d3.html"/>
      <url>/archives/67343d3.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapterP</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h2 id="S-4-4b-介绍std-string"><a href="#S-4-4b-介绍std-string" class="headerlink" title="S.4.4b 介绍std::string"></a>S.4.4b 介绍<code>std::string</code></h2><p>字符串在程序中很常见，大部分现代编程语言都包括一个内置的字符串数据类型。C++包括一个，不是作为核心语言的一部分，而是作为标准库的一部分。</p><h3 id="std-string"><a href="#std-string" class="headerlink" title="std::string"></a>std::string</h3><p>如果想在C++中使用string类型。需要加入头文件<code>#include &lt;string&gt;</code>来声明std::string。只要有这个头文件，我们就可以在程序中使用string类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> myName;</span><br></pre></td></tr></table></figure><p>就像其他类型一样，你可以为字符串类型的变量进行初始化 或者 复制：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> myName&#123; <span class="string">"Alex"</span> &#125;; <span class="comment">// initialize myName with string literal "Alex"</span></span><br><span class="line">myName = <span class="string">"John"</span>; <span class="comment">// assign variable myName the string literal "John"</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>字符串也可以保存数字</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> myID&#123; <span class="string">"45"</span> &#125;; <span class="comment">// "45" is not the same as integer 45!</span></span><br></pre></td></tr></table></figure><p><strong>字符串格式的 数字，其实是文本形式，而不是 数字形式。</strong></p></blockquote><h3 id="输入输出字符串"><a href="#输入输出字符串" class="headerlink" title="输入输出字符串"></a>输入输出字符串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> myName&#123; <span class="string">"Alex"</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"My name is: "</span> &lt;&lt; myName &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************打印***********/</span></span><br><span class="line">My name is: Alex</span><br></pre></td></tr></table></figure><p>但是，使用<code>std::cin</code>来输入字符串，可能会产生异常：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter your full name: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; name; <span class="comment">// this won't work as expected since std::cin breaks on whitespace</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter your age: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> age;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; age;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Your name is "</span> &lt;&lt; name &lt;&lt; <span class="string">" and your age is "</span> &lt;&lt; age &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://raw.githubusercontent.com/longlongqin/CDN-for-HEXO_BLOG/pig_bed/20200428145311.png" alt="image-20200414171736561"></p><p>可以看到，<code>大 魔头</code>中间有空格。然后就会被自动截断，前一部分赋值给变量name；第二半段赋值给age。</p><blockquote><p>也就是说：那是不对的!发生了什么事?结果表明，当使用操作符&gt;&gt;从cin提取字符串时，操作符&gt;&gt;只返回它遇到的第一个空格之前的字符。其他字符留在cin中，等待下一次提取。</p></blockquote><h3 id="用std-getline-输入文本"><a href="#用std-getline-输入文本" class="headerlink" title="用std::getline()输入文本"></a>用<code>std::getline()</code>输入文本</h3><p>要将<strong>整行</strong>输入读入字符串，<strong>我们最好需要使用<code>std::getline()</code></strong>函数。</p><blockquote><p><code>std::getline()</code>含有两个形参：<strong>第一个是<code>std::cin</code></strong>；<strong>第二个是我们输入的字符串的变量</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter your full name: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, name); <span class="comment">// read a full line of text into name</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter your age: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> age&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, age); <span class="comment">// read a full line of text into age</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Your name is "</span> &lt;&lt; name &lt;&lt; <span class="string">" and your age is "</span> &lt;&lt; age &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果**************/</span></span><br><span class="line">Enter your full name: John Doe</span><br><span class="line">Enter your age: <span class="number">23</span></span><br><span class="line">Your name is John Doe <span class="keyword">and</span> your age is <span class="number">23</span></span><br></pre></td></tr></table></figure><h3 id="混合使用std-cin、std-getline"><a href="#混合使用std-cin、std-getline" class="headerlink" title="混合使用std::cin、std::getline()"></a>混合使用<code>std::cin</code>、<code>std::getline()</code></h3><p>混合使用他俩，可能会产生异常：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Pick 1 or 2: "</span>;</span><br><span class="line">    <span class="keyword">int</span> choice&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; choice;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Now enter your name: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, name);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, "</span> &lt;&lt; name &lt;&lt; <span class="string">", you picked "</span> &lt;&lt; choice &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序首先要求您输入1或2，然后等待您这样做。到目前为止一切顺利。然后它会要求你输入你的名字。然而，它实际上不会等待您输入您的名字！相反，它打印“Hello”行，然后退出。发生了什么事?</p><blockquote><p>结果是，当您使用cin输入一个值时，<strong>cin不仅捕获值，还捕获换行符</strong>。当我们输入2时，cin实际上会得到字符串“2\n”。然后提取2到变量选择，使换行留在输入流中。然后，当std::getline()去读取名称时，它会看到“\n”已经在流中，并且认为我们必须输入一个空字符串!绝对不是我们想要的。</p></blockquote><hr><p>一个好方法：<strong>使用<code>std::cin</code>读取完值 之后，将换行 从输入流中删除</strong>：</p><blockquote><p><code>std::cin.ignore(32767, &#39;\n&#39;);</code> //忽略不超过32767个字符，直到删除一个\n.</p><p>关于<code>32767</code>请看下一节</p></blockquote><p>如下，在main函数中，增加一句<code>std::cin.ignore(32767, &#39;\n&#39;);</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Pick 1 or 2: "</span>;</span><br><span class="line"><span class="keyword">int</span> choice&#123;&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; choice;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//新加</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="number">32767</span>, <span class="string">'\n'</span>); <span class="comment">// ignore up to 32767 characters until a \n is removed</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Now enter your name: "</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line"><span class="built_in">std</span>::getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, name);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, "</span> &lt;&lt; name &lt;&lt; <span class="string">", you picked "</span> &lt;&lt; choice &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>规则:<strong>如果使用<code>std::cin</code>读取值</strong>，<strong>最好使用<code>std:: cin .ignore()</code>来删除多余的换行符。</strong></p></blockquote><hr><h3 id="32767代表什么"><a href="#32767代表什么" class="headerlink" title="32767代表什么"></a><code>32767</code>代表什么</h3><p>这告诉<code>std::cin.ignore()</code>要忽略多少字符。我们选择<code>32767</code>是因为它是保证在所有平台上都适合(2字节)整数的最大有符号值。</p><blockquote><p>从技术上讲，忽略无限量输入的正确方法如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>); <span class="comment">// ignore unlimited characters until a \n is removed</span></span><br></pre></td></tr></table></figure><p>但是，相比之下，这样的方式太复杂了。而且还需要加上头文件<code>limits</code></p></blockquote><h3 id="字符串的“加法”"><a href="#字符串的“加法”" class="headerlink" title="字符串的“加法”"></a>字符串的“加法”</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> a&#123; <span class="string">"45"</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> b&#123; <span class="string">"11"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a + b &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// a and b will be concatenated</span></span><br><span class="line">    a += <span class="string">"volts"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*****结果********/</span></span><br><span class="line"><span class="number">4511</span></span><br><span class="line"><span class="number">45</span>volts</span><br></pre></td></tr></table></figure><blockquote><p>注意，如果你想对<strong>字符串减法，是不可以的熬</strong></p></blockquote><h3 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> myName&#123; <span class="string">"Alex"</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; myName &lt;&lt; <span class="string">" has "</span> &lt;&lt; myName.length() &lt;&lt; <span class="string">" characters\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; myName &lt;&lt; <span class="string">" has "</span> &lt;&lt; length(myName) &lt;&lt; <span class="string">" characters\n"</span>;<span class="comment">//error:未定义标识符 length</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，我们不是将字符串长度作为length(myName)，而是使用myName.length()。</p><blockquote><p>length函数不是我们目前使用的一个普通的独立函数，它是属于std::string的一种特殊类型的函数，称为成员函数。</p></blockquote><h2 id="S-4-4c-使用语言参考"><a href="#S-4-4c-使用语言参考" class="headerlink" title="S.4.4c 使用语言参考"></a>S.4.4c 使用语言参考</h2><p>本节原文地址：<a href="https://www.learncpp.com/cpp-tutorial/using-a-language-reference/" target="_blank" rel="noopener"><strong>S.4.4c — Using a language reference</strong></a></p><blockquote><p>其中一个资源是<a href="https://stackoverflow.com/" target="_blank" rel="noopener"><strong>Stack Overflow</strong></a>，你可以在这里提问；</p><p>另一个就是语言参考文档： <strong><a href="https://cppreference.com/" target="_blank" rel="noopener">cppreference</a></strong>；</p></blockquote><h2 id="S-4-5-枚举类型"><a href="#S-4-5-枚举类型" class="headerlink" title="S.4.5 枚举类型"></a>S.4.5 枚举类型</h2><p>c++包含允许程序员创建自己的数据类型的功能。这些数据类型称为<strong>用户定义的数据类型</strong>。</p><p><strong>枚举类型</strong>(也称为<strong>enumeration</strong>或<strong>enum</strong>)是一种数据类型，其中每个可能的值都被定义为<strong>符号常量</strong>(称为<strong>enumerator(枚举器)</strong>)。枚举是通过enum关键字定义的。让我们来看一个例子:</p><blockquote><p>注意，每个枚举数由<strong>逗号</strong>分隔，整个枚举以<strong>分号</strong>结束。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Define a new enumeration named Color</span></span><br><span class="line"><span class="keyword">enum</span> Color</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Here are the enumerators</span></span><br><span class="line">    <span class="comment">// These define all the possible values this type can hold</span></span><br><span class="line">    <span class="comment">// Each enumerator is separated by a comma, not a semicolon</span></span><br><span class="line">    COLOR_BLACK,</span><br><span class="line">    COLOR_RED,</span><br><span class="line">    COLOR_BLUE,</span><br><span class="line">    COLOR_GREEN,</span><br><span class="line">    COLOR_WHITE,</span><br><span class="line">    COLOR_CYAN,</span><br><span class="line">    COLOR_YELLOW,</span><br><span class="line">    COLOR_MAGENTA, <span class="comment">// see note about trailing comma on the last enumerator below</span></span><br><span class="line">&#125;; <span class="comment">// however the enum itself must end with a semicolon</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Define a few variables of enumerated type Color</span></span><br><span class="line">Color paint = COLOR_WHITE;</span><br><span class="line"><span class="function">Color <span class="title">house</span><span class="params">(COLOR_BLUE)</span></span>;</span><br><span class="line">Color apple &#123; COLOR_RED &#125;;</span><br></pre></td></tr></table></figure><p><strong>定义一个枚举类型(也可以说，定义一个用户自定义类型)时，是不会给它分配内存的</strong>；只有当<strong>定义了枚举类型的变量</strong>(如上面示例中的变量paint)时，才会为<strong>该变量</strong>分配内存。</p><blockquote><p>在c++ 11之前，不允许在最后一个枚举数之后使用逗号(例如，在COLOR_MAGENTA之后)(尽管许多编译器都接受了逗号)。但是，从c++ 11开始，允许使用逗号结尾。现在c++ 11编译器更加流行了，一般认为在最后一个元素后面使用逗号是可以接受的。</p></blockquote><h3 id="枚举的命名和枚举器"><a href="#枚举的命名和枚举器" class="headerlink" title="枚举的命名和枚举器"></a>枚举的命名和枚举器</h3><p><strong>枚举的命名是可选的</strong>，通常，没有名字的枚举有时被称为<strong>匿名枚举</strong>。枚举的名字通常以大写字母开头。</p><p><strong>枚举器(枚举常量)</strong>是必须要给出名字的。它的名字通常是大写字母(如，COLOR_WHITE)，或者以大写字母K为前缀(如， kColorWhite)</p><h3 id="枚举常量的范围"><a href="#枚举常量的范围" class="headerlink" title="枚举常量的范围"></a>枚举常量的范围</h3><p>因为枚举常量被放在与枚举相同的命名空间中，所以，枚举常量名字不能用于同一命名空间内的多个枚举:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color</span><br><span class="line">&#123;</span><br><span class="line">RED,</span><br><span class="line">BLUE, <span class="comment">// BLUE is put into the global namespace</span></span><br><span class="line">GREEN</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">enum</span> Feeling</span><br><span class="line">&#123;</span><br><span class="line">HAPPY,</span><br><span class="line">TIRED,</span><br><span class="line">BLUE <span class="comment">// error, BLUE was already used in enum Color in the global namespace</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="枚举常量的值"><a href="#枚举常量的值" class="headerlink" title="枚举常量的值"></a>枚举常量的值</h3><p>每个枚举器根据其在枚举列表中的位置自动分配一个整数值。<strong>默认情况下，第一个枚举数被赋值为整数值0，随后的每个枚举数的值都比前一个枚举数大1:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color</span><br><span class="line">&#123;</span><br><span class="line">    COLOR_BLACK, <span class="comment">// assigned 0</span></span><br><span class="line">    COLOR_RED, <span class="comment">// assigned 1</span></span><br><span class="line">    COLOR_BLUE, <span class="comment">// assigned 2</span></span><br><span class="line">    COLOR_GREEN, <span class="comment">// assigned 3</span></span><br><span class="line">    COLOR_WHITE, <span class="comment">// assigned 4</span></span><br><span class="line">    COLOR_CYAN, <span class="comment">// assigned 5</span></span><br><span class="line">    COLOR_YELLOW, <span class="comment">// assigned 6</span></span><br><span class="line">    COLOR_MAGENTA <span class="comment">// assigned 7</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">Color <span class="title">paint</span><span class="params">(COLOR_WHITE)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; paint;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********结果*********/</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><hr><p><strong>你也可以显式定义枚举数的值</strong>。</p><blockquote><p>这些整数值可以是正的，也可以是负的，并且可以与其他枚举数共享相同的值。任何未定义的枚举数都被赋予一个比前一个枚举数大1的值。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define a new enum named Animal</span></span><br><span class="line"><span class="keyword">enum</span> Animal</span><br><span class="line">&#123;</span><br><span class="line">    ANIMAL_CAT = <span class="number">-3</span>,</span><br><span class="line">    ANIMAL_DOG, <span class="comment">// assigned -2</span></span><br><span class="line">    ANIMAL_PIG, <span class="comment">// assigned -1</span></span><br><span class="line">    ANIMAL_HORSE = <span class="number">5</span>,</span><br><span class="line">    ANIMAL_GIRAFFE = <span class="number">5</span>, <span class="comment">// shares same value as ANIMAL_HORSE</span></span><br><span class="line">    ANIMAL_CHICKEN <span class="comment">// assigned 6</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>注意到：<code>ANIMAL_HORSE</code>和<code>ANIMAL_GIRAFFE</code>的值相同。这表示他们两个可以互换。即，它俩没区别。</p><p>虽然，C++允许这样，但是不建议将枚举常量赋值位相同的值。</p></blockquote><h3 id="枚举类型的input-output"><a href="#枚举类型的input-output" class="headerlink" title="枚举类型的input/output"></a>枚举类型的input/output</h3><p>因为枚举值是整数类型的，所以它们可以被赋值给整型变量。这意味着它们可以 以integers形式被output，因为<code>std::cout</code>知道如何输出整数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mypet = ANIMAL_PIG;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ANIMAL_PIG;<span class="comment">//evaluates to integer before being passed to std::cout</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******结果*****/</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><hr><ul><li><p><strong>编译器不会隐式的将整型转变为枚举类型值。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="number">5</span>; <span class="comment">// will cause compiler error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但是我们可以使用 static_cast 来强制转换</span></span><br><span class="line">Color color = <span class="keyword">static_cast</span>&lt;Color&gt;(<span class="number">5</span>); <span class="comment">// ugly</span></span><br></pre></td></tr></table></figure></li><li><p><strong>编译器也不会让你输入一个枚举类型：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color</span><br><span class="line">&#123;</span><br><span class="line">    COLOR_BLACK, <span class="comment">// assigned 0</span></span><br><span class="line">    COLOR_RED, <span class="comment">// assigned 1</span></span><br><span class="line">    COLOR_BLUE, <span class="comment">// assigned 2</span></span><br><span class="line">    COLOR_GREEN, <span class="comment">// assigned 3</span></span><br><span class="line">    COLOR_WHITE, <span class="comment">// assigned 4</span></span><br><span class="line">    COLOR_CYAN, <span class="comment">// assigned 5</span></span><br><span class="line">    COLOR_YELLOW, <span class="comment">// assigned 6</span></span><br><span class="line">    COLOR_MAGENTA <span class="comment">// assigned 7</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Color color;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; color; <span class="comment">// will cause compiler error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但是，我们可以通过读取一个整型，并使用static_cast来强制编译器将整型值放入枚举类型中：</span></span><br><span class="line"><span class="keyword">int</span> inputColor;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt; inpitColor;</span><br><span class="line"></span><br><span class="line">Color color&#123; <span class="keyword">static_cast</span>&lt;Color&gt;(inputColor) &#125;;</span><br></pre></td></tr></table></figure></li><li><p>每个枚举类型都被认为是不同的类型。因此，试图将枚举数从一个枚举类型分配到另一个枚举类型将导致编译错误:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal animal&#123; COLOR_BLUE &#125;; <span class="comment">// will cause compiler error</span></span><br></pre></td></tr></table></figure></li><li><p><strong>如果您想为枚举器使用不同的整数类型</strong>，你可以您可以在enum声明中指定它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use an 8 bit unsigned integer as the enum base.</span></span><br><span class="line"><span class="keyword">enum</span> Color : <span class="built_in">std</span>::<span class="keyword">uint_least8_t</span></span><br><span class="line">&#123;</span><br><span class="line">    COLOR_BLACK,</span><br><span class="line">    COLOR_RED,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>枚举类型的提前声明</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color; <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">enum</span> Color : <span class="keyword">int</span>; <span class="comment">// Okay</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Because Color was forward declared with a fixed base, we</span></span><br><span class="line"><span class="comment">// need to specify the base again at the definition.</span></span><br><span class="line"><span class="keyword">enum</span> Color : <span class="keyword">int</span></span><br><span class="line">&#123;</span><br><span class="line">    COLOR_BLACK,</span><br><span class="line">    COLOR_RED,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Enum分配和提前声明"><a href="#Enum分配和提前声明" class="headerlink" title="Enum分配和提前声明"></a>Enum分配和提前声明</h3><p>Enum类型被认为是整数类型家族的一部分，它由编译器决定为Enum变量分配多少内存。c++标准要求枚举的大小必须足够大，以表示所有枚举值。通常，它会使<strong>enum变量的大小与标准int相同</strong>。</p><hr><p>因为编译器知道给枚举类型分配多少内存，<strong>所以您只能在指定固定基数时，才可以提前声明它们</strong>。</p><h3 id="枚举器有什么用"><a href="#枚举器有什么用" class="headerlink" title="枚举器有什么用?"></a>枚举器有什么用?</h3><p>当需要表示特定的预定义状态集时，枚举类型对于代码文档和可读性非常有用。</p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readFileContents</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!openFile())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!readFile())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">if</span> (!parseFile())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// success</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>负数用来表示不同的可能的错误代码</strong>。如上面：<code>-1</code> <code>-2</code> <code>-3</code></p></blockquote><p>然而，使用像这样的神奇数字并不是很有描述性。<strong>另一种方法是使用枚举类型</strong>：</p><blockquote><p>这种方法可读性更强。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> ParseResult</span><br><span class="line">&#123;</span><br><span class="line">    SUCCESS = <span class="number">0</span>,</span><br><span class="line">    ERROR_OPENING_FILE = <span class="number">-1</span>,</span><br><span class="line">    ERROR_READING_FILE = <span class="number">-2</span>,</span><br><span class="line">    ERROR_PARSING_FILE = <span class="number">-3</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">ParseResult <span class="title">readFileContents</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!openFile())</span><br><span class="line">        <span class="keyword">return</span> ERROR_OPENING_FILE;</span><br><span class="line">    <span class="keyword">if</span> (!readFile())</span><br><span class="line">        <span class="keyword">return</span> ERROR_READING_FILE;</span><br><span class="line">    <span class="keyword">if</span> (!parsefile())</span><br><span class="line">        <span class="keyword">return</span> ERROR_PARSING_FILE;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用者可以根据适当的枚举器测试函数的返回值，这比测试特定整数值的返回结果更容易理解。</p><p>如：</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (readFileContents() == SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// print error message</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></blockquote><hr><p>许多语言使用枚举定义布尔值。布尔值本质上就是一个有两个枚举器的枚举:false和true!然而，在c++中，true和false被定义为关键字，而不是枚举数。</p><h2 id="S-4-6-枚举类"><a href="#S-4-6-枚举类" class="headerlink" title="S.4.6 枚举类"></a>S.4.6 枚举类</h2><p>C++11定义了一个新概念，<strong>enum class(枚举类)</strong>，也称 <strong>scoped enumeration（作用域枚举）</strong>。我们在enum之后使用<strong>关键字 <code>class</code></strong>来构造枚举类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> // "<span class="title">enum</span> <span class="title">class</span>" <span class="title">defines</span> <span class="title">this</span> <span class="title">as</span> <span class="title">a</span> <span class="title">scoped</span> <span class="title">enumeration</span> <span class="title">instead</span> <span class="title">of</span> <span class="title">a</span> <span class="title">standard</span> <span class="title">enumeration</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        red, <span class="comment">// red is inside the scope of Color</span></span><br><span class="line">        blue</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        banana, <span class="comment">// banana is inside the scope of Fruit</span></span><br><span class="line">        apple</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    Color color&#123; Color::red &#125;; <span class="comment">// note: red is not directly accessible any more, we have to use Color::red</span></span><br><span class="line">    Fruit fruit&#123; Fruit::banana &#125;; <span class="comment">// note: banana is not directly accessible any more, we have to use Fruit::banana</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (color == fruit) <span class="comment">// compile error here, as the compiler doesn't know how to compare different types Color and Fruit</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"color and fruit are equal\n"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"color and fruit are not equal\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>对于正常的枚举，枚举器被放置在与枚举本身相同的范围内</strong>。所以，我们可以直接访问枚举器(枚举常量). (e.g. red).</p><blockquote><p>因为枚举器是enum类的一部分，所以不需要在枚举器名称前面加上前缀(例如，可以使用red而不是COLOR_red，因为Color::COLOR_red是多余的)。</p></blockquote></li><li><p>但是，<strong>在枚举类中，严格的范围规则意味着所有的枚举器(枚举常量)是枚举的一部分。</strong>所以，我们必须使用必须使用范围限定符来访问枚举器(例如，Color::red)。</p><blockquote><p>这有助于降低名称污染和名称冲突的可能性。</p></blockquote><blockquote><p>强类型规则意味着每个enum类都被认为是唯一的类型。这意味着编译器不会隐式地比较来自不同枚举的枚举数。如果尝试这样做，编译器将抛出一个错误，如上面的示例所示。</p></blockquote></li></ul><hr><p>然而，你仍然可以<strong>在同一枚举类 内部进行 枚举常量的比较</strong>(因为让门属于同一类型)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        red,</span><br><span class="line">        blue</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    Color color&#123; Color::red &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (color == Color::red) <span class="comment">// this is okay(这样是可以的)</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The color is red!\n"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (color == Color::blue)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The color is blue!\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用enum类，编译器将不再隐式地将枚举数值转换为整数。</strong>这基本上是一件好事。但是，在某些情况下，这样做是有用的。在这些情况下，<strong>可以使用static_cast将enum类枚举数显式转换为整数:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        red,</span><br><span class="line">        blue</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    Color color&#123; Color::blue &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; color; <span class="comment">// won't work, because there's no implicit conversion to int</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(color); <span class="comment">// will print 1</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【note】万一你遇到它，“<strong>enum struct</strong>”相当于“<strong>enum class</strong>”。但这种用法不推荐，也不常用。</p><h2 id="S-4-7-struct"><a href="#S-4-7-struct" class="headerlink" title="S.4.7 struct"></a>S.4.7 <code>struct</code></h2><p>c++允许我们创建自己的用户定义的<strong>aggregate data types(聚集数据类型)</strong>。</p><blockquote><p><strong>聚集数据类型：是将多个单独变量分组在一起的数据类型</strong></p></blockquote><p><strong><code>struct</code></strong>就是聚集数据类型的最简单之一。</p><h3 id="struct的定义-amp-声明"><a href="#struct的定义-amp-声明" class="headerlink" title="struct的定义&amp;声明"></a>struct的定义&amp;声明</h3><p>因为structs是用户自定义的，所以我们首先要在使用它之前，必须要告诉编译器我们的struct是什么样的。</p><blockquote><p>我们使用<code>struct</code>关键字声明结构体。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//告诉编译器我们定义了一个结构体，名为Employee</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    short id;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> wage;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//这些结构中的变量称为  **成员(或字段)**。</span></span><br></pre></td></tr></table></figure><blockquote><p>记住，<strong>上面的<code>Employee</code>只是一个声明</strong>。<strong>尽管我们告诉编译器结构体将有成员变量，但此时没有分配内存</strong>。按照惯例，结构名以大写字母开头，以便与变量名区分开来。</p></blockquote><hr><ul><li><p>为了使用Employee结构，我们只需声明一个类型为Employee的变量:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employee joe; <span class="comment">// struct Employee is capitalized, variable joe is not</span></span><br></pre></td></tr></table></figure><blockquote><p>这<strong>定义</strong>了一个名为joe的Employee类型的变量。与普通变量一样，定义结构变量为该变量分配内存。</p></blockquote></li></ul><h3 id="访问结构体成员"><a href="#访问结构体成员" class="headerlink" title="访问结构体成员"></a>访问结构体成员</h3><p>当我们定义一个变量如<code>Employee joe</code>时，joe引用整个结构(包含成员变量)。为了访问各个成员，我们使用<strong>member selection operator(成员选择操作符)</strong>。下面是一个使用成员选择操作符初始化每个成员变量的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Employee joe; <span class="comment">// create an Employee struct for Joe</span></span><br><span class="line">joe.id = <span class="number">14</span>; <span class="comment">// assign a value to member id within struct joe</span></span><br><span class="line">joe.age = <span class="number">32</span>; <span class="comment">// assign a value to member age within struct joe</span></span><br><span class="line">joe.wage = <span class="number">24.15</span>; <span class="comment">// assign a value to member wage within struct joe</span></span><br><span class="line"> </span><br><span class="line">Employee frank; <span class="comment">// create an Employee struct for Frank</span></span><br><span class="line">frank.id = <span class="number">15</span>; <span class="comment">// assign a value to member id within struct frank</span></span><br><span class="line">frank.age = <span class="number">28</span>; <span class="comment">// assign a value to member age within struct frank</span></span><br><span class="line">frank.wage = <span class="number">18.27</span>; <span class="comment">// assign a value to member wage within struct frank</span></span><br></pre></td></tr></table></figure><blockquote><p>与普通变量一样，结构成员变量没有初始化，通常会包含垃圾。我们必须手动初始化它们。</p></blockquote><ul><li><p>Struct成员变量的作用就像普通变量一样，所以可以对它们进行普通操作:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> totalAge&#123; joe.age + frank.age &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (joe.wage &gt; frank.wage)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Joe makes more than Frank\n"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (joe.wage &lt; frank.wage)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Joe makes less than Frank\n"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Joe and Frank make the same amount\n"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Frank got a promotion</span></span><br><span class="line">frank.wage += <span class="number">2.50</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Today is Joe's birthday</span></span><br><span class="line">++joe.age; <span class="comment">// use pre-increment to increment Joe's age by 1</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="初始化结构体"><a href="#初始化结构体" class="headerlink" title="初始化结构体"></a>初始化结构体</h3><p>通过逐个成员分配值来初始化结构有点麻烦，因此，c++支持使用<strong>initializer list(初始化列表)</strong>来初始化结构体的更快方法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    short id;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> wage;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Employee joe&#123; <span class="number">1</span>, <span class="number">32</span>, <span class="number">60000.0</span> &#125;; <span class="comment">// joe.id = 1, joe.age = 32, joe.wage = 60000.0</span></span><br><span class="line">Employee frank&#123; <span class="number">2</span>, <span class="number">28</span> &#125;; <span class="comment">// frank.id = 2, frank.age = 28, frank.wage = 0.0 (default initialization)</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>在C++11/14中: Non-static member initialization</strong></p><p>从c++ 11开始，可以给非静态(普通)结构成员一个默认值:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> length&#123; <span class="number">1.0</span> &#125;;</span><br><span class="line">    <span class="keyword">double</span> <span class="built_in">width</span>&#123; <span class="number">1.0</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rectangle x; <span class="comment">// length = 1.0, width = 1.0</span></span><br><span class="line"> </span><br><span class="line">    x.length = <span class="number">2.0</span>; <span class="comment">// you can assign other values like normal</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不幸的是，在c++ 11中，<strong>非静态成员初始化语法</strong>与<strong>初始化列表</strong>和<strong>统一的初始化语法</strong>不兼容。例如，在c++ 11中，以下程序无法编译:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">double</span> length&#123; <span class="number">1.0</span> &#125;; <span class="comment">// non-static member initialization</span></span><br><span class="line"><span class="keyword">double</span> <span class="built_in">width</span>&#123; <span class="number">1.0</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Rectangle x&#123; <span class="number">2.0</span>, <span class="number">2.0</span> &#125;; <span class="comment">// uniform initialization/initializer list【推荐】</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>因此，<strong>在c++ 11中</strong>，您必须决定是使用非静态成员初始化还是使用统一初始化。<strong>统一初始化更加灵活，因此我们建议坚持使用这种方法</strong>。</p><p>然而，<strong>在c++ 14中</strong>，这个限制被取消了，两者都可以使用。如果两者都提供了，则优先使用<strong>初始化列表/统一初始化语法（即：initializer list）</strong>。</p><blockquote><p>在上面的例子中，矩形x的length和width将用2.0进行初始化。</p><p><em>在c++ 14中，两者都使用应该是首选的，因为它允许您声明具有或不具有初始化参数的结构，并确保成员已初始化</em></p></blockquote></li></ul><h3 id="对结构体赋值"><a href="#对结构体赋值" class="headerlink" title="对结构体赋值"></a>对结构体赋值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    short id;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> wage;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Employee joe;</span><br><span class="line">joe = &#123; <span class="number">1</span>, <span class="number">32</span>, <span class="number">60000.0</span> &#125;; <span class="comment">// C++11 only(只在C++11中可以使用)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在C++11之前</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    short id;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> wage;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Employee joe;</span><br><span class="line">joe.id = <span class="number">1</span>;</span><br><span class="line">joe.age = <span class="number">32</span>;</span><br><span class="line">joe.wage = <span class="number">60000.0</span>;</span><br></pre></td></tr></table></figure><h3 id="结构体与函数"><a href="#结构体与函数" class="headerlink" title="结构体与函数"></a>结构体与函数</h3><p>与单个变量相比，使用struct的一大好处是，我们可以将整个struct传递给一个需要与成员协同工作的函数:</p><blockquote><p>这避免了我们必须单独传递每个变量。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    short id;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> wage;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printInformation</span><span class="params">(Employee employee)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ID:   "</span> &lt;&lt; employee.id &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Age:  "</span> &lt;&lt; employee.age &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Wage: "</span> &lt;&lt; employee.wage &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Employee joe &#123; <span class="number">14</span>, <span class="number">32</span>, <span class="number">24.15</span> &#125;;</span><br><span class="line">    Employee frank &#123; <span class="number">15</span>, <span class="number">28</span>, <span class="number">18.27</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Print Joe's information</span></span><br><span class="line">    printInformation(joe);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Print Frank's information</span></span><br><span class="line">    printInformation(frank);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******结果*********/</span></span><br><span class="line">ID:   <span class="number">14</span></span><br><span class="line">Age:  <span class="number">32</span></span><br><span class="line">Wage: <span class="number">24.15</span></span><br><span class="line"></span><br><span class="line">ID:   <span class="number">15</span></span><br><span class="line">Age:  <span class="number">28</span></span><br><span class="line">Wage: <span class="number">18.27</span></span><br></pre></td></tr></table></figure><blockquote><p>我们将整个Employee结构传递给<code>printInformation()</code> (通过值传递，这意味着实参<u>被复制</u>到形参中)。</p></blockquote><ul><li><p><strong>函数的返回可以是一个结构体：</strong></p><blockquote><p>一个函数也可以返回一个结构体，<strong>这是使一个函数返回多个变量的几种方法之一</strong>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point3d</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    <span class="keyword">double</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">Point3d <span class="title">getZeroPoint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// We can create a variable and return the variable.</span></span><br><span class="line">    Point3d temp &#123; <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Point3d <span class="title">getZeroPoint2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// We can return directly. We already specified the type</span></span><br><span class="line">    <span class="comment">// at the function declaration (Point3d), so we don't need</span></span><br><span class="line">    <span class="comment">// it again here.</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Point3d <span class="title">getZeroPoint3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// We can use empty curly braces to zero-initialize all</span></span><br><span class="line">    <span class="comment">// members of `Point3d`.</span></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point3d zero&#123; getZeroPoint() &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (zero.x == <span class="number">0.0</span> &amp;&amp; zero.y == <span class="number">0.0</span> &amp;&amp; zero.z == <span class="number">0.0</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The point is zero\n"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The point is not zero\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="结构体嵌套"><a href="#结构体嵌套" class="headerlink" title="结构体嵌套"></a>结构体嵌套</h3><p>结构体可以包含其他结构体。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    short id;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> wage;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Company</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Employee CEO; <span class="comment">// Employee is a struct within the Company struct</span></span><br><span class="line">    <span class="keyword">int</span> numberOfEmployees;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Company myCompany;</span><br><span class="line"><span class="comment">//我们可以使用初始化列表初始化它们：</span></span><br><span class="line"><span class="comment">//Company myCompany&#123;&#123; 1, 42, 60000.0 &#125;, 5 &#125;;</span></span><br></pre></td></tr></table></figure><h3 id="结构体的大小"><a href="#结构体的大小" class="headerlink" title="结构体的大小"></a>结构体的大小</h3><ul><li><p>结构体的大小是所有成员大小的总和，但这不是一定的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    short id;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> wage;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The size of Employee is "</span> &lt;&lt; <span class="keyword">sizeof</span>(Employee) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******结果*************/</span></span><br><span class="line">The <span class="built_in">size</span> of Employee is <span class="number">16</span></span><br></pre></td></tr></table></figure><blockquote><p>结果是，<strong>我们只能说结构体的大小至少与它所包含的所有变量的大小一样大</strong>。<strong>但它可以更大!</strong> <u>出于性能原因，编译器有时会在结构中添加空白(这称为<strong>padding(填充)</strong>)。</u></p></blockquote><p>事实上，上面程序中的<code>Employee</code>结构体中，编译器在成员<code>id</code>的后面添加了2个字节的填充(这是不可见的)。所以才导结构的大小为16字节，而不是14字节。</p></li></ul><p>本课介绍的结构有时被称为<strong>plain old data structs(普通旧数据结构)</strong>(或<strong>POD结构</strong>)，因为成员都是数据(变量)成员。将来(当我们讨论类时)，我们将讨论其他类型的成员</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转】Github下载提速</title>
      <link href="/archives/260c7660.html"/>
      <url>/archives/260c7660.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red>Github克隆&下载提速</red></p></center><p>以上内容转载于：<a href="https://mp.weixin.qq.com/s/SYR4zvjhAH1mX9fxdp8cbA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/SYR4zvjhAH1mX9fxdp8cbA</a></p><p>原作者：codesheep</p><a id="more"></a><h1 id="一个痛点"><a href="#一个痛点" class="headerlink" title="一个痛点"></a>一个痛点</h1><p>众所周知，GitHub是一个巨大的开源宝库，以及程序员和编程爱好者的聚集地，包括我之前推荐的诸多优秀的开源项目全部都是位于GitHub上。</p><p>但是每当我们看到优秀的开源项目，准备去<strong>下（bai）载（piao）</strong>时，会发现 <code>git clone</code>的速度异常之慢！就我个人而言，在我家里200M移动宽带的环境下，我克隆开源项目就没发现速度大于过 <code>20.00KiB/s</code>的时候，这简直太难受了。</p><p>小项目倒还好，我等几分钟无所谓；一旦项目庞大起来，或者项目文件数目一多， <code>git clone</code> 大概率会失败！</p><p>当然网上常见的诸如修改hosts、代理等方式实际使用效果并不一定好，而且也不稳定。</p><hr><h1 id="“码云”是个好东西"><a href="#“码云”是个好东西" class="headerlink" title="“码云”是个好东西"></a>“码云”是个好东西</h1><p>接下来就介绍一种GitHub下载的加速方法：通过国内<strong>码云平台</strong>的转接，来完成GitHub上项目的下载加速。</p><blockquote><p>感谢公众号小伙伴ioc提供思路</p></blockquote><p><strong>（1）首先确保码云上有账户，可以正常使用，没有的可以自行注册一下。</strong></p><p><strong>（2）点击右上角新建仓库的加号 <code>+</code>，选择“从 <code>GitHub/GitLab</code>导入仓库”菜单</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LearnCpp-chapter3/640-1584014932491.jpg" alt="640-1584014932491"></p><p><strong>（3）然后填写位于 <code>GitHub</code>上你想 <code>clone</code>的仓库地址并导入</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/githubaddress.jpg" alt="img"></p><p>这一步<strong>交给码云来做</strong>速度是非常快的，一会儿功夫，码云就克隆出了一份和GitHub上一模一样的项目！</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/1640.jpg" alt="1640"></p><p><strong>（4）接下来我们通过码云上的项目地址，将项目 <code>clone</code>到本地，这时候的clone速度就很快了，几 <code>MB/s</code>的速度是没问题的，很快项目就下载下来了。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/640-1583735421332.jpg" alt="640-1583735421332"></p><p>按道理讲这时候我们的目的已经达到了，不过不要忘了，还有一件事没做。</p><hr><h1 id="重新关联远端地址"><a href="#重新关联远端地址" class="headerlink" title="重新关联远端地址"></a>重新关联远端地址</h1><p>要知道，这时候克隆到本地的项目关联的是码云Gitee的地址，已经和原来的GitHub项目<strong>完全脱离了</strong>，是另外一个<strong>副本</strong>。</p><p>在必要情况下（比如我们就是要给GitHub上的某个项目提 <code>PR</code>），我们还需要重新将我们本地的项目关联到原来的GitHub项目上去，做法如下：</p><p><strong>（1）首先找到位于本地仓库目录下的隐藏文件夹 <code>.git</code></strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/640-1583735421410.jpg" alt="640-1583735421410"></p><p><strong>（2）用文本编辑器打开 <code>.git</code>文件夹中的 <code>config</code>配置文件</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/640-1583735421407.jpg" alt="640-1583735421407"></p><p>将配置文件中的 <code>[remote&quot;origin&quot;].url</code>字段重新关联到原来位于GitHub上的GitHub项目地址</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200317025816112.png" alt="image-20200317025816112"></p><blockquote><p>当然你也可以通过命令行来修改远端地址，效果一样的</p></blockquote><p>至此大功告成，本地项目就相当于是 <code>clone</code>自GitHub，后续提代码，提 <code>PR</code>到GitHub上都没有问题。</p><p>以上内容转载于：<a href="https://mp.weixin.qq.com/s/SYR4zvjhAH1mX9fxdp8cbA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/SYR4zvjhAH1mX9fxdp8cbA</a></p>]]></content>
      
      
      <categories>
          
          <category> 实用技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转】配置方法集合</title>
      <link href="/archives/6de95ae.html"/>
      <url>/archives/6de95ae.html</url>
      
        <content type="html"><![CDATA[<a id="more"></a><ol><li><strong>WSL 使用指南</strong>：<a href="https://zhuanlan.zhihu.com/p/36482795" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/36482795</a></li><li><strong>OpenCV安装配置</strong>： <a href="http://blog.csdn.net/poem_qianmo/article/details/19809337" target="_blank" rel="noopener">http://blog.csdn.net/poem_qianmo/article/details/19809337</a></li><li><strong>onedrive无法启动</strong>：<a href="https://blog.ooolg.com/index.php/20190121/568=568.html" target="_blank" rel="noopener">https://blog.ooolg.com/index.php/20190121/568=568.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/LearnCpp-chapter6</title>
      <link href="/archives/2faa8a4b.html"/>
      <url>/archives/2faa8a4b.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapter6</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h2 id="6-2-用户自定义namespace"><a href="#6-2-用户自定义namespace" class="headerlink" title="6.2 用户自定义namespace"></a>6.2 用户自定义namespace</h2><p>在<a href="https://www.learncpp.com/cpp-tutorial/2-9-naming-collisions-and-an-introduction-to-namespaces/" target="_blank" rel="noopener">2.9 – Naming collisions and an introduction to namespaces</a>中讲解了命名冲突和命名空间的内容。现在再次看一下<strong>命名冲突</strong>。</p><blockquote><p>下面的<code>foo.cpp</code>和<code>goo.cpp</code>两个源文件，中的函数有着不同的功能，但是它们的名字却是一样的：</p></blockquote><p><code>foo.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this dosomething() adds the value of its parameters</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dosomething</span><span class="params">(intx, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>goo.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this dosomething() subtracts the value of its parameters</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dosomething</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="comment">//forward declaration for dosomething</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; dosometing(<span class="number">4</span>, <span class="number">3</span>) &lt;&lt;<span class="string">'\n'</span>; <span class="comment">//which dosometing will we get?</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，编译器会将<code>foo.cpp</code>和<code>goo.cpp</code>都编译在同一个程序中。因为它们俩里面中的函数的名字、参数都一样，而且又在同一个范围中(global scope)，这将会造成“命名冲突”。结果就是，链接器工作时，将会发生错误：</p><p><code>goo.cpp:3: multiple definition of &quot;doSomething(int, int)&quot;; foo.cpp:3: first defined here</code></p><hr><p>一个较好的解决办法就是，将你的函数放在你自己定义的“<em><em>命名空间</em>namespace</em> **”中。</p><hr><ul><li><p><strong>定义自己的namespace</strong></p><p>C++允许我们使用关键字<em>namespace</em>来定义自己的命名空间。由用户自定义的命名空间，叫：<strong>user-defined namespaces</strong>。而 由C++提供的命名空间，如 <code>global namespace</code>；或者由库提供的，如<code>namespace std</code>；它们就不是user-defined namespaces。</p><blockquote><p><strong>命名空间的标识符</strong>通常 <strong>不大写</strong>。</p></blockquote><p>下面是对上面命名冲突的函数的改写：</p><p><code>foo.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> foo <span class="comment">//定义一个命名空间，名字为：foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//this dosomething() belongs to namespace foo</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dosomething</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>goo.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> goo  <span class="comment">//定义一个命名空间，名字为：goo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//this dosomething() belongs namespace goo</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dosomething</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dosomething</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">//提前对函数dosomething()进行声明</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;dosomething(<span class="number">4</span>, <span class="number">3</span>)&lt;&lt;<span class="string">'\n'</span>; <span class="comment">//which dosomething will we get?</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这个两个<code>dosomething()</code>函数都分别属于不同的命名空间了。让我们来运行一下。</p><p>😂，新问题又出现了：</p><blockquote><p><code>ConsoleApplication1.obj : error LNK2019: unresolved external symbol &quot;int __cdecl doSomething(int,int)&quot; (?doSomething@@YAHHH@Z) referenced in function _main</code></p></blockquote><p>在这个改版中，其实编译器是满意的(因为我们已经进行提前声明)。但是链接器找不到一个在<em>global namespace</em>中的<code>dosomething</code>的定义。</p><blockquote><p>这是因为我们虽然为两个<code>dosomething</code>分别声明在不同的命名空间，可惜的是这两个命名空间都不属于 全局命名空间 中。</p></blockquote><hr><p><strong>这里有两个解决方案：1.使用<em>scope resolution operator<em>；2.通过</em>using statements</em></strong></p><hr></li><li><p>*<em>使用范围解析操作符(::)访问名称空间 *</em></p><blockquote><p>【<strong>范围解析操作符：<em>scope resolution operator(::)</em></strong>】</p></blockquote><p>告诉编译器在特定名称空间中查找标识符的最佳方法是使用<em>scope resolution operator(::)</em></p><blockquote><p>“::”，它告诉编译器：应该在该操作符的 左操作数表示的范围中查找 操作符右边的操作数(也就是要找的标识符)</p></blockquote><p>下面是一个例子：</p><p><em>对于后面的示例，为了便于阅读，我们将把示例压缩为一个文件解决方案。</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> foo <span class="comment">// define a namespace named foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This doSomething() belongs to namespace foo</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> goo <span class="comment">// define a namespace named goo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This doSomething() belongs to namespace goo</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x - y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; foo::doSomething(<span class="number">4</span>, <span class="number">3</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// use the doSomething() that exists in namespace foo</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以注意到main函数中的这个语句：<code>std::cout &lt;&lt; foo::doSomething(4, 3) &lt;&lt; &#39;\n&#39;;</code>，就是用了“范围解析符 :: ”。</p><p>该标识符的左操作数：foo，表示命名空间的名字。右操作数表示标识符。</p><p><strong>所以，<code>foo::dosomething(4,3)</code>，就表示：调用的函数<code>dosomething()</code>是来源于命名空间foo中的。</strong></p></blockquote></li></ul><hr><center><p center large>小结</p></center><p>解决命名冲突的步骤为：</p><ol><li>为这些同名的函数，均设置自己的命名空间；</li><li>在使用这个同名函数的时候，还需要加上“范围解析符 :: ”</li></ol><hr><ul><li><p><strong>没有前缀的范围解析符</strong></p><blockquote><p><strong>格式：<code>:: 标识符</code></strong></p><p><strong>没有前缀的范围解析符，<u>就相当于它的范围是全局命名空间</u></strong>。</p></blockquote><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="comment">//this print lives in the global namespace</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"there"</span>&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> foo</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="comment">// this print lives in the foo namespace</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">foo::<span class="built_in">print</span>(); <span class="comment">// call foo::print()</span></span><br><span class="line">::<span class="built_in">print</span>(); <span class="comment">// call print() in global namespace (same as just calling print() in this case)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>允许多个命名空间块：Multiple namespace blocks allowed</strong></p><blockquote><p>在多个位置(跨多个文件，或同一文件中的多个位置)声明名称空间块是合法的。<strong><u>命名空间内的所有声明都被认为是命名空间的一部分</u>。</strong></p></blockquote><hr></li></ul><p>例子1（多文件中）：</p><p><code>circle.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(CIRCLE_H)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CIRCLE_H</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> basicMath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> pi&#123; <span class="number">3.14</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>growth.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(GROWTH_H)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GROWTH_H</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> basicMath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// the constant e is also part of namespace basicMath</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> e&#123; <span class="number">2.7</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"circle.h"</span> <span class="comment">// for basicMath::pi</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"growth.h"</span> <span class="comment">// for basicMath::e</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; basicMath::pi &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; basicMath::e &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p>3.14</p><p>2.7</p><blockquote><p>标准库充就分利用了这个特性，因为每个标准库头文件都将其声明包含在该头文件中包含的 命名空间std 块中。否则，整个标准库必须在一个头文件中定义!</p></blockquote><p><em>【note】：尽管你可以利用这个功能，将你写的函数添加到<code>std namespace</code>中，但是<code>std namespace</code>有一个规则，那就是禁止用户将自己的函数扩展到它的里面。</em></p><hr><ul><li><p>例子2</p><p>如果你将你的代码分离再多个文件中，你就必须在头文件和原文件中使用命名空间。</p><p><code>add.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(ADD_H)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD_H</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> basicMath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// function add() is part of namespace basicMath</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>add.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"add.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> basicMath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// define the function add()</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"add.h"</span> <span class="comment">// for basicMath::add()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; basicMath::add(<span class="number">4</span>, <span class="number">3</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li><p>如果在<code>add.cpp</code>中省略了<em>namespace</em>，将会导致链接器找不到<code>basicMath::add</code>。</p><p><em>因为这个源文件在缺少namespace时，对add的定义是在全局命名空间中的。</em></p></li><li><p>如果在<code>add.h</code>中省略<em>namespace</em>，将会导致在“main.cpp”中不能使用<code>basicMath::add</code></p><p><em>因为这个头文件在缺少namespace时，对add的声明是在全局命名空间中的。</em></p></li></ol></blockquote></li></ul><hr><ul><li><p><strong>嵌套命名空间</strong></p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> foo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> goo <span class="comment">// goo is a namespace inside the foo namespace</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; foo::goo::add() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>所以，当我们要调用函数<code>add</code>的时候，<strong>我们使用格式为：<code>foo::goo::add</code></strong></p></blockquote><hr><p>在C++17中，嵌套的命名空间也可以这样声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> foo::goo <span class="comment">// goo is a namespace inside the foo namespace (C++17 style)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; foo::goo::add() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>给命名空间设置别名：namespace aliases</strong></p><p>在使用嵌套的命名空间的函数或变量时，我们需要将命名空间层级都全部写完整，这样会很麻烦，如果我们给这个嵌套的命名空间起一个别名就省事多了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> foo</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">namespace</span> goo</span><br><span class="line">&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">namespace</span> boo = foo::goo; <span class="comment">// boo now refers to foo::goo</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; boo::add() &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// This is really foo::goo::add()</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// The boo alias ends here</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="6-3-局部变量"><a href="#6-3-局部变量" class="headerlink" title="6.3 局部变量"></a>6.3 局部变量</h2><p>在 <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-local-scope/" target="_blank" rel="noopener">2.4 – Introduction to local scope</a>,介绍了局部变量，它是在函数中的形参。</p><h3 id="局部变量的块范围"><a href="#局部变量的块范围" class="headerlink" title="局部变量的块范围"></a>局部变量的块范围</h3><p>标识符的范围决定了标识符在源码中可获得的区域。范围是一个“编译时间”的属性。</p><blockquote><p>局部变量的 <strong>块范围(block scope)</strong>，中的范围就是：从他们定义开始，到这个块结束 的这个范围。</p></blockquote><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i &#123;<span class="number">5</span>&#125;; <span class="comment">//i enters scope here</span></span><br><span class="line">    <span class="keyword">double</span> d &#123;<span class="number">4.0</span>&#125;; <span class="comment">// d enters scope here</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">// i and d go out of scope here</span></span><br></pre></td></tr></table></figure><p>虽然函数的形参没有被定义在函数体的内部，但是对于典型函数而言，形参可以被看成，是属于函数体块的范围内。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">//x and y enter scope here</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将x、y中较大者分配给max</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span>&#123;(x&gt;y) ? x : y&#125;; <span class="comment">//max enters scope here</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;<span class="comment">// x, y and max leave scope here</span></span><br></pre></td></tr></table></figure><hr><h3 id="同一范围内的变量名不相同"><a href="#同一范围内的变量名不相同" class="headerlink" title="同一范围内的变量名不相同"></a>同一范围内的变量名不相同</h3><p>下面的函数在编译时会出错，因为该范围内的变量名相同了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunction</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123;&#125;; <span class="comment">//编译时会出错，因为这里的x和形参x之间命名冲突了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="局部变量的自动存储期"><a href="#局部变量的自动存储期" class="headerlink" title="局部变量的自动存储期"></a>局部变量的自动存储期</h3><blockquote><p>变量的<strong>存储期(storage duration),也叫持续时长(duration)</strong>决定了什么时间以及如何创造和销毁它。通常，变量的存储器直接决定了它的<strong>“生命周期(lifetime)”</strong></p></blockquote><p>例如，局部变量的存储器，意味着它在被定义时就被创建，然后在他被定义的范围块的尾部被销毁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i &#123;<span class="number">5</span>&#125;; <span class="comment">//i created and initialized here</span></span><br><span class="line">    <span class="keyword">double</span> d &#123;<span class="number">4.0</span>&#125;; <span class="comment">//d created and initialized here</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// i and d are destoryed here</span></span><br></pre></td></tr></table></figure><p>由于这个原因，局部变量 有时也被称为：<strong>自动变量</strong></p><hr><h3 id="嵌套快中的局部变量"><a href="#嵌套快中的局部变量" class="headerlink" title="嵌套快中的局部变量"></a>嵌套快中的局部变量</h3><p>局部变量可以被定义在嵌套块中，这和在函数体块中的局部变量工作流程相同：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> <span class="comment">//外部块</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123;<span class="number">5</span>&#125;; <span class="comment">//x enters scope and is created here</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//嵌套块</span></span><br><span class="line">        <span class="keyword">int</span> y &#123;<span class="number">7</span>&#125;; <span class="comment">//y enters scope and is created here</span></span><br><span class="line">    &#125; <span class="comment">// y goes out of scope and is destroyed here</span></span><br><span class="line">    <span class="comment">//此时，y就不能再被用了，因为它不属于现在所在的范围</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// x goes out of scope and is destoryed here</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：<strong>变量x的范围是整个mian函数块中，自然，在嵌套块中，变量x也是有效的</strong>，即也可以访问它。</p></blockquote><hr><h3 id="局部变量的无连接"><a href="#局部变量的无连接" class="headerlink" title="局部变量的无连接"></a>局部变量的无连接</h3><p>标识符的另一个属性就是：<strong>“连接(linkage)”</strong>。一个标识符的<em>linkage</em>决定了该标识符的其他声明是否引用的是相同的对象。</p><blockquote><p><strong>局部变量没有<em>关联性</em>，也就是说对一个标识符的每一个声明都代表不同的对象</strong></p></blockquote><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x &#123;<span class="number">2</span>&#125;; <span class="comment">// local variable, no linkage</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x &#123;<span class="number">3</span>&#125;; <span class="comment">//这个标识符x与上面的标识符x，表示的是不同对象(尽管他们名字相同)</span></span><br><span class="line">        <span class="comment">//但是现在嵌套外部的变量x被隐藏起来了(在6.5节会讲到变量隐藏)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="变量定义的范围"><a href="#变量定义的范围" class="headerlink" title="变量定义的范围"></a>变量定义的范围</h3><p>如果一个变量仅在嵌套块中使用，那它就应该旨在嵌套块中被定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//don't define y here</span></span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//y只在这个块中被使用，所以在这里定义它</span></span><br><span class="line">        <span class="keyword">int</span> y&#123;<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;y&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>所以，我们尽量把变量定义在，使用它的范围内部</strong>。</p></blockquote><hr><h2 id="6-4-全局变量"><a href="#6-4-全局变量" class="headerlink" title="6.4 全局变量"></a>6.4 全局变量</h2><h3 id="全局变量的声明"><a href="#全局变量的声明" class="headerlink" title="全局变量的声明"></a>全局变量的声明</h3><p>通常，全局变量声明是在：<strong>头文件的下面，在其他代码的上面</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在函数外面声明的变量是全局变量</span></span><br><span class="line"><span class="keyword">int</span> g_x &#123;&#125;; <span class="comment">// global variable g_x</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// global variables can be seen and used everywhere in the file</span></span><br><span class="line">    g_x = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// global variables can be seen and used everywhere in the file</span></span><br><span class="line">    g_x = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// g_x goes out of scope here</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果*****/</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><blockquote><p>按照惯例， 在全局变量名字加上前缀“g”或者“g_”，来便于是显示的说明它是 全局变量</p></blockquote><hr><h3 id="全局变量的file-scope-amp-静态持续时间"><a href="#全局变量的file-scope-amp-静态持续时间" class="headerlink" title="全局变量的file scope&amp;静态持续时间"></a>全局变量的file scope&amp;静态持续时间</h3><blockquote><p>file scope也叫：<strong>全局范围(global scope)</strong>或者<strong>全局命名空间范围(global namespace scope)</strong></p><blockquote><p>因为全局变量是在函数外部定义的，所以也被视为“全局命名空间(global namespace)”的一部分。所以，才有<em>global namespace scope</em>这个叫法。</p></blockquote></blockquote><p>也就是说，它们从被定义开始，到所在文件的结束期间 都是有效的。</p><hr><p>全局变量在程序开始被创建，在程序结束时被销毁。这成为“<strong>静态持续时间(static duration)</strong>”</p><blockquote><p>有着‘static duration’的变量，也被称为：“<strong>静态变量(static variable)</strong>”</p></blockquote><hr><p><u><strong>局部变量默认是不被初始化的，全局变量默认是被初始化为0的</strong></u></p><ul><li><p><strong>全局变量的初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g_x; <span class="comment">//没有显示的初始化变量(所以默认初始化为0)</span></span><br><span class="line"><span class="keyword">int</span> g_y&#123;&#125;; <span class="comment">//初始化为0</span></span><br><span class="line"><span class="keyword">int</span> g_z&#123;<span class="number">3</span>&#125;; <span class="comment">//显示的初始化为3</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="常量局部变量"><a href="#常量局部变量" class="headerlink" title="常量局部变量"></a>常量局部变量</h3><p>与局部变量一样，全局变量也可以是常量。只要是常量，那它就必须被初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_x; <span class="comment">//error:常量型的变量必须要被初始化</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> g_w; <span class="comment">//error:常量型的变量必须要被初始化（constexpr，表示它是 编译时常量）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_y &#123;<span class="number">1</span>&#125;; <span class="comment">//正确，初始化了</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> g_z &#123;<span class="number">2</span>&#125;; <span class="comment">//正确，初始化了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dosomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//全局变量在这个文件中的每一个地方都是有效的(可以被看见和使用)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_z &lt;&lt; <span class="string">'\n'</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dosomething();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//全局变量在这个文件中的每一个地方都是有效的(可以被看见和使用)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_z &lt;&lt; <span class="string">'\n'</span>;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// g_y and g_z goes out of scope here</span></span><br></pre></td></tr></table></figure><hr><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Non-constant global variables(非常量的全局变量)</span></span><br><span class="line"><span class="keyword">int</span> g_x;                 <span class="comment">// defines non-initialized global variable (zero initialized by default)</span></span><br><span class="line"><span class="keyword">int</span> g_x &#123;&#125;;              <span class="comment">// defines explicitly zero-initialized global variable</span></span><br><span class="line"><span class="keyword">int</span> g_x &#123; <span class="number">1</span> &#125;;           <span class="comment">// defines explicitly initialized global variable</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Const global variables</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_y;           <span class="comment">// error: const variables must be initialized</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_y &#123; <span class="number">2</span> &#125;;     <span class="comment">// defines initialized global constant</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Constexpr global variables</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> g_y;       <span class="comment">// error: constexpr variables must be initialized</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> g_y &#123; <span class="number">3</span> &#125;; <span class="comment">// defines initialized global const</span></span><br></pre></td></tr></table></figure><hr><h2 id="6-5-变量被隐藏"><a href="#6-5-变量被隐藏" class="headerlink" title="6.5 变量被隐藏"></a>6.5 变量被隐藏</h2><h3 id="局部变量被隐藏"><a href="#局部变量被隐藏" class="headerlink" title="局部变量被隐藏"></a>局部变量被隐藏</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// outer block</span></span><br><span class="line"><span class="keyword">int</span> apples &#123; <span class="number">5</span> &#125;; <span class="comment">// 嵌套外部的apples</span></span><br><span class="line">    </span><br><span class="line">    &#123;<span class="comment">// nested block</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;apples&lt;&lt;<span class="string">'\n'</span>; <span class="comment">//这里的apples是嵌套外部的</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> apples &#123;<span class="number">0</span>&#125;; <span class="comment">//在嵌套内部定义变量apples</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//现在的apples指的是嵌套内部 的apples.嵌套外部的apples现在被隐藏起来了</span></span><br><span class="line">        apples = <span class="number">10</span>; <span class="comment">//现在被赋值的apples指的是嵌套内部的apples</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; apples &lt;&lt;<span class="string">'\n'</span>'</span><br><span class="line">    &#125; <span class="comment">//嵌套块内部的apples被销毁</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;apples&lt;&lt;<span class="string">'\n'</span>; <span class="comment">//这个apples指的是嵌套外部的apples(因为现在，嵌套内部的apples已经被销毁)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125; <span class="comment">//嵌套外部的apples被销毁</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">10</span><br><span class="line">5</span><br></pre></td></tr></table></figure><hr><h3 id="全局变量被隐藏"><a href="#全局变量被隐藏" class="headerlink" title="全局变量被隐藏"></a>全局变量被隐藏</h3><p>就像局部变量中的，嵌套块中的变量可以将嵌套外部的同名变量以藏起来 一样。<strong>局部变量可以将全局中的同名变量隐藏起来:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a &#123;<span class="number">5</span>&#125;; <span class="comment">//全局变量</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"global variable a："</span>&lt;&lt;a&lt;&lt;<span class="string">'\n'</span>;<span class="comment">//此时，全局变量a还没有被隐藏。即，这里的变量a，指的是全局变量</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a &#123;<span class="number">7</span>&#125;; <span class="comment">//此时，全局变量a就被这里的局部变量a 隐藏起来了</span></span><br><span class="line">    </span><br><span class="line">    ++a; <span class="comment">//局部变量a加1，而不是全局变量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"local variable a: "</span> &lt;&lt; a &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    foo();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// 局部变量a被销毁</span></span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local variable a: 8</span><br><span class="line">global variable a: 5</span><br></pre></td></tr></table></figure><hr><p>然而啊，全局变量是属于全局的命名空间。所以，我们可以使用 <em>范围解析符(::)</em>（不带前缀的，即默认是在全局命名空间）来告诉编译器我们使用的是全局变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a &#123;<span class="number">5</span>&#125;; <span class="comment">//全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a &#123;<span class="number">7</span>&#125;; <span class="comment">//此时，将全局变量a隐藏起来了</span></span><br><span class="line">    ++a； <span class="comment">//局部变量a加1，而不是全局变量</span></span><br><span class="line">        </span><br><span class="line">    --(::a); <span class="comment">//此时是对于全局变量，减一</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"local variable a: "</span> &lt;&lt; a &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"global variable a: "</span> &lt;&lt; ::a &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;       </span><br><span class="line">&#125;<span class="comment">//local a 被销毁</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local variable a: 8</span><br><span class="line">global variable a: 4</span><br></pre></td></tr></table></figure><hr><h3 id="避免变量被隐藏"><a href="#避免变量被隐藏" class="headerlink" title="避免变量被隐藏"></a>避免变量被隐藏</h3><p>通常应该避免局部变量的隐藏，因为它会在使用或修改错误的变量时导致无意的错误。一些编译器会在变量被隐藏时发出警告。</p><hr><h2 id="6-6-内部连接"><a href="#6-6-内部连接" class="headerlink" title="6.6 内部连接"></a>6.6 内部连接</h2><p>在 <a href="https://www.learncpp.com/cpp-tutorial/local-variables/" target="_blank" rel="noopener">6.3 – Local variables</a>中，讲到：“一个标识符的连接决定了该名称的其他声明是否引用同一对象”和“局部变量的无连接”</p><p>全局变量和函数标识符有：<strong>内部链接(internal linkage)</strong>和<strong>外部链接(external linkage)</strong>。本节主要讲内部链接。</p><hr><p>一个标识若是内部连接，那它就只能在这一个文件中有效(可以被看到和使用)；而不可以在其他文件中看到和使用【<strong>也就是说，它没有暴露给链接器</strong>】。也就是说，如果有两个文件，它们分别含有一个相同名字的标识符(而且这这个同名的标识符是 内部连接)，那么这个同名的标识符就被看待成相互独立的。</p><hr><h3 id="全局变量内部连接"><a href="#全局变量内部连接" class="headerlink" title="全局变量内部连接"></a>全局变量内部连接</h3><p>全局变量是内部链接时，也被称为：<strong>内部变量(<em>internal variables</em>)</strong>。</p><blockquote><p>让 非常量的全局变量 成为内部变量，需要使用<strong>关键字<code>static</code></strong>；（因为非常量的全局变量默认是 外部链接 的）</p><p>而 常量的全局变量 <strong>默认</strong>的就是 内部变量。</p></blockquote><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> g_x; <span class="comment">//非常量的全局变量默认是 外部链接。但是加上关键字static后，就变成内部连接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_y &#123;<span class="number">1</span>&#125;; <span class="comment">//const 的全局变量默认是 内部连接</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> g_z &#123;<span class="number">2</span>&#125;; <span class="comment">//constexpr 的全局变量默认是 内部连接</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>const</code>和<code>constexpr</code>的全局变量默认是 内部连接(所以，不需要加 关键字<code>static</code>)</p></blockquote><hr><h3 id="一个定义规则和内部连接"><a href="#一个定义规则和内部连接" class="headerlink" title="一个定义规则和内部连接"></a>一个定义规则和内部连接</h3><p>还记得在 <a href="https://www.learncpp.com/cpp-tutorial/forward-declarations/" target="_blank" rel="noopener">2.7 – Forward declarations and definitions</a>,中讲到一个定义的规则：<em>在文件或程序中，*</em>一个*<em>对象或者函数只能有一个定义</em>。</p><p>然而，这一个我们却在一个程序中对一个对象或函数进行了“多次定义”，这是否违背了上面的规则呢？</p><blockquote><p>答：不违背。因为本节中我们将它们设置为内部连接，此时虽然它们的名字相同，但是相互独立（即，它们相当于不同的对象或函数，只是名字相同。就好像两个同名的人一样）。所以不违背上面的定义规则。</p></blockquote><hr><h3 id="函数内部连接"><a href="#函数内部连接" class="headerlink" title="函数内部连接"></a>函数内部连接</h3><p>因为“连接(linkage)”是标识符的属性(标识符不仅仅只代表变量(☄⊙ω⊙)☄，因为函数的名字也是标识符)。所以，函数标识符也具有 内部连接 的属性。</p><p>如：</p><p><code>add.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个函数前使用关键字static，表示它现在只在这个文件中有效</span></span><br><span class="line"><span class="comment">//如果，企图通过函数提前声明从，从另一个文件访问它，将失败</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="comment">//对函数add，提前声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序，在链接器连接时，将会出错。因为函数add在<code>main.cpp</code>中不可访问</p><hr><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Internal global variables definitions:</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> g_x;          <span class="comment">// defines non-initialized internal global variable (zero initialized by default)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> g_x&#123; <span class="number">1</span> &#125;;     <span class="comment">// defines initialized internal global variable</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_y &#123; <span class="number">2</span> &#125;;     <span class="comment">// defines initialized internal global const variable</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> g_y &#123; <span class="number">3</span> &#125;; <span class="comment">// defines initialized internal global constexpr variable</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Internal function definitions:</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;;     <span class="comment">// defines internal function</span></span><br></pre></td></tr></table></figure><hr><h2 id="6-7-外部连接"><a href="#6-7-外部连接" class="headerlink" title="6.7 外部连接"></a>6.7 外部连接</h2><p>一个标识符具有 <strong>外部连接(external linkage)</strong>的属性，那么它就可以在整个程序中(不仅仅只在一个文件中)被看见和访问。（在其他文件中，可以通过<em>提前声明</em>来访问它）</p><blockquote><p>所以，具有外部连接属性的表示符，才是真正的“全局”变量</p></blockquote><hr><h3 id="函数默认是外部链接"><a href="#函数默认是外部链接" class="headerlink" title="函数默认是外部链接"></a>函数默认是外部链接</h3><p>在 <a href="https://www.learncpp.com/cpp-tutorial/programs-with-multiple-code-files/" target="_blank" rel="noopener">2.8 – Programs with multiple code files</a>中，讲到我们可以从其他文件中调用函数，这是因为这个函数默认是“外部链接”的。</p><p>在从其他文件中调用函数时，我们必须要对这个函数进行 <strong>提前声明(forward declaration)</strong></p><blockquote><p>因为，<strong>提前声明</strong>可以告诉编译器这个函数的存在；而链接器则是将函数调用连接到实际的函数定义</p></blockquote><p>如：</p><p><code>a.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> <span class="comment">//这个函数默认是 外部连接，所以他可以在整个程序(包括其他文件)中被看见</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hi"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span></span>; <span class="comment">//对函数进行提前声明，使得该函数在这个文件中可以被访问</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sayHi(); <span class="comment">//这里是从其他文件中调用此函数，链接器将把这个调用连接到函数定义</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hi</span><br></pre></td></tr></table></figure><hr><h3 id="全局变量外部连接"><a href="#全局变量外部连接" class="headerlink" title="全局变量外部连接"></a>全局变量外部连接</h3><p>全局变量具有外部连接属性时，也称为：<strong>外部变量(external variables)</strong></p><blockquote><p>非常量的全局变量默认是 外部变量；</p><p>常量的全局变量 要想成为外部变量，需要使用<strong>关键字<code>extern</code></strong></p></blockquote><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g_x &#123;<span class="number">2</span>&#125;; <span class="comment">//非常量的全局变量默认是 外部变量；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> g_y &#123;<span class="number">3</span>&#125;;<span class="comment">//const 的全局变量可以被定义成 外部变量，需要加关键字extern</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> g_z &#123;<span class="number">3</span>&#125;; <span class="comment">//constexpr 的全局变量可以被定义成 外部变量,需要加关键字extern</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>默认情况下，非const全局变量是外部变量(如果使用，extern关键字将被忽略)。</p></blockquote><hr><h3 id="extern提前声明变量"><a href="#extern提前声明变量" class="headerlink" title="extern提前声明变量"></a><code>extern</code>提前声明变量</h3><p>要实际使用在另一个文件中定义的外部全局变量，我们需要在使用它的文件中对全局变量进行<em>提前声明</em>。对于变量，在创建一个<strong>提前声明时，也是需要使用关键字<code>extern</code>的(</strong>没有初始化值)：</p><p>如：</p><p><code>a.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量的定义</span></span><br><span class="line"><span class="keyword">int</span> g_x &#123;<span class="number">2</span>&#125;; <span class="comment">//非常量的全局变量默认是 外部链接</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> g_y &#123;<span class="number">3</span>&#125;; <span class="comment">//常量的全局变量是内部连接，但使用关键字extern后，变为 外部链接</span></span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> g_x; <span class="comment">//对变量g_x的提前声明。它的定义在其他文件中</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> g_y; <span class="comment">//对常量变量g_y的提前声明。它的定义在其他文件中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>&lt;&lt; g_x; <span class="comment">//结果为2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="函数提前声明不用extern"><a href="#函数提前声明不用extern" class="headerlink" title="函数提前声明不用extern"></a>函数提前声明不用<code>extern</code></h3><p><strong>函数的提前声明不需要关键字<code>extern</code></strong></p><blockquote><p>编译器能搞告诉你这个函数在哪定义，也可以根据是否提供函数体来进行提前声明。</p></blockquote><p><strong>变量的提前声明必须要用关键字<code>extern</code></strong>，</p><blockquote><p>来帮助区分 <strong>变量定义</strong> 和 <strong>变量提前声明</strong>(它们看起来是一样的):</p></blockquote><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非常量</span></span><br><span class="line"><span class="keyword">int</span> g_x; <span class="comment">//变量的定义(如果需要，可进行初始化)</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> g_x; <span class="comment">//变量的提前声明(提前声明  不带初始化)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> g_y &#123;<span class="number">1</span>&#125;;<span class="comment">//定义变量(常量的定义必须要进行初始化)</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> g_y; <span class="comment">//提前声明(提前声明  不带初始化)</span></span><br></pre></td></tr></table></figure><hr><h3 id="file范围VS-global范围"><a href="#file范围VS-global范围" class="headerlink" title="file范围VS.global范围"></a>file范围VS.global范围</h3><p>看下面的例子：</p><p><code>global.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g_x &#123;<span class="number">2</span>&#125;; <span class="comment">//（非常量的变量）默认是外部连接</span></span><br><span class="line"><span class="comment">//g_x goes out scope here</span></span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> g_x; <span class="comment">//对变量g_x的提前声明。可以在此文件中使用g_x</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_x; <span class="comment">//应该输出 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//g_x的提前声明 goes out of scope here</span></span><br></pre></td></tr></table></figure><blockquote><p>变量g_x的<strong>文件范围(file scope)</strong>是在<code>global.cpp</code>中。它在该文件中定义之后，就可以被使用。</p><p>但是它<strong>不能<u>直接</u>在其他文件中使用</strong>。如果要在其他文件中使用g_x，我们要在其他文件中对它进行提前声明(记得要使用关键字<code>extern</code>)</p></blockquote><hr><p>也就是说，“文件范围”通常用于具有<em>内部连接</em>属性的全局变量；“全局范围”更多用于具有<em>外部连接</em>属性的全局变量(因为，它被提前声明之后，就可以在其他地方使用)</p><hr><h3 id="全局变量初始化顺序问题"><a href="#全局变量初始化顺序问题" class="headerlink" title="全局变量初始化顺序问题"></a>全局变量初始化顺序问题</h3><p>全局变量的初始化是程序启动的一部分，在执行<code>mian</code>函数之前，这个过程分为两部分：</p><ul><li><p>第一部分，称为 <strong><em>static initialization</em>静态初始化</strong>。</p><blockquote><p>在静态初始化中，带有constexpr初始化器(包括字面值(literal))的全局变量被初始化为给定的值[因为，constexpr和字面值常量定义时自带有初始值]；</p><blockquote><p>eg,</p><p><code>const a {1};</code>那么a就被初始化为1</p><p><code>constexpr a{1};</code>那么a就被初始化为1</p></blockquote><p>定义时没有给定初始值的全局变量<strong>(也使常量的全局变量，但没有显示初始化为0)</strong>被默认初始化为0。</p><blockquote><p><code>const a {};</code>那么a就默认被初始化为0</p><p><code>constexpr a{};</code>那么a就默认被初始化为0</p></blockquote></blockquote></li><li><p>第二部分，称为 <strong><em>dynamic initialization</em>动态初始化</strong>。</p><blockquote><p>这部分，比较复杂，它的要点是：初始化那些“不带有constexpr初始化器的全局变量”(即，就是 非常量的全局变量)。</p></blockquote></li></ul><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_something &#123;init()&#125;; <span class="comment">//非常量的变量初始化</span></span><br></pre></td></tr></table></figure><blockquote><p>在单位件的程序中，全局变量按照定义的顺序被初始化</p></blockquote><p>这个规则有几个例外。考虑到这一点，<strong>您需要小心不要让变量依赖于其他变量的初始化值，这些变量要到稍后才会初始化</strong>。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initx</span><span class="params">()</span></span>;  <span class="comment">// forward declaration</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inity</span><span class="params">()</span></span>;  <span class="comment">// forward declaration</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> g_x&#123; initx() &#125;; <span class="comment">// g_x is initialized first</span></span><br><span class="line"><span class="keyword">int</span> g_y&#123; inity() &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initx</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g_y; <span class="comment">// g_y isn't initialized when this is called</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_x &lt;&lt; <span class="string">' '</span> &lt;&lt; g_y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******结果*******/</span></span><br><span class="line"><span class="number">0</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><hr><p>再多文件程序中，<strong>不同文件之间的初始化顺序是没有规定的</strong>。</p><blockquote><p>例如，有两个文件<code>a.cpp</code>和<code>b.cpp</code>，它们两个文件谁先被初始化是不确定的。</p></blockquote><p>所以，如果在<code>a.cpp</code>中有一个变量的值是依赖于<code>b.cpp</code>。那么就有50%的可能这些变量还没有被初始化。</p><hr><p>注意：C++中，全局变量的动态初始化会造成很多问题。所以避免使用。</p><hr><p>小结：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// External global variable definitions:</span></span><br><span class="line"><span class="keyword">int</span> g_x;                       <span class="comment">// defines non-initialized external global variable (zero initialized by default)</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> g_x&#123; <span class="number">1</span> &#125;;     <span class="comment">// defines initialized const external global variable</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> g_x&#123; <span class="number">2</span> &#125;; <span class="comment">// defines initialized constexpr external global variable</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Forward declarations</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> g_y;                <span class="comment">// forward declaration for non-constant global variable</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> g_y;          <span class="comment">// forward declaration for const global variable</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> g_y;      <span class="comment">// not allowed: constexpr variables can't be forward declared</span></span><br></pre></td></tr></table></figure><hr><h2 id="6-8-全局常量-amp-内联变量"><a href="#6-8-全局常量-amp-内联变量" class="headerlink" title="6.8 全局常量&amp;内联变量"></a>6.8 全局常量&amp;内联变量</h2><blockquote><p><strong>Global constants and inline variables</strong></p></blockquote><p>一些符号常量需(如，阿伏伽德罗常数，重力系数…)要在整个程序中使用。比较好的方法是在一个地方对他们进行声明，而不是在每个需要它们的文件中重新定义这些常量。</p><h3 id="全局常量作为内部变量"><a href="#全局常量作为内部变量" class="headerlink" title="全局常量作为内部变量"></a>全局常量作为内部变量</h3><p>在c++中有多种方法可以促进这一点。在c++ 17之前，以下可能是最简单和最常见的方法:</p><ol><li><p>首先，创建一个头文件来存放这些常量；</p></li><li><p>在这个头文件中，定义一个命名空间（在 <a href="https://www.learncpp.com/cpp-tutorial/user-defined-namespaces/" target="_blank" rel="noopener">6.2 – User-defined namespaces</a>讲解过命名空间）；</p></li><li><p>然后，将常量加入这个命名空间中（请确保它们的类型是<code>constexpr</code>）；</p></li><li><p>在你要用这些变量的文件中，加上这个头文件<code>#include &quot;xxx&quot;</code></p></li></ol><hr><p>eg:</p><p><code>constants.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONSTANTS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONSTANTS_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义你自己的命名空间(用来存储常量)</span></span><br><span class="line"><span class="keyword">namespace</span> constants</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//默认情况下，常量有 内部连接</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">double</span> pi &#123;<span class="number">3.14159</span>&#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">double</span> my_gravity &#123;<span class="number">9.2</span>&#125;;</span><br><span class="line">    <span class="comment">//....常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"constants.h"</span> <span class="comment">//：在这个文件中包含每个常量的副本</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"enter a radius: "</span>;</span><br><span class="line">    <span class="keyword">int</span> radius&#123;&#125;; <span class="comment">//radius：半径</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt;radius;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"the circumference is: "</span> &lt;&lt;<span class="number">2</span>* radius* constants::pi;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：在<code>main.cpp</code>文件中，要想访问<code>constants</code>中的常量，我们需要使用 <strong>范围解析符(::)</strong>。</p><p><code>a::b</code> 范围解析操作符的 左操作数a,表示命名空间名称；右操作符b表示命名空间a中的变量或者函数名字。</p><p><code>::b</code> 这种形式表示 <strong>其命名空间是全局命名空间</strong>。</p></blockquote><hr><h3 id="全局常量作为外部变量"><a href="#全局常量作为外部变量" class="headerlink" title="全局常量作为外部变量"></a>全局常量作为外部变量</h3><p>当作为内部变量时，可能会出现以下问题：</p><p>虽然这很简单(对于较小的程序也很好)，但是每当constants.h被包含到不同的代码文件中时，每个变量都会被复制到包含代码文件中。因此，如果将constants.h包含到20个不同的代码文件中，那么每个变量都会重复20次。头文件保护不会阻止这种情况的发生，因为它们只会阻止头文件不止一次被包含到一个包含文件中，而不会阻止头文件一次被包含到多个不同的代码文件中。这带来了两个挑战:</p><blockquote><p><strong>头文件保护符(header guards)</strong>只能确保在单个文件中包含的头文件只包含一次；</p></blockquote><ul><li>当修改一个常量值时，就可能需要重新编译那些包含这个常量的文件，这可能导致大型项目的重建时间很长。</li><li>如果常量的size很大，并且不能进行优化。这将花费很多内存。</li></ul><hr><p>一个解决上面的办法就是，将这些常量设为<strong>“外部变量(external variables)”</strong>。</p><blockquote><p>因此，我们可以将变量只初始化一次就可以在整个程序中使用。</p></blockquote><p><code>constants.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> constants</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//actual global variables</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">double</span> pi &#123;<span class="number">3.14159</span>&#125;;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">const</span> my_gravity &#123;<span class="number">9.2</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在<code>constants.cpp</code>文件中定义这些常量，来确保它们只被定义一次；</p></blockquote><p><code>constants.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONSTANTS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONSTANTS_H</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> constants</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// since the actual variables are inside a namespace, the forward declarations need to be inside a namespace as well</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">double</span> pi;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">double</span> avogadro;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">double</span> my_gravity;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><blockquote><p>需要在头文件<code>constants.h</code>中对这些常量进行 提前声明</p></blockquote><p><code>main.cpp</code></p><blockquote><p>使用的方法不变</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"constants.h"</span> <span class="comment">// include all the forward declarations</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a radius: "</span>;</span><br><span class="line">    <span class="keyword">int</span> radius&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; radius;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The circumference is: "</span> &lt;&lt; <span class="number">2</span> * radius * constants::pi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>因为全局符号常量在命名空间中(为了避免与全局命名空间中的标识符发生 命名冲突)，所以，就不需要在它名字中使用<code>g_</code>前缀</p></blockquote><p>现在，这些符号常量只用在<code>constants.cpp</code>中实例化一次(而不是每次constants.h被<code>#include</code>中都被实例化一次)，所以，对constants.cpp所做的任何修改都只需要重新编译constants.cpp即可。</p><p>然而，这种方法也有几个缺点。</p><ul><li><strong>首先，这些常量现在只在实际定义它们的文件(constants.cpp)中被认为是 编译时常量</strong>，<strong>而不是在其他地方使用它们</strong>。这意味着在constants.cpp之外的地方，它们不能在任何需要编译时常量的地方使用。</li><li>其次，编译器可能无法对它们进行尽可能多的优化。</li></ul><hr><h3 id="全局常量作为内联变量"><a href="#全局常量作为内联变量" class="headerlink" title="全局常量作为内联变量"></a>全局常量作为内联变量</h3><p>在C++17中，有一个新概念叫做：<strong><em>inline variable</em>(内联变量)</strong></p><blockquote><p><strong>inline</strong>意为：允许多个定义。</p></blockquote><p>所以，一个内联变量就可以在多个文件中被多次定义。(这并不违背 <strong>单定义规则</strong>)</p><blockquote><p><strong>内联全局变量</strong> 默认是 <strong>外部连接</strong></p></blockquote><hr><p>内联变量有两个重要的限制，必须遵守：</p><ul><li>内联变量的所有定义必须相同（否则，将产生未定义的行为）；</li><li>内敛变量的定义(不是提前声明)必须出现在每一个使用这些变量的文件中。</li></ul><blockquote><p>编译器将会把内联变量的所有定义合并为一个变量的定义。这就允许我们在头文件中定义变量，并将它们当作<code>a.cpp</code>文件中只有一个定义。</p><p>这些变量在它们被包含的文件中，依然保持这 constexpr 的性质</p></blockquote><p>这样，我们就可以在头文件中定义全局变量，而不用担心重复变量:</p><p><code>constants.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONSTANTS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONSTANTS_H</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// define your own namespace to hold constants</span></span><br><span class="line"><span class="keyword">namespace</span> constants</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> pi &#123; <span class="number">3.14159</span> &#125;; <span class="comment">// note: now inline constexpr</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> avogadro &#123; <span class="number">6.0221413e23</span> &#125;;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> my_gravity &#123; <span class="number">9.2</span> &#125;; <span class="comment">// m/s^2 -- gravity is light on this planet</span></span><br><span class="line">    <span class="comment">// ... other related constants</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"constants.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a radius: "</span>;</span><br><span class="line">    <span class="keyword">int</span> radius&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; radius;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The circumference is: "</span> &lt;&lt; <span class="number">2</span> * radius * constants::pi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们可以在尽可能多的代码文件中包含<code>constants.h</code>，但是这些变量只会被实例化一次，并在所有代码文件中共享。</p></blockquote><hr><p>如果你需要全局常量，并且你的编译器支持C++17，那建议最好使用 <strong>内联变量</strong></p><hr><h2 id="6-9-非常量的全局变量evil"><a href="#6-9-非常量的全局变量evil" class="headerlink" title="6.9 非常量的全局变量evil"></a>6.9 非常量的全局变量evil</h2><p>最大的问题就是：<strong>当你使用全局变量(not-const)时，它可能在任何地方就被修改，但是你却不能轻松的直到在哪被改的。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g_mode; <span class="comment">//声明全局变量(将默认被初始化为0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dosomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_mode = <span class="number">2</span>; <span class="comment">//这里修改全局变量g_mode为2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_mode =<span class="number">1</span>; <span class="comment">//note:这将全局g_mode变量设置为1。而不是声明一个本地g_mode变量!</span></span><br><span class="line">    dosomething();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//程序猿希望这里输出的g_mode的值是1，但是实际上它的值是2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(g_mode == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"no threat detected.\n"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"lanunching nuclear missiles...\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>局部变量要安全得多，因为其他函数不能直接影响它们。</strong></p></blockquote><hr><h3 id="保护你的全局变量"><a href="#保护你的全局变量" class="headerlink" title="保护你的全局变量"></a>保护你的全局变量</h3><p>如果你非要使用全局变量：</p><ul><li><strong>那我们可以对变量名使用前缀”g_”或“g”，来帮助我们识别它是全局变量。</strong></li><li>最好也将其<strong>放在你自己创建的命名空间，从而避免一些命名冲突。</strong></li></ul><hr><h2 id="6-10-静态局部变量"><a href="#6-10-静态局部变量" class="headerlink" title="6.10 静态局部变量"></a>6.10 静态局部变量</h2><p>术语<code>static</code>是c++语言中最容易混淆的术语之一，这在很大程度上是因为静态在不同的上下文中有不同的含义。</p><p>在之前的课程中，我们讨论了<strong>全局变量具有静态持续时间</strong>，<strong>这意味着它们在程序启动时创建，在程序结束时销毁。</strong></p><p>我们还讨论了<strong><code>static</code>关键字如何提供全局标识符内部链接</strong>，<strong>这意味着标识符只能在定义它的文件中使用。</strong></p><hr><p>我们将探讨<strong>应用于局部变量时静态关键字的用法</strong>。</p><p>在 <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-local-scope/" target="_blank" rel="noopener">2.4 – Introduction to local scope</a>, 您了解到，默认情况下 局部变量具有 <em>自动持续时间</em>，<strong>这意味着它们是在定义时创建的，并在块退出时销毁。</strong></p><blockquote><p>但<strong>关键字<code>static</code></strong>，可以将<strong><em>自动持续时间(attomatic duration)</em></strong>转变成 <strong><em>静态持续时间(static duration)</em></strong> 。从而，静态变量即使已经超出它所在的范围时，他依然没有被销毁。</p><blockquote><p>这意味着变量现在在程序开始时创建，并在程序结束时销毁(就像全局变量一样)。</p></blockquote></blockquote><p>例如：</p><p><em>默认是 automatic duration</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrementAndPrint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value&#123; <span class="number">1</span> &#125;; <span class="comment">// 默认是 automatic duration</span></span><br><span class="line">    ++value;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125; <span class="comment">// value is destroyed here</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    incrementAndPrint();</span><br><span class="line">    incrementAndPrint();</span><br><span class="line">    incrementAndPrint();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果**********/</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>每次</strong>调用函数<code>incrementAndPrint()</code>时，都将穿件一个叫value的变量，它被初始化为1</p></blockquote><hr><p>现在使用<code>static</code>关键字，将默认的 <em>atuomatic duration</em> 转变为 <em>static duration</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrementAndPrint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_value&#123; <span class="number">1</span> &#125;; <span class="comment">// 由于使用关键字 static,所以现在是 static duration。  所以这个变量将只会被初始化一次（不会像上面那个例子，每次调用都会被除初始化）</span></span><br><span class="line">    ++s_value;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s_value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125; <span class="comment">// s_value is not destroyed here, but becomes inaccessible because it goes out of scope</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    incrementAndPrint();</span><br><span class="line">    incrementAndPrint();</span><br><span class="line">    incrementAndPrint();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****结果****/</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><blockquote><p>在这个程序中，<strong>因为s_value被声明为静态的</strong>，<u><strong>所以s_value只创建一次(在程序启动时)(并且初始化为零)。</strong></u>然后在第一次遇到变量定义时使用我们提供的初始化值(1)初始化变量(但在后续调用时不会重新初始化)。</p></blockquote><blockquote><p>就像我们使用“g_” 作为全局变量的前缀一样，使用 “ s_”作为静态(静态持续时间)局部变量的前缀也是很常见的。</p></blockquote><hr><p><strong>静态变量提供了全局变量的一些好处(它们直到程序结束时才被销毁)</strong>，同时，限制为它们只在它自己的块中才能被看见，这使得即使您经常更改它们的值，这也使它们可以安全使用。</p><hr><h3 id="全局、局部变量使用static"><a href="#全局、局部变量使用static" class="headerlink" title="全局、局部变量使用static"></a>全局、局部变量使用<code>static</code></h3><p>全局变量使用关键字<code>static</code>：这会使得全局变量变为 <strong><em>internal linkage(内部连接)</em></strong>，即，使得该变量不能再其他文件中使用。</p><p>局部变量使用关键字<code>statci</code>：这使得局部变量变为 <strong><em>static duration(静态持续时间)</em></strong>,即，使得该变量将 只被创建一次，而且直到程序结束才会被销毁。</p><hr><h2 id="6-11-总结scope-duration-linkage"><a href="#6-11-总结scope-duration-linkage" class="headerlink" title="6.11 总结scope/duration/linkage"></a>6.11 总结scope/duration/linkage</h2><h3 id="总结scope"><a href="#总结scope" class="headerlink" title="总结scope"></a>总结scope</h3><p>标识符的范围决定了它能够被访问的区间：</p><ul><li>具有 <strong>block scope(块范围)</strong> / <strong>local scope(局部范围)</strong> 的变量 只能在它们被声明的块中(包括嵌套块)被访问，这些有：<ul><li>局部变量；</li><li>函数的形参；</li><li>在块中声明的用户定义类型定义（如，枚举(enum)、类(class)）;</li></ul></li><li>具有 <strong>global scope(全局范围)</strong> / <strong>file scope(文件范围)</strong>的变量 可以再文件中的任何地方被访问，这些有：<ul><li>全局变量；</li><li>函数；</li><li>在命 名空间内 或 全局范围 内声明的用户定义类型定义(如枚举(enum)、类(class))</li></ul></li></ul><hr><h3 id="总结duration"><a href="#总结duration" class="headerlink" title="总结duration"></a>总结duration</h3><p>变量的持续时间决定了它们何时被创建与销毁：</p><ul><li>具有 <strong>automatic duration(自动持续时间)</strong>的变量 在定义时被创建，在离开它所在的块时被销毁，这些有：<ul><li>局部变量；</li><li>函数的形参；</li></ul></li><li>具有 <strong>static duration(静态持续时间)</strong>的变量 在程序开始时被创建， 在程序结束时被销毁。这些有：<ul><li>全局变量；</li><li>静态局部变量；</li></ul></li><li>具有 <strong>dynamic duration(动态持续时间)</strong>的变量 由程序员请求创建和销毁。这些有：<ul><li>动态分配的变量；</li></ul></li></ul><hr><h3 id="总结linkage"><a href="#总结linkage" class="headerlink" title="总结linkage"></a>总结linkage</h3><p>标识符的 <strong><em>linkage</em>(连接)</strong> 决定了 一个标识符的多个实例是否引用同一个标识符。</p><ul><li>标识符 没有 连接 时，意味着这个标识符仅指其自身。这些有：<ul><li>局部变量；</li><li>在块中声明的用户定义类型定义(如枚举和类)；</li></ul></li><li>具有 <strong><em>intrnal linkage</em>(内部连接)</strong> 的标识符 只能在它所声明的文件中 被访问。这些有：<ul><li>静态全局变量(static global variables) [初始化 或 未初始化 ]；</li><li>静态函数（static functions）;</li><li>在未命名的命名空间中声明的函数；</li><li>在未命名的命名空间中声明的用户定义类型定义(如枚举和类)；</li></ul></li><li>具有 <strong><em>external linkage(外部连接)</em></strong> 的标识符 可以在 在声明的文件内的任何地方访问，也可以其他文件(通过提前声明)进行访问。这包括:<ul><li>函数；</li><li>非常量的全局变量(初始化 或 未初始化)；</li><li>外部常量全局变量；</li><li>内联常量全局变量；</li><li>在 命名空间内 或 全局范围内声明的用户定义类型定义(如枚举和类)；</li></ul></li></ul><hr><blockquote><p>NOTE:</p><p>默认情况下， 函数是 外部连接；它可通过使用关键字<code>static</code>变成 内部连接。</p></blockquote><hr><h3 id="变量的-scope-duratio-linkage"><a href="#变量的-scope-duratio-linkage" class="headerlink" title="变量的 scope/duratio /linkage"></a>变量的 scope/duratio /linkage</h3><table><thead><tr><th align="left">Type</th><th align="left">Example</th><th align="left">Scope</th><th align="left">Duration</th><th align="left">Linkage</th><th align="left">Notes</th></tr></thead><tbody><tr><td align="left">Local variable</td><td align="left">int x;</td><td align="left">Block</td><td align="left">Automatic</td><td align="left">None</td><td align="left"></td></tr><tr><td align="left">Static local variable</td><td align="left">static int s_x;</td><td align="left">Block</td><td align="left">Static</td><td align="left">None</td><td align="left"></td></tr><tr><td align="left">Dynamic variable</td><td align="left">int *x { new int };</td><td align="left">Block</td><td align="left">Dynamic</td><td align="left">None</td><td align="left"></td></tr><tr><td align="left">Function parameter</td><td align="left">void foo(int x)</td><td align="left">Block</td><td align="left">Automatic</td><td align="left">None</td><td align="left"></td></tr><tr><td align="left">External non-constant global variable</td><td align="left">int g_x;</td><td align="left">File</td><td align="left">Static</td><td align="left">External</td><td align="left">Initialized or uninitialized</td></tr><tr><td align="left">Internal non-constant global variable</td><td align="left">static int g_x;</td><td align="left">File</td><td align="left">Static</td><td align="left">Internal</td><td align="left">Initialized or uninitialized</td></tr><tr><td align="left">Internal constant global variable</td><td align="left">constexpr int g_x { 1 };</td><td align="left">File</td><td align="left">Static</td><td align="left">Internal</td><td align="left">Const or constexpr, Must be initialized</td></tr><tr><td align="left">External constant global variable</td><td align="left">extern constexpr int g_x { 1 };</td><td align="left">File</td><td align="left">Static</td><td align="left">External</td><td align="left">Const or constexpr, Must be initialized</td></tr><tr><td align="left">Inline constant global variable</td><td align="left">inline constexpr int g_x { 1 };</td><td align="left">File</td><td align="left">Static</td><td align="left">External</td><td align="left">Const or constexpr, Must be initialized</td></tr></tbody></table><hr><h3 id="总结提前声明"><a href="#总结提前声明" class="headerlink" title="总结提前声明"></a>总结提前声明</h3><p>你可以在其他文件中对一个 函数/变量 进行提前声明：</p><table><thead><tr><th align="left">Type</th><th align="left">Example</th><th align="left">Notes</th></tr></thead><tbody><tr><td align="left">Function forward declaration</td><td align="left">void foo(int x);</td><td align="left">Prototype only, no function body</td></tr><tr><td align="left">Non-constant global variable forward declaration</td><td align="left">extern int g_x;</td><td align="left">Must be uninitialized</td></tr><tr><td align="left">Const global variable forward declaration</td><td align="left">extern const int g_x;</td><td align="left">Must be uninitialized</td></tr><tr><td align="left">Constexpr global variable forward declaration</td><td align="left">extern constexpr int g_x;</td><td align="left"><u>Not allowed, constexpr cannot be forward declared</u></td></tr></tbody></table><hr><h3 id="什么是存储类说明符"><a href="#什么是存储类说明符" class="headerlink" title="什么是存储类说明符?"></a>什么是存储类说明符?</h3><p>当关键字<code>static</code> 、<code>extern</code>用作标识符声明的一部分时,它们就被称为：<strong>storage class specifier（存储类说明符）</strong>。它们设置标识符的存储的 <em>duration</em> 和 <em>linkage</em></p><p>C++支持4中存储类说明符：</p><table><thead><tr><th align="left">Specifier</th><th align="left">Meaning</th><th align="left">Note</th></tr></thead><tbody><tr><td align="left">extern</td><td align="left">static (or thread_local) storage duration and external linkage</td><td align="left"></td></tr><tr><td align="left">static</td><td align="left">static (or thread_local) storage duration and internal linkage</td><td align="left"></td></tr><tr><td align="left">thread_local</td><td align="left">thread storage duration</td><td align="left">Introduced in C++11</td></tr><tr><td align="left">mutable</td><td align="left">object allowed to be modified even if containing class is const</td><td align="left"></td></tr><tr><td align="left">auto</td><td align="left">automatic storage duration</td><td align="left">Deprecated in C++11</td></tr><tr><td align="left">register</td><td align="left">automatic storage duration and hint to the compiler to place in a register</td><td align="left">Deprecated in C++17</td></tr></tbody></table><blockquote><p>术语 <em>storage class specifier</em> 通常只在正式文档中使用。</p></blockquote><hr><h2 id="6-12-using-语句"><a href="#6-12-using-语句" class="headerlink" title="6.12 using 语句"></a>6.12 using 语句</h2><p>如果你经常使用标准库，那么在使用标准库中的所有内容之前输入std::会变得重复。C++提供了一种可选择的办法，叫做：<strong><em>using statements</em></strong></p><h3 id="using的声明"><a href="#using的声明" class="headerlink" title="using的声明"></a>using的声明</h3><p>一种简化的方法是使用using声明语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="comment">// this using declaration tells the compiler that cout should resolve to std::cout</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!"</span>; <span class="comment">// so no std:: prefix is needed here!</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// the using declaration expires here</span></span><br></pre></td></tr></table></figure><blockquote><p>using 的声明：<code>using std::cout</code>告诉编译器我们将要使用 命名空间std 中的<code>cout</code>。所以当编译器看到cout时，它会假设我们指的是std::cout。</p><p>如果std::cout与cout的其他一些使用之间存在命名冲突，则首选std::cout。</p></blockquote><p>上面的例子，看起来似乎没有简化多少。但如果我们要多次使用<code>cout</code>时，使用 <code>using statements</code>就可以简化很多。</p><blockquote><p>注意，如果你多次使用<code>std::cout</code>和<code>std::cin</code>的话，你需要对他们两个分别使用<code>using statements</code></p></blockquote><hr><h3 id="using-指令"><a href="#using-指令" class="headerlink" title="using 指令"></a>using 指令</h3><p>另一种方法就是使用：<code>using directive</code>语句。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">//这个using指令 告诉编译器我们可以使用 命名空间std 中的任何东西</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world!"</span>; <span class="comment">// 所以，前缀 std:: 就可以省略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个using 指令 ：<code>using namespace std</code>告诉编译器我们想使用 命名空间std 中的任何东西。所以当编译器发现了一个名字它不认识时，它就会检查 命名空间std。</p><p>结果就是，当编译器遇到<code>cout</code>(编译器不认识cout)，编译器就会查看 命名空间std 然后找到cout。</p><hr><p>如果std::cout与cout的其他一些使用之间存在命名冲突，编译器将把它<strong>标记为错误</strong>(而不是选择其中之一)。</p></blockquote><p>下面来看一下 using 指令 造成的歧义：</p><ul><li><p>eg1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> a</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x&#123; <span class="number">10</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> b</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x&#123; <span class="number">20</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> a;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> b;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面例子中，编译器无法在mian函数中决定使用<code>a::x</code>还是<code>b::x</code>。然后就会出现“不明确的符号”错误。</p><p>要想解决这个冲突，我们可以加上前缀使用。即显示标明使用的是哪一个命名空间中的x。</p></blockquote></li><li><p>eg2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // imports the declaration of std::cout</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cout</span><span class="params">()</span> <span class="comment">// declares our own "cout" function</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">// makes std::cout accessible as "cout"</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, world!"</span>; <span class="comment">// uh oh!  Which cout do we want here?  The one in the std namespace or the one we defined above?</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>eg2中，编译器无法判断我们使用的<code>cout</code>是引用的 <code>std::cout</code>还是 cout函数。并出现“不明确的符号”错误。</p><hr><p>解决方法：</p><ol><li><p>使用<code>using declaration</code> 来替代 <code>using directive</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="comment">//告诉编译器， cout 指的是 std::cout</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, world!"</span>; <span class="comment">//所以cout表示的是 std::cout</span></span><br></pre></td></tr></table></figure></li><li><p>显示的使用前缀：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, world!"</span>; <span class="comment">//告诉编译器使用的是std::cout</span></span><br></pre></td></tr></table></figure></li></ol></blockquote></li></ul><hr><h3 id="取消or替换-using语句"><a href="#取消or替换-using语句" class="headerlink" title="取消or替换 using语句"></a>取消or替换 using语句</h3><p>一旦，using语句被声明，那就没有办法在声明它的范围内使用另一个using语句替换或取消它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Foo;</span><br><span class="line">    <span class="comment">//此时无法使用一个其他的 using语句来 取消或替换 “using namespace Foo;”</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//using namespace Foo ends here</span></span><br></pre></td></tr></table></figure><p>对应它的最好办法就是，显示的限制 using语句 的范围：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> Foo; <span class="comment">//在这里调用Foo::中的东西</span></span><br><span class="line">    &#125; <span class="comment">//using namespace Foo 过期</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span><span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，<strong>可以显式地使用范围解析操作符(::)来避免所有这些麻烦。</strong></p><hr><h2 id="6-13-typedef与类型别名"><a href="#6-13-typedef与类型别名" class="headerlink" title="6.13 typedef与类型别名"></a>6.13 typedef与类型别名</h2><center>**优先使用类型别名，而不是typedefs，并大量使用它们来记录类型的含义**</center><p><code>typedef</code>允许程序猿去创建一个数据类型的别名。然后可以使用别名来替换这个类型真正的名字。</p><blockquote><p>Typedef的字面意思是“<strong>类型定义”</strong></p></blockquote><p>我们可以使用关键字<code>typedef</code>，来进行 类型定义：</p><blockquote><p><code>typedef a b</code> ：其中<code>a</code>表示类型的名字，<code>b</code>表示类型被替换成的别名.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> <span class="keyword">distance_t</span>; <span class="comment">//定义distance_t 作为 double类型 的别名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面两个语句是等价的:</span></span><br><span class="line"><span class="keyword">double</span> howFar;</span><br><span class="line"><span class="keyword">distance_t</span> howFar;</span><br></pre></td></tr></table></figure><blockquote><p>按照惯例，typedef名称是使用“_t”后缀声明的。这有助于指示标识符代表的是类型，而不是变量或函数，还有助于防止与其他标识符的命名冲突。</p></blockquote><hr><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>为了帮助解决这些问题，我们引入了一种改进的typedefs语法，它模仿了变量的声明方式。这种语法称为 <strong>type alias(类型别名)</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> <span class="keyword">distance_t</span>; <span class="comment">//定义distance_t 作为 double类型的 别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">distance_t</span> = <span class="keyword">double</span>; <span class="comment">//定义distance_t 作为 double类型的 别名【推荐】</span></span><br></pre></td></tr></table></figure><blockquote><p>上面两个语句在功能上等价。</p><p>【NOTE】虽然使用了关键字<code>using</code>（在这里是重载的意义），但这和 与命名空间相关的 using语句 没有关系。</p></blockquote><hr><h4 id="为易读性使用类型别名"><a href="#为易读性使用类型别名" class="headerlink" title="为易读性使用类型别名"></a>为易读性使用类型别名</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GradeTest</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>我们可以看到返回值是一个整数，但是这个整数是什么意思呢?一个字母等级?遗漏了多少问题?学生的身份证号码?一个错误代码?谁知道!Int不能告诉我们任何东西。写成下面形式，便于理解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> testScore_t = <span class="keyword">int</span>;</span><br><span class="line"><span class="function">testScore_t <span class="title">GradeTest</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="使用类型别名编写与平台无关的代码"><a href="#使用类型别名编写与平台无关的代码" class="headerlink" title="使用类型别名编写与平台无关的代码"></a>使用类型别名编写与平台无关的代码</h4><p>比如，在一些平台中，<code>int</code>类型占2个字节；但在其他平台中，可能占4个字节。所以，在4字节平台中写的代码在2字节平台中可能会出错。</p><p>所以，使用类型别名可以帮助我们避免出错，也更清楚地说明了对变量大小的假设。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> INT_2_BYTES</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">int8_t</span> = <span class="keyword">char</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">int16_t</span> = <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">int32_t</span> = <span class="keyword">long</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">int8_t</span> = <span class="keyword">char</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">int16_t</span> = short;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">int32_t</span> = <span class="keyword">int</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><blockquote><p>如果，在一个机器中，整数是2个字节。那么<code>INT_2_BYTES</code>将被定义。此时，就使用的是上部定义的这几个。</p><p>如果，在一个机器中，整数是4个字节。那么<code>INT_2_BYTES</code>将不被定义。此时，就使用的是下部定义的这几个。</p><hr><p>这种情况下：通过使用char、short、int和long的组合，这对于正在编译程序的机器是合适的</p><p><code>int_8</code>将处理 1字节的整数；</p><p><code>int16_t</code>将处理 2字节的整数；</p><p><code>int32_t</code>将处理 4字节的整数。</p></blockquote><hr><h2 id="6-14-关键字auto"><a href="#6-14-关键字auto" class="headerlink" title="6.14 关键字auto"></a>6.14 关键字<code>auto</code></h2><p>看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d &#123;<span class="number">5.0</span>&#125;;</span><br></pre></td></tr></table></figure><p>如果C++早就知道<code>5.0</code>是double类型的数字，那为什么我们还要显示的指定<code>d</code>是double类型的呢？如果我们可以让一个变量根据我们初始化它的值来设想它的类型，这不是很好吗?</p><h3 id="初始化变量的类型推断"><a href="#初始化变量的类型推断" class="headerlink" title="初始化变量的类型推断"></a>初始化变量的类型推断</h3><p>当初始化一个变量，关键字<code>auto</code>可以用来代替类型，以告诉编译器从初始化器的类型推断变量的类型。这种就叫作：<strong><em>type inference</em>(类型推断)</strong>, 英文中也可以叫作：<strong><em>type deduction</em></strong></p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> d &#123;<span class="number">5.0</span>&#125;; <span class="comment">//因为5.0是一个double类型的数字，所以它的类型将被推断为double</span></span><br><span class="line"><span class="keyword">auto</span> i &#123;<span class="number">1</span>+<span class="number">2</span>&#125;; <span class="comment">//因为1+2的结果是int类型，所以，i 将被推断为int类型</span></span><br></pre></td></tr></table></figure><p>也可以用在函数返回值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sum&#123;add(<span class="number">5</span>,<span class="number">6</span>)&#125;; <span class="comment">//add() 返回一个int, 所以sum的类型将被推断为int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="在C-14中函数的类型推断"><a href="#在C-14中函数的类型推断" class="headerlink" title="在C++14中函数的类型推断"></a>在C++14中函数的类型推断</h3><p>在C++14中，关键字<code>auto</code>被扩展到可以从函数体中的返回语句推断出函数的返回类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为<code>x+y</code>的值是int类型，编译器将会推断这个函数应该返回一个int类型。当使用<code>auto</code>返回类型时，所有的返回语句就必须返回相同的类型，否则将会出错。</p></blockquote><p>但是不推荐对函数的返回类型使用关键字<code>auto</code>。</p><blockquote><p>因为没有上下文来帮助指示函数返回的类型。用户实际上必须深入函数体本身来确定函数返回的类型。它不那么直观，因此更容易出错。</p></blockquote><hr><h3 id="后置返回类型语法"><a href="#后置返回类型语法" class="headerlink" title="后置返回类型语法"></a>后置返回类型语法</h3><p>关键字<code>auto</code>也可以被用来<strong>后置返回类型(trailing return syntax)</strong>。即，在函数原型之后指定返回的类型。</p><blockquote><p>这是C++11新增的<strong>一种函数声明</strong>的方法。</p></blockquote><p>下面的两个对函数声明的语句是等价的：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">auto add(int x, int y) -&gt; int;//在这种情况下，auto不执行类型推断——使用后置返回类型只是语法的一部分。</span><br></pre></td></tr></table></figure><hr><p>那为什么要用后置类型返回语句呢？其中的好处之一就是：可以让函数的声明时的名字对齐😊，如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto add(int x, int y) -&gt; int;</span><br><span class="line">auto divide(double x, double y) -&gt; double;</span><br><span class="line">auto printSomething() -&gt; void;</span><br><span class="line">auto generateSubstring(const std::string &amp;s, int start, int len) -&gt; std::string;</span><br></pre></td></tr></table></figure><hr><h3 id="函数形参的类型推断"><a href="#函数形参的类型推断" class="headerlink" title="函数形参的类型推断"></a>函数形参的类型推断</h3><blockquote><p><strong>在C++20时引入的</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">auto</span> x, <span class="keyword">auto</span> y)</span> <span class="comment">//only valid in C++20</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    add(<span class="number">2</span>, <span class="number">3</span>);    <span class="comment">//int</span></span><br><span class="line">    add(<span class="number">1.1</span>, <span class="number">2.2</span>); <span class="comment">//double</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在C++20之前</strong>，这种形式是无效的。因为编译器在 编译时(complie time) 不能推断函数形参的类型。</p><blockquote><p>在C++20之前，如果你想要创建一个使用各种不同类型的泛型函数，你需要使用<code>function templates</code>，而不是现在用的<code>type inference</code></p></blockquote><hr><h3 id="6-15-强制类型转换-隐式"><a href="#6-15-强制类型转换-隐式" class="headerlink" title="6.15 强制类型转换(隐式)"></a>6.15 强制类型转换(隐式)</h3><blockquote><p>类型转换有两种形式：</p><ul><li><strong>implicit type conversion</strong>（隐式类型转换）：编译器会自动将一种数据类型转换为另一种数据类型</li><li><strong>explicit type conversion</strong>（显示类型转换）：开发人员使用转换操作符来指导转换。</li></ul></blockquote><p>将值从一种数据类型转换为另一种数据类型的过程称为<strong><em>type conversion</em>(类型转换)</strong>。类型转换可以在许多不同的情况下发生:</p><ul><li><p>当用不同数据类型的值 分配 或 初始 化一个变量时:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d&#123;<span class="number">3</span>&#125;;  <span class="comment">// initialize double variable with integer value 3</span></span><br><span class="line">d = <span class="number">6</span>;    <span class="comment">// assign double variable the integer value 6</span></span><br></pre></td></tr></table></figure></li><li><p>当传递一个值给一个函数时，但函数参数是不同的数据类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">long</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">doSomething(<span class="number">3</span>); <span class="comment">// pass integer value 3 to a function expecting a long parameter</span></span><br></pre></td></tr></table></figure></li><li><p>当从一个函数返回一个值时，该函数的返回类型是不同的数据类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3.0</span>; <span class="comment">// Return double value 3.0 back to caller through float return type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用不同类型的操作数的 二元操作符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> division&#123; <span class="number">4.0</span> / <span class="number">3</span> &#125;; <span class="comment">// division with a double and an integer</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p><strong>隐式类型转换</strong>(也称为<strong>自动类型转换</strong>或<strong>强制转换</strong>)在希望是这种数据类型，但提供了另一种数据类型。乳沟编译器能够辨认出类型转换中的两种类型，挠他就转换。否则，报错。</p><blockquote><p>隐式类型转换有两种基本类型：<strong>提升</strong>和<strong>转换</strong>。</p></blockquote><ul><li><p><strong><em>Numeric promotion</em>数值提升</strong></p><p>每当将一个基本数据类型的值转换为来自同一族的更大的基本数据类型的值时，这称为<strong>数值提升</strong>(或<strong>加宽</strong>，尽管这个术语通常用于整数)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//an int can be widened into a long, or a float promoted into a double:</span></span><br><span class="line"><span class="keyword">long</span> l&#123; <span class="number">64</span> &#125;; <span class="comment">// widen the integer 64 into a long</span></span><br><span class="line"><span class="keyword">double</span> d&#123; <span class="number">0.12f</span> &#125;; <span class="comment">// promote the float 0.12 into a double</span></span><br></pre></td></tr></table></figure><p>虽然术语数值推广涵盖了任何类型的提升，但在c++中还有两个具有特定含义的术语:</p><ul><li><strong>Integral promotion(整型提升)</strong>：可以将[ <code>bool</code> , <code>char</code>, <code>unsigned char</code>, <code>signed char</code>, <code>unsigned short</code>, and <code>signed short</code> ]这些类型转换为 <code>int</code>或者是<code>unsigned int</code></li><li><strong>Floating point promotion(浮点型提升)</strong>：可以将<code>float</code>类型转换为<code>double</code></li></ul><p>整型提升 和 浮点型提升 通常是将 较小的数据类型转换为<code>int</code>/<code>unsigned int</code>或<code>double</code>。</p><hr></li><li><p><strong>Numeric conversions(数值转换)</strong></p><p>当我们将一个值从较大的类型转换为类似的较小类型时，或者在不同类型之间转换时，这称为数值转换。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d&#123; <span class="number">3</span> &#125;; <span class="comment">// convert integer 3 to a double (between different types)</span></span><br><span class="line">short s&#123; <span class="number">2</span> &#125;; <span class="comment">// convert integer 2 to a short (from larger to smaller type within same type family)</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>数值提升</strong>是安全的；但是<strong>数值转换</strong>可能会丢失数据。</p><blockquote><p>因此，导致执行隐式转换的代码通常会导致编译器发出警告。</p></blockquote></blockquote><p>eg,将一个值转换为的类型没有足够大的范围来支持这个值，就会出现意想不到的结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i&#123; <span class="number">30000</span> &#125;;</span><br><span class="line">    <span class="keyword">char</span> c = i; <span class="comment">// chars have range -128 to 127</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(c);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果**********/</span></span><br><span class="line"><span class="number">48</span></span><br></pre></td></tr></table></figure><blockquote><p>在本例中，我们将一个大整数分配给一个char(其范围为-128到127)。这会导致char溢出，并产生一个意外的结果: 48</p></blockquote><p>但是，只要值符合较小类型的范围，从较大的整数或浮点类型转换为较小的类似类型通常就可以工作。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> i&#123; <span class="number">2</span> &#125;;</span><br><span class="line">    short s = i; <span class="comment">// convert from int to short</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">double</span> d&#123; <span class="number">0.1234</span> &#125;;</span><br><span class="line">    <span class="keyword">float</span> f = d;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********结果**************/</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">0.1234</span></span><br></pre></td></tr></table></figure><p>对于浮点值，由于较小类型的精度损失，可能会出现一些舍入。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">0.123456789</span>; <span class="comment">// double value 0.123456789 has 9 significant digits, but float can only support about 7</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">9</span>) &lt;&lt; f &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// std::setprecision defined in 头文件“iomanip”中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************结果************/</span></span><br><span class="line"><span class="number">0.123456791</span></span><br></pre></td></tr></table></figure><p>只要值符合浮点类型的范围，就可以将整数转换为浮点数。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> i&#123; <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">float</span> f = i;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************结果**************/</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>只要值符合整数的范围，就可以将浮点数转换为整数，但是任何小数值都会丢失。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> i = <span class="number">3.5</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***在本例中，丢失了分数值(.5)，结果如下:****/</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>计算算术表达式</strong></p><p>当计算表达式时，编译器将每个表达式分解成单独的子表达式。算术运算符要求它们的<strong>操作数必须是相同的类型</strong>。为了确保这一点，编译器使用以下规则:</p><ul><li><p>如果一个操作数是一个比<code>int</code>更窄的整数，它将经历整数提升(如上所述)到<code>int</code>或<code>usigned int</code>。</p></li><li><p>如果操作数仍然不匹配，那么编译器会找到优先级最高的操作数，并隐式地将另一个操作数转换为匹配的操作数。</p><blockquote><p>操作数的优先级如下:</p><ul><li>long double (highest)</li><li>double</li><li>float</li><li>unsigned long long</li><li>long long</li><li>unsigned long</li><li>long</li><li>unsigned int</li><li>int (lowest)</li></ul></blockquote></li></ul><p>我们可以通过使用typeid操作符(包含在头中)看到通常的算术转换，该操作符可用于显示表达式的结果类型。</p><p>eg1:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt; // for typeid()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    short a&#123; <span class="number">4</span> &#125;;</span><br><span class="line">    short b&#123; <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(a + b).name() &lt;&lt; <span class="string">" "</span> &lt;&lt; a + b &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// show us the type of a + b</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*因为short是整数，所以它们在被添加之前要经过整数提升到int。添加两个int的结果是一个int，正如您所期望的:*/</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><blockquote><p>注意:编译器可能会显示一些稍微不同的内容，因为typeid.name()的格式由编译器决定。</p></blockquote><p>eg2:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt; // for typeid()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d&#123; <span class="number">4.0</span> &#125;;</span><br><span class="line">    short s&#123; <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(d + s).name() &lt;&lt; <span class="string">' '</span> &lt;&lt; d + s &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// show us the type of d + s</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****结果*************/</span></span><br><span class="line"><span class="keyword">double</span> <span class="number">6.0</span></span><br></pre></td></tr></table></figure><p>在这种情况下，<code>short</code>将被 <em>数值提升</em> 为<code>int</code>。但是，<code>int</code>与<code>double</code>还是不匹配。又因为<code>double</code>在类型的层次结构中更高。所以，整型的2将被转换为double 类型的 2.0 。然后就相当于是两个double类型的相加，结果还是double类型.</p></li></ul><hr><h2 id="强制类型转换-显式-amp-static-cast"><a href="#强制类型转换-显式-amp-static-cast" class="headerlink" title="强制类型转换(显式) &amp; static_cast"></a>强制类型转换(显式) &amp; <code>static_cast</code></h2><p>显式的类型转换是使用 <strong>type casting operator(类型转换操作符)</strong>。（通常是程序员来做的一个显式的的类型转换）</p><p>在C++中，类型转换大致分为5种： <code>C-style casts</code>, <code>static casts</code>, <code>const casts</code>, <code>dynamic casts</code>, and <code>reinterpret casts</code>. 后四个有时被称为<strong>命名类型转换(named casts)</strong>。</p><p>在本节课中，我们将介绍c风格的类型转换和静态类型转换。我们将在以后的课程中讨论指针和继承时再保存动态类型转换。</p><blockquote><p>通常应该避免使用<code>Const casts</code>和<code>reinterpret casts</code>，因为它们只在极少数情况下有用，如果使用不当可能会有害。</p></blockquote><hr><h3 id="C-style-casts"><a href="#C-style-casts" class="headerlink" title="C-style casts"></a>C-style casts</h3><p>在标准的C语言中，类型转换是通过 <strong>操作符<code>()</code></strong>来完成的。括号内是将要转换的目标类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i1 &#123; <span class="number">10</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> i2 &#123; <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">float</span> f &#123; (<span class="keyword">float</span>)i1 / i2 &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>在上面的程序中，我们使用浮点c风格的强制转换来告诉编译器将<code>i1</code>转换为浮点值。</p><p>因为运算符<code>/</code>的左操作数现在变为浮点值，右操作符也将被转换为浮点值。并且除法将使用浮点除法而不是整数除法!</p></blockquote><hr><p><strong>使用强制类型转换来清除隐式类型转换</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i &#123; <span class="number">48</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// explicit conversion from int to char, so that a char is assigned to variable ch</span></span><br><span class="line"><span class="keyword">char</span> ch = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(i);</span><br></pre></td></tr></table></figure><blockquote><p>当我们这样做时，我们显式地告诉编译器这个转换是有意的，并且我们接受对结果的责任。因为这个<code>static_cast</code>的输出类型是char，所以对变量ch的赋值不会产生任何类型不匹配，因此没有警告。</p></blockquote><p>下面的程序，编译器将会抱怨将double转换成int可能会导致数据丢失:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i &#123; <span class="number">100</span> &#125;;</span><br><span class="line">i = i / <span class="number">2.5</span>;</span><br></pre></td></tr></table></figure><p>告诉编译器，我们明确的意思是这样做:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i &#123; <span class="number">100</span> &#125;;</span><br><span class="line">i = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(i / <span class="number">2.5</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="6-17-未命名-内联-命名空间"><a href="#6-17-未命名-内联-命名空间" class="headerlink" title="6.17 未命名/内联 命名空间"></a>6.17 未命名/内联 命名空间</h2><h3 id="未命名-匿名-命名空间"><a href="#未命名-匿名-命名空间" class="headerlink" title="未命名(匿名) 命名空间"></a>未命名(匿名) 命名空间</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> <span class="comment">// unnamed namespace</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="comment">// can only be accessed in this file</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    doSomething(); <span class="comment">// we can call doSomething() without a namespace prefix</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果**********/</span></span><br><span class="line">v1</span><br></pre></td></tr></table></figure><blockquote><p>在未命名的命名空间中声明的所有内容都被视为父命名空间的一部分。因此，尽管<code>doSomething</code>函数是在未命名的命名空间中定义的，但函数本身可以从父命名空间(在本例中是<code>global namespace</code>)访问，这就是为什么我们可以从main调用doSomething而不需要任何限定符。</p></blockquote><p>这可能使未命名的命名空间看起来毫无用处。但未命名名称空间的另一个影响是：未命名命名空间内的所有标识符都被视为具有<strong>内部链接</strong>，<u>这意味着未命名命名空间的内容就不能在其他文件中看到</u>。</p><hr><p><strong>对于函数</strong>，<u>这实际上等同于将未命名的命名空间中的所有函数定义为<strong>静态函数</strong></u>。下面的程序与上面的程序实际上是相同的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="comment">// can only be accessed in this file</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    doSomething(); <span class="comment">// we can call doSomething() without a namespace prefix</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong><code>unnamed namespace</code></strong>通常用于 当你有很多内容想要确保在给定文件中保持局部时，使用<code>unnamed namespace</code>要比单独将所有声明标记为<code>static</code>更容易。</p><hr><h3 id="内联-命名空间"><a href="#内联-命名空间" class="headerlink" title="内联 命名空间"></a>内联 命名空间</h3><blockquote><p><strong>Inline namespaces</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    doSomething();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是假设你对doSomething不满意，你想通过改变它的行为方式来改进它。但如果这样做，就有可能破坏使用旧版本的现有程序。你是怎么处理的?</p><ul><li><p>一种方法是用不同的名称创建函数的新版本。但是经过许多更改之后，您可能会得到一组名称几乎相同的函数(doSomething、doSomething_v2、doSomething_v3等)。</p></li><li><p>【推荐】另一种方法是使用<strong>内联命名空间</strong>。<u>内联命名空间是通常用于版本化内容的名称空间</u>。与未命名的命名空间非常相似，<u>在内联命名空间中声明的任何内容都被认为是父名称空间的一部分</u>。<u>然而，内联命名空间并不是 内部链接。</u></p><blockquote><p>使用关键字<code>inline</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">namespace</span> v1 <span class="comment">// declare an inline namespace named v1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> v2 <span class="comment">// declare a normal namespace named v2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v2\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    v1::doSomething(); <span class="comment">// calls the v1 version of doSomething()</span></span><br><span class="line">    v2::doSomething(); <span class="comment">// calls the v2 version of doSomething()</span></span><br><span class="line"> </span><br><span class="line">    doSomething(); <span class="comment">// calls the inline version of doSomething() (which is v1)</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********结果********/</span></span><br><span class="line">v1</span><br><span class="line">v2</span><br><span class="line">v1</span><br></pre></td></tr></table></figure><blockquote><p>可以看出，当有 <strong>内联函数</strong>存在时，<u>如果不加前缀，<strong>则默认调用的是 内联函数版本</strong></u></p></blockquote><p>在上面的例子中，调用<code>doSomething</code>将得到<code>doSomething</code>的v1(内联版本)。希望使用新版本的调用者可以<strong>显式</strong>地调用<code>v2::dosomething()</code>。</p><blockquote><p>这保留了现有程序的功能，同时允许更新的程序利用更新的/更好的变体。</p></blockquote><hr></li></ul><h2 id="6-x-Chapter-6-summary-and-quiz"><a href="#6-x-Chapter-6-summary-and-quiz" class="headerlink" title="6.x Chapter 6 summary and quiz"></a>6.x Chapter 6 summary and quiz</h2><p><a href="https://www.learncpp.com/cpp-tutorial/chapter-6-summary-and-quiz/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/chapter-6-summary-and-quiz/</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GIT 学习</title>
      <link href="/archives/18085cf9.html"/>
      <url>/archives/18085cf9.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red></red>Git学习笔记</p></center><a id="more"></a><p>Git的三种状态：</p><blockquote><p>committed（已提交）：数据已经安全的保存在本地数据库（仓库）；</p><p>modified（已修改）：修改了文件，<strong>但还没有保存到数据库</strong>；</p><p>staged（已暂存）：对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</p></blockquote><p>Git项目的三个工作区域概念：</p><blockquote><p><strong>Git仓库（Git directory 或 repository）：</strong>是Git用来保存项目的元数据和对象数据库的地方。是Git最重要部分，从其他计算机克隆仓库时，拷贝的就是这里的数据。</p><p><strong>工作目录（working directory）：</strong>对项目的某个版本独立提取出来的内容。这些从Git仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</p><p><strong>暂存区域（staging area）：</strong>是一个文件，保存了下一次将提交的文件列表信息，一般在Git仓库目录中，有时也被称作“索引”。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/1576831394522.png" alt="1576831394522"></p><p>基本的 Git 工作流程如下：</p><blockquote><p>1.在工作目录中修改文件；</p><p>2.暂存文件，将文件的快照放入暂存区域；</p><p>3.提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目。</p></blockquote><h1 id="初始设置："><a href="#初始设置：" class="headerlink" title="初始设置："></a>初始设置：</h1><h2 id="设置姓名和邮箱："><a href="#设置姓名和邮箱：" class="headerlink" title="设置姓名和邮箱："></a>设置姓名和邮箱：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Firstname Lastname&quot; &#x2F;&#x2F; 名字使用英文输入</span><br><span class="line">git config --global user.email &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><p>这个命令，会在“<code>~/.gitconfig</code>”中以如下形式输出设置文件。我的电脑上，这个文件夹的位置在<code>C:\Users\ACER</code></p><h2 id="设置SSH-key"><a href="#设置SSH-key" class="headerlink" title="设置SSH key:"></a>设置<code>SSH key</code>:</h2><p>创建公开密钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，我的在：<code>C:\Users\ACER\.ssh</code></p><p>里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是<strong>私钥</strong>，不能泄露出去，<code>id_rsa.pub</code>是<strong>公钥</strong>，可以放心地告诉任何人。</p><h2 id="初始化Git仓库："><a href="#初始化Git仓库：" class="headerlink" title="初始化Git仓库："></a>初始化Git仓库：</h2><p>在该仓库中，打开Git bash，然后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><h2 id="关联远程仓库："><a href="#关联远程仓库：" class="headerlink" title="关联远程仓库："></a>关联远程仓库：</h2><p>在远程仓库（如：<code>github、gitee</code>）中有一个新仓库什么都没有，我们可以：</p><p>克隆一份到本地；也可以把一个已有的本地仓库与之关联。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git remote add &lt;远程仓库名字&gt; &lt;远程仓库的SSH或HTTPS&gt;</span><br><span class="line"></span><br><span class="line">如：git remote add origin git@github.com:michaelliao&#x2F;learngit.git</span><br><span class="line">其中：</span><br><span class="line">远程仓库名字：origin（是git的默认叫法，也可以写成其他的）</span><br><span class="line">远程仓库的SSH：git@github.com:longlongqin&#x2F;learngit.git</span><br></pre></td></tr></table></figure><ul><li><input checked disabled type="checkbox"> <strong>当需要将<u>一个仓库</u>同时在<code>github 和 gitee</code>上关联时：</strong></li></ul><ol><li><p>假如在<code>gitee</code>上关联之前，已经在<code>GitHub</code>上关联过了。</p><p>比如事先在GitHub上：<code>git remote add origin git@github.com:longlongqin/LearnGit.git</code>，关联了一个叫<code>origin</code>的远程仓库。</p><p>然后，我现在要在gitee上关联一个仓库：</p><p><code>git remote add origin git@gitee.com:longlongqin/LearnGit.git</code></p><p>出现<u>报错</u>：fatal: remote origin already exists.说明，本地库已经关联了一个叫做<code>origin</code>的远程仓库了，所以才会报错。</p></li><li><p>所以，我们知道，不能将github和gitee上的仓库名字都叫一样的名字。他们之间的名字要区分。</p></li></ol><blockquote><ul><li><p>先，删除关联的已有的GitHub远程库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure></li><li><p>再开始重新关联github和gitee的仓库，这次要将他们的仓库名字区分开：</p><p>/*gitee中的LearnGit仓库起名：<code>gitee</code>；</p><p>/*github中的LearnGit仓库起名：<code>github</code>；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote gitee origin git@gitee.com:longlongqin&#x2F;LearnGit.git</span><br><span class="line">git remote github origin git@github.com:longlongqin&#x2F;LearnGit.git</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>检查一下，是否成功：</p><p>​ 我们用<code>git remote -v</code>查看远程库信息，可以看到两个远程库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">giteegit@gitee.com:longlongqin&#x2F;LearnGit.git (fetch)</span><br><span class="line">giteegit@gitee.com:longlongqin&#x2F;LearnGit.git (push)</span><br><span class="line">githubgit@github.com:longlongqin&#x2F;LearnGit.git (fetch)</span><br><span class="line">githubgit@github.com:longlongqin&#x2F;LearnGit.git (push)</span><br></pre></td></tr></table></figure><p>成功。</p><h2 id="取消关联远程仓库："><a href="#取消关联远程仓库：" class="headerlink" title="取消关联远程仓库："></a>取消关联远程仓库：</h2><p>在<strong><em>关联远程仓库</em></strong>一节中，关联远程仓库，我们也可以取消以经关联的远程仓库，让他们取消关联：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm &lt;要取消关联的远程仓库的名字&gt;</span><br></pre></td></tr></table></figure><h1 id="时光穿梭机"><a href="#时光穿梭机" class="headerlink" title="时光穿梭机"></a>时光穿梭机</h1><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><blockquote><p>1、<strong>没有<code>git add</code>时</strong>（即，对文件做了修改，但是没添加到暂存区）：==用<code>git checkout -- &lt;file&gt;</code> (==file前面有一个<strong>空格</strong>)</p><p>2、<strong>已经<code>git add</code>时</strong>（即，对文件做了修改，并且添加到暂存区）：</p><ul><li>先<code>git reset HEAD &lt;file&gt;</code>把暂存区的修改撤销掉，即：回退到没有git add时的状态</li><li>然后，再<code>git checkout -- &lt;file&gt;</code>。</li></ul><p>3、<strong>已经<code>git commit</code>时</strong>（即，对文件做了修改，不仅添加到暂存区，而且还提交到本地仓库中了）：进行==<strong>版本回退</strong>==</p></blockquote><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>版本之间的切换，<strong>版本</strong>指的是<code>git commit</code>之后带有哈希值的状态。</p><p><strong>版本回退</strong>：</p><ul><li><p><code>git reset --hard commit_id</code> 可以回退到版本号为commit_id的那个版本。</p></li><li><p><code>git reset --hard head^</code> 回退到当前版本的上一个版本。</p></li></ul><p><strong>转回到新版本</strong>：</p><p>因为<code>git log</code>显示的是从此刻<code>head指针</code>所在的状态到之前的状态的提交日志。而<code>git reflog</code>用来记录你的每一次命令。</p><p>所以转回到比当前所在的状态要新的状态需要：</p><ol><li><code>git reflog</code>,找到你想要回去的那个较新的状态的commit 的id</li><li><code>git reset --hard &lt;commit_id&gt;</code> 回到想要回器的那个版本。</li></ol><h1 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h1><ul><li><code>rm &lt;file&gt;</code>从工作区中删除文件（和手动删除文件效果一样。）</li></ul><p><code>git rm &lt;file&gt;</code>将文件从工作区删除，并且还添加到了暂存区（即，把删除的这个状态同步到暂存区了）。<br><code>git rm -r &lt;文件夹&gt;</code> 删除一个文件夹</p><p>[^小提示]: 先手动删除文件，然后使用git rm<file>和git add<file>效果是一样的。</file></file></p><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><h2 id="添加远程仓库："><a href="#添加远程仓库：" class="headerlink" title="添加远程仓库："></a>添加远程仓库：</h2><blockquote><p>关联一个远程仓库：<code>git remote add origin git@github.com:path/repo-name.git</code></p><p>关联后，<strong>第一次</strong>推送master分支的所有内容：<code>git push origin master</code></p></blockquote><h2 id="远程仓库克隆："><a href="#远程仓库克隆：" class="headerlink" title="远程仓库克隆："></a>远程仓库克隆：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;你想要克隆内容的公开密钥的密码&gt;</span><br></pre></td></tr></table></figure><p>公开的密钥密码，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200218130632774.png" alt="image-20200218130632774"></p><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><h2 id="创建与合并分支："><a href="#创建与合并分支：" class="headerlink" title="创建与合并分支："></a>创建与合并分支：</h2><ul><li><p><strong>查看分支</strong>：<code>git branch</code></p></li><li><p><strong>新建分支</strong>：<code>git branch &lt;name&gt;</code></p></li><li><p><strong>创建并切换分支</strong>：<code>git checkout -b &lt;name&gt;</code> or <code>git switch -c &lt;name&gt;</code></p></li><li><p><strong>切换分支</strong>：<code>git checkout &lt;name&gt;</code> or <code>git switch &lt;name&gt;</code></p></li><li><p><strong>删除分支</strong>：<code>git branch -d &lt;name&gt;</code><em>不能删除当前所在的分支</em></p></li><li><p><strong>合并分支</strong>：<code>git merge &lt;name&gt;</code> <em>用于合并分支到<strong>当前</strong>分支</em></p></li></ul><blockquote><p><code>git merge --no-ff &lt;name&gt;</code> 其中参数–no-ff：表示在历史记录中明确记录下本次分支合并。</p><p><strong>注意</strong>：输入此命令之后，会启动编辑器，用于录入合并提交的信息。</p></blockquote><h2 id="解决冲突："><a href="#解决冲突：" class="headerlink" title="解决冲突："></a>解决冲突：</h2><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p><p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p><p>用<code>git log --graph</code>命令可以看到分支合并图。</p><h2 id="分支管理策略："><a href="#分支管理策略：" class="headerlink" title="分支管理策略："></a>分支管理策略：</h2><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p><p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p><p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p><p>所以，团队合作的分支看起来就像这样：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/0.png" alt="0"></p><p>小结：</p><p>Git分支十分强大，在团队开发中应该充分应用。</p><p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p><h2 id="合并分支的两种方式："><a href="#合并分支的两种方式：" class="headerlink" title="合并分支的两种方式："></a>合并分支的两种方式：</h2><p><strong>git 的 <code>merge</code> 与 <code>merge no-ff</code> 的不同之处</strong>： <code>no-ff merge</code>可以看到合并历史。</p><blockquote><ol><li><p>新建分支<code>dev1</code>，修改<code>readme.txt</code>，然后在<code>dev1</code>分支下<code>git add readme.txt</code> <code>git commit -m &quot;dev1 branch commit&quot;</code></p></li><li><p>回到<code>master</code>分支，执行merge即<code>git merge dev1</code></p></li><li><p>删除分支</p></li><li><p>查看日志即<code>git log --graph --pretty=oneline --abbrev-commit</code></p></li><li><p>新建分支<code>dev2</code>，修改<code>readme.txt</code>，然后在<code>dev2</code>分支下<code>git add readme.txt</code> <code>git commit -m &quot;dev2 branch commit&quot;</code></p></li><li><p>回到<code>master</code>分支，执行merge即<code>git merge --no-ff -m &quot;dev2 merged with mo-ff&quot; dev2</code></p></li><li><p>删除分支</p></li><li><p>查看日志即<code>git log --graph --pretty=oneline --abbrev-commit</code></p></li><li><p>比较两次合并，可以看出不同之处，<code>no-ff</code>的模式会记录分支历史、</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://app.yinxiang.com/FileSharing.action?hash=1/792dd8c14a3b3fed2cf0044d82d01671-16494" alt="img"></p></li></ol></blockquote><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查 Git 的某一项配置：</span></span><br><span class="line">git <span class="built_in">config</span>  &lt;key&gt; </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/1576832423904.png" alt="1576832423904"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//列出所有 Git 当时能找到的配置：</span></span><br><span class="line"> git <span class="built_in">config</span> --<span class="built_in">list</span> </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/1576832563424.png" alt="1576832563424"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取帮助：3种方法</span></span><br><span class="line">$ git help &lt;verb&gt;</span><br><span class="line">$ git &lt;verb&gt; --help</span><br><span class="line">$ man git-&lt;verb&gt;</span><br></pre></td></tr></table></figure></blockquote><h1><a href="#" class="headerlink" title="###############################################"></a>###############################################</h1><h1 id="Git-其他指令："><a href="#Git-其他指令：" class="headerlink" title="Git 其他指令："></a>Git 其他指令：</h1><h2 id="查看工作区状态status："><a href="#查看工作区状态status：" class="headerlink" title="查看工作区状态status："></a>查看<code>工作区</code>状态<code>status</code>：</h2><p><code>git status</code>查看的是工作区的状态。</p><blockquote><p><code>git diff</code> 查看工作区与暂存区的区别。</p><p><code>git diff head</code>查看工作区与本地仓库的区别。</p></blockquote><h2 id="查看文件内容："><a href="#查看文件内容：" class="headerlink" title="查看文件内容："></a>查看文件内容：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;name&gt;</span><br></pre></td></tr></table></figure><h2 id="提交："><a href="#提交：" class="headerlink" title="提交："></a>提交：</h2><h3 id="工作区提交到暂存区："><a href="#工作区提交到暂存区：" class="headerlink" title="工作区提交到暂存区："></a>工作区提交到暂存区：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &quot;filename&quot;</span><br></pre></td></tr></table></figure><h3 id="暂存区提交到本地仓库："><a href="#暂存区提交到本地仓库：" class="headerlink" title="暂存区提交到本地仓库："></a>暂存区提交到本地仓库：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;message&quot; &#x2F;&#x2F;message是对此次提交的一个说明语句</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br><span class="line">&#x2F;&#x2F;此命令可以更加详细的记述提交信息（运行此命令后，会自动打开Git设置好的编辑器）</span><br></pre></td></tr></table></figure><blockquote><p>执行此命令后，编辑器就会启动，显示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with &#39;#&#39; will be ignored, and an empty message aborts the commit.</span><br><span class="line">#</span><br><span class="line"># On branch dev</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#modified:   readme.txt</span><br><span class="line">#</span><br></pre></td></tr></table></figure><p>在编辑器中记述提交信息的格式如下：</p><p>● 第一行：用一行文字简述提交的更改内容</p><p>● 第二行：空行</p><p>● 第三行以后：记述更改的原因和详细内容</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200218142052540.png" alt="image-20200218142052540"></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend :修改上一条提交时写的信息</span><br></pre></td></tr></table></figure><h3 id="本地仓库提交-推送-到远程仓库："><a href="#本地仓库提交-推送-到远程仓库：" class="headerlink" title="本地仓库提交(推送)到远程仓库："></a>本地仓库提交(推送)到远程仓库：</h3><center>git push</center><p><strong>情况一：</strong></p><p>注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以git pull是&lt;远程分支&gt;:&lt;本地分支&gt;，而git push是&lt;本地分支&gt;:&lt;远程分支&gt;。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程仓库名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure><p><strong>情况二：（推荐）</strong></p><p>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程仓库名字&gt; &lt;将本地的分支推送到远程仓库的分支（本地分支和远程分支的名字一样）&gt;</span><br><span class="line"></span><br><span class="line">如：git push origin master</span><br><span class="line">上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。</span><br></pre></td></tr></table></figure><p><strong>情况三：</strong></p><p>下面命令将本地的<code>master</code>分支推送到<code>origin</code>远程仓库，同时指定<code>origin</code>为默认仓库，后面就可以不加任何参数使用<code>git push</code>了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u &lt;远程仓库名字&gt; &lt;将本地的分支推送到远程仓库的分支（本地分支和远程分支的名字一样）&gt;</span><br></pre></td></tr></table></figure><p><strong>情况四：</strong></p><p>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push origin :&lt;远程分支&gt;</span><br><span class="line"></span><br><span class="line"># 等同于:git push origin --<span class="keyword">delete</span> master</span><br></pre></td></tr></table></figure><h2 id="获取最新的远程仓库的分支："><a href="#获取最新的远程仓库的分支：" class="headerlink" title="获取最新的远程仓库的分支："></a>获取最新的远程仓库的分支：</h2><p>加入在远程仓库中的一个分支中的内容更新了，而本地的这个分支（和远程的这个分支名字相同）不是最新的，可以用<code>git pull</code>来同步。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;远程仓库名&gt; &lt;需要更新的分支（这个分支名：本地的和远程的名字一样）&gt;</span><br></pre></td></tr></table></figure><p>如：</p><p><code>git pull origin feature-D</code>，表示：从远程仓库<code>origin</code>中的“<code>feature-D</code>”分支进行对本地的分支“<code>feature-D</code>”更新。</p><h2 id="查看提交历史："><a href="#查看提交历史：" class="headerlink" title="查看提交历史："></a>查看提交历史：</h2><ul><li><p><code>git log</code> 查看提交（commit）历史（以便确定要回退到哪个版本）。</p><p>​ 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数，即：<code>git log --pretty=oneline</code></p></li></ul><blockquote><ul><li><p><code>git log &lt;filename&gt;</code> ：显示特定文件(filename)的提交历史</p></li><li><p><code>git log -p</code> ：文件的前后差别就会显示在提交信息之后</p></li><li><p><code>git log -p &lt;filename&gt;</code> ：只查看 “filename”文件的提交日 志以及提交前后的差别。</p></li><li><p><code>git log --graph</code>：以图表形式查看分支，例如下图：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200222002143874.png" alt="image-20200222002143874"></p></blockquote><ul><li><code>git reflog</code> 查看历史的每一次的命令（以便确定要回到未来的哪个版本）。</li></ul><h2 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git:"></a>自定义Git:</h2><h3 id="修改GIT默认编辑器："><a href="#修改GIT默认编辑器：" class="headerlink" title="修改GIT默认编辑器："></a>修改GIT默认编辑器：</h3><p>GIT默认编辑器为Vi，假如我想用<code>Notepad++</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitconfig--globalcore.editor&quot;Notepad++&quot;&#x2F;&#x2F;设置Editor使用Notepad++</span><br></pre></td></tr></table></figure><h3 id="Git显示颜色："><a href="#Git显示颜色：" class="headerlink" title="Git显示颜色："></a>Git显示颜色：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global color.ui true</span><br></pre></td></tr></table></figure><h1 id="-1"><a href="#-1" class="headerlink" title="##################################################"></a>##################################################</h1><h1 id="学习廖雪峰教学中的问题："><a href="#学习廖雪峰教学中的问题：" class="headerlink" title="学习廖雪峰教学中的问题："></a>学习廖雪峰教学中的问题：</h1><p>1、与教学步骤中的命令区别于：“–”</p><p>（1）<code>git diff head --readme.txt</code>：</p><p>问题：在我自己电脑上面运行没反应？</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200112221142249.png" alt="image-20200112221142249"></p><p><strong>解决：</strong></p><p>运行<code>：git diff head readme.txt</code>,即去掉那个“–”。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200112221407621.png" alt="image-20200112221407621"></p><p>（2）<code>git checkout --readme.txt</code></p><p>问题：在于我的电脑上多了“–”会运行失败。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200112222013881.png" alt="image-20200112222013881"></p><p>解决：去掉“–”：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200112222046360.png" alt="image-20200112222046360"></p><hr><h1 id="GitHub使用技巧"><a href="#GitHub使用技巧" class="headerlink" title="GitHub使用技巧"></a><a href="https://www.zhihu.com/question/20084458" target="_blank" rel="noopener">GitHub使用技巧</a></h1><h2 id="搜索："><a href="#搜索：" class="headerlink" title="搜索："></a>搜索：</h2><h3 id="1）、在不同地方搜索"><a href="#1）、在不同地方搜索" class="headerlink" title="1）、在不同地方搜索"></a>1）、在不同地方搜索</h3><h4 id="1、按照name搜索"><a href="#1、按照name搜索" class="headerlink" title="1、按照name搜索"></a>1、<strong>按照<code>name</code>搜索</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in:name &lt;something&gt;    &#x2F;&#x2F;假设想搜索的东西叫：something</span><br></pre></td></tr></table></figure><h4 id="2、按照readme搜索"><a href="#2、按照readme搜索" class="headerlink" title="2、按照readme搜索"></a>2、按照<code>readme</code>搜索</h4><p>也可以按照<code>readme.md</code>中包含<something>的查找项目：</something></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in:readme &lt;something&gt;   &#x2F;&#x2F;假设想搜索的东西叫：something</span><br></pre></td></tr></table></figure><h4 id="3、按照descriptin搜索"><a href="#3、按照descriptin搜索" class="headerlink" title="3、按照descriptin搜索"></a>3、按照<code>descriptin</code>搜索</h4><p>假设我们现在要学习<something>的项目，我们搜索项目描述(description)里面包含<something>的项目:</something></something></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in:description &lt;something&gt;   &#x2F;&#x2F;假设想搜索的东西叫：something</span><br></pre></td></tr></table></figure><h4 id="4、直接搜索"><a href="#4、直接搜索" class="headerlink" title="4、直接搜索"></a>4、直接搜索</h4><p>直接在搜索栏中搜索：加入想搜索与<code>CJSON</code>有关的内容：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200219151224327.png" alt="image-20200219151224327"></p><h3 id="2）、添加约束条件"><a href="#2）、添加约束条件" class="headerlink" title="2）、添加约束条件"></a>2）、添加约束条件</h3><h4 id="star数量"><a href="#star数量" class="headerlink" title="star数量"></a><strong><code>star</code>数量</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stars: &gt; 500     &#x2F;&#x2F; star 数量大于500的项目</span><br><span class="line">stars: 10..20    &#x2F;&#x2F; star 数量在10-20之间的仓库</span><br></pre></td></tr></table></figure><h4 id="fork数量"><a href="#fork数量" class="headerlink" title="fork数量"></a><code>fork</code>数量</h4><p>同理，我们也可以按照fork的数量来进行搜索:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in:name React  forks:&gt;3000</span><br></pre></td></tr></table></figure><hr><h4 id="language编程语言"><a href="#language编程语言" class="headerlink" title="language编程语言"></a><code>language</code>编程语言</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">language:python   &#x2F;&#x2F;比如，把语言限制为Python</span><br></pre></td></tr></table></figure><h4 id="仓库push的时间"><a href="#仓库push的时间" class="headerlink" title="仓库push的时间"></a>仓库<code>push</code>的时间</h4><p>假如在这些项目里面，我们想要找到最近才更新的项目，意思是更新时间就在最近，我们可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pushed:&gt;2020-01-01  &#x2F;&#x2F;项目的最近一次更新时间限制到2020-01-01之后</span><br></pre></td></tr></table></figure><hr><h4 id="仓库持有者"><a href="#仓库持有者" class="headerlink" title="仓库持有者"></a>仓库持有者</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user：&lt;username&gt;</span><br></pre></td></tr></table></figure><h4 id="仓库大小"><a href="#仓库大小" class="headerlink" title="仓库大小"></a>仓库大小</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size:&gt;&#x3D;5000 &#x2F;&#x2F; 仓库大于5000KB的仓库</span><br></pre></td></tr></table></figure><h4 id="仓库create时间"><a href="#仓库create时间" class="headerlink" title="仓库create时间"></a>仓库<code>create</code>时间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">created:&gt;2019-01-01     &#x2F;&#x2F; 2019年以后创建的仓库</span><br></pre></td></tr></table></figure><h4 id="license协议"><a href="#license协议" class="headerlink" title="license协议"></a><code>license</code>协议</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">license:apache-2.0  &#x2F;&#x2F; 使用 apache-2.0 协议的仓库</span><br></pre></td></tr></table></figure><h4 id="组织机构代码"><a href="#组织机构代码" class="headerlink" title="组织机构代码"></a>组织机构代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org:spring-cloud  &#x2F;&#x2F; 列出org 的 spring-cloud  仓库</span><br></pre></td></tr></table></figure><h3 id="3）、组合搜索"><a href="#3）、组合搜索" class="headerlink" title="3）、组合搜索"></a>3）、组合搜索</h3><p>将1）和2）中可以随机组合进行精确搜索,比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in:description &lt;something&gt; language:python  &#x2F;&#x2F;将编程语言限制为python</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in:readme &lt;something&gt; stars:&gt;3000 forks:&gt;3000</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in:description 微服务 language:python pushed:&gt;2020-01-01</span><br><span class="line">&#x2F;*pushed:&gt;2020-01-01的意思是我们把项目的最后更新时间限制到2020-01-01*&#x2F;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in:name React  forks:&gt;3000</span><br></pre></td></tr></table></figure><p>等等</p><h2 id="奇特搜索："><a href="#奇特搜索：" class="headerlink" title="奇特搜索："></a>奇特搜索：</h2><h3 id="awesome搜索"><a href="#awesome搜索" class="headerlink" title="awesome搜索"></a><code>awesome</code>搜索</h3><p><strong>1、awesome-awesome搜索</strong></p><p>直接使用<code>awesome-awesome</code>可以搜索出很多优质项目。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awesome-awesome</span><br></pre></td></tr></table></figure><p><strong>2、<code>awesome name</code>搜索</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awesome &lt;name&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnCpp chapterO</title>
      <link href="/archives/67343d3.html"/>
      <url>/archives/67343d3.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapterO</red></p></center><center><red>https://www.learncpp.com</red></center><p>未完待续~~</p><a id="more"></a><h2 id="O-1-Bit-flags-and-bit-manipulation-via-std-bitset"><a href="#O-1-Bit-flags-and-bit-manipulation-via-std-bitset" class="headerlink" title="O.1 Bit flags and bit manipulation via std::bitset"></a>O.1 Bit flags and bit manipulation via std::bitset</h2><p>在现代计算机体系结构中，最小的可寻址内存单元是<strong>字节</strong>。由于所有对象都需要有唯一的内存地址，这意味着对象的大小必须至少为一个字节。对于大多数变量类型，这是可以的。<strong>然而，对于布尔值，这有点浪费</strong>。布尔类型只有两种状态:真(1)，或假(0)。这一组状态只需要存储一位。然而，如果一个变量必须至少是一个字节，而一个字节是8位，这意味着一个布尔值使用1位，而其他7位不使用。</p><hr><ul><li><p><strong>位操作：bit manipulation</strong></p><p>在对象内部，修改单个bit的过程，叫位操作。</p><blockquote><p>位操作在加密和压缩算法中也很有用。</p></blockquote></li><li><p>但是，我们可以将对象视为单个位的集合，而不是将其视为持有单个值的对象。当对象的个别位用作布尔值时，这些位称为<strong>位标志：bit flag</strong>。</p><blockquote><p>在计算中，标志是作为某个函数或进程的信号的值。类似地，在现实生活中，邮箱标志用于指示邮箱中有内容，因此不必打开邮箱进行检查。</p></blockquote><p>为了定义一组位标志，我们通常使用适当大小的无符号整数(8位、16位、32位等等，这取决于我们有多少个标志)，或者std::bitset。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt; //for std::bitset</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;8&gt; mybitset &#123;&#125;; <span class="comment">//8 bits in size means room for 8 flags</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>位操作</strong>是少数几种<strong>应该明确使用无符号整数(或std::bitset)的操作</strong>之一。</p></blockquote></li></ul><hr><ul><li><p><strong>位编号和位的位置：Bit numbering and bit positions</strong></p><p>给定一个bits 序列，通常从右到左开始进行编号(编号的开头是0，不是1)。每一个数字表示一个<strong><em>bit positon</em>：位的位置</strong>。eg：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">76543210  Bit position</span><br><span class="line">00000101  Bit sequence</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>通过<code>std::bitset</code>操作位</strong></p><p>在 <a href="https://www.learncpp.com/cpp-tutorial/literals/" target="_blank" rel="noopener">4.12 – Literals</a>，我们介绍了如何使用<code>std::bitset</code>来输出二进制形式的结果。现在我们来介绍<code>std::bitset</code>的其他功能：</p><p><code>std::bitset</code>提供了4个关键的功能，对做位操作很有用:</p><ul><li><p><code>text()</code>：允许我们查询一个位是0还是1；</p></li><li><p><code>set()</code>：允许我们将一个 位(bit)设置成 on，即将其设置为1；</p></li><li><p><code>reset()</code>：允许我们将一个 位(bit)设置成 off，即将其设置为 0；</p></li><li><p><code>flip()</code>：允许我们将一个 位(bit) 由0设置为1，或者由1设置为0；</p><blockquote><p>这些函数中的每一个都带有一个位位置参数，该参数指示我们将要操作的位 的位置。</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;8&gt; bits&#123;<span class="number">0b0000'0101</span>&#125;; <span class="comment">//we need 8 bits, start with bit pattern 0000 0101</span></span><br><span class="line">    <span class="built_in">bit</span>.<span class="built_in">set</span>(<span class="number">3</span>); <span class="comment">//set bit position 3 to 1 (now we have 0000 1101)</span></span><br><span class="line">    <span class="built_in">bit</span>.flip(<span class="number">4</span>); <span class="comment">//flip bit 4(now we have 0001 1101)</span></span><br><span class="line">    <span class="built_in">bit</span>.reset(<span class="number">4</span>); <span class="comment">//set bit 4 back to 0 (now we have 0000 1101)</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"All the bits: "</span>&lt;&lt;bits&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"bit 3 has valude: "</span> &lt;&lt;<span class="built_in">bit</span>.test(<span class="number">3</span>) &lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>:;<span class="built_in">cout</span> &lt;&lt;<span class="string">"bit 4 has valud: "</span>&lt;&lt;<span class="built_in">bit</span>.test(<span class="number">4</span>) &lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********输出结果********/</span></span><br><span class="line">All the bits: <span class="number">00001101</span></span><br><span class="line"><span class="built_in">bit</span> <span class="number">3</span> has valude: <span class="number">1</span></span><br><span class="line"><span class="built_in">bit</span> <span class="number">4</span> has valude: <span class="number">0</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="O-2-位操作符"><a href="#O-2-位操作符" class="headerlink" title="O.2 位操作符"></a>O.2 位操作符</h2><p>C++提供了<strong>“位操作符(bitwise operator)”</strong>：</p><table><thead><tr><th align="left">Operator</th><th align="left">Symbol</th><th align="left">Form</th><th align="left">Operation</th></tr></thead><tbody><tr><td align="left">left shift</td><td align="left">&lt;&lt;</td><td align="left">x &lt;&lt; y</td><td align="left">all bits in x shifted left y bits</td></tr><tr><td align="left">right shift</td><td align="left">&gt;&gt;</td><td align="left">x &gt;&gt; y</td><td align="left">all bits in x shifted right y bits</td></tr><tr><td align="left">bitwise NOT</td><td align="left">~</td><td align="left">~x</td><td align="left">all bits in x flipped</td></tr><tr><td align="left">bitwise AND</td><td align="left">&amp;</td><td align="left">x &amp; y</td><td align="left">each bit in x AND each bit in y</td></tr><tr><td align="left">bitwise OR</td><td align="left">|</td><td align="left">x | y</td><td align="left">each bit in x OR each bit in y</td></tr><tr><td align="left">bitwise XOR</td><td align="left">^</td><td align="left">x ^ y</td><td align="left">each bit in x XOR each bit in y</td></tr></tbody></table><blockquote><p>在下面的例子中，我们将主要使用4位二进制值。这是为了方便和保持例子简单。在实际的程序中，使用的位的数量是基于对象的大小(例如，一个2字节的对象将存储16位)。</p><p>为了可读性，我们还将在代码示例之外省略0b前缀(例如，我们将使用0101而不是0b0101)。</p></blockquote><hr><ul><li><p><strong>位操作符：<code>&lt;&lt;</code>左移、<code>&gt;&gt;</code>右移</strong></p><p>按位左移(&lt;&lt;)操作符将位移到左边。左操作数是要移位的位的表达式，而右操作数是要左移的位的整数。</p><blockquote><p>如：<code>x&lt;&lt;1</code>表示，将变量x左移一个位置。从右边移进来的新位接受一个 值0。</p><p>eg，</p><p><code>0011&lt;&lt;1</code> 是 0110</p><p><code>0011&lt;&lt;2</code> 是 1100</p><p><code>0011&lt;&lt;3</code> 是 1000</p></blockquote><p>同理，按位右移(&gt;&gt;)操作符原理也一样：</p><blockquote><p><code>1100&gt;&gt;1</code> 是 0110</p><p><code>1100&gt;&gt;2</code> 是 0011</p><p><code>1100&gt;&gt;3</code> 是 0001</p></blockquote><hr><p>下面是一个示例程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;4&gt; x&#123;<span class="number">0b1100</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;x&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (x&gt;&gt;<span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//右移一个位置，结果是0110</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (x&lt;&lt;<span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//左移一个位置，结果是1000</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******结果******/</span></span><br><span class="line"><span class="number">1100</span></span><br><span class="line"><span class="number">0110</span></span><br><span class="line"><span class="number">1000</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>位操作：NOT <code>~</code></strong></p><p>这个操作符功能就是将每个位的数由0变为1，或由1变为0：</p><blockquote><p>如：<code>~0100</code> 是 1011；<code>~0000 0100</code> 是 1111 1011</p></blockquote><p>上面例子中，虽然：0100 和000 0100是一样的，就像十进制的7和07一样；但是经过<code>~</code>操作符之后，它们位数不一样，就会产生不一样的结果。</p></li></ul><hr><ul><li><p><strong>位操作：OR <code>|</code></strong></p><p>它的形式是对两个表达式进行每个位上的或运算，如：<code>0b0101 | 0b0110</code>。更加直观的形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 1 0 1 OR</span><br><span class="line">0 1 1 0</span><br><span class="line">---------   &#x2F;&#x2F;结果为</span><br><span class="line">0 1 1 1</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (<span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;&#123;<span class="number">0b0101</span>&#125; | <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;&#123;<span class="number">0b0110</span>&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********结果********/</span></span><br><span class="line"><span class="number">0111</span></span><br></pre></td></tr></table></figure><blockquote><p>也可进行多个表达式的运算，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0 1 1 1 OR</span><br><span class="line">0 0 1 1 OR</span><br><span class="line">0 0 0 1</span><br><span class="line">--------</span><br><span class="line">0 1 1 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;只要对应的列有1，它的结果中对应的那一列就是1</span><br></pre></td></tr></table></figure><p>它写成程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (<span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;&#123; <span class="number">0b0111</span> &#125; | <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;&#123; <span class="number">0b0011</span> &#125; | <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;&#123; <span class="number">0b0001</span> &#125;);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********结果*********/</span></span><br><span class="line"><span class="number">0111</span></span><br></pre></td></tr></table></figure></blockquote></li></ul><hr><ul><li><p><strong>位操作：AND <code>&amp;</code></strong></p><p>它的形式为：<code>0b0101 &amp; 0b0110</code>,更加直观的形式（也可以有多个表达式一起运算）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 1 0 1 AND</span><br><span class="line">0 1 1 0</span><br><span class="line">--------</span><br><span class="line">0 1 0 0</span><br></pre></td></tr></table></figure><blockquote><p>每一列中只有全部为1时，结果中对应的列才是1.</p></blockquote><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (<span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;&#123; <span class="number">0b0001</span> &#125; &amp; <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;&#123; <span class="number">0b0011</span> &#125; &amp; <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;&#123; <span class="number">0b0111</span> &#125;);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直观的表示为：</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> AND</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> AND</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">--------  <span class="comment">//结果为</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>位操作：XOR <code>^</code></strong></p><p>它的形式为：<code>0b0001 ^ 0b0011 ^ 0b0111</code></p><p>更加直观的看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 1 XOR</span><br><span class="line">0 0 1 1 XOR</span><br><span class="line">0 1 1 1</span><br><span class="line">--------</span><br><span class="line">0 1 0 1</span><br></pre></td></tr></table></figure><blockquote><p>每一列如果有<strong>奇数个1</strong>，则结果中对应的列就是1；否则就是0.</p></blockquote></li></ul><hr><ul><li><p><strong>位的赋值操作符</strong></p><p>与算术赋值运算符相似，C++提供位的赋值操作符，为了方便修改变量：</p><table><thead><tr><th align="left">Operator</th><th align="left">Symbol</th><th align="left">Form</th><th align="left">Operation</th></tr></thead><tbody><tr><td align="left">Left shift assignment</td><td align="left">&lt;&lt;=</td><td align="left">x &lt;&lt;= y</td><td align="left">Shift x left by y bits</td></tr><tr><td align="left">Right shift assignment</td><td align="left">&gt;&gt;=</td><td align="left">x &gt;&gt;= y</td><td align="left">Shift x right by y bits</td></tr><tr><td align="left">Bitwise OR assignment</td><td align="left">|=</td><td align="left">x |= y</td><td align="left">Assign x | y to x</td></tr><tr><td align="left">Bitwise AND assignment</td><td align="left">&amp;=</td><td align="left">x &amp;= y</td><td align="left">Assign x &amp; y to x</td></tr><tr><td align="left">Bitwise XOR assignment</td><td align="left">^=</td><td align="left">x ^= y</td><td align="left">Assign x ^ y to x</td></tr></tbody></table><p>比如，<code>x= x&gt;&gt;1</code>，可以写成：<code>x&gt;&gt;=1</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;4&gt; bits&#123;<span class="number">0b0100</span>&#125;;</span><br><span class="line">    bits &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; bits;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果*********/</span></span><br><span class="line"><span class="number">0010</span></span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>总结：</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnCpp chapter5</title>
      <link href="/archives/b6a3dbf1.html"/>
      <url>/archives/b6a3dbf1.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapter5</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h2 id="5-1-操作符优先级-amp-结合律"><a href="#5-1-操作符优先级-amp-结合律" class="headerlink" title="5.1 操作符优先级 &amp; 结合律"></a>5.1 操作符优先级 &amp; 结合律</h2><center>Operator precedence and associativity</center><p>下面是<strong>操作符的优先级 及 结合律</strong></p><blockquote><p>【note】</p><ol><li>下面表格的操作符优先级：<strong>level 1是最高优先级；level 17 优先级最低</strong></li><li>结合律：<ul><li><strong>L-&gt;R</strong>：即，从左向右结合</li><li><strong>R-&gt;L</strong> ：即。从右向左结合</li></ul></li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter5/image-20200403103620634.png" alt="1~8 level"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter5/image-20200403103654067.png" alt="9~17 level"></p><hr><p>注意一个<strong>连等号到表达式</strong>：</p><p><strong><code>x=y=z;</code>由上表可知，该表达式其实是这样的：<code>x=(y=z);</code></strong></p><hr><h2 id="5-2-算数运算符"><a href="#5-2-算数运算符" class="headerlink" title="5.2 算数运算符"></a>5.2 算数运算符</h2><center>Arithmetic operators</center><ul><li><p><strong>一元操作符(<em>Unary arithmetic operators</em></strong>)：<strong><code>+</code>、<code>-</code>：</strong></p><blockquote><p><strong>unary minus</strong>：返回 操作数乘以-1 之后的值。</p><p><strong>unary plus</strong>：返回 操作数本身。</p><p>这两个操作符都应该放在操作数的前面(e.g. -x , 而不是 - x)</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter5/image-20200403130245848.png" alt="一元操作符 + -"></p><p>eg: <code>x=5 - -3;</code>.第一个减号表示二元操作符，减法；第二个减号表示一元操作符。</p></li></ul><hr><ul><li><p><strong>二元运算符：<em>Binary arithmetic operators</em></strong></p><p>二元操作符有左、右 两个<strong>操作数(operand)</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter5/image-20200403130913816.png" alt="二元操作符"></p></li></ul><hr><ul><li><p><strong>整数与浮点数 的除法</strong></p><ol><li><p>左右两个操作数<strong>至少有一个是 浮点型值</strong>，它们的运算结果依然是一个浮点型的值。</p><blockquote><p>For example, <code>7.0 / 4 = 1.75</code>, <code>7 / 4.0 = 1.75</code>、<code>7.0 / 4.0 = 1.75</code></p></blockquote></li><li><p>做有<strong>两个操作数均为 整型值</strong>，它的运算结果依然是 整型值。</p><blockquote><p>For example, <code>7 / 4 = 1</code></p></blockquote></li></ol></li></ul><hr><ul><li><p><strong>用<code>static_cast&lt;&gt;</code>对整数进行浮点除法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123;<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> y&#123;<span class="number">4</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"int/int="</span>&lt;&lt;x/y&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"double / int = "</span>&lt;&lt;<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(x)/y&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"int / double = "</span>&lt;&lt;x/ <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(y)&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"double / double = "</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(x) / <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(y)&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****结果*****/</span></span><br><span class="line"><span class="keyword">int</span> / <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">double</span> / <span class="keyword">int</span> = <span class="number">1.75</span></span><br><span class="line"><span class="keyword">int</span> / <span class="keyword">double</span> = <span class="number">1.75</span></span><br><span class="line"><span class="keyword">double</span> / <span class="keyword">double</span> = <span class="number">1.75</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>除以<code>0</code></strong></p><p>如果除以0(或者 0.0)将会使程序崩溃。因为这个结果在数学中是没有定义的。</p></li></ul><hr><ul><li><p><strong>赋值操作符</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter5/image-20200403133616428.png" alt="赋值操作符"></p></li></ul><hr><h2 id="5-3-取模-amp-幂运算"><a href="#5-3-取模-amp-幂运算" class="headerlink" title="5.3 取模 &amp; 幂运算"></a>5.3 取模 &amp; 幂运算</h2><ul><li><p><strong>取模操作符：The modulus operator</strong></p><p><strong><em>取模操作符*，又称 *取余操作符</em></strong>。</p><blockquote><p>【note】：<u><strong>取余运算结果的符号，只和第一个操作数相一致。</strong></u></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123; <span class="number">6</span> &#125;, y&#123; <span class="number">-4</span> &#125;; <span class="comment">//第一个操作数符号为 正</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x%y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> z&#123; <span class="number">-6</span> &#125;, w&#123; <span class="number">4</span> &#125;; <span class="comment">//第一个操作数符号为 负</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; z%w ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="built_in">std</span>::numeric_limits &lt;<span class="built_in">std</span>::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span> );</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter5/image-20200403134914381.png" alt="取余结果的符号与“被除数”的符号相同"></p></blockquote></li></ul><hr><ul><li><p><strong>幂运算符<code>^</code></strong></p><p>您将注意到<code>^</code>运算符(在数学中通常用于表示求幂)是c++中的位<strong>XOR操作</strong>。在C++中不包含“幂运算操作符”。如果要用，就需要加上<strong>头文件<code>cmath</code></strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">double</span> x&#123; <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">3.0</span>, <span class="number">4.0</span>)&#125;; <span class="comment">//3 to the 4th power(3的4次方)</span></span><br></pre></td></tr></table></figure><blockquote><p>【Note】注意，<strong>pow()函数的参数(和返回值)是double类型的</strong>。所以，就算传入的是整数类型的，它的计算还是会有误差的(因为浮点数计算本身就会有误差)</p></blockquote><hr><p>所以，如果你想对整数进行幂运算，可以自己设计函数，使其结果比较精确：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt; //for std::int_fast64_t</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//note: exp(幂数) 不能是负数[因为用的是while循环]</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="keyword">int_fast64_t</span> <span class="title">powint</span> <span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> <span class="built_in">exp</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">int_fast64_t</span> result &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">exp</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">exp</span> &amp; <span class="number">1</span>)</span><br><span class="line">            result *= base;</span><br><span class="line">        <span class="built_in">exp</span> &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        base *= base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;powint(<span class="number">7</span>,<span class="number">12</span>); <span class="comment">//7的12次幂</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="5-4-递增-递减操作符"><a href="#5-4-递增-递减操作符" class="headerlink" title="5.4 递增/递减操作符"></a>5.4 递增/递减操作符</h2><table><thead><tr><th align="left">Operator</th><th align="left">Symbol</th><th align="left">Form</th><th align="left">Operation</th></tr></thead><tbody><tr><td align="left">Prefix increment (pre-increment)</td><td align="left">++</td><td align="left">++x</td><td align="left">Increment x, then return x</td></tr><tr><td align="left">Prefix decrement (pre-decrement)</td><td align="left">––</td><td align="left">––x</td><td align="left">Decrement x, then return x</td></tr><tr><td align="left">Postfix increment (post-increment)</td><td align="left">++</td><td align="left">x++</td><td align="left">Copy x, then increment x, then return the copy</td></tr><tr><td align="left">Postfix decrement (post-decrement)</td><td align="left">––</td><td align="left">x––</td><td align="left">Copy x, then decrement x, then return the copy</td></tr></tbody></table><hr><ul><li><p><strong>副作用：side effects</strong></p><center>c++不定义函数参数或操作符操作数的求值顺序。</center><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> x+y;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123;<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> valude = add(x, ++x); <span class="comment">//结果是5+6,还是6+6?</span></span><br><span class="line">    <span class="comment">//这取决于编译器计算函数参数的顺序</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;value; <span class="comment">// value could be 11 or 12, depending on how the above line evaluates!</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>【副作用】：<strong>c++没有定义函数参数求值的顺序。</strong></p><p>这种就会产生不确定性，因为还要<strong>取决于编译器对函数的参数计算的顺序</strong>。所以，不同的编译器可能会产生不同的结果。</p><p>所以，结果可能为：11 或者 12</p></blockquote></li></ul><hr><h2 id="5-5-逗号“-”-amp-条件-运算符"><a href="#5-5-逗号“-”-amp-条件-运算符" class="headerlink" title="5.5 逗号“,” &amp; 条件 运算符"></a>5.5 逗号“<code>,</code>” &amp; 条件 运算符</h2><h3 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h3><center>逗号操作符适用于for循环，其他情况不推荐用</center><table><thead><tr><th align="left">Operator</th><th align="left">Symbol</th><th align="left">Form</th><th align="left">Operation</th></tr></thead><tbody><tr><td align="left">Comma</td><td align="left">,</td><td align="left">x, y</td><td align="left">Evaluate x then y, returns value of y</td></tr></tbody></table><p><strong>comma operator (,)</strong>：允许您在允许单个表达式的情况下计算多个表达式的值。<strong>逗号运算符对左操作数求值，然后对右操作数求值，<u>然后返回右操作数的结果</u></strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> y&#123;<span class="number">2</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; (++x, ++y); <span class="comment">//先计算左操作符，在计算右操作符，但是返回右操作符的结果</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******结果**********/</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><hr><ul><li><p><strong>逗号操作符是所有操作符中最低的</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">z = (a,b); <span class="comment">//计算(a,b)，然后将返回的结果赋值给z</span></span><br><span class="line">z = a , b; <span class="comment">//由于“=”操作符优先于“,”操作符，所以，先计算“z=a”;然后在计算b，计算完之后，b没用就被抛弃了</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>逗号用作分隔符时，它此时代表的不是操作符</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// Comma used to separate parameters in function definition</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    add(x, y); <span class="comment">// Comma used to separate arguments in function call</span></span><br><span class="line">    int z(3), w(5); // Comma used to separate multiple variables being defined on the same line (don't do this)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h3><p>条件操作符是一个 <strong>三元操作符</strong></p><table><thead><tr><th align="left">Operator</th><th align="left">Symbol</th><th align="left">Form</th><th align="left">Operation</th></tr></thead><tbody><tr><td align="left">Conditional</td><td align="left">? :</td><td align="left">c ? x : y</td><td align="left">If c is nonzero (true) then evaluate x, otherwise evaluate y</td></tr></tbody></table><p>形式：<code>(condition) ? expression1 : expression2;</code></p><blockquote><p>当<code>condition</code>的结果是正确的(或者非零数字)，就执行<code>expression1</code>，否则，执行<code>expression2</code></p></blockquote><hr><ul><li><p><strong>由于条件操作符优先级较低，有时需要括号</strong></p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (x&gt;y) ? x : y;</span><br><span class="line"><span class="comment">//由于“&lt;&lt;”的优先级高于“条件操作符”,所以，等同于以下形式：</span></span><br><span class="line">(<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (x&gt;y)) ? x : y;</span><br><span class="line"><span class="comment">//想要按照我们设计的正确执行，则需要适当加上括号</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;((x&gt;y) ? x : y);</span><br></pre></td></tr></table></figure></li></ul><hr><p>【注意】与在函数内部定义的变量在函数结束时死亡非常相似，在if或else语句中定义的变量在if或else语句结束时死亡。因此，在我们试图打印它时，类大小已经被破坏了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> inBigClassroom &#123; <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (inBigClassroom)</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> classSize &#123; <span class="number">30</span> &#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> classSize &#123; <span class="number">20</span> &#125;;</span><br><span class="line">    <span class="comment">//此时，if/else已经执行结束，所以，其内部定义的变量classSize也已经被销毁</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The class size is: "</span> &lt;&lt; classSize; <span class="comment">//因为classSize被销毁，所以会编译出错</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li><p><strong>条件编译的两个表达式的类型</strong></p><p>条件编译的两个表达式，<strong>要么具有相同的类型</strong>；<strong>要么第二个表达式的类型可以转化为第一个表达式的类型</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (x != <span class="number">5</span> ? x : <span class="string">"x is 5"</span>); <span class="comment">// won't compile</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为，表达式1：x 是integer 类型；表达式2："x is 5"是string类型。所以表达式2要转换为表达式1的类型，但是转换失败。所以编译就不成功</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="5-6-关系运算符-amp-浮点数的比较"><a href="#5-6-关系运算符-amp-浮点数的比较" class="headerlink" title="5.6 关系运算符 &amp; 浮点数的比较"></a>5.6 关系运算符 &amp; 浮点数的比较</h2><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><table><thead><tr><th align="left">Operator</th><th align="left">Symbol</th><th align="left">Form</th><th align="left">Operation</th></tr></thead><tbody><tr><td align="left">Greater than</td><td align="left">&gt;</td><td align="left">x &gt; y</td><td align="left">true if x is greater than y, false otherwise</td></tr><tr><td align="left">Less than</td><td align="left">&lt;</td><td align="left">x &lt; y</td><td align="left">true if x is less than y, false otherwise</td></tr><tr><td align="left">Greater than or equals</td><td align="left">&gt;=</td><td align="left">x &gt;= y</td><td align="left">true if x is greater than or equal to y, false otherwise</td></tr><tr><td align="left">Less than or equals</td><td align="left">&lt;=</td><td align="left">x &lt;= y</td><td align="left">true if x is less than or equal to y, false otherwise</td></tr><tr><td align="left">Equality</td><td align="left">==</td><td align="left">x == y</td><td align="left">true if x equals y, false otherwise</td></tr><tr><td align="left">Inequality</td><td align="left">!=</td><td align="left">x != y</td><td align="left">true if x does not equal y, false otherwise</td></tr></tbody></table><blockquote><p>这些操作符的值分别为布尔值true(1)和false(0)。</p></blockquote><hr><h3 id="浮点数的比较"><a href="#浮点数的比较" class="headerlink" title="浮点数的比较"></a>浮点数的比较</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d1&#123; <span class="number">100.0</span> - <span class="number">99.99</span> &#125;; <span class="comment">// should equal 0.01 ?</span></span><br><span class="line">    <span class="keyword">double</span> d2&#123; <span class="number">10.0</span> - <span class="number">9.99</span> &#125;; <span class="comment">// should equal 0.01 ?</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (d1 == d2)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"d1 == d2"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (d1 &gt; d2)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"d1 &gt; d2"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (d1 &lt; d2)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"d1 &lt; d2"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****结果*****/</span></span><br><span class="line">d1 &gt; d2</span><br></pre></td></tr></table></figure><p>我们可以看到，在我们的调试模式下，d1 = 0.0100000000000005116 而 d2 = 0.0099999999999997868.</p><blockquote><p>【Note】：在两个浮点数非常接近时，如果使用<code>==</code>和<code>!=</code>对浮点数之间比较，结果会不太准确。</p></blockquote><hr><ul><li><p><strong>使用<code>epsilon</code>准确比较浮点数</strong></p><p>我们可以使用<code>epsilon</code>来相对准确的比较两个 足够接近的 浮点型数值。</p><blockquote><p><code>epsilon</code>：通常被定义为一个小的正数(如，0.00000001，即1e-8)</p></blockquote><p>现在，我们来比较两个”close enough”的浮点数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; //for std::abs()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//epsilon is an absolute value</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isAlmostEqual</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> epsilon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//if the distance between a and b is less than epsilon, then a and b are "close enough"</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">abs</span>(a-b) &lt;= epsilon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这个函数可以工作，但它不是很好。0.00001的epsilon值对于1.0左右的输入是合适的，对于0.0000001左右的输入是太大了，对于10,000这样的输入是太小了。这意味着每次我们调用这个函数时，我们必须选择一个适合我们输入的。如果我们知道我们要根据输入的比例来缩放，我们也可以修改函数来做到这一点。</p><p><strong>改进1：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; //std::abs</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; //std::max</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//return true if the difference between a and b is within epsilon</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">approximatelyEqual</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b, <span class="keyword">double</span> epsilon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(a-b) &lt;= ( <span class="built_in">std</span>::<span class="built_in">max</span>( <span class="built_in">std</span>::<span class="built_in">abs</span>(a),<span class="built_in">std</span>::<span class="built_in">abs</span>(b) ) * epsilon ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这种情况下，<code>epsilon</code>不再是一个绝对值，<strong>现在是相对于a或b大小的量级</strong>。</p></blockquote><p><strong>再改进2【推荐】</strong>：</p><p><strong>当浮点数足够接近于0时</strong>，上面的方法还是不太行的。</p><blockquote><p>改进方法就是：<strong>同时使用相对值和绝对值</strong>：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return true if the difference between a and b is less than absEpsilon, or within relEpsilon percent of the larger of a and b</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">approximatelyEqualAbsRel</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> absEpsilon, <span class="keyword">double</span> relEpsilon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Check if the numbers are really close -- needed when comparing numbers near zero.</span></span><br><span class="line">    <span class="keyword">double</span> diff&#123; <span class="built_in">std</span>::<span class="built_in">abs</span>(a - b) &#125;;</span><br><span class="line">    <span class="keyword">if</span> (diff &lt;= absEpsilon)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Otherwise fall back to Knuth's algorithm(相对值方法，即“改进1”的方法)</span></span><br><span class="line">    <span class="keyword">return</span> (diff &lt;= (<span class="built_in">std</span>::<span class="built_in">max</span>(<span class="built_in">std</span>::<span class="built_in">abs</span>(a), <span class="built_in">std</span>::<span class="built_in">abs</span>(b)) * relEpsilon));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这个算法中，我们首先检查a和b在绝对值上是否接近，这处理了a和b都接近于零的情况。<strong>absEpsilon参数应该设置为非常小的值(例如1e-12)</strong>。如果失败了，我们就回到Knuth的算法，即，使用相对的epsilon。</p></blockquote></li></ul><p>完整的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; //std::max</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;     //std::abs</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果a和b之间的差值在a和b之间较大值的百分之几内，则返回true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">approximatelyEqual</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b,<span class="keyword">double</span> epsilon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(a-b) &lt;= (<span class="built_in">std</span>::<span class="built_in">max</span>(<span class="built_in">std</span>::<span class="built_in">abs</span>(a), <span class="built_in">std</span>::<span class="built_in">abs</span>(b)) * epsilon ));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//针对于接近于0 的浮点数的比较</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">approximatelyEqualAbsRel</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b,<span class="keyword">double</span> absEpsilon, <span class="keyword">double</span> relEspilon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//check if the numbers are really close -- need when comparing numbers near zero.</span></span><br><span class="line">    <span class="keyword">double</span> diff &#123;<span class="built_in">std</span>::<span class="built_in">abs</span>(a-b)&#125;;</span><br><span class="line">    <span class="keyword">if</span> (diff &lt;= absEpsilon)</span><br><span class="line">        <span class="keyword">return</span> ture;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//otherwise fall back to 相对值法</span></span><br><span class="line">    <span class="keyword">return</span> (diff &lt;= (<span class="built_in">std</span>::<span class="built_in">max</span>(<span class="built_in">std</span>::<span class="built_in">abs</span>(a), <span class="built_in">std</span>::<span class="built_in">abs</span>(b)) * relEspilon));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//a is really close to 1.0, but has rounding errors</span></span><br><span class="line">    <span class="keyword">double</span> a&#123;<span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; approximatelyEqual(a, <span class="number">1.0</span>, <span class="number">1e-8</span>);<span class="comment">//compare "almost 1.0" to 1.0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; approximatelyEqual(a<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">1e-8</span>); <span class="comment">//compare "almost 0.0" to 0.0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; approximatelyEqualAbsRel(a<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">1e-12</span>, <span class="number">1e-8</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// compare "almost 0.0" to 0.0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********结果*********/</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>可以看出，<strong>在对于接近于0的浮点数，与 0.0比较时。<code>approximatelyEqualAbsRel</code>要更加准确。</strong></p></blockquote><p><strong>使用<code>approximatelyEqualAbsRel</code>方法，就可以解决大多数情况</strong>。它也涵盖了<code>approximatelyEqual</code>函数的功能。</p><hr><h2 id="5-7-逻辑操作符"><a href="#5-7-逻辑操作符" class="headerlink" title="5.7 逻辑操作符"></a>5.7 逻辑操作符</h2><table><thead><tr><th align="left">Operator</th><th align="left">Symbol</th><th align="left">Form</th><th align="left">Operation</th></tr></thead><tbody><tr><td align="left">Logical NOT</td><td align="left">!</td><td align="left">!x</td><td align="left">true if x is false, or false if x is true</td></tr><tr><td align="left">Logical AND</td><td align="left">&amp;&amp;</td><td align="left">x &amp;&amp; y</td><td align="left">true if both x and y are true, false otherwise</td></tr><tr><td align="left">Logical OR</td><td align="left">||</td><td align="left">x || y</td><td align="left">true if either x or y are true, false otherwise</td></tr></tbody></table><hr><ul><li><p><strong>NOT：！</strong></p><p>需要注意的是，<strong>NOT 操作符的优先级很高，在level 3</strong>。所以，你很有可能会犯这种错误：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123;<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> y&#123;<span class="number">7</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!x&gt;y) <span class="comment">//正确写法：if (!(x&gt;y))</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x is not greater than y\n"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x is equal to or greater than y\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果************/</span></span><br><span class="line">x is equal to <span class="keyword">or</span> greater than y</span><br></pre></td></tr></table></figure><p>可以看出，结果不正确。在这里就是因为，<code>if(!x&gt;y)</code>中，由于<code>!</code>优先级高于<code>&gt;</code>。所以，先计算“!x”，其实，就相当于：<code>if ( (!x) &gt; y )</code></p></li></ul><hr><ul><li><p><strong>AND： &amp;&amp;</strong></p><ul><li><p>如果逻辑操作符<code>&amp;&amp;</code>要返回“true”，那么所有的操作数都必须是‘true’；</p></li><li><p>但如果<code>&amp;&amp;</code>返回是“false”，只要有一个操作数是‘false’即可。</p><blockquote><p>特殊的，如果第一个操作数是‘false’的话，就不会再继续看后面操作符是‘false’还是‘true’，即图签终止了。这种情况叫做：“<strong>short circuit evaluation</strong>”</p></blockquote></li></ul><p>相似的，逻辑操作符 或<code>||</code>，如果要返回“true”的话，也是只要有一个操作数是‘true’即可。</p></li></ul><hr><blockquote><p><strong>逻辑操作符<code>&amp;&amp;</code>的优先级高于<code>||</code></strong>，所以，在使用如：<code>value1 || value2 &amp;&amp; value3</code>时，要更加小心，<strong>使用括号才会更加安全</strong>。</p></blockquote><hr><ul><li><p><strong>德摩根定律：De Morgan’s law</strong></p><p>德摩根定律告诉我们，可以这样使用逻辑操作符<code>!</code>：</p><p><code>!(x &amp;&amp; y)</code> 等同于 <code>!x || !y</code></p><p><code>!(x || y)</code>等同于 <code>!x &amp;&amp; !y</code></p><blockquote><p>换句话说，当您分发逻辑NOT时，您还需要转换为逻辑AND逻辑OR，反之亦然!</p></blockquote></li></ul><hr><ul><li><p><strong>逻辑操作符，异或<code>XOR</code></strong></p><table><thead><tr><th align="left">Left operand</th><th align="left">Right operand</th><th align="left">Result</th></tr></thead><tbody><tr><td align="left">false</td><td align="left">false</td><td align="left">false</td></tr><tr><td align="left">false</td><td align="left">true</td><td align="left">true</td></tr><tr><td align="left">true</td><td align="left">false</td><td align="left">true</td></tr><tr><td align="left">true</td><td align="left">true</td><td align="left">false</td></tr></tbody></table></li></ul><blockquote><p>即，<strong>真假 为 真</strong>，<strong>其他结果都是 假</strong></p></blockquote><p>C++没有提供专门提供 异或操作符，但是我们可以使用：</p><ol><li><p><strong>当操作数是布尔型</strong>的，即true，false，而不是integer，可以使用<code>!=</code>来实现异或：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a != b) <span class="comment">//a XOR b ,假定a、b是booleans</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="comment">//多个操作数</span></span><br><span class="line"><span class="keyword">if</span> (a != b != c != d)  <span class="comment">// a XOR b XOR c XOR d, assuming a, b, c, and d are Booleans</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li><li><p><strong>当操作数不是布尔型</strong>时，<strong>使用<code>static_cast</code>转化为bool</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(a) != <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(b) != <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(c)) <span class="comment">// a XOR b XOR c XOR d, for any type that can be converted to bool</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机科学速成课(总)</title>
      <link href="/archives/3ae1bc73.html"/>
      <url>/archives/3ae1bc73.html</url>
      
        <content type="html"><![CDATA[<center><red>计算机科学速成课</red></center><a id="more"></a><h1 id="参考文章-："><a href="#参考文章-：" class="headerlink" title="###参考文章###："></a>###参考文章###：</h1><p>*<em>计算机科学速成课 *</em>：</p><p>笔记：<a href="https://www.cnblogs.com/livil/p/10155073.html" target="_blank" rel="noopener">https://www.cnblogs.com/livil/p/10155073.html</a> 和<a href="https://zhuanlan.zhihu.com/p/103505933" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/103505933</a> 或 <a href="https://www.imooc.com/article/271502" target="_blank" rel="noopener">https://www.imooc.com/article/271502</a></p><p>字幕：<a href="https://github.com/1c7/Crash-Course-Computer-Science-Chinese/blob/master/(字幕)全40集中英字幕文本" target="_blank" rel="noopener">https://github.com/1c7/Crash-Course-Computer-Science-Chinese/blob/master/(字幕)全40集中英字幕文本</a></p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/5c2dbf8e0001443913279329.jpg" alt="5c2dbf8e0001443913279329" style="zoom:150%"><h1 id="2、电子计算机"><a href="#2、电子计算机" class="headerlink" title="2、电子计算机"></a>2、电子计算机</h1><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/1528749-20181221121908992-643367848.png" alt="img" style="zoom:200%"><h1 id="3、布尔逻辑和逻辑门"><a href="#3、布尔逻辑和逻辑门" class="headerlink" title="3、布尔逻辑和逻辑门"></a>3、布尔逻辑和逻辑门</h1><p>计算机最早是机电设备，一般用十进制计数。也有一些是三进制、五进制的。【也就是x进制表示有x种状态。】</p><p>二进制中的 1或0 叫做：位（bit）；1字节（byte）=8位(bits)</p><h1 id="5、算数逻辑单元（ALU）"><a href="#5、算数逻辑单元（ALU）" class="headerlink" title="5、算数逻辑单元（ALU）"></a>5、算数逻辑单元（ALU）</h1><p>：是计算机的数学大脑，是计算机里负责运算的组件。</p><blockquote><p>ALU有2个单元：1个<strong>算数单元</strong>和1个<strong>逻辑单元</strong>。</p><p>算数单元：负责计算机里的所有数字操作。如加减法。</p></blockquote><h2 id="1）算数单元"><a href="#1）算数单元" class="headerlink" title="1）算数单元"></a>1）算数单元</h2><h3 id="半加器-A-half-adder"><a href="#半加器-A-half-adder" class="headerlink" title="(半加器)A half adder:"></a>(半加器)A half adder:</h3><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200220151049446.png" alt="image-20200220151049446" style="zoom:150%"><p>半加器如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200211204327584.png" alt="image-20200211204327584"></p><p>将其抽象化，把“把假期”封装成一个单独组件：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200211204510442.png" alt="image-20200211204510442"></p><h3 id="全加器（Full-Adder）"><a href="#全加器（Full-Adder）" class="headerlink" title="全加器（Full Adder）:"></a>全加器（Full Adder）:</h3><p>如果想要处理多位二进制数加法时，就需要<strong>全加器（Full Adder）</strong>，因为半加器计算完当前位的结果后，会输出进位，意味着计算下一位的结果时，要将两个输入以及前一位的进位相加。我们可以得到<strong>全加器</strong>的真值表：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-f41514f0f20020dd462462f3d58bbcc4_r.jpg" alt="preview"></p><center>全加器真值表</center>![image-20200211205005097](https://longlongqin.gitee.io/image_save/images/assets/image-20200211205005097.png)<p>我们这里可以使用半加器来实现全加器。我们可以将一个半加器结果当做是INPUT A 和INPUT B相加后的结果，然后将SUM当做是新的INPUT A，而PRE CARRY当做是新的INPUT B输入到新的半加器中，可以发现其SUM结果和全加器SUM结果相同。而全加器的CARRY只要对这两个半加器的CARRY进行OR运算就可以了。（<strong>注意：</strong>这两个半加器不会同时出现进位）</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-cd2bf02b43475d66ab37e88a47df4eb2_hd.jpg" alt="img"></p><p>同样我们也可以对全加器进行抽象，得到一个包含三个输入和两个输出的独立部件。</p><p>由此我们可以进行两个8位数字相加，表示为A和B:</p><ol><li>对A和B的第一位进行相加时，由于不存在进位，所以值使用一个半加器就能实现，这个半加器的SUM就为该位的结果，CARRY就为进位。</li><li>后续的7位二进制相加，由于每一个都涉及了上一位的进位，所以后续需要7个全加器，并且每个全加器的CARRY要连接到下一个全加器的输入，而每个全加器的SUM就为该位的结果。</li><li>最后一个全加器有CARRY的输出，如果该CARRY为1，就表示相加结果太大了，超出了8位，所以出现了<strong>溢出（overflow）</strong>【<strong>溢出：</strong>一般来说 “溢出” 的意思是, 两个数字的和太大了，超过了用来表示的位数，这会导致错误和不可预期的结果。】。</li></ol><p>由此，我们就构建出了一个<strong>8位加法器（8-bit adder）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-232e40f98a8adcf998b256bfe5c52bae_hd.jpg" alt="img"></p><p>通过连接1个半加器和n-1个全加器，就能构建n位加法器。通过叠加更多的加法器，能够避免溢出的出现，但是会出现更多的逻辑门，而且每次进位都要一些时间，而计算是串行的，所以消耗的时间也越长，到如今的每秒几十亿次运算时就会造成影响，所以现代计算机用的加法电路有所不同，称为<strong>超前进位加法器（Carry-Look-Ahead Adder）。</strong></p><p><strong>ALU通常支持以下操作：</strong>加法、带进位的加法、减法、带借位的减法、取反、增1、减1、数字无改变通过。这些操作也是由逻辑门构成的。<strong>注意：</strong>简单的ALU并==不==支持乘法，而是把乘法用多次加法来实现，而更好的处理器有专门做乘法的算数单元。</p><h2 id="2）逻辑单元"><a href="#2）逻辑单元" class="headerlink" title="2）逻辑单元"></a>2）逻辑单元</h2><p><strong>逻辑单元：</strong>执行逻辑操作，比如AND、OR和NOT操作，也能做简单的数值测试，比如数字是不是负数。</p><p>对整个8位ALU进行抽象，用一个特殊的V形符号进行表示。其中有两个<strong>8位输入</strong>，并且有一个4位<strong>操作码（Operation Code）</strong>来告诉ALU对输入执行什么操作，比如1000表示加法命令，1100表示减法命令，然后有一个<strong>8位输出</strong>。同时ALU会输出一系列1位<strong>标志（FLAG）</strong>，来表示特定状态，比如我们可以计算A-B，然后通过ZERO来判断结果是否为零来判断A与B是否相等，通过NEGATIVE来判断A是否小于B；然后OVERFLOW连接到加法器的进位，来判断是否出现溢出。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-324be370be80687e69aeb12d8173dccd_hd.jpg" alt="img"></p><hr><h1 id="6、寄存器-amp-内存"><a href="#6、寄存器-amp-内存" class="headerlink" title="6、寄存器&amp;内存"></a>6、寄存器&amp;内存</h1><p>上节中介绍的ALU进行计算后得到的结果需要对其进行存储，可能还要进行多个连续操作，这就需要用到计算机内存了。计算机使用的是<strong>随机存取存储器（Random Access Memory, RAM）</strong>，其只能在<u>有电</u>的情况下存储东西。另一种存储称为<strong>持久存储（Persistent Memory）</strong>，电源关闭时数据也不会丢失，它用来存其他东西。</p><blockquote><p>随机存取存储器(RAM)：只能在有电的时候存储东西。【 <strong>内存</strong>的一个重要特性：可以随时访问任何位置。所以叫“<strong>随机存取存储器(RAM)</strong>”】</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213205406365.png" alt="image-20200213205406365"></p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212233032303.png" alt="image-20200212233032303">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212233049692.png" alt="image-20200212233049692">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212233107576.png" alt="image-20200212233107576"></p></blockquote><p>放入数据的动作叫“<strong>写入</strong>”，拿出数据的动作叫“<strong>读取</strong>”。</p><p>这一节中首先构建能够存储1位的存储器，然后对其扩展来得到内存模块。</p><p>之前构建的都是单向电路，我们同样可以构建回向电路，把输出连回输入。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-81c6dd82241ba3a7de60809922f4e8f7_hd.jpg" alt="img"></p><blockquote><p>1、当将OR门构建成回向电路时，可以分析其电路特性：</p><ul><li>A和B初始为0时，输出结果为0</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://pic1.zhimg.com/80/v2-3dd54ae2c78016bfd6eba69be1f34e98_hd.jpg" alt="img"></p><center>存储0的电路</center>- 将A修改为1时，输出结果为1，此时B的输入就变为了1。随后输出始终保持为1，不论A如何变化。<p>所以这个电路能够永久记录1，并且无法将1变回0。</p><p>2、同理可以分析下AND门构建成回向电路时的特点</p><ul><li><p>A和B初始化为1，则输出结果为1</p></li><li><p>将A修改为0时，输出结果为0，此时B的输入就变成了0。随后输入始终保持为0，无论A如何变化。</p></li></ul><p>所以这个电路能够永久记录0，并且无法将0变回1。</p></blockquote><p>所以我们就得到了能够存储1和0的电路，为了得到有用的Memory，需要将两个电路结合起来，可以得到<strong>AND-OR锁存器（AND-OR Latch）</strong>，上方的是SET输入，下方的是RESET输入，当SET=1、RESET=0，就能将输出设置为1，当RESET=1，就能将输出设置为0，当SET=0、RESET=0，则输出最后放入的内容。由此能够存储1位的信息（该信息存储在OR门上方的输入电极中）！</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200220160959766.png" alt="image-20200220160959766"></p><p>这叫”锁存”, 因为它”锁定”了一个值，放入数据的动作叫 “写入” ，拿出数据的动作叫 “读取”。</p><p>对其进行SET和RESET进行合并，并添加其他门控单元，可以得到一个<strong>门锁（GATE LATCH）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212230438229.png" alt="image-20200212230438229"></p><center>门锁</center>其中DATE INPUT表示数据输入，WRITE ENABLE表示允许写入线，用来控制是否保存当前输入的数据。对这个电路进行分析。<p>可以将门锁进行<u>抽象</u>，得到一个能够存储<strong>一个bit</strong>的部件。当允许写入线为0时，输出保持不变，当允许写入线为1时，输出就是数据输入，并且能够将数据输入进行存储。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212230837936.png" alt="image-20200212230837936"></p><center>门锁的抽象</center>如果我们并排8个锁存器，就能存储8位信息。一组这样的锁存器称为**寄存器（Register）**，寄存器能够存一个数字，这个数字的位数称为寄存器的**位宽（Width）**。<p>写入寄存器之前，要先启动里面所有的锁存器，可以将所有锁存器的允许写入线都连接在一起，把它设为1，然后用8条数据线发送数据，然后将允许写入线设回0，就能将8位数据存储在寄存器中。</p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212231015481.png" alt="image-20200212231015481"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212231043071.png" alt="image-20200212231043071"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212231125590.png" alt="image-20200212231125590"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212231159981.png" alt="image-20200212231159981"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212231218808.png" alt="image-20200212231218808">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212231232434.png" alt="image-20200212231232434"></p></blockquote><h2 id="寄存器："><a href="#寄存器：" class="headerlink" title="寄存器："></a>寄存器：</h2><p>上面是只能存储1bit的“<strong>锁存器</strong>”，如果我们并排放8个锁存器，就可以存8位(bits)信息。</p><p>一组这样的锁存器叫做“<strong>寄存器</strong>”。</p><p>1、<strong>位宽</strong></p><p>寄存器能存一个数字，这个数字有多少位，叫做“<strong>位宽</strong>”。</p><p>$早期电脑用8位寄存器，然后是16位、32位。如今都有64位宽的寄存器。$</p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213201814518.png" alt="image-20200213201814518">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213201940951.png" alt="image-20200213201940951">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213202116937.png" alt="image-20200213202116937">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213202136340.png" alt="image-20200213202136340"></p><p>所以，如64位的寄存器只需要129条线就可以了。【64条是“数据输入线”、“64条数据输出线”、“一条启用写入线”】。</p><p>如果要存256位，就需要513条线。减少线数的方法就是：<strong>矩阵</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213202534237.png" alt="image-20200213202534237">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213202641868.png" alt="image-20200213202641868"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213202711027.png" alt="image-20200213202711027"></p><p>所以，对于一个256位的存储：只需要35条。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213202942105.png" alt="image-20200213202942105">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213203005839.png" alt="image-20200213203005839"></p><p>如果想要访问特定的锁存器（即寻找其地址），（由于行数和列数均只有16，所以均可以用4个二进制位来表示。）就有行号和列号来对应。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213203515940.png" alt="image-20200213203515940">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213203551017.png" alt="image-20200213203551017">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213203634252.png" alt="image-20200213203634252">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213203648070.png" alt="image-20200213203648070"></p><blockquote><p><strong>多路复用器</strong>：有不同大小。通常包含一定数目的数据输入，有一个单独的输出。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213203948627.png" alt="image-20200213203948627"></p></blockquote><p>把256位内存当成一个整体，抽象化一下：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204207689.png" alt="image-20200213204207689">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204308742.png" alt="image-20200213204308742">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204324322.png" alt="image-20200213204324322"></p><p>一个256位内存也不能做什么大事，所以继续扩大：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204433307.png" alt="image-20200213204433307">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204508271.png" alt="image-20200213204508271">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204556045.png" alt="image-20200213204556045">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204731314.png" alt="image-20200213204731314">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204837880.png" alt="image-20200213204837880"></p><p>再次，看成一个整体：</p><p>下图中：我们有256个地址，每个地址能读或写一个8位(bit)的值。<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204931499.png" alt="image-20200213204931499">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213205132085.png" alt="image-20200213205132085">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213205150693.png" alt="image-20200213205150693">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213205208450.png" alt="image-20200213205208450">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213205234980.png" alt="image-20200213205234980">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213205253990.png" alt="image-20200213205253990"></p></blockquote><p>这一节用锁存器做了一块<strong>静态随机存取存储器（Static Random-Access Memory，SRAM）</strong>，还有很多其他类型的RAM，比如DRAM、闪存和NVRAM，它们的功能和SRAM相似，但是使用不同的电路存放单个位。但是根本上，这些技术都是矩阵层层嵌套来存储大量信息。</p><h1 id="7、中央处理器-CPU"><a href="#7、中央处理器-CPU" class="headerlink" title="7、中央处理器(CPU)"></a>7、中央处理器(CPU)</h1><p>CPU负责执行程序，程序由一个个操作组成，这些操作叫“指令(instruction)”。</p><p>如果是<strong>数学指令</strong>，比如加减，CPU会让ALU进行数学运算。如果是<strong>内存指令</strong>，CPU会和内存通信，然后读写值。</p><h1 id="9、高级CPU设计"><a href="#9、高级CPU设计" class="headerlink" title="9、高级CPU设计"></a>9、高级CPU设计</h1><p>RAM是CPU之外的独立组件，意味着数据要用线来传递，这个线叫做“<strong>总线（BUS）</strong>”。</p><p>$总线可能只有几厘米，虽然电信号传输速度接近光速，但是CPU每秒可以处理上亿条指令，很小的延迟也会造成问题。$</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214194800104.png" alt="image-20200214194800104">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214195130456.png" alt="image-20200214195130456"></p><h2 id="提升性能方法一：缓存"><a href="#提升性能方法一：缓存" class="headerlink" title="提升性能方法一：缓存"></a>提升性能方法一：缓存</h2><p>一条“从内存读数据”的指令可能需要多个时钟周期，而此时CPU空等数据。解决延迟的方法之一是给CPU加一点RAM,叫：“<strong>缓存(Cache)</strong>”。因为处理器的空间不大，所以缓存一般只有KB或MB，而RAM都是GB起步。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214195534052.png" alt="image-20200214195534052"></p><p>缓存提高了速度：当CPU从RAM拿数据时，RAM不用传一个，可以传一批。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214195800275.png" alt="image-20200214195800275"></p><p>虽然花的时间多一点，但数据可以存在缓存。这很实用，因为数据常常是一个个按顺序处理。比如：算餐厅的当日收入时，先取RAM地址为100 的交易额，RAM与其只给一个值，不如直接给一批值，把地址为100~200的数据都复制到缓存中。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214200104046.png" alt="image-20200214200104046"></p><p>当处理器要下一个交易额（地址为101的）时，缓存就会告诉处理器：“我已经有这个数据了，现在就给你”。就不用再去RAM取数据了。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214200354398.png" alt="image-20200214200354398">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214200419065.png" alt="image-20200214200419065"></p><p>当想要的数据已经在缓存中时，这种状态叫“<strong>缓存命中</strong>（Cache Hit）”；如果不在，则叫“<strong>缓存未命中（Cache Miss）</strong>”。</p><p>缓存也可以当临时空间，存一些中间值，适合长的或者复杂的运算。继续餐馆的例子：假设CPU算完了一天的销售额，想把结果存到地址为150的地方。就像之前，数据不是直接存到RAM中，而是存在缓存中。这样不但存起来快一些、如果还要接着计算，取值也会快一些。</p><p>但是这会导致：缓存和RAM中的数据不一致。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214201154364.png" alt="image-20200214201154364"></p><p>因此缓存里每块空间有一个特殊标记，叫：“<strong>脏位（Dirty Bit）</strong>”。</p><p>同步一般发生在：当缓存满了而CPU又需要缓存的时候。在清理缓存腾出空间之前，会先检查“脏位”，如果是“脏”的话，在加载新内容之前，会把数据写回RAM。</p><p>![演示 (3)](<a href="https://longlongqin.gitee.io/image_save/images/assets/演示" target="_blank" rel="noopener">https://longlongqin.gitee.io/image_save/images/assets/演示</a> (3).gif)</p><h2 id="提升性能方法二：“指令流水线”"><a href="#提升性能方法二：“指令流水线”" class="headerlink" title="提升性能方法二：“指令流水线”"></a>提升性能方法二：“指令流水线”</h2><blockquote><p>指令流水线：instruction pipelining</p></blockquote><p>例如：如果你想要洗一整个的床单，但只有一个洗衣机和一个烘干机。</p><blockquote><p>选择一：按顺序，先放洗衣机洗30分钟，然后在烘干机30分钟。共计1小时。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214203334316.png" alt="image-20200214203334316"></p><p>选择二：像一中一样，先放一批床单到洗衣机30分钟，然后把它放到烘干机中。但是这时候要等30分钟才能烘干。此时，可以放另一批床单到 洗衣机（此时，洗衣机，烘干机在同时工作），依次，直到洗完所有床单。效率是一的2倍。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214203636909.png" alt="image-20200214203636909"></p></blockquote><p>处理器也可以这样设计，CPU是按顺序处理的：<strong>(读)取指(令)——&gt;解码——&gt;执行</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214203831692.png" alt="image-20200214203831692"></p><p>不断重复：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214203857837.png" alt="image-20200214203857837"></p><p>但是每个阶段都是用的CPU的不同部分，意味着可以并行处理：“执行”一个指令时，同时“解码”下一个指令，同时，“读取”下下条指令。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214204249010.png" alt="image-20200214204249010"></p><p>这样的流水线，每一个时钟周期执行1个指令，吞吐量乘3.</p><p>但是，和缓存一样，这也会带来一些问题：</p><blockquote><p>问题1：指令之间的依赖关系。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214204538900.png" alt="image-20200214204538900">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214204559995.png" alt="image-20200214204559995"></p><p>因此流水线处理器，要先弄清楚<em>数据依赖性</em>。必要时停止流水线，避免出问题。高端的CPU，会最小化流水线的停工时间，这叫“<strong>乱序执行</strong>”。</p><p>问题二：“条件跳转”，比如之前的JUMP NEGATIVE（类似循环跳转）。这些指令会改变程序的执行流。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205017629.png" alt="image-20200214205017629">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205037500.png" alt="image-20200214205037500"></p><p>空等会造成延迟。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205050629.png" alt="image-20200214205050629"></p><p>​ 技巧：“<strong>推测执行</strong>”</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205158772.png" alt="image-20200214205158772">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205214800.png" alt="image-20200214205214800">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205239401.png" alt="image-20200214205239401"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205303755.png" alt="image-20200214205303755">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205314350.png" alt="image-20200214205314350">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205323242.png" alt="image-20200214205323242">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205340699.png" alt="image-20200214205340699"></p><p>为了尽可能减少清空流水线的次数，CPU厂商开发复杂的方法：“<strong>分支预测</strong>”。现在这种猜测的正确率超过90%。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205504704.png" alt="image-20200214205504704"></p><p>在理想情况下，CPU在一个时钟周期完成一个指令。但是“<strong>超标量处理器</strong>”的出现，一个时钟周期可以完成多个指令。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205918942.png" alt="image-20200214205918942"></p><p>用“<strong>多核处理器</strong>”【双核、四核处理器：意思是一个CPU芯片里，有多个独立的处理单元，”看起来就像有多个独立的CPU”。但因为他们整合紧密，可以共享一些资源如，缓存，使得多核可以合作运算。】。当多核不够时，可以用多个CPU。</p></blockquote><h1 id="10、早期的计算机编程"><a href="#10、早期的计算机编程" class="headerlink" title="10、早期的计算机编程"></a>10、早期的计算机编程</h1><p>​ 之前的程序是用<strong>插线板</strong>编程，到后来（1940年代晚期到1950年代初）<strong>内存</strong>的价格下降，容量上升，使得程序存入内存变得可行。程序存入内存中易于修改、方便CPU快速读取，这类机器叫做：“<strong>存储程序计算机（Stored-program Computers）</strong>”。内存足够时，还可以存储程序需要的数据（包括运行时产生的数据）。这种将程序和数据存储在一起的存储结构，叫“<strong>冯诺依曼结构</strong>”。</p><p>​ 冯诺依曼计算机的标志是，一个处理器（有算数逻辑单元）+数据寄存器+指令寄存器+指令地址寄存器+内存（负责存数据和指令）。</p><h1 id="11、编程语言发展史"><a href="#11、编程语言发展史" class="headerlink" title="11、编程语言发展史"></a>11、编程语言发展史</h1><p>​ 计算机只能处理二进制，其实，“<strong>机器语言（Machine Language）</strong>”或“<strong>机器码（Machine Code）</strong>”。在计算机早起，还必须要用机器码 些好吃呢供需，一般会先对程序进行高层次的功能描述，称为“<strong>伪代码（Pseudo-code）</strong>”，只是助于程序员理解无法让计算机运行，然后根据指令表将伪代码转换成二进制机器码，然后将机器码送入计算机中运行。</p><p>​ 在1940-1950年，程序员开发出一种新语言，更可读、更高层次，每个操作码分配一个简单名字，称为<strong>助记符（Mnemonics）</strong>，助记符后跟数据，形成完整的指令。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200215202238984.png" alt="image-20200215202238984"></p><p>所以与其写0和1的机器码，程序员可以直接写“LOAD_A 14”，这个语言称为<strong>汇编语言（Assembly Language）</strong>。当然计算机无法理解“LOAD_A 14”，所以程序员们写了一个程序来将文字指令自动转换成二进制指令，这个程序称为<strong>汇编器（Assembler）</strong>，$汇编器读取汇编语言写的程序，然后转换成机器码$。</p><p>随着发展，汇编器有越来越多的功能使得编程更加容易，其中一个功能就是自动分析JUMP地址。如下图，JUMP后面跟的是内存中的真实地址，如果我们在上方对程序进行修改，则后面的所有地址都会改变。所以<u>汇编器不用固定跳转地址</u>，而是让你插入可跳转的标签，当程序传入汇编器，汇编器就会自己推算出跳转地址，这样就程序员就无序过分关注细节。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-c044bd0bbaf2c1bc95398ca38ea36153_hd.jpg" alt="img"></p><p>​ $汇编代码例子$</p><p>汇编只是修饰了一下机器码，一般来说，<u>一条汇编指令对应一条机器指令</u>，所以汇编码和底层硬件连接很密切，程序员仍需要思考使用什么寄存器和内存地址。为了释放电脑的潜力，霍普设计了一个高级编程语言，叫做Arithmetic Language Version 0，简称A0。一行高级编程语言，可能会转换成几十条二进制指令。为此做到这种复杂转换，霍普在1952年创造了第一个<strong>编译器（Compiler）</strong>，编译器专门把高级语言转换成低级语言（比如汇编 或 机器码）。由此，高级编程语言就不用管寄存器或内存位置，编译器会解决这些细节。</p><p>在1950年，大多数编程语言和编译器只能运行在一种计算机中，如果更换计算机，就要重写所有代码，因此1959年开发一种通用编程语言，可以在不同机器上通用，最后诞生了一门高级、易于使用的语言<strong>普通面向商业语言（Common Business-Oriented Language，COBOL）</strong>。为了兼容不同底层硬件，每个计算机架构需要一个COBOL编译器，由此无论运行的计算机是什么，这些编译器可以接收相同的COBOL代码。如今大多数编程语言都是如此，不必接触CPU特有的汇编码和机器码。</p><h1 id="12、编程原理-语句和函数"><a href="#12、编程原理-语句和函数" class="headerlink" title="12、编程原理-语句和函数"></a>12、编程原理-语句和函数</h1><p><code>a=5;</code>是一个编程语言的<strong>语句</strong>。</p><p>程序由一个个指令组成。</p><h1 id="13、算法入门"><a href="#13、算法入门" class="headerlink" title="13、算法入门"></a>13、算法入门</h1><p><strong>算法</strong>：<strong>解决问题的具体步骤。</strong></p><h1 id="14、数据结构"><a href="#14、数据结构" class="headerlink" title="14、数据结构"></a>14、数据结构</h1><p>数据是以什么形式存在内存里呢？<strong>我们希望数据是结构化的，方便读取</strong>，由此发明了数据结构。</p><h2 id="14-1-数组Array"><a href="#14-1-数组Array" class="headerlink" title="14.1 数组Array"></a>14.1 数组Array</h2><p>一个变量只能存储一个值，而一个数组变量能够保存多个同类型值，并且数组的值是一个个连续存在内存中的。</p><p>为了取出数组中的某个值，我们需要指定一个<strong>下标（Index）</strong>。大多数编程语言中，数组的下标都从0开始。下图是数组保存在内存中的形式，为了简单，假设编译器从内存地址1000开始保存数组，数组中的内容就像图中那样顺序保存在内存中。定义该数组变量为<code>j</code>，则<code>j[0]</code>会取内存地址1000的数据来获得第一个元素的值， <code>j[5]</code> 则会去内存地址1000加5个偏移量得到内存地址1005中保存的数据。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-05e5d5a5004692369a9475bf3d6f886a_hd.jpg" alt="img"></p><p><strong>缺点：</strong>创建数组时就要固定大小，不能动态增加大小，并且数组在内存中是按顺序存储的，在中间插入一个值很困难。</p><h3 id="14-2-字符串String"><a href="#14-2-字符串String" class="headerlink" title="14.2 字符串String"></a>14.2 字符串String</h3><p>类似于数组，其实就是字母、数字、标点符号等构成的数组。我们在第4节中有讨论了计算机怎么存储字符的，通过ASCII或者Unicode编码，将字符转换为对应的二进制数。</p><p>写代码时，可以直接用引号括起来构建字符串<code>j=&quot;Hello World&quot;</code>， 其在内存中的存储形式如下图。<strong>注意：</strong>字符串在内存中以<strong>二进制0</strong>结尾，表示字符串结尾，用来给别的函数指示什么时候字符串结束了。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-b8b2ba66353be16cf7a7c96f744c9879_hd.jpg" alt="img"></p><h3 id="14-3-矩阵Matrix"><a href="#14-3-矩阵Matrix" class="headerlink" title="14.3 矩阵Matrix"></a>14.3 矩阵Matrix</h3><p>之前保存的都是一维数组，但是像电子表格或屏幕像素，都需要保存二维信息，所以这里就需要用到矩阵。</p><p>可以将矩阵看成是数组的数组，比如一个3x3矩阵， 相当于就是一个长度为3的数组，而这个数组中的每个元素又是一个长度为3的数组。矩阵保存在内存中的形式如下图所示，这里使用的是<u>行优先存储</u>，即优先将矩阵的每一行保存在内存的相邻位置，当一行保存完后，再保存下一行。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-45786350b76ab13bf59f20d2d2a0f432_hd.jpg" alt="img"></p><center>矩阵例子</center>![img](https://longlongqin.gitee.io/image_save/images/assets/v2-f4e8c5b992abea5477f71fcf39702a68_hd.jpg)<center>内存中的矩阵</center>为了获取一个值，需要两个小标，比如`j[2][1]`表示从内存地址1000偏移`2*3+1=7`位置，得到元素12。这里偏移量的计算方法是`行索引*列元素个数+列索引`。<p>我们不仅能构建二维矩阵，我们可以构建任意维度的矩阵。</p><h3 id="14-4-结构体Struct"><a href="#14-4-结构体Struct" class="headerlink" title="14.4 结构体Struct"></a>14.4 结构体Struct</h3><p>目前我们只将单个数字或字符存在数组或矩阵中，在数组中保存的都是相同类型的元素。<u>如果我们想把几个有关系的变量存储在一起，并且这些变量都是不同类型的</u>，我们就需要用到结构体。</p><p>…..</p><h1 id="16、软件工程"><a href="#16、软件工程" class="headerlink" title="16、软件工程"></a>16、软件工程</h1><p>为了写大型程序，程序员用各种工具和方法，所有这些形成了软件工程学科。</p><p>将大项目分解成小<strong>函数</strong>可以让很多人同时工作，由此他们无需关心整个项目，只要关心自己的函数就好了。</p><p>但是这种抽象程度还是不够，大型项目中可能还是会存在大量的函数，因此需要将函数打包成层级，将相关代码放在一起，打包成<strong>对象（Object）</strong>。比如汽车软件中，可能有几个和定速巡航有关的函数，因此我们可以包装一个“定速巡航对象”来打包这些函数，我们还可以更进一步，“定速巡航”只是引擎软件的一部分，可能还有“火花塞点火”、“燃油泵”和“散热器”等等，因此我们可以做一个“引擎对象”来打包所有子对象，并且除了子对象，引擎对象还会包含自己的函数，比如“开关引擎”，也会有自己的变量，比如汽车行驶里程数。总的来说，对象可以包含其他对象、函数和变量。然后当你想调用一个比较底层对象的函数时，只需要层层向下调用就行，比如<code>Car.Engine.CruiseControl.setCruiseSpeed(55)</code>。这种将函数打包成对象的思想称为<strong>面向对象编程（Object Oriented Programming）</strong>。相同的想法都是通过封装组件来隐藏复杂度。</p><p>把大型软件拆成一个个更小单元，会更适合团队合作。但是各个团队之间的代码是相互交织的，比如团队A实现的某个函数需要团队B的代码支持，因此团队需要<strong>文档（Documentation）</strong>来帮助理解代码都做什么，以及定义好的<strong>程序编程接口（Application Programming Interface，API）</strong>。这样，即使程序员不知道具体的实现细节，也能直接使用API调用相应的函数。并且API能控制哪些函数和数据是对外开放的，哪些是仅供对象内部使用的，面向对象的编程语言可以指定函数时<code>public</code>或<code>private</code>来设置权限，避免用户调用错了函数造成bug。如果标志为private，表示只有同一个对象内的其他函数能调用它， 所以在这个例子中，只有内部函数比如<code>setRPM</code>能够调用 <code>fireSparkPlug</code>函数，并且由于<code>setRPM</code>函数是public的，所以其他对象可以调用它。</p><blockquote><p><strong>面向对象编程的核心：</strong>隐藏复杂度，选择性的公布功能。</p></blockquote><p>现代软件开发者会使用专门的工具来写代码，工具里集成了很多功能帮助写代码、整理、编译和测试，这些软件称为<strong>集成开发环境（Integrated Development Environments，IDE）</strong>。</p><p>程序员一个重要的工作部分是给代码写文档，一般放在一个叫<code>README</code>的文件中， 文档也能直接写成注释放在源代码中。</p><p>除了IDE，还有一个重要软件帮助团队协作，称为<strong>源代码管理（Source Control）</strong>。比较大型的公司会将代码放在一个中心服务器上，称为<strong>代码仓库（Code Repository）</strong>。当程序员想改一段代码时，可以check out获得代码，然后开发者在自己电脑上编辑代码，当代码没有问题，所有测试都通过时，就能将代码放回代码仓库了，称为<strong>提交（Commit）</strong>。当代码被check out，并且可能被改过了，其他开发者就不会动这段代码，避免代码冲突和重复劳动。代码的主版本（master）应该总是编译正常，尽可能少bug。并且源代码管理可以跟踪所有变化，当出现bug时，全部或部分代码可以<strong>回滚（Rolled Back）</strong>到之前的稳定版本，并且也能记录下代码修改者。</p><p>测试代码一般由个人或小团队完成，测试可统称为<strong>质量保证测试（Quality Assurance Testing，QA）</strong>。<strong>“alpha version”</strong>软件一般很粗糙，错误很多，经常只在公司内部操作，而<strong>“beta version”</strong>软件指的是软件接近完成，但不是完全测试通过，公司有时会向公众发布beta版，以帮助发现问题，用户就像免费的QA团队。</p><h1 id="17、集成电路-amp-摩尔定律"><a href="#17、集成电路-amp-摩尔定律" class="headerlink" title="17、集成电路&amp;摩尔定律"></a>17、集成电路&amp;摩尔定律</h1><p>过去计算机的飞速发展，强烈依赖于硬件的发展。</p><p>大约1940年代-1960年代中期，计算机都由独立部件组成，称为<strong>分立元件（Discrete Components）</strong>，然后不同组件再用线连在一起。比如ENIAC有1万7千多个真空管，7万个电阻，1万个电容，7千个二极管，5百万个手工焊点。如果想要提升性能，就要加更多部件，这就导致了更多更复杂的电线，这个称为<strong>数字暴政（Tyranny of Numbers）</strong>问题。</p><p>到1950年代中期，晶体管开始商业化，开始用于计算机中，晶体管比电子管更小更快更可靠，但晶体管依然是分立元件。1959年，IBM把709计算机从原本的电子管全部换成晶体管，诞生了IBM 7090，速度快6倍，价格只有一半。晶体管标志着计算机2.0时代的到来，但是晶体管的出现还是没有解决数字暴政的问题，有十几万个独立元件的计算机不但难设计，而且难生产。</p><h2 id="集成电路（Integrated-Circuits，IC）："><a href="#集成电路（Integrated-Circuits，IC）：" class="headerlink" title="集成电路（Integrated Circuits，IC）："></a>集成电路（Integrated Circuits，IC）：</h2><p>到1960年代，这个问题的严重性达到顶点，解决方法就是引入一层新抽象，封装复杂性。突破性进展在1958年，与其把多个独立部件用电线连起来，拼装出计算机，我们把多个组件包在一起，变成一个新的独立组件，这个称为<strong>集成电路（Integrated Circuits，IC）</strong>。几个月后，仙童半导体就让集成电路变成现实，之前使用锗来做集成电路，但是锗很稀少且不稳定，仙童半导体使用<strong>硅</strong>，因为硅的蕴藏量丰富，也更稳定可靠。</p><p>起初，一个IC只有几个晶体管，但是也足以将逻辑门封装成独立组件，可以组合出无数种设计，但是最终还是要连起来，创造出更大更复杂的电路，比如计算机。所以创造出了<strong>印刷电路板（Printed Circuit Boards，PCB）</strong>，可以大规模生产，无需焊接或用一堆线，它通过蚀刻金属线的方式将零件连接到一起。把PCB和IC结合使用，可以大幅减少独立组件和电线，但做到相同的功能，而且更小更便宜更可靠。</p><p>不过即使组件再小，塞5个以上的晶体管还是很困难，为了实现更复杂设计，出现了全新的制作工艺——<strong>光刻（Photolithography）</strong>。简单来说，就是用光把复杂图案印到材料上，比如半导体。它只有几个基础操作，但是可以制作出复杂电路。</p><blockquote><ul><li>首先，我们从一片硅开始，称为<strong>晶圆（Wafer）</strong>，长得和薄饼干一样。并且硅是半导体，有时导电有时不导电，我们就可以控制导电时机，所以硅是做晶体管的绝佳材料。我们可以用晶圆做基础，把复杂金属电路放上去，来集成所有东西。</li><li>在硅片顶部加一层薄薄的<strong>氧化层（Oxide Layer）</strong>作为保护层，然后加一层特殊化学品称为<strong>光刻胶（Photoresist）</strong>，光刻胶被光照射后，就变得可溶，可以用一种特殊化学药剂洗掉。然后我们会在光刻胶上加一层<strong>光掩膜（Photomask）</strong>，当用强光照射时，挡住光的部分光刻胶就不会变化，而光照射到的地方，光刻胶就会发生化学变化，洗掉变化的光刻胶后，就会暴露出部分氧化层。然后通常用酸能洗掉氧化层暴露出的部分，就能蚀刻到硅层。然后再用另一种化学试剂清洗掉剩余的光刻胶，这样只剩下氧化层和晶圆了。我们想修改硅暴露出来的区域，让它们导电性更好，所以我们使用<strong>掺杂（Doping）</strong>，通过将磷渗透进暴露的硅，来改变电学性质。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-43b8796ff46c3bf12da90361caf3a74b_hd.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-b19ae3a9f85fb157495ee4a2a986c4b1_hd.jpg" alt="img"></p><ul><li>我们还需要几轮光刻法来做晶体管。还是叠加上氧化层、光刻胶和新的光掩膜，这样就能在掺杂区域上方开缺口，然后进行清洗蚀刻，再用另一种元素进行掺杂，把硅转换成另一种形式。为了控制深度，时机很重要，不要超过之前掺杂的区域，这样所有需要的组件都有了。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-0261b1e130471a85ebaea8f5df038bab_hd.jpg" alt="img"></p><ul><li>最后，在氧化层上做通道，这样可以用细小金属导线连接不同晶体管。首先用光刻胶和光掩膜，在氧化层上蚀刻出小通道。然后用新的处理方法称为<strong>金属化（Metalization）</strong>，在氧化层上放一层薄薄的金属，比如铝或铜，再加上光刻胶和光掩膜，然后融掉暴露的光刻胶，暴露出金属。最终清洗，只保留晶圆、氧化层和金属化，这样就做出了一个晶体管。它有三根线分别连接着硅的三个不同区域，每个区域的掺杂方式不同，这个叫<strong>双极型晶体管（Bipolar Junction Transistor）</strong>。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-b2d6dce62f3352d950dc12e238fc0099_hd.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-f099fd3eea9861f0ef822f76299e616c_hd.jpg" alt="img"></p><center>晶体管</center></blockquote><p>相同方法，光刻可以在一片硅上制作其他电子元件，比如电阻电容，而且相互连接的电路也做好了。</p><p><strong>并且通过调节光掩膜和光源之间的距离</strong>，光可以投射成任意角度，我们可以把光掩膜聚焦到极小的区域，制作出非常精细的细节，这样一片晶圆就能做出很多IC，整块都做完后，就可以切割然后包进微型芯片中，芯片的核心都是一小片IC。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-77dbe69c1ca5bcacd2c735dccfe11c7a_hd.jpg" alt="img"></p><p>随着光刻技术发展，晶体管变小，密度变高。1960年初，IC很少能超过5个晶体管，但到了1960年中期，市场上已经开始出现超过100个晶体管的IC。</p><h2 id="摩尔定律（Moore’s-Law）"><a href="#摩尔定律（Moore’s-Law）" class="headerlink" title="摩尔定律（Moore’s Law）:"></a>摩尔定律（Moore’s Law）:</h2><p>1965年，戈登·摩尔看到了发展趋势，提出<strong>摩尔定律（Moore’s Law）</strong>：<strong>每两年左右，得益于材料和制造技术的发展，同样大小的空间，能塞进两倍量的晶体管。</strong></p><p>晶体管更小密度更高，要移动的电荷量就越少，能快速切换状态，耗电更少。并且电路更紧凑，意味着信号延迟更低，导致时钟速度更快。</p><p>集成电路的出现，尤其是用来做微处理器，开启了<strong>计算机3.0时代</strong>。</p><p>到了2010年，一个IC中有10亿个晶体管。为了达到这种密度，光刻的分辨率从大约一万纳米，发展到如今的14纳米。</p><p>现代工程师设计电路时，不是手工一个个设计晶体管的，从1970年代开始，<strong>超大规模集成（Very-large-scale Integration，VLSI）</strong>软件用来自动生成芯片设计。用比如<strong>逻辑综合（Logic Synthesis）</strong>可以放一整个高级组件，比如内存缓存，软件会自动生成电路，做到尽可能高效，许多人认为这是<strong>计算机4.0时代</strong>的开始。</p><p><u>但是摩尔定律现在迎来了终结，进一步做小，会迎来两个问题：</u></p><ol><li>用光掩膜把图案弄到晶圆上，因为光的波长，精度已经到达极限。所以科学家在研制波长更短的光源，投射更小的形状。</li><li>当晶体管非常小，电极之间可能只距离几个原子，电子就会跳过间隙，称为<strong>量子隧道贯穿（Quantum Tunneling）</strong>，由此晶体管就不能正常工作了。</li></ol><h1 id="18、操作系统"><a href="#18、操作系统" class="headerlink" title="18、操作系统"></a>18、操作系统</h1><p>40 50年代的电脑，每次只能运行一个程序，程序员在打孔纸上写程序，然后再放入计算机中进行计算，一开始计算机速度比较慢，通常一个程序需要运行几天时间，所以放程序的时间还能忍受。但是随着计算机运算速度的告诉发展后，放程序的时间比程序运行时间还要长，我们就需要一种方式，让计算机自动运行，于是诞生了<strong>操作系统（Operation Systems，OS）</strong>。</p><p><strong>操作系统其实也是程序</strong>，<u>但它有操作硬件的特殊权限，可以运行和管理其他程序</u>。操作系统一般是开机第一个启动的程序，然后其他所有程序都由操作系统启动。从1950年代开始有操作系统，那时计算机开始变得更加强大， 第一个操作系统主要加强了程序加载方式，取代了手工加载程序的过程。</p><p>之前只能一次给一个程序，现在可以一次多个程序，当计算机运行完一个程序后，就会自动运行下一个程序，这样就不用浪费时间找下一个程序的纸卡，这称为<strong>批处理（Batch Processing）</strong>。</p><p>随着计算机的发展，计算机出现在大学和政府办公室，人们开始分享软件，但是有个问题。在哈佛1号和ENIAC那个时代，计算都是一次性的，程序员只需要给特定一台机器写代码，其中处理器、读卡器和打印机都是已知并且不会改变的。但是随着计算机越来越普遍，计算机配置并不总是相同的，比如计算机可能有相同的CPU但是不同的打印机等等，这样程序员不仅要担心程序，还要担心程序怎么和不同型号的打印机进行交互，以及计算机连着的其他设备，统称为<strong>外部设备（Peripherals）</strong>。和早期的外部设备交互是非常底层的，程序员需要了解设备的硬件细节，但是程序员又很少能拿到所有型号的设备来测试代码。所以一般是阅读手册然后尽可能编写代码。</p><p>所以为了能够更好地写软件，<em>操作系统就充当软件和硬件之间的媒介</em>。更具体的，操作系统提供API来抽象硬件，叫<strong>设备驱动程序（Device Drivers）</strong>。这样程序员可以通过标准化机制和<strong>输入输出硬件（Input &amp; Output，I/O）</strong>进行交互，而无需关注硬件型号以及具体硬件细节。</p><p>到1950年代末尾，电脑已经运行非常快了，处理器经常需要等待较慢的机械设备（比如打印机和读卡器），程序就阻塞在I/O上，而处理器什么都没有进行处理。英国曼彻斯特大学开始研发世界上第一台超级计算机Atlas，由于机器运算非常快，所以需要一种方式来尽可能利用更多的算力。他们于1962年年设计了一个程序叫Atlas Supervisor，<u>使得操作系统不仅能进行批处理，并且通过<strong>调度（Scheduling）</strong>还能在单个CPU上同时运行几个程序。</u></p><blockquote><p>比如我们需要调用print函数让Atlas打印一个变量值，由于打印机比CPU慢很多，所以print函数需要运行比较长的时间。与其等待打印机完成打印，Atlas会将该程序进行休眠，然后运行其他等待的并且可运行的程序。最终当打印机打印完后，会报告给Atlas，则Atlas会将之前的程序标记为“可运行”状态，然后在某个时刻会安排给CPU继续运行print函数下一行代码。由此，Atlas能够在CPU上运行一个程序，同时另一个程序在打印数据（这里是让打印机自己在打印，所以无需CPU进行参与），同时另一个程序读数据（这里只需要使用读卡器，不需要CPU）。</p></blockquote><p>Atlas配有4台读取器、4台打印机和8个磁带驱动器。使多个程序可以同时运行，在单个CPU上共享时间。操作系统的这种能力称为<strong>多任务处理（Multitasking）</strong>。但是同时运行多个程序存在一个<strong>问题</strong>，每个程序都会占用一些内存，当切换到另一个程序后，我们不能丢失这些内存中的数据。<strong>所以我们给每个程序分配专属内存块</strong>，比如我们计算机一共有10000个内存地址，然后程序A分配到了0-999的内存地址，程序B分配到1000到1999，以此类推。如果一个程序请求更多内存，操作系统就会决定是否同意，如果同意，就要决定分配哪些内存块，这就使得程序A可能会分配到非连续的内存块，使得程序员能难进行跟踪。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-352e87bdb554469c2ed3a5c8a26956bf_hd.jpg" alt="img"></p><center>内存中程序分配</center>**处理分配的内存不连续的情况--动态内存分配**<p>$如果同意，就要决定分配哪些内存块，这就使得程序A可能会分配到非连续的内存块，使得程序员能难进行跟踪。$</p><p>为了隐藏这种复杂性，操作系统会把内存地址进行虚拟化，称为<strong>虚拟内存（Virtual Memory）</strong>。程序可以假定内存总是从地址0开始，而实际的物理位置，被操作系统隐藏和抽象了。以程序B为例，它分配了内存地址1000到1999，但是对于程序B而言，它能看到的地址是0到999，操作系统会自动处理虚拟内存和物理内存之间的映射，所以程序B要地址42，实际需要物理地址1042。对于程序A，它被分配了分散的物理内存块，但是程序A并不知道，它所能看到的是连续的从0到1999的地址，当程序A读内存地址999时，会被映射到物理地址999，而当程序A读内存地址1000，则会被映射到物理地址2000。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-ab782154333eb8168c2a4d3da20a9895_hd.jpg" alt="img"></p><center>虚拟内存例子</center>这种机制使得程序的内存大小可以灵活增减，称为**动态内存分配（Dynamic Memory Allocation）**。对程序而言，内存看起来是连续的，为操作系统同时运行多个程序提供了极大的灵活性，程序员只需要根据连续的虚拟内存地址进行编程，无需考虑程序在实际物理内存中不连续的物理内存块。<p>同时给每个程序分配一个专用的内存块，可以使得隔离起来更方便。如果一个程序出错了，在内存中胡乱写数据，它只能在自己分配的内存块中进行操作，不会影响到其他程序的数据，这个称为<strong>内存保护（Memory Protection）</strong>。这对于防止恶意软件是否有效。Atlas是第一台提供虚拟内存和内存保护功能的操作系统。</p><p>到1970年代，大学会购买电脑给学生使用，此时计算机不仅能同时运行多个程序，还能让多个用户同时访问。多个用户使用<strong>终端（Terminal）</strong>来访问计算机（这里的终端只有键盘和屏幕，然后连接到计算机），终端本身并不具有处理能力。这样计算机不仅要能处理多个程序，还要处理多个用户，为了确保其中一人不会占满计算机资源，开发了<strong>分时操作系统（Time-Sharing）</strong>，指的是每个用户只能用一小部分处理器、内存等，因为计算机很快，所以即使只有一小部分资源，也足以完成很多任务。</p><p>早期分时操作系统中，最有影响力的是1969年发布的Multics，它是第一个从设计时就考虑到安全性的操作系统。开发人员不希望恶意用户访问不该访问的数据，这使得操作系统的复杂度远超当时的平均水平，通常内存的一半都要用来运行操作系统，这种过度设计使得Multics未能获得商业成功。所以研究员们重新打造了一个操作系统Unix，他们想把操作系统分成两部分：</p><blockquote><ol><li>操作系统的核心功能，比如内存管理，多任务和输入输出处理，这个称为<strong>内核（Kernel）</strong>。</li><li>一些有用的工具，但是他们不是内核的一部分，比如程序和运行库。</li></ol></blockquote><p>紧凑的内核意味着功能没有之前那么全面。当内核出现崩溃时，Multics有很多操作来进行恢复，但是Unix是没有办法恢复的，会直接调用一个panic函数，最初只能无限循环打印panic。这种简单性意味着Unix可以再更便宜的硬件上运行。1971年发布之后，就有人写了不同编程语言的编译器，甚至文字处理器，使得Unix迅速成为1970-80年代最流行的操作系统之一。</p><p>到1980年代早期，个人电脑逐渐出现，这些电脑比大型主机简单很多，主机一般在大学、公司和政府，因此操作系统也要变得简单。于1981年微软发布的磁盘操作系统MS-DOS只有160kb，虽然缺少多任务和保护内存这样的功能，意味着程序经常使系统崩溃，用户可以直接重启。即使在1985年发布的早期windos，也一样缺少内存保护功能，当程序错误时，就会出现蓝屏。</p><p>现代的操作系统包含了<strong>多任务</strong>、<strong>虚拟内存</strong>和<strong>内存保护机制</strong>，因此可以同时运行多个程序。</p><h1 id="19、内存-amp-存储介质"><a href="#19、内存-amp-存储介质" class="headerlink" title="19、内存&amp;存储介质"></a>19、内存&amp;存储介质</h1><p>一般来说，电脑<strong>内存</strong>是<strong>非永久性的（Non-Permanent）</strong>，如果电脑关机，则内存中的所有数据都会丢弃，所以内存叫<strong>易失性存储器（Volatile Memory）</strong>，还存在另一种<strong>存储器（Storage）</strong>，存储器（storage）和内存（memory）存在一定的不同。任何写入storage的数据，就会一直保存，直到被覆盖或删除，断点也不会丢失，称为<strong>非易失性（Non-volatile）</strong>。过去是易失性的速度快，非易失性的速度慢，但随着技术发展，两者的差异越来越小。</p><p>最早的存储介质是打孔纸卡以及打孔纸带，到1940年代，纸卡标准是80列x12行，能够存储960位数据。纸卡用了十几年，因为不用电而且便宜耐用，但是读取速度较慢，只能写入一次，对于存临时值，纸卡不好用，我们需要更大更灵活的存储方式。</p><h2 id="延迟线存储器："><a href="#延迟线存储器：" class="headerlink" title="延迟线存储器："></a>延迟线存储器：</h2><p>1944年时，出现了<strong>延迟线存储器（Delay Line Memory）</strong>。<strong>原理</strong>：假设你有一个装满液体（如水银）的管子，管子一端放着扬声器，另一端放着麦克风，当扬声器发出脉冲时，就会在管子内产生压力波，经过一段时间后压力波会传递到麦克风，然后麦克风将压力波转换为电信号，通过在麦克风后面接一个<strong>放大器（AMPLIFIER）</strong>，然后连回扬声器，我们就能用压力波的传播延迟来存储数据。假设有压力波代表1，没有代表0，扬声器发出一系列压力波，因为传播延时的原因，这些压力波会存在管子内，当撞击到麦克风后，又会通过扬声器重新回到管子，所以就能将数据保存在管子内。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200222172929235.png" alt="image-20200222172929235"></p><p>在1949年的EDVAC计算机中使用了延迟线存储器，总共有128条延迟线，每条能存352位，一共能保存45000位。这使得EDVAC成为最早的<strong>存储程序计算机</strong>之一。</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>但延迟线存储器的<strong>缺点</strong>是，每个时刻只能读一位数据，如果想访问一个特定的位，就要等待它从循环中出现，所以又被称为<strong>顺序存储器Sequential Memory）</strong>或者<strong>循环存储器（Cyclic-Access Memory）</strong>。而我们想要<strong>随机存取存储器（Random Access Memory）</strong>，可以随时访问任何位置。并且增加内存密度也是一个挑战，如果要将压力波变得更紧密，就会使其混在一起，所以出现了其他类型的延迟线存储器，比如<strong>磁致伸缩延迟存储器（Magnetostrictive Delay Lines）</strong>，它通过金属线的振动来代表数据。</p><h2 id="磁芯存储器："><a href="#磁芯存储器：" class="headerlink" title="磁芯存储器："></a>磁芯存储器：</h2><p>但是延迟线存储器在1950年代中期就过时了。因为出现了新技术，于是出现了，<strong>磁芯存储器（Magnetic Core Memory）</strong>，它用了环状磁圈，如果给磁芯绕上电线并施加电流，就能将其磁化在一个方向，如果关掉电流，磁芯还会保持磁化，如果施加了相反方向的电流，则磁化方向会翻转。这样我们就能通过磁化方向来存储0和1，就能用来存储1位。通过将磁芯排列成网格状，有线路负责选择行和列，也有电线贯穿每个磁芯，用于读写1位。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-c8e58ebec8d54b77be564e81463cd7de_hd.jpg" alt="img"></p><center>磁芯存储器</center>如果要存的数据超过1bit，就需要把磁芯存储器排列成网格：<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200222173626986.png" alt="image-20200222173626986"></p><p>1953年麻省理工的Whirlwind1计算机第一次大规模使用磁芯内存，磁芯排列使用32x32，用了16块板子，大约能存储16000位。不像延迟线存储器，磁芯存储器能随时访问任何一位，因此从1950年代中期成为主流，流行了20多年，将存储成本从1美元1位降低到了1美分左右。</p><h2 id="磁带："><a href="#磁带：" class="headerlink" title="磁带："></a>磁带：</h2><p>到1951年，UNIVAC电脑推出了一种新存储——<strong>磁带（Magnetic Tape）</strong>。磁带是纤薄柔软的一长条卷在轴上的磁性带子，磁带可以在<strong>磁带驱动器</strong>内前后移动，里面有一个缠绕了电线的<strong>写头（Write Head）</strong>，通过电流来产生磁场，导致磁带的一小部分被磁化，电流方向决定了极性，代表1和0。同样还有一个读头（Read Head），可以非破坏地检测极性来确定数据。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-1d9ac11988c8c3e7e54dc2c032bc21a4_hd.jpg" alt="img"></p><h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><p>磁带的主要缺点是访问速度，磁带是连续的，必须倒带或快进到特定位置。</p><p>50 60年代出现了类似的技术<strong>磁鼓存储器（Magnetic Drum Memory）</strong>,有一个金属圆管，盖满了磁性材料来记录数据，圆管会持续旋转，周围有数十个读写头，等圆管转到了正确的位置，读写头就会读或写数据。</p><p>但到了1970年代磁鼓存储器就不再生产了，但是磁鼓导致了<strong>硬盘（Hard Disk Drives）</strong>的发展，磁盘的好处是薄，可以叠在一起来提供更多表面积来存储数据。要访问某个特定位，一个读写磁头会上下移动，找到正确的磁盘，然后磁头会滑进去，就和磁鼓存储器一样，磁盘也会高速旋转，所以读写头要等到正确的部分旋转过来，这个称为<strong>寻道时间（Seek Time）</strong>。</p><p>以下是<strong>内存层次结构（Memory Hierarchy）</strong>，有一小部分高速且昂贵的内存，一部分稍慢且相对便宜的内存，还有更慢且更便宜的内存，这种混合可以在成本和速度之间取得平衡。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200222174311987.png" alt="image-20200222174311987"></p><p>其次还有<strong>软盘（Floppy Disk）</strong>，除了磁盘是软的，其他都一样。</p><p>后面出现的<strong>光盘（Compact Disk，CD）</strong>以及DVD，它们不使用磁性来保存数据，而是使用表面的小坑来造成光的不同反射，通过光学传感器捕获并解码为1和0。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200222174429795.png" alt="image-20200222174429795"></p><center>光盘表面</center>如今成本下降了更多的存储技术在朝**固态（Solid State）**前进，**机械硬盘（hard disk drive，HDD）**被**固态硬盘（Solid State Drive，SSD）**逐渐代替。由于SSD没有机械活动部件，里面都是集成电路。因为不存在机械活动，所以磁头不用等磁盘旋转，所以固态速度快很多，但是仍然比RAM慢很多，<u>所以现代计算机仍然使用存储层次结构</u>。<h1 id="20、文件系统"><a href="#20、文件系统" class="headerlink" title="20、文件系统"></a>20、文件系统</h1><p>上一节中介绍的数据存储。存储器可以在断电状态下长时间存上万亿位，所以非常适合用来存一整块有关系的<u>数据</u>（或者称为<strong>文件（Files）</strong>），比如文本文件、音乐文件、照片和视频。这一节将讨论文件是什么以及计算机是怎么管理文件的。</p><p>随意排列文件的数据是没有问题的，但按格式排列会更好，这个称为<strong>文件格式（File Format）</strong>。</p><p>首先看一个最简单的文件格式——<strong>文本文件（Txt File，txt）</strong>。就像其他文件一样，文本文件只是一长串二进制数，可以通过ASCII编码将其解码成对应文本。</p><h2 id="波形文件："><a href="#波形文件：" class="headerlink" title="波形文件："></a>波形文件：</h2><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200223201711965.png" alt="image-20200223201711965"></p><center>波形文件（WAV）</center>**波形文件（Wave File，WAV）**用于存音频数据。在正确读取数据之前，我们需要知道一些信息比如码率，以及是单声道还是立体声，这种描述数据的数据称为**元数据（Meta Data）**。元数据保存在文件开头，在实际数据之前，因此也叫**文件头（Header）**。以下是WAV文件的前44个字节，有些部分会根据数据进行变化。<p>[^元数据]: <strong>元数据</strong>（<strong>Metadata</strong>），又称<strong>中介数据</strong>、<strong>中继数据</strong>，为描述<a href="https://baike.baidu.com/item/数据/5947370" target="_blank" rel="noopener">数据</a>的数据（data about data），主要是描述数据<a href="https://baike.baidu.com/item/属性/1405051" target="_blank" rel="noopener">属性</a>（property）的<a href="https://baike.baidu.com/item/信息/111163" target="_blank" rel="noopener">信息</a>，用来支持如指示存储位置、<a href="https://baike.baidu.com/item/历史/360" target="_blank" rel="noopener">历史</a>数据、<a href="https://baike.baidu.com/item/资源/9089683" target="_blank" rel="noopener">资源</a>查找、文件记录等功能。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200223201307602.png" alt="image-20200223201307602"></p><center>WAV格式的数据的元数据</center>而音频数据就紧跟在元数据之后，也是一长串二进制数，这些数字代表每秒捕获多次的声音幅度。麦克风首先会对声音进行每秒上千次采样，每次采样可以用一个数字表示，声压越高数字越大，称为**振幅(Amplitude)**，这就是WAV文件中存储的数据。播放声音时，扬声器就会产生相同的波形。<h2 id="位图-Bitmap"><a href="#位图-Bitmap" class="headerlink" title="位图(Bitmap)"></a>位图(Bitmap)</h2><p>再来谈谈<strong>位图</strong>，其后缀为bmp，用于保存图片。。计算机中，图片由多个<strong>像素(Pixel)</strong>方块组成，每个像素由三种颜色组成：红、绿、蓝，叫<strong>“加色三原色”</strong>，混合在一起能产生其他颜色。类似于WAV文件，BMP文件开头也是元数据，有图片宽度、图片高度和颜色深度等等。现在假设图片宽高均为4个像素，颜色深度为24，也就是8位(bit)红色、8位绿色和9位蓝色，则每个颜色有0-255程度，然后依次保存每个位置的三原色数值。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200223202632500.png" alt="image-20200223202632500"></p><center>位图的元数据</center>![image-20200223203327886](https://longlongqin.gitee.io/image_save/images/assets/image-20200223203327886.png)<center>位图的数据</center>通过以上例子，可以知道，文件底层都是二进制数，为了知道文件是什么，文件格式就十分重要。<h2 id="计算机如何存储文件："><a href="#计算机如何存储文件：" class="headerlink" title="计算机如何存储文件："></a>计算机如何存储文件：</h2><p>最简单存储多个文件的方法是将文件<strong>连续存储</strong>，但是这样怎么知道文件开头和结尾在哪呢？存储器并没有文件的概念，它只是用来存储大量二进制数。所以我们需要特殊文件来记录其他文件的位置，这里称为<strong>目录文件（Directory File）</strong>，它通常保存在存储器最开头，方便寻找。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-46682a86deaa95c83bba62ae802f8120_hd.png" alt="img"></p><center>storage</center>在目录文件中，存有其它所有文件的名字，格式为`文件名+点+扩展名`， 扩展名有助于得知文件类型。目录文件还保存了文件的元数据，比如创建时间、最后修改时间、文件所有者、是否能读写，最重要的是记录了文件起始位置和长度。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200223203721221.png" alt="image-20200223203721221"></p><center>目录文件</center>如果要添加、删除文件或者更改文件名，必须更新整个目录文件。<p>目录文件以及对目录文件的管理，是最基本的<strong>文件系统（File System）</strong>的例子，文件系统专门负责管理文件。刚刚的例子叫<strong>平面文件系统（Flat File System）</strong>，因为所有文件都在同一层次。存在一个<strong>缺点</strong>：当我们想要对中间文件增加数据时，就会覆盖后续文件的数据。所以现代文件系统会做两个处理：</p><ol><li>将空间划分成一块块，会出现一些<strong>预留空间（Slack Space）</strong>，可以方便改动。同时文件数据都对齐到了相同大小，可以方便管理。使用这种方案，目录文件就要记录文件在哪些块中。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200223204243036.png" alt="image-20200223204243036"></p><ol start="2"><li>拆分文件保存在多个块中。假设todo.txt文件中加了一些数据，使得文件太大无法存在一个块中，则文件系统会分配一个没使用的块来容纳额外的数据，<u>则目录文件对每个文件就会记录不止一个块，而是多个块</u>。通过分配块，文件就可以轻松增加减小。如果想要删除carrie.bmp，只要在目录文件中删除对应记录就行，让这一块空间变成可用的，这样就不需要进行擦除，只需要直接删除记录就行。<strong>在那一块被新数据覆盖之前，数据还是保存在原处的。所以恢复删除数据是有可能的。</strong></li></ol><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200223204550449.png" alt="image-20200223204550449"></p><p>当文件过大，保存在若干个块中，这个称为<strong>碎片（Fragmentation）</strong>，碎片是增删改文件导致的，无法避免，但是会造成性能下降。解决方法是通过<strong>碎片整理（Defragmentation）</strong>，计算机会将数据来回一定，排列成正确的顺序，就能很方便地进行读写。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200223204701481.png" alt="image-20200223204701481"></p><center>碎片整理前</center>![image-20200223204733889](https://longlongqin.gitee.io/image_save/images/assets/image-20200223204733889.png)<center>碎片整理后</center>随着容量爆炸式增长，文件数量飞速增加，平面文件系统逐渐应付不来，所以出现了**分层文件系统（Hirerarchical File System）**，这里最大的变化就是每个文件夹中都有一个目录文件，并且目录文件不仅要指向文件，还要指向目录，还需要增加额外的元数据来区分文件和目录。<p><strong>优点</strong>：这种文件系统不仅可以做出无限深的文件夹，也可以让我们很轻松地移动文件，我们不需要移动任何数据块，只需要在两个目录文件中删增记录就行。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200223204831349.png" alt="image-20200223204831349"></p><center>分层文件</center>文件系统使我们不必关心文件在磁盘中的具体位置。<h1 id="21、压缩"><a href="#21、压缩" class="headerlink" title="21、压缩"></a>21、压缩</h1><p>之前介绍了文件格式，如何编码文字、声音和图片，但是它们的效率并不高，我们希望文件能小一点，这样就能保存大量文件，同时传输也会快一些，解决方法就是<strong>压缩（Compression）</strong>，把数据占用的空间压得更小，为此我们需要用更少的bit来表示数据。</p><p>以压缩图片为例，图片一般存成一长串像素值，为了知道一行在哪里结束，图像要有元数据，写明尺寸等属性。每个像素的颜色是三原色的组合，每个颜色用一个字节保存，数字范围是0~255（一个字节=8 bits，2^8^=256），由此一张<code>4*4</code>（16个像素）大小的图像，其中每个像素3个字节。则这个图片需要<code>4*4*3=</code>48字节。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200226140325517.png" alt="image-20200226140325517"></p><p>—》存成一长串像素值：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200226151330368.png" alt="image-20200226151330368"></p><center>图片一般存成一长串像素值</center>![img](https://longlongqin.gitee.io/image_save/images/assets/v2-202fff7eae740ec4451258a92c96eda0_720w.jpg)<center>前五个像素的表示</center>## 无损压缩：<p>一种压缩方法是减少重复信息，最简单的方法叫<strong>游程编码（Run-Length Encoding）</strong>，适合经常出现相同值的文件。比如上图中有7个连续相同的黄色像素块，我们可以插入一个额外字节来表示7个连续黄色像素，然后删掉后面重复的数据。为了让计算机分辨哪些字节时长度，那些字节是颜色，格式需要保持一致，所以我们需要给所有像素前面都标上长度。在这个例子中现在只需要24个字节，并且不损失任何信息。这个方法称为<strong>无损压缩（Lossless Compression）</strong>，没有丢失任何数据。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-315b1a99dd4902cb5d8a9c9d7a81cde1_720w.png" alt="img"></p><center>游程编码</center>另一种无损压缩方法叫做**DFTBA**，它用更紧凑的方式来表示数据块。首先我们需要一个字典，来保存代码和数据之间的对应关系。我们可以将图像看成一块一块，而不是一个个像素，为了简单，我们将2个像素当成一个块，由此我们可以得到下图的4个像素对，我们会对些像素对生成**紧凑代码（Compact Codes）**。这些块出现频率不同，我们通过霍夫曼树的方法对每一种情况进行编码，使得频率最高的块代码最短。然后我们就能通过code代替块来对图像进行压缩。这个例子中将48字节的数据压缩成了14位，但是同样也要把字典保存下来，所以还需要将字典加到数据前面，所以总共有30字节。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-e40dfa25fd9f55ddb49ac3c558b2415f_720w.jpg" alt="img"></p><center>使用霍夫曼树生成的块的编码</center>![img](https://longlongqin.gitee.io/image_save/images/assets/v2-557e83d3f9b5d120457fb8fe3fc9df87_720w.png)<center>压缩结果</center>![img](https://longlongqin.gitee.io/image_save/images/assets/v2-e688a0f2a014255ed2e3c9ba38855ed5_720w.png)<center>加上字典后的压缩结果</center>## 有损压缩：<p>“消除冗余”和“使用更紧凑表示方法”通常会组合起来一起使用，几乎所有无损压缩格式都用到它们。</p><p>无损压缩对于文本数据十分重要，但是有其他一些数据即使丢失了一部分也不会造成很大影响，通常会丢失人们无法注意到的信息，大部分<strong>有损压缩技术（Lossy Compression）</strong>都用到了这点。</p><p>以声音为例，人类听力并不是完美的，有些频率我们可以捕获，但是类似于超声波这类的频率我们根本听不见，所以录制音乐时，超声波数据是可以丢弃的，其次人类对人声十分敏感，所以应该尽可能保持原样。<strong>有损音频压缩（Lossy Audio Compressors）</strong>通过不同精度编码不同频段，这样人类听不出什么区别，也不会明显影响体验。比如电话中也用到了这个技术，这就使得在电话中的声音和现实中有所差别，用过这个技术才使得更多人同时打电话。如果网速变慢，压缩算法就会删掉更多的数据。压缩音频文件MP3和没压缩音频文件WAV或FLAC大小可以相差10倍。</p><p>这种删除人类无法感知的数据的方法称为<strong>感知编码（Perceptual Coding）</strong>。这也是各种有损压缩图像格式的基础，比如JPEG，人类的视觉系统也不是完美的，我们比较善于看到尖锐的对比，比如物体的边缘，但我们无法看出颜色的细微变化。JPEG由此将图像分解成8x8大小的像素块，然后删掉大量高频空间数据。比如以下这张图片，其中一个8x8像素，由于每个像素都有细微差异，所以无损压缩技术很难对其压缩，但是人眼很难看出这些细微差别，所以我们可以删除很多像素值，这样只占10%的原始数据，并且图像看起来没有什么区别。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-0dcede4590c5d2552a8fe9e4d5a45c95_720w.jpg" alt="img"></p><center>原图；8x8原始像素块；8x8压缩像素块；压缩图像</center>视频只是一长串连续图片，所以图片的很多方面也适用于视频，但视频也可以做一些小技巧，因为帧与帧之间有很多相同的像素，称为**时间冗余（Temporal Redundancy）**。我们不需每一帧都保存这些像素，可以只保存变化了的部分。更高级的视频压缩格式会更进一步，他们找出帧和帧之间相似的补丁，然后对他们应用简单变换，比如移动、旋转、变亮和变暗，这样就不用重复保存这些相似的补丁，直接对其进行变换就行。MPEG-4视频是常见的标准，可以比原文件小20倍到200倍。但是当压缩太严重时，没有足够空间更新补丁内的像素，就会出现以下问题。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-759970de261a610b53e2e652fc6f572c_720w.jpg" alt="img"></p><center>过度压缩造成的错误</center># 23、屏幕&2D图像显示<p>早期的文本任务通过打印机显示，因为屏幕分辨率较低，无法显示清晰的文字，而将计算结果的文字打印在纸上，有更高的对比度和分辨率，屏幕一般只用于跟踪程序的运行情况，比如寄存器的值，可以节约纸，并且屏幕更新很快，对临时值很匹配。</p><p>最早最有影响力的是<strong>阴极射线管（Cathode Ray Tube，CRT）</strong>，原理是将电子发射到有磷光体涂层的屏幕上，当电子撞击涂层时，会发光几分之一秒。并且因为电子是带电粒子，所以路径可以通过磁场进行控制。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-739424da713eed4b346efb1dc7543358_720w.jpg" alt="img"></p><center>CRT</center>这样就有两种方法来绘制图形：<ol><li>引导电子束描绘出形状，称为<strong>矢量扫描（Vector Scanning）</strong>。因为发光只持续一小会儿，如果重复速度足够快，就能得到清晰的图像。</li><li>第二种方法是按照固定路径，一行行从上到下、从左到右不断重复，只在特定的点打开电子束来绘制图形。这种方法称为<strong>光栅扫描（Raster Scanning）</strong>。用这种方法可以用很多小线段绘制图形，甚至文字。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-ec5217cfd4e2ebb1de1126112a830c20_720w.jpg" alt="img"></p><center>矢量扫描和光栅扫描</center>随着屏幕的发展，我们终于可以在屏幕上显示清晰的点，称为**像素（Pixel）**。**液晶显示器（Liquid Crystal Display，LCD）**也使用光栅扫描，每秒更新多次像素里红绿蓝的颜色。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-818d25d7f9bfa6d121e602a746837223_720w.jpg" alt="img"></p><center>LCD</center>但是早期计算机不使用像素，因为内存中需要保存像素对应的值，使其占用太多内存，所以需要一些特殊技巧来渲染图形，知道内存发展到足够用的地步。<p>所以早期计算机不保存大量像素值，而是直接保存符号，其中80x25个符号是最经典的，若干每个字符用8个字节表示，一共也才16000位。为此，需要特殊的硬件来从内存读取字符，转换成光栅图形，这样才能显示到屏幕上，这个称为<strong>字符生成器（Character Generator）</strong>，基本算是第一代显卡。</p><p>显卡内部有一小块<strong>只读存储器（Read Only Memory，ROM）</strong>存着每个字符的图形，称为<strong>点阵图案（Dot Matrix Patter）</strong>。如果显卡看到某个字符对应的二进制代码，它就会把该字符的点阵图案通过光栅扫描的方式显示在屏幕的适当位置。为了显示，字符生成器会访问内存中一块特殊区域，这块区域专为图形保留，称为<strong>屏幕缓冲区（Screen Buffer）</strong>，程序想显示文字时，就直接修改保存在这个区域的值就行。字符生成器这种方案用的内存很少，但只能画字符到屏幕上，无法绘制任意形状。</p><p>传统的ASCII编码的字符集太小，做不了很复杂的事情，因此对ASCII进行扩展增加更多的新字符，比如用于DOS的IBM CP437字符集，有些系统还会用额外的bit来定义字体颜色和背景颜色。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-9d82eef96cc809355690e396d46873bf_720w.jpg" alt="img"></p><center>IBM CP437字符集</center>为了绘制任意形状，同时不会占用太多内存，就要使用CRT上的**矢量模式**。所有东西都是由一系列线条组成的，完全不需要有文本的概念，如果要显示文字，直接用画线的形式进行显示。我们使用一个早期适量显示系统Vectrex的命令为例<ol><li>首先使用RESET命令来清空屏幕， 同时将电子枪的绘图点移动到坐标(0,0)，也就是屏幕左上角，并将线的亮度设为0。</li><li>调用MOVE_TO 50 50，就会将绘图点移动到坐标(50,50)。然后使用INTENSITY 100将强度设为100， 然后反复调用以上命令就会绘制出对应图形。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-4820ddaa8ce054742f05ea0afbbabab9_720w.jpg" alt="img"></p><p>这些命令也就占160位，比直接保存一个像素矩阵好很多。</p><p>类似于之前的字符生成器把内存里的字符转换成图形一样，这些矢量指令也保存在内存中，通过<strong>矢量图形卡（Vector Graphics Card）</strong>画在屏幕上。然后通过数百个命令按序保存在屏幕缓冲区中，就能绘制出十分复杂的图形。并且因为这些矢量都在内存中，程序就可以更新这些值，让图形随时间进行变化，就出现了动画。</p><p>1962年诞生的Sketchpad是一个巨大的里程碑，它是一个交互式图形界面，用于计算机辅助设计（CAD），它被认为是第一个完整的图形程序。为了与图形界面进行交互，Sketchpad使用了输入设备——<strong>光笔</strong>，就是一个有线连着电脑的触控笔，笔尖用光线传感器，可以检测到显示器的刷新，并且通过判断刷新时间，电脑也可以知道笔所在的位置。使用光笔和各种按钮，用户可以画线和其他各种简单图案。</p><p><u>最早真正使用像素的计算机和显示器出</u>现于1960年代末。内存中的位对应屏幕上的像素，称为<strong>位图显示（Bitmapped Display）</strong>，通过对像素的控制，我们能够完全绘制任意的图形。可以将图形想象成是一个巨大像素值矩阵，之前计算机将像素数据保存在内存中一个特殊区域，称为<strong>帧缓冲区（Frame Buffer）</strong>，但是后来保存在特殊的高速<strong>视频内存（Video RAM，VRAM）</strong>中，这个VRAM是在显卡上，这样访问速度更快。</p><p>在一个分辨率是60x35的8位灰度屏幕上，我们可用的颜色范围是0到255。如果我们想把(10,10)处的像素设为白色，可以使用frambuffer [10] [10]=255， 如果我们想要从(30,0)到(30,35)画一条直线，可以使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FOR y&#x3D;0 TO 35</span><br><span class="line">    framebuffer[30][y]&#x3D;255</span><br><span class="line">NEXT</span><br></pre></td></tr></table></figure><p>使用相同方法，通过修改像素值就可以绘制任意图像。并且程序可以操纵帧缓冲区内的像素数据，来实现交互式图形。</p><h1 id="28、计算机网络"><a href="#28、计算机网络" class="headerlink" title="28、计算机网络"></a>28、计算机网络</h1><p>第一个计算机网络出现在1950-1960年代，通常在公司或研究室内部使用，方便信息交换，称为<strong>球鞋网络（Sneakernet）</strong>，第二个好处在于共享物理资源，比如，与其每台电脑配一台打印机，不如大家共享一台联网的打印机。并且早期网络也会共享存储空间，因为为每台计算机都配存储器太过昂贵。</p><p>计算机近距离构成的小型网络称为<strong>局域网（Local Area Network，LAN）</strong>，局域网能小到是同一间房间内的两台计算机，或者大到校园内的上千台电脑。</p><p>尽管开发和部署了很多不同的LAN技术，其中最著名的是<strong>“以太网（Ethernet）”</strong>，以太网的最简单形式是：一条以太网电线连接数台计算机，当一台计算机要传数据给另一台计算机时它以<strong>电信号</strong>形式，将数据传入电缆中，由于电缆是共享的，所以连接在同一个网络里的其他计算机都能看到数据，但是所有计算机都不知道这些数据是给自己的还是给别人的。<u>为了解决这个问题</u>，以太网需要每台计算机有唯一的<strong>媒体访问控制地址（Media Access Control Address，MAC Address）</strong>，然后将MAC地址作为数据的前缀发送到网络中，所以计算机只需要监听以太网电缆，只要看到自己的MAC地址，才去接收处理数据。现在制造的每台计算机都自带唯一的MAC地址，用于以太网和无线网络。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://pic4.zhimg.com/80/v2-bd0dfa011a483016ac431b355610fefb_720w.jpg" alt="img"></p><center>以太网</center>但是共享载体有个很大的**弊端**：当网络流量比较小时，计算机可以等待载体清空，然后再传输他们的数据。但随着网络流量上升，两台计算机想同时写入数据的概率也会上升，这称为**冲突（Collision）**，就会使得传输的数据混乱。幸好计算机能够监听电线里的信号来检测冲突，最简单的解决方案就是看到冲突就停止传输，等待网络空闲后再试一次，问题是其他计算机也是这样打算的，其他等待的计算机可能在任何停顿间隙就闯入开始传输数据，这就导致了越来越多的冲突。<p>以太网的<strong>解决方法</strong>是：当计算机检测到冲突后，就会在重传之前等待一小段时间（因为要举例，假设是 1 秒好了），当然 如果所有计算机用同样的等待时间 是不行的，它们会在一秒后再次冲突。所以加入一个随机时间 一台计算机可能等1.3秒，另一台计算机等待1.5秒 。要是运气好 等1.3秒的计算机会醒来发现载体是空闲的 然后开始传输 ，当1.5秒的计算机醒来后 会发现载体被占用会等待其他计算机完成 ，来相互避开。当然这个并不能完全解决问题，还需要用到<strong>另一个技巧</strong>。如果一台计算机在传输数据期间检测到冲突，就等待“1秒+随机时间”，但是如果再次发生冲突，就表明有网络拥塞，这次不等1秒，而是等2秒 ，如果再次发生冲突 等4秒 然后8秒 16秒等等，直到成功传输。因为计算机的退避，冲突次数会大幅减少，使得数据能够再次流动起来，网络就变得顺畅了。<u>这种指数级增加等待时间的方法</u>称为<strong>指数退避（Exponential Backoff）</strong>，很多以太网和WiFi都用到这个技术。</p><p>但是即使有了以上的技术，想用一根网线连接整个大学的计算机还是不可能的，为了减少冲突同时提高效率，我们<u>需要减少同一载体中设备的数量</u>，载体和其中的设备总称为<strong>冲突域（Collision Domain）</strong>。以之前以太网为例，一根电缆连接了6台计算机，这个称为一个冲突域。为了减少冲突，我们可以用<strong>交换机（Switch）</strong>将它拆成两个冲突域。交换机位于两个更小的网络之间，在必要时才在两个网络之间传输数据，并且交换机会记录一个<strong>列表</strong>，写着哪个MAC地址位于哪边网络，所以当MAC A想要传数据给MAC C，交换机就不会将数据传到另一边的网络，同理如果MAC E传输数据给MAC F，交换机也不会将数据传到上面的网络，这使得两边的传输能同时进行。但是如果MAC F想传数据给A，数据就会通过交换机，使得两个网络都会被短暂占用。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/v2-059e0333f1ad801bb826f3f89afeb0a7_720w.jpg" alt="img"></p><center>一个以太网中加入一个交换机</center>即使最大型的网络——**互联网（Internet）**也是这样构建起来的，本质还是多个连在一起的稍小一点的网络，使得不同网络间可以传递数据。而大型网络有一个特点，从一台主机到另一台主机通常有多条线路（**解决的主要问题**），这就引出了另一个话题——**路由（Routing）（用来选择合适路线的方法）**。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/v2-618cd9d33b6ca884945143c2d8e3810e_720w.jpg" alt="img"></p><center>大型网络，两台主机之间存在多条线路</center>连接两台相隔遥远的计算机或网络，最简单的方法是分配一条专门的<u>通信线路</u>，早期的电话系统就是这样运作的，这种方法称为**电路交换（Circuit Switching）**，因为是对整个电路进行修改，来连接到正确目的地，所以这种方法不灵活且价格昂贵，并且总有闲置的路线。但是好处是你可以最大限度随意使用，无需共享。因此军队、银行和其他一些机构依然会购买专门线路来连接数据中心。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229164213580.png" alt="image-20200229164213580"></p><center>电路交换</center>传输数据的另一种方法是**报文交换（Message Switching）**，就像邮政系统一样。不像之前A和B之间有一条专有线路，这里消息会经过好几个站点，就类似于邮寄信封，信封会通过一个个中转站最终到达收件人手中，每个站点都知道下一站要发往哪里，因为站点都有自己一个**表格**，用来记录到达各个目的地，信件要如何传递。报文交换的**好处**是你可以用不同的路由，使得通信更可靠。比如如果其中一个城市由于降雪无法接收邮件时，就能换到另一个城市继续传递数据。这里，城市就相当于网络中的路由器一样。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229163941432.png" alt="image-20200229163941432"></p><center>报文交换</center>> 交换机是连接若干个主机的机器，用来解决冲突域问题。 > > 路由器是连接主机、路由器、交换机的机器，用来构建数据传输的线路。<p>信息沿着路由跳转的次数称为<strong>跳数（Hop Count）</strong>，通过记录跳数，可以分辨出路由问题。比如当路由A认为到达目的地最快的下一个路由是B，就将信息传递给路由B，而路由B则认为到达目的地最快的下一个路由是A，又将信息传递回给了路由A，这就使得信息在路由A和B之间踢皮球，但是这种错误可以通过在信息中实时记录的跳数来解决，如果某条信息的跳数很大，就说明路由有出问题，这个称为<strong>跳数限制（Hop Limit）</strong>。</p><p>而报文交换的<strong>缺点</strong>之一就是当报文较大时，会堵塞网络，因为这里要求将<u>整个报文</u>从一个路由传到下一个路由后，才能继续传递其他报文，当传输大报文时，其他报文要么等待它传递完，要么选择另一条效率较低的路线。<u><strong>解决</strong></u>方法就是将大报文分成很多小块，称为<strong>数据包（Packet）</strong>。和报文交换一样，每个数据包都有网络中的目的地址，因此路由器知道要发送到哪里，这个地址的具体格式由<strong>互联网协议（Internet Protocol，IP）</strong>定义。每个联网的计算机都需要一个<strong>IP地址（IP Address）</strong>，例如<code>172.217.7.238</code>。</p><blockquote><p>MAC地址用来标识每条计算机，而IP地址是对数据包而言的。</p></blockquote><p>路由器会平衡与其他路由器之间的负载，来确保传输可以快速可靠，称为<strong>拥塞控制 （Congestion Control）</strong>。有时候一个报文的多个数据包会经过不同线路，使得到达顺序也可能不相同，这对一些软件来说是存在问题的。幸运的是，在IP之上还有其他协议，<u>比如TCP/IP可以解决乱序问题</u>。</p><p>将数据拆分成多个小数据包，然后通过灵活的路由传递，非常高效且容错率高，这种方法称为<strong>分组交换（Packet Switching）</strong>。它的好处是可以去中心化，就没有单点失败问题。</p><p>如今全球的路由器协同工作，找出最高效的线路，用各种标准协议传输数据，比如<strong>因特网控制信息协议（Internet Control Message Protocol，ICMP）</strong>和<strong>边界网关协议（Border Gateway Protocol，BGP）</strong>。</p><p>网络是一堆管子组成的吗？ 额 算是吧。</p><h1 id="29、互联网"><a href="#29、互联网" class="headerlink" title="29、互联网"></a>29、互联网</h1><p>任意计算机都和一个巨大的分布式网络连接在一起，称为<strong>互联网（Internet）</strong>。</p><p>当你在家中通过计算机观看网上视频时，你的计算机首先需要连接到<strong>局域网LAN</strong>，这个局域网是由家里WiFi路由器连接的所有设备组成的。然后家里的局域网再通过路由器连接到<strong>广域网（Wide Area Network，WAN</strong>），广域网的路由器一般属于你的<strong>互联网服务提供商（Internet Service Provider，ISP）</strong>。在广域网里，首先会有一个区域性路由器，比如覆盖你所在街区的一个路由器，然后该路由器会连接到一个更大的广域网中，比如覆盖你所在的城市，可能再跳跃几次，最终会到达互联网主干，一般由一群超大型、带宽超高的路由器组成。</p><blockquote><p>即首先会连接到你家里的WiFi路由器构建的局域网，然后该路由器再连接到ISP提供的广域网中，该广域网是由很多层层递进的路由器构成的。</p></blockquote><p>比如要从YouTube中获得视频，数据包首先会到达互联网主干，沿着主干到达对应保存该视频文件的YouTube服务器，可能这里会跳4次到达互联网主干，然后跳两次穿过互联网主干，最终再跳4次到达YouTube服务器，所以总共会跳跃10次。</p><p>我们可以通过<code>traceroute</code>来看跳跃了几次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Windows上的Traceroute</span><br><span class="line">1.按开始按钮</span><br><span class="line">2.输入“ CMD”，然后按“ Enter”</span><br><span class="line">3.在命令提示符下，键入“ tracert dftba.com”</span><br><span class="line"></span><br><span class="line">在Mac上的Traceroute</span><br><span class="line">1.点击“转到”下拉菜单</span><br><span class="line">2.点击“实用程序”</span><br><span class="line">3.打开终端</span><br><span class="line">4.键入“ traceroute dftba.com”</span><br><span class="line"></span><br><span class="line">Linux上的Traceroute</span><br><span class="line">1.通过键入CTRL + Alt + T打开终端</span><br><span class="line">2.输入：“ traceroute dftba.com”</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229165556176.png" alt="image-20200229165556176"></p><center>通过traceroute查看到dftba.com中转的次数</center>经历了11次中转。<p>但是数据包到底是怎么传递过去的呢？如果传输时数据包丢失了，会发生什么？当我们在浏览器中输入网址时，浏览器怎么知道服务器的地址是什么呢？</p><p>就像上节介绍的，互联网是一个巨大分布式网络，如果要发送的数据较大，分组传输就会将数据拆成一个个较小的数据包进行传输。其中数据包要想在互联网上进行传输，就要符合<strong>互联网协议（Internet Protocol，IP）</strong>。类似于邮寄手写信一般，每封信都需要一个地址，并且地址必须是唯一的，并且信的大小和重量也是有限制的，否则信件就无法送达。IP数据包也是如此，因为IP是一个非常底层的协议，数据包的头部只包含目标地址（IP地址），意味着当数据包到达对方电脑时，计算机不知道要把数据包交给哪个程序（比如QQ或微信），因此需要在IP之上，开发更高级的协议。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229170514722.png" alt="image-20200229170514722"></p><center>数据包的结构</center>最简单常见的协议称为用户数据报协议（User Datagram Protocol，UDP）。UDP也有头部，位于data payload里面，在data之前。UDP头部里面包含了很多有用的信息，其中之一就是**端口号（Port Number）**，每个想访问网络的程序都要向操作系统申请一个端口号。所以当数据包到达时，接收方的操作系统会读取UDP头部里的端口号，来确定该数据包是要交给哪个软件的。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229170831643.png" alt="image-20200229170831643"></p><center>UDP</center>比如 Skype 会申请端口 3478，当一个数据包到达时接收方的操作系统会读 UDP 头部，读里面的端口号如果看到端口号是 3478，就把数据包交给 Skype。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229171417934.png" alt="image-20200229171417934"></p><center>端口号</center>![image-20200229170954885](assets/image-20200229170954885.png)<blockquote><p>IP协议通过IP地址把数据包送到正确的计算机内；UDP通过数据包里的端口号送到正确的程序。</p></blockquote><p>同时UDP的头部中还有<strong>校验和（Checksum）</strong>，通过对数据求和来检查数据是否正确。假设UDP数据包里原始数据是<code>89 111 33 32 58 41</code>， 最简单的计算校验和的方式就是，在发送数据包之前，计算机会把所有数据加在一起，计算出校验和364。在UDP中，校验和是以16位形式存储的，如果计算出来的和超过16位能表示的最大值，则高位数会被丢弃，只保留低位。当接收方计算机接收到这个数据包时，也会重复以上过程，如果计算出来的校验和和UDP中保存的校验和相同，代表数据是正常的，否则数据是出错的。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/v2-9211cf69881af0f8ba2e4a8e8b5ce8ee_720w.jpg" alt="img"></p><p>但是，UDP不提供数据修复或数据重发机制，当接收方知道数据损坏后，一般只是丢弃这个数据包。并且当发送方使用UDP协议发送数据包时，是无法得知数据包是否到达目的地的。有些程序并不在意以上问题，因为UDP十分简单且快速。比如<u>视频</u>通常使用UDP协议，当数据包丢失时，也就造成视频卡顿。</p><p>但是有些数据不能接受数据包丢失的问题，比如发送电子邮件时，所有数据必须到达，所以就需要<strong>传输控制协议（Transmission Control Protocol，TCP）</strong>。和UDP一样，它的头部也保存在数据之前，人们通常将<u>IP协议和TCP协议</u>统称为<strong>TCP/IP协议</strong>。TCP的头部中也包含端口号和校验和，并且TCP协议还提供更高级的功能：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/v2-969988861bec7064179dd4e99b60dbf8_720w.png" alt="img"></p><center>TCP</center>1. TCP的数据包是<u>有序号</u>的，使得接收方可以通过这个序号将数据包排成正确顺序，即使到达时间不同。 2. TCP要求接收方的电脑收到数据包并校验和检查无误后，需要给发送方发送一个**确认码（Acknowledgement，ACK）**，代表数据包已经正确接收。当发送方接收到确认码后，就知道上一个数据包成功抵达了，发送方就会发送下一个数据包，如果这次发送方过了一段时间没有接收到确认码，则会重新发送一次。即使这里只是由于确认码延迟了，使得接收方那里有重复的数据包，但是通过序列号，可以直接删除重复的数据包。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229171954069.png" alt="image-20200229171954069"></p><p>并且数据包并不会一个个数据包进行传输，而是<strong>同时发送多个数据包</strong>，同时接收多个<strong>确认码(ACK)</strong>，这将大大提高效率，不用浪费时间等待确认码。并且通过确认码的成功率和来回时间，我们可以推测网络的拥塞程度，TCP通过这个信息，来调整同时发包数量来解决拥塞问题。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/v2-061760eadb27bb199a2a917547852efc_720w.jpg" alt="img"></p><p>简而言之，TCP可以处理乱序和丢包问题，并且可以根据拥塞情况自动调整传输率。</p><p>但是由于确认码数据包的存在，使得TCP需要传输的数据包数量翻了一倍，并且并没有传输更多信息，这对时间要求很高的程序代价太高，所以这类程序就会使用UDP协议（比如射击类游戏）。</p><p>当计算机访问一个网站时，需要两个东西<code>：IP地址（目标网站的地址）</code>和 <code>端口号（对应于你使用的计算机浏览器）</code>（例如：例如 <code>172.217.7.238 的 80 端口</code> 这是谷歌的 IP 地址和端口号）。但是通过IP地址访问网站十分不方便，所以互联网提供一个特殊服务，来将<strong>域名（Domain Name）</strong>和IP地址一一对应，称为<strong>域名系统（Dimain Name System，DNS）</strong>，一般DNS服务器都是由ISP提供的。当你在浏览器中输入网站域名时，浏览器就会去访问DNS服务器，DNS就会去查表，如果域名存在，则会返回浏览器对应IP地址，然后浏览器就会给这个IP地址发送TCP请求。</p><p>因为当前域名特别多，所以DNS不会将其保存成列表形式，而是将其保存成树状结构。最顶层是<strong>顶级域名（Top Level Domain，TLD）</strong>，比如<code>.com</code>和<code>.gov</code>；下一层是<strong>二级域名（Second Level Domain）</strong>， 比如<code>google.com</code>和<code>dftba.com</code>；再下一层是<strong>子域名（Sub-domain）</strong>，比如<code>images.google.com</code>等等。由于这个树结构特别大，因此这些数据分布在很多DNS服务器上，不同服务器负责树的不同部分。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229172611126.png" alt="image-20200229172611126"></p><center>域结构<center><p>总结上两节（28、29）的内容，其实计算机网络分成很多层次，接下来从最底层到最高层：</p><ol><li><strong>物理层（Physical Layer）</strong>，比如线路中的电信号，以及无线网络中的无线信号。</li><li><strong>数据链路层（Data Link Layer）</strong>负责操控物理层，其中包含MAC地址、冲突检测、指数回退以及其他一些底层协议。</li><li><strong>网络层（Network Layer）</strong>负责各种报文交换和路由技术。</li><li><strong>传输层（Transport Layer）</strong>负责在计算机之间进行点到点的传输，还会检测和修复错误，比如UDP和TCP协议。</li><li><strong>会话层（Session Layer）</strong>会使用TCP和UDP来创建连接，传递信息，然后关掉连接。</li></ol><p>以上是<strong>开放式系统互联通信参考模型（Open System Interconnection model，OSI）</strong>下的5层，这个框架将网络通信划分成了很多层，每一层处理各自的问题。这种抽象可以使得分工改进多个层，而无需考虑整体复杂性。并且OSI还有额外两层：<strong>表示层（Presentation Layer）</strong>和<strong>应用层（Application Layer）</strong>，在下一节中进行介绍。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229172753982.png" alt="image-20200229172753982"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229172822261.png" alt="image-20200229172822261"></p><h1 id="30、万维网"><a href="#30、万维网" class="headerlink" title="30、万维网"></a>30、万维网</h1><p>前两节介绍的东西共同组成了互联网，这一节将向上抽象一层，来讨论<strong>万维网（World Wide Web）</strong>。万维网和互联网的概念完全不同，万维网是运行于互联网之上的，还有其他比如Skype、Instagram等也是运行在互联网之上的。<strong>互联网是用来传输数据的管道</strong>，各种程序都会使用到，<u>其中传输最多数据的程序就是万维网</u>，我们可以使用特殊的程序——<strong>浏览器（Web Browser）</strong>来访问万维网。</p><p>万维网的最基本单位是单个页面，里面包含内容，也有访问其他页面的链接，这些链接称为<strong>超链接（Hyperlink）</strong>。这些超链接形成巨大的互联网络，这也是万维网名字的由来。并且由于文字超链接的强大，它有一个特殊的名字——<strong>超文本（Hypertext）</strong>。如今超文本最常指向的是另一个页面，这些页面会被获取并由浏览器进行渲染。</p><p>为了使网页能够互相连接，每个网页需要一个唯一的地址，这个地址称为<strong>统一资源定位器（Uniform Resource Locator，URL）</strong>，比如<code>thecrashcourse.com/courses</code>就是一个页面URL。</p><p>当你访问<code>thecrashcourse.com</code>网址时，计算机首先会进行DNS查询，这里输入一个域名，然后DNS就会返回给浏览器对应的计算机IP地址。然后浏览器就会打开一个TCP连接到这个IP地址对应的计算机上，而这个计算机运行着一个特殊的软件——<strong>网络服务器（Web Server）</strong>，网络服务器的标准端口是80。此时，你的计算机就连接到了<code>thecrashcourse.com</code>对应的服务器了，下一步是向服务器请求<code>courses</code> 页面，这里就会用到<strong>超文本传输协议（Hypertext Transfer Protocol，HTTP）</strong>。</p><p>HTTP的第一个标准是1991年创建的HTTP 0.9，只有一个指令<code>GET</code> 。因为这里我们想要获取<code>courses</code>页面， 我们可以直接向服务器发送指令<code>GET/courses</code>， 该指令以ASCII编码发送到服务器，服务器会返回该网址对应的页面，然后浏览器就会将其渲染到屏幕上。如果用户点击了另一个链接，计算机就会重新发送一个GET请求。在之后的版本中，HTTP添加了新的状态码，会将其放在请求页面的前面，比如状态码200表示网页被正确找到了，状态码400-499代表客户端出错。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/v2-5c297a37758affab1974f221b51a678d_720w.jpg" alt="img"></p><p>因为超文本的存储和发送都是以普通文本形式进行的，编码可能是ASCII或者UTF-8，这样就无法表明什么是链接，什么只是普通的文本了，所以必须开发一种标记方法，因此出现了<strong>超文本标记语言（Hypertext Markup Language，HTML）</strong>，第一代HTML创建于1990年的0.8版本，有18种指令。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/v2-d1f17935f645f06fc006ff22a4d68d4b_720w.jpg" alt="img"></p><center>制作一个简单的网页</center>综上，网络浏览器可以和网络服务器沟通，不仅获取网页和媒体，并且还负责显示。<p>随着后期万维网日益繁荣，人们越来越需要搜索。起初人们会维护一个目录，来链接到其他网站，但是随着网络越来越大，人工编辑目录变得很不方便，所以开发了搜索引擎。</p><p>最早的搜索引擎是JumpStation，它有3个部分：</p><ol><li><p>通过爬虫来将新链接添加进自己的列表中。</p></li><li><p>不断扩张的索引，用来记录访问过的网页上出现了哪些词。</p></li><li><p>查询索引的搜索算法，比如输入了某个关键字，则包含这个关键字的网页就会显示出来。</p></li></ol><p>早期的搜索引擎的排名方式直接取决于搜索词在页面上的出现次数，但是有的网页会通过在页面中重复该关键字来提高排名。Google成名的很大原因就是提出了一种算法来解决这个问题，与其信任页面上的内容，搜索引擎会看其他网页有没有连接到这个网页。</p><p>最后提一个概念——<strong>网络中立性（Network Neutrality）</strong>，它指的是要对所有数据包都平等对待，速度和优先级都应该一样。</p><h1 id="31、计算机安全"><a href="#31、计算机安全" class="headerlink" title="31、计算机安全"></a>31、计算机安全</h1><p>计算机安全的范围和计算能力的发展速度一样快，我们可以把计算机安全，看成是保护系统和数据的<strong>保密性、完整性和可用性</strong>。</p><blockquote><p><strong>保密性（Secrecy）：</strong>只有有权限的人才能<strong>读取</strong>计算机系统和数据，比如黑客泄露别人的信用卡信息，就是攻击保密性。</p><p><strong>完整性（Integrity）：</strong>只有有权限的人才能<strong>使用和修改</strong>系统和数据，比如黑客假冒你发送邮件，就是攻击完整性。</p><p><strong>可用性（Availability）：</strong>有权限的人应该随时可以访问系统和数据，<strong>拒绝服务攻击（DDOS</strong>）就是黑客发送大量的假请求到服务器上，使得网站很慢或者直接挂掉，这就是攻击可用性。</p></blockquote><p>为了实现这三个目标，安全专家会从抽象层面想想敌人可能是谁，这个称为<strong>威胁模型分析（Threat Model）</strong>。模型会对攻击者有个大致的描述：能力如何、目标是什么、可能使用什么手段。攻击手段又称为<strong>攻击矢量（Attack Vector）</strong>。威胁模型分析能够让你为特定情境做好准备，不被可能的攻击手段所淹没。换句话说，要怎么保护，具体看要对抗谁。</p><p>通常威胁模型分析中，会以能力水平进行区分。在给定的威胁模型下，安全架构师要提供解决方案，来保持系统安全。</p><p>有很多保护计算机系统、网络和数据的方法。很多安全问题可以总结成<strong>两个问题</strong>：</p><ol><li>你是谁？</li><li>你能访问什么？</li></ol><p>权限应该给适合的人而拒绝错误的人，所以为了区分谁是谁，我们使用<strong>身份认证（Authentication）</strong>来让计算机得知使用者是谁。通常身份认证有三种，各有利弊：</p><ol><li><strong>你知道什么：</strong>这个是基于某种只有用户和计算机知道的秘密，比如用户名和密码。这是如今使用最广最容易实现的方法。但是如果黑客知道了你的密码就惨了，或者可以通过暴力攻击试了密码的所有可能来获取你的密码，有些系统会在你尝试若干次错误后阻止你继续尝试。即使增长密码也很容易破解，所以现在很多网站都要求大小写字母加特殊字符，来增加可能的密码。</li><li><strong>你有什么：</strong>这是基于用户特定的物体，比如钥匙和锁。这种方法可以避免被人猜中密码的问题，而且通常需要人在现场，所以远程攻击就更加困难了。</li><li><strong>你是什么：</strong>这是基于你，通过你自己的特征展示给计算机来进行验证，比如指纹识别器和红膜扫描仪，这些方法特别的安全，但是最好的识别技术十分昂贵。“你知道什么”和“你有什么”是确定性的，但是来自传感器的数据每次都不相同，所以“你是什么”是概率性的，系统可能认不出你，或者将其他人认成了你。并且这种方法另一个问题就是无法重设，你无法修改自己的指纹或者虹膜。</li></ol><p>每种方法都有优缺点，一般建议使用两种或两种以上的认证方式。</p><p>当系统知道了你是谁，接下来就需要知道你能访问什么，这个称为<strong>访问控制（Access Control）</strong>，因此需要一个规范，来说明谁能访问什么、修改什么和使用什么。这个可以通过<strong>权限（Permission）</strong>或<strong>访问控制列表（Access Control List，ACL）</strong>来实现，其中描述了用户对每个文件、文件夹和程序的访问权限。</p><blockquote><p>读权限：允许用户查看文件内容。</p><p>写权限：允许用户修改文件内容。</p><p>执行权限：运行用户运行文件。</p></blockquote><p>有些阻止需要不同层次的权限，则ACL的正确配置就十分重要。假设我们有三个访问级别：<strong>公开、机密和顶级机密</strong>。有个经典模型称为<strong>Bell-LaPadula模型</strong>，其中包含两条规则：</p><ol><li>用户不能<strong>read up</strong>，即不能读等级更高的信息。</li><li>用户不能<strong>write down</strong>，即用户不能写更低权限的信息，这样能避免高级别的信息不会泄漏到低级别的文件中。</li></ol><p>通过身份认证和权限控制，可以让计算机知道你是谁和你能访问什么，但是必须先保证做这些事的软硬件必须是可信的。但是仍然无法保证程序或计算机系统的安全，因为安全软件在理论上可能是安全的，但是实现时可能会不小心留下漏洞。但是我们有办法减少漏洞出现的可能性，比如一发现漏洞就马上修补。</p><p>大部分漏洞都是具体实现时出错了，所以为了减少执行错误，就要减少执行。系统级安全的圣杯之一是安全内核或可信计算机基础：一组尽可能少的操作系统软件，这个安全性是接近可验证的。</p><p>构建安全内核的挑战在于，要决定内核应该有什么（代码越少越好）。当最小化代码数量后，要是能保证代码是安全的，那就很好了。现在最好的验证代码安全性的手段是<strong>独立安全监察和质量验证（Independent Verification and Validation）</strong>，让一群安全行业内的软件开发者来审计代码，这也是为什么安全型代码几乎都是开源的。</p><p>但是即使这样，还是有可能被黑客攻破，因此程序开发者需要控制损失的最大程度，这个称为<strong>隔离（Ioslation）</strong>。要实现隔离，可以<strong>“沙盒”（sandbox）</strong>程序，操作系统通过给每个程序独立的内存块，使得别的程序是无法触及的，这样就能把程序放到沙盒中，即使沙盒被破坏了，也不会影响别的程序执行。并且一台计算机可以运行多个<strong>虚拟机（Virtual Machine）</strong>，使得每个虚拟机都在自己的沙盒中。</p><h1 id="32、黑客-amp-攻击"><a href="#32、黑客-amp-攻击" class="headerlink" title="32、黑客&amp;攻击"></a>32、黑客&amp;攻击</h1><p>黑客入侵最常见的方式不是通过技术，而是欺骗别人，这个称为<strong>社会工程学（Social Engineering）</strong>，通过欺骗别人来让人泄露秘密，或让人配置电脑系统来变得易于攻击。最常见的攻击是<strong>网络钓鱼（Phishing）</strong>，其次还有<strong>假托（Pretexting）</strong>，攻击者给某个公司打电话，假装是IT部门的人，攻击者的第一通电话一般会叫人转接，这样另一个接的时候，电话看起来就像内部的，然后让别人把电脑配置得易于入侵，或者让他们泄露机密信息，比如密码或网络配置。</p><p>邮件里带<strong>木马（trojan horse）</strong>也是常见手段，木马通常会伪装成无害的东西，比如照片或发票，但实际上是恶意软件，有的会偷数据，有的会加密文件。</p><p>如果攻击者无法用木马或电话欺骗，攻击者只能被迫使用其他手段，方法之一就是暴力破解，尝试所有可能的密码，直到进入系统，大多数现代系统会加长等待时间来抵御这种攻击，每次失败就加长等待时间，甚至超过一定次数后，完全封锁。现在出现了一种攻破方法称为<strong>NAND镜像</strong>，如果能物理接触到电脑，可以往内存上接几根线，复制整个内存，然后暴力尝试密码，直到设备让你等待。这时只要把复制的内容覆盖掉内存，本质上重置了内存，就不用等待，可以继续尝试密码。</p><p>如果无法物理接触到设备，就需要远程攻击，比如通过互联网，这一般需要攻击者利用系统漏洞，来获得某些能力或访问权限，称为<strong>漏洞利用（Exploit）</strong>。一种常见的漏洞利用叫<strong>缓冲区溢出（Buffer Overflow）</strong>，这里的缓冲区是指预留的一块内存空间，比如我们在系统登录界面输入用户名和密码，而系统是用缓冲区来存储输入值的，假设缓冲区大小为10，并且缓冲区前后肯定还有其他数据，当用户输入用户名和密码时，这些值就会被复制到缓冲区中来进行验证，而该方法会溢出缓冲区，比如输入超过10个字符的密码，会覆盖掉相邻的数据，有时会让程序或系统崩溃，因为重要值被垃圾数据覆盖掉了。这里只是让系统崩溃，但是攻击者可以输入有意义的新值到程序的内存中，比如把<code>is_admin</code>标志位的值改为true，有了任意修改内存的能力，黑客就可以绕过登录这类东西，甚至使用那个程序劫持整个系统。</p><p>有许多方法阻止缓冲区溢出，最简单的方法就是复制到内存之前先检查长度，称为<strong>边界检查（Bounds checking</strong>），许多现代编程语言都自带边界检查，程序也会随机存放变量在内存中的位置，这样黑客就不知道应该覆盖内存的哪部分，使得更容易让程序崩溃，而不是获得访问权限。程序也可以在缓冲区后，预留一些不用的空间，然后跟踪里面的值，看是否发生变化，来判断是否有攻击，这些不用的内存空间称为<strong>金丝雀（Canaries）</strong>。</p><p>另一种经典手段是<strong>代码注入（Code Injection）</strong>，最常用于攻击用数据库的网站。假设网页上有登录提示，当用户点击“登录”，输入文本就会发送服务器，服务器就会运行代码，检查用户名是否存在，如果存在就看密码是否匹配。为此服务器会执行一段sql查询代码，比如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">password</span> <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> username=<span class="string">'___'</span>;</span><br></pre></td></tr></table></figure><p>这里语句就是要从<code>users</code>表中查找<code>username</code>为<code>___</code>的密码<code>password</code>。 这里的<code>___</code>就是用户输入的用户名。由此攻击者就能把sql命令输入到用户名中，比如<code>whatever&#39;;DROP TABLE users;&#39;</code>，这时上面的查询语句就会变成</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">password</span> <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> username=<span class="string">'whatever'</span>;<span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">users</span>;';</span><br></pre></td></tr></table></figure><p>如果服务器存在用户名<code>wharever</code>，数据库就会返回密码， 当然我们无法得知密码是什么，所以服务器会拒绝我们；如果不存在用户名<code>wharever</code>，服务器会返回空密码或者直接错误，服务器也会拒绝我们。 但是我们关心的是后面的代码<code>DROP TABLE users;</code><strong>这个是我们注入的命令</strong>，这个命令是删掉users这张表。如今几乎所有服务器都会防御这种手段。</p><p>程序员需要认识到从外界输入的信息都是危险的，必须要好好检查，很多用户名和密码表单，不会让你直接输入特殊符号，比如分号或括号，来作为第一道防御。好的服务器也会清理输入，比如修改或删除特殊字符，然后才放到数据库查询语句中。</p><p>当软件制造者不知道的新漏洞被发现时，称为<strong>0day漏洞（Zero Day Vulnerability）</strong>，黑客就会抢在白帽程序员做出补丁之前尽可能利用漏洞。</p><p>如果有足够多的电脑有漏洞，让恶意程序可以自动地在电脑之间互相传播，称为<strong>蠕虫（Worm）</strong>。如果黑客拿下大量电脑，这些电脑可以组成<strong>僵尸网络（Botnet）</strong>，可以用于很多目的，比如发大量垃圾邮件等，用别人电脑的计算能力来挖比特币，或发起DDOS来攻击服务器。DDOS就是僵尸网络里的所有电脑发一大堆垃圾信息到服务器上，造成服务器的阻塞。</p></center></center>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《计算机科学速成课》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnCpp chapter4</title>
      <link href="/archives/c1a4eb67.html"/>
      <url>/archives/c1a4eb67.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapter4</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h2 id="4-1-基本的数据类型"><a href="#4-1-基本的数据类型" class="headerlink" title="4.1 基本的数据类型"></a>4.1 基本的数据类型</h2><ul><li><p>内存最小的单位是一个<strong>二进制数(binary digit)</strong>，即<strong>位(bit)</strong>。它可以存储一个0或者1。</p><blockquote><p>就像传统的电灯开关一样——灯开着(1)，灯关着(0)</p></blockquote></li><li><p>由连续的单元组成的内存，叫<strong>内存地址(memory addresses)</strong>，简称<strong>地址(addresses)</strong></p></li><li><p>现代计算机中，“位”是没有它自己的内存地址的。而是用一个“<strong>字节(byte)</strong>”来表示一个内存地址。</p><blockquote><p>因为内存地址是比较有限的，而且需要逐“位”访问数据的情况很少。</p><p><strong>字节</strong>是作为一个单位来操作的一组”位(bit)”。现代标准规定：一个字节由<strong>8个</strong>连续的<strong>位</strong>组成。</p></blockquote><p>下面的图片显示了一些连续的内存地址，以及相应的数据字节:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/MemoryAddresses.png" alt="MemoryAddresses"></p></li><li><p><strong>数据类型(Data types)</strong>，简称“<strong>类型(type)</strong>”</p><ul><li><p>我们使用<strong>数据类型</strong>来告诉编译器如何以某种有意义的方式解释内存的内容。</p><blockquote><p>如：当我们声明一个变量的类型为 整型(integer)时，就相当于告诉内存“<strong>这个变量使用的内存段将被解释为一个整数值</strong>”</p></blockquote></li><li><p>给对象(object)一个值(value)时，编译器和CPU就负责将您的值 编码(encode)为该数据类型的适当的位序列，并存储在内存中。<u>【记住：内存只存储<strong>位(bits)</strong>】</u></p><blockquote><p>如：给一个整型对象赋一个值,65。这个值就被转换为bits：<code>0100 0001</code>，并被存储在分配给对象的内存中。</p></blockquote></li><li><p>当这个对象被求值，产生一个值时，这个 位序列(sequence of bits) 被重新构造成原来的值。</p><blockquote><p>意思就是：<code>0100 0001</code>被转换回 值65.</p><p>幸运的是，这些转换工作都是由 编译器 和 CPU 来完成的。</p></blockquote></li></ul></li><li><p><strong>基本数据类型(fundamental data types)</strong>，但通常被非正式地称为<strong>基本类型(basic types)</strong>、<strong>基本类型(primitive types)</strong>或<strong>内置类型(built-in types)</strong>。</p><p>下面是一些基本数据类型：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200330175227962.png" alt="fundamental data types"></p><blockquote><p>1、注意：<strong>integer vs integral</strong>：<em>integral</em>即比<em>integer</em>范围更广</p><ul><li><strong>integer：表示整数，即正整数、负整数、0；</strong></li><li><strong>integral：包含了 integer、boolean(布尔型)、字符类型</strong>。</li></ul><p>他们两个名字比较相近，是因为：<u>integral类型在内存中存储形式是和integer一样</u>。</p><hr><p>2、 <strong><code>_t</code>后缀</strong></p><p>这个后缀，表示“类型”的意思。</p></blockquote></li></ul><h2 id="4-2-Void"><a href="#4-2-Void" class="headerlink" title="4.2 Void"></a>4.2 Void</h2><ul><li><p>void是最简单的类型，<strong>void</strong>，即“没有类型”</p></li><li><p>变量不能定义为void类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> value; <span class="comment">// won't work, variables can't be defined with a void type</span></span><br></pre></td></tr></table></figure></li><li><p>void用途：</p><ol><li><p><strong>Functions that do not return a value（函数不返回值）</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeValue</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">// void here means no return value</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The value of x is: "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="comment">// no return statement, because this function doesn't return a value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Functions that do not take parameters(函数中不带参数)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">void</span>)</span> <span class="comment">// void here means no parameters</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者这种形式【在C++中，推荐写这种形式】</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="comment">// empty function parameters is an implicit void</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="4-3-对象大小-amp-sizeof操作符"><a href="#4-3-对象大小-amp-sizeof操作符" class="headerlink" title="4.3 对象大小&amp;sizeof操作符"></a>4.3 对象大小&amp;sizeof操作符</h2><p><strong>对象的大小</strong>：</p><ul><li><p>对象的大小取决于它的数据类型</p></li><li><p>通常通过<strong>变量名访问内存</strong>，<strong>而不是直接通过内存地址</strong>。</p></li><li><p>1个bit(位)可以容纳2个可能的值，0或1；…….</p><blockquote><p><strong>即，具有n位(bits)的对象，可以容纳2^n 个可能的值。</strong></p></blockquote><p>因此，对象的大小限制了它可以存储的唯一值的个数。</p></li><li><p>每次定义一个对象时，<strong>只要该对象存在，就会使用一小部分空闲内存</strong>。</p></li></ul><p><strong>基本数据类型的大小</strong>：</p><ul><li><p>给定数据类型的大小<strong>取决于编译器 和/或 计算机体系结构!</strong></p><p>C++只保证每个基本数据类型的大小都是最小的：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200331095627896.png" alt="image-20200331095627896"></p><blockquote><p><strong>然而，这些类型的大小在不同的计算机上可能会不一样。</strong>比如，有些机器上的int大小为4 bytes</p></blockquote></li></ul><p><strong>操作符“sizeof”</strong></p><p>为了能够在计算机上直到类型的大小，C++提供了<strong>“sizeof”</strong>操作符来确认类型的大小。</p><blockquote><p><strong>sizeof：是一个一元操作符，它接受 类型 或 变量，然后返回它的大小(bytes)</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"bool:\t\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">bool</span>) &lt;&lt; <span class="string">"bytes\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"char:\t\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">char</span>) &lt;&lt; <span class="string">"bytes\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"wchar_t:\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">wchar_t</span>) &lt;&lt; <span class="string">"bytes\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"char16_t:\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">char16_t</span>) &lt;&lt; <span class="string">" bytes\n"</span>; <span class="comment">// C++11 only</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"char32_t:\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">char32_t</span>) &lt;&lt; <span class="string">" bytes\n"</span>; <span class="comment">// C++11 only</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"short:\t\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(short) &lt;&lt; <span class="string">" bytes\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"int:\t\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="string">" bytes\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"long:\t\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span>) &lt;&lt; <span class="string">" bytes\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"long long:\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>) &lt;&lt; <span class="string">" bytes\n"</span>; <span class="comment">// C++11 only</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"float:\t\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">float</span>) &lt;&lt; <span class="string">" bytes\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"double:\t\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">double</span>) &lt;&lt; <span class="string">" bytes\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"long double:\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">double</span>) &lt;&lt; <span class="string">" bytes\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//避免在visual studio 中运行时 闪过</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>运行结果会因为不同类型的机器or编译器，而出现差异。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200331101214364.png" alt="image-20200331101214364"></p><h2 id="4-4-有符号整型"><a href="#4-4-有符号整型" class="headerlink" title="4.4 有符号整型"></a>4.4 有符号整型</h2><ul><li>C++中有四种整型的类型：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200331101704637.png" alt="image-20200331101704637"></p><ul><li><p><strong>Signed integers(有符号整型)</strong></p><p>如：+1、-1、0这种都属于 有符号整型。</p><ul><li><p><strong>定义有符号整型：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【推荐】</span></span><br><span class="line">short s;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">long</span> i;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//除了int，其它类型也可以这样写：</span></span><br><span class="line">short <span class="keyword">int</span> s;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">long</span> liong i;</span><br><span class="line"><span class="comment">//这种【不推荐】，使用“int”后缀不利于观看</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以使用 signed前缀</span></span><br><span class="line"><span class="keyword">signed</span> shrt s;</span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">long</span> i;</span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">long</span> <span class="keyword">long</span> i;</span><br><span class="line"><span class="comment">//【不推荐】，因为signed冗余，不利于辨认</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>有符号整型的范围</strong></p><p>数据类型可以容纳的一组特定值，叫做：<strong>range(范围)</strong></p><blockquote><p>整型变量的“<strong>范围</strong>”的决定因素：</p><ol><li>该类型本身的大小；</li><li>该类型是否是 有符号 的。</li></ol><p>比如，大小为1字节的有符号整型，它的范围是：-128~127(包含范围的两端)，即它可以存储2^8=256 个可能的整数。</p></blockquote></li></ul><p>这是一个包含不同大小有符号整数范围的表:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200331104055635.png" alt="image-20200331104055635"></p><blockquote><p>小结，一个有 <strong>n</strong>-bits的 有符号变量，它可存储值的范围是：<strong>-(2^n-1^) ~ (2^n-1^ -1)</strong></p></blockquote><ul><li><p><strong>整数溢出</strong>，简称：<strong>溢出</strong></p><p>如果我们把值280,存储在 1个字节的有符号整型 中，他就会发生 <strong>溢出</strong>现象。此时，<strong>数据丢失是因为对象没有足够的内存来存储所有东西。</strong></p></li></ul><h2 id="4-5-无符号整型"><a href="#4-5-无符号整型" class="headerlink" title="4.5 无符号整型"></a>4.5 无符号整型</h2><center>不推荐使用</center><p><strong>无符号整型：unsigned integer。</strong>不能存储“负数”，<strong>可以存储：0 和 正整数</strong></p><ul><li><p><strong>定义无符号整型变量</strong></p><p>要定义无符号整数，我们使用<strong>unsigned</strong>关键字。按照惯例，这是放在前面的类型:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> short us;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ui;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> ul;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br></pre></td></tr></table></figure></li><li><p><strong>无符号整型范围</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200331105315653.png" alt="Unsigned integer range"></p><blockquote><p>一个有 n-bits 的无符号整型变量，它可存储的范围是：<strong>0 ~ (2^n^)-1</strong></p></blockquote><p>当不需要负数时，无符号整数非常适合于网络和内存很少的系统，<strong>因为无符号整数可以存储更多的正数而不占用额外的内存。</strong></p></li></ul><ul><li><p><strong>无符号整数的溢出：Unsigned integer overflow</strong></p><p>无符号整数不会溢出。<em>如果一个值超过范围，那么它会除以一个比这个范围大的数，然后将余数存起来。</em></p><ul><li><p><strong>正数溢出</strong></p><blockquote><p>如，在 1byte的范围中，存储数据。</p><ul><li>280在 范围为 1个字节 的整型中存储，因280&gt;255。所以，它会除以256(比 1个字节的范围的最大值大1，即比255大1的数，256)。280/256=24，<strong>所以存储的是24</strong>.</li><li>存储256。256&gt;255。则进行 256/256 = 0，<strong>即相当于存储 0</strong></li><li>存储257。257&gt;255。则进行 257/256 = 1，<strong>即相当于存储 1</strong></li></ul></blockquote><p>看一个程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> short x&#123; <span class="number">65535</span> &#125;; <span class="comment">// 最大的16位无符号值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x was: "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    x = <span class="number">65536</span>; <span class="comment">// 65536 is out of our range, so we get wrap-around</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x is now: "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    x = <span class="number">65537</span>; <span class="comment">// 65537 is out of our range, so we get wrap-around</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x is now: "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200331131152778.png" alt="image-20200331131152778"></p><hr></li></ul></li></ul><ul><li><p><strong>负数溢出</strong></p><p>虽然，无符号整数的范围是0~255(假如在 1byte的范围).但是我们不小心在无符号整型中输入了 负数，应该怎么办呢？</p><p>比如，当输入 -1 时。-1不在 0~255这个范围中。此时就循环到这个范围的顶部（最大值处），即 255。所以，在 1 byte 的范围的无符号整数中，<strong>输入 -1 ，存储的是 255。</strong></p><p><strong>输入-2，存储的是254。（从最顶部往回循环）</strong></p></li></ul><h2 id="4-6-固定宽度的整数和size-t"><a href="#4-6-固定宽度的整数和size-t" class="headerlink" title="4.6 固定宽度的整数和size_t"></a>4.6 固定宽度的整数和size_t</h2><p>之前讲了整型变量的最低size，其实他们可以按照不同的系统变得更大。</p><ul><li><p>为什么不固定整型变量的大小？</p><p>因为在C语言中，为了提高性能，C故意保持整数的大小是开放的，这样编译器实现者就可以为 int 选择一个在目标计算机架构上表现最好的大小。</p></li><li><p><strong>固定宽度的整型</strong></p><p>为了实现跨平台，C99定义了一系列的<strong>固定宽度的整型</strong>(在头文件<code>stdint.h</code>中)，使得在任何平台中的大小都一致。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200331142942242.png" alt="Fixed-width integers"></p><blockquote><p><strong>在C++11中的头文件<code>cstdint</code>中，也包含了上述的固定宽度整型。他们在命名空间<code>std</code>中定义的。</strong></p><p>如;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="keyword">int16_t</span> <span class="title">i</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>应该避免上述固定宽度的整数，因为它们可能不是在所有目标体系结构上定义的。</p></li></ul><hr><ul><li><p><strong>fast &amp; least 整型</strong>：快类型 &amp; 小类型</p><p>为了帮助解决上述缺点，c++ 11还定义了两个可选的整数集。</p><ol><li><p>*<em>fast type *</em></p><p><strong>无符号</strong>格式为： std::<strong>int_fast#_t</strong> ；<strong>有符号</strong>格式：std::<strong>uint_fast#_t</strong></p><p>它提供一个整型，它提供一个在你的机器上<u>表现得性能最好的宽度</u>，但是它的宽度最小是“# <strong>bits</strong>”（# = 8，16，32，or 64 <strong>bit</strong>）</p><blockquote><p>如：<code>std::int_fast32_t</code>将会给你一个最小为 32bits 的无符号整型</p></blockquote></li><li><p><strong>least type</strong></p><p><strong>无符号</strong>格式为： std::<strong>int_least#_t</strong> ；<strong>有符号</strong>格式：std::<strong>uint_least#_t</strong></p><p>它提供一个整型类型，它提供一个<u>最接近于</u>“# <strong>bits</strong>”的宽度，但是它的宽度最小是“# <strong>bits</strong>”（# = 8，16，32，or 64 <strong>bit</strong>）</p></li></ol><blockquote><p>小结：<strong><u>比较：<code>int#\_t</code>、<code>int_fast#_t</code>、<code>int_least#_t</code>的差异</u></strong>：</p><ul><li><code>int#_t</code>的bits(位数)是固定的，即有“# bits”；</li><li><code>int_fast#_t</code> 和 <code>int_least#_t</code>的bits(位数)最少有““# bits”；</li></ul><p>example：</p><p><code>int16_t</code>：是固定的16位的整型；</p><p><code>int_fast16_t</code>：可能转变成了64位的整型。（因为在你的机器上，64位整型最快了）</p><p><code>int_least16_t</code>：可能转变成了32位的整型。（假设因为你的系统中没有16位的整型，而32位此时<strong>是最接近</strong>16位 的整型了）</p></blockquote></li></ul><hr><ul><li><p>注意：<strong><code>std::int8_t</code>和<code>std::uint8_t</code><u>是char类型</u>，而不是integer</strong></p><p>在C++中，很多编译器对<code>std::int8_t</code>和<code>std::uint8_t</code>（以及相应的fast 和 least 整型）的定义和对待方式 是与 <code>signed char</code>(有符号字符类型) 的方式相同。</p><p>但是，在某些系统中，它确实是整型的，而不是char类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">int8_t</span> myint = <span class="number">65</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; myint;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************/</span></span><br><span class="line">运行结果是： A</span><br></pre></td></tr></table></figure><blockquote><p>所以，我们要<strong>避免使用这几个整型类型</strong>。</p></blockquote></li></ul><hr><p><strong>最佳使用整型</strong></p><ul><li>当整型的大小不做要求时，使用<strong><code>int</code></strong>；</li><li>如果需要一个保证为特定大小的变量，并且希望<strong>提高性能</strong>，使用<strong><code>int_fast#_t</code></strong>；</li><li>如果您需要一个保证为特定大小的变量，并且希望<strong>优先考虑内存保护而不是性能</strong>，使用 <strong><code>int_least#_t</code></strong></li></ul><p><strong>尽量不要使用这些</strong>：</p><ul><li>无符号整型，Unsigned types；</li><li>8 bits 的固定宽度的整型类型；</li><li>任何特定于编译器的固定宽度整数（例如，visual studio 定义了 __int8 ，__int16 等等）</li></ul><hr><p><strong><code>std::size_t</code></strong>是什么？</p><blockquote><p>是一个无符号整数类型，通常用于表示对象的大小或长度。</p></blockquote><p>sizeof返回一个<code>std::size_t</code>类型的值。</p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************/</span></span><br><span class="line">结果是： <span class="number">4</span>  【这个<span class="number">4</span>，就是 <span class="built_in">std</span>::<span class="keyword">size_t</span>类型的】</span><br></pre></td></tr></table></figure><ul><li><p><code>size_t</code>本身大小也是不固定的，它确保是无符号的，并且至少是16位。但是在大多数系统中，它的大小将等于应用程序的地址宽度。</p><blockquote><p>比如，在32位应用程序中，<code>size_t</code>是一个 32 bits 的无符号整型；在64位应用程序中，<code>size_t</code>是一个 64 bits 的无符号整型。</p></blockquote></li></ul><h2 id="4-7-科学计数法"><a href="#4-7-科学计数法" class="headerlink" title="4.7 科学计数法"></a>4.7 科学计数法</h2><p><strong>scientific notation</strong></p><p>科学计数法的形式：<strong>a×10^exponent^</strong>。其中, a：只能是0~9的数（不包括0，但包括9）</p><blockquote><p>如：1.2×10^4^ 、 5.9736 x 10^24^</p></blockquote><p>在C++中，我们用字母<code>e</code>（大写<code>E</code>也可以）来代表 10；</p><blockquote><p>1.2×10^4^ -&gt; 1.2e4 ； 5.9736 x 10^24^ -&gt; 5.9736e24</p><p>小于1的分数0.05表示为： 5e-2</p></blockquote><hr><ul><li><p><strong>有效数字：significant digits</strong></p><blockquote><p><em>有效数字的数量定义了数字的精度。</em>(有效数字越多，数字越精确。)</p></blockquote><p>e前面的数就是有效数字，如<code>5.9736e24</code>的有效数字是：5.9736，即，5个有效数字</p></li></ul><h2 id="4-8-浮点数float"><a href="#4-8-浮点数float" class="headerlink" title="4.8 浮点数float"></a>4.8 浮点数<code>float</code></h2><center>永远不要假设浮点数是精确的。</center><ul><li><p>三种浮点型数据：<strong><code>float</code>、<code>double</code>、<code>long double</code></strong></p><blockquote><p>与整数一样，c++没有定义这些类型的实际大小(但它确实保证了最小大小)。在现代体系结构中，浮点表示几乎总是遵循IEEE 754二进制格式。在这种格式中：</p><p><code>float</code>：4字节；</p><p><code>double</code>：8字节，</p><p><code>long double</code>：可以等于一个<code>double</code>(<strong>8字节</strong>)、<strong>80 bits(通常填充为12字节)</strong>或者 <strong>16字节</strong>。</p></blockquote><p>浮点型数据通常是 <strong>有符号的(sign)</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200331194441574.png" alt="image-20200331194441574"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x&#123;<span class="number">5</span>&#125;; <span class="comment">//整型</span></span><br><span class="line"><span class="keyword">double</span> y&#123;<span class="number">5.0</span>&#125;; <span class="comment">//5.0是一个浮点型(没有后缀，默认情况下是double类型)</span></span><br><span class="line"><span class="keyword">float</span> z&#123;<span class="number">5.0f</span>&#125;; <span class="comment">//5.0是一个浮点型，f后缀表示浮点类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********/</span></span><br><span class="line">【注】浮点型数据默认是：<span class="keyword">double</span>类型的，加上后缀“f”表示是 <span class="keyword">float</span>类型</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>浮点型数据的输出</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">5.0</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">6.7f</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">9876543.21</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************/</span></span><br><span class="line">输出结果：</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6.7</span></span><br><span class="line"><span class="number">9.87654e+06</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>第一个，即使我们输入的是5.0，但它输出的依然是 5。【默认情况下，如果小数部分为0,std::cout将不会打印数字的小数部分。】</li><li>第二个输出正常；</li><li>第三个输出是科学记数的形式。</li></ul></blockquote></li></ul><hr><ul><li><p><strong>浮点型的范围</strong></p><p>根据 IEEE 754的表示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200331195509853.png" alt="image-20200331195509853"></p></li></ul><hr><ul><li><p><strong>浮点型的精度</strong></p><ul><li>浮点型的默认精度是6：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">9.87654321f</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">987.654321f</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">987654.321f</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">9876543.21f</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">0.0000987654321f</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******输出**********/</span></span><br><span class="line"><span class="number">9.87654</span></span><br><span class="line"><span class="number">987.654</span></span><br><span class="line"><span class="number">987654</span></span><br><span class="line"><span class="number">9.87654e+006</span></span><br><span class="line"><span class="number">9.87654e-005</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：<strong>根据编译器的不同，指数的位数会被填充</strong>。比如：“9.87654e+006”的指数位置就被填充为3位。</p><p><strong>显示的最小指数位数是特定于编译器的，在Visual Studio 中填充为 <code>3 位</code></strong></p></blockquote></li></ul><ul><li><p>浮点变量的精度位数取决于大小(浮点数的精度小于双精度)和存储的特定值(某些值的精度高于其他值)。</p><p>用 <code>iomanip</code>头文件中的函数 <em>std::setprecison</em>来覆盖std::cout显示的默认精度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt; // for std::setprecision()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">16</span>); <span class="comment">// show 16 digits of precision</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">3.33333333333333333333333333333333333333f</span> &lt;&lt;<span class="string">'\n'</span>; <span class="comment">// f suffix means float</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">3.33333333333333333333333333333333333333</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// no suffix means double</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******输出*********/</span></span><br><span class="line"><span class="number">3.333333253860474</span></span><br><span class="line"><span class="number">3.333333333333334</span></span><br></pre></td></tr></table></figure><blockquote><p>可以看出，<strong><code>double</code>类型的比<code>float</code>类型的精度更高</strong>。</p></blockquote></li></ul><ul><li><p>精度不仅影响小数部分，他还影响比较大的数的精度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt; // for std::setprecision()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> f &#123; <span class="number">123456789.0f</span> &#125;; <span class="comment">// f has 10 significant digits</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">9</span>); <span class="comment">// to show 9 digits in f</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********结果**********/</span></span><br><span class="line"><span class="number">123456792</span></span><br></pre></td></tr></table></figure><blockquote><p>123456789.0 的有效数字是10个，但是浮点型通常有7位精度(123456792的结果只能精确到7位有效数字)。</p><p>我们失去了一些精度!当由于无法精确地存储数字而丢失精度时，这称为<strong>rounding error(舍入误差)</strong>。</p></blockquote><p>小结：<strong>通常情况推荐使用<code>double</code></strong></p></li></ul><hr><ul><li><p><strong>无限循环 &amp; 非数字 ：NaN and Inf</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> zero &#123;<span class="number">0.0</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> posinf &#123; <span class="number">5.0</span> / zero &#125;; <span class="comment">// positive infinity</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; posinf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">double</span> neginf &#123; <span class="number">-5.0</span> / zero &#125;; <span class="comment">// negative infinity</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; neginf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">double</span> nan &#123; zero / zero &#125;; <span class="comment">// not a number (mathematically invalid)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; nan &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******结果************/</span></span><br><span class="line"><span class="number">1.</span>#INF</span><br><span class="line"><span class="number">-1.</span>#INF</span><br><span class="line"><span class="number">1.</span>#IND</span><br></pre></td></tr></table></figure><blockquote><p>INF代表无穷，IND代表不确定。</p><p>请注意，输出Inf和NaN的结果是特定于平台的，因此您的结果可能会有所不同。</p></blockquote></li></ul><hr><p>总结：</p><ol><li><strong>浮点数用于存储非常大或非常小的数字，包括那些具有小数部分的数字。</strong></li><li>浮点数通常有较小的<strong>舍入误差</strong>，即使该数的有效位数比精度小。很多时候，这些数据的舍入误差没有被注意到，因为它们非常小，而且由于输出而被截断。但是，<strong>对浮点数的比较可能不会得到预期的结果。对这些值执行数学运算将导致舍入误差增大。</strong></li></ol><hr><h2 id="4-9-布尔型bool"><a href="#4-9-布尔型bool" class="headerlink" title="4.9 布尔型bool"></a>4.9 布尔型<code>bool</code></h2><p>实际上，<em>Boolean values</em>(布尔值)存储的布尔变量，不是以<code>true</code>、<code>false</code>的形式。<strong>而是以整型类型存储的，即<em>true</em>对应整型<em>1</em>；<em>false</em>对应整型<em>0</em>。</strong></p><blockquote><p>即，布尔值被认为是一个整型类型。</p></blockquote><hr><ul><li><p><strong>输出布尔值</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="literal">true</span>&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="literal">false</span>&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">bool</span> b&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;b&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;!b&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************结果***********/</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><hr><p>如果你想输出“<em>true</em>、<em>false</em>”。你可以用<code>std::boolalpah</code>：</p><blockquote><p><code>std::noboolalpha</code>是关闭作用</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="literal">false</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha; <span class="comment">//print bools as ture or false</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="literal">true</span>&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="literal">false</span>&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果**********/</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>整型与布尔型的转换：Integer to Boolean conversion</strong></p><ul><li><p>*<u>不能</u>用整型数字来初始化bool变量*</p><p><code>bool b{4};</code> //error: 不允许这样转换</p></li><li><p>但是，整型变量可以转换为布尔型：</p><blockquote><p>整型 <em>0</em> 可以被转换为<em>false<em>；其他的非0 的整型可以被转换为</em>true</em></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha; <span class="comment">// print bools as true or false</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> b1 = <span class="number">4</span> ; <span class="comment">// copy initialization allows implicit conversion from int to bool</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b1 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> b2 = <span class="number">0</span> ; <span class="comment">// copy initialization allows implicit conversion from int to bool</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b2 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果**********/</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><ul><li><p><strong>输入布尔型值</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> b &#123;&#125;; <span class="comment">// default initialize to false (0)</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a boolean value: "</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; b;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"You entered: "</span> &lt;&lt; b;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter a Boolean value: true</span><br><span class="line">You entered: 0</span><br></pre></td></tr></table></figure><p>发现，<strong>布尔型值的输入，只接受：<em>0</em> 和<em>1</em></strong> (不是 true 或者 false)。所以，如果输入的值是<em>0</em> 和<em>1</em>之外的其他值，都是失败的，即false，所以是0。</p><blockquote><p>因为在C++11或者更新的标准中，<strong>一个失败的输入也会使变量变为0，所以b也会被赋值为0。</strong></p></blockquote></li></ul><hr><h2 id="4-11-char类型"><a href="#4-11-char类型" class="headerlink" title="4.11 char类型"></a>4.11 <code>char</code>类型</h2><p>char数据类型是<strong>整数类型</strong>，这意味着<u>底层值存储为整数</u>，并且保证<u>大小为1字节</u>。</p><p>但是，与将布尔值解释为true或false类似，<u>将char值解释为ASCII字符</u>。</p><blockquote><p><strong>ASCII</strong>是美国信息交换标准代码的缩写，它定义了一种特殊的方式来将英文字符(加上一些其他符号)表示为0到127之间的数字(称为ASCII码或代码点)。</p><p><strong>字符文字总是放在单引号之间</strong>。例如，ASCII码97被解释为字符“a”。</p></blockquote><p>下面是完整的ASCII字符表:</p><table><thead><tr><th align="left">Code</th><th align="left">Symbol</th><th align="left">Code</th><th align="left">Symbol</th><th align="left">Code</th><th align="left">Symbol</th><th align="left">Code</th><th align="left">Symbol</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">NUL (null)</td><td align="left">32</td><td align="left">(space)</td><td align="left">64</td><td align="left">@</td><td align="left">96</td><td align="left">`</td></tr><tr><td align="left">1</td><td align="left">SOH (start of header)</td><td align="left">33</td><td align="left">!</td><td align="left">65</td><td align="left">A</td><td align="left">97</td><td align="left">a</td></tr><tr><td align="left">2</td><td align="left">STX (start of text)</td><td align="left">34</td><td align="left">”</td><td align="left">66</td><td align="left">B</td><td align="left">98</td><td align="left">b</td></tr><tr><td align="left">3</td><td align="left">ETX (end of text)</td><td align="left">35</td><td align="left">#</td><td align="left">67</td><td align="left">C</td><td align="left">99</td><td align="left">c</td></tr><tr><td align="left">4</td><td align="left">EOT (end of transmission)</td><td align="left">36</td><td align="left">$</td><td align="left">68</td><td align="left">D</td><td align="left">100</td><td align="left">d</td></tr><tr><td align="left">5</td><td align="left">ENQ (enquiry)</td><td align="left">37</td><td align="left">%</td><td align="left">69</td><td align="left">E</td><td align="left">101</td><td align="left">e</td></tr><tr><td align="left">6</td><td align="left">ACK (acknowledge)</td><td align="left">38</td><td align="left">&amp;</td><td align="left">70</td><td align="left">F</td><td align="left">102</td><td align="left">f</td></tr><tr><td align="left">7</td><td align="left">BEL (bell)</td><td align="left">39</td><td align="left">’</td><td align="left">71</td><td align="left">G</td><td align="left">103</td><td align="left">g</td></tr><tr><td align="left">8</td><td align="left">BS (backspace)</td><td align="left">40</td><td align="left">(</td><td align="left">72</td><td align="left">H</td><td align="left">104</td><td align="left">h</td></tr><tr><td align="left">9</td><td align="left">HT (horizontal tab)</td><td align="left">41</td><td align="left">)</td><td align="left">73</td><td align="left">I</td><td align="left">105</td><td align="left">i</td></tr><tr><td align="left">10</td><td align="left">LF (line feed/new line)</td><td align="left">42</td><td align="left">*</td><td align="left">74</td><td align="left">J</td><td align="left">106</td><td align="left">j</td></tr><tr><td align="left">11</td><td align="left">VT (vertical tab)</td><td align="left">43</td><td align="left">+</td><td align="left">75</td><td align="left">K</td><td align="left">107</td><td align="left">k</td></tr><tr><td align="left">12</td><td align="left">FF (form feed / new page)</td><td align="left">44</td><td align="left">,</td><td align="left">76</td><td align="left">L</td><td align="left">108</td><td align="left">l</td></tr><tr><td align="left">13</td><td align="left">CR (carriage return)</td><td align="left">45</td><td align="left">-</td><td align="left">77</td><td align="left">M</td><td align="left">109</td><td align="left">m</td></tr><tr><td align="left">14</td><td align="left">SO (shift out)</td><td align="left">46</td><td align="left">.</td><td align="left">78</td><td align="left">N</td><td align="left">110</td><td align="left">n</td></tr><tr><td align="left">15</td><td align="left">SI (shift in)</td><td align="left">47</td><td align="left">/</td><td align="left">79</td><td align="left">O</td><td align="left">111</td><td align="left">o</td></tr><tr><td align="left">16</td><td align="left">DLE (data link escape)</td><td align="left">48</td><td align="left">0</td><td align="left">80</td><td align="left">P</td><td align="left">112</td><td align="left">p</td></tr><tr><td align="left">17</td><td align="left">DC1 (data control 1)</td><td align="left">49</td><td align="left">1</td><td align="left">81</td><td align="left">Q</td><td align="left">113</td><td align="left">q</td></tr><tr><td align="left">18</td><td align="left">DC2 (data control 2)</td><td align="left">50</td><td align="left">2</td><td align="left">82</td><td align="left">R</td><td align="left">114</td><td align="left">r</td></tr><tr><td align="left">19</td><td align="left">DC3 (data control 3)</td><td align="left">51</td><td align="left">3</td><td align="left">83</td><td align="left">S</td><td align="left">115</td><td align="left">s</td></tr><tr><td align="left">20</td><td align="left">DC4 (data control 4)</td><td align="left">52</td><td align="left">4</td><td align="left">84</td><td align="left">T</td><td align="left">116</td><td align="left">t</td></tr><tr><td align="left">21</td><td align="left">NAK (negative acknowledge)</td><td align="left">53</td><td align="left">5</td><td align="left">85</td><td align="left">U</td><td align="left">117</td><td align="left">u</td></tr><tr><td align="left">22</td><td align="left">SYN (synchronous idle)</td><td align="left">54</td><td align="left">6</td><td align="left">86</td><td align="left">V</td><td align="left">118</td><td align="left">v</td></tr><tr><td align="left">23</td><td align="left">ETB (end of transmission block)</td><td align="left">55</td><td align="left">7</td><td align="left">87</td><td align="left">W</td><td align="left">119</td><td align="left">w</td></tr><tr><td align="left">24</td><td align="left">CAN (cancel)</td><td align="left">56</td><td align="left">8</td><td align="left">88</td><td align="left">X</td><td align="left">120</td><td align="left">x</td></tr><tr><td align="left">25</td><td align="left">EM (end of medium)</td><td align="left">57</td><td align="left">9</td><td align="left">89</td><td align="left">Y</td><td align="left">121</td><td align="left">y</td></tr><tr><td align="left">26</td><td align="left">SUB (substitute)</td><td align="left">58</td><td align="left">:</td><td align="left">90</td><td align="left">Z</td><td align="left">122</td><td align="left">z</td></tr><tr><td align="left">27</td><td align="left">ESC (escape)</td><td align="left">59</td><td align="left">;</td><td align="left">91</td><td align="left">[</td><td align="left">123</td><td align="left">{</td></tr><tr><td align="left">28</td><td align="left">FS (file separator)</td><td align="left">60</td><td align="left">&lt;</td><td align="left">92</td><td align="left">\</td><td align="left">124</td><td align="left">|</td></tr><tr><td align="left">29</td><td align="left">GS (group separator)</td><td align="left">61</td><td align="left">=</td><td align="left">93</td><td align="left">]</td><td align="left">125</td><td align="left">}</td></tr><tr><td align="left">30</td><td align="left">RS (record separator)</td><td align="left">62</td><td align="left">&gt;</td><td align="left">94</td><td align="left">^</td><td align="left">126</td><td align="left">~</td></tr><tr><td align="left">31</td><td align="left">US (unit separator)</td><td align="left">63</td><td align="left">?</td><td align="left">95</td><td align="left">_</td><td align="left">127</td><td align="left">DEL (delete)</td></tr></tbody></table><hr><ul><li><p><strong>初始化字符</strong></p><ol><li><p>使用字符 初始化：</p><p><code>char cha2{&#39;a&#39;};</code> <em>// initialize with code point for ‘a’ (stored as integer 97) (preferred)</em></p></li><li><p>使用整型数值 初始化：</p><p><code>char cha1{97};</code> <em>// initialize with integer 97 (‘a’) (not preferred)</em></p></li></ol></li></ul><hr><ul><li><p><strong>输出字符型</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch1&#123; <span class="string">'a'</span> &#125;; <span class="comment">// (preferred)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ch1; <span class="comment">// cout prints a character</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">char</span> ch2&#123; <span class="number">98</span> &#125;; <span class="comment">// code point for 'b' (not preferred)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ch2; <span class="comment">// cout prints a character</span></span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">'c'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******结果********/</span></span><br><span class="line">abc</span><br></pre></td></tr></table></figure><p>【注意】固定宽度我的整型：<code>int8_t</code>类型，是被当做有符号的char类型对待的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int8_t</span> a&#123; <span class="number">97</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200401174509017.png" alt="image-20200401174509017"></p></li></ul><hr><ul><li><p><strong>通过类型转换将字符打印为整数</strong></p><ul><li>一种(糟糕的)方法是将char赋值给一个整数，然后输出这个整数:</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch&#123;<span class="number">97</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> a&#123;ch&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果*********/</span></span><br><span class="line"><span class="number">97</span></span><br></pre></td></tr></table></figure><hr><ul><li><p>另一种较好的方法就是：<strong><em>type case</em>：强制类型转换</strong>，其格式为：</p><p><code>static_cast&lt;new_type&gt;(expression)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch1&#123;<span class="number">97</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> ch2&#123;<span class="string">'a'</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt; (ch1) &lt;&lt;<span class="string">'\n'</span>; <span class="comment">//强制类型转换</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt; (ch2) ; <span class="comment">//强制类型转换</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********结果********/</span></span><br><span class="line"><span class="number">97</span></span><br><span class="line"><span class="number">97</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，变量ch仍然是一个char，并且仍然保持相同的值。知识在本次输出时，输出的是整型类型的值。</p></li></ul><hr><p><strong><u>知识点</u>：</strong></p><blockquote><p>当您看到c++语法(不包括预处理器)使用<em>尖括号&lt;&gt;</em>时，<strong>尖括号之间的内容很可能是类型</strong>。这就是c++处理需要参数化类型的概念的典型方式。</p></blockquote></li></ul><hr><ul><li><p>【<strong>注意</strong>】：std::cin将<strong>允许您输入多个字符</strong>。<strong>然而，变量ch只能包含一个字符</strong>。因此，只有第一个输入字符被提取到变量ch中，<strong>其余的用户输入留在std::cin使用的输入缓冲区中，可以通过后续调用std::cin来提取。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Input a keyboard character: "</span>; <span class="comment">// assume the user enters "abcd" (without quotes)</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">char</span> ch&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; ch; <span class="comment">// ch = 'a', "bcd" is left queued.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="string">" has ASCII code "</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(ch) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Note: The following cin doesn't ask the user for input, it grabs queued input!</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; ch; <span class="comment">// ch = 'b', "cd" is left queued.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="string">" has ASCII code "</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(ch) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200401202849307.png" alt="image-20200401202849307">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200401202925333.png" alt="image-20200401202925333"></p></li></ul><hr><ul><li><p><strong><code>char</code>的大小、范围以及默认的sign(符号)</strong></p><ul><li><p><strong>size</strong>：C++中char类型通常为：1 byte；</p></li><li><p><strong>sign</strong>：默认情况下，char类型是 signed 或者 unsigned；</p><blockquote><p>如果使用字符来保存ASCII字符，则不需要指定符号(因为有符号和无符号字符都可以保存0到127之间的值)。</p><hr><p>一个有符号的字符可以容纳-128到127之间的数字；无符号字符可以容纳0到255之间的数字。</p></blockquote></li></ul></li></ul><hr><ul><li><p><strong>转义符：escape sequences</strong></p><p>转义符<strong>以 “\” 开头</strong>,<strong>后面跟着一个 字母 或 数字</strong>；</p><table><thead><tr><th align="left">Name</th><th align="left">Symbol</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">Alert</td><td align="left">\a</td><td align="left">Makes an alert, such as a beep</td></tr><tr><td align="left">Backspace</td><td align="left">\b</td><td align="left">Moves the cursor back one space</td></tr><tr><td align="left">Formfeed</td><td align="left">\f</td><td align="left">Moves the cursor to next logical page</td></tr><tr><td align="left">Newline</td><td align="left">\n</td><td align="left">Moves cursor to next line</td></tr><tr><td align="left">Carriage return</td><td align="left">\r</td><td align="left">Moves cursor to beginning of line</td></tr><tr><td align="left">Horizontal tab</td><td align="left">\t</td><td align="left">Prints a horizontal tab</td></tr><tr><td align="left">Vertical tab</td><td align="left">\v</td><td align="left">Prints a vertical tab</td></tr><tr><td align="left">Single quote</td><td align="left">\’</td><td align="left">Prints a single quote</td></tr><tr><td align="left">Double quote</td><td align="left">\”</td><td align="left">Prints a double quote</td></tr><tr><td align="left">Backslash</td><td align="left">\</td><td align="left">Prints a backslash.</td></tr><tr><td align="left">Question mark</td><td align="left">?</td><td align="left">Prints a question mark. No longer relevant. You can use question marks unescaped.</td></tr><tr><td align="left">Octal number</td><td align="left">(number)</td><td align="left">Translates into char represented by octal (<em>octal</em>：8进制)</td></tr><tr><td align="left">Hex number</td><td align="left">\x(number)</td><td align="left">Translates into char represented by hex number(<em>hex</em>：16进制)</td></tr></tbody></table></li></ul><hr><ul><li><p><strong>单引号</strong> VS <strong>双引号</strong> 的区别</p><ul><li><p>单个字符总是放在 单引号 中。(e.g. ‘a’, ‘+’, ‘5’)。<code>char</code>类型的只能接收一个符号(e.g. 字母 a, + , 数字 5)</p><p><code>char ch(&#39;56&#39;);</code> <em>// a char can only hold one symbol</em></p></li><li><p>放在双引号(例如“Hello, world!”)之间的文本称为<strong>字符串<em>string</em></strong>。一个 <em>string</em>是连续字符的集合(因此，一个字符串可以包含多个符号)。</p><p><code>std::cout &lt;&lt; &quot;hello world&quot; ;</code> <em>// “Hello, world!” is a string literal</em></p></li></ul><hr><p>知识点：<strong><em>string</em>类型在C++中，不是基本数据类型</strong></p></li></ul><hr><ul><li><em>char</em>的其他类型：<strong><code>wchar_t</code>、<code>char16_t</code>、<code>char32_t</code></strong><ul><li><code>wchar_t</code>：应避免使用(除非是在windows API接口时使用)。它的大小是在实现时才确定的，它并不可靠。</li><li><code>char16_t</code>、<code>char32_t</code>在C++11中添加，以提供对16位和32位Unicode字符的显式支持。在c++ 20中添加了<code>char8_t</code>。</li></ul></li></ul><hr><h2 id="4-12-字面常量"><a href="#4-12-字面常量" class="headerlink" title="4.12 字面常量"></a>4.12 字面常量</h2><ul><li><p><strong><em>constant</em></strong>：是固定的值，不可被改变。</p><blockquote><p>C++中有两种<em>constant</em>：<strong>字面常量</strong>、<strong>符号常量</strong>。</p></blockquote></li></ul><ul><li><p><strong>literal constant：字面常量</strong>，简称：<strong>literal</strong>。是直接将值插入代码中的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="number">5</span>; <span class="comment">//5是一个整型literal</span></span><br><span class="line"><span class="keyword">bool</span> mynameisqin&#123;<span class="literal">true</span>&#125;; <span class="comment">//true 是一个布尔型literal</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="number">3.4</span>; <span class="comment">//3.4 是一个双精度浮点型的literal</span></span><br></pre></td></tr></table></figure><p>上面这些都是常数，因为他们不能动态的被改变。</p><p>就像对象分类型一样，常量也是有类型的：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200402103515525.png" alt="常量的类型"></p></li></ul><hr><ul><li><p><strong>literal 的后缀</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200402103708146.png" alt="literal 的后缀"></p><p>example：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> value1 &#123;<span class="number">5u</span>&#125;; <span class="comment">//5的类型是 unsigned int</span></span><br><span class="line"><span class="keyword">long</span> value2 &#123;<span class="number">6L</span>&#125;; <span class="comment">// 6的类型是 long</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*默认情况，浮点类型是 double ；如果想定义其为float类型，可以添加后缀类实现*/</span></span><br><span class="line"><span class="keyword">float</span> f1 &#123;<span class="number">5.0f</span>&#125;; <span class="comment">//5.0 的类型是 float</span></span><br><span class="line"><span class="keyword">float</span> f2 &#123;<span class="number">4.1</span>&#125;; <span class="comment">//4.1的类型是   double</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>string literals</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world"</span>; <span class="comment">//这种是 C分割的 string literal</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello"</span> <span class="string">" world"</span>; <span class="comment">//C++将会把它们连接起来</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>Scientific notation for floating point literals：浮点型literal 的科学计数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> pi &#123;<span class="number">3.14159</span>&#125;; <span class="comment">//3.14159是一种一般形式</span></span><br><span class="line"><span class="keyword">double</span> avogadro &#123;<span class="number">6.02e23</span>&#125;; <span class="comment">//6.02e23 是双精度浮点型literal 的科学计数法形式</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>Octal and hexadecimal literals：八进制 &amp; 十六进制 的 literal</strong></p><ol><li><p><strong>八进制：octal</strong></p><p>八进制是以8为底，它可用的数为： 0, 1, 2, 3, 4, 5, 6, 7。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200402105451740.png" alt="八进制与十进制的对应"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*八进制的前缀是，数字“0”，不是字母“o”*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123;<span class="number">012</span>&#125;; <span class="comment">//"0"表示这个数字是八进制数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr></li><li><p><strong>十六进制：hexadecimal</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200402110146793.png" alt="十六进制与十进制的对应"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*十六进制数的前缀是：数字0和字母x，即 0x*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x&#123;<span class="number">0xF</span>&#125;; <span class="comment">//0x表示这个数是十六进制数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>十六进制通常用来<strong>表示内存地址</strong> 或 <strong>内存中的原始值</strong>。</p><blockquote><p>因为相对于二进制，16进制表示起来更加简洁。如：二进制的数<code>0011 1010 0111 1111 1001 1000 0010 0110</code>，单用16进制表示的话，就是<code>3A7F 9826</code></p></blockquote><hr><p>在C++14之前，无法给变量赋一个二进制的literal，但是，16进制对为我们提供了一个有用的解决方法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bin&#123;&#125;;</span><br><span class="line">    bin = <span class="number">0x01</span>; <span class="comment">// assign binary 0000 0001 to the variable</span></span><br><span class="line">    bin = <span class="number">0x02</span>; <span class="comment">// assign binary 0000 0010 to the variable</span></span><br><span class="line">    bin = <span class="number">0x04</span>; <span class="comment">// assign binary 0000 0100 to the variable</span></span><br><span class="line">    bin = <span class="number">0x08</span>; <span class="comment">// assign binary 0000 1000 to the variable</span></span><br><span class="line">    bin = <span class="number">0x10</span>; <span class="comment">// assign binary 0001 0000 to the variable</span></span><br><span class="line">    bin = <span class="number">0x20</span>; <span class="comment">// assign binary 0010 0000 to the variable</span></span><br><span class="line">    bin = <span class="number">0x40</span>; <span class="comment">// assign binary 0100 0000 to the variable</span></span><br><span class="line">    bin = <span class="number">0x80</span>; <span class="comment">// assign binary 1000 0000 to the variable</span></span><br><span class="line">    bin = <span class="number">0xFF</span>; <span class="comment">// assign binary 1111 1111 to the variable</span></span><br><span class="line">    bin = <span class="number">0xB3</span>; <span class="comment">// assign binary 1011 0011 to the variable</span></span><br><span class="line">    bin = <span class="number">0xF770</span>; <span class="comment">// assign binary 1111 0111 0111 0000 to the variable</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><hr><ul><li><p><strong>C++14中 二进制的literal</strong></p><p>在C++14中，使用数字0和字母b，即“0b”。给变量分配二进制的literal：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bin&#123;&#125;;</span><br><span class="line">    bin = <span class="number">0b1</span>;  <span class="comment">// assign binary 0000 0001 to the variable</span></span><br><span class="line">    bin = <span class="number">0b11</span>; <span class="comment">// assign binary 0000 0011 to the variable</span></span><br><span class="line">    bin = <span class="number">0b1010</span>; <span class="comment">// assign binary 0000 1010 to the variable</span></span><br><span class="line">    bin = <span class="number">0b11110000</span>; <span class="comment">// assign binary 1111 0000 to the variable</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*但是二进制数比较长，所以用“ ' ”来当做分隔符，便于读认*/</span></span><br><span class="line">#Include &lt;iostream&gt;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> bin &#123;<span class="number">0b1011'0010</span>&#125;;</span><br><span class="line">     <span class="keyword">long</span> value &#123;<span class="number">0'132'673'462</span>&#125;;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>输出 十进制、八进制、十六进制、二进制数</strong></p><blockquote><p>decimal、octal、hexadecimal、binary</p></blockquote><p>C++默认输出是十进制数，但是我们可以转换输出格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x &#123;<span class="number">12</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt;<span class="string">'\n'</span>; <span class="comment">//默认十进制</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::hex&lt;&lt;x &lt;&lt;<span class="string">'\n'</span>; <span class="comment">//16进制</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt;<span class="string">'\n'</span>; <span class="comment">//x变量的值现在被转换为16进制了</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::oct&lt;&lt; x &lt;&lt;<span class="string">'\n'</span>; <span class="comment">//8进制</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::dec&lt;&lt; x &lt;&lt;<span class="string">'\n'</span>; <span class="comment">//十进制</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****输出*******/</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line">c</span><br><span class="line">c</span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><hr><p><strong>输出二进制</strong>：输出二进制数比较麻烦一点。<strong>需要添加头文件：<code>&lt;bitset&gt;</code></strong>。</p><blockquote><p><code>std::bitset&lt;num&gt;</code>：表示我们存储的位数为num。它可以被初始化成一个 无符号整数值(可以使10，8，16，2进制的形式)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt; //for std::bitset</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// std::bitset&lt;8&gt; means we want to store 8 bits</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;8&gt; bin1&#123; <span class="number">0b1100'0101</span> &#125;; <span class="comment">// binary literal for binary 1100 0101</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;8&gt; bin2&#123; <span class="number">0xC5</span> &#125;; <span class="comment">// hexadecimal literal for binary 1100 0101</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; bin1 &lt;&lt; <span class="string">' '</span> &lt;&lt; bin2 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;4&gt;&#123; <span class="number">0b1010</span> &#125; &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// we can also print from std::bitset directly(输出完之后，被抛弃)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出*/</span></span><br><span class="line"><span class="number">11000101</span> <span class="number">11000101</span></span><br><span class="line"><span class="number">1010</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="4-13-const-constexpr-symbolic-constants"><a href="#4-13-const-constexpr-symbolic-constants" class="headerlink" title="4.13 const, constexpr, symbolic constants"></a>4.13 const, constexpr, symbolic constants</h2><p><strong>常量 变量：其值不能被修改，情形修改会出错</strong></p><ul><li><p>使用<strong>关键字<code>const</code></strong>，来表示该变量是常量：</p><blockquote><p>放在变量类型的前面、后面 都可以</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> gravity &#123;<span class="number">9.8</span>&#125;; <span class="comment">//放在类型的前面【推荐】</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> sidesInSquare &#123;<span class="number">4</span>&#125;; <span class="comment">//放在类型后面【不推荐】</span></span><br></pre></td></tr></table></figure></li></ul><hr><p><red><strong>常量变量(const variable)</strong>必须在定义时要初始化(即要赋值给他们)。赋值完成，它的值就不能被改变.</red></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******常量变量的值被改变*************/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> a &#123;<span class="number">5.0</span>&#125;;</span><br><span class="line">a = <span class="number">1.0</span>;  <span class="comment">//编译出错，因为常量变量的值被改变</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******常量变量不初始化********/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> a; <span class="comment">//compiler error, must be initialized upon definition</span></span><br></pre></td></tr></table></figure><hr><ul><li><p><strong>runtime VS compile time constants</strong></p><blockquote><p><strong>runtime</strong>：程序运行时；</p><p><strong>compile time</strong>：编译器运行时。</p></blockquote><ul><li><strong>runtime constants</strong>：初始化值只能在运行时解析的常量；</li><li><strong>compile-time constants</strong>：初始化值可以在编译时解析的；</li></ul><p>当您声明一个const变量时，编译器将隐式地跟踪它是运行时常量还是编译时常量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">getNumberOfBits</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> numberOfBits&#123; <span class="number">3</span> &#125;; <span class="comment">// Compile-time constant</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;numberOfBits&gt; b&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> otherNumberOfBits&#123; getNumberOfBits() &#125;; <span class="comment">// Run-time constant</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;otherNumberOfBits&gt; b2&#123;&#125;; <span class="comment">// Error[因为此时需要的是编译时常量，而不是运行时常量]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>常量表达式：constexpr</strong></p><p>为了提供更多的特性，c++ 11引入了新的<strong>关键字constexpr，它确保常量必须是 “编译时常量”:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">double</span> gravity &#123;<span class="number">9.8</span>&#125;; <span class="comment">//正确，9.8是编译时的字面常量</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> sum &#123;<span class="number">4</span>+<span class="number">5</span>&#125;; <span class="comment">//正确，4+5的值时编译时的字面常量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"enter your age:"</span>;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; age;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> myage &#123;age&#125;; <span class="comment">//错误，因为“age”是一个运行时常量</span></span><br></pre></td></tr></table></figure></li></ul><hr><p>【小结】：常量变量必须在定义时，对它初始化。</p><ul><li>当一个变量的值需要是 编译时常量时，推荐使用<code>constexpr</code>来声明它。</li><li>当一个变量的值需要是 运行时常量时，推荐使用<code>const</code>来声明它。</li></ul><hr><ul><li><p><strong>符号常量：symbolic constants</strong></p><p><strong>symbolic constant</strong>：是 字面常量(literal constant)的值 的名字。</p><hr><p>两种方法声明符号常量：</p><ol><li><p>使用<strong>“宏(macro)”</strong>定义：【不推荐】</p><p><code>#define identifier substitution_text</code></p><p>如：<code>#define a 10;</code></p></li><li><p>使用关键字<code>constexpr</code>变量：【推荐】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> maxstudentperclass &#123;<span class="number">30</span>&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> maxnamelength &#123;<span class="number">30</span>&#125;;</span><br></pre></td></tr></table></figure></li></ol></li></ul><hr><ul><li><p><strong>在多文件程序中使用符号常量</strong></p><p>在许多应用程序中，需要在整个代码中使用给定的符号常量(而不仅仅是在一个位置)。这些参数可以包括物理或数学常数(如pi或阿伏伽德罗常数)，或特定于应用程序的“调优”值(如摩擦系数或重力系数)。<strong>与其每次需要时都重新定义它们，不如在中心位置声明一次并在需要的地方使用它们。</strong>这样，如果你需要改变它们，你只需要在一个地方改变它们。</p><p>有很多种方法来实现它，这里使用比较简单的一种：</p><ol><li>首先，<strong>创建一个头文件</strong>来写相关的常量；</li><li>在这个头文件中，<strong>声明一个名称空间</strong>；</li><li>将你要用到的<strong>常量写在这个命名空间</strong>中；</li><li>在你需要这些常量的时候，<strong><code>#include</code>这个头文件</strong>。</li></ol><p>example：</p><ul><li><p>constants.h (C++11/14):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONSTANTS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONSTANTS_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//define your own namespace to hold constansts</span></span><br><span class="line"><span class="keyword">namespace</span> constants</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">double</span> pi &#123;<span class="number">3.14159</span>&#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">double</span> avogadro &#123;<span class="number">6.0221413e23</span>&#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">double</span> my_gravity &#123;<span class="number">9.2</span>&#125;;</span><br><span class="line">    <span class="comment">//.........other related constants</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li><li><p>In C++17, prefer “inline constexpr” instead:</p><p>constants.h (C++17 or newer):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONSTANTS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONSTANTS_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// define your own namespace to hold constants</span></span><br><span class="line"><span class="keyword">namespace</span> constants</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> pi &#123;<span class="number">3.14159</span>&#125;;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> avogadro &#123; <span class="number">6.0221413e23</span> &#125;;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> my_gravity &#123; <span class="number">9.2</span> &#125;; <span class="comment">// m/s^2 -- gravity is light on this planet</span></span><br><span class="line">    <span class="comment">// ... other related constants</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li></ul><p>使用<strong>“作用域解析符<code>::</code>”</strong>,在其他文件访问你的常量：</p><p><em>main.cpp</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"constants.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"enter a radius: "</span>;</span><br><span class="line">    <span class="keyword">int</span> radius&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; radius;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> circumference &#123;<span class="number">2.0</span>*radius*constants::pi&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"the circumference is: "</span> &lt;&lt;circumference &lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnCpp chapter3</title>
      <link href="/archives/5fc07ec4.html"/>
      <url>/archives/5fc07ec4.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red>LearnCpp-chapter3</red></p></center><center><red>https://www.learncpp.com</red></center><p>未完待续~~</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnCpp chapter2</title>
      <link href="/archives/28c74e52.html"/>
      <url>/archives/28c74e52.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapter2</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h2 id="2-1-函数"><a href="#2-1-函数" class="headerlink" title="2.1 函数"></a>2.1 函数</h2><p>当你读一本书的时候，突然有人给你打电话。然后你就用“书签”夹在当前阅读位置，去接电话。等你电话接完，再回到你放书签的那个地方继续读书。</p><p><strong>函数调用(function call)</strong>是一个表达式。它告诉CPU中断当前函数并在这里“放一个书签”，然后执行另一个函数(就是函数调用中提及的那个函数)。当调用结束后，CPU就返回到“书签”的位置，然后再继续执行。</p><blockquote><p><strong>caller</strong>：发起函数调用的函数叫做caller；</p><p><strong>callee(called function)</strong>：被调用的函数叫做callee(called function)。</p></blockquote><p><strong>int main()的返回值</strong>：</p><p>在int main()函数最后，会有返回值，这个值是返回到操作系统的，为了让操作系统知道这个程序执行成功与否。main函数的返回值，有一个特定名字叫做：<strong><u>status code （状态码）</u></strong></p><blockquote><p>一般 <code>return 0;</code> 表示程序执行成功。</p><p>返回非零值，表示程序执行错误。</p></blockquote><p>【<strong>Note</strong>】：<strong>C++规定，main函数必须是int型的。即： int main()</strong></p><h2 id="2-3-函数的形参与实参"><a href="#2-3-函数的形参与实参" class="headerlink" title="2.3 函数的形参与实参"></a>2.3 函数的形参与实参</h2><ul><li><p><strong>形参(parameter)</strong>：是指函数定义中参数；(形参初始化是通过调用者传来的值(即，实参)来初始化的 )</p><p><strong>实参(argument)</strong>：函数调用时的实际参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printValues</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">//函数定义时的参数x,y，即这里的x,y是形参</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printValues(<span class="number">6</span>, <span class="number">7</span>); <span class="comment">//调用函数。即，6和7是实参</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>实参与形参如何一起工作？</strong></p><p>当调用一个函数时，函数所有的parameters都被创建为变量，并且每个arguments的值都被复制到匹配的parameters中。这个过程称为<strong>pass by value(按值传递)</strong>。</p></li><li><p><strong>关于函数参数求值顺序的警告</strong></p><p>在C++中，没有规定实参匹配的顺序（顺序：从左→右，还是从右→左），因为匹配顺序不重要。</p><p>但是，如果实参是函数调用，那就需要注意了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someFunction(a(), b()); <span class="comment">// a() or b() may be called first</span></span><br></pre></td></tr></table></figure><ul><li>是从右→左，还是从右→左：<strong>取决于a()和b()的功能</strong>。</li></ul><p>如果你想要规定谁先的话，你可以显示的规定匹配顺序，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> avar&#123; a() &#125;; <span class="comment">// a() will always be called first</span></span><br><span class="line"><span class="keyword">int</span> bvar&#123; b() &#125;; <span class="comment">// b() will always be called second</span></span><br><span class="line"> </span><br><span class="line">someFunction(avar, bvar); <span class="comment">// it doesn't matter whether avar or bvar are copied first because they are just values</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="2-4-局部范围"><a href="#2-4-局部范围" class="headerlink" title="2.4 局部范围"></a>2.4 局部范围</h2><ul><li><strong>局部变量Local variables</strong>：函数的形参，和它内部定义的变量 属于“局部变量”。如：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// function parameters x and y are local variables</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> z&#123; x + y &#125;; <span class="comment">// z is a local variable too</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>局部变量生命周期</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// x and y are created and enter scope here</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// x and y are visible/usable within this function only</span></span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125; <span class="comment">// y and x go out of scope and are destroyed here</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a&#123; <span class="number">5</span> &#125;; <span class="comment">// a is created, initialized, and enters scope here</span></span><br><span class="line">    <span class="keyword">int</span> b&#123; <span class="number">6</span> &#125;; <span class="comment">// b is created, initialized, and enters scope here</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// a and b are usable within this function only</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(a, b) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// calls function add() with x=5 and y=6</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// b and a go out of scope and are destroyed here</span></span><br></pre></td></tr></table></figure><blockquote><p>执行过程：</p><ol><li><p>程序开始执行于main()函数；</p></li><li><p>main()函数的变量a被创建并赋值为5；（初始化）★</p></li><li><p>main()函数的变量b被创建并赋值为6；（初始化）★</p></li><li><p>函数add()被调用，并传入实参5，6；</p></li><li><p>add()函数的变量x被创建，并初值为5;（初始化）★</p></li><li><p>add()函数的变量y被创建，并初值为6;（初始化）★</p></li><li><p>操作符“+”计算表达式”x+y”，产生值11；</p></li><li><p>add函数将值11复制回调用者main()函数；</p></li><li><p>add函数的x、y被摧毁；★</p></li><li><p>main()函数在控制台上打印出11；</p></li><li><p>main()函数返回0到操作系统；</p></li><li><p>main()函数的a、b被摧毁。★</p></li></ol></blockquote><p>由此可知，<strong>局部变量的生命周期</strong>：是从他开始<u>被创建</u>（如上述的第2步，变量a被创建）一直到执行完这个它所在的函数（如上述的第9步）被摧毁。</p><p><strong>【Note】</strong>：变量的创建和摧毁发生在程序的<strong>运行期间（runtime）</strong>。所以生命周期是一个runtime属性。</p></li><li><p><strong>局部范围</strong></p><p><strong>标识符的范围</strong>决定了在源代码中标识符可以被访问的位置。范围是一个<strong>编译期间(compile-time)</strong>的属性。（当使用的标识符不在范围内时，编译器会报错）</p><p><strong>局部变量的范围</strong>：开始于它的<u>定义</u>，结束于<u>定义它们的花括号集合的末尾</u>。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// x is not in scope anywhere in this function</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello!\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// x can not be used here because it's not in scope yet</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> x&#123; <span class="number">0</span> &#125;; <span class="comment">// x enters scope here and can now be used</span></span><br><span class="line"> </span><br><span class="line">    doSomething();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// x goes out of scope here and can no longer be used</span></span><br></pre></td></tr></table></figure><h2 id="2-5-为什么要用函数"><a href="#2-5-为什么要用函数" class="headerlink" title="2.5 为什么要用函数"></a>2.5 为什么要用函数</h2></li></ul><p><strong>使用函数的优势</strong>：</p><ul><li><strong>有组织性Organization</strong>：随着程序越来越复杂，若将全部的代码都写在main()函数中，势必会增加复杂性。一个函数就像一个小型程序。将它与main函数分开写，我们就不必去考其余代码。</li><li><strong>可重用性Reusability</strong>：一个函数可以被调用无数次。就可以避免这种情况：如果写在main函数中，要调用n次这个功能，就要重新写这个功能n次。</li><li><strong>便于测试Testing</strong>：因为函数减少了代码冗余，所以首先要测试的代码就更少了。另外，因为函数是自包含的，所以一旦我们测试了一个函数以确保它可以工作，我们就不需要再次测试它，除非我们修改它。这减少了我们必须一次测试的代码量，使得查找bug(或者在第一时间避免bug)变得更加容易。</li><li><strong>可扩展性Extensibility</strong>：</li><li><strong>抽象化Abstraction</strong>：在每次用这个函数时，我们只需要知道它的名字。输入和输出。不必知道它是如何工作的。</li></ul><p><strong>如何高效的使用函数？</strong></p><ul><li>在一个程序中<u>出现多次的语句</u>通常应该构成一个函数。例如，如果我们以相同的方式多次读取来自用户的输入，那么这就是一个很好的函数候选。如果我们以相同的方式输出多次，这也是一个很好的候选函数。</li><li>一个函数通常应该执行一个(且仅一个)任务。</li><li>当一个函数变得太长、太复杂或难以理解时，可以将其分解为多个子函数。这就是所谓的<strong>重构refactoring</strong>。</li></ul><h2 id="2-6-空白与基本格式"><a href="#2-6-空白与基本格式" class="headerlink" title="2.6 空白与基本格式"></a>2.6 空白与基本格式</h2><h3 id="空白"><a href="#空白" class="headerlink" title="空白"></a>空白</h3><p><strong>空白Whitespace</strong>：是一个术语，指的是用于格式化目的的字符。在c++中，这主要指<strong>空格</strong>、<strong>制表符(tab)</strong>和<strong>换行</strong>。c++编译器通常会忽略空白，只有少数例外(在处理文本时)。因此，<strong>我们说c++是一种与空白无关的语言。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*下面这三个都是一样的作用*/</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>               &lt;&lt;            <span class="string">"Hello world!"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span></span><br><span class="line">&lt;&lt; <span class="string">"Hello world!"</span>;</span><br></pre></td></tr></table></figure><p>【注意】</p><ul><li>在<strong>文本</strong>中，不允许换行：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这种是不被允许的</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello</span></span><br><span class="line"><span class="string">    world!"</span> ;</span><br></pre></td></tr></table></figure><ul><li><p>但是这种情况是可以的：文本只是被空白(空格、制表符(tab)、换行)分离，他将会被连接：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的hello与world都是被双引号包含起来的</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello "</span></span><br><span class="line">     <span class="string">"world!"</span>; <span class="comment">// prints "Hello world!"</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h3><ol><li><p><strong>缩进(indentation)</strong>可以用：<strong>空格spaces</strong>或者<strong>tabs（制符表）</strong>。</p><blockquote><p>如果用制符表，建议将其调整为4个空格的缩进，3个也可以。</p></blockquote></li><li><p><strong>大花括号（brace）</strong>：</p><ul><li><p>Google中的C++风格：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>另一种风格：这一种不容易出错，更容易找出花括号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在大花括号中的每条语句，应该从其所在花括号算起隔开一个tab的距离，开始写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!\n"</span>;       <span class="comment">// tabbed in one tab (4 spaces)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Nice to meet you.\n"</span>;  <span class="comment">// tabbed in one tab (4 spaces)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>每一行的字符不要过长，一般不超过80个字符</p></li><li><p>如果一行别操作符(如，&lt;&lt; 、+)分割(split)。这个操作符应该被卸载下一行的开头：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">3</span> + <span class="number">4</span></span><br><span class="line">    + <span class="number">5</span> + <span class="number">6</span></span><br><span class="line">    * <span class="number">7</span> * <span class="number">8</span>;</span><br></pre></td></tr></table></figure></li><li><p>通过对齐值或注释或在代码块之间添加间距，使用空白使代码更易于阅读。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不易读</span></span><br><span class="line">cost = <span class="number">57</span>;</span><br><span class="line">pricePerItem = <span class="number">24</span>;</span><br><span class="line">value = <span class="number">5</span>;</span><br><span class="line">numberOfItems = <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//易读</span></span><br><span class="line">cost          = <span class="number">57</span>;</span><br><span class="line">pricePerItem  = <span class="number">24</span>;</span><br><span class="line">value         = <span class="number">5</span>;</span><br><span class="line">numberOfItems = <span class="number">17</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不易读</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!\n"</span>; <span class="comment">// cout lives in the iostream library</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"It is very nice to meet you!\n"</span>; <span class="comment">// these comments make the code hard to read</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Yeah!\n"</span>; <span class="comment">// especially when lines are different lengths</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//易读</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!\n"</span>;                  <span class="comment">// cout lives in the iostream library</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"It is very nice to meet you!\n"</span>;  <span class="comment">// these comments are easier to read</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Yeah!\n"</span>;                         <span class="comment">// especially when all lined up</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不易读</span></span><br><span class="line"><span class="comment">// cout lives in the iostream library</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!\n"</span>;</span><br><span class="line"><span class="comment">// these comments make the code hard to read</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"It is very nice to meet you!\n"</span>;</span><br><span class="line"><span class="comment">// especially when all bunched together</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Yeah!\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//易读</span></span><br><span class="line"><span class="comment">// cout lives in the iostream library</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!\n"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// these comments are easier to read</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"It is very nice to meet you!\n"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// when separated by whitespace</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Yeah!\n"</span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-7-提前声明与定义"><a href="#2-7-提前声明与定义" class="headerlink" title="2.7 提前声明与定义"></a>2.7 提前声明与定义</h2><p>一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of 3 and 4 is: "</span> &lt;&lt; add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在vs 2013中运行，会出现：</p><p><code>add.cpp(5) : error C3861: &#39;add&#39;: identifier not found</code></p><p><strong>原因：</strong>因为编译器是按照顺序进行编译的。当编译器在main函数的第5行中调用add函数，他不知道add是什么。因为目前为止还没有定义add函数（因为add函数的定义在第9行）</p><hr><p><strong>如何解决呢？</strong></p><ol><li><p>法一：<strong>调整代码顺序</strong>：让被调用的函数在调用者之前【在复杂程序中，不实用】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of 3 and 4 is: "</span> &lt;&lt; add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>如果在一个复杂的程序中，会调用很多函数，还有嵌套型的调用。如果去一个个个去找出调用顺序，然后去调整代码。这样是很乏味低效的。</strong></p></blockquote></li><li><p>法二<strong>[推荐]</strong>：<strong>提前声明forward declaration</strong>：在使用函数之前，先声明它。（然后就不用关注代码实现的顺序了）</p><blockquote><p>提前向声明<strong>允许我们在实际定义标识符之前告诉编译器标识符的存在。</strong></p></blockquote><p>为了编写一个函数的提前向声明，我们使用一个称为<strong>函数原型(function prototype)</strong>的声明语句。函数原型包括：函数的 返回<strong>类型</strong>、<strong>名字</strong>、<strong>形参</strong>，以<strong>分号(semicolon)</strong>结束。但是不包含函数<strong>主体(function body)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="comment">// forward declaration of add() (using a function prototype)</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of 3 and 4 is: "</span> &lt;&lt; add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// this works because we forward declared add() above</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// even though the body of add() isn't defined until here</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="忘记定义函数主题"><a href="#忘记定义函数主题" class="headerlink" title="忘记定义函数主题"></a>忘记定义函数主题</h3><ol><li><p>如果<strong>声明</strong>了函数，但<strong>没定义</strong>函数，而且这个函数<strong>没有被调用</strong>，那么这个程序<strong>可以被编译&amp;运行</strong>；</p></li><li><p>如果<strong>声明</strong>了函数，但<strong>没定义</strong>函数，而且而且这个函数<strong>有被调用</strong>，那么这个程序<strong>可以被编译</strong>，但<strong>链接会出错</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="comment">// forward declaration of add() using function prototype</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of 3 and 4 is: "</span> &lt;&lt; add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// note: No definition for function add</span></span><br></pre></td></tr></table></figure><p>上面程序在visual studio 中，会出现：编译成功，链接失败</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Compiling...</span><br><span class="line">add.cpp</span><br><span class="line">Linking...</span><br><span class="line">add.obj : error LNK2001: unresolved external symbol &quot;int __cdecl add(int,int)&quot; (?add@@YAHHH@Z)</span><br><span class="line">add.exe : fatal error LNK1120: 1 unresolved externals</span><br></pre></td></tr></table></figure></li></ol><h3 id="声明-VS-定义"><a href="#声明-VS-定义" class="headerlink" title="声明 VS. 定义"></a>声明 VS. 定义</h3><ul><li><p><strong>定义(define)</strong>：实现(函数或类型）或者是 实例化(对于变量）标识符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// implements function add()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> z&#123; x + y &#125;; <span class="comment">// instantiates variable z</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于<strong>链接器(linker)</strong>来说<strong>定义（define）</strong>是必要的的。</p></blockquote></li></ul><h4 id="单定义规则"><a href="#单定义规则" class="headerlink" title="单定义规则"></a>单定义规则</h4><p><strong>单定义规则（one definition rule）</strong>简称：<strong>ODR</strong>：在C++中非常有名的规则，主要分三部分：</p><ol><li><p>在给定的文件中（这里翻译不准确），每个函数、对象、类型、模板<u>只能有一次定义</u>。</p></li><li><p>在整个程序中，一个对象或者函数只能被定义一次；</p></li><li><p>类型、模板、内置函数、变量 被允许在不同的文件中有相同的定义。</p><hr></li></ol><p><strong>违背第1条，将会使编译器发出重新定义错误；</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// violation part1 of ODR, we've already defined function add</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> x; <span class="comment">// violation of ODR, we've already defined x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在visual studio中，会出现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">project3.cpp(9): error C2084: function &#39;int add(int,int)&#39; already has a body</span><br><span class="line">project3.cpp(3): note: see previous definition of &#39;add&#39;</span><br><span class="line">project3.cpp(16): error C2086: &#39;int x&#39;: redefinition</span><br><span class="line">project3.cpp(15): note: see declaration of &#39;x&#39;</span><br></pre></td></tr></table></figure></li></ul><p><strong>违背第2条，将会使连接器发出重新定义的错误；</strong></p><p><strong>违背第3条，将会产生未定义的行为。</strong></p><hr><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p><strong>声明(declaration)</strong>：是一个语句。它告诉编译器这里存在一个标识符和它的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="comment">// tells the compiler about a function named "add" that takes two int parameters and returns an int.  No body!</span></span><br><span class="line"><span class="keyword">int</span> x; <span class="comment">// tells the compiler about an integer variable named x</span></span><br></pre></td></tr></table></figure><blockquote><p>对<strong>编译器(complier)</strong>而言<strong>声明(declaeation)</strong>是必要的。</p></blockquote><p>在C++中，所有的<strong>定义</strong>也用作<strong>声明</strong>。上述例子中的<code>int x</code>是 定义，也是声明。</p><p>多数情况下，<strong>定义</strong>符合我们的目的，因为定义能同时满足“编译器”和“链接器”的要求。</p><hr><p><red>【所有的<strong>定义</strong>都是<strong>声明</strong>，但所有的<strong>声明</strong>并不一定是<strong>定义</strong>。这些不是定义的声明有一个名字：<u><strong>纯声明(pure declarations)</strong></u>】</red></p><ul><li>一个典型的例子就是：<u>函数原型(function prototype)</u>，它满足编译器的要求，但不满足链接器的要求。</li><li>其他类型的纯声明包含：提前声明变量 和 类型声明。</li></ul><p><strong>单定义规则不适用于纯声明。</strong>所以，你可以对一些标识符声明n多次都可以（虽然声明n次，会有很多次是冗余的）</p><hr><p>小结：</p><p>在很多编程语言中，“声明”就是指“纯声明”；“定义”就是指“定义也可以用于声明”。所以，<code>int x;</code>是一个定义（虽然他既是定义，也是声明）</p><h2 id="2-9-命名冲突-amp-命名空间"><a href="#2-9-命名冲突-amp-命名空间" class="headerlink" title="2.9 命名冲突&amp;命名空间"></a>2.9 命名冲突&amp;命名空间</h2><h3 id="命名冲突"><a href="#命名冲突" class="headerlink" title="命名冲突"></a>命名冲突</h3><p><strong>命名冲突：naming collision</strong> (or <strong>naming conflict</strong>).</p><blockquote><p>将两个同名的标识符放在同一个程序中，编译器或者链接器无法区分它们时，就会报错。这种情况就是：<strong>命名冲突</strong></p></blockquote><p>例如：</p><blockquote><p>a.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFcn</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>main.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFcn</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> * x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当编译器编译这个程序时，它将会<strong>单独的</strong>编译<em>a.cpp</em>和<em>main.cpp</em>，每个cpp文件都编译成功。但是，当链接时，链接器将会链接<em>a.cpp</em>和<em>main.cpp</em>中所有的定义到一起，此时就发现函数<em>myFun</em>命名冲突了。【注意，虽然函数<em>myFun</em>没有被调用，但在链接时还是会出错】</p><p>命名冲突一般出现在以下两种情况：</p><ol><li>一个函数(或全局变量)的两个(或多个)定义被引入到不同的文件中，这些文件被编译到同一个程序中。这将导致一个<strong>链接器错误</strong>，如上所示。</li><li>一个函数(或全局变量)的两个(或多个)定义被引入到同一个文件中(通常通过#include)。这将导致<strong>编译器错误</strong>。</li></ol><p>对于<strong>局部变量</strong>，C++提供一种局部范围的机制，它使定义在函数内部的局部变量不会冲突。但这种机制对于函数的名字无效。</p><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p><strong>命名空间：namespace</strong></p><p><strong>命名空间：</strong>之所以出来这样一个东西，是因为人类可用的单词数太少，并且不同的人写的程序不可能所有的变量都没有重名现象，对于库来说，这个问题尤其严重，如果两个人写的库文件中出现同名的变量或函数(不可避免)，使用起来就有问题了。为了解决这个问题，引入了名字空间这个概念，通过使用 namespace xxx；你所使用的库函数或变量就是在该名字空间中定义的，这样一来就不会引起不必要的冲突了。</p><blockquote><p>注意，在同一命名空间中，所有的名字必须是独一无二的。</p></blockquote><h4 id="全局命名空间"><a href="#全局命名空间" class="headerlink" title="全局命名空间"></a>全局命名空间</h4><p>在C++中，任何没有定义在 类、函数、或 命名空间 的名字，都被默认的归为“<strong>全局命名空间(global namespace)</strong>”，有时也叫“<strong>全局范围(global scope)</strong>”</p><h4 id="std-命名空间"><a href="#std-命名空间" class="headerlink" title="std 命名空间"></a>std 命名空间</h4><p>在最初设计c++时，c++标准库中的所有标识符(包括std::cin和std::cout)都可以在没有std::前缀的情况下使用(它们是全局命名空间的一部分)。</p><p>但是，这意味着标准库中的任何标识符都可能与你自己定义的标识符的名字(也在全局名称空间中定义)发生冲突。</p><p>为了避免这种冲突，C++将所有标准库中的所有函数都移入一个叫做<strong>“std(是standard的简称)”的命名空间</strong>，即：<strong>std namespace</strong></p><blockquote><p>所以，你看到的<em>std::cout</em>，这并不是它的名字，它实际上只是<em>cout</em>，<em>std</em>只是命名空间的名字，而<em>cout</em>是std namespace中的一部分。</p></blockquote><p><strong>【注】：如果你使用一个命名空间中的标识符，你必须告诉编译器，这个标识符是在这个命名空间内。</strong></p><hr><ol><li><p><strong>显示的命名空间限定符 std::</strong></p><p>最直接的方法是：告诉编译器我们使用<em>cout</em>是来自 <em>std</em>这个namespace(命名空间)的。可以使用前缀 “std::” 来完成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!"</span>; <span class="comment">// when we say cout, we mean the cout defined in the std namespace</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>‘::’</strong> 是一个操作符，叫做<strong>“作用域解析符(scope resolution operator)”</strong>。</p><p>在它左边的标识符表示：所在命名空间的名称；在它右边的标识符表示：这个命名空间的一个 标识符。</p><p>【注】如果“::”的左边没有东西，则默认为它在<strong>全局命名空间( global namespace )</strong>中。</p></blockquote><p>std::cout就表示<em>cout</em>是在 std namsoace 中。</p></li></ol><ol start="2"><li><p><strong>using namespace std</strong></p><p>另一种方法是：用<strong>使用指令(using directive)**</strong><code>using namespace std</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">// this is a using directive telling the compiler to check the std namespace when resolving identifiers with no prefix</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!"</span>; <span class="comment">// cout has no prefix, so the compiler will check to see if cout is defined locally or in namespace std</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>using directive</strong>：告诉编译器 当试图解析一个没有使用<u>命名空间前缀(namespace prefix)</u>的标识符时，检查一个指定的命名空间。</p></blockquote><p><strong>【不推荐此方法】</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // imports the declaration of std::cout</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">// makes std::cout accessible as "cout"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cout</span><span class="params">()</span> <span class="comment">// declares our own "cout" function</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, world!"</span>; <span class="comment">// Compile error!  Which cout do we want here?  The one in the std namespace or the one we defined above?</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况，将不会被编译。因为编译器不知道我们到底想用我们自己定义的cout函数，还是想用 std命名空间 中的cout函数。</p><p>并且，虽然标识符名称现在可能不冲突，但在将来的语言修订中，它可能与添加到std名称空间的新标识符发生冲突。</p></li></ol><h2 id="2-10-预处理器"><a href="#2-10-预处理器" class="headerlink" title="2.10 预处理器"></a>2.10 预处理器</h2><p>在编译之前，代码要经过一个阶段，叫做“<strong>翻译(translation)</strong>”。在翻译阶段会发生许多事情，以使您的代码准备好被编译(如果您感兴趣，可以在<a href="https://en.cppreference.com/w/cpp/language/translation_phases" target="_blank" rel="noopener">这里</a>找到翻译阶段的列表)。应用翻译的代码文件称为<strong>翻译单元(translation unit)</strong>。</p><p>最值得注意的是：翻译阶段包含<strong>预处理器(preprocessor)</strong>。最好将预处理器看作是一个单独的程序，它处理每个代码文件中的文本部分。</p><p>当预处理器运行时，它从头到尾的扫描源码文件，寻找预处理程序指令。</p><blockquote><p><strong>预处理指令(preprocessor directives)，也称作directives</strong>：<u>是以“#”符号开始，以换行符结束的指令(不是分号，即不要加分号)</u>。</p></blockquote><ul><li><strong>“使用指令(using directives)”</strong>不是预处理指令，所以不会被预处理器处理。所以当提起“directive”，通常指的是“preprocessor directive”</li></ul><h4 id="include"><a href="#include" class="headerlink" title="include"></a>include</h4><p>当你<em>#include*一个文件，预处理器将会把</em>#include*指令 替换为 include file的内容。（include file 的内容将会被预处理，然后被编译）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, world!"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当预处理器运行时，预处理器将会把<code>#include &lt;iostream&gt;</code>替换为 名为“iostream”的文件。</p></blockquote><h4 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h4><p><strong>宏定义：Macro defines</strong></p><p><em>#include</em> 指令可以用来创建<strong>宏</strong>。在C++中，<strong>宏</strong>是定义如何将 ‘输入文本’ 转换为 ‘替换输出文本’。</p><p>宏有两种基本类型：1️⃣<strong>对象式宏</strong>(<em>object-like macros</em>)。2️⃣<strong>函数式宏</strong>( <em>function-like macros</em>)</p><ol><li><p>函数式宏</p><p>函数式宏的作用类似于函数，并具有类似的用途。</p></li><li><p>对象式宏</p><p>可以被定义成以下两种形式：</p><ul><li><p>#define identifier</p></li><li><p>#define identifier substitution_text</p><blockquote><p>此处，identifier：宏名【一般是大写字母，用下划线表示空格】；substitution_text：替换文本(替换输出文本)</p></blockquote></li></ul><p>1.带有输出文本(substitution_text)：当预处理器处理此条指令时，宏名 将会被替换为‘输出文本’。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_NAME <span class="meta-string">"Alex"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"My name is: "</span> &lt;&lt; MY_NAME;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预处理程序将上述转换为以下内容:</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"My name is: "</span> &lt;&lt; <span class="string">"Alex"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.不带输出文本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USE_YEN</span></span><br></pre></td></tr></table></figure><p>如你所想，这条宏指令工作方式：标识符的任何进一步出现都将被删除，并将被nothing替换!</p></li></ol><h4 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h4><p><strong>条件编译：conditional compilation</strong></p><p>使用<strong>条件编译的预处理指令</strong>可以设置在什么条件下编译，什么条件下不编译。比较常见的条件编译指令有以下三个：<em>#ifdef*、</em>#ifndef<em>、</em>#endif*</p><ul><li><p><strong><em>#ifdef</em></strong> 预处理指令允许预处理器检查这个标识符(identifier)是否已经被 #define(定义了)。如果被定义，那么在<em>#ifdef*和</em>#endif*之间的代码将会被编译；如果没被定义，这些代码将会被忽略。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_JOE</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PRINT_JOE</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Joe\n"</span>; <span class="comment">// if PRINT_JOE is defined, compile this code</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PRINT_BOB</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Bob\n"</span>; <span class="comment">// if PRINT_BOB is defined, compile this code</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><em>ifndef</em></strong>指令和<em>ifdef*指令的作用是相反的。即，如果这个标识符没有被 #define，那么在</em>#ifndef<em>和</em>#endif*之间的代码才会被编译</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PRINT_BOB</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Bob\n"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是“Bob”,因为PRINT_BOB没有被 #define，所有才会执行。</p></li><li><p><strong><em>#if 0</em></strong> ：条件编译的另一个常见用法是使用<em>#if 0</em>来排除正在编译的代码块(就像它在一个注释块中一样):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Joe\n"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0 <span class="comment">// Don't compile anything starting here</span></span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Bob\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Steve\n"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// until this point</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>【注】<strong>对象式宏</strong>不会影响<strong>预处理器的其他指令</strong></p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO 9 <span class="comment">// Here's a macro substitution</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> FOO <span class="comment">// This FOO does not get replaced because it’s part of another preprocessor directive</span></span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; FOO; <span class="comment">// This FOO gets replaced with 9 because it's part of the normal code</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="宏定义的范围"><a href="#宏定义的范围" class="headerlink" title="宏定义的范围"></a>宏定义的范围</h4><p>指令在编译之前，从上到下逐个文件地解析。</p><ol><li><strong>同一文件中</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_NAME <span class="meta-string">"Alex"</span></span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"My name is: "</span> &lt;&lt; MY_NAME;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然，上面的代码表面上看起来：<em>#define MY_NAME “Alex”</em>是定义在函数<em>foo</em>内部的。<strong>但是预处理器将不会注意，因为它不懂C++中的概念，例如函数。所以，这个程序的执行流程与#define MY_NAME “Alex”在函数foo之前或之后定义的行为相同。</strong>但是，一般情况下，我们习惯于将 <code>#define identifiers</code>这种宏定义放在函数的外面。</p><ol start="2"><li><strong>同一项目的不同文件中</strong></li></ol><p>预处理程序完成后，将丢弃该文件中定义的所有标识符。这意味着指令仅从<strong>定义点</strong>到<strong>定义它们的文件末尾</strong>有效。<u>在一个代码文件中定义的指令不会影响同一项目中的其他代码文件。</u></p><p>example：</p><p><code>function.cpp:</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PRINT</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Printing!"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PRINT</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Not printing!"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>; <span class="comment">// forward declaration for function doSomething()</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    doSomething();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行的结果是：Not printing!</p><p><strong>因为文件之间的宏定义互不影响。</strong></p><h2 id="2-11-头文件"><a href="#2-11-头文件" class="headerlink" title="2.11 头文件"></a>2.11 头文件</h2><p><strong>头文件：Header files</strong></p><p>当程序变得越来越大了，对每个函数都进行提前声明是很乏味无趣的。如果能够将所有的 提前声明 放在一个地方，然后在需要时导入它们，这不是很好吗?</p><blockquote><p><strong>code files</strong>：<strong>源文件(后缀 .cpp)</strong>；<strong>header files</strong>：<strong>头文件(后缀 .h 或 .hpp)</strong></p></blockquote><p>头文件的主要用途就是：将 声明 引入 源文件 中。</p><h4 id="使用标准库头文件"><a href="#使用标准库头文件" class="headerlink" title="使用标准库头文件"></a>使用标准库头文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, world!"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序使用<em>std::cout</em>。但是这个程序没有提供关于<em>std::cout</em>的声明或者定义，那编译器是如何知道<em>std::cout</em>是什么呢？</p><p>答：因为<em>std::cout<em>在头文件“iostream” 中 已经提前声明过了。当我们<code>#include &lt;iostream&gt;</code>时，我们就请求预处理器将头文件“iostream”中的所有内容(当然也包含</em>std::cout</em>)都复制过来。</p><blockquote><p><strong>注意：</strong><red>当<code>#include xxx</code>时，xxx头文件的所有内容都被引入到当前文件中。</red></p></blockquote><p><strong>头文件通常只包含：函数和对象的声明，不包含它们的定义</strong>。</p><blockquote><p>如 <em>std::cout</em>在头文件“iostream”中<u>声明</u>， 但 <u>定义</u>为c++标准库的一部分，在链接器阶段自动链接到程序中。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter2/IncludeLibrary.png" alt="IncludeLibrary"></p></blockquote><h4 id="创建自己的头文件"><a href="#创建自己的头文件" class="headerlink" title="创建自己的头文件"></a>创建自己的头文件</h4><p>步骤：</p><ol><li><strong>头文件保护符(header guaed)</strong></li><li>然后添加头文件(后缀 .h)进行声明；相应的也要添加源文件(后缀 .cpp)进行定义。【注意头文件、源文件的名字要一样】</li></ol><p>创建完之后：</p><p><code>add.h</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1) We really should have a header guard here, but will omit it for simplicity (we'll cover header guards in the next lesson)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2) This is the content of the .h file, which is where the declarations go</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="comment">// function prototype for add.h -- don't forget the semicolon!</span></span><br></pre></td></tr></table></figure><p><code>add.cpp</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"add.h"</span> <span class="comment">// Insert contents of add.h at this point.  Note use of double quotes here.【不是标准库的头文件，一般用双引号""】</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of 3 and 4 is "</span> &lt;&lt; add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序的编译、链接过程：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter2/IncludeHeader.png" alt="IncludeHeader"></p><h4 id="头文件的-lt-gt-amp-””"><a href="#头文件的-lt-gt-amp-””" class="headerlink" title="头文件的&lt;&gt;&amp;””"></a>头文件的&lt;&gt;&amp;””</h4><p><strong>尖括号</strong>：<strong>Angled brackets</strong> ，即<strong>&lt;&gt;</strong>。尖括号用来告诉预处理程序我们包含了编译器包含的头文件，所以它应该在<u>系统目录中查找那个头文件</u>。</p><p><strong>双引号</strong>：<strong>double-quotes</strong>，即<strong>“”</strong>。双引号告诉预处理器这是一个用户定义的头文件，所以它应该在当前目录中寻找这个头文件。如果没找到，它会检查其他的包含路径(已指定为compiler/IDE设置的一部分的路径)。如果还是失败的话，它将去系统目录中寻找这个头文件。</p><h4 id="“iostream”没-h-后缀？"><a href="#“iostream”没-h-后缀？" class="headerlink" title="“iostream”没 .h 后缀？"></a>“iostream”没 .h 后缀？</h4><ol><li><p>好奇，为什么“iostream”(或者其他标准库头文件)没有后缀 .h？</p><p>答：因为<em>iostream.h</em>是另一个头文件</p></li><li><p><em>iostream.h</em>与<em>iostream</em>：</p><p>在C++最开始创建的时候，所有标准库都是有 .h 后缀的。但是，后来ANSI委员会修改C++，将所有的标准库放在 <em>std 命名空间</em> 中，进而避免与用户自定义的标识符 冲突。</p><p>但是为题来了，将这些标准库移入<em>std 命名空间</em> 后，以前的程序将无法运行。为了解决这个问题，一个新的头文件：<em>iostream</em>出现，这个新头文件包含了 <em>iostream.h</em>的所有内容。然后，旧的程序依然可以用<code>#include &lt;iostream.h&gt;</code>，新程序就用<code>#include &lt;iostream&gt;</code></p></li></ol><h4 id="头文件路径建议"><a href="#头文件路径建议" class="headerlink" title="头文件路径建议"></a>头文件路径建议</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/myHeader.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../moreHeaders/myOtherHeader.h"</span></span></span><br></pre></td></tr></table></figure><p>这种设置成路径形式的头文件，假设现在路径没问题。但是很有可能在某一天，你的文件位置就不小心的被移动了，这时候就用不了了。</p><p>【建议】将你平常会用到的很多不同的文件放在比较固定的地方，然后在你的 compiler/IDE 这个固定地方的位置。这样当它在当前目录中找不到它们时，它就会去你设置的固定位置找。这通常可以通过在IDE项目设置中设置包含路径或搜索目录来实现。</p><blockquote><p>visual studio设置方法：</p><p>在“解决方案”中，点击project的“属性”，然后看到“VC++目录”中的“包含目录(include directories)”，在这里面添加你要使用的头文件的目录。</p></blockquote><p>这种方法的优点是，如果要更改目录结构，只需更改单个编译器或IDE设置，而不必更改每个代码文件。</p><h2 id="2-12-头文件保护符"><a href="#2-12-头文件保护符" class="headerlink" title="2.12 头文件保护符"></a>2.12 头文件保护符</h2><p><strong>头文件保护符：header guards</strong></p><h3 id="重复定义"><a href="#重复定义" class="headerlink" title="重复定义"></a>重复定义</h3><p><strong>duplicate definition：重复定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变量重定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x; <span class="comment">// this is a definition for variable x</span></span><br><span class="line">    <span class="keyword">int</span> x; <span class="comment">// compile error: duplicate definition</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数重定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> <span class="comment">// this is a definition for function foo</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> <span class="comment">// compile error: duplicate definition</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; foo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种比较容易修复。</p><hr><p>但是在头文件中，很容易出现一个头文件中的定义被include不止一次。这通常发生在 一个头文件 又#include 其他头文件：</p><p><code>square.h</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在头文件中，不建议出现 定义；但是这里为了方便举例</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSquareSides</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>geometry.h</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"square.h"</span></span></span><br></pre></td></tr></table></figure><p><code>main.cpp</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"square.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"geometry.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个程序。首先，在<code>main.cpp</code>中<em>#include square.h</em> ，它(<em>square.h</em>)将<code>getSquareSides</code>函数的定义复制到main.cpp中。然后，<code>main.cpp</code>又<em>#include geometry.h</em> ，它(<em>geometry.h</em>)又包含了<em>square.h</em>，所以也会将<em>square.h</em>中的内容(包括<code>getSquareSides</code>函数)复制到<em>geometry.h</em>，进而也就被复制到<em>main.cpp</em>中。</p><p>所以，当解析完所有的<em>#include</em>之后，main.cpp就变成这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSquareSides</span><span class="params">()</span>  <span class="comment">// from square.h</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSquareSides</span><span class="params">()</span> <span class="comment">// from geometry.h (via square.h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，就会出现重复定义，编译也会出错。每个单独的文件没问题，但是因为main.cpp最终#include了两次square.h的内容，所以我们遇到了问题。如何解决呢？？？答：使用<strong>header guard</strong></p><h3 id="头文件保护符"><a href="#头文件保护符" class="headerlink" title="头文件保护符"></a>头文件保护符</h3><p><strong>头文件保护符(header guard)</strong>是<strong>条件编译(conditional compilation)</strong>的指令，它的形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SOME_UNIQUE_NAME_HERE <span class="comment">//SOME_UNIQUE_NAME_HERE：你可以用任何名字代替它</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOME_UNIQUE_NAME_HERE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里是写关于 声明 的代码</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>当这个头文件被<em>#included</em>时，预处理器检查<code>SOME_UNIQUE_NAME_HERE</code>是否被定义过。</p><ul><li>如果这是我们第一次包含这个头文件，<code>SOME_UNIQUE_NAME_HERE</code>还没有被创建。然后就会定义<code>SOME_UNIQUE_NAME_HERE</code>，而且会包含文件的内容。</li><li>如果这个头文件之前已经被包含到这个文件中，那么<code>SOME_UNIQUE_NAME_HERE</code>是已经被定义过的，而且其内容也以经被包含在这个文件中。所以这个头文件的内容将会被忽略（由于<strong><code>#ifndef</code></strong>）。</li></ul><hr><p><strong>每一个头文件都应该要有头文件保护符</strong>。</p><hr><p><strong>好的头文件保护符命名规则</strong>：</p><p><code>&lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H</code>或者<code>&lt;FILE&gt;_&lt;LARGE RANDOM NUMBER&gt;_H</code>或者<code>&lt;FILE&gt;_&lt;CREATION DATE&gt;_H</code></p><hr><p>请注意，头文件保护的目标是防止<strong>源文件</strong>多次接收到被保护的<strong>头文件</strong>。根据设计，头文件保护<strong>不</strong>会阻止将给定的头文件(一次)包含到单独的源码文件中。这也会导致意想不到的问题：</p><p><code>square.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SQUARE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE_H</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSquareSides</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSquarePerimeter</span><span class="params">(<span class="keyword">int</span> sideLength)</span></span>; <span class="comment">// forward declaration for getSquarePerimeter</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>square.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"square.h"</span>  <span class="comment">// square.h is included once here</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSquarePerimeter</span><span class="params">(<span class="keyword">int</span> sideLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sideLength * getSquareSides();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"square.h"</span> <span class="comment">// square.h is also included once here</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a square has "</span> &lt;&lt; getSquareSides() &lt;&lt; <span class="string">" sides\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a square of length 5 has perimeter length "</span> &lt;&lt; getSquarePerimeter(<span class="number">5</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，square.h包含在main.cpp和square.cpp中。这意味着square.h的内容将被包含一次到square.cpp中，一次到main.cpp中。</p><blockquote><p>细节：</p><p>当<code>square.h</code>被包含在<code>square.cpp</code>中时，在<code>square.cpp</code>结束之前，<code>SQUARE_H</code>都一直被定义。（这阻止了<code>square.h</code>被多次包含于<code>square.cpp</code>。也真是头文件保护符起作用的）。然而，一旦<code>square.cpp</code>结束后，<code>SQUARE_H</code>将不再被定义。这就意味着当预处理器运行<code>main.cpp</code>时，<code>SQUARE_H</code>在<code>main.cpp</code>中最初是没有定义的。</p><p>结果就是，<code>square.cpp</code>和<code>main.cpp</code>都复制了<em>getSquareSides</em>的定义。这个程序将<strong>可以被编译</strong>，但是会<strong>链接出错</strong>（链接器会抱怨为什么会有不止一个的<em>getSquareSides</em>的定义）</p></blockquote><p><strong>最好的解决办法就是：将函数的<u>定义</u>放在源文件中(即 .cpp文件中)，头文件中只含有<u>声明</u>。</strong></p><h3 id="pragma-once"><a href="#pragma-once" class="headerlink" title="#pragma once"></a>#pragma once</h3><p><code>#program once</code>的作用和头文件标识符相同，但是它更加短。</p><blockquote><p>但是，<code>#program once</code>不是C++官方原生的一部分，所以<strong>不是所有的编译器都支持它</strong>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let’s Build A Simple Interpreter-10</title>
      <link href="/archives/2f66ae56.html"/>
      <url>/archives/2f66ae56.html</url>
      
        <content type="html"><![CDATA[<p>今天的改进内容：</p><ol><li>如何进行语法Fenix和解释Pascal的程序头部；</li><li>如何进行语法分析Pascal的变量声明；</li><li>将更新解释器，用<em>DIV</em>关键字来表示整数的出发、用品”<strong>/</strong>“来表示浮点数的除法；</li><li>添加Pascal语言的注释功能</li></ol><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-10/lsbasi_part10_intro.png" alt="img"></p><a id="more"></a><h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p>在进行细致的讲解之前，我们先下载本节的解释器的<a href="https://github.com/rspivak/lsbasi/blob/master/part10/python/spi.py" target="_blank" rel="noopener">源码：spy.py</a>和一个简单的Pascal语言的<a href="https://github.com/rspivak/lsbasi/blob/master/part10/python/part10.pas" target="_blank" rel="noopener">程序：part10.pas</a>。然后再在命令提示符(Windows10系统 可直接在左下角搜索框中搜索“cmd”)中进行输入：<code>python spi.py part10.pas</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-10/image-20200325134921750.png" alt="image-20200325134921750"></p><p>好了。现在来看看今天要改进的内容，我们将学习：</p><ol><li>如何进行语法Fenix和解释Pascal的程序头部；</li><li>如何进行语法分析Pascal的变量声明；</li><li>将更新解释器，用<em>DIV</em>关键字来表示整数的出发、用品”<strong>/</strong>“来表示浮点数的除法；</li><li>添加Pascal语言的注释功能</li></ol><h2 id="更新后的语法规则"><a href="#更新后的语法规则" class="headerlink" title="更新后的语法规则"></a>更新后的语法规则</h2><p>更新后的语法规则，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-10/lsbasi_part10_grammar1.png" alt="lsbasi_part10_grammar1"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-10/lsbasi_part10_grammar2.png" alt="lsbasi_part10_grammar2"></p><blockquote><p>这里给出一个简单地Pascal语言的程序，便于理解其语法：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PROGRAM</span> Part10;</span><br><span class="line"><span class="keyword">VAR</span></span><br><span class="line">   number     : INTEGER;</span><br><span class="line">   a, b, c, x : INTEGER;</span><br><span class="line">   y          : REAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> <span class="comment">&#123;Part10&#125;</span></span><br><span class="line">   <span class="keyword">BEGIN</span></span><br><span class="line">      number := <span class="number">2</span>;</span><br><span class="line">      a := number;</span><br><span class="line">      b := <span class="number">10</span> * a + <span class="number">10</span> * number <span class="keyword">DIV</span> <span class="number">4</span>;</span><br><span class="line">      c := a - - b</span><br><span class="line">   <span class="keyword">END</span>;</span><br><span class="line">   x := <span class="number">11</span>;</span><br><span class="line">   y := <span class="number">20</span> / <span class="number">7</span> + <span class="number">3.14</span>;</span><br><span class="line">   <span class="comment">&#123; writeln('a = ', a); &#125;</span></span><br><span class="line">   <span class="comment">&#123; writeln('b = ', b); &#125;</span></span><br><span class="line">   <span class="comment">&#123; writeln('c = ', c); &#125;</span></span><br><span class="line">   <span class="comment">&#123; writeln('number = ', number); &#125;</span></span><br><span class="line">   <span class="comment">&#123; writeln('x = ', x); &#125;</span></span><br><span class="line">   <span class="comment">&#123; writeln('y = ', y); &#125;</span></span><br><span class="line"><span class="keyword">END</span>.  <span class="comment">&#123;Part10&#125;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="1-program"><a href="#1-program" class="headerlink" title="1. program"></a>1. program</h3><p>程序定义的语法规则，包括：保留字“<strong><em>PROGRAM</em></strong>”、程序的<strong>名字</strong>、一个以点“<strong>.</strong>”结尾的<strong>block</strong>。如：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PROGRAM</span> Part10;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">END</span>.</span><br></pre></td></tr></table></figure><blockquote><p>上面是一个完整的Pascal程序</p></blockquote><h3 id="2-block"><a href="#2-block" class="headerlink" title="2. block"></a>2. block</h3><p>block包含：一个<strong>声明规则</strong>、<strong>复合语句</strong>，如：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例1</span></span><br><span class="line"><span class="keyword">VAR</span></span><br><span class="line">   number : INTEGER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例2</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><h3 id="3-declarations"><a href="#3-declarations" class="headerlink" title="3. declarations"></a>3. declarations</h3><p>Pascal的声明有几个部分，每个部分都是可选的。本节中，我们只讨论变量声明的部分。变量声明规则：要么有一个变量声明的子规则，要么是空的。</p><h3 id="4-VAR"><a href="#4-VAR" class="headerlink" title="4. VAR"></a>4. VAR</h3><p>Pascal是静态类语言，也就是说在使用每一个变量之前，都需要明确的声明它的类型。变量的声明在程序中用<strong>VAR</strong>保留字，如：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">VAR</span></span><br><span class="line">   number     : INTEGER;</span><br><span class="line">   a, b, c, x : INTEGER;</span><br><span class="line">   y          : REAL;</span><br></pre></td></tr></table></figure><h3 id="5-type-spec"><a href="#5-type-spec" class="headerlink" title="5. type_spec"></a>5. type_spec</h3><p>在本节中，数据类型是两种：INTEGER 和 REAL(float)，常出现在变量声明部分：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">VAR</span></span><br><span class="line">   a : INTEGER;</span><br><span class="line">   b : REAL;</span><br></pre></td></tr></table></figure><blockquote><p>本节中没有进行设计类型检查，这将会在后续文章中添加</p></blockquote><h3 id="6-term"><a href="#6-term" class="headerlink" title="6. term"></a>6. term</h3><p>term规则更新之后，将整数、浮点数的出发分开表示：DIV、/</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span> / <span class="number">7</span> = <span class="number">2.85714285714</span> <span class="comment">//浮点数出发</span></span><br><span class="line"><span class="number">20</span> <span class="keyword">DIV</span> <span class="number">7</span> = <span class="number">2</span>           <span class="comment">//整数除法</span></span><br></pre></td></tr></table></figure><h3 id="7-factor"><a href="#7-factor" class="headerlink" title="7. factor"></a>7. factor</h3><p>更新之后可以处理整数、浮点数的常量。</p><hr><p>以下是今天的完整语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">program : PROGRAM variable SEMI block DOT</span><br><span class="line"></span><br><span class="line">block : declarations compound_statement</span><br><span class="line"></span><br><span class="line">declarations : VAR (variable_declaration SEMI)+</span><br><span class="line">             | empty</span><br><span class="line"></span><br><span class="line">variable_declaration : ID (COMMA ID)* COLON type_spec</span><br><span class="line"></span><br><span class="line">type_spec : INTEGER | REAL</span><br><span class="line"></span><br><span class="line">compound_statement : BEGIN statement_list END</span><br><span class="line"></span><br><span class="line">statement_list : statement</span><br><span class="line">               | statement SEMI statement_list</span><br><span class="line"></span><br><span class="line">statement : compound_statement</span><br><span class="line">          | assignment_statement</span><br><span class="line">          | empty</span><br><span class="line"></span><br><span class="line">assignment_statement : variable ASSIGN expr</span><br><span class="line"></span><br><span class="line">empty :</span><br><span class="line"></span><br><span class="line">expr : term ((PLUS | MINUS) term)*</span><br><span class="line"></span><br><span class="line">term : factor ((MUL | INTEGER_DIV | FLOAT_DIV) factor)*</span><br><span class="line"></span><br><span class="line">factor : PLUS factor</span><br><span class="line">       | MINUS factor</span><br><span class="line">       | INTEGER_CONST</span><br><span class="line">       | REAL_CONST</span><br><span class="line">       | LPAREN expr RPAREN</span><br><span class="line">       | variable</span><br><span class="line"></span><br><span class="line">variable: ID</span><br></pre></td></tr></table></figure><h2 id="更新Lexer"><a href="#更新Lexer" class="headerlink" title="更新Lexer"></a>更新Lexer</h2><p>总结一下，lexer的改变：</p><ol><li>新的tokens</li><li>新的保留字</li><li>添加处理Pascal语言的注释，用<em>skip_comment</em></li><li>更新<em>integer</em></li><li>更新<em>get_next_token</em> ，使其能够返回新添加的tokens</li></ol><p>让我们深入研究一下上面提到的变化:</p><ol><li><p>为了处理程序头、变量的声明、整数与浮点数常量以及它们的除法。我们需要添加新的tokens，我们还需要更新“INTEGER”的含义：表示一个整数类型，而不是一个整数常量。</p><p>下面是更新后全部的<strong>tokens</strong>:</p><ul><li>PROGRAM (reserved keyword)</li><li>VAR (reserved keyword)</li><li>COLON (:)</li><li>COMMA (,)</li><li>INTEGER (we change it to mean integer type and not integer constant like 3 or 5)</li><li>REAL (for Pascal REAL type)</li><li>INTEGER_CONST (for example, 3 or 5)</li><li>REAL_CONST (for example, 3.14 and so on)</li><li>INTEGER_DIV for integer division (the <strong><em>DIV</em></strong> reserved keyword)</li><li>FLOAT_DIV for float division ( forward slash / )</li></ul></li><li><p>全部的<strong>保留字</strong>token：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RESERVED_KEYWORDS = &#123;</span><br><span class="line">    <span class="string">'PROGRAM'</span>: Token(<span class="string">'PROGRAM'</span>, <span class="string">'PROGRAM'</span>),</span><br><span class="line">    <span class="string">'VAR'</span>: Token(<span class="string">'VAR'</span>, <span class="string">'VAR'</span>),</span><br><span class="line">    <span class="string">'DIV'</span>: Token(<span class="string">'INTEGER_DIV'</span>, <span class="string">'DIV'</span>),</span><br><span class="line">    <span class="string">'INTEGER'</span>: Token(<span class="string">'INTEGER'</span>, <span class="string">'INTEGER'</span>),</span><br><span class="line">    <span class="string">'REAL'</span>: Token(<span class="string">'REAL'</span>, <span class="string">'REAL'</span>),</span><br><span class="line">    <span class="string">'BEGIN'</span>: Token(<span class="string">'BEGIN'</span>, <span class="string">'BEGIN'</span>),</span><br><span class="line">    <span class="string">'END'</span>: Token(<span class="string">'END'</span>, <span class="string">'END'</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>处理<strong>注释</strong>，添加一个<em>skip_comment</em> 函数来处理注释，它的原理就是在找到右花括号“｛”之前，丢弃所有字符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">skip_comment</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> self.current_char != <span class="string">'&#125;'</span>:</span><br><span class="line">        self.advance()</span><br><span class="line">    self.advance()  <span class="comment"># the closing curly brace</span></span><br></pre></td></tr></table></figure></li><li><p>重新命名<strong><em>integer</em>函数</strong>为<strong><em>number</em>函数</strong>，，使其能够处理整型常量和浮点型常量，如3和3.14：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">number</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Return a (multidigit) integer or float consumed from the input."""</span></span><br><span class="line">    result = <span class="string">''</span></span><br><span class="line">    <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">        result += self.current_char</span><br><span class="line">        self.advance()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.current_char == <span class="string">'.'</span>:</span><br><span class="line">        result += self.current_char</span><br><span class="line">        self.advance()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (</span><br><span class="line">            self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span></span><br><span class="line">            self.current_char.isdigit()</span><br><span class="line">        ):</span><br><span class="line">            result += self.current_char</span><br><span class="line">            self.advance()</span><br><span class="line"></span><br><span class="line">        token = Token(<span class="string">'REAL_CONST'</span>, float(result))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        token = Token(<span class="string">'INTEGER_CONST'</span>, int(result))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> token</span><br></pre></td></tr></table></figure></li><li><p>更新<strong><em>get_next_token</em>函数</strong>，使其能够返回新增的tokens：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> self.current_char == <span class="string">'&#123;'</span>:</span><br><span class="line">            self.advance()</span><br><span class="line">            self.skip_comment()</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> self.current_char.isdigit():</span><br><span class="line">            <span class="keyword">return</span> self.number()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.current_char == <span class="string">':'</span>:</span><br><span class="line">            self.advance()</span><br><span class="line">            <span class="keyword">return</span> Token(COLON, <span class="string">':'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.current_char == <span class="string">','</span>:</span><br><span class="line">            self.advance()</span><br><span class="line">            <span class="keyword">return</span> Token(COMMA, <span class="string">','</span>)</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> self.current_char == <span class="string">'/'</span>:</span><br><span class="line">            self.advance()</span><br><span class="line">            <span class="keyword">return</span> Token(FLOAT_DIV, <span class="string">'/'</span>)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></li></ol><h2 id="更新Parser"><a href="#更新Parser" class="headerlink" title="更新Parser"></a>更新Parser</h2><p>总结Parser的变化：</p><ol><li>新的<strong>抽象语法树结点（AST nodes）</strong>：<em>Program</em>, <em>Block</em>, <em>VarDecl</em>, <em>Type</em></li><li>对应新的语法规则的函数：<em>block</em>, <em>declarations</em>, <em>variable_declaration</em>, 和 <em>type_spec</em>.</li><li>更新已经存在的paeser中的方法：<em>program</em>, <em>term</em>, and <em>factor</em></li></ol><p>让我们深入研究一下上面提到的变化:</p><ol><li><p>新的<strong>AST nodes</strong>：</p><ul><li><p><em>Program</em> AST node：表示一个程序，也是我们的根节点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Program</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, block)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.block = block</span><br></pre></td></tr></table></figure></li><li><p><em>Block</em> AST node：包含声明与复合语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Block</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, declarations, compound_statement)</span>:</span></span><br><span class="line">        self.declarations = declarations</span><br><span class="line">        self.compound_statement = compound_statement</span><br></pre></td></tr></table></figure></li><li><p><em>VarDecl</em> AST node：表示一个变量声明，它包含一个边梁节点和变量的类型结点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VarDecl</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, var_node, type_node)</span>:</span></span><br><span class="line">        self.var_node = var_node</span><br><span class="line">        self.type_node = type_node</span><br></pre></td></tr></table></figure></li><li><p><em>Type</em> AST node：表示一个变量类型（INTEGER or REAL）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Type</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, token)</span>:</span></span><br><span class="line">        self.token = token</span><br><span class="line">        self.value = token.value</span><br></pre></td></tr></table></figure></li></ul></li><li><p>对应<strong>新增的语法规则的函数(方法)</strong>：<em>block</em>, <em>declarations</em>, <em>variable_declaration</em>, 和 <em>type_spec</em>.【这些方法负责解析新的语言结构和构造新的AST nodes】：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">block</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""block : declarations compound_statement"""</span></span><br><span class="line">    declaration_nodes = self.declarations()</span><br><span class="line">    compound_statement_node = self.compound_statement()</span><br><span class="line">    node = Block(declaration_nodes, compound_statement_node)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">declarations</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""declarations : VAR (variable_declaration SEMI)+</span></span><br><span class="line"><span class="string">                    | empty</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    declarations = []</span><br><span class="line">    <span class="keyword">if</span> self.current_token.type == VAR:</span><br><span class="line">        self.eat(VAR)</span><br><span class="line">        <span class="keyword">while</span> self.current_token.type == ID:</span><br><span class="line">            var_decl = self.variable_declaration()</span><br><span class="line">            declarations.extend(var_decl)</span><br><span class="line">            self.eat(SEMI)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> declarations</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">variable_declaration</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""variable_declaration : ID (COMMA ID)* COLON type_spec"""</span></span><br><span class="line">    var_nodes = [Var(self.current_token)]  <span class="comment"># first ID</span></span><br><span class="line">    self.eat(ID)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> self.current_token.type == COMMA:</span><br><span class="line">        self.eat(COMMA)</span><br><span class="line">        var_nodes.append(Var(self.current_token))</span><br><span class="line">        self.eat(ID)</span><br><span class="line"></span><br><span class="line">    self.eat(COLON)</span><br><span class="line"></span><br><span class="line">    type_node = self.type_spec()</span><br><span class="line">    var_declarations = [</span><br><span class="line">        VarDecl(var_node, type_node)</span><br><span class="line">        <span class="keyword">for</span> var_node <span class="keyword">in</span> var_nodes</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">return</span> var_declarations</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">type_spec</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""type_spec : INTEGER</span></span><br><span class="line"><span class="string">                 | REAL</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    token = self.current_token</span><br><span class="line">    <span class="keyword">if</span> self.current_token.type == INTEGER:</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.eat(REAL)</span><br><span class="line">    node = Type(token)</span><br><span class="line">    <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure></li><li><p>更新已有的<em>program</em>, <em>term</em>, 和, <em>factor</em> 方法来适应语法的改变：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">program</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""program : PROGRAM variable SEMI block DOT"""</span></span><br><span class="line">    self.eat(PROGRAM)</span><br><span class="line">    var_node = self.variable()</span><br><span class="line">    prog_name = var_node.value</span><br><span class="line">    self.eat(SEMI)</span><br><span class="line">    block_node = self.block()</span><br><span class="line">    program_node = Program(prog_name, block_node)</span><br><span class="line">    self.eat(DOT)</span><br><span class="line">    <span class="keyword">return</span> program_node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""term : factor ((MUL | INTEGER_DIV | FLOAT_DIV) factor)*"""</span></span><br><span class="line">    node = self.factor()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, INTEGER_DIV, FLOAT_DIV):</span><br><span class="line">        token = self.current_token</span><br><span class="line">        <span class="keyword">if</span> token.type == MUL:</span><br><span class="line">            self.eat(MUL)</span><br><span class="line">        <span class="keyword">elif</span> token.type == INTEGER_DIV:</span><br><span class="line">            self.eat(INTEGER_DIV)</span><br><span class="line">        <span class="keyword">elif</span> token.type == FLOAT_DIV:</span><br><span class="line">            self.eat(FLOAT_DIV)</span><br><span class="line"></span><br><span class="line">        node = BinOp(left=node, op=token, right=self.factor())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""factor : PLUS factor</span></span><br><span class="line"><span class="string">              | MINUS factor</span></span><br><span class="line"><span class="string">              | INTEGER_CONST</span></span><br><span class="line"><span class="string">              | REAL_CONST</span></span><br><span class="line"><span class="string">              | LPAREN expr RPAREN</span></span><br><span class="line"><span class="string">              | variable</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    token = self.current_token</span><br><span class="line">    <span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">        self.eat(PLUS)</span><br><span class="line">        node = UnaryOp(token, self.factor())</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">        self.eat(MINUS)</span><br><span class="line">        node = UnaryOp(token, self.factor())</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="keyword">elif</span> token.type == INTEGER_CONST:</span><br><span class="line">        self.eat(INTEGER_CONST)</span><br><span class="line">        <span class="keyword">return</span> Num(token)</span><br><span class="line">    <span class="keyword">elif</span> token.type == REAL_CONST:</span><br><span class="line">        self.eat(REAL_CONST)</span><br><span class="line">        <span class="keyword">return</span> Num(token)</span><br><span class="line">    <span class="keyword">elif</span> token.type == LPAREN:</span><br><span class="line">        self.eat(LPAREN)</span><br><span class="line">        node = self.expr()</span><br><span class="line">        self.eat(RPAREN)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        node = self.variable()</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure></li></ol><p>现在来看看我们的<strong>抽象语法树<em>Abstract Syntax Tree</em></strong>，下面是一个Pascal程序：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PROGRAM</span> Part10AST;</span><br><span class="line"><span class="keyword">VAR</span></span><br><span class="line">   a, b : INTEGER;</span><br><span class="line">   y    : REAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> <span class="comment">&#123;Part10AST&#125;</span></span><br><span class="line">   a := <span class="number">2</span>;</span><br><span class="line">   b := <span class="number">10</span> * a + <span class="number">10</span> * a <span class="keyword">DIV</span> <span class="number">4</span>;</span><br><span class="line">   y := <span class="number">20</span> / <span class="number">7</span> + <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">END</span>.  <span class="comment">&#123;Part10AST&#125;</span></span><br></pre></td></tr></table></figure><p>它的解析树为：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-10/lsbasi_part10_ast-1585124028847.png" alt="lsbasi_part10_ast"></p><p>在图中可以看到我们添加的新节点。</p><h2 id="更新Interpreter"><a href="#更新Interpreter" class="headerlink" title="更新Interpreter"></a>更新Interpreter</h2><p>现在，剩下的就是向解释器类添加新的访问者方法。下面是将要新增的四个访问方法（对应新增的四种结点）：</p><ul><li><em>visit_Program</em></li><li><em>visit_Block</em></li><li><em>visit_VarDecl</em></li><li><em>visit_Type</em></li></ul><ol><li><p>其中对于<em>VarDecl</em>和<em>Type</em>，解释器对他们什么都不做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_Program</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    self.visit(node.block)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_Block</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> declaration <span class="keyword">in</span> node.declarations:</span><br><span class="line">        self.visit(declaration)</span><br><span class="line">    self.visit(node.compound_statement)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_VarDecl</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    <span class="comment"># Do nothing</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_Type</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    <span class="comment"># Do nothing</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li><li><p>更新<em>visit_BinOp</em> 方法，使其能够准确的解释整数和浮点数的除法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_BinOp</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> node.op.type == PLUS:</span><br><span class="line">        <span class="keyword">return</span> self.visit(node.left) + self.visit(node.right)</span><br><span class="line">    <span class="keyword">elif</span> node.op.type == MINUS:</span><br><span class="line">        <span class="keyword">return</span> self.visit(node.left) - self.visit(node.right)</span><br><span class="line">    <span class="keyword">elif</span> node.op.type == MUL:</span><br><span class="line">        <span class="keyword">return</span> self.visit(node.left) * self.visit(node.right)</span><br><span class="line">    <span class="keyword">elif</span> node.op.type == INTEGER_DIV:</span><br><span class="line">        <span class="keyword">return</span> self.visit(node.left) // self.visit(node.right)</span><br><span class="line">    <span class="keyword">elif</span> node.op.type == FLOAT_DIV:</span><br><span class="line">        <span class="keyword">return</span> float(self.visit(node.left)) / float(self.visit(node.right))</span><br></pre></td></tr></table></figure></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下，在本文中，扩展了Pascal解释器的哪些部分：</p><ul><li>添加新的语法规则和更新现有的规则；</li><li>添加新token，并相应地添加新方法去处理这些tokens，更新了现有的方法；</li><li>parser中：为新的语法结构添加新的AST nodes；</li><li>向我们的递归下降解析器添加与新语法规则相对应的新方法，并更新一些现有的方法；</li><li>interpreter中添加新的访问方法，更新了一个现存的访问方法</li></ul><p>我们也出去了一些“HACKS”(part9 中提到的)：</p><ul><li>本文的解释器可以处理程序头部(<strong><em>PROGRAM</em></strong> header)</li><li>变量可以用VAR关键字来声明</li><li>将整数与浮点数的除法分开来</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Let’s Build A Simple Interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LSBASI整理</title>
      <link href="/archives/6fc94bb0.html"/>
      <url>/archives/6fc94bb0.html</url>
      
        <content type="html"><![CDATA[<center><red>持续更新</red></center><a id="more"></a><h2 id="part-3"><a href="#part-3" class="headerlink" title="part 3"></a><a href="https://www.longlongqin.github.io/archives/f957.html" target="_blank" rel="noopener">part 3</a></h2><ul><li>实现了<strong>加减混合运算</strong>，并引入<strong>语法图概念</strong></li></ul><h2 id="part-4"><a href="#part-4" class="headerlink" title="part 4"></a><a href="https://www.longlongqin.github.io/archives/3b16.html" target="_blank" rel="noopener">part 4</a></h2><ul><li>实现了整数的<strong>乘除混合运算</strong>，引入<strong>上下文无关语法(context-free-grammars)，即BNF</strong></li></ul><h2 id="part-5"><a href="#part-5" class="headerlink" title="part 5"></a><a href="https://www.longlongqin.github.io/archives/173c.html" target="_blank" rel="noopener">part 5</a></h2><ul><li>实现了<strong>加减乘除混合运算</strong>，引入<strong>结合律(associativity)</strong>和<strong>优先级(precedence)</strong></li></ul><h2 id="part-6"><a href="#part-6" class="headerlink" title="part 6"></a><a href="https://www.longlongqin.github.io/archives/167c.html" target="_blank" rel="noopener">part 6</a></h2><ul><li>新增<strong>括号运算</strong></li></ul><h2 id="part-7"><a href="#part-7" class="headerlink" title="part 7"></a><a href="https://www.longlongqin.github.io/archives/5a757a52.html" target="_blank" rel="noopener">part 7</a></h2><ul><li>从本小节开始，将<code>interpreter</code>和<code>parser</code>分开来实现。并引入<strong>抽象语法树(AST)</strong>和<strong>解析树(parse tree)</strong>概念</li></ul><h2 id="part-8"><a href="#part-8" class="headerlink" title="part 8"></a><a href="https://www.longlongqin.github.io/archives/ae12.html" target="_blank" rel="noopener">part 8</a></h2><ul><li>新增<strong>一元操作符(unary operators)</strong>：“+”，“-”</li></ul><h2 id="part-9"><a href="#part-9" class="headerlink" title="part 9"></a><a href="https://www.longlongqin.github.io/archives/8632918.html" target="_blank" rel="noopener">part 9</a></h2><h2 id="整体分析"><a href="#整体分析" class="headerlink" title="整体分析"></a>整体分析</h2><p>整体分析，不管是part x，都一起分析，看看他的整体结构：</p><h3 id="Lexer"><a href="#Lexer" class="headerlink" title="Lexer"></a>Lexer</h3><ul><li><p>token类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">INTEGER       = <span class="string">'INTEGER'</span> <span class="comment">#用于表示整数类型</span></span><br><span class="line">REAL          = <span class="string">'REAL'</span>  <span class="comment">#表示浮点型</span></span><br><span class="line">INTEGER_CONST = <span class="string">'INTEGER_CONST'</span> <span class="comment">#整型常量</span></span><br><span class="line">REAL_CONST    = <span class="string">'REAL_CONST'</span>  <span class="comment">#浮点型常量</span></span><br><span class="line">PLUS          = <span class="string">'PLUS'</span></span><br><span class="line">MINUS         = <span class="string">'MINUS'</span></span><br><span class="line">MUL           = <span class="string">'MUL'</span></span><br><span class="line">INTEGER_DIV   = <span class="string">'INTEGER_DIV'</span> <span class="comment">#整型数的除法</span></span><br><span class="line">FLOAT_DIV     = <span class="string">'FLOAT_DIV'</span> <span class="comment">#浮点数的除法</span></span><br><span class="line">LPAREN        = <span class="string">'LPAREN'</span> <span class="comment">#左小括号</span></span><br><span class="line">RPAREN        = <span class="string">'RPAREN'</span> <span class="comment">#右小括号</span></span><br><span class="line">ID            = <span class="string">'ID'</span> <span class="comment">#表示有效的标识符</span></span><br><span class="line">ASSIGN        = <span class="string">'ASSIGN'</span> <span class="comment">#这种token表示两个字符，“:=”,用于赋值语句</span></span><br><span class="line">BEGIN         = <span class="string">'BEGIN'</span> </span><br><span class="line">END           = <span class="string">'END'</span></span><br><span class="line">SEMI          = <span class="string">'SEMI'</span> <span class="comment"># 表示分号，用于标记复合语句中的一个句子的结尾</span></span><br><span class="line">DOT           = <span class="string">'DOT'</span> <span class="comment">#点，用于Pascal语言中program的定义</span></span><br><span class="line">PROGRAM       = <span class="string">'PROGRAM'</span> </span><br><span class="line">VAR           = <span class="string">'VAR'</span></span><br><span class="line">COLON         = <span class="string">'COLON'</span> <span class="comment">#冒号</span></span><br><span class="line">COMMA         = <span class="string">'COMMA'</span> <span class="comment">#逗号</span></span><br><span class="line">EOF           = <span class="string">'EOF'</span></span><br></pre></td></tr></table></figure></li><li><p>保留字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RESERVED_KEYWORDS = &#123;</span><br><span class="line">    <span class="string">'PROGRAM'</span>: Token(<span class="string">'PROGRAM'</span>, <span class="string">'PROGRAM'</span>),</span><br><span class="line">    <span class="string">'VAR'</span>: Token(<span class="string">'VAR'</span>, <span class="string">'VAR'</span>),</span><br><span class="line">    <span class="string">'DIV'</span>: Token(<span class="string">'INTEGER_DIV'</span>, <span class="string">'DIV'</span>),</span><br><span class="line">    <span class="string">'INTEGER'</span>: Token(<span class="string">'INTEGER'</span>, <span class="string">'INTEGER'</span>),</span><br><span class="line">    <span class="string">'REAL'</span>: Token(<span class="string">'REAL'</span>, <span class="string">'REAL'</span>),</span><br><span class="line">    <span class="string">'BEGIN'</span>: Token(<span class="string">'BEGIN'</span>, <span class="string">'BEGIN'</span>),</span><br><span class="line">    <span class="string">'END'</span>: Token(<span class="string">'END'</span>, <span class="string">'END'</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>词法分析器的结构：</p><ol><li><p>有一个<code>___init__</code>的函数，在创建实例的时候，就会自动调用这个方法；</p></li><li><p>一个提示错误的函数<code>error</code>；</p></li><li><p>然后开始处理“词”，这里有一个函数<code>advance</code>用于向前进一步(pos会➕1）：</p><ul><li><p><code>peek</code>：为了在以相同的字符开头时，区分是“保留字”还是“标识符”。</p><blockquote><p>在这里，我们可以在不消耗下一个字符的情况下去查看缓冲区：就是利用peek_pos移动查看下一个字符，而真正的pos不动。</p></blockquote></li><li><p><code>skip_comment</code>：处理注释；</p></li><li><p><code>skip_whitespace</code>：处理空格；</p></li><li><p><code>number</code>：在part10之前，叫做integer，因为现在不仅有整型数据，还有浮点型的。所以改名为number。</p></li><li><p><code>_id</code>：处理“标识符”和“保留字”</p></li></ul></li><li><p><code>get_next_token</code>：词法分析器的核心部分，前面的都是设计，现在才开始识别出一个个的token，下面就是列出识别token的种类：</p><blockquote><p>其实这里叫做：<code>get_token_and_go_next</code>比较直观，这个函数是，先识别出一个token，然后再继续寻找下一个token</p></blockquote><ol><li>左括号token：<strong>“{”</strong></li><li><strong>保留字</strong>token、<strong>标识符</strong>token。（用函数<code>_id()</code>来完成）</li><li><strong>整型变量</strong>token</li><li>赋值符号<strong>“:=”</strong>token</li><li>冒号<strong>“:”</strong>token</li><li>分号<strong>“;”</strong>token</li><li>逗号<strong>“,”</strong>token</li><li><strong>加、减、乘</strong> token</li><li>除法token<ul><li>整数除法：<strong>“DIV”</strong> token</li><li>浮点数除法：<strong>“/”</strong> token</li></ul></li><li>左小括号<strong>“(”</strong> token ； &amp; 右小括号<strong>“)”</strong> token</li><li>点<strong>“.”</strong> token</li></ol></li></ol></li></ul><h3 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h3><p>​ 语法分析，主要是分析词法分析器传过来的一个个token，分析它们之间的运算关系，即语法：</p><p>它们之间的关系，即语法，用<strong>抽象语法树</strong>来表示：</p><ol><li>一个基类：<code>AST</code>。（后面的继承于它）</li><li>一个二元操作符类：<code>BinOp(AST)</code>（表示加减乘除运算）</li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Let&#39;s Build A Simple Interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的云书签</title>
      <link href="/archives/eaabd222.html"/>
      <url>/archives/eaabd222.html</url>
      
        <content type="html"><![CDATA[<p center large><center><green>搜集学习资料&好用的工具</green></center></p><a id="more"></a><hr><h2 id="Ⅰ-CS-学习"><a href="#Ⅰ-CS-学习" class="headerlink" title="Ⅰ CS 学习"></a><red>Ⅰ CS 学习</red></h2><h3 id="00全科资料"><a href="#00全科资料" class="headerlink" title="00全科资料"></a>00全科资料</h3><h4 id="1-面试笔记集合"><a href="#1-面试笔记集合" class="headerlink" title="1. 面试笔记集合"></a>1. 面试笔记集合</h4><table><thead><tr><th>资源</th><th>描述</th></tr></thead><tbody><tr><td><strong><a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">CS-Notes</a></strong>、<a href="https://cyc2018.github.io/CS-Notes/#/" target="_blank" rel="noopener">网页版</a>、【<a href="https://github.com/longlongqin/CS-Notes" target="_blank" rel="noopener">备用链接</a>】</td><td>📚 技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计、Java、Python、C++</td></tr><tr><td><strong><a href="https://github.com/linw7/Skill-Tree" target="_blank" rel="noopener">准备秋招，欢迎来树上取果实</a></strong></td><td>这里将以最短的篇幅，最清晰的层级结构去总结那些对C++后台开发最为核心的内容。</td></tr><tr><td><strong><a href="https://github.com/zhengjianglong915/note-of-interview" target="_blank" rel="noopener">《互联网面试笔记》</a></strong></td><td>收集和分析互联网常见面试题，并将这些面试知识整理成文方便大家查阅。主要是面向java程序员，但基础知识部分不同语言程序员(c,c++,python等）都可以参考</td></tr><tr><td><strong><a href="https://github.com/huihut/interview" target="_blank" rel="noopener">C/C++笔记</a></strong></td><td>C/C++ 技术面试基础知识总结，包括语言、程序库、数据结构、算法、系统、网络、链接装载库等知识及面试经验、招聘、内推等信息。 <a href="https://interview.huihut.com" target="_blank" rel="noopener">https://interview.huihut.com</a></td></tr></tbody></table><hr><h4 id="2-教程集合"><a href="#2-教程集合" class="headerlink" title="2. 教程集合"></a>2. 教程集合</h4><ol><li><p><a href="https://github.com/Ewenwan/ShiYanLou" target="_blank" rel="noopener"><strong>学习C &amp; C++</strong></a></p><blockquote><p>学习C &amp; C++ &amp; python&amp;汇编语言 LLVM编译器 数据结构 算法 操作系统 单片机 linux 面试</p></blockquote></li></ol><hr><h3 id="01实用网站"><a href="#01实用网站" class="headerlink" title="01实用网站"></a>01实用网站</h3><ol><li><p><strong><a href="https://www.geeksforgeeks.org/" target="_blank" rel="noopener">geeksforgeeks</a></strong></p><blockquote><p>是印度的一家致力于计算机科学的百科全书，根据不同的用户计算机水平而发布不同的难度等级，从基础到专家级，内容涵盖了编程、算法、面试问题等。​</p></blockquote></li><li></li></ol><hr><h3 id="02项目练习"><a href="#02项目练习" class="headerlink" title="02项目练习"></a>02项目练习</h3><p><a href="https://github.com/tuvtran/project-based-learning#cc" target="_blank" rel="noopener">基于项目学习</a>（project-based-learning)</p><hr><h3 id="03编程相关书籍"><a href="#03编程相关书籍" class="headerlink" title="03编程相关书籍"></a>03编程相关书籍</h3><ol><li><a href="https://github.com/EbookFoundation/free-programming-books" target="_blank" rel="noopener">英文版</a></li><li><a href="https://github.com/justjavac/free-programming-books-zh_CN" target="_blank" rel="noopener">中文版</a></li></ol><hr><h3 id="04科目"><a href="#04科目" class="headerlink" title="04科目"></a>04科目</h3><h4 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h4><p>适合回顾知识点：<a href="https://oi-wiki.org/" target="_blank" rel="noopener">https://oi-wiki.org/</a></p><hr><table><thead><tr><th>学习教程</th><th>描述</th><th>状态</th></tr></thead><tbody><tr><td><a href="https://www.cnblogs.com/skywang12345/p/3603935.html" target="_blank" rel="noopener"><strong>数据结构与算法系列</strong></a></td><td>博客园中的一个博主写的</td><td><strong><u>再看</u>👁️</strong></td></tr><tr><td><strong><a href="https://github.com/nonstriater/Learn-Algorithms" target="_blank" rel="noopener">算法学习笔记</a></strong></td><td>这里的内容是学习算法过程的一些记录，希望能一直坚持下去。</td><td></td></tr><tr><td><a href="https://github.com/xiufengcheng/DATASTRUCTURE" target="_blank" rel="noopener">备用</a></td><td></td><td></td></tr></tbody></table><hr><table><thead><tr><th>可视化工具</th><th>描述</th></tr></thead><tbody><tr><td><strong><a href="https://visualgo.net/zh" target="_blank" rel="noopener">Visualgo</a></strong></td><td>可视化的观察数据结构的操作</td></tr><tr><td><strong><a href="http://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">David Galles可视化演示(JS)</a></strong></td><td>旧金山大学David Galles可视化演示(JS)</td></tr><tr><td><a href="https://github.com/algorithm-visualizer/algorithm-visualizer" target="_blank" rel="noopener"><strong>可以从代码中可视化算法</strong></a></td><td>算法可视化工具是一个交互式的在线平台，可以从代码中可视化算法。</td></tr><tr><td><a href="https://github.com/xiufengcheng/DATASTRUCTURE#可视化" target="_blank" rel="noopener"><strong>更多可视化工具</strong></a></td><td></td></tr></tbody></table><hr><h4 id="2-learn-OpenGL"><a href="#2-learn-OpenGL" class="headerlink" title="2. learn OpenGL"></a>2. learn OpenGL</h4><p>中文教学网址：<a href="https://learnopengl-cn.github.io/intro/" target="_blank" rel="noopener">https://learnopengl-cn.github.io/intro/</a></p><hr><h4 id="3-C-C"><a href="#3-C-C" class="headerlink" title="3. C/C++"></a>3. C/C++</h4><hr><p><strong>C语言相关：</strong></p><p><a href="https://wizardforcel.gitbooks.io/lcthw/content/" target="_blank" rel="noopener"><strong>笨办法学C</strong></a></p><hr><center>官方文档</center><ul><li><a href="https://en.cppreference.com/w/" target="_blank" rel="noopener"><strong>cppreference</strong></a></li></ul><hr><center>相关网站</center><table><thead><tr><th>网站</th><th>描述</th></tr></thead><tbody><tr><td><strong><a href="http://www.cplusplus.com/" target="_blank" rel="noopener">Cplusplus</a></strong></td><td>这也是一个学习 C++ 的优秀网站，除了提供相应的教程之外，还有一个很棒的论坛。和其它网站相比，它的价值更多体现在参考上，因为里面解释了许多编程概念，如果对某个特定的东西感到困惑，那么这些概念将会很有帮助。</td></tr><tr><td><strong><a href="https://www.tutorialspoint.com/cplusplus/index.htm" target="_blank" rel="noopener">TutorialsPoint</a></strong></td><td>Tutorialspoint 是一个顶级网站，之所以这么说，是因为你想学的任何技术（包括 C++），它几乎都提供了详细的教程。保存好就对了，超级有用。</td></tr><tr><td><strong><a href="https://github.com/fffaraz/awesome-cpp" target="_blank" rel="noopener">Awesome C++</a></strong></td><td>GitHub 上的 Awesome-XXX 系列的资源整理，awesome-cpp 就是 fffaraz 发起维护的 C++ 资源列表，内容包括：标准库、Web 应用框架、人工智能、数据库、图片处理、机器学习、日志、代码分析等</td></tr></tbody></table><hr><center>学习路线</center><p><a href="http://www.renrenstudy.com/default/cplus-advanced-learning/" target="_blank" rel="noopener">C++学习进阶(陈皓)</a></p><center>学习教程</center><table><thead><tr><th>资料</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.learncpp.com/cpp-tutorial/syntax-and-semantic-errors/" target="_blank" rel="noopener">LearnCpp</a></td><td>一个很好地C++学习网站</td></tr><tr><td><a href="https://www.cnblogs.com/nihaoCPP/p/3925336.html" target="_blank" rel="noopener">你好，C++</a></td><td>辅助学习文章阅读（有时间可以看）</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><hr><h2 id="Ⅱ-关注的博客"><a href="#Ⅱ-关注的博客" class="headerlink" title="Ⅱ 关注的博客"></a>Ⅱ 关注的博客</h2><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><ol><li><a href="http://linux.vbird.org/linux_basic/" target="_blank" rel="noopener"><strong>鳥哥的 Linux 私房菜</strong></a></li></ol><hr><h2 id="Ⅲ-Github中的资源"><a href="#Ⅲ-Github中的资源" class="headerlink" title="Ⅲ Github中的资源"></a>Ⅲ Github中的资源</h2><center>[github仓库排名](https://gitstar-ranking.com/repositories)</center><ol><li><p><a href="https://github.com/kamranahmedse/developer-roadmap" target="_blank" rel="noopener">web开发人员的路线图</a></p></li><li><p><strong>自学计算机课程的参考</strong></p><ul><li><p><strong><a href="https://github.com/ossu/computer-science-cn" target="_blank" rel="noopener">计算机技术与科学自学之旅</a></strong>(中文)</p><blockquote><p>开源社区大学计算机科学课程中文项目（OSSU CS CN)旨在为英语能力有待提高的中文学习者提供全中文的在线本科计算机科学学习课程。消除学习者在自学计算机课程中遇到的语言障碍。请注意本课程并不是英文课程的对照翻译，而是在其基础上结合地区实际情况提供全中文的在线教育。<strong>值得注意的是，我们仍然推荐学有余力者在学习完本课程后系统学习和掌握英语技能。</strong></p></blockquote></li><li><p><strong><a href="https://github.com/ossu/computer-science" target="_blank" rel="noopener">computer-science</a></strong></p><blockquote><p>通往免费自学计算机科学教育的道路!</p></blockquote></li></ul></li></ol><h2 id="Ⅱ-工具"><a href="#Ⅱ-工具" class="headerlink" title="Ⅱ 工具"></a><red>Ⅱ 工具</red></h2><h3 id="01写作相关"><a href="#01写作相关" class="headerlink" title="01写作相关"></a>01写作相关</h3><ol><li><p><strong>编辑器</strong></p><ul><li><p><strong><a href="https://github.com/mdnice/markdown-nice" target="_blank" rel="noopener">公众号排版(支持Markdown)</a></strong>：<strong>推荐</strong>【分为：Google插件 &amp; 在线版】</p><ul><li><a href="https://mdnice.com/" target="_blank" rel="noopener">在线版</a></li></ul></li><li><p><strong><a href="https://www.135editor.com/" target="_blank" rel="noopener">135编辑器</a></strong>：</p><blockquote><p>一款强大的微信公众号文章排版</p></blockquote></li></ul></li><li><p><strong>插件</strong></p><ul><li><p><a href="https://yiban.io/" target="_blank" rel="noopener">壹伴</a>：</p><blockquote><p>壹伴运营神器_新媒体小编最喜欢的微信排版工具</p></blockquote></li></ul></li><li><p><strong><a href="https://urlify.cn/" target="_blank" rel="noopener">短链生成</a></strong></p></li><li><p><strong><a href="https://squoosh.app/" target="_blank" rel="noopener">图片压缩</a></strong></p></li><li><p><strong><a href="http://tools.jb51.net/static/colorpicker/" target="_blank" rel="noopener">RGB及其它类型颜色查询</a></strong></p></li><li><p><strong>无版权图片</strong></p><ol><li><p><a href="https://pixabay.com/images/search/" target="_blank" rel="noopener"><strong>Pixabay</strong></a>：</p><blockquote><p>Pixabay是一个支持中文搜索的免费可商用图库。</p></blockquote></li><li><p><a href="https://gratisography.com/" target="_blank" rel="noopener"><strong>Gratisography</strong></a>：</p><blockquote><p>Gratisography是一个免费高分辨率摄影图片库，所有的图片都可以用于个人或者商业用途，每周更新图片你只需要点击即可下载。</p></blockquote></li><li><p><a href="https://unsplash.com/" target="_blank" rel="noopener"><strong>Unsplash</strong></a>：</p><blockquote><p>每天更新一张高质量的图片素材，全是生活中的景象作品，清新的生活气息图片。</p></blockquote></li><li><p><a href="https://www.pexels.com/" target="_blank" rel="noopener"><strong>Pexels</strong></a>：</p><blockquote><p>根据英文关键词搜索图片，还能根据不同颜色分类查找，匹配的图片复古自带滤镜，风格简约，图片质量很高，素材丰富。</p></blockquote></li><li><p><a href="https://visualhunt.com/" target="_blank" rel="noopener"><strong>VisualHunt</strong></a>：</p><blockquote><p>可以通过颜色来查找图片。</p></blockquote></li><li><p><a href="https://www.photock.jp/" target="_blank" rel="noopener"><strong>Photock</strong></a>：</p><blockquote><p>天空、水、河、海、草坪、火、山、动物、建筑、夜景、日本景点、日本历史文化图片等等。</p></blockquote></li><li><p><a href="http://pngimg.com/" target="_blank" rel="noopener"><strong>pngimg</strong></a>：</p><blockquote><p>全部都是无背景图片，非常适合那些需要png透明底配图的。而且它分类也很细，找起来方便。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/image-20200323143423265.png" alt="image-20200323143423265"></p></blockquote></li><li><p><a href="https://www.foodiesfeed.com/" target="_blank" rel="noopener"><strong>Foodiesfeed</strong></a>：</p><blockquote><p>专注于<u>美食</u>的图片网站，高清无水印，根据分类选择匹配关键词。</p></blockquote></li><li><p><a href="https://www.everypixel.com/" target="_blank" rel="noopener"><strong>Everypixel</strong></a>：</p><blockquote><p>Everypixel 是一款帮助用户寻找免费图片素材的搜索引擎，选择免费或付费，利用AI和图片分析技术筛选图片，并查看图片来源网站。</p></blockquote></li><li><p><a href="https://www.howtostartanllc.org/free-stock-photos/" target="_blank" rel="noopener">https://www.howtostartanllc.org/free-stock-photos/</a></p><blockquote><p>这是一个汇总了很多个免费图片网站的导航。</p></blockquote></li></ol></li></ol><hr><h3 id="02-云同步备份功能"><a href="#02-云同步备份功能" class="headerlink" title="02 云同步备份功能"></a>02 云同步备份功能</h3><ol><li><p><a href="https://www.jianguoyun.com/" target="_blank" rel="noopener"><strong>坚果云</strong></a></p><blockquote><p>可以实现本地与云端实时同步，还带有历史版本回退功能。缺点：每月上传只有1G容量，只能同步体积较小的文件。</p></blockquote></li><li><p><a href="https://www.fangcloud.com/" target="_blank" rel="noopener"><strong>亿方云</strong></a>：</p><blockquote><p>可以实现本地与云端实时同步，还带有历史版本回退功能。功能和坚果云类似。</p></blockquote></li></ol><hr><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li><a href="https://github.com/mdnice/markdown-resume" target="_blank" rel="noopener">Markdown 简历排版</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> forme </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>凸包总结</title>
      <link href="/archives/bf113a1c.html"/>
      <url>/archives/bf113a1c.html</url>
      
        <content type="html"><![CDATA[<h2 id="凸包的相关“test”测试"><a href="#凸包的相关“test”测试" class="headerlink" title="凸包的相关“test”测试"></a><a href="https://www.longlongqin.github.io/archives/510d.html" target="_blank" rel="noopener">凸包的相关“test”测试</a></h2><p><strong>一些定义：</strong></p><ul><li><p><strong>凸包[Convex Hull]</strong>：简单理解为将很多钉子围住的“皮筋”。</p></li><li><p><strong>极点(Extreme Point)</strong>：有一个点集S。如果存在通过点P的直线L，使得点集S中除了点P之外的其他的点都在这个直线的同一侧，则这个点P就是<strong>极点(Extreme Points)</strong>。</p></li><li><p><strong>极边(Extreme Edge)</strong>：两个极点连成的边，剩余的所有点均会在该边的一侧。</p></li></ul><h3 id="To-Left-Test"><a href="#To-Left-Test" class="headerlink" title="To-Left Test"></a>To-Left Test</h3><p>To-Left测试是相对于另外这两个点所确定的那条<strong>有向</strong>直线而言的，任何一条有向直线不仅会把平面分成两部分，我们还可以知道哪一边是左边，哪一边是右边。To-Left，其实就是说这个点相对于刚才的那条有向线而言到底是位于它的左侧(就是true)，还是右侧(就是false)。</p><blockquote><p>这里用到了行列式来求三角形面积（请看下面手写证明）。下图中的这个行列式实际上算的是它的”面积(指：有向面积）”的<strong>两倍</strong>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ToLeft</span> <span class="params">(Point p, Point q, Point s)</span> <span class="comment">//判断点s对于线段pq的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Area2(p,q,s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Area2</span><span class="params">(Point p, Point q, Point s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.x*q.y - p.y*q.x + q.x*s.y - q.y*s.x</span><br><span class="line">            +s.x * p.y - s.y *p.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>行列式来求三角形面积的证明：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="%E5%87%B8%E5%8C%85%E6%80%BB%E7%BB%93/v2-7c2f030cc1b9012bfefe41f0598ec6e9_720w.jpg" alt="img"></p></blockquote><center>图片来源于：https://zhuanlan.zhihu.com/p/35543479</center><h3 id="In-Trangle-Test"><a href="#In-Trangle-Test" class="headerlink" title="In-Trangle Test"></a>In-Trangle Test</h3><p>其实这个算法就是判断点是否在三角形内部。</p><p>这个测试最直接的理解为：使用了三次<em>To-Left Test</em>，三角形有三条边，所以每一条边都测试一次：</p><ul><li>三次<em>To-Left Test</em>结果相同的（均为true或者是false），则证明在三角形内部。</li><li>三次结果中有一次不相同，则证明在三角形外部。</li></ul><h3 id="判断极边"><a href="#判断极边" class="headerlink" title="判断极边"></a>判断极边</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//判断极边的核心</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkEdge</span><span class="params">(Point S[], <span class="keyword">int</span> n, <span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> lEmpty =TRUE, REmpty = TRUE;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n&amp;&amp;(LEmpty||REmpty); k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k!=p &amp;&amp; k!=q)</span><br><span class="line">            ToLeft(S[p], S[q], S[k]) ? LEmpty=FALSE: REmpty=FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(LEmpty || REmpty)</span><br><span class="line">        S[p].extreme =S[q].extreme= TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="in-convex-polygon-test"><a href="#in-convex-polygon-test" class="headerlink" title="in-convex-polygon test"></a>in-convex-polygon test</h3><p><strong>判定待定点是否位于某多边形内部（in-convex-polygon test）</strong></p><p>实现的方法就是：按一定方向（约定为逆时针）凸包的每条边和待定点做ToLeft test，一旦有一次test为false就说明改点在凸包外面。</p><h2 id="构造凸包的方法"><a href="#构造凸包的方法" class="headerlink" title="构造凸包的方法"></a>构造凸包的方法</h2><h3 id="1-利用极点法"><a href="#1-利用极点法" class="headerlink" title="1 利用极点法"></a>1 利用<strong>极点法</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extremePoint</span> <span class="params">(<span class="built_in">point</span> S[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>; s&lt;n; s++)</span><br><span class="line">        S[s].extreme = TRUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>; p&lt;n; p++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> q=p+<span class="number">1</span>; q&lt;n; q++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> r=q+<span class="number">1</span>; r&lt;n; r++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>; s&lt;n; s++)</span><br><span class="line">                &#123;</span><br><span class="line"><span class="keyword">if</span>(s==p || s==q || s==r ||!S[s].extreme)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(Intriangle(S[p],S[q],S[r],S[s]))</span><br><span class="line">                        S[s].extreme = FALSE;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n^4)</p></blockquote><h3 id="2-利用极边法"><a href="#2-利用极边法" class="headerlink" title="2 利用极边法"></a>2 利用<strong>极边法</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> markEE（<span class="built_in">point</span> S[], <span class="keyword">int</span> n）</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++) <span class="comment">//将所有点的初始状态都设置成：非极点</span></span><br><span class="line">        S[K].extreme = FALSE; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p=<span class="number">0</span>; p&lt;n; p++) <span class="comment">//遍历每条边，看他是否是极边</span></span><br><span class="line">        <span class="keyword">for</span>(q=p+<span class="number">1</span>; q&lt;n; q++)</span><br><span class="line">            checkEdge(S,n,p,q) <span class="comment">//判断极边的核心</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//判断极边的核心</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkEdge</span><span class="params">(Point S[], <span class="keyword">int</span> n, <span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> lEmpty =TRUE, REmpty = TRUE;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n&amp;&amp;(LEmpty||REmpty); k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k!=p &amp;&amp; k!=q)</span><br><span class="line">            ToLeft(S[p], S[q], S[k]) ? LEmpty=FALSE: REmpty=FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(LEmpty || REmpty)</span><br><span class="line">        S[p].extreme =S[q].extreme= TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n^3)</p></blockquote><h3 id="3-incremental-construction（增量构造）"><a href="#3-incremental-construction（增量构造）" class="headerlink" title="3 incremental construction（增量构造）"></a>3 incremental construction（增量构造）</h3><p>详细讲解：<a href="https://www.longlongqin.github.io/archives/7c53.html" target="_blank" rel="noopener">https://www.longlongqin.github.io/archives/7c53.html</a></p><p><strong>该算法的核心步骤就是：</strong>复杂度 O(n^2)</p><ol><li><p>判定新加入点与凸包的位置关系：用<strong>in-convex-polygon test</strong></p><blockquote><p>in-convex-polygon test在上面有讲</p></blockquote></li><li><p>向凸包插入新点：<strong>support-line</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200311230823679.png" alt="新点准备插入现有凸包"></p><p>如上面的点x，如何插入现有凸包当中呢？</p><p><strong>插入过程：</strong>插入过程其实就是寻找两个连接点s和t，然后将新点x与t、s分别连接得到新的凸包。t、s两个点将原凸包的边界分成两部分：st和ts两个邮箱线段。构造新凸包就要保留远端st，舍弃近端ts。取代ts的是x和s、t的连接线xt和xs。其中xt、xs被称为<strong>切线（tangent）</strong>或者<strong>support line（支撑线）</strong>。（配合下图理解）</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/v2-8afbf4ebfa808eec9ffff8c111ae6465_720w.jpg" alt="img"></p><ul><li><p>现在就是<strong>如何找到t、s这两个点？</strong></p><p>在凸包上任取一点v，按<strong>逆</strong>时针方向v点会有一个直接前驱点和直接后继点。考察有向直线xv与点v直接前驱和直接后继的位置关系（两次to left test），记为一个<strong>pattern表</strong>。</p><p>【结果无非是四种情况：v的直接前驱和直接后继相对于有向直线xv的位置是RL，LR，LL，RR。例如上图黄色点v，是R和L；蓝色点v分别是L和R。实际上凸包边界st上所有点的pattern都为RL，ts上所有点的pattern都为LR。关键点在于：点S的pattern是LL，点t的pattern为RR。】</p></li></ul></li></ol><p>说了这么多，其实我们可以将上面的两步合为一步：<strong><u>对于每个待定点x，不必特意去考虑它与凸包的位置关系，而是遍历凸包上每一个点。</u></strong></p><blockquote><p>对于凸包<strong>边界</strong>上的每一个点，我们都能通过两次to left test迅速判断出pattern。</p><p>对于x位于凸包<strong>外部</strong>的情况，经过遍历凸包的点，我们很容易就能得到s和t的位置，得到两条support line，从而构造出新的凸包；</p><p>而对于x位于凸包<strong>内部</strong>的情况，凸包边界每个点都不可能出现RR或LL的情况，直接舍弃x即可。</p></blockquote><h3 id="4-Jarvis-March"><a href="#4-Jarvis-March" class="headerlink" title="4 Jarvis March"></a>4 Jarvis March</h3><p>详细讲解：<a href="https://longlongqin.github.io/archives/9c7f.html">https://longlongqin.github.io/archives/9c7f.html</a></p><p>又称：Gift Wrapping</p><p>算法步骤：</p><ol><li>初始化所有点，设置点集的初态为 <strong>非极点</strong></li><li>找到开始的第一个极点：用<strong>LTL方法</strong></li><li>寻找下一个极点：用<strong><em>ToLeft test</em></strong>寻找下一个极点</li><li>循环步骤3，直到找到所有极点</li></ol><p>也就是：首先从任何一个极点（用LTL确定）开始，然后找到一条以这个极点为端点的极边。然后沿着这个极边的另一个端点<strong>（endpoint）</strong>出发，再找出下一条极边。如此反复操作，最终会找到一条以最初极点为endpoint的极边，得到一个封闭的环，凸包也构造完成。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200312175230158.png" alt="image-20200312175230158"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LTL</span><span class="params">(Point S[], <span class="keyword">int</span> n)</span> <span class="comment">//寻找最下and最左的点作为第一个极点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ltl = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;n; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S[k].y &lt; S[ltl].y || (S[k].y==S[ltl].y &amp;&amp; S[k].x&lt;S[ltl].x) )</span><br><span class="line">            ltl = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ltl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Javis</span> <span class="params">(Point S[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; k++)</span><br><span class="line">    S[k].extreme=FALSE; <span class="comment">//1.将所有点标记为非极点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ltl = LTL(S, n); <span class="comment">//2.找到ltl</span></span><br><span class="line">    <span class="keyword">int</span> k = ltl; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        S[k].extreme = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">-1</span>; <span class="comment">//要找的下一个极点用s表示</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t=<span class="number">0</span>; t&lt;n; t++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (t!=k &amp;&amp; t!=s &amp;&amp; ( s==<span class="number">-1</span> || !ToLeft(S[K],S[s],S[t]) ) )</span><br><span class="line">                s = t; </span><br><span class="line">        &#125;  </span><br><span class="line">        S[k].succ = s; <span class="comment">//新的极边确定</span></span><br><span class="line">        k = s； <span class="comment">//更新k的值，变为下一次查找的边的起点</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(k != ltl) <span class="comment">//如果循环回到了原来的点，则结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度：Jarvis March算法算法的复杂度<strong>更准确的表示为O(nh)。</strong>h（凸包边界的点的个数）又由最终输出结果，即凸包本身来决定，输出结果决定了构造过程的复杂度，这就是所谓的“输出敏感性”。这种类型的算法又被称为output sensitive algorithm。这种特性在其它凸包算法中也会体现。</p><h3 id="5-Graham-Scan"><a href="#5-Graham-Scan" class="headerlink" title="5 Graham Scan"></a>5 Graham Scan</h3><p>详细讲解；<a href="https://longlongqin.github.io/archives/3478.html">https://longlongqin.github.io/archives/3478.html</a></p><p><strong>算法流程：</strong></p><ol><li><p><strong>预排序(presorting)</strong>：即找到某个基准点，然后将其余所有的点按照相对于基准点的<strong>极坐标</strong>排序。它主要做了三个事情：</p><blockquote><p>1、<strong>找出基准点</strong>：用<strong>lowest-then-leftmost point（LTL）</strong>，然后对其他点按照极坐标排序：根据极角排序的方法，在：（<a href="https://longlongqin.github.io/archives/510d.html#补：根据极角排序）">https://longlongqin.github.io/archives/510d.html#补：根据极角排序）</a></p><p>2、<strong>找出起始边</strong>：从排好序的点集，选取前两个点，就是起始边。</p><p>3、<strong>将起始边 与 剩下的n-2条边分别存储在不同的栈(stack)中：</strong>如下图</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="%E5%87%B8%E5%8C%85%E6%80%BB%E7%BB%93/image-20200314181609764.png" alt="栈：T和S"></p></blockquote></li><li><p><strong>Scan扫描</strong></p><p>这一步是算法的核心。</p><p>scan的过程主要关注三个点：<strong>栈S的栈顶（S[0]）、次栈顶（S[1]）和栈T的栈顶（T[0]）</strong>。也就下图红色标注的三个点：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/20180207210925858.jpg" alt="img"></p><ul><li>可以观察到，每次待处理的S[0]和S[1]构成的边一定是一条极边（如上图点1和点2），算法<strong>关键步骤</strong>就是对边这条极边和T[0]做to left test，判断T[0]位于边S[0]S[1]的左边还是右边。若在左边则继续拓展，若在右边则否定掉此前认定的极边。无论结果如何，每次判定都会将问题规模缩小一个单元，算法结束时T最终肯定为空。T空后，<strong>S中存留下的点正是凸包的极点</strong>，这些点自底而上正是凸包边界点的逆时针遍历，也得到了整个凸包构造问题的解。</li></ul></li></ol><p><strong>复杂度：</strong></p><p>Graham Scan算法复杂度由三部分决定：</p><ul><li>persorting，采用一般排序算法，复杂度是O(nlogn)</li><li>逐步迭代，O(n)：算法一步步纳入新点，会迭代n步。</li><li>scan，O(?)</li></ul><p><strong>所以算法的总体复杂度：O(nlogn + n * ?) ，可见scan的复杂度决定了算法总体的复杂度。</strong></p><ul><li>算法一步步纳入新点，会迭代n步。但是在每个点上都有可能做回溯操作，所以scan的复杂度是不确定的。我们来以上图最坏情况为例，到第8个点时判定为false，舍弃点7，回溯。下一步判断也为false，舍弃点6，回溯。如此回溯直到算法开始的点2。这次scan倒退了高达O(n)个点，如果每次scan都是如此那么算法整体复杂度就为：O(nlogn + n * n) = O(n^2)了，那这种算法的意义也就不大了。</li></ul><p>其实上述分析并非错误，只是不够精确。O(n^2)确实是Graham Scan算法的一个<strong>上界</strong>，但是这个上界并不是紧的。</p><p>问题就出在分析假定了每次都会出现回退高达O(n)个点。</p><p><strong>代码部分：</strong><a href="https://longlongqin.github.io/archives/d4fa.html">https://longlongqin.github.io/archives/d4fa.html</a></p><h2 id="6-Divide-And-Conquer"><a href="#6-Divide-And-Conquer" class="headerlink" title="6 [Divide And Conquer]"></a>6 [Divide And Conquer]</h2><p>详细讲解：<a href="https://longlongqin.github.io/archives/f32f.html">https://longlongqin.github.io/archives/f32f.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 凸包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记</title>
      <link href="/archives/7b67faab.html"/>
      <url>/archives/7b67faab.html</url>
      
        <content type="html"><![CDATA[<center>陈皓——程序员练级攻略</center><h2 id="提及的书籍-amp-手册等"><a href="#提及的书籍-amp-手册等" class="headerlink" title="提及的书籍&amp;手册等"></a>提及的书籍&amp;手册等</h2><p>书籍列表：<a href="https://github.com/git-zjx/programmer_training_strategy" target="_blank" rel="noopener">https://github.com/git-zjx/programmer_training_strategy</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo中插入pdf</title>
      <link href="/archives/448ac7f1.html"/>
      <url>/archives/448ac7f1.html</url>
      
        <content type="html"><![CDATA[<p>法1：安装hexo-pdf插件</p><p>法2：利用html语法：可以轻松设定尺寸</p><a id="more"></a><h2 id="安装hexo-pdf插件"><a href="#安装hexo-pdf插件" class="headerlink" title="安装hexo-pdf插件"></a>安装hexo-pdf插件</h2><h3 id="hexo-pdf"><a href="#hexo-pdf" class="headerlink" title="hexo-pdf"></a><a href="https://github.com/superalsrk/hexo-pdf" target="_blank" rel="noopener">hexo-pdf</a></h3><p>Hexo tag for embeded pdf</p><h4 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save hexo-pdf</span><br></pre></td></tr></table></figure><h4 id="Normal-PDF"><a href="#Normal-PDF" class="headerlink" title="Normal PDF"></a>Normal PDF</h4><p>pdf链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf http:&#x2F;&#x2F;7xov2f.com1.z0.glb.clouddn.com&#x2F;bash_freshman.pdf %&#125;</span><br></pre></td></tr></table></figure><p>本地（<u>我的失败了，还没找到原因</u>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf .&#x2F;bash_freshman.pdf %&#125;</span><br></pre></td></tr></table></figure><h4 id="Google-drive"><a href="#Google-drive" class="headerlink" title="Google drive"></a>Google drive</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf https:&#x2F;&#x2F;drive.google.com&#x2F;file&#x2F;d&#x2F;0B6qSwdwPxPRdTEliX0dhQ2JfUEU&#x2F;preview %&#125;</span><br></pre></td></tr></table></figure><h4 id="Slideshare"><a href="#Slideshare" class="headerlink" title="Slideshare"></a>Slideshare</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf http:&#x2F;&#x2F;www.slideshare.net&#x2F;slideshow&#x2F;embed_code&#x2F;key&#x2F;8Jl0hUt2OKUOOE %&#125;</span><br></pre></td></tr></table></figure><p>示例：图片来源于网络</p><div class="row"><embed src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/PDF/Google_Cpp_Style_guide_CN.pdf" width="100%" height="550" type="application/pdf"></div><hr><h2 id="利用html语法"><a href="#利用html语法" class="headerlink" title="利用html语法"></a>利用html语法</h2><h3 id="首先修改-config-yml文件"><a href="#首先修改-config-yml文件" class="headerlink" title="首先修改_config.yml文件"></a>首先修改_config.yml文件</h3><p><strong>将_config.yml中的post_asset_folder选项置为true</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><p>关于这个选项的功能说明如下:</p><blockquote><p>当您设置post_asset_folder为true参数后，在建立文件时，Hexo<br>会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。</p></blockquote><h3 id="然后新建一篇文章"><a href="#然后新建一篇文章" class="headerlink" title="然后新建一篇文章"></a>然后新建一篇文章</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new</span><br></pre></td></tr></table></figure><blockquote><p>由于上一步已经将post_asset_folder选项设为了true<br>所以这一步新建文章时会创建一个md文件和一个同名的文件夹<br>为了方便叙述，我用test作为文件和文件夹名</p></blockquote><h3 id="编辑test-md"><a href="#编辑test-md" class="headerlink" title="编辑test.md"></a>编辑test.md</h3><blockquote><p>用vim或者别的编辑器打开test.md</p><p>test.md文件中加入如下代码</p><p><code>&lt;object data=&quot;./test/test.pdf&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;</code></p><p>关于这句代码简单的解释<br>data表示你要上传的pdf的路径,使用相对路径，将你要上传的pdf放入第二步生成的test文 件夹<br>type和width就不说了，这里注意height不能设成100%，不然太矮了，显示效果不好<br>可以用浏览器预览，通过F12预估一下高度。我最后代码如下，供参考</p><p><code>&lt;object data=&quot;https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/PDF/Google_Cpp_Style_guide_CN.pdf &quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;877px&quot;&gt;</code></p></blockquote><p>这里不一定非用object标签，embed、iframe标签也一样</p><p>具体参考:<a href="https://blog.csdn.net/qappleh/article/details/80250492" target="_blank" rel="noopener">网页链接</a></p><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><u><strong>注意</strong></u>：</h2><p><u>用html方法，在我的主题中，如果它后面有文字，会显示不出来，原因不详。</u>所以实例我放在文章底部展示了</p><hr><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://github.com/superalsrk/hexo-pdf" target="_blank" rel="noopener">hexo-pdf官方教程</a></p><p><a href="http://miracle778.site/pdf-test/pdf-test.html" target="_blank" rel="noopener">hexo中插入pdf解决方法</a></p><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p><a href="http://lingr7.coding.me/2019/10/02/theme-hexo-pdf%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7-%E8%A7%A3%E5%86%B3hexo-pdf%E6%96%87%E4%BB%B6%E6%98%BE%E7%A4%BA%E4%B8%8D%E5%85%A8%E7%9A%84%E9%97%AE%E9%A2%98.html" target="_blank" rel="noopener">theme-hexo-pdf使用技巧—-解决hexo-pdf文件显示不全的问题</a></p><object data="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/PDF/Google_Cpp_Style_guide_CN.pdf" width="100%" height="877px"></object>]]></content>
      
      
      <categories>
          
          <category> hexo博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo显示pdf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnCpp chapter1</title>
      <link href="/archives/a0a78e77.html"/>
      <url>/archives/a0a78e77.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red>LearnCpp-chapter1</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h2 id="0-5-介绍compiler-linker-and-libraries"><a href="#0-5-介绍compiler-linker-and-libraries" class="headerlink" title="0.5 介绍compiler, linker, and libraries"></a>0.5 介绍compiler, linker, and libraries</h2><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter1/Development-min.png" alt="Development-min"></p><h3 id="Step-4-Compiling-your-source-code"><a href="#Step-4-Compiling-your-source-code" class="headerlink" title="Step 4: Compiling your source code"></a>Step 4: Compiling your source code</h3><p>为了编译C++程序，我们需要一个编译器。编译器主要是对每一个<code>.cpp</code>文件做两件事情：</p><ol><li>它检查你的代码是否符合C++的规则。如果不符合，就会报错（同时返回相应的行号）来帮助你确定什么需要修改，同时停止编译</li><li>它将C++源代码翻译成机器代码文件（叫做：<red><strong>object file</strong></red>）。<strong>object file</strong>的名字通常是这种形式：<u><em>name*</em>.o<strong>*</strong></u> 或者 <u>*name.obj***</u>（其中name与<code>.cpp</code>文件的name是对应的）。</li></ol><p>例如：下面的三个.cpp的源文件，编译之后形成：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter1/CompileSource-min.png" alt="The compilation process"></p><hr><h3 id="Step-5-Linking-object-files-and-libraries"><a href="#Step-5-Linking-object-files-and-libraries" class="headerlink" title="Step 5: Linking object files and libraries"></a>Step 5: Linking object files and libraries</h3><p><strong>编译器compiler **编译完成后，生成若干的 object files。接下来就需要</strong>链接器Linker**出马了。linker的工作主要有三方面：</p><ol><li><p>将所有的object files（编译之后生成的）合并成为一个<em>可执行程序executable program</em></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter1/LinkingObjects-min.png" alt="LinkingObjects-min"></p></li><li><p>此外，linker还可以链接<strong>库文件library files</strong>（library files是一个已经预编译好的代码经过“打包”，在其他程序中重用）</p><blockquote><p>C++有有一个扩充的库，叫做：标准库<strong>C++ Standard Library</strong>。它提供额外的功能性库，比如我们常用的<em>iostream library</em></p><p>你可以有选择性的去链接其他库，比如当你想写一个播放声音的程序。你肯定不想从头到尾的去写如何去读取文件、检查文件是否有效….. 这时候，我们只需要下载相关的库进行利用就方便很多了。</p></blockquote></li><li><p>连接器会确保所有的跨文件依赖项都正确的解析了。</p><blockquote><p>例如：</p><p>如果你在一个.cpp文件中定义了”A”，然后在另一个.cpp文件中去使用”A”。linker就会将这两个文件联系起来。如果链接不成功，就会报错并且连接终止</p></blockquote></li></ol><p>只要linker成功的完成所有的“object files 和 libraries ”的链接工作，你就会得到一个可执行文件，然后你就可以运行它。</p><table><thead><tr><th align="left">Makefile</th></tr></thead><tbody><tr><td align="left">【注】有些开发环境使用<strong>Makefile</strong>，它是一个描述如何构建一个程序的文件（哪一个文件要编译&amp;链接，或者以不同方式处理）它是一个强大的工具。但是在本系列课程我们不回去讲解它。</td></tr></tbody></table><h3 id="Steps-6-amp-7-Testing-and-Debugging"><a href="#Steps-6-amp-7-Testing-and-Debugging" class="headerlink" title="Steps 6 &amp; 7: Testing and Debugging"></a>Steps 6 &amp; 7: Testing and Debugging</h3><p>如果你的可执行程序没有按照预期的工作，那么你就需要调试。</p><h2 id="Integrated-development-environments-IDEs"><a href="#Integrated-development-environments-IDEs" class="headerlink" title="Integrated development environments (IDEs)"></a>Integrated development environments (IDEs)</h2><p><u>【note】step3、4、5、7（editor, compiler, linker, debugger）都是需要软件的。</u></p><p>当然，你可以每一部分都是用独立的软件，但是有这样的一个软件包：<u><strong>integrated development environment (IDE)集成开发环境</strong></u> 将上面四步一体化。</p><hr><h2 id="0-6-compling-your-first-program"><a href="#0-6-compling-your-first-program" class="headerlink" title="0.6 compling your first program"></a>0.6 compling your first program</h2><p><strong>Console projects</strong></p><p>控制台项目没有<strong>graphical user interface (GUI)图形用户界面</strong>，它在控制台中打印text，从输入设备键盘读取信息。并且被编译成独立的可执行文件。</p><p><strong>Workspaces / solutions</strong></p><p>当创建一个项目时，许多IDE会自动给这个项目创建一个 “workspace” 或 “solution” 。</p><p><strong>workspace or solution</strong>：是一个可以容纳多个相关的项目的container。（例如，你正在写一个游戏，你想有一个单人 与 多人分开的可执行文件，那就需要创建两个项目。<strong>但是</strong>将这两个项目分开始没有意义的，因为它们属于同一个游戏的。所以，<u>最好的就是每一个都被配置为单个工作空间/解决方案中的 一个单独项目</u>。）</p><h2 id="0-8-C-中常见问题"><a href="#0-8-C-中常见问题" class="headerlink" title="0.8 C++中常见问题"></a>0.8 C++中常见问题</h2><h3 id="General-run-time-issues"><a href="#General-run-time-issues" class="headerlink" title="General run-time issues"></a>General run-time issues</h3><ol><li><p><strong>当执行程序时，控制台窗口闪烁，然后立即关闭？</strong></p><ul><li>1、首先确保下面的这几行在你的源程序的最上部（visio studio 用户，请确认如果有 #include “pch.h” or #include “stdafx.h” ，那么让它在最顶顶顶部的）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>2、在main()函数中的结束部分（<u>但要在return 语句之前</u>）添加如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">clear</span>(); <span class="comment">// reset any error flags</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>); <span class="comment">// ignore any characters in the input buffer until we find an enter character</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>(); <span class="comment">// get one more char from the user</span></span><br></pre></td></tr></table></figure><p><u>避免使用</u>：<code>system(&quot;pause&quot;)</code> 因为它只能在特定的操作系统中使用</p></li><li><p><strong>运行程序，得到窗口，但没有输出？</strong></p><p>有可能是你的xx安全管家等拦截的。试着关闭它们，然后重新运行</p></li><li><p><strong>程序编译成功，但是没有正确工作？</strong></p><p>去debug它</p></li></ol><h3 id="General-compile-time-issues"><a href="#General-compile-time-issues" class="headerlink" title="General compile-time issues"></a>General compile-time issues</h3><ol><li><p><strong>当编译程序时，得到一个未解析的外部符号：_main or _WinMain@16 ？</strong></p><p>说明你的编译器找不到main()函数。</p></li></ol><h3 id="Visual-Studio-issues"><a href="#Visual-Studio-issues" class="headerlink" title="Visual Studio issues"></a>Visual Studio issues</h3><ol><li><p><strong>使用Microsoft Visual c++进行编译时，得到C1010 fatal error，并且伴随着提示信息，如：”c:\vcprojects\test.cpp(263) :fatal error C1010: unexpected end of file while looking for precompiled header directive”</strong></p><p>答：这种问题出现在：当microsoft visual c++编译器被设置为使用预编译头文件，但您的c++代码文件中有一个(或多个)没有将<code>#include “stdafx.h”</code> or <code>#include “pch.h”</code>作为代码文件的第一行。</p><p>建议：</p><ol><li><p>在创建项目时，将预编译头 <em>precompiled headers</em>选项关闭。</p></li><li><p>如果您希望保持打开预编译头文件，要修复这个问题，只需找到产生错误的文件(在上面的错误中，test.cpp是罪魁祸首)，并在文件的<u>最顶部</u>添加以下行:</p><p><code>#include “pch.h”</code>或者<code>#include “stdafx.h”</code>【老版本的VS使用“stdafx.h” ，当其中一个不起作用，可以换成另外一个】</p><blockquote><p>注意，每一个C++文件都是从这一行开始的。如果不想从这一行开始，那就在创建项目的时候关闭“预编译头文件”选项</p></blockquote></li></ol></li><li><p>出现错误：<strong>“1MSVCRTD.lib(exe_winmain.obj) : error LNK2019: unresolved external symbol _WinMain@16 referenced in function “int __cdecl invoke_main(void)” (?invoke_main@@YAHXZ)”</strong></p><p>答：您可能已经创建了一个Windows图形化应用程序，而不是控制台应用程序。重新创建项目，并确保将其创建为Windows(或Win32)控制台项目。</p></li></ol><h2 id="0-9-配置编译器-“生成（build）”配置"><a href="#0-9-配置编译器-“生成（build）”配置" class="headerlink" title="0.9 配置编译器:“生成（build）”配置"></a>0.9 配置编译器:“生成（build）”配置</h2><p><strong>debug configuration</strong> ：可以帮助你调试你的程序，而且也是IDE默认的。但是它会关掉所有的优化，包含调试信息（这会让你的项目变得很大、很慢）。</p><p><strong>release configuration</strong>：当你将你的程序发布给公众的时候使用release模式。这个模式会优化项目的大小和它的性能，而且不会包含额外的调试信息。所以这种模式适用于：测试你的代码的性能.</p><h2 id="0-10-配置编译器-编译器扩展"><a href="#0-10-配置编译器-编译器扩展" class="headerlink" title="0.10 配置编译器:编译器扩展"></a>0.10 配置编译器:编译器扩展</h2><p>c++标准定义了关于程序在特定环境下应该如何表现的规则。在大多数情况下，编译器将遵循这些规则。然而，许多编译器实现自己对语言的更改，通常是为了增强与该语言的其他版本(例如C99)的兼容性，或者是出于历史原因。这些特定于编译器的行为称为<strong>编译器扩展（Compiler extensions）</strong>。</p><p>编写使用编译器扩展的程序允许你编写与c++标准不兼容的程序。使用非标准扩展的程序通常无法在其他编译器上编译(这些编译器不支持相同的扩展)，或者即使它们支持，也可能无法正确运行。</p><p>注意，编译器扩展通常是默认启用的，这对初学者是不友好的，因为它会让初学者觉得某些行为是符合官方C++的标准，但是实际上是因为编译器只是过于宽松。</p><p>因为，编译器扩展从来都不是必须的，如果开启可能让你误以为你写的代码是符合C++标准的。<u>所以，建议，建议关闭编译器扩展。</u></p><h2 id="0-11-配置编译器-warning和error"><a href="#0-11-配置编译器-warning和error" class="headerlink" title="0.11 配置编译器:warning和error"></a>0.11 配置编译器:warning和error</h2><p>出现error提示：说明你写的代码可能不符合C++语言的标准。</p><p>出现warning提示：说明编译器认为你的代码的某些地方<u>可能</u>有些错误，但是编译器不能百分百确定。</p><blockquote><p>好习惯：</p><p>不要让warning提示堆积，要尽你所能的去解决warning提示。</p></blockquote><p>在大多数情况下出现的warning是需要我们尽量去解决的。但在极少数情况的warning提示，我们需要明确告诉编译器不要产生这个警告。C++官方不支持这样，但是有很多单独的编译器（如：visio studio xx 和GCC）会提供解决方案：利用不可移植 <u># pragma 指令</u> 来暂时的关闭这个警告。</p><blockquote><p>好习惯：</p><p>将你的经高级别调到最大，特别是在你学习的时候，他会帮你识别潜在的问题。</p></blockquote><h3 id="将warnings视为errors"><a href="#将warnings视为errors" class="headerlink" title="将warnings视为errors"></a>将warnings视为errors</h3><p>如果在你学习的时候，最好告诉编译器让它把warning当做error对待，然后你就不得不去解决出现的warning了。</p><h2 id="0-12-配置编译器-选择一个C-标准"><a href="#0-12-配置编译器-选择一个C-标准" class="headerlink" title="0.12 配置编译器: 选择一个C++标准"></a>0.12 配置编译器: 选择一个C++标准</h2><p>C++的标准有很多，如：C++98, C++03, C++11, C++14, C++17, 等. 通常情况，编译器的标准都是默认的，而不是最新的C++标准。如果你想使用指定的标准版本，需要手动设置。</p><h3 id="正在制定中的标准的名字"><a href="#正在制定中的标准的名字" class="headerlink" title="正在制定中的标准的名字"></a>正在制定中的标准的名字</h3><p>有一些语言标准是按照他最终定案时候的年份（如，C++17是在2017年完成的）。但是，当一个新的语言标准正在制定ing的时候，我们不能确定它最终完成的时间。这个时候这个语言标准的名字 将会被最终完成时候的名字替代，（如，<em>C++11</em>在制作ing时，名字为<em>C++1x</em>，当最终完成的时候“<em>C++1x</em>”就会被替换），比如下面的一些：</p><ul><li>c++1x = C++11</li><li>c++1y = C++14</li><li>c++1z = C++17</li><li>c++2a = C++20</li></ul><p>所以，如果你看见C++1Z，这就代表C++17</p><p><u>【注意】</u>：在VS xxxx系列的IDE中，是不能设置全局的语言标准的，你只能一个一个项目的去设置</p><h2 id="1-1-语句与程序结构"><a href="#1-1-语句与程序结构" class="headerlink" title="1.1 语句与程序结构"></a>1.1 语句与程序结构</h2><p><strong>Statements and the structure of a program</strong></p><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p><strong>语句(Statements)</strong>是一种指令类型，它使程序执行某些操作。它是最小的独立计算单元。在C++中，一个单独的语句就可能会被编译成很多机器语言指令。</p><p>下面列出了很多种语句：</p><ol><li>Declaration statements(声明语句)</li><li>Jump statements（循环语句）</li><li>Expression statements（表达式语句）</li><li>Compound statements（复合语句）</li><li>Selection statements (conditionals) (条件语句)</li><li>Iteration statements (loops) （循环语句）</li><li>Try blocks</li></ol><h3 id="函数与main函数"><a href="#函数与main函数" class="headerlink" title="函数与main函数"></a>函数与main函数</h3><p><strong>函数</strong>是按照顺序执行的语句集合。</p><blockquote><p>每一个C++程序都必须要有一个<code>main</code>函数。一个程序开始执行的时候，开始于main函数中的第一条语句，然后按照顺序执行余下语句。</p></blockquote><p>说到函数，你可能会看到<em>main()</em> 或者 <em>doSomething()</em>，后面的括号其实起了一个说明作用。这个括号就说明他前面的那个字符是一个函数的名字。</p><h4 id="分析“hello-world”"><a href="#分析“hello-world”" class="headerlink" title="分析“hello world”"></a>分析“hello world”</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!"</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>第一行：一个预处理指令。这个预处理器指令指示，我们希望使用iostream库的内容，它是c++标准库的一部分，允许我们从控制台上读写文本。我们需要这一行以便在第5行上使用std::cout。排除这一行将导致第5行出现编译错误，因为编译器不知道std::cout是什么。</li><li>第2行是空的，编译器会忽略它。这一行的存在只是为了帮助使程序对人类更具可读性(通过分隔#include预处理指令和程序的后续部分)。</li><li>第3行告诉编译器我们要编写(定义)一个名为main的函数。每个c++程序必须有一个主函数，否则它将无法编译。</li><li>第4行和第7行告诉编译器哪些行是主函数的一部分。第4行上的左大括号和第7行上的右大括号之间的所有内容都被认为是主函数的一部分。这叫做函数体</li><li>第5行是main函数中的第一个语句，也是运行程序时执行的第一个语句。cout(代表“字符输出”)和&lt;&lt;操作符允许我们将字母或数字发送到要输出的控制台。在本例中，我们向它发送文本“Hello world!”，将输出到控制台。此语句创建程序的可见输出。</li><li>第6行是一个返回语句。当可执行程序完成运行时，程序将一个值发送回操作系统，以指示它是否成功运行。按照惯例，这个特殊的return语句将0的值返回给操作系统，这意味着“一切正常!”这是执行的程序中的最后一条语句。</li></ul></blockquote><p>结尾，<strong>什么是C++ 标准库？</strong></p><ul><li>答：一个标准库文件是一个 预编译代码的集合，它被“打包”起来，以供其他程序重用。</li></ul><h2 id="1-2-注释"><a href="#1-2-注释" class="headerlink" title="1.2 注释"></a>1.2 注释</h2><p><strong>正确的注释</strong>：</p><ul><li>At the library, program, or function level, use comments to describe <em>what</em>.</li><li>Inside the library, program, or function, use comments to describe <em>how</em>.</li><li>At the statement level, use comments to describe <em>why</em>.</li></ul><h2 id="1-3-—-Introduction-to-variables"><a href="#1-3-—-Introduction-to-variables" class="headerlink" title="1.3 — Introduction to variables"></a>1.3 — Introduction to variables</h2><p><strong>data：数据</strong></p><blockquote><p>data就是可以被电脑移动、存储、处理的任何信息。</p><p>计算机上的数据通常以一种便于存储或处理的格式存储(因此人类无法读懂)，这种格式就是：二进制（binary）</p></blockquote><p><strong>Objects and variables：对象和数据</strong></p><ul><li><p><strong>RAM(random access memory)</strong>：随机存取存储器。在程序中，你可以把RAM看作一列邮箱，它可以在程序运行时存储数据。存储在内存中的单个数据，称为<strong>value</strong></p></li><li><p>在C++中，不允许直接访问内存。但可以通过object来访问内存。一旦创建object，编译器就自动的决定这个object存放在内存中的位置。</p><blockquote><p><strong>object</strong>：是具有value和其他相关属性的存储区域。</p></blockquote><p>这样，我们就可以说，获取这个object的value，编译器直到这个value存储在内存的具体位置。也就是说，<u>我们可以只关注使用object(对象)来存储和检索value，而且不用担心它在内存中的存储位置。</u></p></li><li><p>object(对象)可以命名也可以不命名。有名字的object叫做：<strong>variable(变量)</strong>。这个object的名字，叫做：<strong>标识符(identifier)</strong>。</p><blockquote><p>在一般编程中，对象通常指内存中的变量、数据结构或函数。在c++中，“对象”的定义较窄，将函数排除在外。</p></blockquote></li></ul><p><strong>Variable instantiation：变量实例化</strong></p><ul><li><p>为了创建一个变量，需要用一种特殊的声明：<strong>定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x; <span class="comment">// define a variable named x, of type int</span></span><br></pre></td></tr></table></figure><ol><li><p>在编译时，当编译器看到这个语句，它会告诉自己我们需要定义一个变量，变量名字叫x，类型为int。从此之后，只要编译器看到标识符x，它就知道我们在引用这个变量。</p></li><li><p>程序运行时(称为：<strong>runtime</strong>)，该变量将会被<strong><u>实例化</u></strong>。<u>变量在用来存储values之前，必须要先实例化。</u></p><blockquote><p><strong>实例化</strong>：对象(object)将会被创建，并且会分配一个内存地址。</p></blockquote><p>为了便于举例，假设变量x是在内存位置140处实例化的。当程序使用变量x时，它将访问内存位置140中的值。实例化的对象有时也称为<strong>实例</strong>。</p></li></ol></li></ul><p><strong>Data types：数据类型</strong></p><ul><li><strong>Data types(更通用的称呼：type)</strong>：它告诉编译器变量将会存储什么类型的value</li></ul><p>在c++中，变量的类型必须在编译时(当程序被编译时)已知，如果不重新编译程序，就不能更改该类型。这意味着一个整型变量只能包含整型值。如果希望存储其他类型的值，则需要使用不同的变量。</p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><ol><li><strong>Data</strong> is any sequence of symbols (numbers, letters, etc…) that can be interpreted to mean something.</li><li>A <strong>value</strong> is a single piece of data stored in memory.【值是存储在内存中的单个数据块。】</li><li>A <strong>variable</strong> is a named region of memory.【变量是一个命名的内存区域。】</li><li>An <strong>identifier</strong> is the name that a variable is accessed by.【标识符是变量被访问的名称】</li><li>A <strong>type</strong> tells the program how to interpret a value in memory.【类型是告诉程序如何解释内存中的值】</li></ol><h2 id="1-4-变量赋值与初始化"><a href="#1-4-变量赋值与初始化" class="headerlink" title="1.4 变量赋值与初始化"></a>1.4 变量赋值与初始化</h2><p><strong>定义变量</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x; <span class="comment">// define an integer variable named x</span></span><br><span class="line"><span class="keyword">int</span> y, z; <span class="comment">// define two integer variables, named y and z</span></span><br></pre></td></tr></table></figure><p><strong>变量赋值：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">width</span>; <span class="comment">// define an integer variable named width</span></span><br><span class="line"><span class="built_in">width</span> = <span class="number">5</span>; <span class="comment">// copy assignment of value 5 into variable width</span></span><br></pre></td></tr></table></figure><p><strong>初始化变量</strong>：(定义&amp;赋值同时进行)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>; <span class="comment">//初始化变量a为1</span></span><br></pre></td></tr></table></figure><blockquote><p>C++初始化变量的形式有三种：</p><ol><li><p>使用<strong>“=”</strong> <strong>copy initialization</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">width</span> = <span class="number">5</span>; <span class="comment">// copy initialization of value 5 into variable width</span></span><br></pre></td></tr></table></figure></li><li><p>使用括号<strong>“()”</strong> <strong>direct initialization</strong> 【这种在一些高级数据类型上，性能较好】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">width</span><span class="params">(<span class="number">5</span>)</span></span>; <span class="comment">// direct brace initialization of value 5 into variable width (preferred)</span></span><br></pre></td></tr></table></figure></li><li><p><red>使用大括号<strong>“{}”</strong> <strong>Brace initialization</strong>(<strong>uniform initialization</strong>)[推荐这种]</red></p><blockquote><p>这种可以用于对象初始化<u>一系列</u>的数据</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*推荐第一种形式*/</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">width</span>&#123; <span class="number">5</span> &#125;; <span class="comment">// direct brace initialization of value 5 into variable width (preferred)</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">height</span> = &#123; <span class="number">6</span> &#125;; <span class="comment">// copy brace initialization of value 6 into variable height</span></span><br></pre></td></tr></table></figure><p>另外，空初始化：用空的花括号对数据进行<strong>Zero initialization</strong>。它表示对该变量初始化为0，或者为空。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">width</span>&#123;&#125;; <span class="comment">//zero initialization to value 0</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><p>对于上述三种初始化方法，看一下下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1.2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">b</span><span class="params">(<span class="number">2.8</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> c&#123; <span class="number">3.1</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span>.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">cin</span>.ignore(numeric_limits&lt;streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line">    <span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter1/image-20200325231749396.png" alt="第三种初始化方法更严谨"></p><p>从运行结果可以看出，第1和2种方法只会基于<strong>“警告”</strong>，它们运行结果就是只把整数部分初始化给响应变量；而第三种就直接提示<strong>“出错”</strong>。</p><hr><p>变量初始化是很有必要的。如果不初始化，编译器可能报错的ヾ(≧O≦)〃嗷~</p><h2 id="1-5介绍输入输出流：cout-cin-endl"><a href="#1-5介绍输入输出流：cout-cin-endl" class="headerlink" title="1.5介绍输入输出流：cout cin endl"></a>1.5介绍输入输出流：cout cin endl</h2><ol><li><p><strong>std::endl 与 ‘\n’</strong></p><p><strong>使用’\n’的效率比std::endl高</strong>。因为：</p></li></ol><ul><li><strong>std::endl</strong>做两件事：1、将光标一刀下一行；2、它“刷新”输出(确保它立即显示在屏幕上)</li><li><strong>‘\n’</strong>只做一件事：1、将光标一刀下一行；</li></ul><ol start="2"><li><p>&lt;&lt; 、&gt;&gt;</p><p>&lt;&lt;： insertion operator (<code>&lt;&lt;</code>)</p><p>&gt;&gt;： extraction operator (<code>&gt;&gt;</code>)</p></li></ol><h2 id="1-6-未初始化-amp-未定义"><a href="#1-6-未初始化-amp-未定义" class="headerlink" title="1.6 未初始化&amp;未定义"></a>1.6 未初始化&amp;未定义</h2><ol><li><p><strong>初始化、赋值、未初始化：</strong></p><p>不像其他语言，C/C++在定义的时候，不会自动的给变量赋值(比如说 0)。所以说，如果一个变量被编译器分配到一个内存地址，如果他没有被人为的赋值，它默认的值就是这个内存地址原来存储的值（也叫“垃圾值”）。</p><ul><li>Initialization = 在对象被定义的同时给它赋值；</li><li>Assignment = 在对象被定义之<strong>后</strong>，再赋值给它；</li><li>Uninitialized = 对象只是被定义，但是还没有被赋值。</li></ul><blockquote><p>所以，我们应该<u><strong>记住要初始化对象</strong></u>（因为现在，初始化对象的成本与带来的好处相比，成本不值一提）。</p><p>不初始化对象，可能会出现无法预料的错误。</p></blockquote></li><li><p><strong>未初始化行为，可能带来以下症状</strong>：</p><ul><li>程序每次运行都会有不同的结果；</li><li>程序每次运行都会出现一个相同的错误结果；</li><li>程序结果不稳定：有时结果正确，有时结果是错误的；</li><li>程序似乎工作，但是稍后的结果不正确；</li><li>程序崩溃；</li><li>程序可以在一些编译器上运行，但在其他编译器中不能运行；</li></ul></li></ol><h2 id="1-7-关键字-amp-标识符"><a href="#1-7-关键字-amp-标识符" class="headerlink" title="1.7 关键字&amp;标识符"></a>1.7 关键字&amp;标识符</h2><p><strong>关键字：</strong></p><p>C++17中的关键字（<strong>keywords</strong> 或者 <strong>reserved words</strong>）有84个关键字。</p><p><strong>标识符：</strong></p><p>变量、函数、类、模块、或任何其他用户自定义项目的 <strong>的名字</strong> 叫做：标识符。</p><p>命名规则：</p><ol><li>标识符名字不能和保留字重名；</li><li>标识符只能由字母、下划线、数字；</li><li>标识符必须以 字母 或 数字 开头（“以下划线开头”的一般都是操作系统的保留字；库，或者是编译器使用的）；</li><li>C++对大小写敏感，所以wa和WA和Wa和wA互不相同。</li></ol><h2 id="1-8-常量-amp-操作符"><a href="#1-8-常量-amp-操作符" class="headerlink" title="1.8 常量&amp;操作符"></a>1.8 常量&amp;操作符</h2><p><strong>常量(literal，literal constant)</strong>：是一个已直接插入源代码的固定值。</p><blockquote><p>常量与变量都有一个value（和一个type）。但是，<strong>常量的值不可更改</strong>。</p></blockquote><p><strong>操作符(Operators)</strong>：在数学中，操作是一种数学计算，包括0个或多个输入值(称为<strong>操作数<em>operands</em></strong>)，它们产生一个新值(称为输出值)。要执行的特定操作由一个称为操作符的结构(通常是一个符号或一对符号)表示。</p><p>操作符分为三类：</p><ul><li><strong>一元操作符(Unary operators)</strong>：只有一个操作数；</li><li><strong>二元操作符(Binary operators)</strong>：有两个操作数（左边、右边各一个）；</li><li><strong>三元操作符(Ternary operators)</strong>：有三个操作数。在C++中只有一个三元操作符。</li></ul><h2 id="1-9-表达式"><a href="#1-9-表达式" class="headerlink" title="1.9 表达式"></a>1.9 表达式</h2><ol><li><p><strong>表达式与语句的区别</strong>？</p><p>当我们需要程序执行某个操作时，使用<strong>语句</strong>；当我们需要程序计算有一个值的时候，使用<strong>表达式</strong>。</p></li><li><p>表达式、语句、表达式语句？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x; <span class="comment">//语句不含表达式</span></span><br><span class="line"><span class="keyword">int</span> x=<span class="number">5</span>; <span class="comment">//语句包含表达式</span></span><br><span class="line">x=<span class="number">5</span>;  <span class="comment">//表达式语句</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="总结chapter-1"><a href="#总结chapter-1" class="headerlink" title="总结chapter 1"></a>总结chapter 1</h1><ul><li><p><strong>语句(statement)</strong>：是一种指令，它通常使程序执行某些操作，语句以分号（semicolon）结尾。</p></li><li><p><strong>预处理指令(Preprocessor directives)</strong>：告诉编译器执行一种特殊任务。在本章中，用到的是”<code>#include &lt;iostream&gt;</code>“</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let’s Build A Simple Interpreter-9</title>
      <link href="/archives/8632918.html"/>
      <url>/archives/8632918.html</url>
      
        <content type="html"><![CDATA[<p><yellow>今天要学习的内容：</yellow></p><ol><li>如何parse and interpret 一个Pascal程序的<strong>定义 definition</strong></li><li>如何parse and interpret <strong>复合语句compound statements</strong></li><li>如何parse and interpret <strong>赋值语句(包括变量)assignment statements, including variables.</strong></li><li>介绍符号表，以及如何存储和查找变量。</li></ol><a id="more"></a><p>原文链接：<a href="https://ruslanspivak.com/lsbasi-part9/" target="_blank" rel="noopener">https://ruslanspivak.com/lsbasi-part9/</a></p><p>本节源代码：<a href="https://github.com/rspivak/lsbasi/tree/master/part9/python" target="_blank" rel="noopener">https://github.com/rspivak/lsbasi/tree/master/part9/python</a></p><p>下面是一个简单的 Pascal程序，来介绍新概念：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        number := <span class="number">2</span>;</span><br><span class="line">        a := number;</span><br><span class="line">        b := <span class="number">10</span> * a + <span class="number">10</span> * number / <span class="number">4</span>;</span><br><span class="line">        c := a - - b</span><br><span class="line">    <span class="keyword">END</span>;</span><br><span class="line">    x := <span class="number">11</span>;</span><br><span class="line"><span class="keyword">END</span>.</span><br></pre></td></tr></table></figure><p>今天所学内容与前面的part1~8相比有了很大的飞跃，现在不再是像以前一样只是一个计算器了。我们要提升一下档次了😊</p><h2 id="新的语法树及规则"><a href="#新的语法树及规则" class="headerlink" title="新的语法树及规则"></a><red>新的语法树及规则</red></h2><p>现在，来看看新语言结构的<em>语法树syntax diagrams</em> 以及其对应的<em>语法规则grammar rules</em></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-9/lsbasi_part9_syntax_diagram_01.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-9/lsbasi_part9_syntax_diagram_02.png" alt="img">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-9/lsbasi_part9_syntax_diagram_03.png" alt="img"></p><h3 id="pascal语法"><a href="#pascal语法" class="headerlink" title="pascal语法"></a><red>pascal语法</red></h3><p>一个Pascal语法由一下组成&lt;<red>这不是完整的定义，会在后面文章慢慢扩展</red>&gt;：</p><ul><li><strong>BEGIN</strong>开头</li><li>中间是<strong>复合语句<em>compound statement</em></strong></li><li>一个<strong>点(dot) “.”</strong>结束</li></ul><h4 id="compound-statement"><a href="#compound-statement" class="headerlink" title="compound statement"></a><red><em>compound statement</em></red></h4><p><em>compound statement</em>是一个block(区块)：</p><ul><li>它标有BEGIN 和 END ，中间可能(也可能没有)包含有<u>一段语句</u>或<u>其他的复合语句<em>compound statement</em></u></li><li>所有嵌入在复合语句中的句子，除了最后一个，其他的都要以分号“;”结尾</li><li>在block中的最后一个句子(last statement)可能或可能没有 中断分号“;”</li></ul><p>如下面所示：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">“<span class="keyword">BEGIN</span> <span class="keyword">END</span>”</span><br><span class="line">“<span class="keyword">BEGIN</span> a := <span class="number">5</span>; x := <span class="number">11</span> <span class="keyword">END</span>”</span><br><span class="line">“<span class="keyword">BEGIN</span> a := <span class="number">5</span>; x := <span class="number">11</span>; <span class="keyword">END</span>”</span><br><span class="line">“<span class="keyword">BEGIN</span> <span class="keyword">BEGIN</span> a := <span class="number">5</span> <span class="keyword">END</span>; x := <span class="number">11</span> <span class="keyword">END</span>”</span><br></pre></td></tr></table></figure><h4 id="statement-list"><a href="#statement-list" class="headerlink" title="statement list"></a><red><em>statement list</em></red></h4><p>一个<strong><em>statement list</em></strong> 含有0个或多个语句，其位于<em>compound statement</em>内。如上面的例子</p><h4 id="statement"><a href="#statement" class="headerlink" title=" statement"></a><red><em>statement</em></red></h4><p>一个<em>statement<em>可以是一个 *compound statement</em>， 一个赋值语句<em>assignment statement</em>，或者是一个空语句*empty</em> statement。</p><h4 id="assignment-statement"><a href="#assignment-statement" class="headerlink" title="assignment statement"></a><red><em>assignment statement</em></red></h4><p>一个赋值语句的组成：<u>一个变量</u> 后面跟着 <u>一个指定的token（two characters, ‘:’ and ‘=’）</u> 后面跟着 <u>一个表达式</u>。如下所示：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“a := <span class="number">11</span>”</span><br><span class="line">“b := a + <span class="number">9</span> - <span class="number">5</span> * <span class="number">2</span>”</span><br></pre></td></tr></table></figure><h4 id="varible"><a href="#varible" class="headerlink" title="varible"></a><red><em>varible</em></red></h4><p>一个 <strong>变量<em>variable</em></strong>是一个<u>标识符<em>identifier</em></u>。我们将用ID token来表示variables，这个token的value是变量的名字(如，‘a’、‘number’、‘x’…..)。在下面的一个block的代码中的‘a’、‘b’就是变量：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“<span class="keyword">BEGIN</span> a := <span class="number">11</span>; b := a + <span class="number">9</span> - <span class="number">5</span> * <span class="number">2</span> <span class="keyword">END</span>”</span><br></pre></td></tr></table></figure><h4 id="empty-statement"><a href="#empty-statement" class="headerlink" title="empty statement"></a><red><strong><em>empty</em></strong> statement</red></h4><p>一个空语句表示一个语法规则，这个语法规则没有更深层的产生式<em>productions<em>。我们使用</em>empty_statement<em>语法规则来描述语法分析中末尾的</em>statement_list</em> ；同时也允许一个空的复合语句<em>compound statements</em>表示为：‘BEGIN END’</p><h4 id="factor"><a href="#factor" class="headerlink" title="factor"></a><red><em>factor</em></red></h4><p><em>factor</em>的规则更新为处理变量。</p><h3 id="完整的语法"><a href="#完整的语法" class="headerlink" title="完整的语法"></a>完整的语法</h3><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> : compound_statement DOT</span><br><span class="line"></span><br><span class="line">compound_statement : <span class="keyword">BEGIN</span> statement_list <span class="keyword">END</span></span><br><span class="line"></span><br><span class="line">statement_list : statement</span><br><span class="line">               | statement SEMI statement_list</span><br><span class="line"></span><br><span class="line">statement : compound_statement</span><br><span class="line">          | assignment_statement</span><br><span class="line">          | empty</span><br><span class="line"></span><br><span class="line">assignment_statement : variable ASSIGN expr</span><br><span class="line"></span><br><span class="line">empty :</span><br><span class="line"></span><br><span class="line">expr: term ((PLUS | MINUS) term)*</span><br><span class="line"></span><br><span class="line">term: factor ((MUL | DIV) factor)*</span><br><span class="line"></span><br><span class="line">factor : PLUS factor</span><br><span class="line">       | MINUS factor</span><br><span class="line">       | INTEGER</span><br><span class="line">       | LPAREN expr RPAREN</span><br><span class="line">       | variable</span><br><span class="line"></span><br><span class="line">variable: ID</span><br></pre></td></tr></table></figure><p>上面的语法中，</p><ul><li>在<em>compound_statement</em> rule 中没有用“*”来表示重复（0或多次），而是明确的制定了 <em>statement_list</em> rule。这是另一种方法来表示“0或多次”的操作。这在后面的语法分析器（如<a href="http://www.dabeaz.com/ply/" target="_blank" rel="noopener">PLY</a>）会派上用场。</li><li>我还将规则：“(PLUS | MINUS) factor”也细分成两个规则。</li></ul><h2 id="修改lexer-parser-interpreter"><a href="#修改lexer-parser-interpreter" class="headerlink" title="修改lexer,parser,interpreter"></a><red>修改lexer,parser,interpreter</red></h2><p>为了支持更新后的语法，我们需要修改我们的此番分析器、语法分析器和解释器。</p><h3 id="lexer的改变"><a href="#lexer的改变" class="headerlink" title="lexer的改变"></a><red>lexer的改变</red></h3><p>下面是我们此番分析器有改动的地方：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-9/lsbasi_part9_lexer.png" alt="img"></p><ol><li><p>为了支持Pascal程序的定义、复合语句、赋值语句、变量。我们需要新的token类型：（Pascal program’s definition, compound statements, assignment statements, and variables）</p><ul><li>BEGIN (标记复合语句的开始)</li><li>END (标记复合语句的结束)</li><li>DOT (一个token表示 点，用于Pascal程序的定义)</li><li>ASSIGN (一个token表示两个字符， ‘:=’)在Pascal中，赋值操作符不同于其他语言（如C语言用 “=”）</li><li>SEMI (一个token表示分号‘ ; ’ 。用来标记在复合语句中的一个句子的结尾)</li><li>ID（一个token表示 有效的标识符。）</li></ul></li><li><p>有时候，为了区分不同token（它们都以相同的字符为开头，如：‘:’ vs ‘:=’ or ‘==’ vs ‘=&gt;’），我们需要在不消耗下一个字符的情况下去查看输入缓冲区。为了这个特殊的目的，我介绍一种查看方法<em>peek</em> method，这种方法将帮助我们标记赋值语句。这个方法不是必要的，但是还是想早一点介绍一下，并且它也使得<em>get_next_token</em>函数简洁一些。</p><p>它所做的目的就是：从文本缓冲区返回下一个字符，但不增加<em>self.pos</em>的值。下面是这个方法的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">    peek_pos = self.pos + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> peek_pos &gt; len(self.text) - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> self.text[peek_pos]</span><br></pre></td></tr></table></figure></li><li><p>因为pascal中的 变量 和 保留字 都是 标识符。所以我们需要用一个方法来区分它们，方法为：<strong><em>_id</em></strong>。它工作的原理：词法分析器对这个字母、数字序列进行检查，看这个序列是否是保留字<em>reserved keyword</em>，如果是，就返回一个预先构造的token来表示这个保留字；如果不是，就返回一个新的ID token（它的值就是这个字符串）（lexeme）.下面是它的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RESERVED_KEYWORDS = &#123;</span><br><span class="line">    <span class="string">'BEGIN'</span>: Token(<span class="string">'BEGIN'</span>, <span class="string">'BEGIN'</span>),</span><br><span class="line">    <span class="string">'END'</span>: Token(<span class="string">'END'</span>, <span class="string">'END'</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_id</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Handle identifiers and reserved keywords"""</span></span><br><span class="line">    result = <span class="string">''</span></span><br><span class="line">    <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isalnum():</span><br><span class="line">        result += self.current_char</span><br><span class="line">        self.advance()</span><br><span class="line"></span><br><span class="line">    token = RESERVED_KEYWORDS.get(result, Token(ID, result))</span><br><span class="line">    <span class="keyword">return</span> token</span><br></pre></td></tr></table></figure></li><li><p>词法分析器的函数<em>get_next_token</em>的改变:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> self.current_char.isalpha():</span><br><span class="line">            <span class="keyword">return</span> self._id()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.current_char == <span class="string">':'</span> <span class="keyword">and</span> self.peek() == <span class="string">'='</span>:</span><br><span class="line">            self.advance()</span><br><span class="line">            self.advance()</span><br><span class="line">            <span class="keyword">return</span> Token(ASSIGN, <span class="string">':='</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.current_char == <span class="string">';'</span>:</span><br><span class="line">            self.advance()</span><br><span class="line">            <span class="keyword">return</span> Token(SEMI, <span class="string">';'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.current_char == <span class="string">'.'</span>:</span><br><span class="line">            self.advance()</span><br><span class="line">            <span class="keyword">return</span> Token(DOT, <span class="string">'.'</span>)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></li></ol><h3 id="parser的改变"><a href="#parser的改变" class="headerlink" title="parser的改变"></a><red>parser的改变</red></h3><p>下面是它的总的变化：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-9/lsbasi_part9_parser.png" alt="img"></p><ol><li><p>新的AST结点：</p><ul><li><p><strong><em>Compound</em> AST node</strong>：表示一个复合语句，在它的孩子的变量中包含着语句节点的列表；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compound</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="string">"""Represents a 'BEGIN ... END' block"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.children = []</span><br></pre></td></tr></table></figure></li><li><p><strong><em>Assign</em> AST node</strong>：表示赋值语句。它的左孩子的值是<strong><em>Var</em> node</strong>，右孩子结点存储着由expr解析器返回的结点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Assign</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, left, op, right)</span>:</span></span><br><span class="line">        self.left = left</span><br><span class="line">        self.token = self.op = op</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure></li><li><p><strong><em>Var</em> AST node</strong>：表示一个变量，它的value就是着这个变量的名字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Var</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="string">"""The Var node is constructed out of ID token."""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, token)</span>:</span></span><br><span class="line">        self.token = token</span><br><span class="line">        self.value = token.value</span><br></pre></td></tr></table></figure></li><li><p><strong><em>NoOp</em> node</strong>：用来表示一个空语句。如<code>‘BEGIN END’</code> 是一个有效的复合语句但没有句子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoOp</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>我们之前讲过，在我们的递归的语法分析器中每一个语法的规则都有相应的函数(method)。这次将增加7个新的函数。这些函数都是用于语法分析中新的语法和新的AST结点。下面就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">program</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""program : compound_statement DOT"""</span></span><br><span class="line">    node = self.compound_statement()</span><br><span class="line">    self.eat(DOT)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compound_statement</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    compound_statement: BEGIN statement_list END</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    self.eat(BEGIN)</span><br><span class="line">    nodes = self.statement_list()</span><br><span class="line">    self.eat(END)</span><br><span class="line"></span><br><span class="line">    root = Compound()</span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">        root.children.append(node)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">statement_list</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    statement_list : statement</span></span><br><span class="line"><span class="string">                   | statement SEMI statement_list</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    node = self.statement()</span><br><span class="line"></span><br><span class="line">    results = [node]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> self.current_token.type == SEMI:</span><br><span class="line">        self.eat(SEMI)</span><br><span class="line">        results.append(self.statement())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.current_token.type == ID:</span><br><span class="line">        self.error()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">statement</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    statement : compound_statement</span></span><br><span class="line"><span class="string">              | assignment_statement</span></span><br><span class="line"><span class="string">              | empty</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> self.current_token.type == BEGIN:</span><br><span class="line">        node = self.compound_statement()</span><br><span class="line">    <span class="keyword">elif</span> self.current_token.type == ID:</span><br><span class="line">        node = self.assignment_statement()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        node = self.empty()</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">assignment_statement</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    assignment_statement : variable ASSIGN expr</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    left = self.variable()</span><br><span class="line">    token = self.current_token</span><br><span class="line">    self.eat(ASSIGN)</span><br><span class="line">    right = self.expr()</span><br><span class="line">    node = Assign(left, token, right)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">variable</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    variable : ID</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    node = Var(self.current_token)</span><br><span class="line">    self.eat(ID)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">empty</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""An empty production"""</span></span><br><span class="line">    <span class="keyword">return</span> NoOp()</span><br></pre></td></tr></table></figure></li><li><p><strong><em>factor</em></strong> 函数的修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""factor : PLUS  factor</span></span><br><span class="line"><span class="string">              | MINUS factor</span></span><br><span class="line"><span class="string">              | INTEGER</span></span><br><span class="line"><span class="string">              | LPAREN expr RPAREN</span></span><br><span class="line"><span class="string">              | variable</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    token = self.current_token</span><br><span class="line">    <span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">        self.eat(PLUS)</span><br><span class="line">        node = UnaryOp(token, self.factor())</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        node = self.variable()</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure></li><li><p><strong><em>parse</em></strong> ：更新之后，它从程序的定义开始语法的分析：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self)</span>:</span></span><br><span class="line">    node = self.program()</span><br><span class="line">    <span class="keyword">if</span> self.current_token.type != EOF:</span><br><span class="line">        self.error()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure></li></ol><p>下面是一个简单的程序：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        number := <span class="number">2</span>;</span><br><span class="line">        a := number;</span><br><span class="line">        b := <span class="number">10</span> * a + <span class="number">10</span> * number / <span class="number">4</span>;</span><br><span class="line">        c := a - - b</span><br><span class="line">    <span class="keyword">END</span>;</span><br><span class="line">    x := <span class="number">11</span>;</span><br><span class="line"><span class="keyword">END</span>.</span><br></pre></td></tr></table></figure><p>它的解析树为（为了简洁，下面的树中变量的名字所在结点就是<strong><em>Var</em> node</strong>， <strong>Assign node</strong>赋值结点表示为 ‘:=’ ）：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://ruslanspivak.com/lsbasi-part9/lsbasi_part9_full_ast.png" alt="img"></p><h3 id="interpreter的改变"><a href="#interpreter的改变" class="headerlink" title="interpreter的改变"></a><red>interpreter的改变</red></h3><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-9/lsbasi_part9_interpreter.png" alt="img"></p><p>为了解释新的AST结点，我们需要在interpreter中添加相应的visitor 函数：</p><ul><li>visit_Compound</li><li>visit_Assign</li><li>visit_Var</li><li>visit_NoOp</li></ul><p>其中，<code>visit_Compound</code>：遍历它的孩子节点，<code>visit_NoOp</code>：什么都不做。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_Compound</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> node.children:</span><br><span class="line">        self.visit(child)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_NoOp</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><code>visit_Assign</code>：当我们给变量赋值时，需要将该变量的值存到某个地方，待用。这也就是此函数的功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_Assign</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    var_name = node.left.value</span><br><span class="line">    self.GLOBAL_SCOPE[var_name] = self.visit(node.right)</span><br></pre></td></tr></table></figure><blockquote><p>这个函数存储了一个键-值对key-value pair（一个变量名、一个变量的值），存储在<em>symbol table</em> GLOBAL_SCOPE。</p><ul><li><p>what is <em>symbol table</em>?</p><p><strong><em>symbol table</em></strong>是一个抽象数据类型（abstract data type (<strong>ADT</strong>)），用于跟踪源码中各种符号。目前的符号类型还只有变量，我们用Python字典趋势线符号表的ADT。</p><p>（在这里用符号字表 实现的笨拙：因为它不是一个带有特殊方法的独立类，而是一个简单的Python字典，而且它的另外职责是 内存空间。在后面的文章中，原作者将会带我们了解symbol tables的细节）</p></li></ul></blockquote><ul><li><p>让我们来看一下“a := 3;” 的AST，和它的 symbol table （<em>visit_Assign</em> 函数处理前和处理后的）：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-9/lsbasi_part9_ast_st01-1584541191100.png" alt="lsbasi_part9_ast_st01"></p></li></ul><p>现在让我们看看句子：“b := a + 7;”的AST：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-9/lsbasi_part9_ast_only_st02.png" alt="lsbasi_part9_ast_only_st02"></p><p><code>visit_Var</code>：可以看出，赋值语句得到右半部分：“a + 7” 提及变量a，所以我们要先知道变量a的value，这就是visit_Var函数要干的事情：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_Var</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    var_name = node.value</span><br><span class="line">    val = self.GLOBAL_SCOPE.get(var_name)</span><br><span class="line">    <span class="keyword">if</span> val <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> NameError(repr(var_name))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> val</span><br></pre></td></tr></table></figure><blockquote><p>visit 一个 <em>Var</em> 结点：它首先得到变量的名字；然后这个变量名字作为进入<em>GLOBAL_SCOPE</em> dictionary的key🔑去寻找变量的value，如果找到了 就返回变量地值，如果找不到就NameError函数伺候。</p><p>下面是“b := a + 7;”的AST和符号表（赋值前和复制后）</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-9/lsbasi_part9_ast_st02.png" alt="lsbasi_part9_ast_st02"></p></blockquote><hr><p>上面就是今天所有需要进行的update了。</p><p>At the end of the main program, we simply print the contents of the symbol table GLOBAL_SCOPE to standard output.</p><p>Let’s take our updated interpreter for a drive both from a Python interactive shell and from the command line. Make sure that you downloaded both the source code for the interpreter and the <a href="https://github.com/rspivak/lsbasi/blob/master/part9/python/assignments.txt" target="_blank" rel="noopener">assignments.txt</a> file before testing:</p><p>Launch your Python shell:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ python</span><br><span class="line">&gt;&gt;&gt; from spi import Lexer, Parser, Interpreter</span><br><span class="line">&gt;&gt;&gt; text &#x3D; &quot;&quot;&quot;\</span><br><span class="line">... BEGIN</span><br><span class="line">...</span><br><span class="line">...     BEGIN</span><br><span class="line">...         number :&#x3D; 2;</span><br><span class="line">...         a :&#x3D; number;</span><br><span class="line">...         b :&#x3D; 10 * a + 10 * number &#x2F; 4;</span><br><span class="line">...         c :&#x3D; a - - b</span><br><span class="line">...     END;</span><br><span class="line">...</span><br><span class="line">...     x :&#x3D; 11;</span><br><span class="line">... END.</span><br><span class="line">... &quot;&quot;&quot;</span><br><span class="line">&gt;&gt;&gt; lexer &#x3D; Lexer(text)</span><br><span class="line">&gt;&gt;&gt; parser &#x3D; Parser(lexer)</span><br><span class="line">&gt;&gt;&gt; interpreter &#x3D; Interpreter(parser)</span><br><span class="line">&gt;&gt;&gt; interpreter.interpret()</span><br><span class="line">&gt;&gt;&gt; print(interpreter.GLOBAL_SCOPE)</span><br><span class="line">&#123;&#39;a&#39;: 2, &#39;x&#39;: 11, &#39;c&#39;: 27, &#39;b&#39;: 25, &#39;number&#39;: 2&#125;</span><br></pre></td></tr></table></figure><p>And from the command line, using a source file as input to our interpreter:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python spi.py assignments.txt</span><br><span class="line">&#123;&#39;a&#39;: 2, &#39;x&#39;: 11, &#39;c&#39;: 27, &#39;b&#39;: 25, &#39;number&#39;: 2&#125;</span><br></pre></td></tr></table></figure><p>If you haven’t tried it yet, try it now and see for yourself that the interpreter is doing its job properly.</p><h2 id="summary"><a href="#summary" class="headerlink" title="summary"></a><red>summary</red></h2><p>让我们来总结一下，你今天扩展了Pascal解释器的哪些部分：</p><ol><li>添加新的语法规则</li><li>添加新的token，和它对应词法分析器中的方法（也更新了<em>get_next_token</em>）</li><li>在 parser 中为新的语法结构添加新的AST结点</li><li>在（递归下降的）语法分析中 添加相应对应新语法规则的新函数，</li><li>在interpreter中增添了新的visitor函数</li><li>新增 用于存储和查找变量的字典</li></ol><h2 id="HACKS"><a href="#HACKS" class="headerlink" title="HACKS"></a><red>HACKS</red></h2><p>现在要介绍一下“hacks”（不完善的地方），并且随着系列文章的深入，我们还将一步步解决这些内容：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-9/lsbasi_part9_hacks.png" alt="lsbasi_part9_hacks"></p><p>上图中的不完善的地方，也就是这些：</p><ol><li><p><em>program</em> 语法规则目前不完善，在后续文章会扩展；</p></li><li><p>Pascal语言是一个静态类型语言，在使用变量之前必须要先声明；</p></li><li><p>没有类型检测，目前还不是什么大问题。但当有更多类型的时候，就需要类型检测；</p></li><li><p>符号表</p></li><li><p>目前为止，都是用“/”来表示除法。但在Pascal语言中，必须要用关键字“div”来表示整数除法；</p></li><li><p>在Pascal语言中，标识符 和 保留字 是不区分大小写的(case insensitive)。但是在目前的文章中，我们把它设计成了区分大小写。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Let&#39;s Build A Simple Interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Front-matter的规则</title>
      <link href="/archives/138a.html"/>
      <url>/archives/138a.html</url>
      
        <content type="html"><![CDATA[<p>文章写作时，的front matter 的参数</p><a id="more"></a><p>参数描述<code>layout</code>布局<code>title</code>标题<code>date</code>建立日期<code>updated</code>更新日期<code>comments</code>开启文章的评论功能<code>tags</code>标签（不适用于分页）<code>categories</code>分类（不适用于分页）<code>permalink</code>覆盖文章网址</p><p>其中，分类和标签需要区别一下，分类具有顺序性和层次性，也就是说<code>Foo</code>，<code>Bar</code>不等于<code>Bar</code>，<code>Foo</code>；而标签没有顺序和层次。</p><p><strong>注意：每个冒号后面是有一个空格的。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">title: 文章的front-matter规则 <span class="comment">// 你的博客名字    </span></span><br><span class="line">date: <span class="number">2019</span><span class="number">-08</span><span class="number">-10</span> <span class="number">21</span>:<span class="number">44</span>:<span class="number">44</span>  <span class="comment">//文章创建的日期</span></span><br><span class="line">author: longlongqin   <span class="comment">//作者名字</span></span><br><span class="line">img: /medias/banner/<span class="number">6.</span>jpg <span class="comment">//文章的显示的时候的背景</span></span><br><span class="line">coverImg: /medias/banner/<span class="number">6.</span>jpg  </span><br><span class="line">top: <span class="literal">true</span></span><br><span class="line">cover: <span class="literal">true</span></span><br><span class="line">toc: <span class="literal">true</span></span><br><span class="line">password: </span><br><span class="line">mathjax: <span class="literal">true</span></span><br><span class="line">summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</span><br><span class="line">tags:</span><br><span class="line">- Hexo</span><br><span class="line">- Github</span><br><span class="line">- 博客</span><br><span class="line">categories:</span><br><span class="line">- 软件安装与配置</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">配置选项</th><th align="left">默认值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">title</td><td align="left"><code>Markdown</code> 的文件标题</td><td align="left">文章标题，强烈建议填写此选项</td></tr><tr><td align="left">date</td><td align="left">文件创建时的日期时间</td><td align="left">发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td align="left">author</td><td align="left">根 <code>_config.yml</code>中的 <code>author</code></td><td align="left">文章作者</td></tr><tr><td align="left">img</td><td align="left"><code>featureImages</code>中的某个值</td><td align="left">文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td align="left">top</td><td align="left"><code>true</code></td><td align="left">推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td align="left">cover</td><td align="left"><code>false</code></td><td align="left"><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td align="left">coverImg</td><td align="left">无</td><td align="left"><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td align="left">password</td><td align="left">无</td><td align="left">文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td align="left">toc</td><td align="left"><code>true</code></td><td align="left">是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td align="left">mathjax</td><td align="left"><code>false</code></td><td align="left">是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td align="left">summary</td><td align="left">无</td><td align="left">文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td align="left">categories</td><td align="left">无</td><td align="left">文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td align="left">tags</td><td align="left">无</td><td align="left">文章标签，一篇文章可以多个标签</td></tr><tr><td align="left">reprintPolicy</td><td align="left">cc_by</td><td align="left">文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><p><strong>注意</strong>:</p><blockquote><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2" target="_blank" rel="noopener">开源中国在线工具</a>、<a href="http://encode.chahuo.com/" target="_blank" rel="noopener">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx" target="_blank" rel="noopener">站长工具</a>。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> front-matter配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let’s Build A Simple Interpreter-8</title>
      <link href="/archives/ae12.html"/>
      <url>/archives/ae12.html</url>
      
        <content type="html"><![CDATA[<p>今天，将要在前面的基础上，添加<strong>一元操作符unary operators</strong>：unary plus (+) and unary minus (-) operators。</p><a id="more"></a><p><strong>今天将要完成的任务：</strong></p><ul><li>扩展语法，能够处理“+”、“-”一元操作符；</li><li>添加一个新的结点类：<em>UnaryOp</em> AST node class；</li><li>扩展语法分析器parser，生成含有<em>UnaryOp</em> nodes结点的抽象语法树；</li><li>扩展解释器interpreter。并且增添一个新的<em>visit_UnaryOp</em> method函数，它可以解析一元操作符</li></ul><p>现在，开始吧。</p><h1 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h1><h2 id="一元操作符是什么？"><a href="#一元操作符是什么？" class="headerlink" title="一元操作符是什么？"></a>一元操作符是什么？</h2><p><strong>二元操作符：</strong></p><p>之前，我们的计算器都是围绕着这些二元操作符 (+, -, *, /)在工作，这些操作符操作两个操作数（the operators that operate on two operands.）。</p><p><strong>一元操作符<em>unary operator</em> ：</strong></p><p>那么，我们就能知道一元操作符是：一个操作符只操作一个操作数。（A <em>unary operator</em> is an operator that operates on one <em>operand</em> only.）</p><h2 id="一元操作符的规则"><a href="#一元操作符的规则" class="headerlink" title="一元操作符的规则"></a>一元操作符的规则</h2><p>下面是一元操作符“+、-”的规则：</p><ul><li>一元操作符<code>-</code>：它会使它的操作数取反（negation）</li><li>一元操作符<code>+</code>：他对于它的操作数没影响，即，它的操作数不改变什么</li><li>一元操作符比二元操作符（+, -, *, and /）有着更高的优先级（precedence）</li></ul><p>例子：</p><ol><li><p><strong>“+ - 3”</strong></p><p>其中，这第一个位置的“+”表示一元操作符加号操作；第二个位置的“-”表示一元操作符减号操作。所以，“+ - 3”就相当于“+ (- (3))”，即，等于-3。</p><p>【注】：这里的-3平常情况说它是一个负整数（negative integer），但是在这里我们称它是：一个一元操作符“-”，它的操作数是3。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-8/lsbasi_part8_exp1.png" alt="img"></p></li><li><p><strong>“5 - - 2”</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-8/lsbasi_part8_exp2.png" alt="img"></p><p><u>在这个表达式中，第一个“-”表示一个二元操作符：减法。第二个“-”表示一个一元操作符：取反。</u></p><p>比如下面的一些例子，也是这个样子：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-8/lsbasi_part8_exp3.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-8/lsbasi_part8_exp4.png" alt="img"></p></li></ol><h1 id="开始修改"><a href="#开始修改" class="headerlink" title="开始修改"></a>开始修改</h1><h2 id="将一元操作符添加入语法"><a href="#将一元操作符添加入语法" class="headerlink" title="将一元操作符添加入语法"></a>将一元操作符添加入语法</h2><h3 id="修改factor"><a href="#修改factor" class="headerlink" title="修改factor"></a>修改factor</h3><p>因为，一元操作符的优先级高于二元操作符。所以，函数<code>factor</code>需要需改。它之前的规则为：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-8/lsbasi_part8_factor_before.png" alt="更新前"></p><p>更新后的，规则为：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-8/lsbasi_part8_factor_after.png" alt="更新后"></p><blockquote><p>从更新后的factor函数的规则，可知：<strong>它扩展之后能够引用它本身</strong>。</p><p>这样我们就能够写出类似于：- - - + - 3”这样的式子，这是合法的带有很多一元操作符的表达式。</p></blockquote><p>其实，这里修改语法，只用修改<code>factor</code>函数的产生式，其他的<code>expr</code>、<code>term</code>产生式不变：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-8/lsbasi_part8_grammar.png" alt="img"></p><h2 id="扩展抽象语法树的结点类"><a href="#扩展抽象语法树的结点类" class="headerlink" title="扩展抽象语法树的结点类"></a>扩展抽象语法树的结点类</h2><p>下一步就是要添加一个AST node class，来表示一元操作符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnaryOp</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, op, expr)</span>:</span></span><br><span class="line">        self.token = self.op = op</span><br><span class="line">        self.expr = expr</span><br></pre></td></tr></table></figure><p>这个函数有两个参数：op、expr：</p><ul><li>op：代表一元操作符的token（+或-）</li><li>expr：表示一个AST的结点（要与expr函数区分，这两个知识名字一样，但是代表的东西不一样）</li></ul><h2 id="扩展语法分析器parser"><a href="#扩展语法分析器parser" class="headerlink" title="扩展语法分析器parser"></a>扩展语法分析器parser</h2><p>之前我们修改了语法规则，当中的factor函数的产生式也发生了变化，所以现在我们将要修改代码，使其能够处理产生式中的 “(PLUS | MINUS) factor” 子规则：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""factor : (PLUS | MINUS) factor | INTEGER | LPAREN expr RPAREN"""</span></span><br><span class="line">    token = self.current_token</span><br><span class="line">    <span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">        self.eat(PLUS)</span><br><span class="line">        node = unaryop(token, self.factor())</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">        self.eat(MINUS)</span><br><span class="line">        node = unaryop(token, self.facot())</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="keyword">elif</span> token.type == INTEGER:</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        node = NUM(token)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="keyword">elif</span> token.type == LPAREN:</span><br><span class="line">        self.eat(LPAREN)</span><br><span class="line">        node = self.expr()</span><br><span class="line">        self.eat(RPAREN)</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure><h2 id="扩展解释器Interpreter"><a href="#扩展解释器Interpreter" class="headerlink" title="扩展解释器Interpreter"></a>扩展解释器Interpreter</h2><p>现在我们还需要扩展解释器类<em>Interpreter</em> class ，向其中添加<em>visit_UnaryOp</em> 函数，来解释一元操作符结点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_UnaryOp</span><span class="params">(self, node)</span></span></span><br><span class="line">op = node.op.type #token的类型</span><br><span class="line">    <span class="keyword">if</span> op == PLUS:</span><br><span class="line">        <span class="keyword">return</span> +self.visit(node.expr)</span><br><span class="line">    <span class="keyword">elif</span> op == MINUS:</span><br><span class="line">        <span class="keyword">return</span> -self.visit(node.expr)</span><br></pre></td></tr></table></figure><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>让我们看一个例子，表达式 “5 - - - 2” ，通过我们的解析器来证实这个新的<em>visit_UnaryOp</em>函数确实起作用了。</p><p>下面是如何从Python shell中实现:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> spi <span class="keyword">import</span> BinOp, UnaryOp, Num, MINUS, INTEGER, Token</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>five_tok = Token(INTEGER, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>two_tok = Token(INTEGER, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>minus_tok = Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>expr_node = BinOp(</span><br><span class="line"><span class="meta">... </span>    Num(five_tok),</span><br><span class="line"><span class="meta">... </span>    minus_tok,</span><br><span class="line"><span class="meta">... </span>    UnaryOp(minus_token, UnaryOp(minus_token, Num(two_tok)))</span><br><span class="line"><span class="meta">... </span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> spi <span class="keyword">import</span> Interpreter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inter = Interpreter(<span class="literal">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inter.visit(expr_node)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>上面的AST树看起来是这样的:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-8/lsbasi_part8_ast.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Let&#39;s Build A Simple Interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造凸包——Divide And Conquer</title>
      <link href="/archives/f32f.html"/>
      <url>/archives/f32f.html</url>
      
        <content type="html"><![CDATA[<p>Graham Scan算法说明了凸包构造问题的下界O(nlogn)是可以达到的。其实O(nlogn)的算法远不止这一种，分治法就是一种能达到O(nlogn)复杂度的思想。在此引入运用分治思想的两种算法来构造凸包。</p><a id="more"></a><h1 id="归并排序与分治思想"><a href="#归并排序与分治思想" class="headerlink" title="归并排序与分治思想"></a>归并排序与分治思想</h1><p>引入新算法之前依旧先来回顾一个经典排序算法：归并排序（merge sort）。归并排序的基本流程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315163056136.png" alt="image-20200315163056136"></p><p>算法分为两个阶段：<strong>分（divide）</strong>和<strong>归并（merge）</strong>。</p><ul><li><strong>分</strong>的阶段将待排序列均分到一个个子序列（如图中划分到单个元素）。</li><li><strong>归并</strong>阶段将分好的子序列两两合并成有序序列，重复合并的过程直到整体归为一个序列。</li></ul><p>归并过程共logn步，每步耗费n的时间，总体复杂度为O(nlogn)。</p><p>归并排序的过程就是一个典型的分治（divide-and-conquer）策略。凸包构造问题也可以套用这种策略来分而治之，逐步求解。<u>我们可以将待处理点集S分为同等规模的两个子点集，并分别对其求凸包。</u></p><p>有了两个子解后，问题就变成了如何<strong>适当加一些边</strong>，将两个子凸包merge成整体解。<strong>分治法核心的任务就是如何merge。</strong></p><h1 id="Divide-And-Conquer（1）"><a href="#Divide-And-Conquer（1）" class="headerlink" title="Divide And Conquer（1）"></a>Divide And Conquer（1）</h1><h2 id="预处理为star-shaped-polygon"><a href="#预处理为star-shaped-polygon" class="headerlink" title="预处理为star-shaped polygon"></a>预处理为star-shaped polygon</h2><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315163119718.png" alt="image-20200315163119718"></p><p>分治法解决问题的过程可以概括为：大事化小，小事化了。就是首先将问题划分为易求解的子问题，子问题套用已知方法解答即可。例如子凸包的构造就能用Graham Scan来解决。</p><p>Graham Scan解决问题的前提是：参照基准点，其他点按极角有序排列，也就是构成了一个有序的星形多边形（star-shaped polygon）。<strong>首先要做的就是将两个子凸包预处理成两个star-shaped polygon。</strong></p><blockquote><p><strong>star-shaped polygon星形多边形</strong>是什么呢？</p><p>其实就是在多边形内部存在一个点A，这个点与多边形内任意一点的连线都在多边形内部，就叫做星形多边形，这一个点A就叫做多边形的内核。</p></blockquote><p>由于任何一个凸多边形都是star-shaped polygon，它必然有一个核，其他点按极角有序排列。<u>问题在于如何找到一个公共核</u>，使得两个子凸包同时关于这个核是极角有序排列的。也就是公共核处于两个凸包的交部分，这样是最好处理的情况（如下左图）。不过还有可能有其他情况，不能找到公共核（如下中图），甚至两个凸包根本不相交（如下右图）：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315163145301.png" alt="image-20200315163145301"></p><p>这就要将分治策略分不同情况来实现：</p><h3 id="两个子凸包有公共核："><a href="#两个子凸包有公共核：" class="headerlink" title="两个子凸包有公共核："></a>两个子凸包有公共核：</h3><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315163518484.png" alt="image-20200315163518484"></p><p><u>先找其中一个子凸包的核</u>：我们可以任取该子凸包上的三点构成三角形，求三角形重心作为核。</p><p><u>然后判断这个核是否也在另一个子凸包内部</u>，若判定为真，就是有公共核的最简单情况。判定方法也就是之前提过的<u>in convex polygon test</u>，对凸包每条边做to left test即可，在线性时间内可以判定。</p><p><strong>找到公共核之后，进行凸包形成</strong>：—-用二路归并</p><p>相对于公共核，两个子凸包的各自有序排列，相互交错。要做的就是将二者点序列合并，方法正是经典的<strong>二路归并</strong>，线性时间可以完成。最后进行Graham Scan即可得到大凸包。</p><h3 id="一个子凸包的核落在另一个子凸包外部："><a href="#一个子凸包的核落在另一个子凸包外部：" class="headerlink" title="一个子凸包的核落在另一个子凸包外部："></a>一个子凸包的核落在另一个子凸包外部：</h3><p>存在公共核的情况处理是很简单的，再看第一个子凸包的核落在第二个子凸包外部的情况。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315164325225.png" alt="image-20200315164325225"></p><p>这中情况与<strong>增量构造法</strong>的情况很相似，P1的核x相对于P2就是一个新加入的点。做出两条support line：x→t和x→s，舍弃P2上t→s路径的点即可。这样P2中剩余点与x构成了一个星形多边形，x也成为了P2的核。<strong>这就转化成了第一种有公共核的情况。</strong></p><h1 id="Divide-And-Conquer（2）"><a href="#Divide-And-Conquer（2）" class="headerlink" title="Divide And Conquer（2）"></a>Divide And Conquer（2）</h1><p>上述分治策略的算法过于复杂，所以引入一种更加简明的分治策略。这种分治策略也会为三角剖分等问题提供思路。</p><p>首先规定一种点集划分的策略。假设待合并的两个子凸包是沿着某方向是分离的，<strong>二者不相交</strong>（Divide And Conquer（1）中是有相交的）。例如下图凸包P1和P2就是相互分离的：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315164957102.png" alt="image-20200315164957102"></p><p><strong>这样划分会使得合并更加简明，不必区分多种复杂情况</strong>。</p><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>为了满足这种划分策略，<strong>需要引入一种预处理</strong>，也就是一个x方向的排序过程（X-sorting）。排序后就可取点x坐标的中值，将点集划分为规模相当的左右两个子集。每个凸包都有其<strong>最左点l</strong>和<strong>最右点r</strong>，如上图。</p><h2 id="merge操作"><a href="#merge操作" class="headerlink" title="merge操作"></a>merge操作</h2><p>现在<strong>merge操作</strong>就是将两个左右相离的两个子凸包合并为一个大凸包的过程了。运算的关注的正是两对l和r点。</p><p>先直观感受一下merge操作要添加的新极边：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315165142262.png" alt="image-20200315165142262"></p><p>上下两条紫色边正是要求的新边，又称支撑边（<strong>support line</strong>），<u>并且每次merge<strong>只会</strong>增加<strong>两条</strong>新边</u>。两条边类似两个圆的<strong>公切线（common tangent）</strong>，将二者连接起来。</p><blockquote><p>注意，注意，注意：<strong>眼睛可能会欺骗你</strong></p><p>直观上感觉，两条support line正是两个子凸包的最高点t和最低点b相互连接得到的，这些点只需线性时间就能找到。<u>当真如此的话凸包构造的下界就成了O(n)，显然直觉是错误的。</u>例如下面的两种情况，support line就和b、t两点没有直接关系了：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315165430771.png" alt="image-20200315165430771">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315165443290.png" alt="image-20200315165443290"></p><p>构造support line的过程需要缜密的分析，并非凭直觉能得到的。</p></blockquote><h3 id="缝合（stitch）—构造support-line"><a href="#缝合（stitch）—构造support-line" class="headerlink" title="缝合（stitch）—构造support line"></a>缝合（stitch）—构造support line</h3><p>将两个子凸包连接的过程更像古代妇女用针将两块布缝合在一起（但是这里的两个凸包的间距是不能变的，仅仅是用线将其连接在一起。而且这里连接只需要最后找出来的那两条线，其余剩下的中间“工具线”都要舍去）。</p><p>构造过程首先从<strong>左凸包的r点</strong>和<strong>右凸包的l点</strong>连线开始，以这条线为基础逐步得到support line。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315165636768.png" alt="image-20200315165636768"></p><blockquote><p>注意一个细节问题：</p><p>如何得到各子凸包的l点和r点。每次合并都会产生新的凸包，所以凸包是一个动态的结构。当然可以每次计算出最左点和最右点，只需要线性时间。但是这并不是最优的方式。考虑分治的思想，就整个merge流程来讲，是自底向上将子凸包两两合并的过程。因此只要在最底层上最小的子凸包中记录最左点和最右点，每次merge更新一下这两个变量即可，只需要O(1)的常数时间！这种优化对整体的复杂度上线nlogn虽然没有影响，也能为程序节省一部分的开销。</p></blockquote><h4 id="缝合上半部分"><a href="#缝合上半部分" class="headerlink" title="缝合上半部分"></a>缝合上半部分</h4><blockquote><p>再看如何将最初的r-l线变成support line，在此以<strong>寻找upper support line为例</strong>（上切线，相应的还需要计算下切线）。<strong><u>算法的核心依然是to left test</u></strong>。</p></blockquote><ul><li><strong>首先看<code>l</code>点</strong>，从r-l线出发，可以发现相对于对于r→l时，l的前驱、后继是LR型的。而我们想要的是RR型的。所以必须要找l的前驱。直到在某一个时刻，我们找到了l的一个前驱点满足RR型：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315171448455.png" alt="找到l点的前驱满足当前形势的RR"></p><ul><li><p><strong>再看<code>r</code>点</strong>，同样的，从此时的状态，来观察r的类型：是RL型的。要想成为LL型，r必须要找它的后驱。</p><p>在某一时刻，r找到r的后继（就是该凸包点t）使其满足LL型：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315171826930.png" alt="找到r的后驱满足当前形势的LL"></p></li><li><p><strong>反过来继续看<code>l</code></strong>，此时，<strong>具体的说应该是检测l的前驱点<code>l&#39;</code></strong>，经检测，<code>l&#39;</code>已经不再满足RR型了，编程了LR型，所以还要继续寻找它的前驱点，使其再次满足RR型。</p><p>某一时刻，找到它的前驱（就是该凸包的点t），使其成为RR型。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315171826931.png" alt="image-20200315171826931"></p><ul><li><strong>反过来继续看<code>r</code></strong>，此时，更准确的应该说是在看<code>r&#39;</code>，经检测，该店符合LL型。至此，所谓的<code>r</code>和<code>l</code>都已经符合RR或LL型了。从而已经找到<strong>upper support line</strong>了。结束上半部分。</li></ul></li></ul><blockquote><p>回顾由r-l线逐步推进得到support line的过程，每次操作一个端点，得到是一种“Z”字形（zig-zag）的推进轨迹。操作点的切换由另一点满足要求决定，而算法停止的依据是两个端点同时满足了要求。这种方式类似快速排序构造轴点的过程，左右两轴点交替操作，直到二者都满足要求时算法停止。</p></blockquote><h4 id="缝合下半部分"><a href="#缝合下半部分" class="headerlink" title="缝合下半部分"></a>缝合下半部分</h4><p>缝合下半部分的流程与，上半部分流程一样。</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>分析一下算法时间复杂度。<strong>算法首先要按照x坐标排序，排序复杂度为O(nlogn)。</strong>再看merge过程，无论是左侧子凸包还是右侧子凸包，对于其每个点的操作至多只有以此，也就是每次归并是线性时间。归并共logn次，算法的<strong>总体复杂度就是O(nlogn)</strong>了。</p><h1 id="更多的考虑"><a href="#更多的考虑" class="headerlink" title="更多的考虑"></a>更多的考虑</h1><p>在这些算法讲解中，<strong>通常都是不考虑退化的情况</strong>，如，三点共线……</p><p>最后总结一下第二种分治法的特点。此前<a href="http://blog.csdn.net/houszchina/article/details/79261505" target="_blank" rel="noopener">Jarvis March算法</a>虽然以平方复杂度为上界，但其”输出敏感性“使得实际复杂度为O(hn)，最好情况下仅甚至为线性。例如如下情况：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315174908920.png" alt="image-20200315174908920"></p><p>Jarvis March算法的复杂度变为了O(4n)，而此时分治法依旧会经历按部就班的X-sorting，一上来就注定了O(nlogn)的复杂度，然后经历同样O(nlogn)的merge过程。也就是说这种分治法在各种情况下的表现都是很均匀的。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造凸包-Graham Scan法</title>
      <link href="/archives/3478.html"/>
      <url>/archives/3478.html</url>
      
        <content type="html"><![CDATA[<h1 id="Graham-Scan算法的流程"><a href="#Graham-Scan算法的流程" class="headerlink" title="Graham Scan算法的流程"></a>Graham Scan算法的流程</h1><p>假设待处理点集S共有n个点。</p><h2 id="1、预处理"><a href="#1、预处理" class="headerlink" title="1、预处理"></a>1、预处理</h2><ol><li><p><strong>预排序(presorting</strong>）</p><p>Graham Scan首先要做的是一个预处理排序操作（<strong>presorting</strong>）。即找到某个基准点，然后将其余所有的点按照相对于基准点的<strong>极坐标</strong>排序。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/20180207204917568.jpg" alt="img"></p><blockquote><p>点的排序可以套用任意排序算法的框架，只是将排序对象由数值变为了平面上的点，而比较器改为<strong>to left test</strong>实现。</p></blockquote><p><strong>如何找出第一个点：点1？</strong></p><blockquote><p>以点1为基准点，其余点按照相当于点1的极角依次排序为2、3、4……理论上讲任何一个点都能当第一个基准点，为了简化算法通常选择<strong>lowest-then-leftmost point（LTL）</strong>作为基准点。</p></blockquote></li><li><p><strong>找出起始边</strong></p><p>对于与基准点1极角最小的点，也就是图中点2（假设没有三点共线的情况）。将点1和点2作为算法的起始点。</p></li><li><p><strong>将起始边 与 剩下的n-2条边分别存储在不同的栈(stack)中：</strong></p><p>算法开始前先将起始点1和2入栈S，其他的n-2个点入栈T，如下图。注意S和T中元素的入栈顺序。至此预处理已经完成。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/image-20200314181609764.png" alt="栈：T和S"></p><blockquote><p>Graham Scan用到的数据结构。整个算法非常简明，核心数据结构只有两个<strong>栈</strong>，分别记作栈<strong>S</strong>和栈<strong>T</strong>。便于理解我们将S和T画成开口相对的形式，如上图。</p></blockquote></li></ol><h2 id="2、scan操作-此处为逆时针扫描"><a href="#2、scan操作-此处为逆时针扫描" class="headerlink" title="2、scan操作(此处为逆时针扫描)"></a>2、scan操作(此处为逆时针扫描)</h2><p>完成预处理之后，就能开始算法的核心：scan操作。scan的过程主要关注三个点：<strong>栈S的栈顶（S[0]）、次栈顶（S[1]）和栈T的栈顶（T[0]）</strong>。也就下图红色标注的三个点：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/20180207210925858.jpg" alt="img"></p><p>对这三个关注的点，进行检测，检测的框架为：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/image-20200314182719216.png" alt="image-20200314182719216"></p><ul><li>可以观察到，<u>每次待处理的S[0]和S[1]构成的边一定是一条极边（如上图点1和点2）</u>，算法<strong>关键步骤</strong><u>就是对边这条极边和T[0]做to left test，判断T[0]位于边S[0]S[1]的左边还是右边。若在左边则继续拓展，若在右边则否定掉此前认定的极边。</u>无论结果如何，每次判定都会将问题规模缩小一个单元，算法结束时T最终肯定为空。T空后，S中存留下的点正是凸包的极点，这些点自底而上正是凸包边界点的逆时针遍历，也得到了整个凸包构造问题的解。</li></ul><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><strong>1、</strong>先来看一个最简单的例子，即点集S中所有的点都在凸包边界上。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/image-20200314183056395.png" alt="image-20200314183056395"></p><ul><li><p>先找到LTL，也就是图中点1。然后基于点1对其余点按极角排序为点2、3、4……<em>（实际上以一个点为中心的有序的点集，构成了所谓的星形多边形（star-shaped polygon），中心点正是星形多边形核（kernel）的一部分。凸多边形必然是星形多边形，反之则不然。）</em>然后找到点1的后继2，点1和点2构成第一条极边。初始化栈S和栈T。</p></li><li><p>现在要关心S[1], S[0]和T[0]，就是点1，2和3。点3位于边12左侧，to left关系为true，S.push ( T.pop() )，向前拓展了一条暂定极边。</p></li><li><p>接下来重复上述过程。考虑点2，3和4。to left关系为true，S.push( T.pop() )……最终栈T空，算法结束，凸包由栈S自底向上得到。S和T的变化过程如下图：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/image-20200314211052355.png" alt="image-20200314211052355"></p><hr><p><strong>2、</strong>上面列举了最简单的情况下Graham Scan的过程，接下来列举一个更有代表性的实例深入算法的细节。输入的点集S，并进行预处理排序，并初始化栈S、T，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/20180207215925185.jpg" alt="20180207215925185"></p><ul><li><p>接下来对点1，2和3进行to left测试，本质上就是判断边2→3（图中黄色边）能否被暂时采纳。测试结果为true，暂时采纳边2→3，<strong>S.push( T.pop() )</strong>。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/image-20200314211330428.png" alt="image-20200314211330428"></p><blockquote><p>注意图中蓝色边表示已经被暂时接纳的边，也就是算法暂时认定的极边。上一次操作将蓝色边推进一个单元</p></blockquote></li><li><p>接下来关注点2，3和4，来判断下一条黄色边3→4能否被接纳。to left测试为true，<strong>S.push( T.pop() )</strong>，接纳边3→4。如下图右侧所示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/image-20200314211603647.png" alt="image-20200314211603647"></p></li><li><p>然后判断点3，4和5。点5在边3→4的右侧，即to left测试为false。<strong>S.pop()</strong>，也就是判断出点4不可能为极点，丢弃4。因此算法回溯到点3，判断点2，3和5的关系。5在2→3的左侧，暂时接纳边3→5，<strong>S.push( T.pop() )。</strong>如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/image-20200314211705197.png" alt="image-20200314211705197"></p><blockquote><p>算法经历了无效操作，进行了回溯，得到了目前来说最优的“极边”。虽然这些”极边“不一定能最终保留，但问题的规模得到了削减。</p></blockquote></li><li><p>下一次scan考察的就是3，5和6了。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/image-20200314211916570.png" alt="image-20200314211916570"></p><blockquote><p>3，5和6的to left测试为false，<strong>S.pop()</strong>，舍弃点5。</p></blockquote></li><li><p>然后考察点2，3和6，to left测试为false，<strong>S.pop()</strong>舍弃点3。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/20180207223417072.jpg" alt="img"></p></li><li><p>……..</p></li><li><p>………</p></li><li><p>直遍历完剩下其他点，凸包就构造完成。</p></li></ul><h1 id="验证算法的正确性"><a href="#验证算法的正确性" class="headerlink" title="验证算法的正确性"></a>验证算法的正确性</h1><h2 id="思路上的正确性"><a href="#思路上的正确性" class="headerlink" title="思路上的正确性"></a>思路上的正确性</h2><p>了解了算法的整体流程之后，我们再来论证一下算法的正确性。证明一个算法正确性的方法有很多，在此选用数学归纳法。数学归纳法的思想可用多米诺骨牌类比，要做的无非是两件事：证明第1张骨牌会倒；证明如果第n张骨牌会倒则第n+1张骨牌也会倒下。</p><p>Graham Scan过程就是一个个引入点的过程。每当我们得到第k个点的时候，算法所得到的就是前k个点对应的“最好的凸包”。因此当k = n时得到的是整体的凸包。</p><ol><li><p>归纳的第一步就是证明k = 3时得到的是当前点集S‘ = {1，2，3}中的极边——也就是证明第1张骨牌会倒。</p><blockquote><p>显然边1→2是S’的一条极边。而根据预处理的方式，3相较于1的极角一定大于2，因此点3一定在边1→2的左侧，因此边2→3会得到保留。对于这三个点来说，任意两条边一定都是极边，2→3也是一条极边。</p></blockquote></li><li><p>然后证明：假设已经处理到第k个点，得到的是前点集S’ = {1，2，3，…，k}中所谓“最好的凸包”。根据算法处理方式，接下来从S’’ = {1，2，3，…，k，k+1}得到的结果是否也是正确的——也就是证明第n张骨牌会倒，则第n+1张骨牌也会倒下。</p><blockquote><p>预处理的方式是对2~n所有点相较于点1按极角排序，因此下一个要处理点k+1一定出现在线1→k的左侧，也就是下图蓝色区域和绿色区域（假设k = 9）：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/20180207231513568.jpg" alt="img"></p><p>而根据目前接纳的最后一条极边( k-1)→k （例如图中8→9）来划分，点k+1可能出现的区域又分为两块，即该极边的左侧（绿色区域）和右侧（蓝色区域）。这也正对应于算法判定的两个分支。</p><ul><li><p>左侧：左侧的情况很简单，点k+1显然会是一个新的极点。Graham Scan要做的正是暂时接纳边k→k+1，拓展了一个新的单位。</p></li><li><p>右侧：再看k+1落在右侧的情况。如下图点10：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/20180207232235024.jpg" alt="img"></p><p>Graham Scan要做的是丢弃点k（图中点9），也就是判定出点k不可能是极点。这样做的原因：是引入点k+1后，点k一定会被包含在三角形(1, k-1, k+1)内部。如图中点9一定包含于三角形(1, 8, 10)内部。正如极点法中排除非极点的做法，点k被排除是正确的做法。接下来点k-1，k-2等（如图中点8，点7等）也可能是非极点，按照算法的流程，它们总会被判定在某个三角形的内部（例如点7在三角形(1, 5, 10)内部）而被排除，直到left test为true，回溯停止。</p><p>换个角度考虑，回溯停止时得到的新边正是增量构造法中每步得到的support line，即切线。例如图中线5→10正是算法当前保留的”凸包“的切线。这也能论证Graham Scan处理方式的正确性。</p></li></ul></blockquote></li></ol><p>至此，算法思路上的正确性已经证明完毕。</p><h2 id="表述方式的正确性"><a href="#表述方式的正确性" class="headerlink" title="表述方式的正确性"></a>表述方式的正确性</h2><p>接下来还要考虑算法的表述方式是否有漏洞：代码中每次to left test之前并没有判断S栈中是否有≥2个元素。这也可以由预处理的方式来论证。点1选取的是LTL，而点2是相对于点1极角最小的点，这样的做法保证了除了点1和点2之外所有的点一定是在边1→2左侧的。因此算法回溯最多到点2，永远不可能把点2丢弃，S中元素任何时候至少有两个。</p><hr><p>Graham Scan算法的正确性论证完毕。</p><h1 id="预处理操作的必要性"><a href="#预处理操作的必要性" class="headerlink" title="预处理操作的必要性"></a>预处理操作的必要性</h1><p>最后来思考一下预处理操作：presorting。仔细回顾上述论证过程会发现，每一步的正确性都是建立在最初的排序上的。那么这个预处理排序真的是必要的吗？可以来举极端的反例，每次选取下一个点都是随机的，例如下图的路径：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/20180207235736089.jpg" alt="img"></p><p>上图中从点1开始出发进行to left测试，可以发现，每次判定结果都为true，最终所有的点都被保留了下了，而显然这并不是一个凸包。因此presorting是整个算法成立的基础。</p><h1 id="分析复杂度"><a href="#分析复杂度" class="headerlink" title="分析复杂度"></a>分析复杂度</h1><p>上面证明了Graham Scan算法的正确性，接下来分析其复杂度是否满足O(nlogn)，实现所谓的最优算法。</p><p>直观上无法断定Graham Scan是一个最优的算法，尤其是以下极端情况令人质疑其效率：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/image-20200314220437069.png" alt="image-20200314220437069"></p><p>Graham Scan算法复杂度由三部分决定：</p><ul><li>persorting，采用一般排序算法，复杂度是O(nlogn)</li><li>逐步迭代，O(n)：算法一步步纳入新点，会迭代n步。</li><li>scan，O(?)</li></ul><p><strong>所以算法的总体复杂度：O(nlogn + n * ?) ，可见scan的复杂度决定了算法总体的复杂度。</strong></p><ul><li>算法一步步纳入新点，会迭代n步。但是在每个点上都有可能做回溯操作，所以scan的复杂度是不确定的。我们来以上图最坏情况为例，到第8个点时判定为false，舍弃点7，回溯。下一步判断也为false，舍弃点6，回溯。如此回溯直到算法开始的点2。这次scan倒退了高达O(n)个点，如果每次scan都是如此那么算法整体复杂度就为：O(nlogn + n * n) = O(n^2)了，那这种算法的意义也就不大了。</li></ul><p>其实上述分析并非错误，只是不够精确。<u>O(n^2)确实是Graham Scan算法的一个<strong>上界</strong></u>，但是这个上界并不是紧的。</p><p><u>问题就出在分析假定了每次都会出现回退高达O(n)个点。</u></p><ul><li><p>下图展示了整个Graham Scan的流程：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/20180208002202338.jpg" alt="img"></p><p>图中黄色边是没有采纳的，就是to left测试判定为false后直接舍去的。紫色边则是曾经被认为是极边而接纳的，后来经过回溯又舍去了。无论是黄边还是紫边，在其上耗费的都是常数时间，关键就在于黄色边和紫色边的数目了。</p><blockquote><p>通过观察可以发现，从图论的角度看，所有的黄色边和紫色边连在一起构成了一张<strong>平面图</strong>，也就是它们互相是不可能内部相交的。平面图的一个重要性质：<strong>平面图中所有边的数目和顶点数目保持同阶</strong></p><p>这个性质来自<strong>欧拉公式</strong>：有n个点的平面图，<u>边</u>的数目上限是3n，也就是<strong>O(3n)</strong>。</p><ul><li>回溯（backtrack）可能会倒退的边数：在0~n之间。【但是注意，不是每次回溯都能回退到n，因为由上面可知，点集边数最多为3n，而这里面的每一个边，会被回退0次（极边），或者1次（非极边）。所以，某条边一旦被回退过，之后就不可能再被回退了】</li></ul><p>根据这个性质，在persorting之后的整个流程中，Graham Scan所能走过的所有边不仅不会到达n^2，而顶多到达和n同阶的一个<strong>线性数目</strong>。因此整个算法的复杂度也就取决于persorting的O(nlogn)了。</p></blockquote></li></ul><h1 id="算法推广"><a href="#算法推广" class="headerlink" title="算法推广"></a>算法推广</h1><p>Graham Scan算法不仅可以用于凸包构造问题，在其他许多场景下中也十分有效。为了推广Graham Scan算法，首先可以对其做简化，以方便利用在其他问题。</p><p>首先再来回顾一下预处理排序，这是算法成立必不可少的一步。排序算法套用成熟的方法即可，利用数学方法计算偏角不仅复杂而且引入了误差，所以要采用to left test。要做的就是两点：</p><ul><li>套用成熟的排序算法，将待排序元素由数值变为点</li><li>将排序算法的比较器改为<strong>to left test</strong>实现</li></ul><p>按照这样的流程就能间接地实现persorting。</p><h2 id="1、原始点集已经有某种次序"><a href="#1、原始点集已经有某种次序" class="headerlink" title="1、原始点集已经有某种次序"></a>1、原始点集已经有某种次序</h2><p>有时候我们并不是从零开始构造凸包，例如得到的待处理点集已经是有某种次序的（比如已经按x坐标大小排序，如下图）。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/20180208004657243.jpg" alt="img"></p><p><u>这种情况也不一定非得进行persorting构造新的次序</u>，通常改变观察的角度，换一种理解方式就能免去预处理而直接进行后面的线性的scan操作了。</p><p><strong>上半部分凸包：</strong></p><p>考虑y轴负方向无穷远一个点，所有的点相对于这个点的极角排序恰好就是各点的x坐标序！也就是将无穷远的点看作起始点①，最右侧点（图中点8）看作点②，进行scan过程直到最左边的点（图中点1）结束，就得到了凸包的上半部分（upper hull），也就是下图的8→7→2→1：</p><p><em>注：对 “考虑y轴负方向无穷远一个点，所有的点相对于这个点的极角排序恰好就是各点的x坐标序！” 这句话的理解：</em></p><ul><li>就像太阳光照在地球上的道理是一样的，太阳离地球足够的远，那么它的光到达地球上的时候，就近似的是<strong>平行</strong>的。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/20180208005912300.jpg" alt="img"></p><p><strong>下半部分凸包（lower hull）的构造</strong></p><p>也是如此。考虑一个在y轴正方向无穷远的一个点，以此为起点进行scan，最终得到lower hull：1→4→7。最后将两个凸包合二为一即可。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 凸包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lower Bound</title>
      <link href="/archives/ba04.html"/>
      <url>/archives/ba04.html</url>
      
        <content type="html"><![CDATA[<h2 id="Lower-Bound"><a href="#Lower-Bound" class="headerlink" title="Lower Bound"></a>Lower Bound</h2><p>从极点法的O(n^4^)复杂度，到极边法的O(n^3^)，再到增量构造法和Jarvis March的O(n^2^)，我们经历了将特定问题算法不断优化、降低复杂度的过程。那么还有比O(n^2^)更高效的算法吗？凸包构造算法的下界是什么？推广到一般情况，在计算模型固定的情况下特定问题的复杂度下界又是如何确定的？</p><p>在计算模型固定的情况下特定问题的复杂度<strong>下界（lower bound）</strong>是确定的。严谨考虑，在设计算法前应该先确定下界是多少。</p><p>对于某个问题的特定算法，我们可以用时间复杂度来评价算法的好坏。算法能达到的下界也就是所谓问题的难度。当然这种评价通常是比较麻烦的，有时候甚至是不可行的。<u>这就要引入新的的方式来衡量一个算法的好坏。</u></p><h3 id="规约（reduction）"><a href="#规约（reduction）" class="headerlink" title="规约（reduction）"></a>规约（reduction）</h3><p>我们引入<strong>规约（reduction）</strong>的方法来<u>间接</u>衡量一个算法。规约简单来讲就是用一个“参照物”对比待评算法，得到算法的复杂度。规约的一般方法如图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20180206145307478.png" alt="规约（reduction）"></p><blockquote><p>左侧是已知的问题<strong>A</strong>，已经明确它的难度，右侧是待分析问题<strong>B</strong>，复杂度未知。我们在二者之间建立起一种基本<strong>reduction</strong>关系：<strong>linear-time reduction</strong>。</p><p>linear-time reduction具体表述为：</p><ul><li>任何一个A的输入（input of A），都可以在O(n)复杂度转化为一个B的输入（input of B），然后通过B的某种算法（any algorithm）计算出结果（output of B）;</li><li>而对于output of B又都可以在在O(n)复杂度转化为A问题的结果（output of A）。两次转换的复杂度不能超过线性，也就是linear-time（线性时间）。</li></ul></blockquote><p>能够进行上述操作，就称为：<strong>A问题可以规约到B问题（problem A is linear-time reducible to problem B）</strong>。注意表述方式防止搞混A和B的位置。</p><h4 id="曹冲称象"><a href="#曹冲称象" class="headerlink" title="曹冲称象"></a>曹冲称象</h4><p>可以通过<strong>曹冲称象</strong>的故事来帮助理解规约的思想。要解决的问题是：没有秤能直接称量大象重量（问题B的难度无法直接衡量），<u>解决方案是</u>：利用船和石块间接称量。石头块的重量是可以直接称量的（问题A的难度是已知的），利用<u>船和水</u>来转换石头和大象的重量是可操作的（规约的方法是可操作的）。【这里的<u>规约关系(Reduction relationship)</u>是指曹冲成像时的船和水】</p><h4 id="规约记号"><a href="#规约记号" class="headerlink" title="规约记号"></a>规约记号</h4><p>引入规约记号，problem A is linear-time reducible to problem B表示为：<br>$$<br>A≤_NB<br>$$<br>将问题A、B的难度分别表示为|A|，|B|。规约记号的意思相当于<strong>|A|≤|B|</strong>，A的下界必然就是B的下界。</p><p><strong>规约的过程</strong>：</p><ol><li>将A的输入转化为B的输入</li><li>经过B的某种算法获得解后又转化为A的解，也就是这个算法也是解决A问题的算法。</li></ol><p>已知A问题的下界，那么这个算法必然不会低于A的这个下界。</p><h3 id="构造凸包的下界"><a href="#构造凸包的下界" class="headerlink" title="构造凸包的下界"></a>构造凸包的下界</h3><p>按照“曹冲称象”的规约思想，分析问题的难度，最重要的在于找到“石头”，而船就是规约这种方法。以二维凸包（2d-CH）来分析，首先将待解决的问题放到规约记号<u>右边</u>，而左边的“石头”就是<strong>排序算法</strong>。<br>$$<br>Sorting≤_N2D-CH<br>$$<br>排序是纯粹的数值计算问题，而凸包是典型的几何问题，二者是如何联系在一起的呢？前面<a href="http://blog.csdn.net/HouszChina/article/details/79254856" target="_blank" rel="noopener">增量构造法</a>和<a href="http://blog.csdn.net/HouszChina/article/details/79261505" target="_blank" rel="noopener">Jarvis March算法</a>正是分别由两种排序算法来类比引入的，可见排序和凸包之间有深刻的内在联系。二者之间的联系可以通过下图表示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200312231702595.png" alt="image-20200312231702595"></p><p>首先清点要做的任务：</p><ul><li><p>可以在线性时间内，将排序问题的输入转化为凸包问题的输入</p><ul><li>排序问题的输入可以表示为x轴上的一系列的点（图中蓝色点）。然后将这些点转化为凸包问题的输入，就是将这些待排序的数转化为平面上的点。引入辅助线——一条抛物线，例如图中蓝色虚线。接下来要对蓝色点做到抛物线上的映射（O(n)），映射在抛物线上的点用绿色标出。这样就完成了将待排序数字转化为平面上点的操作。接下来就可以用某种算法将绿色点构造为凸包，即图中CH(P)。</li></ul></li><li><p>可以在线性时间内，将凸包问题的结果转化为排序问题的结果</p><ul><li>凸包CH(P)就是问题B的解，如何将B的解转化为A的解？注意最左和最右边两点的连线，即图中1和4的连线4→1。除去这条连线之外，其他首尾相接的连线：1→2，2→3和3→4都是“沿着x方向单调的”，遍历这些首尾相连的边（O(n)）就能得到一系列的数值，并且已经是有序的了。这样就将凸包问题的解——凸包CH(P) 转化为了排序问题的解——有序数值序列。</li></ul></li></ul><p>两次转化说明规约是可行的，因此2d-CH问题的下界可由sorting的下界确定。一般而言，排序问题的难度是确定的：<strong>O(nlogn)</strong>。2d-CH问题的下界也就是：<br>$$<br>O(nlogn)<br>$$<br>更高维的凸包问题下界也是如此。</p><p>增量构造法和Jarvis March的O(n^2^)到O(nlogn)之间的鸿沟能否跨越呢？是否存在O(nlogn)复杂度的凸包构造算法？后续文章会有回答。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 凸包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造凸包-Jarvis March(Gift Wrapping)算法</title>
      <link href="/archives/9c7f.html"/>
      <url>/archives/9c7f.html</url>
      
        <content type="html"><![CDATA[<p>回顾凸包构造算法：极点法、极边法和增量构造法，其复杂度分别为O(n^4^)、O(n^3^)和O(n^2^)，效率经过优化已经大大提高了。接下来引入一种新的算法——Jarvis March，其复杂度也是O(n^2^)，但是相较于增量构造在最好情况下效率是较高的。</p><a id="more"></a><h3 id="实现策略"><a href="#实现策略" class="headerlink" title="实现策略"></a>实现策略</h3><p>先想一下为何<a href="http://blog.csdn.net/houszchina/article/details/79253249" target="_blank" rel="noopener">极边法</a>复杂度高达O(n^3^)。实际上我们要对点集中所有边进行遍历，这需要n^2^复杂度，然后对每个边进行鉴别，又需要n复杂度，因此总体复杂度高达O(n^3^)。那么该如何改进呢？这就可以运用选择排序的思想：将下一个要查找的边缩小到一个小范围，而非遍历所有边。</p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20180205163738819-1584005657109.png" alt="选择排序示意"></p><p>选择排序每次选取出的unsorted最大元素放在sorted 部分的首部，<u>也就意味着整个unsorted部分必然不会超过sorted部分</u>。从算法整体框架考虑，每次我们都是维护一个局部解（也就是sorted部分），然后从尚未处理的部分（也就是unsorted部分）找到一个与当前局部解“紧密相关的元素”（相当于选取的最大元素）。这个思想为解决凸包问题带来了新思路。</p></blockquote><p>对算法的大致过程进行描述(标识为：已找到极边数/所有极边数)：</p><ul><li><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200312175230158.png" alt="在加入[partial convex hull]之前找出下一条极边"></p><p>首先从任何一个极点（后面说明如何找到这个点）开始（图中0/5），然后找到一条以这个极点为端点的极边（1/5）。接着沿着极边另一个端点<strong>（endpoint）</strong>出发，再找出下一条极边（2/5）。如此反复操作，<u>最终会找到一条以最初极点为endpoint的极边，得到一个封闭的环，凸包也构造完成</u>。凸包构造过程类似于选择排序中sorted不断向前扩展一样，不断扩展局部解，最后得到问题最终解。</p></li></ul><table><thead><tr><th>凸包构造的问题由此分解为一个个子问题：<u>如何从endpoint出发找到下一条极边</u>。</th></tr></thead><tbody><tr><td></td></tr></tbody></table><h4 id="用to-left-test找到下一条极边"><a href="#用to-left-test找到下一条极边" class="headerlink" title="用to left test找到下一条极边"></a>用to left test找到下一条极边</h4><p>现分析如何从endpoint找到下一条极边。考虑一下的一般情况：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200312175230158.png" alt="image-20200312175230158"></p><p>我们从极点o开始寻找极边，假设当前找到的极边是ik，接下来要做的工作是找到从k出发的另一条极边ks，即找到极点s。</p><p>显然，s来自于其他那些尚未处理的点中，那么s与其他点相比有什么特征？观察发现，ik作为一条极边，它的右侧肯定都是空的，所有其他点都在ik左侧。画出k与其他候选点的有向直线，例如下图中的ks，kt：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200312175450087.png" alt="image-20200312175450087"></p><p>注意图中红色标出的角度，可以看出ks与ik的夹角比kt小，也就是ks比kt相较于ik偏左的角度更小。实际上ks偏左的角度比其他任何从k出发的边都小，<strong>这就是s点的判定依据</strong>。</p><p><strong>这样就找到了从其余点中选择s点的思路</strong>：任选两个点，从k出发过这两点做有向边，看哪个偏左的角度更小就留下，另一点丢弃。然后再拿一点与留下的点比较，反复这个过程，最终留下的就是要找的s点。</p><table><thead><tr><th>问题至此转化为：<u>如何比较两条有向边（例如ks和kt）相较于另一有向直线（例如ik）谁偏左的角度更小。</u></th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>当然可以通过计算三角函数的方法来比较，这是最直观的数学思维。但是这样计算十分复杂，更重要的是引入了误差。<u>这时候又要使用<strong>to left test</strong>这个基础方法来解决问题了</u></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200312175904984.png" alt="image-20200312175904984"></p><p>具体做法就是以在ks和kt中以任意个为基准（如以ks为基准），对另一点（如t）做to left test。上图点t和有向边ks的to left test结果为true，t在ks左边，因此ks偏左的角度更小，舍弃点t。</p><blockquote><p>类比选择排序来理解:</p><ul><li><u>已得到的极边</u>（从极点o开始到ik的首尾相连的极边）——相当于 sorted部分</li><li><u>其余点</u>——相当于 unsorted部分</li><li><u>找到点s</u>（能构成最小偏角的点）——相当于 从unsorted部分取出极大值</li></ul><p>选择排序中的选择过程需要比较元素大小，就要由一种<strong>比较器</strong>完成，<u>而上述比较偏角的过程也可以抽象为一种比较器的操作</u>。构造凸包的算法框架与选择排序相同，<u>只是比较器替换为to left test而已</u>。</p></blockquote><p><em>此处只是考虑一般情况，一些特殊细节未进行处理。例如在st上有s和s’两点，这两点的取舍问题未考虑。当然为了理解算法整体框架忽略特殊情况是很必要的。</em></p><h4 id="确定第一个极点"><a href="#确定第一个极点" class="headerlink" title="确定第一个极点"></a>确定第一个极点</h4><p><strong>一个细节</strong>：上文一开始提到的算法的最开始的<strong>第一个极点</strong>如何确定？</p><p>任何一个极点都可以使用，我们没必要去计算出哪个点是极点。可以选取y坐标最小的点，也就是最低点，在没有退化的情况下，这个点一定是一个极点。如果情况退化，有多个最低点（如例图中所示），我们就去选x坐标最小的那个点，也就是最左边的点即可。这种方法选出的点称为<strong>lowest-then-leftmost point（LTL）</strong>。<u>注意选取的规则的先后顺序，先选lowest，若点不唯一再选leftmost。</u></p><h3 id="Jarvis-March"><a href="#Jarvis-March" class="headerlink" title="Jarvis March"></a>Jarvis March</h3><p>类比选择排序的过程，我们得到的凸包构造算法就是<strong>Jarvis March算法</strong>，又称<strong><a href="https://en.wikipedia.org/wiki/Gift_wrapping_algorithm" target="_blank" rel="noopener">gift wrapping算法</a></strong>（算法过程如包装礼物一样）。接下来看算法具体实现方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ToLeft</span><span class="params">(Point P, Point q, Point s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> area2 = p.x*q.y - p.y*q.x + q.x*s.y -q.y*s.x + s.x*p.y - s.y*p.x;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> area2 &gt;<span class="number">0</span> ; <span class="comment">//左侧为真</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LTL</span> <span class="params">(Point S[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ltl = <span class="number">0</span>; <span class="comment">//the lowest-then-leftmost point</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;n;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S[k].y &lt; S[ltl].y || (S[k].y==S[ltl].y &amp;&amp; S[k].x&lt;S[ltl].x))</span><br><span class="line">            ltl =k;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> ltl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Javis</span><span class="params">(Point S[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; k++)</span><br><span class="line">    S[k].extreme =FALSE; <span class="comment">//首先将所有点标记为非极点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ltl=LTL(S, n); <span class="comment">//找到LTL</span></span><br><span class="line">    <span class="keyword">int</span> k=ltl;  <span class="comment">//将LTL作为第一个极点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">    S[k].extrem = <span class="literal">true</span>; <span class="keyword">int</span> s =<span class="number">-1</span>; <span class="comment">//s是要找的下一个极点，用t去循环找</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t=<span class="number">0</span>; t&lt;n; t++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(t != k &amp;&amp;t != s &amp;&amp; ( s == <span class="number">-1</span> || !ToLeft(S[K],S[s],S[t]) ) )</span><br><span class="line">                s = t; <span class="comment">//如果t在pq的右侧，则更新s</span></span><br><span class="line">        &#125;</span><br><span class="line">        S[k].succ = s; k = s; <span class="comment">//新的极边pq确定   </span></span><br><span class="line">        k = s; <span class="comment">//更新k的值，变为下一次查找的起点</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(ltl != k) <span class="comment">//如果循环回到了原来的点，则结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h3><ol><li>首先，初始化将所有点都设为：非极点</li><li>然后，开始找到<u>第一个极点</u>（用LTL方法），找到之后赋值给k</li><li>接下来，开始找<u>下一个极点</u>s：<ul><li>主要用<code>ToLeft Test</code>来找出下一个极点</li></ul></li><li>循环第3步骤，直到找到所有极点</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>最后分析Jarvis March算法相较于增量构造法的优势。二者都是O(n^2^)的复杂度，Jarvis March算法的优势在于其的“<strong>输出敏感性（output sensitive）</strong>”。考虑点集S，共有n个点，来构造S上的凸包。</p><p>何为“<u>输出敏感性</u>”？Jarvis March算法每次新加入一条边都会耗费n的复杂度，但是构造过程一共会加入的边数往往比n少。如下图（设n = 7）：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20180206002208800.png" alt="img"></p><p>在非退化为共线的前提下，最好情况为只加入3条边（复杂度为O(3n)），最坏情况为所有点都是极点，加入n-1条边（复杂度为O(n^2^)）。实际情况中最坏情况出现的几率很小，我们引入一个指标h来衡量凸包的极边数（the size of convex hull）：<br>$$<br>h = |CH(S)|<br>$$<br>Jarvis March算法算法的复杂度<strong>更准确的表示为O(nh)。</strong>h又由最终输出结果，即凸包本身来决定，输出结果决定了构造过程的复杂度，这就是所谓的“输出敏感性”。这种类型的算法又被称为output sensitive algorithm。这种特性在其它凸包算法中也会体现。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 凸包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Convex Hull(凸包)</title>
      <link href="/archives/510d.html"/>
      <url>/archives/510d.html</url>
      
        <content type="html"><![CDATA[<p>这山之高，就叫凸碧；山之低洼近水处，就叫作凹晶。这凸、凹二字，历来用的人最少，如今直用做轩馆之名，更觉新鲜，不落窠臼。</p><a id="more"></a><h1 id="欧拉公式"><a href="#欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式</h1><p>简单介绍一下欧拉公式：</p><p>虚数中：i^2^=-1 ; i=√(-1)</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/1573819506389.png" alt="1573819506389"></p><p>其中θ为实数，i表示虚数中的虚数单位 i；</p><p>欧拉恒等式：</p><p>当θ=π时；</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/1573820164006.png" alt="1573820164006"></p><p>几何学中的欧拉公式：</p><p><code>V-E+F=2</code> 【v：几何体的顶点数；E：边数；F：面数】</p><h1 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h1><p><strong>凸包</strong>：比如，我们有很多很多钉子钉在木板上面，然后用一个皮筋将这些钉子包围起来，当我们松手后，皮筋就把这些定在全都包围起来。此时，这个皮筋所形成的凸多边形就叫<strong>凸包</strong>。如下图的蓝色的多边形就是凸包。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200304214005104.png" alt="绿色线圈记为凸包"></p><h2 id="凸性-Convexity"><a href="#凸性-Convexity" class="headerlink" title="凸性(Convexity)"></a>凸性(Convexity)</h2><p>下图中，假设x,y,z是三种颜色，如果仅以x,y就能调出来的颜色，那么如u所示它一定会落在x,y中；若需要x,y,z三种 一起，那么如v所示会落在以x,y,z三点连成的三角形内部。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/v2-386fd3aaf073885dd32ab6241e9a0452_720w.jpg" alt="凸性"></p><h2 id="极点-Extreme-Point"><a href="#极点-Extreme-Point" class="headerlink" title="极点(Extreme Point)"></a>极点(Extreme Point)</h2><p>有一个点集S。如果存在通过点P的直线L，使得点集S中除了点P之外的其他的点都在这个直线的同一侧，则这个点P就是<strong>极点(Extreme Points)</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200304214843584.png" alt="极点"></p><ul><li><p><strong>判断一个点是否为极点</strong>：该点P是否会被包含在其他点中任意三个点形成的三角形中，如果点P不在任何三角形内部，则说明点P是极点。反之，则不是极点。如下图：</p><p>下图中，S就不是极点，因为他在三角形内部。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200304220601816.png" alt="判断极点"></p><h2 id="判断极点的算法"><a href="#判断极点的算法" class="headerlink" title="判断极点的算法"></a>判断极点的算法</h2><h3 id="In-Trangle-Test"><a href="#In-Trangle-Test" class="headerlink" title="In-Trangle Test"></a>In-Trangle Test</h3><p><strong>算法描述伪代码</strong>：其实这个算法就是判断点是否在三角形内部。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200304221051234.png" alt="In-Trangle Test"></p><p><strong>代码实现：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200304221130677.png" alt="算法实现"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extremePoint</span> <span class="params">(<span class="built_in">point</span> S[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>; s&lt;n; s++)</span><br><span class="line">        S[s].extreme = TRUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>; p&lt;n; p++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> q=p+<span class="number">1</span>; q&lt;n; q++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> r=q+<span class="number">1</span>; r&lt;n; r++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>; s&lt;n; s++)</span><br><span class="line">                &#123;</span><br><span class="line"><span class="keyword">if</span>(s==p || s==q || s==r ||!S[s].extreme)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(Intriangle(S[p],S[q],S[r],S[s]))</span><br><span class="line">                        S[s].extreme = FALSE;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可知，该算法的时间复杂度为O(n^4^)，其实挺大的，在后面我们会进一步改善。</p><p>这样基于极点的凸包算法虽然效率不高，但是它会引出一个非常重要的操作我们称之为<strong>To-Left Test</strong><br>在后面我们可以看到这个测试几乎是贯穿于我们计算几何这个课程的始终的。如果说我们刚才所给出的那个算法还有什么需要补充的话其实最重要的也就是那样的一个细节也就是所谓的<strong>In-Triangle test</strong>。</p><h4 id="To-Left-Test"><a href="#To-Left-Test" class="headerlink" title="To-Left Test"></a>To-Left Test</h4><p>我们将刚才这个In-Triangle Test转化为三次To-Left测试也就是说一个点如果确实落在某一个三角形的内部的话那么相对于这个三角形的三条边所做的这个To-Left测试都会统一的返回true或者统一地返回false。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200304223141504.png" alt="To-Left Test"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InTriangle</span><span class="params">(Point p, Point q, Point r, Point s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> pqLeft = ToLeft(p, q, s);</span><br><span class="line">    <span class="keyword">bool</span> qrLeft = ToLeft(q, r, s);</span><br><span class="line">    <span class="keyword">bool</span> rpLeft = ToLeft(r, p, s);</span><br><span class="line">    <span class="keyword">return</span> (pdLeft == qrLeft) &amp;&amp; (qrLeft == rqLeft);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>To-Left测试是相对于另外这两个点所确定的那条<strong>有向</strong>直线而言的，任何一条有向直线不仅会把平面分成两部分，我们还可以知道哪一边是左边，哪一边是右边。To-Left，其实就是说这个点相对于刚才的那条有向线而言到底是位于它的左侧，还是右侧。如果是前者就是true，否则的话就是false。因为三角形有三条边，所以我们要用三次To-Left Test。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200304223826387.png" alt="INT=3*TLT"></p><p><strong>To-Left Test具体实现</strong>：</p><p>这里用到了行列式来求三角形面积（至于原理，这里就不多说了）。下图中的这个行列式实际上算的首先是它的面积的<strong>两倍</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200304224456126.png" alt="To-Left Test"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ToLeft</span><span class="params">(Point p, Point q, Point s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Area2(p, q, s) &gt; <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Area2</span><span class="params">(Point p, Point q, Point s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">        p.x * q.y - p.y * q.x </span><br><span class="line">       +q.x * s.y - q.y * s.x</span><br><span class="line">       +s.x * p.y - s.y *p.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：这里的面积其实是“有向面积”，也就是说这里的面积分正负（相对于这样一个逆时针的<br>一个编号pqs的这样的一个面积 与 s在右侧也就是按照顺时针的pqs所构成的面积虽然有可能大小是一样完全对称但是它们的符号是相反的）。整个这个To-Left的测试的<strong>判断的依据也就在于这个符号</strong>。</p><p>这个行列式取正条件为：当且仅当s位于pq所确定的这条有向直线的左侧。其中转换成代码也是非常简明的，代码如上图所示。</p><p>至此，To-Left Test实现完成。</p><h2 id="极边-Extreme-Edge"><a href="#极边-Extreme-Edge" class="headerlink" title="极边(Extreme Edge)"></a>极边(Extreme Edge)</h2><p><strong>极边</strong>：两个极点连成的边，剩余的所有点均会在该边的一侧。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/v2-534df0cc332ead89da7586c99c22dd5f_720w.jpg" alt="极边"></p><p><strong>判断是否为极边</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200308231616965.png" alt="image-20200308231616965"></p><ul><li><strong>代码实现</strong>：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200308231916308.png" alt="markEE"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">markEE</span><span class="params">(<span class="built_in">point</span> S[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; k++)</span><br><span class="line">        S[k].extreme = FALSE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p=<span class="number">0</span>; p&lt;n; p++) <span class="comment">//test</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> q=p+<span class="number">1</span>; q&lt;n; q++) <span class="comment">//检验每一条边</span></span><br><span class="line">            checkEdge(S,n,p,q) <span class="comment">//有向边pq</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200308231932585.png" alt="checkEdge"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkEdge</span><span class="params">(Point S[], <span class="keyword">int</span> n, <span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> LEmpty =TRUE, REmpty =TRUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n &amp;&amp; (LEmpty || REmpty); k++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k != p &amp;&amp; k != q)</span><br><span class="line">            ToLeft(S[p], S[q], S[k]) ? LEmpty=FALSE : REmpty=FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(LEmpty || REmpty)</span><br><span class="line">        S[p].extreme=S[q].extreme=TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现的步骤：</p><ol><li><p>初始时，先假设所有的点都不是极点。</p></li><li><p>开始遍点集S中的点，它们两两组合成一个线段，然后进行checkEdge(检查这些线段是否是极边)。</p><p>检查的方法<code>checkEdge</code>：</p><p>利用ToLeft测试，每次都将当前的线段与其他点（即，除了这两个点之外的点）进行ToLeft测试<strong>，如果测试结果中：LEmpty、REmpty 其中之一为true，就表明这两个点构成的线段为*极边*，而且同时也检测出这两个点是*极点*。</strong>（其实两个点组成的线段进行<code>checkEdge</code>的结果中的LEmpty、REmpty最多只有一个是true,因为这里不存在一条边的两侧都没有其他点的情况）</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">markEE</span><span class="params">(Point S[], <span class="keyword">int</span> n)</span> <span class="comment">//n&gt;2</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;n; k ++)</span><br><span class="line">        S[k].extreme = False; <span class="comment">//先假设所有的点都不是极点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; n; p ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> q = p + <span class="number">1</span>; q &lt; n; q ++)</span><br><span class="line">            checkEdge(S, n, p, q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkEdge</span><span class="params">(Point S[], <span class="keyword">int</span> n, <span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//LEmpty、REmpty表示改边的左侧、右侧，等于True时表示该侧是没有点的。</span></span><br><span class="line">    <span class="keyword">bool</span> LEmpty = True, REmpty = True;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n &amp;&amp; (LEmpty || REmpty); k ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k != p &amp;&amp; k != q)</span><br><span class="line">        &#123;</span><br><span class="line">            ToLeft(S[p], S[q], S[k]) ? LEmpty = False : REmpty = False;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(LEmpty || REmpty)</span><br><span class="line">        S[p].extreme = S[q].extreme = True;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样可利用此来判断是否是极点（复杂度为O(n^3)）。</p><h1 id="补：根据极角排序"><a href="#补：根据极角排序" class="headerlink" title="补：根据极角排序"></a>补：根据极角排序</h1><p><strong>定义：</strong></p><p>我们平常所使用的坐标系都是直角坐标系，而极角排序是在极坐标系下进行的。<br>这里首先要选取一个点，然后其它点根据与参考点的连线与x轴所成的夹角的大小进行排序的。<br>这里我们可以简单理解为绕着一个点逆时针转圈访问。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/1-1584641857659.png" alt="极角排序"></p><p><strong>代码：</strong></p><p>在讲具体实现方法之前，先给出用到的函数和结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>//存储点</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cross</span><span class="params">(<span class="keyword">double</span> x1,<span class="keyword">double</span> y1,<span class="keyword">double</span> x2,<span class="keyword">double</span> y2)</span>　<span class="comment">//计算叉积</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x1*y2-x2*y1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">compare</span><span class="params">(<span class="built_in">point</span> a,<span class="built_in">point</span> b,<span class="built_in">point</span> c)</span><span class="comment">//计算极角</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cross((b.x-a.x),(b.y-a.y),(c.x-a.x),(c.y-a.y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>利用叉积的正负来排序</p><blockquote><p>　关于叉积：叉积=0是指两向量平行（重合）；叉积&gt;0，则向量a在向量b的顺时针方向（粗略的理解为在a在b的下方）；叉积&lt;0，则向量a在向量b的逆时针方向（粗略的理解为在a在b的上方）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">point</span> a,<span class="built_in">point</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">point</span> c;<span class="comment">//原点</span></span><br><span class="line">    c.x = <span class="number">0</span>;</span><br><span class="line">    c.y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(compare(c,a,b)==<span class="number">0</span>)<span class="comment">//计算叉积，函数在上面有介绍，如果叉积相等，按照X从小到大排序</span></span><br><span class="line">        <span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> compare(c,a,b)&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用 complex 的内建函数，算出极角大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x real()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y imag()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Point&amp; p1, <span class="keyword">const</span> Point&amp; p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg(p1) &lt; arg(p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用 arctan 计算极角大小。注意角的大小范围是(-180°, +180°]。弧度表示。这里用 arctan2 函数应该是为了提高精度。</p><blockquote><p>关于atan2()函数：在C语言的math.h或C++中的cmath中有两个求反正切的函数atan(double x)与atan2(double y,double x) 他们返回的值是弧度要转化为角度再自己处理下。</p><p>前者接受的是一个正切值（直线的斜率）得到夹角，但是由于正切的规律性本可以有两个角度的但它却只返回一个，因为atan的值域是从-90°~90° 也就是它只处理一四象限，所以一般不用它。</p><p><strong>推荐这个</strong>：第二个atan2(double y,double x) 其中y代表已知点的Y坐标，同理x ,返回值是此点与远点连线与x轴正方向的夹角，这样它就可以处理四个象限的任意情况了，它的值域相应的也就是-180~180了</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">const</span> Point&amp; p1, <span class="keyword">const</span> Point&amp; p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">atan2</span>(p1.y, p1.x) &lt; <span class="built_in">atan2</span>(p2.y, p2.x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>先判断象限，再用外积判断顺序，最后根据长度排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Quadrant</span><span class="params">(<span class="built_in">point</span> a)</span>　　<span class="comment">//象限排序，注意包含四个坐标轴</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x&gt;<span class="number">0</span>&amp;&amp;a.y&gt;=<span class="number">0</span>)  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a.x&lt;=<span class="number">0</span>&amp;&amp;a.y&gt;<span class="number">0</span>)  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a.x&lt;<span class="number">0</span>&amp;&amp;a.y&lt;=<span class="number">0</span>)  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(a.x&gt;=<span class="number">0</span>&amp;&amp;a.y&lt;<span class="number">0</span>)  <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp3</span><span class="params">(<span class="built_in">point</span> a,<span class="built_in">point</span> b)</span>  <span class="comment">//先按象限从小到大排序 再按极角从小到大排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Quadrant(a)==Quadrant(b))<span class="comment">//返回值就是象限</span></span><br><span class="line">        <span class="keyword">return</span> cmp1(a,b);</span><br><span class="line">    <span class="keyword">else</span> Quadrant(a)&lt;Quadrant(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="向量的点乘与叉乘的几何意义"><a href="#向量的点乘与叉乘的几何意义" class="headerlink" title="向量的点乘与叉乘的几何意义"></a>向量的点乘与叉乘的几何意义</h2><p>向量的<strong>点乘（内积）</strong>：</p><p>$$<br>\vec{a} \cdot \vec{b}=|\vec{a}| \cdot |\vec{b}|\cdot cos\theta<br>$$<br>点乘的几何意义是可以用来表征或计算两个向量之间的夹角，以及在b向量在a向量方向上的投影</p><p>向量的<strong>叉乘（外积）</strong>：<br>$$<br>\vec{a} \times \vec{b}=|\vec{a}| \cdot |\vec{b}|\cdot sin\theta<br>$$<br>向量积被定义为：</p><ul><li><p>模长：（在这里θ表示两向量之间的夹角(共起点的前提下)（0° ≤ θ ≤ 180°），它位于这两个矢量所定义的平面上。）</p></li><li><p>方向：a向量与b向量的向量积的方向与这两个向量所在平面垂直，且遵守右手定则。（一个简单的确定满足“右手定则”的结果向量的方向的方法是这样的：若坐标系是满足右手定则的，当右手的四指从a以不超过180度的转角转向b时，竖起的大拇指指向是c的方向。<strong>c</strong> = <strong>a</strong> ∧ <strong>b</strong>）</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/afa5c98582b08ef4bac175d7bb5c9bda80adcaab.png@968w_1346h.webp" alt="叉乘"></p><p>特别的，在二维中，两个向量的向量积的模的绝对值等于由这两天向量组成的平行四边形的面积。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/62a0493b8bb7f29f2655190b718be3d029e6750e.png@960w_750h.webp" alt="向量积"></p><p>向量的叉乘，即求同时垂直两个向量的向量，即c垂直于a，同时c垂直于b（a与c的夹角为90°，b与c的夹角为90°）</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><strong>极角排序</strong>：<a href="https://sumygg.com/2013/07/30/Sorting-Points-by-Polar-Angle/" target="_blank" rel="noopener">https://sumygg.com/2013/07/30/Sorting-Points-by-Polar-Angle/</a></p><p><strong>关于极角排序：</strong><a href="https://www.cnblogs.com/aiguona/p/7248311.html" target="_blank" rel="noopener">https://www.cnblogs.com/aiguona/p/7248311.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 凸包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造凸包-增量构造法</title>
      <link href="/archives/7c53.html"/>
      <url>/archives/7c53.html</url>
      
        <content type="html"><![CDATA[<p>在引入新算法之前首先来回顾一下经典的算法思想：减治（decrease and conquer），注意不是分治（divided and conquer），二者<a href="https://www.geeksforgeeks.org/decrease-and-conquer/" target="_blank" rel="noopener">稍有区别</a>。简单来讲就是将问题划分为一个个简单的小问题，减而治之，逐个求解，最终就能得到整个问题的解。</p><p>减治法的经典例子就是插入排序（insertion sort）。插入排序的过程可以归结成下图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200315172527.png" alt="img"></p><p>排序的过程中将序列分为两部分：已排序部分（sorted）和未排序部分（unsorted）。每次排序都是从unsorted中拿出一个元素，通过一次<strong>顺序查找</strong>过程在sorted部分中找到位置并插入其中。</p><p>整个插入排序的过程就是逐个元素的去“蚕食”unsorted部分的过程，连续的进行这个操作就会将整个问题解决。这种将大问题分解成小问题的减治过程，又被看成一种递增的、增量式的策略（incremental strategy）。这种思想为解决凸包问题提供了新的思路：从逐个插入新点的角度构造凸包。</p><p>典型流程如下图（标识为：极点/整体规模）：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200311222412367.png" alt="image-20200311222412367"></p><p>插入新的点可能的情况有：</p><blockquote><ul><li>新点对凸包有“贡献”，例如5/5→6/6，6/6→7/7；</li><li>新点也有可能没有“贡献”，例如7/7→7/8；</li><li>还有可能使原先有“贡献”的点失效，极点数量减少，例如7/8→6/9。<br>那么如何对不同情况进行处理呢？</li></ul></blockquote><h3 id="确定新点与现有凸包的关系-in-convex-polygon-test"><a href="#确定新点与现有凸包的关系-in-convex-polygon-test" class="headerlink" title="确定新点与现有凸包的关系~in-convex-polygon test"></a>确定新点与现有凸包的关系~in-convex-polygon test</h3><p>构造过程的核心算法应该是：<strong>判定待定点是否位于某多边形内部（in-convex-polygon test）</strong>。再看上图流程，实际上每步的核心就是判断点位于多边形内部还是外部，若落在外部，则新插入的点就是下一个极点，否则舍弃。</p><p>考虑基本情况，给定一个点和一个多边形，如何高效判断该点与多边形的位置关系呢？</p><ul><li><p>一种思路是：我们可以先对多边形进行一个“<strong>预处理</strong>”，给每个点按序编号，类比<strong>有序向量二分查找</strong>的思想，来逐步缩小规模。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/v2-3e18e3822557820d852899d5c503f62a_720w.jpg" alt="img"></p><p>首先任选一点为基准点（蓝色点），然后用二分法选取其余点的“中点“（预处理已经为所有点排了序），然后判断基准点到终点的有向直线与待定点的位置关系<strong>（to-left test）</strong>。然后可将搜索范围减半，反复上述过程，直到最后退化为平凡情况：三角形与点的位置关系<strong>（in-triangle test）</strong>。</p></li></ul><p>分析一下算法的整体复杂度：整个算法共log(n)步，每步的to-left test或in-triangle test都为常数成本，则整体复杂度为log(n)。至此，我们似乎得到了一个log(n)的“高效”算法，但是这种方法真的可行吗？</p><blockquote><p>注意，每步都会将原凸包规模减半，也就是说凸包是<strong>动态的</strong>，随时可能变化。这种方法和极点法或极边法中静态查找的情况是完全不同的。</p><p>类比插入排序的过程来解释这个问题。为何插入排序的复杂度是n^2^而非nlog(n)？每次插入时，既然sorted部分已经有序，为何不使用二分查找来取代顺序查找（复杂度由n变为log(n)）？这不得不考虑sorted部分的动态性，每次插入后它的结构都会改变，而二分查找必须在静态结构中实现。当然可以使用std::vector这类支持按秩访问（call by rank）的数据结构，但是插入时维护vector的成本依旧是线性复杂度。因此插入排序的总体复杂度是n^2^。要处理的凸包与插入排序中sorted部分本质是一样的，它们都不是静态不变的结构，而要随着算法执行而不断变化。若要每次在log(n)成本下完成待定点的in-convex-polygon test，必须将凸包存储为类似vector的数据结构，但是每次向这种数据结构插入新点的成本依旧是线性的。因此对凸包进行的所谓“预处理”是没有意义的，这种减治策略算法复杂度最低应该为O(n^2^)。</p></blockquote><p>到现在问题依旧没有解决，究竟如何用这种增量式的策略来构造凸包？其实复杂问题中最朴素、最基本的方法反而是最有效的。</p><p>in-convex-polygon test最基本的方法是什么？就是按一定方向（约定为逆时针）凸包的每条边和待定点做<strong>to-left test</strong>，一旦有一次test为false就能断定点在凸包外面。这实际上就是将in-triangle test推广多边形的情况。因此每次in-convex-polygon test的成本就会变成当前凸包的规模，也就是n。对于每个新点做一次in-convex-polygon test，构造算法的整体复杂度就是O(n^2^)。算法的复杂度从极边法的O(n^3^)又下降了一个数量级。</p><p><strong>其实增量算法的整个思路可以分成两块：</strong></p><ul><li><strong>1、如何判断凸包与新点的位置关系（in-convex-polygon test）</strong></li><li><strong>2、如何向凸包插入新点</strong></li></ul><p>上面的方法已经解决了第一个问题。第二个问题看下面部分：</p><h3 id="如何向凸包插入新点-support-line"><a href="#如何向凸包插入新点-support-line" class="headerlink" title="如何向凸包插入新点~support-line"></a>如何向凸包插入新点~support-line</h3><p>现在来讨论如何向凸包插入新点：</p><p>比如下面这个点，应该如何插入凸包之中呢？</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200311230823679.png" alt="新点准备插入现有凸包"></p><p><strong>插入过程</strong>：将新点x插入原凸包的过程，本质上就是寻找两个连接点s和t，将x和t、s分别连接得到新的凸包。注意t和s两点将整个原凸包边界分为两部分：st和ts两个有向段。构造新凸包就要保留远端st、舍弃近端ts。取代近端ts的两条线就是x和t的连线xt和xs，被称为<strong>切线（tangent）</strong>或者<strong>support line（支撑线）</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/v2-8afbf4ebfa808eec9ffff8c111ae6465_720w.jpg" alt="img"></p><p><strong>那如何查找t、s这两个点呢？</strong></p><blockquote><p>我们在凸包上任取一点v，按<u>逆时针</u>方向v点会有一个直接前驱点和直接后继点。考察有向直线xv与点v直接前驱和直接后继的位置关系（两次to left test），记录为一个<strong>pattern表</strong>。</p><p>结果无非是四种情况：v的直接前驱和直接后继相对于有向直线xv的位置是RL，LR，LL，RR。例如上图黄色点v，是R和L；蓝色点v分别是L和R。实际上凸包边界st上所有点的pattern都为RL，ts上所有点的pattern都为LR。关键点在于：点S的pattern是LL，点t的pattern为RR。</p></blockquote><p>因此对凸包边界每个点做<strong>两次to left test</strong>，判断其pattern就可找出s和t，花费时间成本为常数。</p><h3 id="incremental-construction"><a href="#incremental-construction" class="headerlink" title="incremental construction"></a>incremental construction</h3><p>再来回顾整个凸包构造算法的两大问题：in-convex-polygon test和插入新点。分开考虑只是为了将思路简化，实际上这两个问题可以套用一个算法，同时来解决。</p><p>具体做法就是：对于每个待定点x，<u>不必特意去考虑它与凸包的位置关系</u>，<u>而是遍历凸包上每一个点</u>。</p><blockquote><p>对于凸包<strong>边界</strong>上的每一个点，我们都能通过两次to left test迅速判断出pattern。</p><p>对于x位于凸包<strong>外部</strong>的情况，经过遍历凸包的点，我们很容易就能得到s和t的位置，得到两条support line，从而构造出新的凸包；</p><p>而对于x位于凸包<strong>内部</strong>的情况，凸包边界每个点都不可能出现RR或LL的情况，直接舍弃x即可。</p></blockquote><p>每次遍历凸包边界点的复杂度为O(n)，整个构造过程要增量式的逐点考察，自然得到了一个<strong>O(n^2^)</strong>的incremental construction算法。</p><p>这就是所谓增量构造法来构造凸包的过程。构造过程巧妙的避开了特殊处理诸如5/5→6/6、7/7→7/8、7/8→6/9等复杂情况，采用一致的思路逐个考察“新点”，最终完成凸包的构造。</p><h3 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h3><p>待写……..</p><h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p><strong>其实增量算法的整个思路可以分成两块：</strong></p><ul><li><strong>1、如何判断凸包与新点的位置关系（in-convex-polygon test）</strong></li><li><strong>2、如何向凸包插入新点</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 凸包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let’s Build A Simple Interpreter 7</title>
      <link href="/archives/5a757a52.html"/>
      <url>/archives/5a757a52.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原文链接：<a href="https://ruslanspivak.com/lsbasi-part7/" target="_blank" rel="noopener">https://ruslanspivak.com/lsbasi-part7/</a></p><p>之前的那几小结，我们都是把interpreter的代码和parser的代码混在一起，而且interpreter在parser识别出一个如加减乘除之类 的特定的语言结构(language construct)后，就会立刻对它进行求值。这种 interpreter 被称为 <strong>语法导向解释器</strong>(syntax-directed interpreter)。</p><blockquote><p>他们通常在输 入上做一个 pass 且只适合基础的语言应用。</p></blockquote><p>为了分析更复杂的编程语言 Pascal 的结构， 我们需要建立一个 <strong>中间表示</strong> (intermediate representation, <strong>IR)</strong>。</p><blockquote><p>parser 会 负责构建 IR</p><p>interpreter 会用来解释由 IR 所代表的输入。</p></blockquote><p>事实证明树是一个表示 IR 非常合适的数据结构。关于数的一些术语terminology：</p><ul><li>树是一个包含一个或多个结点组成的层次数据结构。</li><li>树有一个<strong>根结点</strong>，就是顶部结点。</li><li>除根结点外的所有结点有唯一 一个<strong>父结点</strong>。</li><li>下图中结点为*的是一个父结点。结点为 2 和 7 的是它的子结点；子结点从左到右排序。</li><li>没有子结点的结点称为<strong>叶子结点</strong>。</li><li>有一个或多个子结点的非根结点被称为<strong>中间结点</strong>。</li><li>子结点也可以是完全子树。下图中结点＋的左子树（结点为*）就是一个有自己子结点的 完全子树。</li><li>在计算机科学中我们把树倒过来画，根结点在最上边，分枝向下生长。</li></ul><p>下面是表达式 2 * 7 + 3 的带有解释的树形表示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_tree_terminology.png" alt="lsbasi_part7_tree_terminology"></p><p>本系列中我们会用到的 IR 被称为 <strong>抽象语法树</strong> (abstract-syntax tree, AST)。但在深 入了解 AST 之前让我们简单聊聊 <strong>解析树</strong> (parse tree)。</p><blockquote><p>尽管我们不会在解释器和编译 器中用到解析树，但它会通过可视化 parser 执行轨迹的方法，加深你对 parser 如何解释 输入的理解。我们也会将它和 AST 做比较，来表明为什么 AST 比解析树更适合用来做 IR。</p></blockquote><p>那么，什么是解析树呢？</p><ul><li>解析树（有时叫做 <strong>具体语法树<em>concrete syntax tree</em></strong> ）是一个根据我们的语法定义来 表示一门语言的句法结构的树形结构。它基本上展示了你的 parser 如何识别语言结构或者， 换句话说，它展示了你语法的开始符号怎么派生出该编程语言中一个特定的字符串的。</li></ul><p>parser 的调用栈隐式地代表了一个解析树，且当parser 在试图识别一个特定的语言结构时，解析树 就会自动地在内存中构建出来。下面是表达式 2 * 7 + 3 的解析树：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_parsetree_01.png" alt="lsbasi_part7_parsetree_01"></p><blockquote><p>在上面的图片中可以看到：</p><ul><li>解析树记录了 parser 用来识别输入的一系列规则。</li><li>解析树的根结点的标签是语法的开始符号(start symbol)。</li><li>每个中间结点表示一个非终结符(non-terminal)，代表应用了一条语法规则，像我们的情况里的 <code>expr</code>, <code>term</code>和 <code>factor</code>.</li><li>每个叶子结点代表了一个 token.</li></ul></blockquote><blockquote><p>我们不会手动构建解析树且在我们的解释器中用到它，但解析树可以通过可视化 调用过程帮助我们理解 parser 怎么解释输入。</p><p>你可以使用一个名为 <a href="https://github.com/rspivak/lsbasi/blob/master/part7/python/genptdot.py" target="_blank" rel="noopener">genptdot.py</a> 的小应用（我很快写完用来帮助你的），来查看不同的 算术表达式看起来什么样。要使用这个应用你首先需要安装 <a href="http://graphviz.org/" target="_blank" rel="noopener">Graphviz</a>包，然后运行下面的 命令，你可以打开生成的图片文件 parsetree.png 查看你从命令行传入的表达式的解析树：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python genptdot.py <span class="string">"14 + 2 * 3 - 6 / 2"</span> &gt; \</span><br><span class="line">  parsetree.dot &amp;&amp; dot -Tpng -o parsetree.png parsetree.dot</span><br></pre></td></tr></table></figure><p>下面是由表达式 14 + 2 * 3 - 6 / 2 生成的图片 parsetree.png:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_genptdot_01.png" alt="lsbasi_part7_genptdot_01"></p></blockquote><h2 id="parser"><a href="#parser" class="headerlink" title="parser"></a>parser</h2><h3 id="抽象语法树-AST"><a href="#抽象语法树-AST" class="headerlink" title="抽象语法树(AST)"></a>抽象语法树(AST)</h3><p>现在我们来聊聊<strong>抽象语法树(AST)</strong>。它是在余下的文章中会大量用到的中间表示(IR)。它是我们的解释器和未来编译器项目的核心数据结构。</p><p>让我们以把表达式 2 * 7 + 3 的 AST 和解析树放在一起看来开始我们的讨论：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_ast_01.png" alt="lsbasi_part7_ast_01"></p><p>从上面的图片中可以看出，AST抓住了输入的精髓且更小。</p><p><strong>AST 和解析树最主要的区别有</strong>：</p><blockquote><ul><li>AST 使用操作符/操作(operators/operations )作为根结点，操作数(operands)作为它们的子结点。</li><li>不像解析树，AST <strong>不</strong>使用中间结点来表示语法规则。</li><li>AST 并不把真实句法中的所有结节都表示出来（这就是为什么它是抽象的）──例如，没有 规则结点和括号。</li><li>对于相同的语言结构来说，AST 相比于解析树更紧凑。</li></ul></blockquote><p><strong>抽象语法树是什么</strong>？</p><blockquote><p>抽象语法树(AST)是表示一个语言结构的抽象句法结构的树形表示，它的中间结点和根结点代表了一个操作符，子结点代表了该操作符的操作数。</p></blockquote><p>看一下AST与解析树对比，显现他的紧凑性：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_ast_02.png" alt="lsbasi_part7_ast_02"></p><p><strong>如何将操作符的优先级(precedence)编码进 AST 呢？</strong></p><blockquote><p>为了把操作符优先级编码进 AST，即，为了表示“X 在 Y 之前发生”你只需要在树中把 X 放在低于 Y 的位置。你在前面 的图片中已经见过到了。</p><ul><li>【例子】：在下面的图片中，左边是表达式 2 * 7 + 3 的 AST。让我们用括号把 7 + 3 围起来以改变 它的优先级。在右边是修改后的表达式 2 * (7 + 3) 的 AST：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_astprecedence_01.png" alt="lsbasi_part7_astprecedence_01"></p></blockquote><h4 id="代码实现AST"><a href="#代码实现AST" class="headerlink" title="代码实现AST"></a>代码实现AST</h4><p>好了，让我们写些代码来实现不同的 AST 结点类 并修改我们的 parser 来生成包含这些结点的 AST 树：</p><ul><li><p>首先，新建一个基本结点类叫做 AST，其他类会从它继承：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AST</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span> <span class="comment">#pass 不做任何事情，一般用做占位语句。因为如果定义一个空函数程序会报错，当你没有想好函数的内容是可以用 pass 填充，使程序可以正常运行。</span></span><br></pre></td></tr></table></figure></li><li><p>回忆一下 AST 表示了<strong>操作符-操作数</strong>模型。到现在为止，我们有4个操作符和整型操作数。操作符有加、减、乘、除。我们原本可以新建单独的类来表示每个操作符如 AddNode, SubNode, MulNode 和 DivNode，相反我们只会新建一个 BinOp 类来表示所有 4 个<strong>二元操作符*binary operator*</strong> （二元操作符就是作用在两个操作数的操作符）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinOp</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, left, op, right)</span>:</span></span><br><span class="line">    self.left = left</span><br><span class="line">    self.token = self.op = op</span><br><span class="line">    self.right = right</span><br></pre></td></tr></table></figure><ul><li>构造函数的参数是 <code>left</code>, <code>op</code>, 和 <code>right</code>, 其中 <code>left</code> 和 <code>right</code> 分别指向了表示 左操作数和右操作数的结点。 <code>op</code> 保存了指向操作符本身的 token: <code>Token(PLUS, &#39;+&#39;)</code> 表示加操作符， <code>Token(MINUS, &#39;-&#39;)</code> 表示减操作符，等等。</li></ul></li><li><p>为了在 AST 中表示整数，我们定义一个 <code>Num</code> 类，它将保存一个 <code>INTEGER</code> token 和该 token 的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Num</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, token)</span>:</span></span><br><span class="line">    self.token = token</span><br><span class="line">    self.value = token.value</span><br></pre></td></tr></table></figure><ul><li>和你注意到的一样，所有的note保存 token 从而则创建note(all nodes store the token used to create the node)。这主要是为了方便，将来会派上用场。</li></ul></li></ul><p>回忆一下表达式 2 * 7 + 3 的 AST。我们会在代码中手工创建该表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> spi <span class="keyword">import</span> Token, MUL, PLUS, INTEGER, Num, BinOp</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mul_token = Token(MUL, <span class="string">'*'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plus_token = Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mul_node = BinOp(</span><br><span class="line"><span class="meta">... </span>    left=Num(Token(INTEGER, <span class="number">2</span>)),</span><br><span class="line"><span class="meta">... </span>    op=mul_token,</span><br><span class="line"><span class="meta">... </span>    right=Num(Token(INTEGER, <span class="number">7</span>))</span><br><span class="line"><span class="meta">... </span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_node = BinOp(</span><br><span class="line"><span class="meta">... </span>    left=mul_node,</span><br><span class="line"><span class="meta">... </span>    op=plus_token,</span><br><span class="line"><span class="meta">... </span>    right=Num(Token(INTEGER, <span class="number">3</span>))</span><br><span class="line"><span class="meta">... </span>)</span><br></pre></td></tr></table></figure><p>以下是在新定义的结点类下 AST 的样子。下面的图片也遵循了上面手工创建的过程：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_astimpl_01.png" alt="lsbasi_part7_astimpl_01"></p><h3 id="parser-代码"><a href="#parser-代码" class="headerlink" title="parser 代码"></a>parser 代码</h3><p>下面是我们修改过的 parser 代码，在识别输入（算术表达式）时建立和返回一个 AST:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AST</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinOp</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, left, op, right)</span>:</span></span><br><span class="line">    self.left  = left</span><br><span class="line">    self.token = self.op = op</span><br><span class="line">    self.right = right</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Num</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, token)</span>:</span></span><br><span class="line">    self.token = token</span><br><span class="line">    self.value = token.value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lexer)</span>:</span></span><br><span class="line">    self.lexer = lexer</span><br><span class="line">    <span class="comment"># set current token to the first token from the input</span></span><br><span class="line">    self.current_token = self.lexer.get_next_token()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">'Invalid syntax'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">    <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">    <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">    <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">    <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">    <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">        self.current_token = self.lexer.get_next_token()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.error()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""factor : INTEGER | LPAREN expr RPAREN"""</span></span><br><span class="line">    token = self.current_token</span><br><span class="line">    <span class="keyword">if</span> token.type == INTEGER:</span><br><span class="line">        <span class="keyword">return</span> Num(token)</span><br><span class="line">    <span class="keyword">elif</span> token.type == LPAREN:</span><br><span class="line">        self.eat(LPAREN)</span><br><span class="line">        node = self.expr()</span><br><span class="line">        self.eat(RPAREN)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""term : factor ((MUL | DIV) factor)*"""</span></span><br><span class="line">    node = self.factor()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">        token = self.current_token</span><br><span class="line">        <span class="keyword">if</span> token.type == MUL:</span><br><span class="line">        self.eat(MUL)</span><br><span class="line">        <span class="keyword">elif</span> token.type == DIV:</span><br><span class="line">        self.eat(DIV)</span><br><span class="line"></span><br><span class="line">        node = BinOp(left=node, op=token, right=self.factor())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    expr   : term ((PLUS | MINUS) term)*</span></span><br><span class="line"><span class="string">    term   : factor ((MUL | DIV) factor)*</span></span><br><span class="line"><span class="string">    factor : INTEGER | LPAREN expr RPAREN</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    node = self.term()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (PLUS, MINUS):</span><br><span class="line">        token = self.current_token</span><br><span class="line">        <span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">        self.eat(PLUS)</span><br><span class="line">        <span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">        self.eat(MINUS)</span><br><span class="line"></span><br><span class="line">        node = BinOp(left=node, op=token, right=self.term())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.expr()</span><br></pre></td></tr></table></figure><p>让我们看一些算术表达式的 AST 的构建过程。</p><p>如果你看了上面的 parser 代码，可以看到它建立一个 AST 中的结点的时，把变量 node 的当前值做为 BinOp 结点的左子结点，把对 <code>term</code> 或 <code>factor</code> 调用的返回结果做为它 的右子结点，这实际上就是把结点推向左边，下面表达式 1 +2 + 3 + 4 + 5 的树结构就是 这种情况的一个好例子。下面是 parser 如何一步步地构建表达式 1 + 2 + 3 + 4 + 5 的 AST 的图形表示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_astimpl_02.png" alt="lsbasi_part7_astimpl_02"></p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>好了，下面是表达式 2 * 7 + 3 的 AST：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_ast_walking_01.png" alt="lsbasi_part7_ast_walking_01"></p><p><strong>你怎么遍历这个树并恰当地对它所代表的表达式进行求值呢？</strong></p><blockquote><p>你可以使用<strong>后序遍历*postorder traversal*</strong> (深度优先遍历<em>depth-first traversal</em> 的一个特例) 。</p><ul><li>这种方式由根结点开始，递归由左至右访问每个结点的子结点。后序遍历从根结点开始尽可能快地访问离根结点远的结点(The postorder traversal visits nodes as far away from the root as fast as it can)。</li></ul></blockquote><p>下面是后序遍历的伪代码，其中 <code>&lt;&lt; postorder actions &gt;&gt;</code>是一些操作的占位符，如 <code>BinOp</code> 结点的加减乘除操作或 <code>Num</code> 结点返回整数的简单操作：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_ast_visit_postorder.png" alt="lsbasi_part7_ast_visit_postorder"></p><ul><li><p><strong>为什么要使用后续遍历呢？</strong></p><blockquote><p>第一，我们需要对在树中更低的中间结点进行求值， 因为它们代表了优先级更高的操作符，</p><p>第二，我们在对操作数 参与 对应操作符 的运算 之前需要对操作数进行求值。</p></blockquote><p>在下面的图片中，可以看到使用后序遍历时我们会首先对表达式 2*7 进行 求值，而只有在对 14 + 3 求值之后，我们才会得到正确答案 17:</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_ast_walking_02.png" alt="lsbasi_part7_ast_walking_02"></p><p><strong>三种深度优先遍历</strong>：</p><p>为了完整起见，三种深度优先遍历的方式：先序遍历，中序遍历和后序遍历。这 些遍历方式名字的来自于遍历代码中操作的位置：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_ast_visit_generic.png" alt="lsbasi_part7_ast_visit_generic"></p><p>有时你可能需要在所有地方（先序，中序和后序）都执行一些操作。你会在本文的源代码仓 库中找到一些例子。</p><blockquote><ul><li><p>先序遍历<em>preorder traversal</em>,</p><p>在先序遍历中，我们先访问根节点，然后递归使用先序遍历访问左子树，再递归使用先序遍历访问右子树，即：根节点-&gt;左子树-&gt;右子树</p></li><li><p>中序遍历<em>inorder traversal</em>,</p><p>在中序遍历中，我们递归使用中序遍历访问左子树，然后访问根节点，最后再递归使用中序遍历访问右子树，即：<br>左子树-&gt;根节点-&gt;右子树</p></li><li><p>后序遍历 <em>postorder traversal</em>.</p><p>在后序遍历中，我们先递归使用后序遍历访问左子树和右子树，最后访问根节点。 即：<br>左子树-&gt;右子树-&gt;根节点</p></li></ul></blockquote><h2 id="Interpreter"><a href="#Interpreter" class="headerlink" title="Interpreter"></a>Interpreter</h2><p><strong>用代码来遍历和解释由 parser 建立的抽象语法树</strong>：</p><p>好了，让我们写一些代码来遍历和解释由 parser 建立的抽象语法树，好吗？</p><p>下面是实现了<a href="https://en.wikipedia.org/wiki/Visitor_pattern" target="_blank" rel="noopener">访问者模式</a>的源代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeVisitor</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        method_name = <span class="string">'visit_'</span> + type(node).__name__</span><br><span class="line">        visitor = getattr(self, method_name, self.generic_visit)</span><br><span class="line">        <span class="keyword">return</span> visitor(node)</span><br><span class="line"><span class="comment">#generic_visit 是一个备用函数，它会抛出一个异常来表示它遇到了一个实现类中没有相 应 #visit_NodeType 方法的结点。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generic_visit</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'No visit_&#123;&#125; method'</span>.format(type(node).__name__))</span><br></pre></td></tr></table></figure><blockquote><p>NodeVisitor一个结点访问器的基类：它遍历抽象语法树并为找到的每个节点调用一个访问器函数。（这个函数可能会返回一个由visit()方法转发 的值）。This class is meant to be subclassed, with the subclass adding visitor methods.</p><p>成员函数：</p><ul><li>1️⃣ visit(node)：访问一个结点。它默认调用self.visit_classname（其中的classname是结点类的名<br>字，或者如果这个方法不存在时，classname就是 generic_visit() ）的方法。</li><li>2️⃣ generic_visit(node)：这个访问器(visitor)对结点的所有子节点调用visit()。<br>【注意：只有这个访问器调用generic_visit() 或者访问它本身，否则自定义访问器的结点的子节点将不会被访问】</li></ul><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getattr(object, name[, default])</span><br></pre></td></tr></table></figure><p>官方文档中说这个函数作用是返回对象的一个属性，第一个参数是对象实例<code>obj</code>,<code>name</code>是个字符串，是对象的成员函数名字或者成员变量，<code>default</code>当对象没有这个属相的时候就返回默认值，如果没有提供默认值就返回异常。</p><p>如：</p><ol><li>提供不默认写法：</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Test</span>(<span class="title">object</span>):</span></span><br><span class="line">...     <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">...             print <span class="string">'I am a test'</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; test = Test()  <span class="comment"># 实例化一个对象</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; func = getattr(test, <span class="string">'func'</span>) <span class="comment"># 使用getattr函数获取func的值</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; func()</span><br><span class="line">I am a test</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; func = getattr(test, <span class="string">'f'</span>)  <span class="comment"># 使用对象没有的属性，则会出现异常</span></span><br><span class="line">Traceback (most recent call last)<span class="symbol">:</span></span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line"><span class="symbol">AttributeError:</span> <span class="string">'Test'</span> object has no attribute <span class="string">'f'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><ol><li>提供默认写法</li></ol><p>如果对象没有该属性可以提供一个默认值。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; func = getattr(test, <span class="string">'f'</span>, None)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; print func</span><br><span class="line">None</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="Interpreter-类的源代码"><a href="#Interpreter-类的源代码" class="headerlink" title="Interpreter 类的源代码"></a>Interpreter 类的源代码</h3><p>下面是 Interpreter 类的源代码，它继承自 NodeVisitor 类且实现了形式为 <code>visit_NodeType</code> 的不同方法，其中 <code>NodeType</code> 会被如 <code>BinOp</code>, <code>Num</code> 等类名替换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(NodeVisitor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parser)</span>:</span></span><br><span class="line">    self.parser = parser</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_BinOp</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> node.op.type == PLUS:</span><br><span class="line">        <span class="keyword">return</span> self.visit(node.left) + self.visit(node.right)</span><br><span class="line">    <span class="keyword">elif</span> node.op.type == MINUS:</span><br><span class="line">        <span class="keyword">return</span> self.visit(node.left) - self.visit(node.right)</span><br><span class="line">    <span class="keyword">elif</span> node.op.type == MUL:</span><br><span class="line">        <span class="keyword">return</span> self.visit(node.left) * self.visit(node.right)</span><br><span class="line">    <span class="keyword">elif</span> node.op.type == DIV:</span><br><span class="line">        <span class="keyword">return</span> self.visit(node.left) / self.visit(node.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_Num</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> node.value</span><br></pre></td></tr></table></figure><p>关于以上代码有两点值得在这里提一下：</p><blockquote><p>第一，<u>操作 AST 结点的访问器(也就是对AST数据的操作)</u>的代码 和 AST 结点(即，AST的数据结构)本身 分离（解耦了）。</p><ul><li>可以看到 AST 结点类(BinOp 和 Num)没有提供任何代码来操作存储在这些结点中的数据，该逻辑被封装在了实现 <code>NodeVisitor</code> 的 <code>Interpreter</code> 类中。（也就是对数据的操作在<code>NodeVisitor</code> 的 <code>Interpreter</code> 类中）。</li></ul><p>第二，在NodeVisitor的访问函数中，不像这样使用一个巨大的if语句:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit</span><span class="params">(node)</span>:</span></span><br><span class="line">    node_type = type(node).__name__</span><br><span class="line">    <span class="keyword">if</span> node_type == <span class="string">'BinOp'</span>:</span><br><span class="line">        <span class="keyword">return</span> self.visit_BinOp(node)</span><br><span class="line">    <span class="keyword">elif</span> node_type == <span class="string">'Num'</span>:</span><br><span class="line">        <span class="keyword">return</span> self.visit_Num(node)</span><br><span class="line">    <span class="keyword">elif</span> ...</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"><span class="comment">#####或者##########</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit</span><span class="params">(node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(node, BinOp):</span><br><span class="line">        <span class="keyword">return</span> self.visit_BinOp(node)</span><br><span class="line">    <span class="keyword">elif</span> isinstance(node, Num):</span><br><span class="line">        <span class="keyword">return</span> self.visit_Num(node)</span><br><span class="line">    <span class="keyword">elif</span> ...</span><br></pre></td></tr></table></figure><p>NodeVisitor 的 visit 方法非常通用，能根据传入的结点类型来调度适当的方法。正如前面提到的，为了利用这一点，我们的解释器继承了 NodeVisitor 类并实现了必要的方法。 因此：</p><ul><li>如果传递给 <code>visit</code> 函数的结点是 <code>BinOp</code>，那么<code>visit</code> 函数就会调用 <code>visit_BinOp</code> 方法。</li><li>如果传递给 <code>visit</code>函数的结点是 <code>Num</code>,那么 <code>visit</code> 函数就会调用<code>visit_Num</code> 方 法，等等。</li></ul></blockquote><p>花此时间研究一下这个方法（Python 的标准模块 <a href="https://docs.python.org/2.7/library/ast.html#module-ast" target="_blank" rel="noopener">ast</a> 也使用了相同的机制来遍历结点）， 因为我们将来会用很多新的 <code>visit_NodeType</code> 方法来扩展我们的解释器。</p><p>现在，让我们手工为表达式 2 * 7 + 3 建立一个 AST 并把它传递给解释器，通过对该表达式求值看看运行中的 visit 方法。下面是你从 Python shell 中尝试的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> spi <span class="keyword">import</span> Token, MUL, PLUS, INTEGER, Num, BinOp</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mul_token = Token(MUL, <span class="string">'*'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plus_token = Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mul_node = BinOp(</span><br><span class="line"><span class="meta">... </span>    left=Num(Token(INTEGER, <span class="number">2</span>)),</span><br><span class="line"><span class="meta">... </span>    op=mul_token,</span><br><span class="line"><span class="meta">... </span>    right=Num(Token(INTEGER, <span class="number">7</span>))</span><br><span class="line"><span class="meta">... </span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_node = BinOp(</span><br><span class="line"><span class="meta">... </span>    left=mul_node,</span><br><span class="line"><span class="meta">... </span>    op=plus_token,</span><br><span class="line"><span class="meta">... </span>    right=Num(Token(INTEGER, <span class="number">3</span>))</span><br><span class="line"><span class="meta">... </span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> spi <span class="keyword">import</span> Interpreter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inter = Interpreter(<span class="literal">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inter.visit(add_node)</span><br><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure><p>如你所见，我把表达式树的根结点传递给了 <code>visit</code> 方法，这一行为触发了树的遍历，遍历调用了 <code>Interpreter</code> 类正确的方法(<code>visit_BinOp</code> 和 <code>visit_Num</code>)并生成了结果。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""" SPI - Simple Pascal Interpreter """</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, PLUS, MINUS, MUL, DIV, LPAREN, RPAREN, EOF = (</span><br><span class="line">    <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'MINUS'</span>, <span class="string">'MUL'</span>, <span class="string">'DIV'</span>, <span class="string">'('</span>, <span class="string">')'</span>, <span class="string">'EOF'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        self.type = type</span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""String representation of the class instance.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">            Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">            Token(PLUS, '+')</span></span><br><span class="line"><span class="string">            Token(MUL, '*')</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Token(&#123;type&#125;, &#123;value&#125;)'</span>.format(</span><br><span class="line">            type=self.type,</span><br><span class="line">            value=repr(self.value)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"></span><br><span class="line"><span class="comment">###############################################################################</span></span><br><span class="line"><span class="comment">#                                                                             #</span></span><br><span class="line"><span class="comment">#  LEXER                                                                      #</span></span><br><span class="line"><span class="comment">#                                                                             #</span></span><br><span class="line"><span class="comment">###############################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lexer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="comment"># client string input, e.g. "4 + 2 * 3 - 6 / 2"</span></span><br><span class="line">        self.text = text</span><br><span class="line">        <span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        self.current_char = self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid character'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Advance the `pos` pointer and set the `current_char` variable."""</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt; len(self.text) - <span class="number">1</span>:</span><br><span class="line">            self.current_char = <span class="literal">None</span>  <span class="comment"># Indicates end of input</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_char = self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">            self.advance()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return a (multidigit) integer consumed from the input."""</span></span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">            result += self.current_char</span><br><span class="line">            self.advance()</span><br><span class="line">        <span class="keyword">return</span> int(result)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">        apart into tokens. One token at a time.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">                self.skip_whitespace()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isdigit():</span><br><span class="line">                <span class="keyword">return</span> Token(INTEGER, self.integer())</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'+'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'-'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'*'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MUL, <span class="string">'*'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'/'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(DIV, <span class="string">'/'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'('</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(LPAREN, <span class="string">'('</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">')'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(RPAREN, <span class="string">')'</span>)</span><br><span class="line"></span><br><span class="line">            self.error()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">###############################################################################</span></span><br><span class="line"><span class="comment">#                                                                             #</span></span><br><span class="line"><span class="comment">#  PARSER                                                                     #</span></span><br><span class="line"><span class="comment">#                                                                             #</span></span><br><span class="line"><span class="comment">###############################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AST</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span>   <span class="comment"># 表示定义留空</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinOp</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, left, op, right)</span>:</span></span><br><span class="line">        self.left = left</span><br><span class="line">        self.token = self.op = op</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Num</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, token)</span>:</span></span><br><span class="line">        self.token = token</span><br><span class="line">        self.value = token.value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lexer)</span>:</span></span><br><span class="line">        self.lexer = lexer</span><br><span class="line">        <span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">        self.current_token = self.lexer.get_next_token()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid syntax'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">        <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">        <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">        <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.lexer.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""factor : INTEGER | LPAREN expr RPAREN"""</span></span><br><span class="line">        token = self.current_token</span><br><span class="line">        <span class="keyword">if</span> token.type == INTEGER:</span><br><span class="line">            self.eat(INTEGER)</span><br><span class="line">            <span class="keyword">return</span> Num(token)</span><br><span class="line">        <span class="keyword">elif</span> token.type == LPAREN:</span><br><span class="line">            self.eat(LPAREN)</span><br><span class="line">            node = self.expr()</span><br><span class="line">            self.eat(RPAREN)</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""term : factor ((MUL | DIV) factor)*"""</span></span><br><span class="line">        node = self.factor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == MUL:</span><br><span class="line">                self.eat(MUL)</span><br><span class="line">            <span class="keyword">elif</span> token.type == DIV:</span><br><span class="line">                self.eat(DIV)</span><br><span class="line"></span><br><span class="line">            node = BinOp(left=node, op=token, right=self.factor())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        expr   : term ((PLUS | MINUS) term)*</span></span><br><span class="line"><span class="string">        term   : factor ((MUL | DIV) factor)*</span></span><br><span class="line"><span class="string">        factor : INTEGER | LPAREN expr RPAREN</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        node = self.term()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (PLUS, MINUS):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">                self.eat(PLUS)</span><br><span class="line">            <span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">                self.eat(MINUS)</span><br><span class="line"></span><br><span class="line">            node = BinOp(left=node, op=token, right=self.term())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.expr()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">###############################################################################</span></span><br><span class="line"><span class="comment">#                                                                             #</span></span><br><span class="line"><span class="comment">#  INTERPRETER                                                                #</span></span><br><span class="line"><span class="comment">#                                                                             #</span></span><br><span class="line"><span class="comment">###############################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeVisitor</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        method_name = <span class="string">'visit_'</span> + type(node).__name__</span><br><span class="line">        visitor = getattr(self, method_name, self.generic_visit)</span><br><span class="line">        <span class="keyword">return</span> visitor(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generic_visit</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'No visit_&#123;&#125; method'</span>.format(type(node).__name__))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(NodeVisitor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parser)</span>:</span></span><br><span class="line">        self.parser = parser</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_BinOp</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node.op.type == PLUS:</span><br><span class="line">            <span class="keyword">return</span> self.visit(node.left) + self.visit(node.right)</span><br><span class="line">        <span class="keyword">elif</span> node.op.type == MINUS:</span><br><span class="line">            <span class="keyword">return</span> self.visit(node.left) - self.visit(node.right)</span><br><span class="line">        <span class="keyword">elif</span> node.op.type == MUL:</span><br><span class="line">            <span class="keyword">return</span> self.visit(node.left) * self.visit(node.right)</span><br><span class="line">        <span class="keyword">elif</span> node.op.type == DIV:</span><br><span class="line">            <span class="keyword">return</span> self.visit(node.left) / self.visit(node.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_Num</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">interpret</span><span class="params">(self)</span>:</span></span><br><span class="line">        tree = self.parser.parse()</span><br><span class="line">        <span class="keyword">return</span> self.visit(tree)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                text = raw_input(<span class="string">'spi&gt; '</span>)</span><br><span class="line">            <span class="keyword">except</span> NameError:  <span class="comment"># Python3</span></span><br><span class="line">                text = input(<span class="string">'spi&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        lexer = Lexer(text)</span><br><span class="line">        parser = Parser(lexer)</span><br><span class="line">        interpreter = Interpreter(parser)</span><br><span class="line">        result = interpreter.interpret()</span><br><span class="line">        print(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>将以上代码保存到名为 <code>spi.py</code> 的文件中，或者直接从 <a href="https://github.com/rspivak/lsbasi/blob/master/part7/python/spi.py" target="_blank" rel="noopener">GitHub</a> 下载。自己试一试，确认 你的新的基于树的解释器可以正确地对算术表达式进行求值。</p><p>下面是某次运行过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python spi.py</span><br><span class="line">spi&gt; <span class="number">7</span> + <span class="number">3</span> * (<span class="number">10</span> / (<span class="number">12</span> / (<span class="number">3</span> + <span class="number">1</span>) - <span class="number">1</span>))</span><br><span class="line"><span class="number">22</span></span><br><span class="line">spi&gt; <span class="number">7</span> + <span class="number">3</span> * (<span class="number">10</span> / (<span class="number">12</span> / (<span class="number">3</span> + <span class="number">1</span>) - <span class="number">1</span>)) / (<span class="number">2</span> + <span class="number">3</span>) - <span class="number">5</span> - <span class="number">3</span> + (<span class="number">8</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line">spi&gt; <span class="number">7</span> + (((<span class="number">3</span> + <span class="number">2</span>)))</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天你学习了关于解析树和 AST，如何构建 AST 以及遍历表示输入的 AST 并解释执行。你还修改了 parser 和 interpreter 并将这两部分解开了。现在 lexer, parser 和 interpreter 之间的接口看起来像这样：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_pipeline.png" alt="lsbasi_part7_pipeline"></p><p>你可以把它读作“parser 从 lexer 中 得到 token 然后返回生成的 AST 给 Interpreter 进行遍历并解释执行所给输入”。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>这就是今天的所有内容，但在总结之前我还想简单地聊一聊递归下降 (recursive-descent) parser，即是仅仅给出它的定义。</p><blockquote><p>定义就是：一个 <strong>递归下降parser</strong> 就 是一个自顶向下的 parser，它使用一组递归过程来处理输入。自顶向下反映了 parser 从 构建解析树的顶部结点开始逐渐构建更低的结点这一事实。</p></blockquote><h2 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h2><p>本节与part6相比主要添加了AST：</p><ol><li><code>Lexer</code>与part6中的是一样的，还是将输入的text分析转换为token。(这也是词法分析器的功能)</li><li><code>Parser</code>相比part6，<ul><li>它添加了构造AST的内容：添加了三个类：<ul><li><code>AST()</code>：是一个基类</li><li><code>BinOp(AST)</code>：继承于<code>AST()</code>，主要功能是实现<strong>二元操作符<em>binary operator</em></strong> 。（这里只有四种：加、减、乘、除法）</li><li><code>Num(AST)</code>：继承于<code>AST()</code>，它主要是表示AST中的整数integer token（它将保存一个 <code>INTEGER</code> token 和该 token 的值）</li></ul></li><li>第二个变化就是实现语法解析的这三个函数<code>term</code>、<code>factor</code>、<code>expr</code>中的返回的不在是result变量了，而是返回一个结点node。</li></ul></li><li><code>Interpreter</code>：通过词法分析、语法分析之后，开始解释语法分析之后的算式，计算出它的结果，用<code>Interpreter</code>来解释：<ul><li>增添了<strong>访问者模式</strong>：将 对数据的操作(对数据的操作在interpreter中完成：访问、解释) 和 数据结构(数据结构 在parser中的三个类中构建) 进行分离（解耦合）。使得操作集合可相对自由地演化。<ul><li>这里通过创建 <code>NodeVisitor()</code>类 实现访问者模式。实现了通过什么方式去<strong>访问</strong>生成的AST</li><li>又通过<code>Interpreter</code>（继承于 <code>NodeVisitor()</code>类）来实现<strong>解释</strong>生成的AST</li></ul></li></ul></li></ol><p>最后，再次提醒一下：之前的那几小结，我们都是把interpreter的代码和parser的代码混在一起，但这一小节我们把interpreter的代码和parser的代码<strong>分开了</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Let&#39;s Build A Simple Interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let’s Build A Simple Interpreter 6</title>
      <link href="/archives/167c.html"/>
      <url>/archives/167c.html</url>
      
        <content type="html"><![CDATA[<p>新增了<strong>括号运算(parenthesized expressions)</strong></p><a id="more"></a><p>原文链接：<a href="https://ruslanspivak.com/lsbasi-part6/" target="_blank" rel="noopener">https://ruslanspivak.com/lsbasi-part6/</a></p><p>本文在前面的基础上，新增了<strong>括号运算(parenthesized expressions)</strong>，如： 7 + 3 * (10 / (12 / (3 + 1) - 1))</p><p>所以需要在part5中的语法基础上，进行修改，修改后的语法如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part6_grammar.png" alt="lsbasi_part6_grammar"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part5_grammar.png" alt="lsbasi_part5_grammar"></p><p>从上面的图可以看出来,在part6中，<code>expr</code>和<code>term</code>和part5中一样，<u>唯一变的是<code>factor</code>的<strong>产生式 (production)</strong>。</u></p><blockquote><p>它新添加了两个 terminal ：</p><ul><li>LPAREN：表示一个左括号 left parenthesis ‘( ‘</li><li>RPAREN：表示一个右括号 right parenthesis ‘)’</li></ul><p>还新添加了一个非终端符：<code>expr</code></p><ul><li><code>expr</code>添加在两个括号之间</li></ul></blockquote><p>下面是<code>factor</code>的语法图：（这里用到了<u>递归</u>）</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part6_factor_diagram.png" alt="lsbasi_part6_factor_diagram"></p><p>然后，再放一下没有改变的（与part5相同）<code>expr</code>、<code>term</code>的语法图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part6_expr_term_diagram.png" alt="img"></p><p>现在看一下算式：2 * (7 + 3) 的分解过程吧：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part6_decomposition.png" alt="img"></p><p>现在把语法转换成代码。</p><p>下面这两条是代码中主要改变的部分：</p><blockquote><ol><li><code>Lexer</code>被修改，使其在原来的基础上可以返回另外两个token：左括号LPAREN 、右括号RPAREN</li><li><code>Interpreter</code>类的<code>factor</code>被修改，修改之后不仅可以解析整数integer，还可以解析括号表达式(parenthesized expressions)</li></ol></blockquote><p>下面就是本小节的代码部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, PLUS, MINUS, MUL, DIV, LPAREN, RPAREN, EOF = (</span><br><span class="line">    <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'MINUS'</span>, <span class="string">'MUL'</span>, <span class="string">'DIV'</span>, <span class="string">'('</span>, <span class="string">')'</span>, <span class="string">'EOF'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        self.type = type</span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""String representation of the class instance.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">            Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">            Token(PLUS, '+')</span></span><br><span class="line"><span class="string">            Token(MUL, '*')</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Token(&#123;type&#125;, &#123;value&#125;)'</span>.format(</span><br><span class="line">            type=self.type,</span><br><span class="line">            value=repr(self.value)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lexer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="comment"># client string input, e.g. "4 + 2 * 3 - 6 / 2"</span></span><br><span class="line">        self.text = text</span><br><span class="line">        <span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        self.current_char = self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid character'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Advance the `pos` pointer and set the `current_char` variable."""</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt; len(self.text) - <span class="number">1</span>:</span><br><span class="line">            self.current_char = <span class="literal">None</span>  <span class="comment"># Indicates end of input</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_char = self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">            self.advance()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return a (multidigit) integer consumed from the input."""</span></span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">            result += self.current_char</span><br><span class="line">            self.advance()</span><br><span class="line">        <span class="keyword">return</span> int(result)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">        apart into tokens. One token at a time.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">                self.skip_whitespace()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isdigit():</span><br><span class="line">                <span class="keyword">return</span> Token(INTEGER, self.integer())</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'+'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'-'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'*'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MUL, <span class="string">'*'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'/'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(DIV, <span class="string">'/'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'('</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(LPAREN, <span class="string">'('</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">')'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(RPAREN, <span class="string">')'</span>)</span><br><span class="line"></span><br><span class="line">            self.error()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lexer)</span>:</span></span><br><span class="line">        self.lexer = lexer</span><br><span class="line">        <span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">        self.current_token = self.lexer.get_next_token()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid syntax'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">        <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">        <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">        <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.lexer.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""factor : INTEGER | LPAREN expr RPAREN"""</span></span><br><span class="line">        token = self.current_token</span><br><span class="line">        <span class="keyword">if</span> token.type == INTEGER:</span><br><span class="line">            self.eat(INTEGER)</span><br><span class="line">            <span class="keyword">return</span> token.value</span><br><span class="line">        <span class="keyword">elif</span> token.type == LPAREN:</span><br><span class="line">            self.eat(LPAREN)</span><br><span class="line">            result = self.expr()</span><br><span class="line">            self.eat(RPAREN)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""term : factor ((MUL | DIV) factor)*"""</span></span><br><span class="line">        result = self.factor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == MUL:</span><br><span class="line">                self.eat(MUL)</span><br><span class="line">                result = result * self.factor()</span><br><span class="line">            <span class="keyword">elif</span> token.type == DIV:</span><br><span class="line">                self.eat(DIV)</span><br><span class="line">                result = result / self.factor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Arithmetic expression parser / interpreter.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        calc&gt; 7 + 3 * (10 / (12 / (3 + 1) - 1))</span></span><br><span class="line"><span class="string">        22</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        expr   : term ((PLUS | MINUS) term)*</span></span><br><span class="line"><span class="string">        term   : factor ((MUL | DIV) factor)*</span></span><br><span class="line"><span class="string">        factor : INTEGER | LPAREN expr RPAREN</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = self.term()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (PLUS, MINUS):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">                self.eat(PLUS)</span><br><span class="line">                result = result + self.term()</span><br><span class="line">            <span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">                self.eat(MINUS)</span><br><span class="line">                result = result - self.term()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># To run under Python3 replace 'raw_input' call</span></span><br><span class="line">            <span class="comment"># with 'input'</span></span><br><span class="line">            text = raw_input(<span class="string">'calc&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        lexer = Lexer(text)</span><br><span class="line">        interpreter = Interpreter(lexer)</span><br><span class="line">        result = interpreter.expr()</span><br><span class="line">        print(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Let&#39;s Build A Simple Interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let’s Build A Simple Interpreter 5</title>
      <link href="/archives/173c.html"/>
      <url>/archives/173c.html</url>
      
        <content type="html"><![CDATA[<p>本文为这一系列的part5，第五小节。这次将写一个可移植性加减乘除混合运算的解释器。</p><a id="more"></a><p>原文链接：<a href="https://ruslanspivak.com/lsbasi-part5/" target="_blank" rel="noopener">https://ruslanspivak.com/lsbasi-part5/</a></p><p>本文为这一系列的part5，第五小节。这次将写一个可移植性加减乘除混合运算的解释器。</p><p>在开始写代码之前，我们需要知道一些，比如：<strong>结合律</strong>、操作符(operator)的<strong>优先级(precedence)</strong></p><h2 id="结合律-associativity"><a href="#结合律-associativity" class="headerlink" title="结合律(associativity)"></a>结合律(associativity)</h2><p>比如，7+3+1等同于(7+3)+1 ，7 - 3 - 1 等同于 (7 - 3) - 1。这没有什么奇怪的。但是再比如： 7 - 3 - 1 与 7 - (3 - 1) 的结果就不一样了。</p><p>其实：加、减、乘、除 这些操作符(operator)是<strong>左结合(left-associative)</strong>。</p><ul><li>比如， 7 + 3 + 1 中的 <strong>操作数(operand)</strong> 3，它的左右都是 加号 ，但是这个操作数3是与它左边的加号“+”结合的， 所以加法是左结合。</li><li>那加减乘除混合时，如 7 + 5 * 2 是否还是遵循左结合律呢？很显然，不遵循，因为 (7 + 5) * 2 不等于 7 + 5 * 2 。</li></ul><p>由此可知：</p><p>​ <u>加法</u>和<u>减法</u>是一类，所以它们在一起组成的运算是左结合；<u>乘法</u>和<u>除法</u>是一类，所以他们在一起组成的运算是左结合。（即，左结合律只适用于同一类的操作符(operator)）</p><h2 id="优先级-precedence"><a href="#优先级-precedence" class="headerlink" title="优先级(precedence)"></a>优先级(precedence)</h2><p>那我们如何规定这种加减乘除（这两类操作符(operator)）同时出现时的运算规则呢？（实际上我们都知道，但是这里是为实现代码来做出一种运算规则）</p><p>在 7 + 5 * 2中，如果<u>操作符“<em>”</em></u>能先比<u>操作符“+”</u>到他的<u>操作数5</u>，就说，操作符“”有<strong>更高的优先级(higher precedence)</strong>。</p><p>在实际中我们也在用，也知道。乘除的优先级要高于加减法。</p><p>好了，现在我们开始用表格来表示操作符的结合律与优先级：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part5_precedence.png" alt="随着箭头方向优先级升高"></p><p>由上表可知：+ and - 是优先级相同，都是左结合；* and / 优先级相同，也都是左结合；</p><p>我们还可以根据上面的优先级表格来制定一个语法规则：</p><ol><li>优先级相同的每一级都定义一个非终端符(non-terminal)。其中每个<strong>产生式(production)</strong>的body中应该包含:算数运算符(arithmetic operators) &amp; 非终端符(这里的非终端又参与构成下一较高的优先级的规则(产生式)的一部分)</li><li>创建一个表示 基本表达式的非终端符<code>factor</code>，本文中指integer。一般的规则是：如果你有N个优先级，那么你就需要N+1个非终端符（一类是每一层优先级的一个非终端符，一类是表示基本表达式单元）</li></ol><h2 id="构建语法-grammars"><a href="#构建语法-grammars" class="headerlink" title="构建语法(grammars)"></a>构建语法(grammars)</h2><p>现在根据上面的规则来构建语法：</p><p>由规则1，我们将定义两个非终结符(non-terminal)，一个是leve1的non-terminal叫做<code>expr</code>，另一个是level2的non-terminal叫做term。然后根据规则2，我们需要定义一个叫做<code>factor</code>的non-terminal来作为一个基本的表达式单元，integers。</p><p>这个语法的<strong>开始符号（<em>start symbol</em> ）</strong>叫做<code>expr</code>。它的产生式(production)的body含有：</p><ul><li><p>1️⃣表示level2的操作符(在这指的是+ and - )，</p></li><li><p>2️⃣和一个非终端符<code>term</code>(这个term是下一层优先级（更高的）level1 的一个产生式)</p></li></ul><blockquote><p><strong>开始符号（S）</strong>：最大的语法单位 或 最重要的语法单位。（如上面的那个英文句子中的，最大的语法单位是：句子。）</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part5_cfg_expr.png" alt="start symbol（开始符）:expr"></p><p>非终端符<code>term</code>的production(产生式)的body包含:</p><ul><li><p>1️⃣表示level1的操作符(在这指的是 * and /)。</p></li><li><p>2️⃣还有一个非终端符<code>factor</code>来表示基本的表达式单元，integers</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part5_cfg_term.png" alt="term"></p></li></ul><p>非终端符<code>factor</code>包含：</p><ul><li><p>1️⃣一个integer</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part5_cfg_factor.png" alt="factor"></p></li></ul><p>上面的三幅图是语法、语法图的一部分，这在之前的文章中也出现过。但现在需要将上面的三幅图结合在一起来考虑结合律和优先级（ associativity and precedence ）</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part5_grammar.png" alt="img"></p><p>下面是本文的语法对应的语法图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-5/20200318213222.png" alt="grammar"></p><p>上面语法图的每一个小方框都是其他语法图的：函数调用（“method call”）。</p><blockquote><p>如果你以表达式 7 + 5 * 2 为例并从顶 层图 <code>expr</code> 开始逐步分解到最底层的图 <code>factor</code>, 你应该可以看到位于中间的图的高优 先级操作符*和/会比上面的图的操作符+和-先执行。</p></blockquote><p>为了解释清楚运算符的优先级，让我们看看使用上面语法和句法图来分解相同算术表达式 7 + 5 * 2 的过程。这只是另一种展示高优先级运算符 先于 低优先级运算符执行这个事实的 方式。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part5_exprdecomp.png" alt="img"></p><h3 id="语法转换成代码"><a href="#语法转换成代码" class="headerlink" title="语法转换成代码"></a>语法转换成代码</h3><p>让我们使用<a href="http://ruslanspivak.com/lsbasi-part4/" target="_blank" rel="noopener">part 4</a>中的准则把该语法转化成代码，看看它怎么工作，先看一张上面放过的语法图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part5_grammar-1583931621458.png" alt="语法图"></p><p>下面是能处理可以包含任意数量加减乘除操作符的算术表达式的计算器的完整代码。</p><blockquote><p>相比于<a href="http://ruslanspivak.com/lsbasi-part4/" target="_blank" rel="noopener">part 4</a>代码的主要变化有：</p><ul><li><code>Lexer</code> 类现在可以把+,-,*和/都 token 化了（没什么新方法，我们只是把前面文章中 的代码合并到一个类中来支持所有这些 token）</li><li>回想语法中的每条规则（产生式）R都要变成一个同名的方法，且对该规则的引用都要变 成一个方法调用 <code>R()</code> 这一点。现在 <code>Interpreter</code> 类有了三个方法来对应语法中的非 终结符： <code>expr</code>, <code>term</code>, <code>factor</code>.</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, PLUS, MINUS, MUL, DIV, EOF = (</span><br><span class="line">    <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'MINUS'</span>, <span class="string">'MUL'</span>, <span class="string">'DIV'</span>, <span class="string">'EOF'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        <span class="comment"># token type: INTEGER, PLUS, MINUS, MUL, DIV, or EOF</span></span><br><span class="line">        self.type = type</span><br><span class="line">        <span class="comment"># token value: non-negative integer value, '+', '-', '*', '/', or None</span></span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""String representation of the class instance.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">            Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">            Token(PLUS, '+')</span></span><br><span class="line"><span class="string">            Token(MUL, '*')</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Token(&#123;type&#125;, &#123;value&#125;)'</span>.format(</span><br><span class="line">            type=self.type,</span><br><span class="line">            value=repr(self.value)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lexer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="comment"># client string input, e.g. "3 * 5", "12 / 3 * 4", etc</span></span><br><span class="line">        self.text = text</span><br><span class="line">        <span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        self.current_char = self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid character'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Advance the `pos` pointer and set the `current_char` variable."""</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt; len(self.text) - <span class="number">1</span>:</span><br><span class="line">            self.current_char = <span class="literal">None</span>  <span class="comment"># Indicates end of input</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_char = self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">            self.advance()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return a (multidigit) integer consumed from the input."""</span></span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">            result += self.current_char</span><br><span class="line">            self.advance()</span><br><span class="line">        <span class="keyword">return</span> int(result)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">        apart into tokens. One token at a time.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">                self.skip_whitespace()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isdigit():</span><br><span class="line">                <span class="keyword">return</span> Token(INTEGER, self.integer())</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'+'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'-'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'*'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MUL, <span class="string">'*'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'/'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(DIV, <span class="string">'/'</span>)</span><br><span class="line"></span><br><span class="line">            self.error()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lexer)</span>:</span></span><br><span class="line">        self.lexer = lexer</span><br><span class="line">        <span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">        self.current_token = self.lexer.get_next_token()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid syntax'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">        <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">        <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">        <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.lexer.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""factor : INTEGER"""</span></span><br><span class="line">        token = self.current_token</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        <span class="keyword">return</span> token.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""term : factor ((MUL | DIV) factor)*"""</span></span><br><span class="line">        result = self.factor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == MUL:</span><br><span class="line">                self.eat(MUL)</span><br><span class="line">                result = result * self.factor()</span><br><span class="line">            <span class="keyword">elif</span> token.type == DIV:</span><br><span class="line">                self.eat(DIV)</span><br><span class="line">                result = result / self.factor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Arithmetic expression parser / interpreter.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        calc&gt;  14 + 2 * 3 - 6 / 2</span></span><br><span class="line"><span class="string">        17</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        expr   : term ((PLUS | MINUS) term)*</span></span><br><span class="line"><span class="string">        term   : factor ((MUL | DIV) factor)*</span></span><br><span class="line"><span class="string">        factor : INTEGER</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = self.term()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (PLUS, MINUS):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">                self.eat(PLUS)</span><br><span class="line">                result = result + self.term()</span><br><span class="line">            <span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">                self.eat(MINUS)</span><br><span class="line">                result = result - self.term()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># To run under Python3 replace 'raw_input' call</span></span><br><span class="line">            <span class="comment"># with 'input'</span></span><br><span class="line">            text = raw_input(<span class="string">'calc&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        lexer = Lexer(text)</span><br><span class="line">        interpreter = Interpreter(lexer)</span><br><span class="line">        result = interpreter.expr()</span><br><span class="line">        print(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>将以上代码保存到名为 <code>calc5.py</code> 中，或者直接从 <a href="https://github.com/rspivak/lsbasi/blob/master/part5/calc5.py" target="_blank" rel="noopener">GitHub</a> 上下载。和以往一样，自己尝 试一下，确认解释器可以对包含不同优先级操作符的算术表达式进行求值。</p><h2 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h2><p>代码中有三个类(class)，他们中的函数及作用：</p><ol><li><p><code>Token</code>：</p><ul><li><p><code>__init__</code>：初始化实例</p></li><li><p><code>__str__</code>：字符串形式</p></li><li><p><code>__repr__</code>：字符串形式</p><blockquote><p>在Python中，所有以“_<em>”双下划线包起来的方法，都统称为“Magic Method”（魔术方法）,例如类的初始化方法 __init_</em></p><table><thead><tr><th><strong><strong>repr</strong>(self)</strong></th><th>定义当被 repr() 调用时的行为</th></tr></thead><tbody><tr><td><strong><strong>str</strong>(self)</strong></td><td>定义当被 str() 调用时的行为</td></tr></tbody></table></blockquote></li></ul></li><li><p><code>Lexer</code>用于词法分析：</p><ul><li><code>__init__</code>：初始化实例</li><li><code>error</code>：错误提示</li><li><code>advance</code>：使pos前进一个位置</li><li><code>skip_whitespace</code>：略过空格</li><li><code>integer</code>：识别整数（可以识别多位数）</li><li><code>get_next_token</code>：获得一个token（其实我觉得叫做：<code>get_token_and_to_next</code>更合适）</li></ul></li><li><p><code>Interpreter</code>用于语法分析：</p><ul><li><code>__init__</code>：初始化实例</li><li><code>error</code>：错误提示</li><li><code>eat</code>：负责检测当前的token.type与传入的token_type是否相同。若相同，则将当前的token“吃了”，然后把当前token的下一个token分配给current_token。</li><li>下面就是语法分析的核心了，由上面的分析直到，它由：<code>expr</code>、<code>term</code>、<code>factor</code>构成。</li></ul></li></ol><p>梳理完毕。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Let&#39;s Build A Simple Interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let’s Build A Simple Interpreter 4</title>
      <link href="/archives/3b16.html"/>
      <url>/archives/3b16.html</url>
      
        <content type="html"><![CDATA[<p>原文链接：<a href="https://ruslanspivak.com/lsbasi-part4/" target="_blank" rel="noopener">https://ruslanspivak.com/lsbasi-part4/</a></p><p>在前面的文章中你学会了怎样识别和解释包含任意数量的加减操作的算术表达式，例如“7 - 3 + 2 - 1”。还学会了句法图以及它们如何被用来表示一门编程语言的语法。</p><p>今天你将会学习解析(parse)和解释(interpret)包含任意乘除操作的算术表达式，例如“7 * 4 / 2 * 3”。在这篇文章中使用的是整数除法，所以对于表达式“9 / 4”来说，结果是一个 整数：2。</p><p>我今天会讲很多另一个表示编程语言句法的广泛使用的表示法，叫 <strong>上下文无关语法</strong> (context-free grammars, 简记为 grammars)或 <strong>BNF</strong> (Backus-Naur Form)。为了这篇文章的目的，我不会使用纯 <a href="https://en.wikipedia.org/wiki/Backus–Naur_Form" target="_blank" rel="noopener">BNF</a> 记法，而更像是一个修改过的 <a href="https://en.wikipedia.org/wiki/Extended_Backus–Naur_Form" target="_blank" rel="noopener">EBNF</a> 记法。</p><blockquote><p><strong>文法(语法)</strong>：描述语言的语法结构的形式规则。</p><p><strong>上下文无关语法</strong>就是说这个文法中所有的产生式左边只有一个非终结符，比如：</p><p>S -&gt; aSb</p><p>S -&gt; ab<br>这个文法有两个产生式，每个产生式左边只有一个非终结符S，这就是上下文无关文法，因为你只要找到符合产生式右边的串，就可以把它归约为对应的非终结符。</p><p>比如：</p><p>aSb -&gt; aaSbb</p><p>S -&gt; ab<br>这就是上下文相关文法，因为它的第一个产生式左边有不止一个符号，所以你在匹配这个产生式中的S的时候必需确保这个S有正确的“上下文”，也就是左边的a和右边的b，所以叫上下文相关文法。</p><p>作者：徐辰<br>链接：<a href="https://www.zhihu.com/question/21833944/answer/40689967" target="_blank" rel="noopener">https://www.zhihu.com/question/21833944/answer/40689967</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><p>以下是一些使用语法的原因：</p><ol><li>语法使用了一种简明的方式来描述一门编程语言的句法。不像语法图，语法非常紧凑。 在以后的文章中，你会看到我越来越多地使用语法。</li><li>语法可以做为文档保存。</li><li>即使对从头开始写解析器(parser)来说，语法也是一个好的入手点。很多时候通过遵循 一套简单的规则你就可以把语法转化成代码。</li><li>有一套工具，叫解析器生成器(parser generator)，可以把语法做为输入并自动根据它为你生成一个解析器。我会以后在这个系列中谈到这些工具。</li></ol><h2 id="语法机制"><a href="#语法机制" class="headerlink" title="语法机制"></a>语法机制</h2><p>现在，我们来聊聊语法的机制方面：</p><p>下面的语法描述了算术表达式，像“7 * 4 / 2 * 3”这样的（这只是该语法可以生成的许多表达式<strong>之一</strong>）：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200310202232.png" alt="BNF-1"></p><p>语法是由一系列规则组成的，也被称为<strong>产生式(production)</strong>。我们的语法中有两条规则(产生式)：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200310202500.png" alt=""></p><ul><li><p>1、一条规则由：<u>一个非终结符</u>(叫做 <strong>head</strong>或生成式的<strong>左</strong>边) <strong>+</strong> <u>一个分号</u>（:）<strong>+</strong> <u>一系列终结符 和/或 非终结符</u>(叫做 <strong>body</strong> 或 <strong>右边</strong>)：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200310204653.png" alt=""></p></li><li><p>2、在上面展示的语法中，像 MUL, DIV, 或 INTEGER 这样的 token 被称为 <strong>终结符(terminals)</strong>, <code>expr</code> <code>factor</code> 这样的变量被称为 <strong>非终结符(not-terminals)</strong>.</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200310204953.png" alt=""></p></li></ul><p>第一条规则左边的非终结符被叫做 <strong>开始符号(start symbol)</strong>. 在我们的语法中，开始符号是 <em>expr</em>:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200310205155.png" alt=""></p><p>你可以这么理解 <code>expr</code> 这条规则：“expr 是一个 factor 后面可选地跟一个乘或除运算符再跟 另一个 factor，后面也相应可选地跟一个乘或除运算符再跟另一个 factor，如此重复”。</p><p>factor 是什么？对于本文来说 factor 就是一个整数。</p><h3 id="语法中的符号"><a href="#语法中的符号" class="headerlink" title="语法中的符号"></a>语法中的符号</h3><p>让我们快速地过一遍语法中的符号及它们的意义。</p><ul><li><p><code>|</code>多选一。竖线表示“或”。所以 <code>(MUL | DIV)</code> 表示 MUL 或 DIV</p></li><li><p><code>(...)</code>被括号包围表示把终结符 和/或 非终结符组成一组，就像 <code>(MUL | DIV)</code></p></li><li><p><code>(...)*</code>分组中的内容被匹配 0 或 多次。</p></li></ul><p>语法通过解释可以组成什么样的句子来定义一门语言。通过语法派生出算术表达式的方式为：首先从开始符号 <code>expr</code> 开始，然后反复地使用所包含的非终结符的规则替换该非终结符， 直到生成一个<u>只包含终结符的</u>句子。语法能组成的句子构成了一门语言。</p><p>下面举例说明：</p><ul><li><p>例1，下面是语法如何派生出表达式 <code>3</code>:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200310210521.png" alt=""></p></li><li><p>例2，下面是语法如何派生出表达式 <code>3 * 7</code>:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200310210557.png" alt=""></p></li><li><p>例3，下面是语法如何派生出表达式 <code>3 * 7 / 2</code>:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part4_derive3.png" alt="img"></p></li></ul><h2 id="将语法变成代码"><a href="#将语法变成代码" class="headerlink" title="将语法变成代码"></a>将语法变成代码</h2><p>下面是一些我们在把语法转化成源代码时会用到的==四个准则==。按照这些准则，你真的就可以把语法翻译成一个可工作的 parser:</p><ol><li>对于语法中定义的每个规则 R，将它做成一个有相同名字的方法，对该规则的引用就变成了一个方法调用：R()。该方法的方法体遵循该规则的步骤，过程中使用相同的准则。</li><li>多选一 <code>(a1|a2|aN)</code> 变成 <strong>if-elif-else</strong> 语句</li><li>可选组 <code>(...)*</code> 变成一个可以执行 0 或多次的 <strong>while</strong> 循环（can loop over zero or more times）</li><li>每个 Token 记为 T 变成一个 <code>eat</code> 方法调用: <code>eat(T)</code>. <code>eat</code> 方法的工作是 当它匹配到当前的<code>向前看</code> (lookahead) token 就消耗掉它，然后从 lexer 中得到一个新 token 并将它赋值给内部变量 <code>current_token</code>.</li></ol><p>这些准则看上去像这样：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200310211240.png" alt=""></p><p>让我们继续并遵循上述准则把我们的语法转化为代码。</p><p>我们的语法中有两条规则： <code>expr</code> 和 <code>factor</code>. 我们从 <code>factor</code> 规则（生成式）开始。 根据准则，需要新建一个名为 factor 的方法（准则1)，它调用了一次 <code>eat</code> 方法来消耗INTEGER token （准则4)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span>   <span class="comment">#factor就是指的integer型数值</span></span><br><span class="line">    self.eat(INTEGER)</span><br></pre></td></tr></table></figure><p><code>expr</code> 规则变成了 <code>expr</code> 方法（还是准则1）。规则体(body)开始的 <code>factor</code> 引用 变成了对 <code>factor()</code> 方法的调用。可行组 <code>(...)*</code> 变成了一个 <code>while</code> 循环，多选一 <code>(MUL|DIV)</code> 变成了一个 <code>if-elif-else</code> 语句。把这些片段合并在一起就得到了下面的<code>expr</code> 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.factor() <span class="comment">#语法准则中的第一个factor</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">        token = self.current_token</span><br><span class="line">        <span class="keyword">if</span> token.type == MUL:</span><br><span class="line">            self.eat(MUL)</span><br><span class="line">            self.factor()</span><br><span class="line">        <span class="keyword">elif</span> token.type == DIV:</span><br><span class="line">            self.eat(DIV)</span><br><span class="line">            self.factor()</span><br></pre></td></tr></table></figure><p>原作者将本文的代码放在了文件 <code>parser.py</code> 中，它包含了 lexer 和 parser 但没有interpreter。你可以直接从 <a href="https://github.com/rspivak/lsbasi/blob/master/part4/parser.py" target="_blank" rel="noopener">GitHub</a>下载并尝试一下。它包含有一个 interpreter 提示符，你可以输入表达式来查看它是否合法，即查看根据语法建立的 parser 是否可以识别出表达式。</p><p>下面是在我笔记本上的一次尝试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ python parser.py</span><br><span class="line">calc&gt; <span class="number">3</span></span><br><span class="line">calc&gt; <span class="number">3</span> * <span class="number">7</span></span><br><span class="line">calc&gt; <span class="number">3</span> * <span class="number">7</span> / <span class="number">2</span></span><br><span class="line">calc&gt; <span class="number">3</span> *</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"parser.py"</span>, line <span class="number">155</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    main()</span><br><span class="line">  File <span class="string">"parser.py"</span>, line <span class="number">151</span>, <span class="keyword">in</span> main</span><br><span class="line">    parser.parse()</span><br><span class="line">  File <span class="string">"parser.py"</span>, line <span class="number">136</span>, <span class="keyword">in</span> parse</span><br><span class="line">    self.expr()</span><br><span class="line">  File <span class="string">"parser.py"</span>, line <span class="number">130</span>, <span class="keyword">in</span> expr</span><br><span class="line">    self.factor()</span><br><span class="line">  File <span class="string">"parser.py"</span>, line <span class="number">114</span>, <span class="keyword">in</span> factor</span><br><span class="line">    self.eat(INTEGER)</span><br><span class="line">  File <span class="string">"parser.py"</span>, line <span class="number">107</span>, <span class="keyword">in</span> eat</span><br><span class="line">    self.error()</span><br><span class="line">  File <span class="string">"parser.py"</span>, line <span class="number">97</span>, <span class="keyword">in</span> error</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">'Invalid syntax'</span>)</span><br><span class="line">Exception: Invalid syntax</span><br></pre></td></tr></table></figure><p>这里再次提起语法图。这是相同的 <code>expr</code> 规则（也叫，产生式(production)）对应的句法图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200310212342.png" alt="expr"></p><p>下面是原作者的关于本文的源码。下面是可以处理包含任意数量整数 乘除（整数除法）操作的合法的算术表达式的计算器代码。这里把词法分析器重构 到了一个单独的类 <code>Lexer</code> 中，并让 <code>Interpreter</code> 类使用 <code>Lexer</code> 实例做为参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, MUL, DIV, EOF = <span class="string">'INTEGER'</span>, <span class="string">'MUL'</span>, <span class="string">'DIV'</span>, <span class="string">'EOF'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        <span class="comment"># token type: INTEGER, MUL, DIV, or EOF</span></span><br><span class="line">        self.type = type</span><br><span class="line">        <span class="comment"># token value: non-negative integer value, '*', '/', or None</span></span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""String representation of the class instance.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">            Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">            Token(MUL, '*')</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Token(&#123;type&#125;, &#123;value&#125;)'</span>.format(</span><br><span class="line">            type=self.type,</span><br><span class="line">            value=repr(self.value)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"></span><br><span class="line"><span class="comment">#词法分析</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lexer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="comment"># client string input, e.g. "3 * 5", "12 / 3 * 4", etc</span></span><br><span class="line">        self.text = text</span><br><span class="line">        <span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        self.current_char = self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid character'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Advance the `pos` pointer and set the `current_char` variable."""</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt; len(self.text) - <span class="number">1</span>:</span><br><span class="line">            self.current_char = <span class="literal">None</span>  <span class="comment"># Indicates end of input</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_char = self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">            self.advance()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return a (multidigit) integer consumed from the input."""</span></span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">            result += self.current_char</span><br><span class="line">            self.advance()</span><br><span class="line">        <span class="keyword">return</span> int(result)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#不如叫做：get_token_and_next</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">        apart into tokens. One token at a time.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">                self.skip_whitespace()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isdigit():</span><br><span class="line">                <span class="keyword">return</span> Token(INTEGER, self.integer())</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'*'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MUL, <span class="string">'*'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'/'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(DIV, <span class="string">'/'</span>)</span><br><span class="line"></span><br><span class="line">            self.error()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lexer)</span>:</span></span><br><span class="line">        self.lexer = lexer</span><br><span class="line">        <span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">        self.current_token = self.lexer.get_next_token()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid syntax'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">        <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">        <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">        <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.lexer.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return an INTEGER token value.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        factor : INTEGER</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        token = self.current_token</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        <span class="keyword">return</span> token.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Arithmetic expression parser / interpreter.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        expr   : factor ((MUL | DIV) factor)*</span></span><br><span class="line"><span class="string">        factor : INTEGER</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = self.factor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == MUL:</span><br><span class="line">                self.eat(MUL)</span><br><span class="line">                result = result * self.factor()</span><br><span class="line">            <span class="keyword">elif</span> token.type == DIV:</span><br><span class="line">                self.eat(DIV)</span><br><span class="line">                result = result / self.factor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># To run under Python3 replace 'raw_input' call</span></span><br><span class="line">            <span class="comment"># with 'input'</span></span><br><span class="line">            text = raw_input(<span class="string">'calc&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        lexer = Lexer(text)</span><br><span class="line">        interpreter = Interpreter(lexer)</span><br><span class="line">        result = interpreter.expr()</span><br><span class="line">        print(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>将以上代码保存到名为 <code>calc4.py</code> 中，或者直接从 <a href="https://github.com/rspivak/lsbasi/blob/master/part4/calc4.py" target="_blank" rel="noopener">GitHub</a> 上下载。和以往一样，自己尝 试一下，确认它能工作。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Let&#39;s Build A Simple Interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let’s Build A Simple Interpreter 3</title>
      <link href="/archives/f957.html"/>
      <url>/archives/f957.html</url>
      
        <content type="html"><![CDATA[<p>原文链接：<a href="https://ruslanspivak.com/lsbasi-part3/" target="_blank" rel="noopener">https://ruslanspivak.com/lsbasi-part3/</a></p><p>目前为止，你已经学习了如何解释整数相加或相减的算术表达式如“7+3”或“12-9”。今天我 会聊一聊怎样解析（识别）并解释包含多位整数的加减法的算术表达式，如“7 - 3 + 2 - 1”。</p><h2 id="语法图"><a href="#语法图" class="headerlink" title="语法图"></a>语法图</h2><p>本文中的算术表达式可以用如下的语法图(syntax diagram)表示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part3_syntax_diagram-1583822487945.png" alt="语法图"></p><blockquote><p><strong>语法图(syntax diagram)</strong>：就是程序语言句法规则的图形表示。基本上，语法图从视觉上向你展示了在你的程序语言中哪些语句是允许的哪些是不允许的。</p></blockquote><p>句法图很容易阅读：只需跟随箭头所指示的路径即可。一些路径表示选择，一些路径表示循环。</p><p>你可以这样阅读上面的句法图：一个 term 后面可以跟一个加号或减号，后面又跟另一个 term， 相应地它后面又可以跟一个加号或减号，后面又跟另一个 term，如此循环。你已经读懂了 这幅图片，真的。<u>你可能会疑惑什么是“term”。在这篇文章中“term”就是一个整数。</u></p><h3 id="语法图的用途"><a href="#语法图的用途" class="headerlink" title="语法图的用途"></a>语法图的用途</h3><p>本文中的语法图主要有两个用途：</p><ul><li>从图形上表示一个编程语言的标准（语法）。</li><li>用来帮助你编写parser(语法分析器)，你可以通过下面简单的规则将图映射到代码。</li></ul><h2 id="语法分析器"><a href="#语法分析器" class="headerlink" title="语法分析器"></a>语法分析器</h2><p>你已经学过了从 token 流中识别组合的过程叫 <strong>parsing</strong>. 且解释器或编译器中执行这部分任务的叫 <strong>parser</strong>. parsing也被称为 <strong>语法分析</strong> (syntax analysis)，parser也相应地被称为<strong>语法分析器</strong>(syntax analyzer)，你应该也猜到这点了。</p><p>根据上面的句法图，下面所有的算术表达式都是合法的：</p><ul><li>3</li><li>3 + 4</li><li>7 - 3 + 2 - 1</li></ul><p>因为在不同的程序语言中算术表达式的句法规则都相似，我们可以使用 Python shell 来 “测试”我们的句法图。启动 Python shell 自己试一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> + <span class="number">4</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">7</span> - <span class="number">3</span> + <span class="number">2</span> - <span class="number">1</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>一切正常。</p><p>但表达式“3+”就不是合法的算术表达式，因为根据句法图加号后面必须跟一个 term（整数）， 否则就是句法错误。两次启动 Python shell 自己查看结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> +</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    <span class="number">3</span> +</span><br><span class="line">      ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><p>使用 Python shell 来做测试是挺不错的，不过我们还是把上面的句法图映射到代码，用我 们自己的解释器来测试，是吧？</p><p>从前面的文章（<a href="http://ruslanspivak.com/lsbasi-part1/" target="_blank" rel="noopener">第一部分</a>和<a href="http://ruslanspivak.com/lsbasi-part2/" target="_blank" rel="noopener">第二部分</a>）你知道了 parser 和 interpreter 都在 <code>expr</code> 方 法中。再重复一下，parser只是识别出结构并保证它符合某些规范，interpreter在parser成功识别后对表达式进行求值。</p><p>下面的代码片段展示了与句语法图相对应的 parser 的代码。语法图中的矩形盒子变成了解析一个整数的 <code>term</code> 方法， <code>expr</code> 方法则只是跟随了语法图的指示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span>    </span><br><span class="line">    self.eat(INTEGER)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span>    </span><br><span class="line"><span class="comment"># set current token to the first token taken from the input  </span></span><br><span class="line">self.current_token = self.get_next_token()    </span><br><span class="line">        </span><br><span class="line">self.term()    </span><br><span class="line"><span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (PLUS, MINUS):</span><br><span class="line">token = self.current_token</span><br><span class="line">        <span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">self.eat(PLUS)</span><br><span class="line">self.term()</span><br><span class="line"><span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">self.eat(MINUS)</span><br><span class="line">self.term()</span><br></pre></td></tr></table></figure><p>可以看到 <code>expr</code> 方法首先调用了 <code>term</code> 方法。然后是一个可能执行 0 或多次的循环。 在循环中，parser 根据 token （是加号还是减号）来做选择。</p><p><strong>Parser 本身并不解释任何事</strong>：如果识别到一个表达式它就沉默，否则就抛出一个句法错误。 让我们修改 <code>expr</code> 方法来添加 interpreter 代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Return an INTEGER token value"""</span></span><br><span class="line">    token = self.current_token</span><br><span class="line">    self.eat(INTEGER)</span><br><span class="line">    <span class="keyword">return</span> token.value</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Parser / Interpreter"""</span></span><br><span class="line">    <span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">    self.current_token = self.get_next_token()</span><br><span class="line"></span><br><span class="line">    result = self.term()</span><br><span class="line">    <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (PLUS, MINUS):</span><br><span class="line">token = self.current_token</span><br><span class="line"><span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">    self.eat(PLUS)</span><br><span class="line">    result = result += self.term()</span><br><span class="line"><span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">    self.eat(MINUS)</span><br><span class="line">    result = result - self.term()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>因为 interpreter 需要对表达式进行求值，所以 <code>term</code> 方法被修改为返回一个整数值， <code>expr</code> 方法被修改为在适当的地方执行加减法并返回解释的结果。</p><p>让我们继续前进，来看一下现在解释器的完整代码怎么样？</p><p>下面是你新版计算器的源代码，它可以处理包含任意多个整数的加减操作的合法算术表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Token的类型：'INTEGER', 'PLUS', 'MINUS', 'EOF'</span></span><br><span class="line"><span class="comment"># Token的值(value)：整数，'+', '-', or None</span></span><br><span class="line">INTEGER, PLUS, MINUS, EOF = <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'MINUS'</span>, <span class="string">'EOF'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义Token类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        self.type = type</span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Token( &#123;type&#125;, &#123;value&#125; ) '</span> .format(</span><br><span class="line">            type = self.type ,</span><br><span class="line">            value = repr(self.value) <span class="comment">#repr与下面的__repr__不一样，下面的是重构的。</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        self.currrent_token = <span class="literal">None</span> <span class="comment">#此时还没有token实例所以是None</span></span><br><span class="line">        self.current_char =self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="comment">##########################################################</span></span><br><span class="line">    <span class="comment">#                       Lexer code                       #</span></span><br><span class="line">    <span class="comment">##########################################################</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid syntax'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt; len(self.text) <span class="number">-1</span> :</span><br><span class="line">            self.current_char =<span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_char = self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">            self.advance()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span></span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">            result += self.current_char</span><br><span class="line">            self.advance()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> int(result)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#词法分析(分析之后形成一个个的token)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">                self.skip_whitespace()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment">#识别整数</span></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isdigit():</span><br><span class="line">                <span class="keyword">return</span> Token(INTEGER, self.integer() )</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 识别是否为+ - 运算符号</span></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'+'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'-'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line"></span><br><span class="line">            self.error()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    <span class="comment">##########################################################</span></span><br><span class="line">    <span class="comment">#               Parser / Interpreter code                #</span></span><br><span class="line">    <span class="comment">##########################################################</span></span><br><span class="line">    <span class="comment">#比较当前的token的类型与传来的类型是否相同</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.currrent_token.type == token_type:</span><br><span class="line">            self.currrent_token = self.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#返回一个整型的token的value</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">        token = self.currrent_token</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        <span class="keyword">return</span> token.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.currrent_token = self.get_next_token()</span><br><span class="line"></span><br><span class="line">        result = self.term()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.currrent_token.type <span class="keyword">in</span> (PLUS , MINUS):</span><br><span class="line">            <span class="comment">#循环是为了算不止一次的加or减法，从而达到混合运算的目的</span></span><br><span class="line">            token = self.currrent_token</span><br><span class="line">            <span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">                self.eat(PLUS)</span><br><span class="line">                result = result + self.term()</span><br><span class="line">            <span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">                self.eat(MINUS)</span><br><span class="line">                result = result - self.term()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># To run under Python3 replace 'raw_input' call</span></span><br><span class="line">            <span class="comment"># with 'input'</span></span><br><span class="line">            text = input(<span class="string">'calc&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        interpreter = Interpreter(text)</span><br><span class="line">        result = interpreter.expr()</span><br><span class="line">        print(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>将以上代码保存到名为 <code>calc3.py</code> 中，或者直接从 <a href="https://github.com/rspivak/lsbasi/blob/master/part3/calc3.py" target="_blank" rel="noopener">GitHub</a> 上下载。试一试。亲眼看一下 它可以处理之前展示给你的句法图中包含的算术表达式规则。</p><h2 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h2><ol><li>输入字符串表达式（如“2+8-6+1”)，存入变量text中</li><li>将text进行词法分析，执行此功能的是<code>get_next_token()</code>函数，词法分析会生成一个个的token</li><li>然后对词法分析之后的token按照规定的语法，进行语法分析，相应函数为<code>expr()</code></li><li>最后输出结果</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Let&#39;s Build A Simple Interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3、布尔逻辑和逻辑门</title>
      <link href="/archives/87ef.html"/>
      <url>/archives/87ef.html</url>
      
        <content type="html"><![CDATA[<p>计算机最早的是机电设备，一般使用十进制计数，比如用齿轮数来代表十进制。但是其实只用开/关两种状态已经足够表示信息了，将其称为<strong>二进制（Binary）</strong>。</p><a id="more"></a><p>在计算机中，当电流流过时，为闭合状态，表示true（1），当没有电流流过时，为断开状态，表示false（0）。但是其实晶体管可以不只是开/关状态，还可以让不同大小的电流通过，一些早期电子计算机，通过对不同电流大小进行划分，可以使用三进制、五进制等等。但问题是，状态越多就越难区分信号，如果存在电噪音，可能就会使状态十分混乱。所以为了让信号更加清晰，可以只使用“开”和“关”两种状态。</p><p>另一个使用二进制的原因是，有一整个数学分支专门处理“真”和“假”，它已解决了所有法则和运算，即<strong>布尔代数（Boolean Algebra）</strong>。</p><h1 id="布尔代数（Boolean-Algebra）与逻辑门"><a href="#布尔代数（Boolean-Algebra）与逻辑门" class="headerlink" title="布尔代数（Boolean Algebra）与逻辑门"></a>布尔代数（Boolean Algebra）与逻辑门</h1><p>在布尔代数中，变量的值是true和false，能够对其进行逻辑操作。布尔代数中有三个<strong>基本操作：</strong>NOT、AND和OR。</p><h2 id="NOT-GATE"><a href="#NOT-GATE" class="headerlink" title="NOT GATE"></a>NOT GATE</h2><p><strong>NOT</strong>：把输出端（就像水龙头左边部分送水，它送电）接在上面的电极，如果打开输出，电流就可以流过，然后“接地”，输出就没有电流，所以输出是off。当输入关闭时，电流没法接地，就流过了输出，所以输出是on。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310011249234.png" alt="NOT GATE"></p><p>就像是水龙头一样：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310014800881.png" alt="水龙头关着"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310015120188.png" alt="水龙头开着"></p><p>​</p><p>​ <strong>NOT操作：</strong>把布尔值进行翻转，所以NOT操作的真值表为</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310011832488.png" alt="NOT 真值表"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310020424245.png" alt="NOT GATE的表示图"></p><h2 id="AND-GATE"><a href="#AND-GATE" class="headerlink" title="AND GATE"></a>AND GATE</h2><p><strong>AND</strong>：为了实现“AND 门”，我们需要2个晶体管连接在一起，这样有2个输入和1个输出。如果只打开A，不打开B，电流无法留到output，所以输出是false；如果只打开B，不打开A，也一样，电流无法留到output；只有当A、B都打开了，output才有电流。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310012335375.png" alt="image-20200310012335375"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310020520507.png" alt="AND GATE表示图"></p><h2 id="OR-GATE"><a href="#OR-GATE" class="headerlink" title="OR GATE"></a>OR GATE</h2><p><strong>OR</strong>：实现OR 门除了晶体管还需要额外的线将两个晶体管(transistor)并联起来，即得到OR GATE</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/v2-fda2d5cd50eb2f760f0a2ac72eb5efe5_720w.jpg" alt="OR GATE"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310020006112.png" alt="image-20200310020006112"></p><p>左侧电极为电源，下方两个电极分别表示两个输入，右侧电极为输出。只要任意一个输入开启，就能使得电源和输出电极接通，使得输出开启；当两个输入都关闭时，就使得电源和输出电极保持断开状态，使得输出保持关闭。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310020600225.png" alt="OR GATE表示图"></p><p>由此通过上方的三个组件（NOT门、AND门和OR门）可以构建出更加复杂的组件。另一个常见的布尔操作叫做<strong>异或操作</strong>。</p><h2 id="XOR-异或"><a href="#XOR-异或" class="headerlink" title="XOR(异或)"></a>XOR(异或)</h2><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310020826408.png" alt="XOR"></p><p>我们有两个输入，A和B，还有一个输出。先放一个OR门。因为OR和XOR的逻辑表很像，只有一个不同点就是：当两个输入都为true时，XOR输出false，而OR输出true。通过对AND操作真值表取反，再和OR操作真值表进行对比，可以发现，第二三行都为true，而第一四行结果不同，因此只要在这两个结果后面加个AND就能得到XOR的真值表。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>操作真值表：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310021526100.png" alt="XOR操作真值表"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310021854665.png" alt="NOT操作真值表"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/v2-eb0326d9127258653005333d2d1c59a6_720w.jpg" alt="AND操作真值表"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/v2-088dbb26ce45d8e512140426f6e3bb62_720w.jpg" alt="OR操作真值表"></p><p>对应的罗基本表示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310022102365.png" alt="逻辑门的表示图"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学速成课 </tag>
            
            <tag> 布尔逻辑和逻辑门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let’s Build A Simple Interpreter 2</title>
      <link href="/archives/d57d.html"/>
      <url>/archives/d57d.html</url>
      
        <content type="html"><![CDATA[<p>If you learn only methods, you’ll be tied to your methods. But if you learn<br>principles, you can devise your own methods.</p><a id="more"></a><p>原文地址：<a href="https://ruslanspivak.com/lsbasi-part2/" target="_blank" rel="noopener">https://ruslanspivak.com/lsbasi-part2/</a></p><p>这是第二个版本V2.0，第二个版本较第一个版V1.0，它可以做到：</p><ol><li>处理输入字符串中任何位置的空白符</li><li>处理输入中的多位数</li><li>两个整数相减（版本V1.0中只有加法）</li></ol><p>下面先给出V2.0的新版计算器的源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, PLUS, MINUS, EOF = <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'MINUS'</span>, <span class="string">'EOF'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line"><span class="comment"># token type: 'INTEGER', 'PLUS', 'MINUS', or 'EOF'</span></span><br><span class="line">self.type  = type</span><br><span class="line"><span class="comment"># token value: non-negative integer value, '+', '-', or None</span></span><br><span class="line">self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""String representation of class instance</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Examples:</span></span><br><span class="line"><span class="string">    Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">    Token(PLUS, '+')</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">f'Token(<span class="subst">&#123;self.type&#125;</span>, <span class="subst">&#123;self.value&#125;</span>)'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">return</span> self.__str__()</span><br><span class="line"><span class="comment">##__repr__() 与 __str__() 的主要区别在于，前者在交互式步骤中显示结果，后者在 print 函数中显示结果。</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line"><span class="comment"># client string input, e.g. "3 + 5", "12 - 5", etc</span></span><br><span class="line">self.text = text</span><br><span class="line"><span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">self.pos  = <span class="number">0</span></span><br><span class="line"><span class="comment"># current token instance</span></span><br><span class="line">self.current_token = <span class="literal">None</span></span><br><span class="line">self.current_char  = self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">raise</span> Exception(<span class="string">'Error parsing input'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">########新增#######</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""Advance the 'pos' pointer and set the 'current_char' variable."""</span></span><br><span class="line">self.pos += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> self.pos &gt;= len(self.text):</span><br><span class="line">    self.current_char = <span class="literal">None</span>  <span class="comment"># Indicates end of input</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    self.current_char = self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">    self.advance()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""Return a (multidigit) integer consumed from the input."""</span></span><br><span class="line">result = <span class="string">''</span></span><br><span class="line"><span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">    result += self.current_char</span><br><span class="line">    self.advance()</span><br><span class="line"><span class="keyword">return</span> int(result)</span><br><span class="line">  <span class="comment">##新增 完毕#####</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">apart into tokens.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">self.skip_whitespace()</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> self.current_char.isdigit():</span><br><span class="line"><span class="keyword">return</span> Token(INTEGER, self.integer())</span><br><span class="line">    <span class="keyword">if</span> self.current_char == <span class="string">'+'</span>:</span><br><span class="line">self.advance()</span><br><span class="line"><span class="keyword">return</span> Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line">    <span class="keyword">if</span> self.current_char == <span class="string">'-'</span>:</span><br><span class="line">self.advance()</span><br><span class="line"><span class="keyword">return</span> Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line"></span><br><span class="line">    self.error()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line"><span class="comment"># compare the current token type with the passed token</span></span><br><span class="line"><span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line"><span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line"><span class="comment"># otherwise raise an exception.</span></span><br><span class="line"><span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">    self.current_token = self.get_next_token()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    self.error()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""Parser / Interpreter</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">expr -&gt; INTEGER PLUS INTEGER</span></span><br><span class="line"><span class="string">expr -&gt; INTEGER MINUS INTEGER</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># set current token to the first token from the input</span></span><br><span class="line">self.current_token = self.get_next_token()</span><br><span class="line"></span><br><span class="line"><span class="comment"># we expect the current token to be an integer</span></span><br><span class="line">left = self.current_token</span><br><span class="line">self.eat(INTEGER)</span><br><span class="line"></span><br><span class="line"><span class="comment"># we expect the current token to be either a '+' or '-'</span></span><br><span class="line">op = self.current_token</span><br><span class="line"><span class="keyword">if</span> op.type == PLUS:</span><br><span class="line">    self.eat(PLUS)</span><br><span class="line"><span class="keyword">elif</span> op.type == MINUS:</span><br><span class="line">    self.eat(MINUS)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    self.error()</span><br><span class="line"></span><br><span class="line"><span class="comment"># we expect the current token to be an integer</span></span><br><span class="line">right = self.current_token</span><br><span class="line">self.eat(INTEGER)</span><br><span class="line"><span class="comment"># after the above call the self.current_token is set to</span></span><br><span class="line"><span class="comment"># EOF token</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># at this point either the INTEGER PLUS INTEGER or</span></span><br><span class="line"><span class="comment"># the INTEGER MINUS INTEGER sequence of tokens</span></span><br><span class="line"><span class="comment"># has been successfully found and the method can just</span></span><br><span class="line"><span class="comment"># return the result of adding or subtracting two integers,</span></span><br><span class="line"><span class="comment"># thus effectively interpreting client input</span></span><br><span class="line"><span class="keyword">if</span> op.type == PLUS:</span><br><span class="line">    result = left.value + right.value</span><br><span class="line"><span class="keyword">elif</span> op.type == MINUS:</span><br><span class="line">    result = left.value - right.value</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    self.error()</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># To run under Python3 replace 'raw_input' call with 'input'</span></span><br><span class="line">    text = input(<span class="string">'calc&gt; '</span>)</span><br><span class="line"><span class="keyword">except</span> EOFError:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">interpreter = Interpreter(text)</span><br><span class="line">result      = interpreter.expr()</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>把以上代码保存到名为 <code>calc2.py</code> 中，或者直接从 <a href="https://github.com/rspivak/lsbasi/blob/master/part2/calc2.py" target="_blank" rel="noopener">GitHub</a> 上下载。试一试。亲眼看一下 它可以按预期运行：它可以处理输入中的任何位置的空白符；它接受多位整数，除了整数相 加还可以处理整数相减。</p><p>下面可以再笔记本上次尝试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python calc2.py</span><br><span class="line">calc&gt; <span class="number">27</span> + <span class="number">3</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line">calc&gt; <span class="number">27</span> - <span class="number">7</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line">calc&gt;</span><br></pre></td></tr></table></figure><p>与<a href="http://ruslanspivak.com/lsbasi-part1/" target="_blank" rel="noopener">第一部分</a>相比代码的主要变化有：</p><ol><li><code>get_next_token</code> 方法做了一点重构。增加指针 <code>pos</code> 的逻辑被重构到了方法 <code>advance</code> 中。</li><li>增加了两个方法： <code>skip_whitespace</code> 用来忽略空白符， <code>integer</code> 用来处理输入中的多位整数。</li><li><code>expr</code> 方法在修改后，除了可以识别 INTEGER -&gt; PLUS -&gt; INTEGER 这个组合(phrase) 之外，还可以识别INTEGER -&gt; MINUS -&gt; INTEGER。而且在成功识别相应的组合后，也可以进行相应的加减操作。</li></ol><p>在<a href="http://ruslanspivak.com/lsbasi-part1/" target="_blank" rel="noopener">第一部分</a>你尝到了两个重要的概念，即 <strong>token</strong> 和 <strong>词法分析器</strong> 。今天我想聊一聊 <strong>lexeme</strong> 、 <strong>parsing</strong> 和 <strong>parser</strong> 。</p><p>你已经知道 token 了。但为了叙述方便，需要介绍一下 lexeme。什么是 lexeme？ lexeme 是组成 token 的一个字符序列。在下面的图片中是一些 token 和 lexeme 的例子， 希望它能把两者之间的关系表达清楚：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part2_lexemes.png" alt="img"></p><p>现在还记得 <code>expr</code> 方法吗？我以前说过这是真正解释算术表达式的地方。但在解释一个表达式之前，你需要知道它是哪种组合，比如相加或相减。这是 <code>expr</code> 方法本质上做的事： 它从 <code>get_next_token</code> 方法得到的 token 流中找到结构，然后解释它识别出的组合，产 生算术表达式的结果。</p><p>又到了做练习的时间了。</p><ol><li>扩展计算器以处理两个整数相乘</li><li>扩展计算器以处理两个整数相除</li><li>修改代码以使它可以解释包含任意个数字的加减操作，如“9 - 5 + 3 + 11”</li></ol><p>本节检测：</p><ol><li>什么是 lexeme？</li><li>在 token 流中找到结构的过程叫什么？或者这么问，在 token 流中识别出特定组合的过程叫什么？</li><li>解释器（编译器）做 parsing 工作的部分叫什么？</li></ol><hr><p><strong>梳理</strong>：</p><ol><li>首先输入一个表达式，如“3+9”，送给解释器<strong><code>Interpreter</code></strong></li><li>开始对这个表达式拆分成一个个的token，这一步叫做词法分析，由<strong>词法分析器</strong>(lexical analyzer)来完成。在本文中，函数<strong><code>get_next_token</code></strong>就相当于词法分析器。<ul><li>词法分析器<code>get_next_token</code>处理完之后的是一个个的<code>token(type , value)</code></li></ul></li><li>然后开始进行语法分析（由于本文中只实现了加法、减法），所以这里的语法分析就是分析：加、减法的表达式。执行这个步骤的是<strong><code>expr</code></strong>函数，其中<code>expr</code> 方法使用了辅助方法<strong><code>eat</code></strong>来验证传给token的类型与当前类型是否相匹配。与现有语法规则（即，加法规则和减法规则）不匹配，<code>eat</code>就会抛出异常。</li><li>语法分析完成之后，就直接得出算式的结果。（这也很符合解释器的特性嘛：边解释边执行，不会生成目标代码）</li></ol><p>其他的函数：</p><p><code>Interpreter</code></p><ul><li><code>error(self)</code>：当有错误的时候，就调用它</li><li><code>advance(self)</code>：增加指针pos的作用，即，将指向下一个token</li><li><code>skip_whitespace(self)</code>：跳过空格，V2.0新增加的功能</li><li><code>integer(self)</code>：为了可以算多位数的加减法。<ul><li>这里要注意：如3和233是两个整数类型的token，但是值得注意的是这篇文章中的token是按照输入的一串字符串（如“3+155”）每一个都当成一个token。也就是说本来155是一个token，但是从细节上看，在代码实现中155是被当成了三次“token”然后经过<code>integer</code>函数才形成了最终形体155这个token。</li></ul></li></ul><hr><p>在本系列的下一篇文章中你会扩展你的计算器来处理更复杂的算术表达式。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Let’s Build A Simple Interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let’s Build A Simple Interpreter 1</title>
      <link href="/archives/427485bf.html"/>
      <url>/archives/427485bf.html</url>
      
        <content type="html"><![CDATA[<hr><hr><p>为什么要你学解释器和编译器？这里有三条理由。</p><a id="more"></a><ol><li>要写一个解释器或编译器，你必须同时用到很多技术。编写一个解释器或编译器会帮助 你提高这些技能并且成为一个更好的软件开发者。而且，你将学到的这些技能在开发任 何软件时都有可能用到，而不仅仅是解释器或编译器。</li><li>你确实想要知道计算机如何工作。一般解释器和编译器看上去都像魔法一样。但你不应 该对这些魔法感到舒服。你想要揭开解释器和编译器的神秘面纱，理解它们如何工作并 控制所有一切。</li><li>你想要创造自己的编程语言或者领域特定语言。如果是这样，你就需要为这个语言创建 一个解释器或编译器。最近，创建新语言再度兴起。你几乎每天都可以看到一门新语言 的诞生：Elixir, Go, Rust 等。</li></ol><p>原文链接：<a href="https://ruslanspivak.com/lsbasi-part1/" target="_blank" rel="noopener">https://ruslanspivak.com/lsbasi-part1/</a></p><p>好了，但什么是<strong>解释器</strong>和<strong>编译器</strong>呢？</p><h1 id="解释器与编译器"><a href="#解释器与编译器" class="headerlink" title="解释器与编译器"></a>解释器与编译器</h1><p>解释器与编译器都是“高级语言与机器之间的翻译官”。都是将代码翻译成机器可以执行的二进制机器码，只不过在运行原理和翻译过程不同。</p><p>那它们的区别在于：</p><ul><li>编译器：先整体编译完，然后<strong>一次性</strong>执行。比如：C语言代码被编译成二进制代码（exe程序），在windows平台上执行。</li><li>解释器：解释一句后就提交计算机执行一句，即边解释边执行。比如php，postscritp，javascript就是典型的解释性语言。</li></ul><blockquote><p>用一个通俗的例子来讲：我们去饭馆吃饭，点了八菜一汤。<strong>编译器</strong>的方式就是厨师把所有的菜给你全做好了，一起给你端上来，至于你在哪吃，怎么吃，随便。<strong>解释器</strong>的方式就是厨师做好一个菜给你上一个菜，你就吃这个菜，而且必须在饭店里吃。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200309170643.png" alt="解释器与编译器的区别"></p><p>编译器与解释器的工作流程的差别：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20160918194226830.jpg" alt="编译器与解释器的工作流程的差别"></p><p>编译器与解释器的各自的特点：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200309171531.png" alt="各自特点"></p><h1 id="构造解释器V1-0"><a href="#构造解释器V1-0" class="headerlink" title="构造解释器V1.0"></a>构造解释器V1.0</h1><p>该系列文章的作者使用 Python 编写Pascal语言的解释器。</p><p>第一版V1.0，构造的计算器有诸多限制。如：</p><ul><li>只输入一位的数字</li><li>现阶段仅支持加法操作</li><li>输入中不允许有空白符</li></ul><p>这些约束使得构建一个计算器很简单，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Token types：</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, PLUS, EOF = <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'EOF'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line"><span class="comment"># token type: INTEGER, PLUS, or EOF</span></span><br><span class="line">self.type  = type</span><br><span class="line"><span class="comment"># token value: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, '+', or None</span></span><br><span class="line">self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""String representation of the class instance.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Examples:</span></span><br><span class="line"><span class="string">    Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">    Token(PLUS, '+')</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">'Token(&#123;type&#125;, &#123;value&#125;)'</span>.format(</span><br><span class="line">    type=self.type,</span><br><span class="line">    value=repr(self.value)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">return</span> self.__str__()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line"><span class="comment"># client string input, e.g. "3+5"</span></span><br><span class="line">self.text = text</span><br><span class="line"><span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">self.pos  = <span class="number">0</span></span><br><span class="line"><span class="comment"># current token instance</span></span><br><span class="line">self.current_token = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">raise</span> Exception(<span class="string">'Error parsing input'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">apart into tokens. One token at a time.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">text = self.text</span><br><span class="line"></span><br><span class="line"><span class="comment"># is self.pos index past the end of the self.text ?</span></span><br><span class="line"><span class="comment"># if so, then return EOF token because there no more</span></span><br><span class="line"><span class="comment"># input left to convert into tokens</span></span><br><span class="line"><span class="keyword">if</span> self.pos &gt; len(text) - <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get a character at the position self.pos and decide</span></span><br><span class="line"><span class="comment"># what token to create based on the single character</span></span><br><span class="line">current_char = text[self.pos]</span><br><span class="line"></span><br><span class="line"><span class="comment"># if the character is a digit then convert it to</span></span><br><span class="line"><span class="comment"># integer, create an INTEGER token, increment self.pos</span></span><br><span class="line"><span class="comment"># index to point to the next character after the digit,</span></span><br><span class="line"><span class="comment"># and return the INTEGER token</span></span><br><span class="line"><span class="keyword">if</span> current_char.isdigit():</span><br><span class="line">    token     = Token(INTEGER, int(current_char))</span><br><span class="line">    self.pos += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> token</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> current_char == <span class="string">'+'</span>:</span><br><span class="line">    token     = Token(PLUS, current_char)</span><br><span class="line">    self.pos += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> token</span><br><span class="line"></span><br><span class="line">self.error()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line"><span class="comment"># compare the current token type with the passed token</span></span><br><span class="line"><span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line"><span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line"><span class="comment"># otherwise raise an exception.</span></span><br><span class="line"><span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">    self.current_token = self.get_next_token()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    self.error()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""expr -&gt; INTEGER PLUS INTEGER"""</span></span><br><span class="line"><span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">self.current_token = self.get_next_token()</span><br><span class="line"></span><br><span class="line"><span class="comment"># we expect the current token to be a single-digit integer</span></span><br><span class="line">left = self.current_token</span><br><span class="line">self.eat(INTEGER)</span><br><span class="line"></span><br><span class="line"><span class="comment"># we expect the current token to be a '+' token</span></span><br><span class="line">op = self.current_token</span><br><span class="line">self.eat(PLUS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># we expect the current token to be a single-digit integer</span></span><br><span class="line">right = self.current_token</span><br><span class="line">self.eat(INTEGER)</span><br><span class="line"><span class="comment"># after the above call the self.current_token is set to</span></span><br><span class="line"><span class="comment"># EOF token</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># at this point INTEGER PLUS INTEGER sequence of tokens</span></span><br><span class="line"><span class="comment"># has been successfully found and the method can just</span></span><br><span class="line"><span class="comment"># return the result of adding two integers, thus</span></span><br><span class="line"><span class="comment"># effectively interpreting client input</span></span><br><span class="line">result = left.value + right.value</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># To run under Python3 replace 'raw_input' call with 'input'</span></span><br><span class="line">    text = input(<span class="string">'calc&gt; '</span>)</span><br><span class="line"><span class="keyword">except</span> EOFError:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">interpreter = Interpreter(text)</span><br><span class="line">result = interpreter.expr()</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>把以上代码保存到名为 <code>calc1.py</code> 中，或者直接从 <a href="https://github.com/rspivak/lsbasi/blob/master/part1/calc1.py" target="_blank" rel="noopener">GitHub</a> 上下载。在你开始仔细研究代 码之前，在命令行上运行这个计算器并看它实现运行。把玩一下！下面是在我笔记本上的一 次尝试（如果你想在 Python3 下运行，就需要把 <code>raw_input</code> 替换为 input）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ python calc1.py</span><br><span class="line">calc&gt; 3+4</span><br><span class="line">7</span><br><span class="line">calc&gt; 3+5</span><br><span class="line">8</span><br><span class="line">calc&gt; 3+9</span><br><span class="line">12</span><br><span class="line">calc&gt;</span><br></pre></td></tr></table></figure><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>假设我们在命令行输入一个表达式“3+5”。你的解释器得到一个字符串 “3+5”。为了使解释器真正理解如何处理这个字符串，需要先把输入的 “3+5” 拆分成被叫做 <strong>token</strong> 的部件。</p><blockquote><p><strong>词法分析</strong>：（<strong>lexical analysis</strong>，简称<strong>lexer</strong>，亦称<strong>scanner</strong> 或 <strong>tokenizer</strong>）</p><p>​ 词法分析也称为 <strong>分词</strong> ，此阶段编译器从左向右扫描源文件，将其字符流分割成一个个的 <strong>词</strong> （ <strong>token</strong> 、 <strong>记号</strong> ，后文中将称为 <strong>token</strong> ）。</p><p><strong>Token</strong>：</p><p>​ 所谓 <strong>token</strong> ，就是源文件中不可再进一步分割的一串字符，类似于英语中单词，或汉语中的词。</p></blockquote><p>这里的 <strong>token</strong> 就是一个有类型的值的对象（即，token还存着值的类型）。例如对于字符串“3”来说，token 类型为 <code>INTEGER</code> ， 相应的值是整数 3 。</p><p>解释器<code>Interpreter</code>要做的第一步就是读取输入的字符串并把他转化成 token <strong>流</strong>。解释器中做这个工作的部分被称为 <strong>词法分析器</strong>(lexical analyzer)，简称 <strong>lexer</strong> 。也可以称它为： <strong>scanner</strong> 或 <strong>tokenizer</strong> 。他们的含义是一样的：表示解释器或编译器中将输入的字符串转化为 token 流的部分。</p><p>那是如何转化为token流呢？</p><ul><li>解释器 <code>Interpreter</code>中的 <code>get_next_token</code> 方法就是你的词法分析器。你每次调用它，就会从输入到解释器的字符流中得到下一个 token。让我们仔细看一下这个方法，看看它是怎么把字符转化 为 token 的。输入被存放在变量 <code>text</code> 中，它保存了输入的字符串， <code>pos</code> 是指向该字符串的一个索引（把字符串看作是一个字符数组）。 <code>pos</code> 的初值被设为 0, 指向字符‘3’。 该方法首先检查该字符是不是数字，若是数字，就递增 <code>pos</code> 并返回一个类型为 <code>INTEGER</code> 值 为整数 3 的 token：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part1_lexer1-1583746666076.png" alt="img"></p><p>现在 <code>pos</code> 指向了 <code>text</code> 中的字符‘+’，下次你调用这个方法时，它会先测试 <code>pos</code> 位 置的字符是否是数字，然后再测试它是否是加号，此时它是加号。这样该方法就递增 <code>pos</code> 并返回一个类型为 <code>PLUS</code> 值为‘+’的 token：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part1_lexer2.png" alt="img"></p><p>现在 <code>pos</code> 指向了字符‘5’。当你再次调用 <code>get_next_token</code> 时，它会检查 <code>pos</code> 位置 是否是一个数字，此时是的，因此它递增 <code>pos</code> 并返回一个类型为 <code>INTEGER</code> 值为‘5’的 token：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part1_lexer3.png" alt="img"></p><p>现在索引 <code>pos</code> 越过了字符串“3+5”的末尾，接下来每次调用 <code>get_next_token</code> 方法都会 返回 <code>EOF</code> token：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part1_lexer4.png" alt="img"></p><p>自己动手试试看看你的计算器的 lexer 组件怎么工作的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> calc1 <span class="keyword">import</span> Interpreter</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>interpreter = Interpreter(<span class="string">'3+5'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>interpreter.get_next_token()</span><br><span class="line">Token(INTEGER, <span class="number">3</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>interpreter.get_next_token()</span><br><span class="line">Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>interpreter.get_next_token()</span><br><span class="line">Token(INTEGER, <span class="number">5</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>interpreter.get_next_token()</span><br><span class="line">Token(EOF, <span class="literal">None</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>此时你的解释器已经可以从输入的字符流中获得 token 流了，解释器需要对它做点什么： 它需要从使用 lexer <code>get_next_token</code> 得到的字符流中找到结构。你的解释器期望从 流中找到如下的结构： INTEGER -&gt; PLUS -&gt; INTEGER. 即，它试着找到这样一个 token 序 列：整数后跟一个加号再跟一个整数。</p><p>负责查找和解释这个结构的方法是 <code>expr</code>. 这个方法验证一个 token 序列是否遵从期望的 token 序列，即 INTEGER -&gt; PLUS -&gt; INTEGER. 当确定遵从这个结构后，它就把 PLUS 左 边和右边 token 的值相加来生成结果，从而成功地解释了你传给解释器的算术表达式。</p><p><code>expr</code> 方法使用了辅助方法 <code>eat</code> 来验证传给 <code>eat</code> 的 token 类型与当前的 token 类 型相匹配。在匹配到传入的 token 类型后， <code>eat</code> 方法会取得下一个 token 并把它赋值 给变量 <code>current_token</code>, 这样实际上是“吃掉”了当前匹配的 token 并把想象中的 token 流中的指针向前移动了。如果 token 流中的结构不遵从期望的 INTEGER PLUS INTEGER 序 列， <code>eat</code> 方法就会抛出一个异常。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>回顾一下你的解释器为了对一个算术表达式求值都做了什么：</p><ol><li>解释器接<code>Interpreter</code>收一个输入字符串，假设为“3+5”</li><li>解释器调用了 <code>expr</code> 方法来从词法解析器 <code>get_next_token</code> 返回的 token 流中寻找一个结构。这个结构就是一个 <em>INTEGER PLUS INTEGER</em> 的形式。当确认了这个结构以后，它就使用把两个 INTEGER token 相加的方式来解释这个输入，因为此时解释器已经清楚 地知道它要做的就是把 3 和 5 两个整数相加。</li></ol><p>祝贺你。你刚刚学会了怎么构造你的第一个解释器！</p><p>现在是时候做此练习了。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_exercises2.png" alt="img"></p><p>你不会觉得你刚刚读了这篇文章就足够了，是吧？好了，自己动手做下面的练习：</p><ol><li>修改代码使得允许输入多位整数，例如“12+3”</li><li>增加一个跳过空白符的方法，使你的计算器可以处理包含空白符的输入如 “ 12 + 3”</li><li>修改代码使得它可以处理‘-’而非‘+’的情况</li></ol><p>检查你的理解。</p><ol><li>什么是解释器？</li><li>什么是编译器？</li><li>解释器和编译器的区别是什么？</li><li>什么是 token？</li><li>将输入拆分成 token 的过程叫什么？</li><li>解释器中做词法分析的部分叫什么？</li><li>解释器或编译器的这个部分还有什么其他常见的名字？</li></ol><p>相关文章链接：</p><p>编译器与解释器：<a href="https://www.liujiangblog.com/course/python/9" target="_blank" rel="noopener">https://www.liujiangblog.com/course/python/9</a></p><p>Let’s Build A Simple Interpreter. Part 1：<a href="https://feng-qi.github.io/2018/01/23/lets-build-a-simple-interpreter-part-01/" target="_blank" rel="noopener">https://feng-qi.github.io/2018/01/23/lets-build-a-simple-interpreter-part-01/</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Let’s Build A Simple Interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2、电子计算机</title>
      <link href="/archives/d84f.html"/>
      <url>/archives/d84f.html</url>
      
        <content type="html"><![CDATA[<p>这个系列的课程还是值得大家去看一看的。这个系列的视频叫《计算机科学速成课》。虽然叫速成课，我们也要做到心中有数，它肯定不是让你看了这些内容你就什么都知道了。这是科普性的视频。这个视频都是被翻译好的，再次感谢这些翻译者。</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>视频在B站上都有全集的，传送门：<a href="https://www.bilibili.com/video/av21376839" target="_blank" rel="noopener">https://www.bilibili.com/video/av21376839</a></p><p>在GitHub上的地址：<a href="https://github.com/1c7/crash-course-computer-science-chinese" target="_blank" rel="noopener">https://github.com/1c7/crash-course-computer-science-chinese</a></p><p>这门课总共有40节，每节课的标题为：</p><ol><li>计算机早期历史</li><li>电子计算</li><li>布尔逻辑与逻辑电路</li><li>二进制</li><li>算术逻辑单元</li><li>寄存器 &amp; 内存</li><li>中央处理器</li><li>指令和程序</li><li>高级 CPU 设计</li><li>编程史话</li><li>编程语言</li><li>编程原理：语句和函数</li><li>算法初步</li><li>数据结构</li><li>阿兰·图灵</li><li>软件工程</li><li>集成电路、摩尔定律</li><li>操作系统</li><li>内存 &amp; 储存介质</li><li>文件系统</li><li>压缩</li><li>命令行界面</li><li>屏幕 &amp; 2D 图形显示</li><li>冷战和消费主义</li><li>个人计算机革命</li><li>图形用户界面</li><li>3D 图形</li><li>计算机网络</li><li>互联网</li><li>万维网</li><li>网络安全</li><li>黑客与攻击</li><li>加密</li><li>机器学习与人工智能</li><li>计算机视觉</li><li>自然语言处理</li><li>机器人</li><li>计算机中的心理学</li><li>教育型科技</li><li>奇点，天网，计算机的未来</li></ol><h1 id="计算机早期历史"><a href="#计算机早期历史" class="headerlink" title="计算机早期历史"></a>计算机早期历史</h1><p>这一张图大致说明了计算机早期发展的历史。图片来源：请查看图片本身链接。</p><p>后面的课会较详细的讲解。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/5c2dbf8e0001443913279329.png" alt="计算机历史"></p><h1 id="电子计算机"><a href="#电子计算机" class="headerlink" title="电子计算机"></a>电子计算机</h1><h2 id="继电器"><a href="#继电器" class="headerlink" title="继电器"></a>继电器</h2><p>在1937年最大的机电计算机之一是哈佛的马克一号(Harvard Mark Ⅰ)，是IBM在1944年给二战的同盟国建造的。该机器的大脑(CPU的基础器件)是“<strong>继电器</strong>”。</p><ul><li><strong>继电器</strong>：是用电控制的机械开关，继电器里有根“控制线路”控制着电路的开关，“控制线路”连着一个线圈，当线圈通电时，会产生感应磁场，由此由此能够吸引上方的金属臂，从而闭合电路，得到高电平。它的<strong>性能：</strong>1940年一个好的继电器1秒能翻转50次。哈佛马克一号1秒能做3次加减法运算，一次乘法需要6秒，除法需要15秒，三角函数需要一分钟以上。它的<strong>缺点：</strong>控制开关的金属臂是“有质量的”，因此无法快速开关。并且金属臂的反复移动就会存在磨损（任何会动的机械都会随时间磨损），哈佛马克一号平均每天需要更换一个故障继电器。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200308033154957.png" alt="继电器"></p><h2 id="真空管"><a href="#真空管" class="headerlink" title="真空管"></a>真空管</h2><p>在1904年，英国物理学家John Ambrose Fleming开发了新的电子组件——<strong>热电子管（Thermionic valve）</strong>。</p><ul><li><strong>热电子管</strong>：把两个电极装在一个气密的真空玻璃灯泡中。其中一个点击A可以加热，从而发射电子，称为<strong>热电子发射（Thermionic emission）</strong>；另一个电极B会吸引电子，来形成电流。但只有当电极B带正电时才能吸引电子，否则当电极B带负电荷或者中性电荷时，电子就无法跨越真空区。</li></ul><p>美国发明家Lee de Forest在此基础上加入了第三个控制电极。通过向控制电极施加正电荷，就能吸引电子，从而闭合电路；而通过施加负电荷，就能闭合电路。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/v2-94062a34bd644ef937224efaa2ebdf6c_720w.png" alt="img"></p><p><strong>特点：</strong></p><p><em>每秒可开闭数千次。</em></p><p><em>和继电器相同的是，可以通过一个控制线路来控制断开或闭合电路，并且真空管内没有会动的组件，因此存在更少的磨损。</em></p><p><em>比较脆弱，会像灯泡一样烧坏，并且体积比较大。</em></p><p><strong>真空管的出现，标志着计算机从机电转向电子</strong>，电子数值积分计算机ENIAC，在1946年于宾夕法尼亚大学设计制造，这是世上第一个真正的通用可编程电子计算机，每秒可执行5000次十位加减法。但是由于存在大量的真空管，因此ENIAC运行半天左右就会出现一次故障。</p><h2 id="晶体管"><a href="#晶体管" class="headerlink" title="晶体管"></a>晶体管</h2><p><strong>晶体管：</strong>类似于继电器和真空管，晶体管也是一个用于控制电路闭合断开的开关。晶体管有两个电极，这两个电极之间通过半导体材料隔开。控制线连接到一个“门”电极，通过改“门”的电荷，我们可以控制半导体的导电性，由此来控制电流是否流动。当控制线路通电时，两个电极接通，否则两个电极断开。</p><p><strong>特点：</strong></p><p><em>每秒可开关10000次。</em></p><p><em>相比玻璃制成的真空管，晶体管是固体的，并且体积远小于继电器和真空管。</em></p><p>第一个消费者可购买的，完全由晶体管构成的计算机是1957年发布的IBM 608，它有3000个晶体管，每秒执行4500次加减法，或80次左右的乘除法。</p><p>如今，计算机里的晶体管小于50nm，并且每秒可切换上百万次，工作几十年。很多晶体管和半导体开发在圣克拉拉谷，位于旧金山和圣河西之间，由于制造半导体最常见的材料是硅，由此这个地方被称为“硅谷”。并且William Shockley搬过去创建了肖克利半导体，里面的员工后来成立了仙童半导体，而这里面的员工后来创立了英特尔。</p><hr><p>所以，计算机的大脑基础单元的发展路径，可概括为：<strong>继电器-&gt;电子管-&gt;晶体管</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《计算机科学速成课》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo之 Yilia主题配置</title>
      <link href="/archives/460671de.html"/>
      <url>/archives/460671de.html</url>
      
        <content type="html"><![CDATA[<p>Yilia主题配置</p><a id="more"></a><h2 id="在左侧显示总文章数"><a href="#在左侧显示总文章数" class="headerlink" title="在左侧显示总文章数"></a>在左侧显示总文章数</h2><p>将themes\yilia\layout_partial\left-col.ejs文件的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;nav <span class="class"><span class="keyword">class</span></span>=<span class="string">"header-menu"</span>&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">    &lt;% <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> theme.menu)&#123; %&gt;</span><br><span class="line">        &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%- url_for(theme.menu[i]) %&gt;"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">i</span> %&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;%&#125;%&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/u</span>l&gt;</span><br><span class="line">&lt;<span class="regexp">/nav&gt;</span></span><br></pre></td></tr></table></figure><p>后面加上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;nav&gt;</span><br><span class="line">    总文章数 &lt;%=site.posts.length%&gt;</span><br><span class="line">&lt;<span class="regexp">/nav&gt;</span></span><br></pre></td></tr></table></figure><h2 id="字数、阅读时长添加"><a href="#字数、阅读时长添加" class="headerlink" title="字数、阅读时长添加"></a>字数、阅读时长添加</h2><p>首先安装 <a href="https://github.com/willin/hexo-wordcount" target="_blank" rel="noopener">hexo-wordcount</a></p><p>使用如下命令安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-wordcount  <span class="comment">#如果安装了cnpm，可换为cnpm安装</span></span><br></pre></td></tr></table></figure><blockquote><p>Node 版本7.6.0之前,请安装 2.x 版本 (Node.js v7.6.0 and previous)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copynpm install hexo-wordcount@2 --save</span><br></pre></td></tr></table></figure><p>然后在 <code>themes\yilia\layout\_partial\left-col.ejs</code>中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copy&lt;nav&gt;</span><br><span class="line">    总字数 &lt;span class&#x3D;&quot;post-count&quot;&gt;&lt;%&#x3D; totalcount(site, &#39;0,0.0a&#39;) %&gt;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;nav&gt;</span><br></pre></td></tr></table></figure><p>添加位置在如下代码的下面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copy&lt;nav&gt;</span><br><span class="line">    总文章数 &lt;%&#x3D;site.posts.length%&gt;</span><br><span class="line">&lt;&#x2F;nav&gt;</span><br></pre></td></tr></table></figure><p>编辑 <code>themes\yilia\layout\_partial\article.ejs</code></p><p>在header下面加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div align&#x3D;&quot;left&quot; class&#x3D;&quot;post-count&quot;&gt;   &lt;!--其中align可以在：right、center、left--&gt;</span><br><span class="line">    字数：&lt;%&#x3D; wordcount(post.content) %&gt;字 | 预计阅读时长：&lt;%&#x3D; min2read(post.content) %&gt;分钟</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>即可显示单篇字数和预计阅读时长。</p><h2 id="置顶文章"><a href="#置顶文章" class="headerlink" title="置顶文章"></a>置顶文章</h2><p><strong>安装插件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure><p><strong>配置置顶标准</strong></p><p>打开：/themes/*/layout（/_macro）/post.ejs 直接在最前面加入以下代码即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (page.top) &#123; %&gt;</span><br><span class="line">  &lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">"fa fa-thumb-tack"</span>&gt;&lt;<span class="regexp">/i&gt;</span></span><br><span class="line"><span class="regexp">  &lt;font color=7D26CD&gt;置顶&lt;/</span>font&gt;</span><br><span class="line">  &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"post-meta-divider"</span>&gt;|&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;% &#125; %&gt;</span></span><br></pre></td></tr></table></figure><p><strong>配置文章</strong></p><p>然后在需要置顶的文章的Front-matter中加上top选项即可 top后面的数字越大，优先级越高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 2019</span><br><span class="line">date: 2019-02-14 16:10:03</span><br><span class="line">top: 5</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h2 id="增加不蒜子统计"><a href="#增加不蒜子统计" class="headerlink" title="增加不蒜子统计"></a>增加不蒜子统计</h2><p>利用这个统计，可以知道你博客的访问量。</p><p><strong>安装不蒜子脚本</strong>：</p><p>在themes\yilia\layout\ _partial\after-footer.ejs最后添加：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="单篇文章点击量："><a href="#单篇文章点击量：" class="headerlink" title="单篇文章点击量："></a>单篇文章点击量：</h3><p>在themes/yilia/layout/_partial/article.ejs中 在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%- partial(&#39;post&#x2F;title&#39;, &#123;class_name: &#39;article-title&#39;&#125;) %&gt;</span><br></pre></td></tr></table></figure><p>后面插入如下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--显示阅读次数--&gt;</span><br><span class="line">&lt;% <span class="keyword">if</span> (!index &amp;&amp; post.comments)&#123; %&gt;</span><br><span class="line">  &lt;br/&gt;</span><br><span class="line">  &lt;a <span class="class"><span class="keyword">class</span></span>=<span class="string">"cloud-tie-join-count"</span> href=<span class="string">"javascript:void(0);"</span> style=<span class="string">"color:gray;font-size:14px;"</span>&gt;</span><br><span class="line">  &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"icon-sort"</span>&gt;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;span id="busuanzi_container_page_pv" style="color:#ef7522;font-size:14px;"&gt;</span></span><br><span class="line"><span class="regexp">            阅读数: &lt;span id="busuanzi_value_page_pv"&gt;&lt;/</span>span&gt;次 &amp;nbsp;&amp;nbsp;</span><br><span class="line">  &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>a&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line">&lt;!--显示阅读次数完毕--&gt;</span><br></pre></td></tr></table></figure><h2 id="增加版权声明"><a href="#增加版权声明" class="headerlink" title="增加版权声明"></a>增加版权声明</h2><p><strong>配置yilia</strong>：</p><p>在themes/yilia/layout/_partial/article.ejs中，标注的位置添加代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"article-entry"</span> itemprop=<span class="string">"articleBody"</span>&gt;</span><br><span class="line">  &lt;% <span class="keyword">if</span> (post.excerpt &amp;&amp; index)&#123; %&gt;</span><br><span class="line">    &lt;%- post.excerpt %&gt;</span><br><span class="line">    &lt;% <span class="keyword">if</span> (theme.excerpt_link) &#123; %&gt;</span><br><span class="line">      &lt;a <span class="class"><span class="keyword">class</span></span>=<span class="string">"article-more-a"</span> href=<span class="string">"&lt;%- url_for(post.path) %&gt;#more"</span>&gt;&lt;%= theme.excerpt_link %&gt; &gt;&gt;&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">    &lt;% &#125; %&gt;</span></span><br><span class="line"><span class="regexp">  &lt;% &#125; else &#123; %&gt;</span></span><br><span class="line"><span class="regexp">    &lt;%- post.content %&gt;</span></span><br><span class="line"><span class="regexp">  &lt;% &#125; %&gt;</span></span><br><span class="line"><span class="regexp">  &lt;-- 在此处添加代码--&gt; &lt;-- 在此处添加代码--&gt; &lt;-- 在此处添加代码--&gt; &lt;-- 在此处添加代码--&gt;</span></span><br><span class="line"><span class="regexp">  &lt;% if ((theme.reward_type === 2 || (theme.reward_type === 1 &amp;&amp; post.reward)) &amp;&amp; !index)&#123; %&gt;</span></span><br><span class="line"><span class="regexp">  &lt;div class="page-reward"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;a href="javascript:;" class="page-reward-btn tooltip-top"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="tooltip tooltip-east"&gt;</span></span><br></pre></td></tr></table></figure><p>在目录：themes/yilia/source-src/css中创建新文件：declare.scss，并添加如下CSS代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.declare &#123;</span><br><span class="line">    background-color: #eaeaea;</span><br><span class="line">    margin-top: <span class="number">2</span>em;</span><br><span class="line">    border-left: 3px solid #ff1700;</span><br><span class="line">    padding: <span class="number">.5</span>em <span class="number">1</span>em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，为themes/yilia/source-src/css/main.scss，添加如下代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">"./declare"</span>;</span><br></pre></td></tr></table></figure><p><strong>配置显示</strong>：</p><p>现在该让其显示出来，在themes/yilia/_config.yml，中加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#版权基础设定：0-关闭声明； 1-文章对应的md文件里有declare: true属性，才有版权声明； 2-所有文章均有版权声明</span><br><span class="line">#当前应用的版权协议地址。</span><br><span class="line">#版权协议的名称</span><br><span class="line">#版权协议的Logo</span><br><span class="line"></span><br><span class="line">declare_type: 1</span><br><span class="line">licensee_url: https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by-nc-sa&#x2F;4.0&#x2F;</span><br><span class="line">licensee_name: &#39;知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议&#39;</span><br><span class="line">licensee_img: https:&#x2F;&#x2F;i.creativecommons.org&#x2F;l&#x2F;by-nc-sa&#x2F;4.0&#x2F;88x31.png</span><br></pre></td></tr></table></figure><p>然后在需要进行版权声明的文章的md文件头部，设置属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare:true</span><br></pre></td></tr></table></figure><p>即可。</p><h2 id="在主页时文章显示摘要"><a href="#在主页时文章显示摘要" class="headerlink" title="在主页时文章显示摘要"></a>在主页时文章显示摘要</h2><p>在你 MD 格式文章正文插入 <code>&lt;!-- more --&gt;</code> 即可，只会显示它之前的，此后的就不显示，点击文章标题，，或者点击下面的<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200302193556416.png" alt="image-20200302193556416">按钮，即可进入全文。</p><p>如：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200302180731556.png" alt="image-20200302180731556"></p><h2 id="文章显示目录"><a href="#文章显示目录" class="headerlink" title="文章显示目录"></a>文章显示目录</h2><p>增加文章目录 TOC ( table of content )，方便阅读文章，在 <code>themes/yilia/_config.yml</code> 中进行配置 <code>toc: 2</code> 即可，它会将你 Markdown 语法的标题，生成目录，目录查看在右下角。</p><h2 id="头像设置"><a href="#头像设置" class="headerlink" title="头像设置"></a>头像设置</h2><p><strong>设置存放位置</strong>：</p><p>头像/图标图片的存放位置是<code>/themes/yilia/source/</code>下任意位置，可以自己新建一个文件夹存放，我存放在<code>assets</code>文件夹下。（我之前放在img中，但是不知道为什么，它就显示不出来）</p><p><strong>配置修改</strong>：</p><p>配置文件为<code>/themes/yilia/_config.yml</code>。设置头像为配置文件中<code>avatar</code>一项，设置图标为配置文件中<code>favicon</code>一项，设置路径的根目录为<code>/themes/yilia/source/</code>。例如，我的头像存放的地址是<code>/themes/yilia/source/assets/me.png</code>，设置则为<code>avatar: /assets/me.png</code>。（图标同理）</p><h2 id="提交网页"><a href="#提交网页" class="headerlink" title="提交网页"></a>提交网页</h2><h3 id="sitemap方式提交网页"><a href="#sitemap方式提交网页" class="headerlink" title="sitemap方式提交网页"></a>sitemap方式提交网页</h3><p>在 Hexo 根目录打开命令行工具，执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;your_hexo_path&#125;&#x2F;public</span><br></pre></td></tr></table></figure><p>文件夹，可以看到文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sitemap.xml</span><br></pre></td></tr></table></figure><p>sitemap 的初衷是给搜索引擎看的，为了提高搜索引擎对自己站点的收录效果，我们最好手动到 google 和百度等搜索引擎提交 sitemap.xml。</p><p>baidu提交网址：<a href="https://ziyuan.baidu.com/?castk=LTE%3D" target="_blank" rel="noopener">https://ziyuan.baidu.com/?castk=LTE%3D</a></p><h3 id="百度自动推送方式提交网页"><a href="#百度自动推送方式提交网页" class="headerlink" title="百度自动推送方式提交网页"></a>百度自动推送方式提交网页</h3><p>在本机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;博客根目录&gt;&#x2F;themes&#x2F;yilia&#x2F;layout&#x2F;_partial</span><br></pre></td></tr></table></figure><p>目录下打开article.ejs文件，定位到如下这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">        var sUrl &#x3D; url.replace(&#x2F;index\.html$&#x2F;, &#39;&#39;);</span><br><span class="line">        sUrl &#x3D; &#x2F;^(http:|https:)\&#x2F;\&#x2F;&#x2F;.test(sUrl) ? sUrl : &#39;https:&#39; + sUrl;</span><br><span class="line">      %&gt;</span><br></pre></td></tr></table></figure><p>在它前面加上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!- 百度自动推送方式提交 --&gt;</span><br><span class="line">&lt;% if (1)&#123; %&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">  (function()&#123;</span><br><span class="line">      var bp &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">      var curProtocol &#x3D; window.location.protocol.split(&#39;:&#39;)[0];</span><br><span class="line">      if (curProtocol &#x3D;&#x3D;&#x3D; &#39;https&#39;) &#123;</span><br><span class="line">          bp.src &#x3D; &#39;https:&#x2F;&#x2F;zz.bdstatic.com&#x2F;linksubmit&#x2F;push.js&#39;;</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">          bp.src &#x3D; &#39;http:&#x2F;&#x2F;push.zhanzhang.baidu.com&#x2F;push.js&#39;;</span><br><span class="line">      &#125;</span><br><span class="line">      var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0];</span><br><span class="line">      s.parentNode.insertBefore(bp, s);</span><br><span class="line">  &#125;)();</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line">&lt;!- 百度自动推送方式提交结束 --&gt;</span><br></pre></td></tr></table></figure><p>即完成了新增博客文章页面（不包括其他页面）的自动推送方式提交。</p><h2 id="链接提交"><a href="#链接提交" class="headerlink" title="链接提交"></a>链接提交</h2><p>百度站长平台的链接提交方式分为自动提交和手动提交两种，此处只讲自动提交，手动提交按照要求操作即可。</p><h3 id="主动推送"><a href="#主动推送" class="headerlink" title="主动推送"></a>主动推送</h3><h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><p>主动推送最为快速的提交方式，是被百度收录最快的推送方式。主动推送可以通过安装插件实现：</p><p><strong>首先安装插件：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-baidu-url-submit --save</span><br></pre></td></tr></table></figure><p>修改站点根目录下的配置文件_config.yml，添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">baidu_url_submit:</span><br><span class="line">  count: 20 ## 提交最新的20个链接</span><br><span class="line">  host: www.dongshuyan.com ## 百度站长平台中注册的域名</span><br><span class="line">  token:  ## 16位准入秘钥</span><br><span class="line">  path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里</span><br></pre></td></tr></table></figure><p><strong>准入秘钥获取</strong>:</p><p>在如下图的网址中：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/e8d810a8-af7b-40ce-8a7d-1db0e61a8a14-3316715.jpg" alt="img"></p><p>下拉，找到这里：<br><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/a94c8872-d402-4ce3-afc2-ea2705e95aeb-3316715.jpg" alt="img"><br>点击进去就是准入秘钥。</p><p><strong>检查</strong>:</p><p>其次，记得查看根目录下的_config.yml文件中url的值， 必须包含是百度站长平台注册的域名， 比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;</span><br><span class="line">url: http:&#x2F;&#x2F;dongshuyan.com</span><br><span class="line">root: &#x2F;</span><br><span class="line">permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure><p><strong>最后，加入新的deployer</strong></p><p>最后，加入新的deployer:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- type: git ## 这是我原来的deployer</span><br><span class="line">  repo:</span><br><span class="line">  branch:</span><br><span class="line">- type: baidu_url_submitter ## 添加这里内容即可</span><br></pre></td></tr></table></figure><p>这里的”-“,必不可少！ 否则报错。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>其主动推送的实现原理如下：<br>新链接的产生， hexo generate 会产生一个文本文件，里面包含最新的链接<br>新链接的提交， hexo deploy 会从上述文件中读取链接，提交至百度搜索引擎</p><h3 id="自动推送"><a href="#自动推送" class="headerlink" title="自动推送"></a>自动推送</h3><p>装自动推送JS代码的网页，在页面被访问时，页面URL将立即被推送给百度。</p><p>修改主题目录下的layout/post.ejs文件，末尾添加自动推送代码，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">(function()&#123;</span><br><span class="line">    var bp &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">    var curProtocol &#x3D; window.location.protocol.split(&#39;:&#39;)[0];</span><br><span class="line">    if (curProtocol &#x3D;&#x3D;&#x3D; &#39;https&#39;) &#123;</span><br><span class="line">        bp.src &#x3D; &#39;https:&#x2F;&#x2F;zz.bdstatic.com&#x2F;linksubmit&#x2F;push.js&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        bp.src &#x3D; &#39;http:&#x2F;&#x2F;push.zhanzhang.baidu.com&#x2F;push.js&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0];</span><br><span class="line">    s.parentNode.insertBefore(bp, s);</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>出处：(<a href="http://dongshuyan.com/2019/05/24/hexo博客注意事项/#14-Hexo添加百度统计" target="_blank" rel="noopener">http://dongshuyan.com/2019/05/24/hexo博客注意事项/#14-Hexo添加百度统计</a>)</p><h2 id="添加百度统计和谷歌统计代码"><a href="#添加百度统计和谷歌统计代码" class="headerlink" title="添加百度统计和谷歌统计代码"></a>添加百度统计和谷歌统计代码</h2><h3 id="百度统计"><a href="#百度统计" class="headerlink" title="百度统计"></a>百度统计</h3><p>首先打开<a href="https://ziyuan.baidu.com/site/index" target="_blank" rel="noopener">百度站长平台</a>，注册账户。</p><p>然后登陆 百度统计》管理》新增站点。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200303193303556.png" alt="image-20200303193303556"></p><p>然后复制生成的代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> _hmt = _hmt || [];</span></span><br><span class="line"><span class="actionscript">(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> hm = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span></span><br><span class="line"><span class="actionscript">  hm.src = <span class="string">"https://hm.baidu.com/hm.js?这里是你的专属字符串"</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> s = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"script"</span>)[<span class="number">0</span>]; </span></span><br><span class="line">  s.parentNode.insertBefore(hm, s);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这一段代码，最重要的就是你那段专属的字符串。</p><p><strong>开始配置：</strong></p><p>首先，打开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">themes&#x2F;yilia&#x2F;_config.yml</span><br></pre></td></tr></table></figure><p>里面</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">baidu_analytics:</span> <span class="string">''</span></span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">baidu_analytics:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>然后，打开：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">themes/yilia/layout/_partial/baidu-analytics.ejs</span><br></pre></td></tr></table></figure><p>你会看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (theme.baidu_analytics)&#123; %&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var _hmt &#x3D; _hmt || [];</span><br><span class="line">(function() &#123;</span><br><span class="line">var hm &#x3D; document.createElement(&quot;script&quot;);</span><br><span class="line">hm.src &#x3D; &quot;https:&#x2F;&#x2F;hm.baidu.com&#x2F;hm.js?&lt;%&#x3D; theme.baidu_analytics %&gt;&quot;;</span><br><span class="line">var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0]; </span><br><span class="line">s.parentNode.insertBefore(hm, s);</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>这里，我们直接用你的<code>专属字符串</code>去替换<code>&lt;%= theme.baidu_analytics %&gt;</code>就行了。替换后为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (theme.baidu_analytics)&#123; %&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var _hmt &#x3D; _hmt || [];</span><br><span class="line">(function() &#123;</span><br><span class="line">var hm &#x3D; document.createElement(&quot;script&quot;);</span><br><span class="line">hm.src &#x3D; &quot;https:&#x2F;&#x2F;hm.baidu.com&#x2F;hm.js?你的专属字符串&quot;;</span><br><span class="line">var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0]; </span><br><span class="line">s.parentNode.insertBefore(hm, s);</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><h3 id="谷歌统计"><a href="#谷歌统计" class="headerlink" title="谷歌统计"></a>谷歌统计</h3><p>参考：<a href="http://yansheng836.coding.me/article/eda67a25.html" target="_blank" rel="noopener">http://yansheng836.coding.me/article/eda67a25.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Yilia主题配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo之Matery主题配置</title>
      <link href="/archives/514b.html"/>
      <url>/archives/514b.html</url>
      
        <content type="html"><![CDATA[<p>最近的三天一直在折腾hexo框架的博客，先是使用yilia主题，但是用来一天觉得我不适合这个主题，随即看到了matery主题。</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E4%B9%8BMatery%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/qqpyimg1583400714.jpg" alt="img"></p><p>今天又折腾了白天一天时间，我这个是直接克隆的<a href="https://sunhwee.com/about" target="_blank" rel="noopener">hongweiの博客</a>，这是一个大佬呀，还要多多向他学习。</p><p>然后，只把一些简单的配置弄好了。现在梳理一下：</p><p><strong>已完成的配置：</strong></p><ul><li><input checked disabled type="checkbox"><p>404页面</p></li><li><input checked disabled type="checkbox"><p>简历</p></li><li><input checked disabled type="checkbox"><p>建站时间</p></li><li><input checked disabled type="checkbox"><p>设置个人域名（已购买域名，单还需要审核，明天再去弄。）</p></li><li><input checked disabled type="checkbox"><p>不蒜子设置</p></li></ul><ul><li><input checked disabled type="checkbox"> 添加评论插件</li><li><input checked disabled type="checkbox"> 网站SEO优化</li><li><input disabled type="checkbox"> 百度收录站点 1.验证网站所有权</li><li><input disabled type="checkbox"> 谷歌收录站点</li><li><input checked disabled type="checkbox"> 优化你的URL</li><li><input disabled type="checkbox"> 添加代码块复制功能</li><li><input disabled type="checkbox"> 添加文章更新时间功能</li></ul><p><strong>非必要配置（已经取消）：</strong></p><ul><li><input checked disabled type="checkbox"><p>添加网易云音乐BGM</p></li><li><input checked disabled type="checkbox"><p>添加鼠标点击烟花爆炸效果</p></li><li><input checked disabled type="checkbox"><p>添加页面樱花飘落效果</p></li><li><input checked disabled type="checkbox"><p>添加鼠标点击文字特效</p></li><li><input checked disabled type="checkbox"><p>添加页面雪花飘落动效</p></li><li><input checked disabled type="checkbox"><p>优化网站加载速度</p></li><li><input checked disabled type="checkbox"><p>数学公式渲染和代码高亮</p></li><li><input disabled type="checkbox"><p>其他搜索引擎收录你的站点</p></li><li><input disabled type="checkbox"><p>添加动漫人物</p></li><li><input disabled type="checkbox"><p>增加emoji支持</p></li><li><input disabled type="checkbox"><p>添加博客动态标签</p></li><li><input disabled type="checkbox"><p>添加博客天气插件</p></li><li><input checked disabled type="checkbox"><p>GitHub&amp;coding pages双部署</p></li><li><input checked disabled type="checkbox"><p>修复Valine评论的头像不显示问题</p></li></ul><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h2><p>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 <a href="https://github.com/ele828/hexo-prism-plugin" target="_blank" rel="noopener">hexo-prism-plugin</a> 的 Hexo 插件来做代码高亮，安装命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -S hexo-prism-plugin</span><br></pre></td></tr></table></figure><p>然后，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并新增 <code>prism</code> 插件相关的配置，主要配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">prism_plugin:</span></span><br><span class="line">  <span class="attr">mode:</span> <span class="string">'preprocess'</span>    <span class="comment"># realtime/preprocess</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">'tomorrow'</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">false</span>    <span class="comment"># default false</span></span><br><span class="line">  <span class="attr">custom_css:</span></span><br></pre></td></tr></table></figure><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><h2 id="1、Cannot-set-property-39-lastIndex-39-of-undefined"><a href="#1、Cannot-set-property-39-lastIndex-39-of-undefined" class="headerlink" title="1、Cannot set property &#39;lastIndex&#39; of undefined"></a>1、<code>Cannot set property &#39;lastIndex&#39; of undefined</code></h2><p>运行<code>hexo g</code>出现Cannot set property ‘lastIndex’ of undefined</p><p>解决方法：修改配置文件的 _config.yml，注意不是主题里面的配置文件，把 <code>auto_detect</code> 设置为<code>false</code> 即可。</p><h2 id="2、代码显示异常"><a href="#2、代码显示异常" class="headerlink" title="2、代码显示异常"></a>2、代码显示异常</h2><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E4%B9%8BMatery%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/image-20200307011749942.png" alt="image-20200307011749942"></p><p>解决方法：</p><ul><li>首先，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>。</li></ul><p>然后<code>hexo clean</code>&amp; <code>hexo g</code>&amp; <code>hexo s</code></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E4%B9%8BMatery%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/image-20200307012129958.png" alt="image-20200307012129958"></p><p>好了。</p><p><strong>注</strong>：作者给的解决方案比我这个要多一步，我在这里贴出来，供大家参考。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E4%B9%8BMatery%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/image-20200307012313539.png" alt="image-20200307012313539"></p><h2 id="3、目录定位内容有偏差"><a href="#3、目录定位内容有偏差" class="headerlink" title="3、目录定位内容有偏差"></a>3、目录定位内容有偏差</h2><p>我反复的去测试，后来发现，可能有两个原因会导致这个问题的出现：</p><ol><li><p>网页没有刷新完全的时候，点击目录他有可能不会跳转。</p><p><strong>解决方法</strong>：</p><ul><li>法一：等待网页刷新完全。</li><li>法二：手动的去停止网页的刷新（这个来的比较快一点，哈哈）</li></ul></li><li><p>你的文章的标题格式有问题，比如，我用Typora软件来写文章，这个软件就是所写即所得。但是这样你就不容易发现格式细节处的错误。</p><p><u>错误示范</u>：</p><p>我先写了一个一级标题，<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E4%B9%8BMatery%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/image-20200308024217913.png" alt="image-20200308024217913"></p><p>然后，我又点击引用，就变成这样了：<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E4%B9%8BMatery%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/image-20200308024438170.png" alt="image-20200308024438170">这种写法在Typora中，是不会认为它是一级标题的。</p><p>我们打开源码查看他的格式：<code>&gt; # 配置</code>。他的格式是这样的。就是这里<u>出错了</u>，在matery主题中这样写它仍然会识别成标题，然后就导致从这个标题开始后面的标题，在你点击这些标题的时候，它会定位错误。</p><p><strong>解决方法</strong>：我们一定要遵循Markdown格式的语法，一定要，一定要。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matery主题配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tsinghua_Online_Judge_练习</title>
      <link href="/archives/d4fa.html"/>
      <url>/archives/d4fa.html</url>
      
        <content type="html"><![CDATA[<h2 id="CG2017-PA1-1-Convex-Hull-凸包"><a href="#CG2017-PA1-1-Convex-Hull-凸包" class="headerlink" title="CG2017 PA1-1 Convex Hull (凸包)"></a>CG2017 PA1-1 Convex Hull (凸包)</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><hr><p>Description (描述)</p><p>After learning Chapter 1, you must have mastered the convex hull very well. Yes, convex hull is at the kernel of computational geometry and serves as a fundamental geometric structure. That’s why you are asked to implement such an algorithm as your first programming assignments.</p><p>Specifically, given a set of points in the plane, please construct the convex hull and output an encoded description of all the extreme points.</p><p>经过了第一章的学习，想必你对于凸包的认识已经非常深刻。是的，凸包是计算几何的核心问题，也是一种基础性的几何结构。因此你的第一项编程任务，就是来实现这样的一个算法。</p><p>具体地，对于平面上的任意一组点，请构造出对应的凸包，并在经过编码转换之后输出所有极点的信息。</p><p>Input (输入)</p><p>The first line is an integer <strong>n &gt; 0</strong>, i.e., the total number of input points.</p><p>The k-th of the following <strong>n</strong> lines gives the k-th point:</p><p>pk = (xk, yk), k = 1, 2, …, n</p><p>Both xk and yk here are integers and they are delimited by a space.</p><p>第一行是一个正整数首行为一个正整数<strong>n &gt; 0</strong>，即输入点的总数。</p><p>随后<strong>n</strong>行中的第k行给出第k个点：</p><p>pk = (xk, yk), k = 1, 2, …, n</p><p>这里，xk与yk均为整数，且二者之间以空格分隔。</p><p>Output (输出)</p><p>Let <strong>{ s1, s2, …, sh }</strong> be the indices of all the extreme points, <strong>h ≤ n</strong>. Output the following integer as your solution:</p><p>( s1 * s2 * s3 * … * sh * h ) mod (n + 1)</p><p>若 <strong>{ s1, s2, …, sh }</strong> 为所有极点的编号, <strong>h ≤ n</strong>，则作为你的解答，请输出以下整数：</p><p>( s1 * s2 * s3 * … * sh * h ) mod (n + 1)</p><p>Sample Input (输入样例)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line"></span><br><span class="line">10</span><br><span class="line">7 9</span><br><span class="line">-8 -1</span><br><span class="line">-3 -1</span><br><span class="line">1 4</span><br><span class="line">-3 9</span><br><span class="line">6 -4</span><br><span class="line">7 5</span><br><span class="line">6 6</span><br><span class="line">-6 10</span><br><span class="line">0 8</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://dsa.cs.tsinghua.edu.cn/oj/attachment/9f51/9f516d08f38b1bbde0ab6aec6bfccb92211dc802.png" alt="img"></p><p>Sample Output (输出样例)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"></span><br><span class="line">7   &#x2F;&#x2F; ( 9 x 2 x 6 x 7 x 1 x 5 ) % (10 + 1)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://dsa.cs.tsinghua.edu.cn/oj/attachment/cb9d/cb9dbfbef90751cc0bc372041f543118dc6c9f1a.png" alt="img"></p><p>Limitation (限制)</p><ul><li><p>3 ≤ <strong>n</strong> ≤ 10^5</p></li><li><p>Each coordinate of the points is an integer from (-10^5, 10^5). There are no duplicated points. Each point is selected uniformly randomly in (-10^5, 10^5) x (-10^5, 10^5).</p></li><li><p>All points on extreme edges are regarded as extreme points and hence should be included in your solution.</p></li><li><p>Time Limit: 2 sec</p></li><li><p>Space Limit: 512 MB</p></li><li><p>3 ≤ <strong>n</strong> ≤ 10^5</p></li><li><p>所有点的坐标均为范围(-10^5, 10^5)内的整数，且没有重合点。每个点在(-10^5, 10^5) x (-10^5, 10^5)范围内均匀随机选取</p></li><li><p>极边上的所有点均被视作极点，故在输出时亦不得遗漏</p></li><li><p>时间限制：2 sec</p></li><li><p>空间限制：512 MB</p></li></ul><p>Hint (提示)</p><p>Use the CH algorithms presented in the lectures.</p><p>课程中讲解过的凸包算法</p><h3 id="解答：Graham-Scan算法"><a href="#解答：Graham-Scan算法" class="headerlink" title="解答：Graham Scan算法"></a><a href="https://renjikai.com/cg2017-pa1-1-convex-hull/" target="_blank" rel="noopener">解答：Graham Scan算法</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x, y, id;</span><br><span class="line">    <span class="built_in">point</span>() :x(<span class="number">0</span>), y(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">point</span>(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y) :x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> ==(<span class="keyword">const</span> <span class="built_in">point</span>&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x == p.x &amp;&amp; y == p.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;PP; <span class="comment">//PP: Polar Point</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">point</span>&gt; points;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">area2</span><span class="params">(<span class="built_in">point</span> p, <span class="built_in">point</span> q, <span class="built_in">point</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    |p.x p.y 1|</span></span><br><span class="line"><span class="comment">    |q.x q.y 1| == 2*DirectedTriangleArea(p,q,s)</span></span><br><span class="line"><span class="comment">    |s.x s.y 1|</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> p.x * q.y - s.x * q.y</span><br><span class="line">        + q.x * s.y - q.x * p.y</span><br><span class="line">        + s.x * p.y - p.x * s.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">toLeftTest</span><span class="params">(<span class="built_in">point</span> p, <span class="built_in">point</span> q, <span class="built_in">point</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//When return value large than 0, S is on the left side of ray PQ</span></span><br><span class="line">    <span class="keyword">return</span> area2(p, q, s) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">toLeftTest2</span><span class="params">(<span class="built_in">point</span> p, <span class="built_in">point</span> q, <span class="built_in">point</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//When return value large than 0, S is on the left side of ray PQ</span></span><br><span class="line">    <span class="keyword">return</span> area2(p, q, s) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">point</span>&amp; p1, <span class="keyword">const</span> <span class="built_in">point</span>&amp; p2)</span> </span>&#123; <span class="comment">// Sort according to polar angle</span></span><br><span class="line">    <span class="keyword">return</span> PP == p1 || !(PP == p2) &amp;&amp; toLeftTest(PP, p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">point</span> <span class="title">LTL</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">point</span>&gt;&amp; points)</span> </span>&#123; <span class="comment">//Lowest then leftmost</span></span><br><span class="line">    <span class="built_in">point</span> ltl = points[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (points[i].y &lt; ltl.y || points[i].y == ltl.y &amp;&amp; points[i].x &lt; ltl.x)</span><br><span class="line">            ltl = points[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ltl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">point</span>&gt; <span class="title">grahamScan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PP = LTL(points);</span><br><span class="line">    sort(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">point</span>&gt; S, T;</span><br><span class="line">    S.push_back(points[<span class="number">0</span>]); S.push_back(points[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = points.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; <span class="number">1</span>; i--)T.push_back(points[i]);</span><br><span class="line">    <span class="keyword">while</span> (!T.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (toLeftTest2(S[S.<span class="built_in">size</span>() - <span class="number">2</span>], S[S.<span class="built_in">size</span>() - <span class="number">1</span>], T[T.<span class="built_in">size</span>() - <span class="number">1</span>])) &#123;</span><br><span class="line">            S.push_back(T[T.<span class="built_in">size</span>() - <span class="number">1</span>]);</span><br><span class="line">            T.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> S.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">point</span> tmp;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tmp.x &gt;&gt; tmp.y;</span><br><span class="line">        tmp.id = i;</span><br><span class="line">        points.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">point</span>&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (points.<span class="built_in">size</span>() &gt; <span class="number">2</span>)result = grahamScan();</span><br><span class="line">    <span class="keyword">else</span> result = points;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; result[i].id &lt;&lt; endl;//debug</span></span><br><span class="line">        res = ((res % (n + <span class="number">1</span>)) * (result[i].id % (n + <span class="number">1</span>))) % (n + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    res = ((res % (n + <span class="number">1</span>)) * (result.<span class="built_in">size</span>() % (n + <span class="number">1</span>))) % (n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分数：92.5<br>使用Graham Scan算法。凸包板子题。</p>]]></content>
      
      
      <categories>
          
          <category> OJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>32、黑客&amp;攻击</title>
      <link href="/archives/622.html"/>
      <url>/archives/622.html</url>
      
        <content type="html"><![CDATA[<p>黑客入侵最常见的方式不是通过技术，而是欺骗别人，这个称为<strong>社会工程学（Social Engineering）</strong>，通过欺骗别人来让人泄露秘密，或让人配置电脑系统来变得易于攻击。最常见的攻击是<strong>网络钓鱼（Phishing）</strong>，其次还有<strong>假托（Pretexting）</strong>，攻击者给某个公司打电话，假装是IT部门的人，攻击者的第一通电话一般会叫人转接，这样另一个接的时候，电话看起来就像内部的，然后让别人把电脑配置得易于入侵，或者让他们泄露机密信息，比如密码或网络配置。</p><a id="more"></a><p>邮件里带<strong>木马（trojan horse）</strong>也是常见手段，木马通常会伪装成无害的东西，比如照片或发票，但实际上是恶意软件，有的会偷数据，有的会加密文件。</p><p>如果攻击者无法用木马或电话欺骗，攻击者只能被迫使用其他手段，方法之一就是暴力破解，尝试所有可能的密码，直到进入系统，大多数现代系统会加长等待时间来抵御这种攻击，每次失败就加长等待时间，甚至超过一定次数后，完全封锁。现在出现了一种攻破方法称为<strong>NAND镜像</strong>，如果能物理接触到电脑，可以往内存上接几根线，复制整个内存，然后暴力尝试密码，直到设备让你等待。这时只要把复制的内容覆盖掉内存，本质上重置了内存，就不用等待，可以继续尝试密码。</p><p>如果无法物理接触到设备，就需要远程攻击，比如通过互联网，这一般需要攻击者利用系统漏洞，来获得某些能力或访问权限，称为<strong>漏洞利用（Exploit）</strong>。一种常见的漏洞利用叫<strong>缓冲区溢出（Buffer Overflow）</strong>，这里的缓冲区是指预留的一块内存空间，比如我们在系统登录界面输入用户名和密码，而系统是用缓冲区来存储输入值的，假设缓冲区大小为10，并且缓冲区前后肯定还有其他数据，当用户输入用户名和密码时，这些值就会被复制到缓冲区中来进行验证，而该方法会溢出缓冲区，比如输入超过10个字符的密码，会覆盖掉相邻的数据，有时会让程序或系统崩溃，因为重要值被垃圾数据覆盖掉了。这里只是让系统崩溃，但是攻击者可以输入有意义的新值到程序的内存中，比如把<code>is_admin</code>标志位的值改为true，有了任意修改内存的能力，黑客就可以绕过登录这类东西，甚至使用那个程序劫持整个系统。</p><p>有许多方法阻止缓冲区溢出，最简单的方法就是复制到内存之前先检查长度，称为<strong>边界检查（Bounds checking</strong>），许多现代编程语言都自带边界检查，程序也会随机存放变量在内存中的位置，这样黑客就不知道应该覆盖内存的哪部分，使得更容易让程序崩溃，而不是获得访问权限。程序也可以在缓冲区后，预留一些不用的空间，然后跟踪里面的值，看是否发生变化，来判断是否有攻击，这些不用的内存空间称为<strong>金丝雀（Canaries）</strong>。</p><p>另一种经典手段是<strong>代码注入（Code Injection）</strong>，最常用于攻击用数据库的网站。假设网页上有登录提示，当用户点击“登录”，输入文本就会发送服务器，服务器就会运行代码，检查用户名是否存在，如果存在就看密码是否匹配。为此服务器会执行一段sql查询代码，比如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">password</span> <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> username=<span class="string">'___'</span>;</span><br></pre></td></tr></table></figure><p>这里语句就是要从<code>users</code>表中查找<code>username</code>为<code>___</code>的密码<code>password</code>。 这里的<code>___</code>就是用户输入的用户名。由此攻击者就能把sql命令输入到用户名中，比如<code>whatever&#39;;DROP TABLE users;&#39;</code>，这时上面的查询语句就会变成</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">password</span> <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> username=<span class="string">'whatever'</span>;<span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">users</span>;';</span><br></pre></td></tr></table></figure><p>如果服务器存在用户名<code>wharever</code>，数据库就会返回密码， 当然我们无法得知密码是什么，所以服务器会拒绝我们；如果不存在用户名<code>wharever</code>，服务器会返回空密码或者直接错误，服务器也会拒绝我们。 但是我们关心的是后面的代码<code>DROP TABLE users;</code><strong>这个是我们注入的命令</strong>，这个命令是删掉users这张表。如今几乎所有服务器都会防御这种手段。</p><p>程序员需要认识到从外界输入的信息都是危险的，必须要好好检查，很多用户名和密码表单，不会让你直接输入特殊符号，比如分号或括号，来作为第一道防御。好的服务器也会清理输入，比如修改或删除特殊字符，然后才放到数据库查询语句中。</p><p>当软件制造者不知道的新漏洞被发现时，称为<strong>0day漏洞（Zero Day Vulnerability）</strong>，黑客就会抢在白帽程序员做出补丁之前尽可能利用漏洞。</p><p>如果有足够多的电脑有漏洞，让恶意程序可以自动地在电脑之间互相传播，称为<strong>蠕虫（Worm）</strong>。如果黑客拿下大量电脑，这些电脑可以组成<strong>僵尸网络（Botnet）</strong>，可以用于很多目的，比如发大量垃圾邮件等，用别人电脑的计算能力来挖比特币，或发起DDOS来攻击服务器。DDOS就是僵尸网络里的所有电脑发一大堆垃圾信息到服务器上，造成服务器的阻塞。</p><center>完~~~</center>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《计算机科学速成课》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 博客框架搭建</title>
      <link href="/archives/7f7e.html"/>
      <url>/archives/7f7e.html</url>
      
        <content type="html"><![CDATA[<center>搭建这个博客起因是2020年的二月末的某一天晚上，无聊逛B站，然后就看到了一个博客搭建教程，随机就有了这一系列的文章了。</center><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我的是在windows操作系统上面，在其他的系统上面大同小异。也参考了很多文章及视频教程。主要参考的是：</p><p><a href="https://www.codesheep.cn" target="_blank" rel="noopener"><strong>程序羊</strong></a>的视频：<a href="https://www.bilibili.com/video/av44544186?from=search&amp;seid=12981624311298276946" target="_blank" rel="noopener">https://www.bilibili.com/video/av44544186?from=search&amp;seid=12981624311298276946</a></p><p>文章：</p><ul><li><p><a href="https://ouwen666.gitee.io/2020/01/29/Hexo+Gitee搭建个人博客" target="_blank" rel="noopener">https://ouwen666.gitee.io/2020/01/29/Hexo+Gitee搭建个人博客</a></p><p>作者部署的是gitee</p></li><li><p><a href="https://godweiyang.com/2018/04/13/hexo-blog/#toc-heading-6" target="_blank" rel="noopener">https://godweiyang.com/2018/04/13/hexo-blog/#toc-heading-6</a></p><p>含有个性化配置</p></li></ul><p><strong>注</strong>：文中的指令都是在<code>cmd</code>（Windows中的命令提示符）中完成的。如果在这之前电脑上就已经安装了<code>Git bash</code>，那么也可以在<code>Git bash</code>中运行指令。</p><h2 id="下面会用得到的命令"><a href="#下面会用得到的命令" class="headerlink" title="下面会用得到的命令"></a>下面会用得到的命令</h2><ul><li><p><code>npm install</code>=<code>npm i</code>。在git clone项目的时候，项目文件中并没有 node_modules文件夹，项目的依赖文件可能很大。直接执行，npm会根据package.json配置文件中的依赖配置下载安装。</p></li><li><p><code>-global</code>=<code>-g</code>，全局安装，安装后的包位于系统预设目录下</p></li><li><p><code>--save</code>=<code>-S</code>，安装的包将写入package.json里面的dependencies，dependencies：生产环境需要依赖的库</p></li></ul><h1 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h1><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>博客框架<code>Hexo</code>是基于<code>Node.js</code>制作的静态博客，我们待会要用到Node.js里面的<a href="https://www.npmjs.cn/" target="_blank" rel="noopener">npm</a>(node package manager)包管理器来安装插件。</p><p>可以点击<a href="https://nodejs.org/en/" target="_blank" rel="noopener">这里</a>进入其官网。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200301192702158.png" alt="image-20200301192702158"></p><p>进入之后，按照操作系统进行下载安装。如上图是Windows系统64位的版本，上面官方推荐下载的版本。</p><p>安装选项就按默认的，一直点击<code>Next</code>。</p><p>然后，检验是否安装成功：用<code>Win+R</code>命令打开命令提示符，输入<code>node -v</code> 和<code>npm -v</code> ，出现版本号，则说明安装成功。</p><h3 id="添加cnpm"><a href="#添加cnpm" class="headerlink" title="添加cnpm"></a>添加cnpm</h3><p><strong>注</strong>：因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，如果npm的服务器在中国就好了，所以我们乐于分享的淘宝团队干了这事。来自官网：“这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。”</p><p>所以我们可以利用<code>npm</code>安装<code>cnpm</code>，再<code>cmd</code>中输入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install cnpm -g –registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>再输入：<code>cnpm -v</code>来检验是否安装成功。</p><p>此时，假设我们<code>Node.js</code>安装成功。</p><h2 id="安装Hexo框架"><a href="#安装Hexo框架" class="headerlink" title="安装Hexo框架"></a>安装Hexo框架</h2><p>我们要利用<code>Hexo</code>框架模型来搭建我们的博客。点击<a href="https://hexo.io/" target="_blank" rel="noopener">这里</a>可以进入其官网。下载该框架也仍然是在<code>cmd</code>（Windows中的“命令提示符”）中输入指令完成的。</p><ol><li><p>在上一步我们安装了<code>cnpm</code>，现在我们要用它来安装<code>hexo</code>，用<code>cnpm</code>安装的速度更快一些，也可以用<code>npm</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>检验是否安装成功，当运行之后出现版本号则安装成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><p>现在，我们的<code>Hexo</code>框架已经安装成功了。</p></li></ol><h3 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h3><p>想要看到博客运行起来，我们现在还需要对<code>Hexo</code>框架进行初始化。</p><p>在你的电脑上找一个合适的位置，创建一个文件夹，名字可以随便取，可以用Blog等等的名字，随个人喜好取名。为了便于演示，假设你取的名字叫做：<code>blog</code></p><p>注意，初始化是在我们创建的这个<code>blog</code>文件夹中初始化的，所以，我们的命令提示符（cmd）左边的路径要在这个<code>blog</code>文件夹中。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200301215807657.png" alt="image-20200301215807657"></p><center>进入刚刚创建的文件夹中</center>然后，在输入指令 ：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>初始化完成后，我们的<code>blog</code>文件夹中，就会生成这些文件：</p><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li>_config.yml: 博客的配置文件</li></ul><p>在安装一些必要的包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>初始化完成，在打开<code>hexo</code>服务器：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><p>我们，打开浏览器，输入：localhost:4000，就可以看到你的博客的雏形已经好了。</p><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>加入你觉得这个主题你不喜欢，想要找一个其他的主题，你可以进入Hexo的官网的<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题</a>板块，来选择你喜欢的主题：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200301221159332.png" alt="image-20200301221159332"></p><p>假如，你想更换为<code>3-hexo</code>，那就点击它，会跳转到该主题的创作者的GitHub上：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200301221422653.png" alt="image-20200301221422653"></p><p>安装<code>3-hexo</code>主题，其中命令的<code>themes/3-hexo</code>指的是该主题的安装位置：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/yelog/hexo-theme-3-hexo.git themes/3-hexo</span><br></pre></td></tr></table></figure><p>安装完之后，我们需要运行：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean          # 清除所有记录 </span><br><span class="line">$ hexo generate       # 生成静态网页 简写：hexo g</span><br><span class="line">$ hexo server         # 启动服务 简写：hexo s</span><br></pre></td></tr></table></figure><p>然后，我们就能在本地localhost:4000中，查看修改好的主题了。</p><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>如果你不想只在本地上查看你的博客，也想有自己的博客网址链接，那我们可以下载Git，把博客内容部署到<code>GitHub</code>或者<code>gitee</code>上面。我们这里以GitHub为例。</p><p>Git的官网点击<a href="https://git-scm.com/" target="_blank" rel="noopener">这里</a>。然后按照你的电脑的操作系统下载相应的版本。安装选项还是全部默认，只不过最后一步添加路径时选择<code>Use Git from the Windows Command Prompt</code>，这样我们就可以直接在命令提示符里打开git了。</p><p>安装完成后在命令提示符中输入<code>git --version</code>验证是否安装成功。</p><h3 id="GitHub账号"><a href="#GitHub账号" class="headerlink" title="GitHub账号"></a>GitHub账号</h3><p>如果你没有GitHub账号，我们现在去创建一个吧。点击<a href="https://github.com/" target="_blank" rel="noopener">这里</a>创建。创建完成之后，我们新建一个github仓库：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200301223129140.png" alt="image-20200301223129140"></p><p>注意你的仓库名字不要随便起，待会我们要用到。加入你GitHub名字叫“AAA”，那么仓库个名字就一定是：<code>AAA.github.io</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200301223729456.png" alt="image-20200301223729456"></p><h1 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h1><h2 id="将博客部署在github中"><a href="#将博客部署在github中" class="headerlink" title="将博客部署在github中"></a>将博客部署在github中</h2><p>目前，还不能部署到GitHub上。还需要下载<code>hexo-deployer-git</code>插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install hexo-deployer-git --save  <span class="comment">#通过cpnm安装git插件</span></span><br></pre></td></tr></table></figure><p>如果，你是刚刚才下载的Git，则还需要设置你的姓名和邮箱：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"Firstname Lastname"</span> // 名字使用英文输入</span><br><span class="line">git config --global user.email <span class="string">"your_email@example.com"</span></span><br></pre></td></tr></table></figure><p>还有你的SSH Key，创建公开密钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><p>​ 把生成的密钥添加到GitHub中去：</p><ol><li>找到生成的密钥：如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，我的在：<code>C:\Users\xxxx\.ssh</code>（xxxx是我的一个目录）。里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是<strong>私钥</strong>，不能泄露出去，<code>id_rsa.pub</code>是<strong>公钥</strong>，可以放心地告诉任何人。</li><li>在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个SSH，名字随便，把公钥复制进去。</li></ol><p>到这里，我们的git与远程的GitHub已经建立起关系了。</p><p>我们还需要把<code>blog</code>文件夹中的设置文件，即：<code>_config.yml</code>，将最后一行进行修改,：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: https://github.com/longlongqin/longlongqin.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>​ repository修改为你自己的github项目地址，在实际操作过程中，repository: <a href="mailto:git@github.com">git@github.com</a>:longlongqin/longlongqin.github.io.git,也是可以的。</p><p>修改之后，我们才能部署到GitHub上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deployer</span><br><span class="line"><span class="comment">## 初次使用这个命令，需要输入github的用户名username和密码password</span></span><br></pre></td></tr></table></figure><p>​ 这里，就是利用刚下载的插件：<code>hexo-deployer-git</code></p><p>现在我们可以访问我们在github服务器上的博客网址，网址就是我们刚刚创建仓库的名字，比如我的仓库名是：<code>longlongqin.github.io</code>，我们复制粘贴它到浏览器，然后你就可以看到你的博客内容了。😊</p><h2 id="Git提交到多个仓库"><a href="#Git提交到多个仓库" class="headerlink" title="Git提交到多个仓库"></a>Git提交到多个仓库</h2><p><a href="https://yuxiang.ren/2017/08/25/hexo博客自动部署到多台服务器/" target="_blank" rel="noopener">https://yuxiang.ren/2017/08/25/hexo%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%88%B0%E5%A4%9A%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/</a></p><h2 id="部署在gitee"><a href="#部署在gitee" class="headerlink" title="部署在gitee"></a>部署在gitee</h2><h3 id="部署在gitee上的坑"><a href="#部署在gitee上的坑" class="headerlink" title="部署在gitee上的坑"></a>部署在gitee上的坑</h3><p>在gitee上面，和在GitHub上面部署差不多，但是有些地方我们还是要注意的。</p><h4 id="仓库命名问题"><a href="#仓库命名问题" class="headerlink" title="仓库命名问题"></a>仓库命名问题</h4><p>在创建gitee仓库时，最好也是将仓库名字命名为你的账号的用户名，比如我的：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200302144640624.png" alt="image-20200302144640624"></p><p>​ 当然，你也可以命名为其他名字，但是换成其他名字之后，可能会带来一系列其他的问题，比如图片无法显示。其实我之前命名成其他名字，就出现了很大的问题：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200302015639908.png" alt="image-20200302015639908"></p><p>这种情况是因为，他找不到资源，加载错误：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200302015741200.png" alt="image-20200302015741200"></p><p>熬了一个晚上，终于发现了。在官方文档中有：</p><blockquote><p><strong>网站在子目录的情况</strong></p></blockquote><p>如果你的网站在一个子目录（例如<a href="https://link.jianshu.com/?t=http://example.org/blog" target="_blank" rel="noopener">http://example.org/blog</a>） 设置<code>url</code>为<code>http://example.org/blog</code>并且设置<code>root</code>为<code>/blog/</code></p><p>说来也奇怪，在GitHub上面，和本地运行的时候都是好好的。就是在gitee上面出错了。o(︶︿︶)o 唉</p><p>解决它的办法就是：</p><p>​ 将root添加上缺少的那一级目录，即可</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://yoursite.com/child</span></span><br><span class="line"></span><br><span class="line"><span class="attr">root:</span> <span class="string">/blog/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:post_title/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line"></span><br><span class="line"> <span class="attr">trailing_index:</span> <span class="literal">false</span>   <span class="comment"># Set to false to remove trailing 'index.html' from permalinks</span></span><br><span class="line"></span><br><span class="line"> <span class="attr">trailing_html:</span> <span class="literal">true</span>     <span class="comment"># Set to false to remove trailing '.html' from permalinks</span></span><br></pre></td></tr></table></figure><p>这一篇帖子里面也有人遇到了同样的问题，最后也是通过root的修改解决的。：<a href="https://gitee.com/oschina/git-osc/issues/IFVWV?from=project-issue" target="_blank" rel="noopener">https://gitee.com/oschina/git-osc/issues/IFVWV?from=project-issue</a></p><h4 id="gitee-pages刷新"><a href="#gitee-pages刷新" class="headerlink" title="gitee pages刷新"></a>gitee pages刷新</h4><p>除了仓库名字需要注意，我们还需要注意，gitee个人版似乎不能自动刷新，所以你<strong>每次</strong><code>hexo d</code>之后，需要手动的刷新<code>gitee pages</code>，才能显示你新提交的内容。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200302145524039.png" alt="image-20200302145524039"></p><h1 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h1><h2 id="编辑器推荐"><a href="#编辑器推荐" class="headerlink" title="编辑器推荐"></a>编辑器推荐</h2><p>推荐使用<code>Typora</code>这款软件，点击<a href="https://www.typora.io/" target="_blank" rel="noopener">这里</a>进入官网，他可以写Markdown格式的内容，这个软件的方便之处在于直接将markdown语法呈现出其效果，并且已经集成了很多方便的功能，你无需记住插入代码的语法格式，无需记住插入图片的语法格式，这使得我可以专心写博客而无法关心学习markdown语法。有很多md编辑器，他们分成两个界面，一个界面是md源代码，另外一个界面实时更新显示其效果，而Typora是浑然一体的，真正所见即所得，就跟在使用word一样方便。</p><p>不仅如此，它还可以导出PDF、Word、HTML、图片等格式。</p><p>待续……</p><h2 id="图片问题"><a href="#图片问题" class="headerlink" title="图片问题"></a>图片问题</h2><p><a href="http://etrd.org/2017/01/23/hexo中完美插入本地图片/" target="_blank" rel="noopener">http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/</a></p><h1 id="Hexo的操作指令"><a href="#Hexo的操作指令" class="headerlink" title="Hexo的操作指令"></a>Hexo的操作指令</h1><p>我们刚开始，对于<code>Hexo</code>的指令不太熟悉，我们可以在他的官网上去查找相应的操作指令。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200301222120697.png" alt="image-20200301222120697"></p><h2 id="文章的front-matter"><a href="#文章的front-matter" class="headerlink" title="文章的front-matter"></a><a href="https://hexo.io/zh-cn/docs/front-matter" target="_blank" rel="noopener">文章的front-matter</a></h2><h3 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code>的值。</p><table><thead><tr><th align="left">配置选项</th><th align="left">默认值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">title</td><td align="left"><code>Markdown</code> 的文档标题</td><td align="left">文章标题，强烈建议填写此选项</td></tr><tr><td align="left">date</td><td align="left">文档创建时的日期时间</td><td align="left">发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td align="left">author</td><td align="left">根 <code>_config.yml</code>中的 <code>author</code></td><td align="left">文章作者</td></tr><tr><td align="left">img</td><td align="left"><code>featureImages</code>中的某个值</td><td align="left">文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td align="left">top</td><td align="left"><code>true</code></td><td align="left">（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页</td></tr><tr><td align="left">password</td><td align="left">无</td><td align="left">文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td align="left">toc</td><td align="left"><code>true</code></td><td align="left">是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td align="left">mathjax</td><td align="left"><code>false</code></td><td align="left">是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文档中也需要开启才行</td></tr><tr><td align="left">summary</td><td align="left">无</td><td align="left">文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则进程会自动截取文章的部分内容作为摘要</td></tr><tr><td align="left">categories</td><td align="left">无</td><td align="left">文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td align="left">tags</td><td align="left">无</td><td align="left">文章标签，一篇文章可以多个标签</td></tr></tbody></table><p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量，举例来说：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hello</span> <span class="string">World</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2013</span><span class="string">/7/13</span> <span class="number">20</span><span class="string">:46:25</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h3 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a>分类和标签</h3><p>只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而标签没有顺序和层次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">- Diary</span><br><span class="line">tags:</span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br></pre></td></tr></table></figure><blockquote><p><strong>分类方法的分歧</strong></p><p>如果您有过使用 WordPress 的经验，就很容易误解 Hexo 的分类方式。WordPress 支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是 Hexo 不支持指定多个同级分类。下面的指定方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - Diary</span><br><span class="line">  - Life</span><br></pre></td></tr></table></figure><p>会使分类<code>Life</code>成为<code>Diary</code>的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。</p><p>如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">- [Diary, PlayStation]</span><br><span class="line">- [Diary, Games]</span><br><span class="line">- [Life]</span><br></pre></td></tr></table></figure><p>此时这篇文章同时包括三个分类： <code>PlayStation</code> 和 <code>Games</code> 分别都是父分类 <code>Diary</code> 的子分类，同时 <code>Life</code> 是一个没有子分类的分类。</p></blockquote><h3 id="JSON-Front-matter"><a href="#JSON-Front-matter" class="headerlink" title="JSON Front-matter"></a>JSON Front-matter</h3><p>除了 YAML 外，你也可以使用 JSON 来编写 Front-matter，只要将 <code>---</code> 代换成 <code>;;;</code> 即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;title&quot;: &quot;Hello World&quot;,</span><br><span class="line">&quot;date&quot;: &quot;2013&#x2F;7&#x2F;13 20:46:25&quot;</span><br><span class="line">;;;</span><br></pre></td></tr></table></figure><h1 id="配置过程遇到的问题"><a href="#配置过程遇到的问题" class="headerlink" title="配置过程遇到的问题"></a>配置过程遇到的问题</h1><h2 id="Hexo博客中文章图片不显示的坑"><a href="#Hexo博客中文章图片不显示的坑" class="headerlink" title="Hexo博客中文章图片不显示的坑"></a>Hexo博客中文章图片不显示的坑</h2><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/qqpyimg1583424159.gif" alt="img"></p><p>这个是真的坑，搞了好久，终于看到一篇博文，才解决了这个问题。放一下这篇文章的<a href="https://myfavs.win/2019/08/08/%E8%AE%B0%E5%BD%95-Hexo-%E5%9B%BE%E7%89%87%E7%9A%84%E5%9D%91/" target="_blank" rel="noopener">传送门</a>。</p><h2 id="在coding中SSL证书申请失败的坑"><a href="#在coding中SSL证书申请失败的坑" class="headerlink" title="在coding中SSL证书申请失败的坑"></a>在coding中SSL证书申请失败的坑</h2><p>在搭建到coding中步骤其实和在github中比较相似，就是给仓库命名原则的时候需要注意，尽量让仓库名字与你的用户名相同，即和在github中命名规则相似。</p><p>如果你之前都很顺利，那么在SSL证书申请时，需要注意了：你会遇到证书申请一直失败的情况。这是为什么呢？是这样的：</p><ul><li><p>第一次尝试，查资料说是如果之前你已经在github oages上部署了，你自己买的域名也已经解析过了。此时直接在coding pages中申请ssl的话，会失败。</p><p>解决的办法就是：先把用于解析github pages的那两条暂停了，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200306234025834.png" alt="image-20200306234025834"></p></li><li><p>然后，我再试试，还是申请失败。出现类似于下面的错误：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200306234233629.png" alt="image-20200306234233629"></p></li><li><p>继续去查。嗯，找到了，申请失败是因为我的域名在国外无法解析，这是我的DNS设置导致的。</p><p>解决办法：在解析的时候，需要将<strong>线路类型</strong>改成<strong>默认</strong>。去试一试，等待一小会</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200306234452437.png" alt="image-20200306234452437"></p><p>哇，终于申请成功了。</p><p>#Hexo博客备份</p><p>有时候我们外出，自己的电脑没有带，这时候想写博客怎么办。这也是有办法的，就是我们要先备份我们的博客。这里我们可以备份到github或者gitee.</p><p>拿github举例：</p><ul><li><p>首先，我们先要在GitHub上面建立一个仓库，仓库名字自取，仓库是public还是private，按照自己的心情来就好了。</p></li><li><p>然后，我们要在本地关联远程仓库：</p><p>我们进入你的本地博客所在的目录，比如我的在<code>D:\Blog</code>，然后，打开你的Git bash，按顺序输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init    <span class="comment">#初始化本地仓库</span></span><br><span class="line">git remote add origin &lt;你的远程仓库的SSH或HTTPS链接&gt;  <span class="comment">#关联远程仓库（ssh的链接比较快一点）</span></span><br></pre></td></tr></table></figure><p>关联完成，然后我们还需要，将本地的推送到远端，同样，按顺序输入一下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .  <span class="comment">#这个‘.’表示将整个文件夹都一起添加到暂存区（不然还要一个个输入文件名）</span></span><br><span class="line">git commit -m <span class="string">"输入你这次提交的说明"</span> </span><br><span class="line">git push origin master  <span class="comment">#推送到远程仓库</span></span><br></pre></td></tr></table></figure><p>好了，记得按时将本地的备份到远程仓库。</p></li></ul><p>至此，本地备份已经完成。如果你想同时备份到gitee和github上面，你可以参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/1163625339727712" target="_blank" rel="noopener">这里</a>。</p><h1 id="在另外一台电脑上写博客"><a href="#在另外一台电脑上写博客" class="headerlink" title="在另外一台电脑上写博客"></a>在另外一台电脑上写博客</h1><p>前提是我们把博客备份在github、gitee等上面。</p><p>然后在新电脑上面：</p><ol><li>安装 Git、nodejs</li><li>把你远程的博客备份，clone下来到一个指定的位置（位置自己定）</li><li>在本地的博客仓库运行：<code>npm install</code>，来 安装依赖包</li></ol><p>好了，你可开始写博客了。</p><h1 id="优化技巧"><a href="#优化技巧" class="headerlink" title="优化技巧"></a>优化技巧</h1><h2 id="优化文章URL"><a href="#优化文章URL" class="headerlink" title="优化文章URL"></a>优化文章URL</h2><p><code>seo</code>搜索引擎优化认为，网站的最佳结构是<strong>用户从首页点击三次就可以到达任何一个页面</strong>，但是我们使用<code>hexo</code>编译的站点打开文章的<code>url</code>是：<code>sitename/year/mounth/day/title</code>四层的结构，这样的<code>url</code>结构很不利于<code>seo</code>，爬虫就会经常爬不到我们的文章，于是，我们需要优化一下网站文章<code>url</code></p><p>方案一：</p><p>我们可以将<code>url</code>直接改成<code>sitename/title</code>的形式，并且<code>title</code>最好是用英文，在根目录的配置文件下修改<code>permalink</code>如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://sunhwee.com</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:title.html</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br></pre></td></tr></table></figure><p>方案二：</p><p>使用插件优化<code>url</code></p><p>插件<code>hexo-abbrlink</code>实现了这个功能，它将原来的<code>URL</code>地址重新进行了进制转换和再编码。</p><p>安装<code>hexo-abbrlink</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>配置博客根目录下的_config.yml文件。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># permalink: :title/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">archives/:abbrlink.html</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>  <span class="comment"># 算法：crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>    <span class="comment"># 进制：dec(default) and hex</span></span><br></pre></td></tr></table></figure><p>运行<code>hexo clean</code>和<code>hexo g</code>命令来重新生成文件看看，可以清楚的看到，<code>URL</code>结构成功变为了3层。</p><p>来源: 洪卫の博客<br>作者: 洪卫<br>文章链接: <a href="https://sunhwee.com/posts/6e8839eb.html#toc-heading-59" target="_blank" rel="noopener">https://sunhwee.com/posts/6e8839eb.html#toc-heading-59</a><br>本文章著作权归作者所有，任何形式的转载都请注明出处。</p><h1 id="其他参考文章"><a href="#其他参考文章" class="headerlink" title="其他参考文章"></a>其他参考文章</h1><p>列表：<br><a href="http://dongshuyan.com/2019/05/24/hexo博客注意事项/#14-Hexo添加百度统计" target="_blank" rel="noopener">http://dongshuyan.com/2019/05/24/hexo%E5%8D%9A%E5%AE%A2%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/#14-Hexo添加百度统计</a></p><p><a href="https://www.dazhuanlan.com/2019/10/16/5da6352aa2a2e/" target="_blank" rel="noopener">网络编程系列 Hexo + Github搭建个人博客 · 花田半亩</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo主题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
