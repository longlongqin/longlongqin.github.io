<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hexo中插入pdf</title>
      <link href="/archives/448ac7f1.html"/>
      <url>/archives/448ac7f1.html</url>
      
        <content type="html"><![CDATA[<p>法1：安装hexo-pdf插件</p><p>法2：利用html语法</p><a id="more"></a><h2 id="安装hexo-pdf插件"><a href="#安装hexo-pdf插件" class="headerlink" title="安装hexo-pdf插件"></a>安装hexo-pdf插件</h2><h3 id="hexo-pdf"><a href="#hexo-pdf" class="headerlink" title="hexo-pdf"></a><a href="https://github.com/superalsrk/hexo-pdf" target="_blank" rel="noopener">hexo-pdf</a></h3><p>Hexo tag for embeded pdf</p><h4 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save hexo-pdf</span><br></pre></td></tr></table></figure><h4 id="Normal-PDF"><a href="#Normal-PDF" class="headerlink" title="Normal PDF"></a>Normal PDF</h4><p>pdf链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf http:&#x2F;&#x2F;7xov2f.com1.z0.glb.clouddn.com&#x2F;bash_freshman.pdf %&#125;</span><br></pre></td></tr></table></figure><p>本地（<u>我的失败了，还没找到原因</u>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf .&#x2F;bash_freshman.pdf %&#125;</span><br></pre></td></tr></table></figure><h4 id="Google-drive"><a href="#Google-drive" class="headerlink" title="Google drive"></a>Google drive</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf https:&#x2F;&#x2F;drive.google.com&#x2F;file&#x2F;d&#x2F;0B6qSwdwPxPRdTEliX0dhQ2JfUEU&#x2F;preview %&#125;</span><br></pre></td></tr></table></figure><h4 id="Slideshare"><a href="#Slideshare" class="headerlink" title="Slideshare"></a>Slideshare</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf http:&#x2F;&#x2F;www.slideshare.net&#x2F;slideshow&#x2F;embed_code&#x2F;key&#x2F;8Jl0hUt2OKUOOE %&#125;</span><br></pre></td></tr></table></figure><p>示例：图片来源于网络</p><div class="row"><embed src="http://image.fiftykg.com/pdf/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E8%8F%9C%E5%8D%95%E8%B0%83%E7%A0%94.pdf" width="100%" height="550" type="application/pdf"></div><hr><h2 id="利用html语法"><a href="#利用html语法" class="headerlink" title="利用html语法"></a>利用html语法</h2><h3 id="首先修改-config-yml文件"><a href="#首先修改-config-yml文件" class="headerlink" title="首先修改_config.yml文件"></a>首先修改_config.yml文件</h3><p><strong>将_config.yml中的post_asset_folder选项置为true</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><p>关于这个选项的功能说明如下:</p><blockquote><p>当您设置post_asset_folder为true参数后，在建立文件时，Hexo<br>会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。</p></blockquote><h3 id="然后新建一篇文章"><a href="#然后新建一篇文章" class="headerlink" title="然后新建一篇文章"></a>然后新建一篇文章</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new</span><br></pre></td></tr></table></figure><blockquote><p>由于上一步已经将post_asset_folder选项设为了true<br>所以这一步新建文章时会创建一个md文件和一个同名的文件夹<br>为了方便叙述，我用test作为文件和文件夹名</p></blockquote><h3 id="编辑test-md"><a href="#编辑test-md" class="headerlink" title="编辑test.md"></a>编辑test.md</h3><blockquote><p>用vim或者别的编辑器打开test.md</p><p>test.md文件中加入如下代码</p><p><code>&lt;object data=&quot;./test/test.pdf&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;</code></p><p>关于这句代码简单的解释<br>data表示你要上传的pdf的路径,使用相对路径，将你要上传的pdf放入第二步生成的test文 件夹<br>type和width就不说了，这里注意height不能设成100%，不然太矮了，显示效果不好<br>可以用浏览器预览，通过F12预估一下高度。我最后代码如下，供参考</p><p><code>&lt;object data=&quot;./test/test.pdf&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;877px&quot;&gt;</code></p></blockquote><p>这里不一定非用object标签，embed、iframe标签也一样</p><p>具体参考:<a href="https://blog.csdn.net/qappleh/article/details/80250492" target="_blank" rel="noopener">网页链接</a></p><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><u><strong>注意</strong></u>：</h2><p><u>用html方法，在我的主题中，如果它后面有文字，会显示不出来，原因不详。</u></p><hr><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://github.com/superalsrk/hexo-pdf" target="_blank" rel="noopener">hexo-pdf官方教程</a></p><p><a href="http://miracle778.site/pdf-test/pdf-test.html" target="_blank" rel="noopener">hexo中插入pdf解决方法</a></p><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p><a href="http://lingr7.coding.me/2019/10/02/theme-hexo-pdf%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7-%E8%A7%A3%E5%86%B3hexo-pdf%E6%96%87%E4%BB%B6%E6%98%BE%E7%A4%BA%E4%B8%8D%E5%85%A8%E7%9A%84%E9%97%AE%E9%A2%98.html" target="_blank" rel="noopener">theme-hexo-pdf使用技巧—-解决hexo-pdf文件显示不全的问题</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo显示pdf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnCpp Note</title>
      <link href="/archives/a0a78e77.html"/>
      <url>/archives/a0a78e77.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red>LearnCpp</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h1 id="0-5-介绍compiler-linker-and-libraries"><a href="#0-5-介绍compiler-linker-and-libraries" class="headerlink" title="0.5 介绍compiler, linker, and libraries"></a>0.5 介绍compiler, linker, and libraries</h1><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LearnCpp-Note/Development-min.png" alt="Development-min"></p><h2 id="Step-4-Compiling-your-source-code"><a href="#Step-4-Compiling-your-source-code" class="headerlink" title="Step 4: Compiling your source code"></a>Step 4: Compiling your source code</h2><p>为了编译C++程序，我们需要一个编译器。编译器主要是对每一个<code>.cpp</code>文件做两件事情：</p><ol><li>它检查你的代码是否符合C++的规则。如果不符合，就会报错（同时返回相应的行号）来帮助你确定什么需要修改，同时停止编译</li><li>它将C++源代码翻译成机器代码文件（叫做：<red><strong>object file</strong></red>）。<strong>object file</strong>的名字通常是这种形式：<u><em>name.o</em></u> 或者 <u><em>name.obj</em></u>（其中name与<code>.cpp</code>文件的name是对应的）。</li></ol><p>例如：下面的三个.cpp的源文件，编译之后形成：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LearnCpp-Note/CompileSource-min.png" alt="The compilation process"></p><hr><h2 id="Step-5-Linking-object-files-and-libraries"><a href="#Step-5-Linking-object-files-and-libraries" class="headerlink" title="Step 5: Linking object files and libraries"></a>Step 5: Linking object files and libraries</h2><p><strong>编译器compiler **编译完成后，生成若干的 object files。接下来就需要</strong>链接器Linker**出马了。linker的工作主要有三方面：</p><ol><li><p>将所有的object files（编译之后生成的）合并成为一个<em>可执行程序executable program</em></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LearnCpp-Note/LinkingObjects-min.png" alt="LinkingObjects-min"></p></li><li><p>此外，linker还可以链接<strong>库文件library files</strong>（library files是一个已经预编译好的代码经过“打包”，在其他程序中重用）</p><blockquote><p>C++有有一个扩充的库，叫做：标准库<strong>C++ Standard Library</strong>。它提供额外的功能性库，比如我们常用的<em>iostream library</em></p><p>你可以有选择性的去链接其他库，比如当你想写一个播放声音的程序。你肯定不想从头到尾的去写如何去读取文件、检查文件是否有效….. 这时候，我们只需要下载相关的库进行利用就方便很多了。</p></blockquote></li><li><p>连接器会确保所有的跨文件依赖项都正确的解析了。</p><blockquote><p>例如：</p><p>如果你在一个.cpp文件中定义了”A”，然后在另一个.cpp文件中去使用”A”。linker就会将这两个文件联系起来。如果链接不成功，就会报错并且连接终止</p></blockquote></li></ol><p>只要linker成功的完成所有的“object files 和 libraries ”的链接工作，你就会得到一个可执行文件，然后你就可以运行它。</p><table><thead><tr><th align="left">Makefile</th></tr></thead><tbody><tr><td align="left">【注】有些开发环境使用<strong>Makefile</strong>，它是一个描述如何构建一个程序的文件（哪一个文件要编译&amp;链接，或者以不同方式处理）它是一个强大的工具。但是在本系列课程我们不回去讲解它。</td></tr></tbody></table><h2 id="Steps-6-amp-7-Testing-and-Debugging"><a href="#Steps-6-amp-7-Testing-and-Debugging" class="headerlink" title="Steps 6 &amp; 7: Testing and Debugging"></a>Steps 6 &amp; 7: Testing and Debugging</h2><p>如果你的可执行程序没有按照预期的工作，那么你就需要调试。</p><h2 id="Integrated-development-environments-IDEs"><a href="#Integrated-development-environments-IDEs" class="headerlink" title="Integrated development environments (IDEs)"></a>Integrated development environments (IDEs)</h2><p><u>【note】step3、4、5、7（editor, compiler, linker, debugger）都是需要软件的。</u></p><p>当然，你可以每一部分都是用独立的软件，但是有这样的一个软件包：<u><strong>integrated development environment (IDE)集成开发环境</strong></u> 将上面四步一体化。</p><hr><h1 id="0-6-compling-your-first-program"><a href="#0-6-compling-your-first-program" class="headerlink" title="0.6 compling your first program"></a>0.6 compling your first program</h1><p><strong>Console projects</strong></p><p>控制台项目没有<strong>graphical user interface (GUI)图形用户界面</strong>，它在控制台中打印text，从输入设备键盘读取信息。并且被编译成独立的可执行文件。</p><p><strong>Workspaces / solutions</strong></p><p>当创建一个项目时，许多IDE会自动给这个项目创建一个 “workspace” 或 “solution” 。</p><p><strong>workspace or solution</strong>：是一个可以容纳多个相关的项目的container。（例如，你正在写一个游戏，你想有一个单人 与 多人分开的可执行文件，那就需要创建两个项目。<strong>但是</strong>将这两个项目分开始没有意义的，因为它们属于同一个游戏的。所以，<u>最好的就是每一个都被配置为单个工作空间/解决方案中的 一个单独项目</u>。）</p><h1 id="0-8-—-C-中常见问题"><a href="#0-8-—-C-中常见问题" class="headerlink" title="0.8 — C++中常见问题"></a>0.8 — C++中常见问题</h1><h2 id="General-run-time-issues"><a href="#General-run-time-issues" class="headerlink" title="General run-time issues"></a>General run-time issues</h2><ol><li><p><strong>当执行程序时，控制台窗口闪烁，然后立即关闭？</strong></p><ul><li>1、首先确保下面的这几行在你的源程序的最上部（visio studio 用户，请确认如果有 #include “pch.h” or #include “stdafx.h” ，那么让它在最顶顶顶部的）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>2、在main()函数中的结束部分（但要在return 语句上面）添加如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">clear</span>(); <span class="comment">// reset any error flags</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>); <span class="comment">// ignore any characters in the input buffer until we find an enter character</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>(); <span class="comment">// get one more char from the user</span></span><br></pre></td></tr></table></figure><p><u>避免使用</u>：<code>system(&quot;pause&quot;)</code> 因为它只能在特定的操作系统中使用</p></li><li><p><strong>运行程序，得到窗口，但没有输出？</strong></p><p>有可能是你的xx安全管家等拦截的。试着关闭它们，然后重新运行</p></li><li><p><strong>程序编译成功，但是没有正确工作？</strong></p><p>去debug它</p></li></ol><h2 id="General-compile-time-issues"><a href="#General-compile-time-issues" class="headerlink" title="General compile-time issues"></a>General compile-time issues</h2><ol><li><p><strong>当编译程序时，得到一个未解析的外部符号：_main or _WinMain@16 ？</strong></p><p>说明你的编译器找不到main()函数。</p></li></ol><h2 id="Visual-Studio-issues"><a href="#Visual-Studio-issues" class="headerlink" title="Visual Studio issues"></a>Visual Studio issues</h2><ol><li><p><strong>使用Microsoft Visual c++进行编译时，得到C1010 fatal error，并且伴随着提示信息，如：”c:\vcprojects\test.cpp(263) :fatal error C1010: unexpected end of file while looking for precompiled header directive”</strong></p><p>答：这种问题出现在：当microsoft visual c++编译器被设置为使用预编译头文件，但您的c++代码文件中有一个(或多个)没有将<code>#include “stdafx.h”</code> or <code>#include “pch.h”</code>作为代码文件的第一行。</p><p>建议：</p><ol><li><p>在创建项目时，将预编译头 <em>precompiled headers</em>选项关闭。</p></li><li><p>如果您希望保持打开预编译头文件，要修复这个问题，只需找到产生错误的文件(在上面的错误中，test.cpp是罪魁祸首)，并在文件的<u>最顶部</u>添加以下行:</p><p><code>#include “pch.h”</code>或者<code>#include “stdafx.h”</code>【老版本的VS使用“stdafx.h” ，当其中一个不起作用，可以换成另外一个】</p><blockquote><p>注意，每一个C++文件都是从这一行开始的。如果不想从这一行开始，那就在创建项目的时候关闭“预编译头文件”选项</p></blockquote></li></ol></li><li><p>出现错误：<strong>“1MSVCRTD.lib(exe_winmain.obj) : error LNK2019: unresolved external symbol _WinMain@16 referenced in function “int __cdecl invoke_main(void)” (?invoke_main@@YAHXZ)”</strong></p><p>答：您可能已经创建了一个Windows图形化应用程序，而不是控制台应用程序。重新创建项目，并确保将其创建为Windows(或Win32)控制台项目。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let’s Build A Simple Interpreter-9</title>
      <link href="/archives/8632918.html"/>
      <url>/archives/8632918.html</url>
      
        <content type="html"><![CDATA[<p><yellow>今天要学习的内容：</yellow></p><ol><li>如何parse and interpret 一个Pascal程序的<strong>定义 definition</strong></li><li>如何parse and interpret <strong>复合语句compound statements</strong></li><li>如何parse and interpret <strong>赋值语句(包括变量)assignment statements, including variables.</strong></li><li>介绍符号表，以及如何存储和查找变量。</li></ol><a id="more"></a><p>原文链接：<a href="https://ruslanspivak.com/lsbasi-part9/" target="_blank" rel="noopener">https://ruslanspivak.com/lsbasi-part9/</a></p><p>下面是一个简单的 Pascal程序，来介绍新概念：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        number := <span class="number">2</span>;</span><br><span class="line">        a := number;</span><br><span class="line">        b := <span class="number">10</span> * a + <span class="number">10</span> * number / <span class="number">4</span>;</span><br><span class="line">        c := a - - b</span><br><span class="line">    <span class="keyword">END</span>;</span><br><span class="line">    x := <span class="number">11</span>;</span><br><span class="line"><span class="keyword">END</span>.</span><br></pre></td></tr></table></figure><p>今天所学内容与前面的part1~8相比有了很大的飞跃，现在不再是像以前一样只是一个计算器了。我们要提升一下档次了☻</p><h2 id="新的语法树及规则"><a href="#新的语法树及规则" class="headerlink" title="新的语法树及规则"></a><red>新的语法树及规则</red></h2><p>现在，来看看新语言结构的<em>语法树syntax diagrams</em> 以及其对应的<em>语法规则grammar rules</em></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-9/lsbasi_part9_syntax_diagram_01.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-9/lsbasi_part9_syntax_diagram_02.png" alt="img">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-9/lsbasi_part9_syntax_diagram_03.png" alt="img"></p><h3 id="pascal语法"><a href="#pascal语法" class="headerlink" title="pascal语法"></a><red>pascal语法</red></h3><p>一个Pascal语法由一下组成&lt;<red>这不是完整的定义，会在后面文章慢慢扩展</red>&gt;：</p><ul><li><strong>BEGIN</strong>开头</li><li>中间是<strong>复合语句<em>compound statement</em></strong>，</li><li>一个<strong>点(dot) “.”</strong>结束</li></ul><h4 id="compound-statement"><a href="#compound-statement" class="headerlink" title="compound statement"></a><red><em>compound statement</em></red></h4><p><em>compound statement</em>是一个block(区块)：</p><ul><li>它标有BEGIN 和 END ，中间可能(也可能没有)包含有<u>一段语句</u>或<u>其他的复合语句<em>compound</em></u> statement</li><li>所有嵌入在复合语句中的句子，除了最后一个，其他的都要以分号“;”结尾</li><li>在block中的最后一个句子(last statement)可能或可能没有 中断分号“;”</li></ul><p>如下面所示：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">“<span class="keyword">BEGIN</span> <span class="keyword">END</span>”</span><br><span class="line">“<span class="keyword">BEGIN</span> a := <span class="number">5</span>; x := <span class="number">11</span> <span class="keyword">END</span>”</span><br><span class="line">“<span class="keyword">BEGIN</span> a := <span class="number">5</span>; x := <span class="number">11</span>; <span class="keyword">END</span>”</span><br><span class="line">“<span class="keyword">BEGIN</span> <span class="keyword">BEGIN</span> a := <span class="number">5</span> <span class="keyword">END</span>; x := <span class="number">11</span> <span class="keyword">END</span>”</span><br></pre></td></tr></table></figure><h4 id="statement-list"><a href="#statement-list" class="headerlink" title="statement list"></a><red><em>statement list</em></red></h4><p>一个<strong><em>statement list</em></strong> 含有0个或多个语句，其位于<em>compound statement</em>内。如上面的例子</p><h4 id="statement"><a href="#statement" class="headerlink" title=" statement"></a><red><em>statement</em></red></h4><p>一个<em>statement<em>可以是一个 *compound statement</em>， 一个赋值语句<em>assignment statement</em>，或者是一个空语句*empty</em> statement。</p><h4 id="assignment-statement"><a href="#assignment-statement" class="headerlink" title="assignment statement"></a><red><em>assignment statement</em></red></h4><p>一个赋值语句的组成：<u>一个变量</u> 后面跟着 <u>一个指定的token（two characters, ‘:’ and ‘=’）</u> 后面跟着 <u>一个表达式</u>。如下所示：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“a := <span class="number">11</span>”</span><br><span class="line">“b := a + <span class="number">9</span> - <span class="number">5</span> * <span class="number">2</span>”</span><br></pre></td></tr></table></figure><h4 id="varible"><a href="#varible" class="headerlink" title="varible"></a><red><em>varible</em></red></h4><p>一个 <strong>变量<em>variable</em></strong>是一个<u>标识符<em>identifier</em></u>。我们将用ID token来表示variables，这个token的value是变量的名字(如，‘a’、‘number’、‘x’…..)。在下面的一个block的代码中的‘a’、‘b’就是变量：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“<span class="keyword">BEGIN</span> a := <span class="number">11</span>; b := a + <span class="number">9</span> - <span class="number">5</span> * <span class="number">2</span> <span class="keyword">END</span>”</span><br></pre></td></tr></table></figure><h4 id="empty-statement"><a href="#empty-statement" class="headerlink" title="empty statement"></a><red><strong><em>empty</em></strong> statement</red></h4><p>一个空语句表示一个语法规则，这个语法规则没有更深层的产生式<em>productions<em>。我们使用</em>empty_statement<em>语法规则来描述语法分析中末尾的</em>statement_list</em> ；同时也允许一个空的复合语句<em>compound statements</em>表示为：‘BEGIN END’</p><h4 id="factor"><a href="#factor" class="headerlink" title="factor"></a><red><em>factor</em></red></h4><p><em>factor</em>的规则更新为处理变量。</p><h3 id="完整的语法"><a href="#完整的语法" class="headerlink" title="完整的语法"></a>完整的语法</h3><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> : compound_statement DOT</span><br><span class="line"></span><br><span class="line">compound_statement : <span class="keyword">BEGIN</span> statement_list <span class="keyword">END</span></span><br><span class="line"></span><br><span class="line">statement_list : statement</span><br><span class="line">               | statement SEMI statement_list</span><br><span class="line"></span><br><span class="line">statement : compound_statement</span><br><span class="line">          | assignment_statement</span><br><span class="line">          | empty</span><br><span class="line"></span><br><span class="line">assignment_statement : variable ASSIGN expr</span><br><span class="line"></span><br><span class="line">empty :</span><br><span class="line"></span><br><span class="line">expr: term ((PLUS | MINUS) term)*</span><br><span class="line"></span><br><span class="line">term: factor ((MUL | DIV) factor)*</span><br><span class="line"></span><br><span class="line">factor : PLUS factor</span><br><span class="line">       | MINUS factor</span><br><span class="line">       | INTEGER</span><br><span class="line">       | LPAREN expr RPAREN</span><br><span class="line">       | variable</span><br><span class="line"></span><br><span class="line">variable: ID</span><br></pre></td></tr></table></figure><p>上面的语法中，</p><ul><li>在<em>compound_statement</em> rule 中没有用“<em>”来表示重复（0或多次），而是明确的制定了 *statement_list</em> rule。这是另一种方法来表示“0或多次”的操作。这在后面的语法分析器（如<a href="http://www.dabeaz.com/ply/" target="_blank" rel="noopener">PLY</a>）会派上用场。</li><li>我还将规则：“(PLUS | MINUS) factor”也细分成两个规则。</li></ul><h2 id="修改lexer-parser-interpreter"><a href="#修改lexer-parser-interpreter" class="headerlink" title="修改lexer,parser,interpreter"></a><red>修改lexer,parser,interpreter</red></h2><p>为了支持更新后的语法，我们需要修改我们的此番分析器、语法分析器和解释器。</p><h3 id="lexer的改变"><a href="#lexer的改变" class="headerlink" title="lexer的改变"></a><red>lexer的改变</red></h3><p>下面是我们此番分析器有改动的地方：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-9/lsbasi_part9_lexer.png" alt="img"></p><ol><li><p>为了支持Pascal程序的定义、复合语句、赋值语句、变量。我们需要新的token类型：（Pascal program’s definition, compound statements, assignment statements, and variables）</p><ul><li>BEGIN (标记复合语句的开始)</li><li>END (标记复合语句的结束)</li><li>DOT (一个token表示 点，用于Pascal程序的定义)</li><li>ASSIGN (一个token表示两个字符， ‘:=’)在Pascal中，赋值操作符不同于其他语言（如C语言用 “=”）</li><li>SEMI (一个token表示分号‘ ; ’ 。用来标记在复合语句中的一个句子的结尾)</li><li>ID（一个token表示 有效的标识符。）</li></ul></li><li><p>有时候，为了区分不同token（它们都以相同的字符为开头，如：‘:’ vs ‘:=’ or ‘==’ vs ‘=&gt;’），我们需要在不消耗下一个字符的情况下去查看输入缓冲区。为了这个特殊的目的，我介绍一种查看方法<em>peek</em> method，这种方法将帮助我们标记赋值语句。这个方法不是必要的，但是还是想早一点介绍一下，并且它也使得<em>get_next_token</em>函数简洁一些。</p><p>它所做的目的就是：从文本缓冲区返回下一个字符，但不增加<em>self.pos</em>的值。下面是这个方法的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">    peek_pos = self.pos + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> peek_pos &gt; len(self.text) - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> self.text[peek_pos]</span><br></pre></td></tr></table></figure></li><li><p>因为pascal中的 变量 和 保留字 都是 标识符。所以我们需要用一个方法来区分它们，方法为：<strong><em>_id</em></strong>。它工作的原理：词法分析器对这个字母、数字序列进行检查，看这个序列是否是保留字<em>reserved keyword</em>，如果是，就返回一个预先构造的token来表示这个保留字；如果不是，就返回一个新的ID token（它的值就是这个字符串）（lexeme）.下面是它的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RESERVED_KEYWORDS = &#123;</span><br><span class="line">    <span class="string">'BEGIN'</span>: Token(<span class="string">'BEGIN'</span>, <span class="string">'BEGIN'</span>),</span><br><span class="line">    <span class="string">'END'</span>: Token(<span class="string">'END'</span>, <span class="string">'END'</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_id</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Handle identifiers and reserved keywords"""</span></span><br><span class="line">    result = <span class="string">''</span></span><br><span class="line">    <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isalnum():</span><br><span class="line">        result += self.current_char</span><br><span class="line">        self.advance()</span><br><span class="line"></span><br><span class="line">    token = RESERVED_KEYWORDS.get(result, Token(ID, result))</span><br><span class="line">    <span class="keyword">return</span> token</span><br></pre></td></tr></table></figure></li><li><p>词法分析器的函数<em>get_next_token</em>的改变:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> self.current_char.isalpha():</span><br><span class="line">            <span class="keyword">return</span> self._id()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.current_char == <span class="string">':'</span> <span class="keyword">and</span> self.peek() == <span class="string">'='</span>:</span><br><span class="line">            self.advance()</span><br><span class="line">            self.advance()</span><br><span class="line">            <span class="keyword">return</span> Token(ASSIGN, <span class="string">':='</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.current_char == <span class="string">';'</span>:</span><br><span class="line">            self.advance()</span><br><span class="line">            <span class="keyword">return</span> Token(SEMI, <span class="string">';'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.current_char == <span class="string">'.'</span>:</span><br><span class="line">            self.advance()</span><br><span class="line">            <span class="keyword">return</span> Token(DOT, <span class="string">'.'</span>)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></li></ol><h3 id="parser的改变"><a href="#parser的改变" class="headerlink" title="parser的改变"></a><red>parser的改变</red></h3><p>下面是它的总的变化：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-9/lsbasi_part9_parser.png" alt="img"></p><ol><li><p>新的AST结点：</p><ul><li><p><strong><em>Compound</em> AST node</strong>：表示一个复合语句，在它的孩子的变量中包含着语句节点的列表；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compound</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="string">"""Represents a 'BEGIN ... END' block"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.children = []</span><br></pre></td></tr></table></figure></li><li><p><strong><em>Assign</em> AST node</strong>：表示赋值语句。它的左孩子的值是<strong><em>Var</em> node</strong>，右孩子结点存储着由expr解析器返回的结点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Assign</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, left, op, right)</span>:</span></span><br><span class="line">        self.left = left</span><br><span class="line">        self.token = self.op = op</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure></li><li><p><strong><em>Var</em> AST node</strong>：表示一个变量，它的value就是着这个变量的名字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Var</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="string">"""The Var node is constructed out of ID token."""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, token)</span>:</span></span><br><span class="line">        self.token = token</span><br><span class="line">        self.value = token.value</span><br></pre></td></tr></table></figure></li><li><p><strong><em>NoOp</em> node</strong>：用来表示一个空语句。如<code>‘BEGIN END’</code> 是一个有效的复合语句但没有句子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoOp</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>我们之前讲过，在我们的递归的语法分析器中每一个语法的规则都有相应的函数(method)。这次将增加7个新的函数。这些函数都是用于语法分析中新的语法和新的AST结点。下面就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">program</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""program : compound_statement DOT"""</span></span><br><span class="line">    node = self.compound_statement()</span><br><span class="line">    self.eat(DOT)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compound_statement</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    compound_statement: BEGIN statement_list END</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    self.eat(BEGIN)</span><br><span class="line">    nodes = self.statement_list()</span><br><span class="line">    self.eat(END)</span><br><span class="line"></span><br><span class="line">    root = Compound()</span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">        root.children.append(node)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">statement_list</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    statement_list : statement</span></span><br><span class="line"><span class="string">                   | statement SEMI statement_list</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    node = self.statement()</span><br><span class="line"></span><br><span class="line">    results = [node]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> self.current_token.type == SEMI:</span><br><span class="line">        self.eat(SEMI)</span><br><span class="line">        results.append(self.statement())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.current_token.type == ID:</span><br><span class="line">        self.error()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">statement</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    statement : compound_statement</span></span><br><span class="line"><span class="string">              | assignment_statement</span></span><br><span class="line"><span class="string">              | empty</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> self.current_token.type == BEGIN:</span><br><span class="line">        node = self.compound_statement()</span><br><span class="line">    <span class="keyword">elif</span> self.current_token.type == ID:</span><br><span class="line">        node = self.assignment_statement()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        node = self.empty()</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">assignment_statement</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    assignment_statement : variable ASSIGN expr</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    left = self.variable()</span><br><span class="line">    token = self.current_token</span><br><span class="line">    self.eat(ASSIGN)</span><br><span class="line">    right = self.expr()</span><br><span class="line">    node = Assign(left, token, right)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">variable</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    variable : ID</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    node = Var(self.current_token)</span><br><span class="line">    self.eat(ID)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">empty</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""An empty production"""</span></span><br><span class="line">    <span class="keyword">return</span> NoOp()</span><br></pre></td></tr></table></figure></li><li><p><strong><em>factor</em></strong> 函数的修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""factor : PLUS  factor</span></span><br><span class="line"><span class="string">              | MINUS factor</span></span><br><span class="line"><span class="string">              | INTEGER</span></span><br><span class="line"><span class="string">              | LPAREN expr RPAREN</span></span><br><span class="line"><span class="string">              | variable</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    token = self.current_token</span><br><span class="line">    <span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">        self.eat(PLUS)</span><br><span class="line">        node = UnaryOp(token, self.factor())</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        node = self.variable()</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure></li><li><p><strong><em>parse</em></strong> ：更新之后，它从程序的定义开始语法的分析：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self)</span>:</span></span><br><span class="line">    node = self.program()</span><br><span class="line">    <span class="keyword">if</span> self.current_token.type != EOF:</span><br><span class="line">        self.error()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure></li></ol><p>下面是一个简单的程序：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        number := <span class="number">2</span>;</span><br><span class="line">        a := number;</span><br><span class="line">        b := <span class="number">10</span> * a + <span class="number">10</span> * number / <span class="number">4</span>;</span><br><span class="line">        c := a - - b</span><br><span class="line">    <span class="keyword">END</span>;</span><br><span class="line">    x := <span class="number">11</span>;</span><br><span class="line"><span class="keyword">END</span>.</span><br></pre></td></tr></table></figure><p>它的解析树为（为了简洁，下面的树中变量的名字所在结点就是<strong><em>Var</em> node</strong>，** <strong>Assign node</strong>赋值结点 表示为 ‘:=’ ）：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://ruslanspivak.com/lsbasi-part9/lsbasi_part9_full_ast.png" alt="img"></p><h4 id="interpreter的改变"><a href="#interpreter的改变" class="headerlink" title="interpreter的改变"></a><red>interpreter的改变</red></h4><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-9/lsbasi_part9_interpreter.png" alt="img"></p><p>为了解释新的AST结点，我们需要在interpreter中添加相应的visitor 函数：</p><ul><li>visit_Compound</li><li>visit_Assign</li><li>visit_Var</li><li>visit_NoOp</li></ul><p>其中，<code>visit_Compound</code>：遍历它的孩子节点和<code>visit_NoOp</code>：什么都不做。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_Compound</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> node.children:</span><br><span class="line">        self.visit(child)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_NoOp</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><code>visit_Assign</code>：当我们给变量赋值时，需要将该变量的值存到某个地方，待用。这也就是此函数的功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_Assign</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    var_name = node.left.value</span><br><span class="line">    self.GLOBAL_SCOPE[var_name] = self.visit(node.right)</span><br></pre></td></tr></table></figure><blockquote><p>这个函数存储了一个键-值对key-value pair（一个变量名、一个变量的值），存储在<em>symbol table</em> GLOBAL_SCOPE。</p><ul><li><p>what is <em>symbol table</em>?</p><p><strong><em>symbol table</em></strong>是一个抽象数据类型（abstract data type (<strong>ADT</strong>)），用于跟踪源码中各种符号。目前的符号类型还只有变量，我们用Python字典趋势线符号表的ADT。</p><p>（在这里用符号字表却实现的笨拙：因为它不是一个带有特殊方法的独立类，而是一个简单的Python字典，而且它的另外职责是 内存空间。在后面的文章中，原作者将会带我们了解symbol tables的细节）</p></li></ul></blockquote><ul><li><p>让我们来看一下“a := 3;” 的AST，和它的 symbol table （<em>visit_Assign</em> 函数处理前和处理后的）：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-9/lsbasi_part9_ast_st01-1584541191100.png" alt="lsbasi_part9_ast_st01"></p></li></ul><p>现在让我们看看句子：“b := a + 7;”的AST：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-9/lsbasi_part9_ast_only_st02.png" alt="lsbasi_part9_ast_only_st02"></p><p><code>visit_Var</code>：可以看出，赋值语句得到右半部分：“a + 7” 提及变量a，所以我们要先知道变量a的value，这就是visit_Var函数要干的事情：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_Var</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    var_name = node.value</span><br><span class="line">    val = self.GLOBAL_SCOPE.get(var_name)</span><br><span class="line">    <span class="keyword">if</span> val <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> NameError(repr(var_name))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> val</span><br></pre></td></tr></table></figure><blockquote><p>visit 一个 <em>Var</em> 结点：它首先得到变量的名字；然后这个变量名字作为进入<em>GLOBAL_SCOPE</em> dictionary的key🔑去寻找变量的value，如果找到了 就返回变量地值，如果找不到就NameError函数伺候。</p><p>下面是“b := a + 7;”的AST和符号表（赋值前和复制后）</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-9/lsbasi_part9_ast_st02.png" alt="lsbasi_part9_ast_st02"></p></blockquote><hr><p>上面就是今天所有需要进行的update了。</p><p>At the end of the main program, we simply print the contents of the symbol table GLOBAL_SCOPE to standard output.</p><p>Let’s take our updated interpreter for a drive both from a Python interactive shell and from the command line. Make sure that you downloaded both the source code for the interpreter and the <a href="https://github.com/rspivak/lsbasi/blob/master/part9/python/assignments.txt" target="_blank" rel="noopener">assignments.txt</a> file before testing:</p><p>Launch your Python shell:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ python</span><br><span class="line">&gt;&gt;&gt; from spi import Lexer, Parser, Interpreter</span><br><span class="line">&gt;&gt;&gt; text &#x3D; &quot;&quot;&quot;\</span><br><span class="line">... BEGIN</span><br><span class="line">...</span><br><span class="line">...     BEGIN</span><br><span class="line">...         number :&#x3D; 2;</span><br><span class="line">...         a :&#x3D; number;</span><br><span class="line">...         b :&#x3D; 10 * a + 10 * number &#x2F; 4;</span><br><span class="line">...         c :&#x3D; a - - b</span><br><span class="line">...     END;</span><br><span class="line">...</span><br><span class="line">...     x :&#x3D; 11;</span><br><span class="line">... END.</span><br><span class="line">... &quot;&quot;&quot;</span><br><span class="line">&gt;&gt;&gt; lexer &#x3D; Lexer(text)</span><br><span class="line">&gt;&gt;&gt; parser &#x3D; Parser(lexer)</span><br><span class="line">&gt;&gt;&gt; interpreter &#x3D; Interpreter(parser)</span><br><span class="line">&gt;&gt;&gt; interpreter.interpret()</span><br><span class="line">&gt;&gt;&gt; print(interpreter.GLOBAL_SCOPE)</span><br><span class="line">&#123;&#39;a&#39;: 2, &#39;x&#39;: 11, &#39;c&#39;: 27, &#39;b&#39;: 25, &#39;number&#39;: 2&#125;</span><br></pre></td></tr></table></figure><p>And from the command line, using a source file as input to our interpreter:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python spi.py assignments.txt</span><br><span class="line">&#123;&#39;a&#39;: 2, &#39;x&#39;: 11, &#39;c&#39;: 27, &#39;b&#39;: 25, &#39;number&#39;: 2&#125;</span><br></pre></td></tr></table></figure><p>If you haven’t tried it yet, try it now and see for yourself that the interpreter is doing its job properly.</p><h2 id="summary"><a href="#summary" class="headerlink" title="summary"></a><red>summary</red></h2><p>让我们来总结一下，你今天扩展了Pascal解释器的哪些部分：</p><ol><li>添加新的语法规则</li><li>添加新的token，和它对应词法分析器中的方法（也更新了<em>get_next_token</em>）</li><li>在 parser 中为新的语法结构添加新的AST结点</li><li>在（递归下降的）语法分析中 添加相应对应新语法规则的新函数，</li><li>在interpreter中增添了新的visitor函数</li><li>新增 用于存储和查找变量的字典</li></ol><h2 id="HACKS"><a href="#HACKS" class="headerlink" title="HACKS"></a><red>HACKS</red></h2><p>现在要介绍一下“hacks”，并且随着系列文章的深入，我们还将一步步删除这些内容：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-9/lsbasi_part9_hacks.png" alt="lsbasi_part9_hacks"></p><p center large><blue>未完待续</blue>....</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Let&#39;s Build A Simple Interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Front-matter的规则</title>
      <link href="/archives/138a.html"/>
      <url>/archives/138a.html</url>
      
        <content type="html"><![CDATA[<p>文章写作时，的front matter 的参数</p><a id="more"></a><p>参数描述<code>layout</code>布局<code>title</code>标题<code>date</code>建立日期<code>updated</code>更新日期<code>comments</code>开启文章的评论功能<code>tags</code>标签（不适用于分页）<code>categories</code>分类（不适用于分页）<code>permalink</code>覆盖文章网址</p><p>其中，分类和标签需要区别一下，分类具有顺序性和层次性，也就是说<code>Foo</code>，<code>Bar</code>不等于<code>Bar</code>，<code>Foo</code>；而标签没有顺序和层次。</p><p><strong>注意：每个冒号后面是有一个空格的。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">title: 文章的front-matter规则 <span class="comment">// 你的博客名字    </span></span><br><span class="line">date: <span class="number">2019</span><span class="number">-08</span><span class="number">-10</span> <span class="number">21</span>:<span class="number">44</span>:<span class="number">44</span>  <span class="comment">//文章创建的日期</span></span><br><span class="line">author: longlongqin   <span class="comment">//作者名字</span></span><br><span class="line">img: /medias/banner/<span class="number">6.</span>jpg <span class="comment">//文章的显示的时候的背景</span></span><br><span class="line">coverImg: /medias/banner/<span class="number">6.</span>jpg  </span><br><span class="line">top: <span class="literal">true</span></span><br><span class="line">cover: <span class="literal">true</span></span><br><span class="line">toc: <span class="literal">true</span></span><br><span class="line">password: </span><br><span class="line">mathjax: <span class="literal">true</span></span><br><span class="line">summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</span><br><span class="line">tags:</span><br><span class="line">- Hexo</span><br><span class="line">- Github</span><br><span class="line">- 博客</span><br><span class="line">categories:</span><br><span class="line">- 软件安装与配置</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">配置选项</th><th align="left">默认值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">title</td><td align="left"><code>Markdown</code> 的文件标题</td><td align="left">文章标题，强烈建议填写此选项</td></tr><tr><td align="left">date</td><td align="left">文件创建时的日期时间</td><td align="left">发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td align="left">author</td><td align="left">根 <code>_config.yml</code>中的 <code>author</code></td><td align="left">文章作者</td></tr><tr><td align="left">img</td><td align="left"><code>featureImages</code>中的某个值</td><td align="left">文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td align="left">top</td><td align="left"><code>true</code></td><td align="left">推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td align="left">cover</td><td align="left"><code>false</code></td><td align="left"><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td align="left">coverImg</td><td align="left">无</td><td align="left"><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td align="left">password</td><td align="left">无</td><td align="left">文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td align="left">toc</td><td align="left"><code>true</code></td><td align="left">是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td align="left">mathjax</td><td align="left"><code>false</code></td><td align="left">是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td align="left">summary</td><td align="left">无</td><td align="left">文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td align="left">categories</td><td align="left">无</td><td align="left">文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td align="left">tags</td><td align="left">无</td><td align="left">文章标签，一篇文章可以多个标签</td></tr><tr><td align="left">reprintPolicy</td><td align="left">cc_by</td><td align="left">文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><p><strong>注意</strong>:</p><blockquote><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2" target="_blank" rel="noopener">开源中国在线工具</a>、<a href="http://encode.chahuo.com/" target="_blank" rel="noopener">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx" target="_blank" rel="noopener">站长工具</a>。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> front-matter配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let’s Build A Simple Interpreter-8</title>
      <link href="/archives/ae12.html"/>
      <url>/archives/ae12.html</url>
      
        <content type="html"><![CDATA[<p>今天，将要在前面的基础上，添加<strong>一元操作符unary operators</strong>：unary plus (+) and unary minus (-) operators。</p><a id="more"></a><p><strong>今天将要完成的任务：</strong></p><ul><li>扩展语法，能够处理“+”、“-”一元操作符；</li><li>添加一个新的结点类：<em>UnaryOp</em> AST node class；</li><li>扩展语法分析器parser，生成含有<em>UnaryOp</em> nodes结点的抽象语法树；</li><li>扩展解释器interpreter。并且增添一个新的<em>visit_UnaryOp</em> method函数，它可以解析一元操作符</li></ul><p>现在，开始吧。</p><h1 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h1><h2 id="一元操作符是什么？"><a href="#一元操作符是什么？" class="headerlink" title="一元操作符是什么？"></a>一元操作符是什么？</h2><p><strong>二元操作符：</strong></p><p>之前，我们的计算器都是围绕着这些二元操作符 (+, -, *, /)在工作，这些操作符操作两个操作数（the operators that operate on two operands.）。</p><p><strong>一元操作符<em>unary operator</em> ：</strong></p><p>那么，我们就能知道一元操作符是：一个操作符只操作一个操作数。（A <em>unary operator</em> is an operator that operates on one <em>operand</em> only.）</p><h2 id="一元操作符的规则"><a href="#一元操作符的规则" class="headerlink" title="一元操作符的规则"></a>一元操作符的规则</h2><p>下面是一元操作符“+、-”的规则：</p><ul><li>一元操作符<code>-</code>：它会使它的操作数取反（negation）</li><li>一元操作符<code>+</code>：他对于它的操作数没影响，即，它的操作数不改变什么</li><li>一元操作符比二元操作符（+, -, *, and /）有着更高的优先级（precedence）</li></ul><p>例子：</p><ol><li><p><strong>“+ - 3”</strong></p><p>其中，这第一个位置的“+”表示一元操作符加号操作；第二个位置的“-”表示一元操作符减号操作。所以，“+ - 3”就相当于“+ (- (3))”，即，等于-3。</p><p>【注】：这里的-3平常情况说它是一个负整数（negative integer），但是在这里我们称它是：一个一元操作符“-”，它的操作数是3。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-8/lsbasi_part8_exp1.png" alt="img"></p></li><li><p><strong>“5 - - 2”</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-8/lsbasi_part8_exp2.png" alt="img"></p><p><u>在这个表达式中，第一个“-”表示一个二元操作符：减法。第二个“-”表示一个一元操作符：取反。</u></p><p>比如下面的一些例子，也是这个样子：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-8/lsbasi_part8_exp3.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-8/lsbasi_part8_exp4.png" alt="img"></p></li></ol><h1 id="开始修改"><a href="#开始修改" class="headerlink" title="开始修改"></a>开始修改</h1><h2 id="将一元操作符添加入语法"><a href="#将一元操作符添加入语法" class="headerlink" title="将一元操作符添加入语法"></a>将一元操作符添加入语法</h2><h3 id="修改factor"><a href="#修改factor" class="headerlink" title="修改factor"></a>修改factor</h3><p>因为，一元操作符的优先级高于二元操作符。所以，函数<code>factor</code>需要需改。它之前的规则为：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-8/lsbasi_part8_factor_before.png" alt="更新前"></p><p>更新后的，规则为：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-8/lsbasi_part8_factor_after.png" alt="更新后"></p><blockquote><p>从更新后的factor函数的规则，可知：<strong>它扩展之后能够引用它本身</strong>。</p><p>这样我们就能够写出类似于：- - - + - 3”这样的式子，这是合法的带有很多一元操作符的表达式。</p></blockquote><p>其实，这里修改语法，只用修改<code>factor</code>函数的产生式，其他的<code>expr</code>、<code>term</code>产生式不变：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-8/lsbasi_part8_grammar.png" alt="img"></p><h2 id="扩展抽象语法树的结点类"><a href="#扩展抽象语法树的结点类" class="headerlink" title="扩展抽象语法树的结点类"></a>扩展抽象语法树的结点类</h2><p>下一步就是要添加一个AST node class，来表示一元操作符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnaryOp</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, op, expr)</span>:</span></span><br><span class="line">        self.token = self.op = op</span><br><span class="line">        self.expr = expr</span><br></pre></td></tr></table></figure><p>这个函数有两个参数：op、expr：</p><ul><li>op：代表一元操作符的token（+或-）</li><li>expr：表示一个AST的结点（要与expr函数区分，这两个知识名字一样，但是代表的东西不一样）</li></ul><h2 id="扩展语法分析器parser"><a href="#扩展语法分析器parser" class="headerlink" title="扩展语法分析器parser"></a>扩展语法分析器parser</h2><p>之前我们修改了语法规则，当中的factor函数的产生式也发生了变化，所以现在我们将要修改代码，使其能够处理产生式中的 “(PLUS | MINUS) factor” 子规则：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""factor : (PLUS | MINUS) factor | INTEGER | LPAREN expr RPAREN"""</span></span><br><span class="line">    token = self.current_token</span><br><span class="line">    <span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">        self.eat(PLUS)</span><br><span class="line">        node = unaryop(token, self.factor())</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">        self.eat(MINUS)</span><br><span class="line">        node = unaryop(token, self.facot())</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="keyword">elif</span> token.type == INTEGER:</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        node = NUM(token)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="keyword">elif</span> token.type == LPAREN:</span><br><span class="line">        self.eat(LPAREN)</span><br><span class="line">        node = self.expr()</span><br><span class="line">        self.eat(RPAREN)</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure><h2 id="扩展解释器Interpreter"><a href="#扩展解释器Interpreter" class="headerlink" title="扩展解释器Interpreter"></a>扩展解释器Interpreter</h2><p>现在我们还需要扩展解释器类<em>Interpreter</em> class ，向其中添加<em>visit_UnaryOp</em> 函数，来解释一元操作符结点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_UnaryOp</span><span class="params">(self, node)</span></span></span><br><span class="line">op = node.op.type #token的类型</span><br><span class="line">    <span class="keyword">if</span> op == PLUS:</span><br><span class="line">        <span class="keyword">return</span> +self.visit(node.expr)</span><br><span class="line">    <span class="keyword">elif</span> op == MINUS:</span><br><span class="line">        <span class="keyword">return</span> -self.visit(node.expr)</span><br></pre></td></tr></table></figure><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>让我们看一个例子，表达式 “5 - - - 2” ，通过我们的解析器来证实这个新的<em>visit_UnaryOp</em>函数确实起作用了。</p><p>下面是如何从Python shell中实现:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> spi <span class="keyword">import</span> BinOp, UnaryOp, Num, MINUS, INTEGER, Token</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>five_tok = Token(INTEGER, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>two_tok = Token(INTEGER, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>minus_tok = Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>expr_node = BinOp(</span><br><span class="line"><span class="meta">... </span>    Num(five_tok),</span><br><span class="line"><span class="meta">... </span>    minus_tok,</span><br><span class="line"><span class="meta">... </span>    UnaryOp(minus_token, UnaryOp(minus_token, Num(two_tok)))</span><br><span class="line"><span class="meta">... </span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> spi <span class="keyword">import</span> Interpreter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inter = Interpreter(<span class="literal">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inter.visit(expr_node)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>上面的AST树看起来是这样的:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-8/lsbasi_part8_ast.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Let&#39;s Build A Simple Interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造凸包——Divide And Conquer</title>
      <link href="/archives/f32f.html"/>
      <url>/archives/f32f.html</url>
      
        <content type="html"><![CDATA[<p>Graham Scan算法说明了凸包构造问题的下界O(nlogn)是可以达到的。其实O(nlogn)的算法远不止这一种，分治法就是一种能达到O(nlogn)复杂度的思想。在此引入运用分治思想的两种算法来构造凸包。</p><a id="more"></a><h1 id="归并排序与分治思想"><a href="#归并排序与分治思想" class="headerlink" title="归并排序与分治思想"></a>归并排序与分治思想</h1><p>引入新算法之前依旧先来回顾一个经典排序算法：归并排序（merge sort）。归并排序的基本流程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315163056136.png" alt="image-20200315163056136"></p><p>算法分为两个阶段：<strong>分（divide）</strong>和<strong>归并（merge）</strong>。</p><ul><li><strong>分</strong>的阶段将待排序列均分到一个个子序列（如图中划分到单个元素）。</li><li><strong>归并</strong>阶段将分好的子序列两两合并成有序序列，重复合并的过程直到整体归为一个序列。</li></ul><p>归并过程共logn步，每步耗费n的时间，总体复杂度为O(nlogn)。</p><p>归并排序的过程就是一个典型的分治（divide-and-conquer）策略。凸包构造问题也可以套用这种策略来分而治之，逐步求解。<u>我们可以将待处理点集S分为同等规模的两个子点集，并分别对其求凸包。</u></p><p>有了两个子解后，问题就变成了如何<strong>适当加一些边</strong>，将两个子凸包merge成整体解。<strong>分治法核心的任务就是如何merge。</strong></p><h1 id="Divide-And-Conquer（1）"><a href="#Divide-And-Conquer（1）" class="headerlink" title="Divide And Conquer（1）"></a>Divide And Conquer（1）</h1><h2 id="预处理为star-shaped-polygon"><a href="#预处理为star-shaped-polygon" class="headerlink" title="预处理为star-shaped polygon"></a>预处理为star-shaped polygon</h2><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315163119718.png" alt="image-20200315163119718"></p><p>分治法解决问题的过程可以概括为：大事化小，小事化了。就是首先将问题划分为易求解的子问题，子问题套用已知方法解答即可。例如子凸包的构造就能用Graham Scan来解决。</p><p>Graham Scan解决问题的前提是：参照基准点，其他点按极角有序排列，也就是构成了一个有序的星形多边形（star-shaped polygon）。<strong>首先要做的就是将两个子凸包预处理成两个star-shaped polygon。</strong></p><blockquote><p><strong>star-shaped polygon星形多边形</strong>是什么呢？</p><p>其实就是在多边形内部存在一个点A，这个点与多边形内任意一点的连线都在多边形内部，就叫做星形多边形，这一个点A就叫做多边形的内核。</p></blockquote><p>由于任何一个凸多边形都是star-shaped polygon，它必然有一个核，其他点按极角有序排列。<u>问题在于如何找到一个公共核</u>，使得两个子凸包同时关于这个核是极角有序排列的。也就是公共核处于两个凸包的交部分，这样是最好处理的情况（如下左图）。不过还有可能有其他情况，不能找到公共核（如下中图），甚至两个凸包根本不相交（如下右图）：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315163145301.png" alt="image-20200315163145301"></p><p>这就要将分治策略分不同情况来实现：</p><h3 id="两个子凸包有公共核："><a href="#两个子凸包有公共核：" class="headerlink" title="两个子凸包有公共核："></a>两个子凸包有公共核：</h3><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315163518484.png" alt="image-20200315163518484"></p><p><u>先找其中一个子凸包的核</u>：我们可以任取该子凸包上的三点构成三角形，求三角形重心作为核。</p><p><u>然后判断这个核是否也在另一个子凸包内部</u>，若判定为真，就是有公共核的最简单情况。判定方法也就是之前提过的<u>in convex polygon test</u>，对凸包每条边做to left test即可，在线性时间内可以判定。</p><p><strong>找到公共核之后，进行凸包形成</strong>：—-用二路归并</p><p>相对于公共核，两个子凸包的各自有序排列，相互交错。要做的就是将二者点序列合并，方法正是经典的<strong>二路归并</strong>，线性时间可以完成。最后进行Graham Scan即可得到大凸包。</p><h3 id="一个子凸包的核落在另一个子凸包外部："><a href="#一个子凸包的核落在另一个子凸包外部：" class="headerlink" title="一个子凸包的核落在另一个子凸包外部："></a>一个子凸包的核落在另一个子凸包外部：</h3><p>存在公共核的情况处理是很简单的，再看第一个子凸包的核落在第二个子凸包外部的情况。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315164325225.png" alt="image-20200315164325225"></p><p>这中情况与<strong>增量构造法</strong>的情况很相似，P1的核x相对于P2就是一个新加入的点。做出两条support line：x→t和x→s，舍弃P2上t→s路径的点即可。这样P2中剩余点与x构成了一个星形多边形，x也成为了P2的核。<strong>这就转化成了第一种有公共核的情况。</strong></p><h1 id="Divide-And-Conquer（2）"><a href="#Divide-And-Conquer（2）" class="headerlink" title="Divide And Conquer（2）"></a>Divide And Conquer（2）</h1><p>上述分治策略的算法过于复杂，所以引入一种更加简明的分治策略。这种分治策略也会为三角剖分等问题提供思路。</p><p>首先规定一种点集划分的策略。假设待合并的两个子凸包是沿着某方向是分离的，<strong>二者不相交</strong>（Divide And Conquer（1）中是有相交的）。例如下图凸包P1和P2就是相互分离的：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315164957102.png" alt="image-20200315164957102"></p><p><strong>这样划分会使得合并更加简明，不必区分多种复杂情况</strong>。</p><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>为了满足这种划分策略，<strong>需要引入一种预处理</strong>，也就是一个x方向的排序过程（X-sorting）。排序后就可取点x坐标的中值，将点集划分为规模相当的左右两个子集。每个凸包都有其<strong>最左点l</strong>和<strong>最右点r</strong>，如上图。</p><h2 id="merge操作"><a href="#merge操作" class="headerlink" title="merge操作"></a>merge操作</h2><p>现在<strong>merge操作</strong>就是将两个左右相离的两个子凸包合并为一个大凸包的过程了。运算的关注的正是两对l和r点。</p><p>先直观感受一下merge操作要添加的新极边：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315165142262.png" alt="image-20200315165142262"></p><p>上下两条紫色边正是要求的新边，又称支撑边（<strong>support line</strong>），<u>并且每次merge<strong>只会</strong>增加<strong>两条</strong>新边</u>。两条边类似两个圆的<strong>公切线（common tangent）</strong>，将二者连接起来。</p><blockquote><p>注意，注意，注意：<strong>眼睛可能会欺骗你</strong></p><p>直观上感觉，两条support line正是两个子凸包的最高点t和最低点b相互连接得到的，这些点只需线性时间就能找到。<u>当真如此的话凸包构造的下界就成了O(n)，显然直觉是错误的。</u>例如下面的两种情况，support line就和b、t两点没有直接关系了：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315165430771.png" alt="image-20200315165430771">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315165443290.png" alt="image-20200315165443290"></p><p>构造support line的过程需要缜密的分析，并非凭直觉能得到的。</p></blockquote><h3 id="缝合（stitch）—构造support-line"><a href="#缝合（stitch）—构造support-line" class="headerlink" title="缝合（stitch）—构造support line"></a>缝合（stitch）—构造support line</h3><p>将两个子凸包连接的过程更像古代妇女用针将两块布缝合在一起（但是这里的两个凸包的间距是不能变的，仅仅是用线将其连接在一起。而且这里连接只需要最后找出来的那两条线，其余剩下的中间“工具线”都要舍去）。</p><p>构造过程首先从<strong>左凸包的r点</strong>和<strong>右凸包的l点</strong>连线开始，以这条线为基础逐步得到support line。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315165636768.png" alt="image-20200315165636768"></p><blockquote><p>注意一个细节问题：</p><p>如何得到各子凸包的l点和r点。每次合并都会产生新的凸包，所以凸包是一个动态的结构。当然可以每次计算出最左点和最右点，只需要线性时间。但是这并不是最优的方式。考虑分治的思想，就整个merge流程来讲，是自底向上将子凸包两两合并的过程。因此只要在最底层上最小的子凸包中记录最左点和最右点，每次merge更新一下这两个变量即可，只需要O(1)的常数时间！这种优化对整体的复杂度上线nlogn虽然没有影响，也能为程序节省一部分的开销。</p></blockquote><h4 id="缝合上半部分"><a href="#缝合上半部分" class="headerlink" title="缝合上半部分"></a>缝合上半部分</h4><blockquote><p>再看如何将最初的r-l线变成support line，在此以<strong>寻找upper support line为例</strong>（上切线，相应的还需要计算下切线）。<strong><u>算法的核心依然是to left test</u></strong>。</p></blockquote><ul><li><strong>首先看<code>l</code>点</strong>，从r-l线出发，可以发现相对于对于r→l时，l的前驱、后继是LR型的。而我们想要的是RR型的。所以必须要找l的前驱。直到在某一个时刻，我们找到了l的一个前驱点满足RR型：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315171448455.png" alt="找到l点的前驱满足当前形势的RR"></p><ul><li><p><strong>再看<code>r</code>点</strong>，同样的，从此时的状态，来观察r的类型：是RL型的。要想成为LL型，r必须要找它的后驱。</p><p>在某一时刻，r找到r的后继（就是该凸包点t）使其满足LL型：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315171826930.png" alt="找到r的后驱满足当前形势的LL"></p></li><li><p><strong>反过来继续看<code>l</code></strong>，此时，<strong>具体的说应该是检测l的前驱点<code>l&#39;</code></strong>，经检测，<code>l&#39;</code>已经不再满足RR型了，编程了LR型，所以还要继续寻找它的前驱点，使其再次满足RR型。</p><p>某一时刻，找到它的前驱（就是该凸包的点t），使其成为RR型。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315171826931.png" alt="image-20200315171826931"></p><ul><li><strong>反过来继续看<code>r</code></strong>，此时，更准确的应该说是在看<code>r&#39;</code>，经检测，该店符合LL型。至此，所谓的<code>r</code>和<code>l</code>都已经符合RR或LL型了。从而已经找到<strong>upper support line</strong>了。结束上半部分。</li></ul></li></ul><blockquote><p>回顾由r-l线逐步推进得到support line的过程，每次操作一个端点，得到是一种“Z”字形（zig-zag）的推进轨迹。操作点的切换由另一点满足要求决定，而算法停止的依据是两个端点同时满足了要求。这种方式类似快速排序构造轴点的过程，左右两轴点交替操作，直到二者都满足要求时算法停止。</p></blockquote><h4 id="缝合下半部分"><a href="#缝合下半部分" class="headerlink" title="缝合下半部分"></a>缝合下半部分</h4><p>缝合下半部分的流程与，上半部分流程一样。</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>分析一下算法时间复杂度。<strong>算法首先要按照x坐标排序，排序复杂度为O(nlogn)。</strong>再看merge过程，无论是左侧子凸包还是右侧子凸包，对于其每个点的操作至多只有以此，也就是每次归并是线性时间。归并共logn次，算法的<strong>总体复杂度就是O(nlogn)</strong>了。</p><h1 id="更多的考虑"><a href="#更多的考虑" class="headerlink" title="更多的考虑"></a>更多的考虑</h1><p>在这些算法讲解中，<strong>通常都是不考虑退化的情况</strong>，如，三点共线……</p><p>最后总结一下第二种分治法的特点。此前<a href="http://blog.csdn.net/houszchina/article/details/79261505" target="_blank" rel="noopener">Jarvis March算法</a>虽然以平方复杂度为上界，但其”输出敏感性“使得实际复杂度为O(hn)，最好情况下仅甚至为线性。例如如下情况：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315174908920.png" alt="image-20200315174908920"></p><p>Jarvis March算法的复杂度变为了O(4n)，而此时分治法依旧会经历按部就班的X-sorting，一上来就注定了O(nlogn)的复杂度，然后经历同样O(nlogn)的merge过程。也就是说这种分治法在各种情况下的表现都是很均匀的。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造凸包-Graham Scan法</title>
      <link href="/archives/3478.html"/>
      <url>/archives/3478.html</url>
      
        <content type="html"><![CDATA[<p>上文简要分析出了凸包构造问题算法的下届：O(nlog n)，在此就引入一种下界意义上最优的算法：<strong>Graham Scan算法</strong>。这种算法可以保证在最坏的情况下时间复杂度也不超过 nlogn。</p><a id="more"></a><h1 id="Graham-Scan算法的流程"><a href="#Graham-Scan算法的流程" class="headerlink" title="Graham Scan算法的流程"></a>Graham Scan算法的流程</h1><p>假设待处理点集S共有n个点。</p><h2 id="1、预处理"><a href="#1、预处理" class="headerlink" title="1、预处理"></a>1、预处理</h2><ol><li><p><strong>预排序(presorting</strong>）</p><p>Graham Scan首先要做的是一个预处理排序操作（<strong>presorting</strong>）。即找到某个基准点，然后将其余所有的点按照相对于基准点的<strong>极坐标</strong>排序。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/20180207204917568.jpg" alt="img"></p><blockquote><p>点的排序可以套用任意排序算法的框架，只是将排序对象由数值变为了平面上的点，而比较器改为<strong>to left test</strong>实现。</p></blockquote><p><strong>如何找出第一个点：点1？</strong></p><blockquote><p>以点1为基准点，其余点按照相当于点1的极角依次排序为2、3、4……理论上讲任何一个点都能当第一个基准点，为了简化算法通常选择<strong>lowest-then-leftmost point（LTL）</strong>作为基准点。</p></blockquote></li><li><p><strong>找出起始边</strong></p><p>对于与基准点1极角最小的点，也就是图中点2（假设没有三点共线的情况）。将点1和点2作为算法的起始点。</p></li><li><p><strong>将起始边 与 剩下的n-2条边分别存储在不同的栈(stack)中：</strong></p><p>算法开始前先将起始点1和2入栈S，其他的n-2个点入栈T，如上图。注意S和T中元素的入栈顺序。至此预处理已经完成。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/image-20200314181609764.png" alt="栈：T和S"></p><blockquote><p>Graham Scan用到的数据结构。整个算法非常简明，核心数据结构只有两个<strong>栈</strong>，分别记作栈<strong>S</strong>和栈<strong>T</strong>。便于理解我们将S和T画成开口相对的形式，如上图。</p></blockquote></li></ol><h2 id="2、scan操作-此处为逆时针扫描"><a href="#2、scan操作-此处为逆时针扫描" class="headerlink" title="2、scan操作(此处为逆时针扫描)"></a>2、scan操作(此处为逆时针扫描)</h2><p>完成预处理之后，就能开始算法的核心：scan操作。scan的过程中要时刻关注三个点：<strong>栈S的栈顶（S[0]）、次栈顶（S[1]）和栈T的栈顶（T[0]）</strong>。也就下图红色标注的三个点：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/20180207210925858.jpg" alt="img"></p><p>对这三个关注的点，进行检测，检测的框架为：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/image-20200314182719216.png" alt="image-20200314182719216"></p><ul><li>可以观察到，<u>每次待处理的S[0]和S[1]构成的边一定是一条极边（如上图点1和点2）</u>，算法<strong>关键步骤</strong><u>就是对边这条极边和T[0]做to left test，判断T[0]位于边S[0]S[1]的左边还是右边。若在左边则继续拓展，若在右边则否定掉此前认定的极边。</u>无论结果如何，每次判定都会将问题规模缩小一个单元，算法结束时T最终肯定为空。T空后，S中存留下的点正是凸包的极点，这些点自底而上正是凸包边界点的逆时针遍历，也得到了整个凸包构造问题的解。</li></ul><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><strong>1、</strong>先来看一个最简单的例子，即点集S中所有的点都在凸包边界上。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/image-20200314183056395.png" alt="image-20200314183056395"></p><ul><li><p>先找到LTL，也就是图中点1。然后基于点1对其余点按极角排序为点2、3、4……<em>（实际上以一个点为中心的有序的点集，构成了所谓的星形多边形（star-shaped polygon），中心点正是星形多边形核（kernel）的一部分。凸多边形必然是星形多边形，反之则不然。）</em>然后找到点1的后继2，点1和点2构成第一条极边。初始化栈S和栈T。</p></li><li><p>现在要关心S[1], S[0]和T[0]，就是点1，2和3。点3位于边12左侧，to left关系为true，S.push ( T.pop() )，向前拓展了一条暂定极边。</p></li><li><p>接下来重复上述过程。考虑点2，3和4。to left关系为true，S.push( T.pop() )……最终栈T空，算法结束，凸包由栈S自底向上得到。S和T的变化过程如下图：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/image-20200314211052355.png" alt="image-20200314211052355"></p><hr><p><strong>2、</strong>上面列举了最简单的情况下Graham Scan的过程，接下来列举一个更有代表性的实例深入算法的细节。输入的点集S，并进行预处理排序，并初始化栈S、T，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/20180207215925185.jpg" alt="20180207215925185"></p><ul><li><p>接下来对点1，2和3进行to left测试，本质上就是判断边2→3（图中黄色边）能否被暂时采纳。测试结果为true，暂时采纳边2→3，<strong>S.push( T.pop() )</strong>。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/image-20200314211330428.png" alt="image-20200314211330428"></p><blockquote><p>注意图中蓝色边表示已经被暂时接纳的边，也就是算法暂时认定的极边。上一次操作将蓝色边推进一个单元</p></blockquote></li><li><p>接下来关注点2，3和4，来判断下一条黄色边3→4能否被接纳。to left测试为true，<strong>S.push( T.pop() )</strong>，接纳边3→4。如下图右侧所示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/image-20200314211603647.png" alt="image-20200314211603647"></p></li><li><p>然后判断点3，4和5。点5在边3→4的右侧，即to left测试为false。<strong>S.pop()</strong>，也就是判断出点4不可能为极点，丢弃4。因此算法回溯到点3，判断点2，3和5的关系。5在2→3的左侧，暂时接纳边3→5，<strong>S.push( T.pop() )。</strong>如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/image-20200314211705197.png" alt="image-20200314211705197"></p><blockquote><p>算法经历了无效操作，进行了回溯，得到了目前来说最优的“极边”。虽然这些”极边“不一定能最终保留，但问题的规模得到了削减。</p></blockquote></li><li><p>下一次scan考察的就是3，5和6了。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/image-20200314211916570.png" alt="image-20200314211916570"></p><blockquote><p>3，5和6的to left测试为false，<strong>S.pop()</strong>，舍弃点5。</p></blockquote></li><li><p>然后考察点2，3和6，to left测试为false，<strong>S.pop()</strong>舍弃点3。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/20180207223417072.jpg" alt="img"></p></li><li><p>……..</p></li><li><p>………</p></li><li><p>直遍历完剩下其他点，凸包就构造完成。</p></li></ul><h1 id="验证算法的正确性"><a href="#验证算法的正确性" class="headerlink" title="验证算法的正确性"></a>验证算法的正确性</h1><h2 id="思路上的正确性"><a href="#思路上的正确性" class="headerlink" title="思路上的正确性"></a>思路上的正确性</h2><p>了解了算法的整体流程之后，我们再来论证一下算法的正确性。证明一个算法正确性的方法有很多，在此选用数学归纳法。数学归纳法的思想可用多米诺骨牌类比，要做的无非是两件事：证明第1张骨牌会倒；证明如果第n张骨牌会倒则第n+1张骨牌也会倒下。</p><p>Graham Scan过程就是一个个引入点的过程。每当我们得到第k个点的时候，算法所得到的就是前k个点对应的“最好的凸包”。因此当k = n时得到的是整体的凸包。</p><ol><li><p>归纳的第一步就是证明k = 3时得到的是当前点集S‘ = {1，2，3}中的极边——也就是证明第1张骨牌会倒。</p><blockquote><p>显然边1→2是S’的一条极边。而根据预处理的方式，3相较于1的极角一定大于2，因此点3一定在边1→2的左侧，因此边2→3会得到保留。对于这三个点来说，任意两条边一定都是极边，2→3也是一条极边。</p></blockquote></li><li><p>然后证明：假设已经处理到第k个点，得到的是前点集S’ = {1，2，3，…，k}中所谓“最好的凸包”。根据算法处理方式，接下来从S’’ = {1，2，3，…，k，k+1}得到的结果是否也是正确的——也就是证明第n张骨牌会倒，则第n+1张骨牌也会倒下。</p><blockquote><p>预处理的方式是对2~n所有点相较于点1按极角排序，因此下一个要处理点k+1一定出现在线1→k的左侧，也就是下图蓝色区域和绿色区域（假设k = 9）：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/20180207231513568.jpg" alt="img"></p><p>而根据目前接纳的最后一条极边( k-1)→k （例如图中8→9）来划分，点k+1可能出现的区域又分为两块，即该极边的左侧（绿色区域）和右侧（蓝色区域）。这也正对应于算法判定的两个分支。</p><ul><li><p>左侧：左侧的情况很简单，点k+1显然会是一个新的极点。Graham Scan要做的正是暂时接纳边k→k+1，拓展了一个新的单位。</p></li><li><p>右侧：再看k+1落在右侧的情况。如下图点10：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/20180207232235024.jpg" alt="img"></p><p>Graham Scan要做的是丢弃点k（图中点9），也就是判定出点k不可能是极点。这样做的原因：是引入点k+1后，点k一定会被包含在三角形(1, k-1, k+1)内部。如图中点9一定包含于三角形(1, 8, 10)内部。正如极点法中排除非极点的做法，点k被排除是正确的做法。接下来点k-1，k-2等（如图中点8，点7等）也可能是非极点，按照算法的流程，它们总会被判定在某个三角形的内部（例如点7在三角形(1, 5, 10)内部）而被排除，直到left test为true，回溯停止。</p><p>换个角度考虑，回溯停止时得到的新边正是增量构造法中每步得到的support line，即切线。例如图中线5→10正是算法当前保留的”凸包“的切线。这也能论证Graham Scan处理方式的正确性。</p></li></ul></blockquote></li></ol><p>至此，算法思路上的正确性已经证明完毕。</p><h2 id="表述方式的正确性"><a href="#表述方式的正确性" class="headerlink" title="表述方式的正确性"></a>表述方式的正确性</h2><p>接下来还要考虑算法的表述方式是否有漏洞：代码中每次to left test之前并没有判断S栈中是否有≥2个元素。这也可以由预处理的方式来论证。点1选取的是LTL，而点2是相对于点1极角最小的点，这样的做法保证了除了点1和点2之外所有的点一定是在边1→2左侧的。因此算法回溯最多到点2，永远不可能把点2丢弃，S中元素任何时候至少有两个。</p><hr><p>Graham Scan算法的正确性论证完毕。</p><h1 id="预处理操作的必要性"><a href="#预处理操作的必要性" class="headerlink" title="预处理操作的必要性"></a>预处理操作的必要性</h1><p>最后来思考一下预处理操作：presorting。仔细回顾上述论证过程会发现，每一步的正确性都是建立在最初的排序上的。那么这个预处理排序真的是必要的吗？可以来举极端的反例，每次选取下一个点都是随机的，例如下图的路径：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/20180207235736089.jpg" alt="img"></p><p>上图中从点1开始出发进行to left测试，可以发现，每次判定结果都为true，最终所有的点都被保留了下了，而显然这并不是一个凸包。因此presorting是整个算法成立的基础。</p><h1 id="分析复杂度"><a href="#分析复杂度" class="headerlink" title="分析复杂度"></a>分析复杂度</h1><p>上面证明了Graham Scan算法的正确性，接下来分析其复杂度是否满足O(nlogn)，实现所谓的最优算法。</p><p>直观上无法断定Graham Scan是一个最优的算法，尤其是以下极端情况令人质疑其效率：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/image-20200314220437069.png" alt="image-20200314220437069"></p><p>Graham Scan算法复杂度由三部分决定：</p><ul><li>persorting，采用一般排序算法，复杂度是O(nlogn)</li><li>逐步迭代，O(n)：算法一步步纳入新点，会迭代n步。</li><li>scan，O(?)</li></ul><p><strong>所以算法的总体复杂度：O(nlogn + n * ?) ，可见scan的复杂度决定了算法总体的复杂度。</strong></p><ul><li>算法一步步纳入新点，会迭代n步。但是在每个点上都有可能做回溯操作，所以scan的复杂度是不确定的。我们来以上图最坏情况为例，到第8个点时判定为false，舍弃点7，回溯。下一步判断也为false，舍弃点6，回溯。如此回溯直到算法开始的点2。这次scan倒退了高达O(n)个点，如果每次scan都是如此那么算法整体复杂度就为：O(nlogn + n * n) = O(n^2)了，那这种算法的意义也就不大了。</li></ul><p>其实上述分析并非错误，只是不够精确。<u>O(n^2)确实是Graham Scan算法的一个<strong>上界</strong></u>，但是这个上界并不是紧的。</p><p><u>问题就出在分析假定了每次都会出现回退高达O(n)个点。</u></p><ul><li><p>下图展示了整个Graham Scan的流程：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/20180208002202338.jpg" alt="img"></p><p>图中黄色边是没有采纳的，就是to left测试判定为false后直接舍去的。紫色边则是曾经被认为是极边而接纳的，后来经过回溯又舍去了。无论是黄边还是紫边，在其上耗费的都是常数时间，关键就在于黄色边和紫色边的数目了。</p><blockquote><p>通过观察可以发现，从图论的角度看，所有的黄色边和紫色边连在一起构成了一张<strong>平面图</strong>，也就是它们互相是不可能内部相交的。平面图的一个重要性质：<strong>平面图中所有边的数目和顶点数目保持同阶</strong></p><p>这个性质来自<strong>欧拉公式</strong>：有n个点的平面图，<u>边</u>的数目上限是3n，也就是<strong>O(3n)</strong>。</p><ul><li>回溯（backtrack）可能会倒退的边数：在0~n之间。【但是注意，不是每次回溯都能回退到n，因为由上面可知，点集边数最多为3n，而这里面的每一个边，会被回退0次（极边），或者1次（非极边）。所以，某条边一旦被回退过，之后就不可能再被回退了】</li></ul><p>根据这个性质，在persorting之后的整个流程中，Graham Scan所能走过的所有边不仅不会到达n^2，而顶多到达和n同阶的一个<strong>线性数目</strong>。因此整个算法的复杂度也就取决于persorting的O(nlogn)了。</p></blockquote></li></ul><h1 id="算法推广"><a href="#算法推广" class="headerlink" title="算法推广"></a>算法推广</h1><p>Graham Scan算法不仅可以用于凸包构造问题，在其他许多场景下中也十分有效。为了推广Graham Scan算法，首先可以对其做简化，以方便利用在其他问题。</p><p>首先再来回顾一下预处理排序，这是算法成立必不可少的一步。排序算法套用成熟的方法即可，利用数学方法计算偏角不仅复杂而且引入了误差，所以要采用to left test。要做的就是两点：</p><ul><li>套用成熟的排序算法，将待排序元素由数值变为点</li><li>将排序算法的比较器改为<strong>to left test</strong>实现</li></ul><p>按照这样的流程就能间接地实现persorting。</p><h2 id="1、原始点集已经有某种次序"><a href="#1、原始点集已经有某种次序" class="headerlink" title="1、原始点集已经有某种次序"></a>1、原始点集已经有某种次序</h2><p>有时候我们并不是从零开始构造凸包，例如得到的待处理点集已经是有某种次序的（比如已经按x坐标大小排序，如下图）。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/20180208004657243.jpg" alt="img"></p><p><u>这种情况也不一定非得进行persorting构造新的次序</u>，通常改变观察的角度，换一种理解方式就能免去预处理而直接进行后面的线性的scan操作了。</p><p><strong>上半部分凸包：</strong></p><p>考虑y轴负方向无穷远一个点，所有的点相对于这个点的极角排序恰好就是各点的x坐标序！也就是将无穷远的点看作起始点①，最右侧点（图中点8）看作点②，进行scan过程直到最左边的点（图中点1）结束，就得到了凸包的上半部分（upper hull），也就是下图的8→7→2→1：</p><p><em>注：对 “考虑y轴负方向无穷远一个点，所有的点相对于这个点的极角排序恰好就是各点的x坐标序！” 这句话的理解：</em></p><ul><li>就像太阳光照在地球上的道理是一样的，太阳离地球足够的远，那么它的光到达地球上的时候，就近似的是<strong>平行</strong>的。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/20180208005912300.jpg" alt="img"></p><p><strong>下半部分凸包（lower hull）的构造</strong></p><p>也是如此。考虑一个在y轴正方向无穷远的一个点，以此为起点进行scan，最终得到lower hull：1→4→7。最后将两个凸包合二为一即可。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 凸包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lower Bound</title>
      <link href="/archives/ba04.html"/>
      <url>/archives/ba04.html</url>
      
        <content type="html"><![CDATA[<p>冲曰：“置象大船之上，而刻其水深所至，称物以载之，则校可知矣。”</p><a id="more"></a><h2 id="Lower-Bound"><a href="#Lower-Bound" class="headerlink" title="Lower Bound"></a>Lower Bound</h2><p>冲曰：“置象大船之上，而刻其水深所至，称物以载之，则校可知矣。”</p><p>从极点法的O(n^4^)复杂度，到极边法的O(n^3^)，再到增量构造法和Jarvis March的O(n^2^)，我们经历了将特定问题算法不断优化、降低复杂度的过程。那么还有比O(n^2^)更高效的算法吗？凸包构造算法的下界是什么？推广到一般情况，在计算模型固定的情况下特定问题的复杂度下界又是如何确定的？</p><p>在计算模型固定的情况下特定问题的复杂度<strong>下界（lower bound）</strong>是确定的。严谨考虑，在设计算法前应该先确定下界是多少。</p><p>对于某个问题的特定算法，我们可以用时间复杂度来评价算法的好坏。算法能达到的下界也就是所谓问题的难度。当然这种评价通常是比较麻烦的，有时候甚至是不可行的。<u>这就要引入新的的方式来衡量一个算法的好坏。</u></p><h3 id="规约（reduction）"><a href="#规约（reduction）" class="headerlink" title="规约（reduction）"></a>规约（reduction）</h3><p>我们引入<strong>规约（reduction）</strong>的方法来<u>间接</u>衡量一个算法。规约简单来讲就是用一个“参照物”对比待评算法，得到算法的复杂度。规约的一般方法如图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20180206145307478.png" alt="规约（reduction）"></p><blockquote><p>左侧是已知的问题<strong>A</strong>，已经明确它的难度，右侧是待分析问题<strong>B</strong>，复杂度未知。我们在二者之间建立起一种基本<strong>reduction</strong>关系：<strong>linear-time reduction</strong>。</p><p>linear-time reduction具体表述为：</p><ul><li>任何一个A的输入（input of A），都可以在O(n)复杂度转化为一个B的输入（input of B），然后通过B的某种算法（any algorithm）计算出结果（output of B）;</li><li>而对于output of B又都可以在在O(n)复杂度转化为A问题的结果（output of A）。两次转换的复杂度不能超过线性，也就是linear-time（线性时间）。</li></ul></blockquote><p>能够进行上述操作，就称为：<strong>A问题可以规约到B问题（problem A is linear-time reducible to problem B）</strong>。注意表述方式防止搞混A和B的位置。</p><h4 id="曹冲称象"><a href="#曹冲称象" class="headerlink" title="曹冲称象"></a>曹冲称象</h4><p>可以通过<strong>曹冲称象</strong>的故事来帮助理解规约的思想。要解决的问题是：没有秤能直接称量大象重量（问题B的难度无法直接衡量），<u>解决方案是</u>：利用船和石块间接称量。石头块的重量是可以直接称量的（问题A的难度是已知的），利用<u>船和水</u>来转换石头和大象的重量是可操作的（规约的方法是可操作的）。【这里的<u>规约关系(Reduction relationship)</u>是指曹冲成像时的船和水】</p><h4 id="规约记号"><a href="#规约记号" class="headerlink" title="规约记号"></a>规约记号</h4><p>引入规约记号，problem A is linear-time reducible to problem B表示为：<br>$$<br>A≤_NB<br>$$<br>将问题A、B的难度分别表示为|A|，|B|。规约记号的意思相当于<strong>|A|≤|B|</strong>，A的下界必然就是B的下界。</p><p><strong>规约的过程</strong>：</p><ol><li>将A的输入转化为B的输入</li><li>经过B的某种算法获得解后又转化为A的解，也就是这个算法也是解决A问题的算法。</li></ol><p>已知A问题的下界，那么这个算法必然不会低于A的这个下界。</p><h3 id="构造凸包的下界"><a href="#构造凸包的下界" class="headerlink" title="构造凸包的下界"></a>构造凸包的下界</h3><p>按照“曹冲称象”的规约思想，分析问题的难度，最重要的在于找到“石头”，而船就是规约这种方法。以二维凸包（2d-CH）来分析，首先将待解决的问题放到规约记号<u>右边</u>，而左边的“石头”就是<strong>排序算法</strong>。<br>$$<br>Sorting≤_N2D-CH<br>$$<br>排序是纯粹的数值计算问题，而凸包是典型的几何问题，二者是如何联系在一起的呢？前面<a href="http://blog.csdn.net/HouszChina/article/details/79254856" target="_blank" rel="noopener">增量构造法</a>和<a href="http://blog.csdn.net/HouszChina/article/details/79261505" target="_blank" rel="noopener">Jarvis March算法</a>正是分别由两种排序算法来类比引入的，可见排序和凸包之间有深刻的内在联系。二者之间的联系可以通过下图表示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200312231702595.png" alt="image-20200312231702595"></p><p>首先清点要做的任务：</p><ul><li><p>可以在线性时间内，将排序问题的输入转化为凸包问题的输入</p><ul><li>排序问题的输入可以表示为x轴上的一系列的点（图中蓝色点）。然后将这些点转化为凸包问题的输入，就是将这些待排序的数转化为平面上的点。引入辅助线——一条抛物线，例如图中蓝色虚线。接下来要对蓝色点做到抛物线上的映射（O(n)），映射在抛物线上的点用绿色标出。这样就完成了将待排序数字转化为平面上点的操作。接下来就可以用某种算法将绿色点构造为凸包，即图中CH(P)。</li></ul></li><li><p>可以在线性时间内，将凸包问题的结果转化为排序问题的结果</p><ul><li>凸包CH(P)就是问题B的解，如何将B的解转化为A的解？注意最左和最右边两点的连线，即图中1和4的连线4→1。除去这条连线之外，其他首尾相接的连线：1→2，2→3和3→4都是“沿着x方向单调的”，遍历这些首尾相连的边（O(n)）就能得到一系列的数值，并且已经是有序的了。这样就将凸包问题的解——凸包CH(P) 转化为了排序问题的解——有序数值序列。</li></ul></li></ul><p>两次转化说明规约是可行的，因此2d-CH问题的下界可由sorting的下界确定。一般而言，排序问题的难度是确定的：<strong>O(nlogn)</strong>。2d-CH问题的下界也就是：<br>$$<br>O(nlogn)<br>$$<br>更高维的凸包问题下界也是如此。</p><p>增量构造法和Jarvis March的O(n^2^)到O(nlogn)之间的鸿沟能否跨越呢？是否存在O(nlogn)复杂度的凸包构造算法？后续文章会有回答。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 凸包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造凸包-Jarvis March(Gift Wrapping)算法</title>
      <link href="/archives/9c7f.html"/>
      <url>/archives/9c7f.html</url>
      
        <content type="html"><![CDATA[<p>回顾凸包构造算法：极点法、极边法和增量构造法，其复杂度分别为O(n^4^)、O(n^3^)和O(n^2^)，效率经过优化已经大大提高了。接下来引入一种新的算法——Jarvis March，其复杂度也是O(n^2^)，但是相较于增量构造在最好情况下效率是较高的。</p><a id="more"></a><h3 id="实现策略"><a href="#实现策略" class="headerlink" title="实现策略"></a>实现策略</h3><p>先想一下为何<a href="http://blog.csdn.net/houszchina/article/details/79253249" target="_blank" rel="noopener">极边法</a>复杂度高达O(n^3^)。实际上我们要对点集中所有边进行遍历，这需要n^2^复杂度，然后对每个边进行鉴别，又需要n复杂度，因此总体复杂度高达O(n^3^)。那么该如何改进呢？这就可以运用选择排序的思想：将下一个要查找的边缩小到一个小范围，而非遍历所有边。</p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20180205163738819-1584005657109.png" alt="选择排序示意"></p><p>选择排序每次选取出的unsorted最大元素放在sorted 部分的首部，<u>也就意味着整个unsorted部分必然不会超过sorted部分</u>。从算法整体框架考虑，每次我们都是维护一个局部解（也就是sorted部分），然后从尚未处理的部分（也就是unsorted部分）找到一个与当前局部解“紧密相关的元素”（相当于选取的最大元素）。这个思想为解决凸包问题带来了新思路。</p></blockquote><p>对算法的大致过程进行描述(标识为：已找到极边数/所有极边数)：</p><ul><li><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200312175230158.png" alt="在加入[partial convex hull]之前找出下一条极边"></p><p>首先从任何一个极点（后面说明如何找到这个点）开始（图中0/5），然后找到一条以这个极点为端点的极边（1/5）。接着沿着极边另一个端点<strong>（endpoint）</strong>出发，再找出下一条极边（2/5）。如此反复操作，<u>最终会找到一条以最初极点为endpoint的极边，得到一个封闭的环，凸包也构造完成</u>。凸包构造过程类似于选择排序中sorted不断向前扩展一样，不断扩展局部解，最后得到问题最终解。</p></li></ul><table><thead><tr><th>凸包构造的问题由此分解为一个个子问题：<u>如何从endpoint出发找到下一条极边</u>。</th></tr></thead><tbody><tr><td></td></tr></tbody></table><h4 id="用to-left-test找到下一条极边"><a href="#用to-left-test找到下一条极边" class="headerlink" title="用to left test找到下一条极边"></a>用to left test找到下一条极边</h4><p>现分析如何从endpoint找到下一条极边。考虑一下的一般情况：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200312175230158.png" alt="image-20200312175230158"></p><p>我们从极点o开始寻找极边，假设当前找到的极边是ik，接下来要做的工作是找到从k出发的另一条极边ks，即找到极点s。</p><p>显然，s来自于其他那些尚未处理的点中，那么s与其他点相比有什么特征？观察发现，ik作为一条极边，它的右侧肯定都是空的，所有其他点都在ik左侧。画出k与其他候选点的有向直线，例如下图中的ks，kt：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200312175450087.png" alt="image-20200312175450087"></p><p>注意图中红色标出的角度，可以看出ks与ik的夹角比kt小，也就是ks比kt相较于ik偏左的角度更小。实际上ks偏左的角度比其他任何从k出发的边都小，<strong>这就是s点的判定依据</strong>。</p><p><strong>这样就找到了从其余点中选择s点的思路</strong>：任选两个点，从k出发过这两点做有向边，看哪个偏左的角度更小就留下，另一点丢弃。然后再拿一点与留下的点比较，反复这个过程，最终留下的就是要找的s点。</p><table><thead><tr><th>问题至此转化为：<u>如何比较两条有向边（例如ks和kt）相较于另一有向直线（例如ik）谁偏左的角度更小。</u></th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>当然可以通过计算三角函数的方法来比较，这是最直观的数学思维。但是这样计算十分复杂，更重要的是引入了误差。<u>这时候又要使用<strong>to left test</strong>这个基础方法来解决问题了</u></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200312175904984.png" alt="image-20200312175904984"></p><p>具体做法就是以在ks和kt中以任意个为基准（如以ks为基准），对另一点（如t）做to left test。上图点t和有向边ks的to left test结果为true，t在ks左边，因此ks偏左的角度更小，舍弃点t。</p><blockquote><p>类比选择排序来理解:</p><ul><li><u>已得到的极边</u>（从极点o开始到ik的首尾相连的极边）——相当于 sorted部分</li><li><u>其余点</u>——相当于 unsorted部分</li><li><u>找到点s</u>（能构成最小偏角的点）——相当于 从unsorted部分取出极大值</li></ul><p>选择排序中的选择过程需要比较元素大小，就要由一种<strong>比较器</strong>完成，<u>而上述比较偏角的过程也可以抽象为一种比较器的操作</u>。构造凸包的算法框架与选择排序相同，<u>只是比较器替换为to left test而已</u>。</p></blockquote><p><em>此处只是考虑一般情况，一些特殊细节未进行处理。例如在st上有s和s’两点，这两点的取舍问题未考虑。当然为了理解算法整体框架忽略特殊情况是很必要的。</em></p><h4 id="确定第一个极点"><a href="#确定第一个极点" class="headerlink" title="确定第一个极点"></a>确定第一个极点</h4><p><strong>一个细节</strong>：上文一开始提到的算法的最开始的<strong>第一个极点</strong>如何确定？</p><p>任何一个极点都可以使用，我们没必要去计算出哪个点是极点。可以选取y坐标最小的点，也就是最低点，在没有退化的情况下，这个点一定是一个极点。如果情况退化，有多个最低点（如例图中所示），我们就去选x坐标最小的那个点，也就是最左边的点即可。这种方法选出的点称为<strong>lowest-then-leftmost point（LTL）</strong>。<u>注意选取的规则的先后顺序，先选lowest，若点不唯一再选leftmost。</u></p><h3 id="Jarvis-March"><a href="#Jarvis-March" class="headerlink" title="Jarvis March"></a>Jarvis March</h3><p>类比选择排序的过程，我们得到的凸包构造算法就是<strong>Jarvis March算法</strong>，又称<strong><a href="https://en.wikipedia.org/wiki/Gift_wrapping_algorithm" target="_blank" rel="noopener">gift wrapping算法</a></strong>（算法过程如包装礼物一样）。接下来看算法具体实现方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ToLeft</span><span class="params">(Point P, Point q, Point s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> area2 = p.x*q.y - p.y*q.x + q.x*s.y -q.y*s.x + s.x*p.y - s.y*p.x;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> area2 &gt;<span class="number">0</span> ; <span class="comment">//左侧为真</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LTL</span> <span class="params">(Point S[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ltl = <span class="number">0</span>; <span class="comment">//the lowest-then-leftmost point</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;n;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S[k].y &lt; S[ltl].y || (S[k].y==S[ltl].y &amp;&amp; S[k].x&lt;S[ltl].x))</span><br><span class="line">            ltl =k;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> ltl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Javis</span><span class="params">(Point S[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; k++)</span><br><span class="line">    S[k].extreme =FALSE; <span class="comment">//首先将所有点标记为非极点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ltl=LTL(S, n); <span class="comment">//找到LTL</span></span><br><span class="line">    <span class="keyword">int</span> k=ltl;  <span class="comment">//将LTL作为第一个极点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">    S[k].extrem = <span class="literal">true</span>; <span class="keyword">int</span> s =<span class="number">-1</span>; <span class="comment">//s是要找的下一个极点，用t去循环找</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t=<span class="number">0</span>; t&lt;n; t++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(t != k &amp;&amp;t != s &amp;&amp; ( s == <span class="number">-1</span> || !ToLeft(S[K],S[s],S[t]) ) )</span><br><span class="line">                s = t; <span class="comment">//如果t在pq的右侧，则更新s</span></span><br><span class="line">        &#125;</span><br><span class="line">        S[k].succ = s; k = s; <span class="comment">//新的极边pq确定   </span></span><br><span class="line">        k = s; <span class="comment">//更新k的值，变为下一次查找的起点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span>(ltl != k) <span class="comment">//如果循环回到了原来的点，则结束</span></span><br></pre></td></tr></table></figure><h3 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h3><ol><li>首先，初始化将所有点都设为：非极点</li><li>然后，开始找到<u>第一个极点</u>（用LTL方法），找到之后赋值给k</li><li>接下来，开始找<u>下一个极点</u>s：<ul><li>主要用<code>ToLeft Test</code>来找出下一个极点</li></ul></li><li>循环第3步骤，直到找到所有极点</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>最后分析Jarvis March算法相较于增量构造法的优势。二者都是O(n^2^)的复杂度，Jarvis March算法的优势在于其的“<strong>输出敏感性（output sensitive）</strong>”。考虑点集S，共有n个点，来构造S上的凸包。</p><p>何为“<u>输出敏感性</u>”？Jarvis March算法每次新加入一条边都会耗费n的复杂度，但是构造过程一共会加入的边数往往比n少。如下图（设n = 7）：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20180206002208800.png" alt="img"></p><p>在非退化为共线的前提下，最好情况为只加入3条边（复杂度为O(3n)），最坏情况为所有点都是极点，加入n-1条边（复杂度为O(n^2^)）。实际情况中最坏情况出现的几率很小，我们引入一个指标h来衡量凸包的极边数（the size of convex hull）：<br>$$<br>h = |CH(S)|<br>$$<br>Jarvis March算法算法的复杂度<strong>更准确的表示为O(nh)。</strong>h又由最终输出结果，即凸包本身来决定，输出结果决定了构造过程的复杂度，这就是所谓的“输出敏感性”。这种类型的算法又被称为output sensitive algorithm。这种特性在其它凸包算法中也会体现。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 凸包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Convex Hull(凸包)</title>
      <link href="/archives/510d.html"/>
      <url>/archives/510d.html</url>
      
        <content type="html"><![CDATA[<p>这山之高，就叫凸碧；山之低洼近水处，就叫作凹晶。这凸、凹二字，历来用的人最少，如今直用做轩馆之名，更觉新鲜，不落窠臼。</p><a id="more"></a><h1 id="欧拉公式"><a href="#欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式</h1><p>简单介绍一下欧拉公式：</p><p>虚数中：i^2^=-1 ; i=√(-1)</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/1573819506389.png" alt="1573819506389"></p><p>其中θ为实数，i表示虚数中的虚数单位 i；</p><p>欧拉恒等式：</p><p>当θ=π时；</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/1573820164006.png" alt="1573820164006"></p><p>几何学中的欧拉公式：</p><p><code>V-E+F=2</code> 【v：几何体的顶点数；E：边数；F：面数】</p><h1 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h1><p><strong>凸包</strong>：比如，我们有很多很多钉子钉在木板上面，然后用一个皮筋将这些钉子包围起来，当我们松手后，皮筋就把这些定在全都包围起来。此时，这个皮筋所形成的凸多边形就叫<strong>凸包</strong>。如下图的蓝色的多边形就是凸包。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200304214005104.png" alt="绿色线圈记为凸包"></p><h2 id="凸性-Convexity"><a href="#凸性-Convexity" class="headerlink" title="凸性(Convexity)"></a>凸性(Convexity)</h2><p>下图中，假设x,y,z是三种颜色，如果仅以x,y就能调出来的颜色，那么如u所示它一定会落在x,y中；若需要x,y,z三种 一起，那么如v所示会落在以x,y,z三点连成的三角形内部。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/v2-386fd3aaf073885dd32ab6241e9a0452_720w.jpg" alt="凸性"></p><h2 id="极点-Extreme-Point"><a href="#极点-Extreme-Point" class="headerlink" title="极点(Extreme Point)"></a>极点(Extreme Point)</h2><p>有一个点集S。如果存在通过点P的直线L，使得点集S中除了点P之外的其他的点都在这个直线的同一侧，则这个点P就是<strong>极点(Extreme Points)</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200304214843584.png" alt="极点"></p><ul><li><p><strong>判断一个点是否为极点</strong>：该点P是否会被包含在其他点中任意三个点形成的三角形中，如果点P不在任何三角形内部，则说明点P是极点。反之，则不是极点。如下图：</p><p>下图中，S就不是极点，因为他在三角形内部。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200304220601816.png" alt="判断极点"></p><h2 id="判断极点的算法"><a href="#判断极点的算法" class="headerlink" title="判断极点的算法"></a>判断极点的算法</h2><h3 id="In-Trangle-Test"><a href="#In-Trangle-Test" class="headerlink" title="In-Trangle Test"></a>In-Trangle Test</h3><p><strong>算法描述伪代码</strong>：其实这个算法就是判断点是否在三角形内部。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200304221051234.png" alt="In-Trangle Test"></p><p><strong>代码实现：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200304221130677.png" alt="算法实现"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extremePoint</span> <span class="params">(<span class="built_in">point</span> S[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>; s&lt;n; s++)</span><br><span class="line">        S[s].extreme = TRUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>; p&lt;n; p++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> q=p+<span class="number">1</span>; q&lt;n; q++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> r=q+<span class="number">1</span>; r&lt;n; r++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>; s&lt;n; s++)</span><br><span class="line">                &#123;</span><br><span class="line"><span class="keyword">if</span>(s==p || s==q || s==r ||!S[s].extreme)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(Intriangle(S[p],S[q],S[r],S[s]))</span><br><span class="line">                        S[s].extreme = FALSE;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可知，该算法的时间复杂度为O(n^4^)，其实挺大的，在后面我们会进一步改善。</p><p>这样基于极点的凸包算法虽然效率不高，但是它会引出一个非常重要的操作我们称之为<strong>To-Left Test</strong><br>在后面我们可以看到这个测试几乎是贯穿于我们计算几何这个课程的始终的。如果说我们刚才所给出的那个算法还有什么需要补充的话其实最重要的也就是那样的一个细节也就是所谓的<strong>In-Triangle test</strong>。</p><h4 id="To-Left-Test"><a href="#To-Left-Test" class="headerlink" title="To-Left Test"></a>To-Left Test</h4><p>我们将刚才这个In-Triangle Test转化为三次To-Left测试也就是说一个点如果确实落在某一个三角形的内部的话那么相对于这个三角形的三条边所做的这个To-Left测试都会统一的返回true或者统一地返回false。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200304223141504.png" alt="To-Left Test"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InTriangle</span><span class="params">(Point p, Point q, Point r, Point s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> pqLeft = ToLeft(p, q, s);</span><br><span class="line">    <span class="keyword">bool</span> qrLeft = ToLeft(q, r, s);</span><br><span class="line">    <span class="keyword">bool</span> rpLeft = ToLeft(r, p, s);</span><br><span class="line">    <span class="keyword">return</span> (pdLeft == qrLeft) &amp;&amp; (qrLeft == rqLeft);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>To-Left测试是相对于另外这两个点所确定的那条<strong>有向</strong>直线而言的，任何一条有向直线不仅会把平面分成两部分，我们还可以知道哪一边是左边，哪一边是右边。To-Left，其实就是说这个点相对于刚才的那条有向线而言到底是位于它的左侧，还是右侧。如果是前者就是true，否则的话就是false。因为三角形有三条边，所以我们要用三次To-Left Test。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200304223826387.png" alt="INT=3*TLT"></p><p><strong>To-Left Test具体实现</strong>：</p><p>这里用到了行列式来求三角形面积（至于原理，这里就不多说了）。下图中的这个行列式实际上算的首先是它的面积的<strong>两倍</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200304224456126.png" alt="To-Left Test"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ToLeft</span><span class="params">(Point p, Point q, Point s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Area2(p, q, s) &gt; <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Area2</span><span class="params">(Point p, Point q, Point s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">        p.x * q.y - p.y * q.x </span><br><span class="line">       +q.x * s.y - q.y * s.x</span><br><span class="line">       +s.x * p.y - s.y *p.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：这里的面积其实是“有向面积”，也就是说这里的面积分正负（相对于这样一个逆时针的<br>一个编号pqs的这样的一个面积 与 s在右侧也就是按照顺时针的pqs所构成的面积虽然有可能大小是一样完全对称但是它们的符号是相反的）。整个这个To-Left的测试的<strong>判断的依据也就在于这个符号</strong>。</p><p>这个行列式取正条件为：当且仅当s位于pq所确定的这条有向直线的左侧。其中转换成代码也是非常简明的，代码如上图所示。</p><p>至此，To-Left Test实现完成。</p><h2 id="极边-Extreme-Edge"><a href="#极边-Extreme-Edge" class="headerlink" title="极边(Extreme Edge)"></a>极边(Extreme Edge)</h2><p><strong>极边</strong>：两个极点连成的边，剩余的所有点均会在该边的一侧。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/v2-534df0cc332ead89da7586c99c22dd5f_720w.jpg" alt="极边"></p><p><strong>判断是否为极边</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200308231616965.png" alt="image-20200308231616965"></p><ul><li><strong>代码实现</strong>：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200308231916308.png" alt="markEE"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">markEE</span><span class="params">(<span class="built_in">point</span> S[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; k++)</span><br><span class="line">        S[k].extreme = FALSE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p=<span class="number">0</span>; p&lt;n; p++) <span class="comment">//test</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> q=p+<span class="number">1</span>; q&lt;n; q++) <span class="comment">//检验每一条边</span></span><br><span class="line">            checkEdge(S,n,p,q) <span class="comment">//有向边pq</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200308231932585.png" alt="checkEdge"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkEdge</span><span class="params">(Point S[], <span class="keyword">int</span> n, <span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> LEmpty =TRUE, REmpty =TRUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n &amp;&amp; (LEmpty || REmpty); k++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k != p &amp;&amp; k != q)</span><br><span class="line">            ToLeft(S[p], S[q], S[k]) ? LEmpty=FALSE : REmpty=FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(LEmpty || REmpty)</span><br><span class="line">        S[p].extreme=S[q].extreme=TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现的步骤：</p><ol><li><p>初始时，先假设所有的点都不是极点。</p></li><li><p>开始遍点集S中的点，它们两两组合成一个线段，然后进行checkEdge(检查这些线段是否是极边)。</p><p>检查的方法<code>checkEdge</code>：</p><p>利用ToLeft测试，每次都将当前的线段与其他点（即，除了这两个点之外的点）进行ToLeft测试<strong>，如果测试结果中：LEmpty、REmpty 其中之一为true，就表明这两个点构成的线段为*极边*，而且同时也检测出这两个点是*极点*。</strong>（其实两个点组成的线段进行<code>checkEdge</code>的结果中的LEmpty、REmpty最多只有一个是true,因为这里不存在一条边的两侧都没有其他点的情况）</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">markEE</span><span class="params">(Point S[], <span class="keyword">int</span> n)</span> <span class="comment">//n&gt;2</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;n; k ++)</span><br><span class="line">        S[k].extreme = False; <span class="comment">//先假设所有的点都不是极点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; n; p ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> q = p + <span class="number">1</span>; q &lt; n; q ++)</span><br><span class="line">            checkEdge(S, n, p, q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkEdge</span><span class="params">(Point S[], <span class="keyword">int</span> n, <span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//LEmpty、REmpty表示改边的左侧、右侧，等于True时表示该侧是没有点的。</span></span><br><span class="line">    <span class="keyword">bool</span> LEmpty = True, REmpty = True;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n &amp;&amp; (LEmpty || REmpty); k ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k != p &amp;&amp; k != q)</span><br><span class="line">        &#123;</span><br><span class="line">            ToLeft(S[p], S[q], S[k]) ? LEmpty = False : REmpty = False;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(LEmpty || REmpty)</span><br><span class="line">        S[p].extreme = S[q].extreme = True;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样可利用此来判断是否是极点（复杂度为O(n^3)）。</p><h1 id="补：根据极角排序"><a href="#补：根据极角排序" class="headerlink" title="补：根据极角排序"></a>补：根据极角排序</h1><p><strong>定义：</strong></p><p>我们平常所使用的坐标系都是直角坐标系，而极角排序是在极坐标系下进行的。<br>这里首先要选取一个点，然后其它点根据与参考点的连线与x轴所成的夹角的大小进行排序的。<br>这里我们可以简单理解为绕着一个点逆时针转圈访问。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="Convex-Hull-%E5%87%B8%E5%8C%85/1-1584641857659.png" alt="极角排序"></p><p><strong>代码：</strong></p><p>在讲具体实现方法之前，先给出用到的函数和结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>//存储点</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cross</span><span class="params">(<span class="keyword">double</span> x1,<span class="keyword">double</span> y1,<span class="keyword">double</span> x2,<span class="keyword">double</span> y2)</span>　<span class="comment">//计算叉积</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x1*y2-x2*y1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">compare</span><span class="params">(<span class="built_in">point</span> a,<span class="built_in">point</span> b,<span class="built_in">point</span> c)</span><span class="comment">//计算极角</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cross((b.x-a.x),(b.y-a.y),(c.x-a.x),(c.y-a.y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>利用叉积的正负来排序</p><blockquote><p>　关于叉积：叉积=0是指两向量平行（重合）；叉积&gt;0，则向量a在向量b的顺时针方向（粗略的理解为在a在b的下方）；叉积&lt;0，则向量a在向量b的逆时针方向（粗略的理解为在a在b的上方）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">point</span> a,<span class="built_in">point</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">point</span> c;<span class="comment">//原点</span></span><br><span class="line">    c.x = <span class="number">0</span>;</span><br><span class="line">    c.y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(compare(c,a,b)==<span class="number">0</span>)<span class="comment">//计算叉积，函数在上面有介绍，如果叉积相等，按照X从小到大排序</span></span><br><span class="line">        <span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> compare(c,a,b)&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用 complex 的内建函数，算出极角大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x real()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y imag()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Point&amp; p1, <span class="keyword">const</span> Point&amp; p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg(p1) &lt; arg(p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用 arctan 计算极角大小。注意角的大小范围是(-180°, +180°]。弧度表示。这里用 arctan2 函数应该是为了提高精度。</p><blockquote><p>关于atan2()函数：在C语言的math.h或C++中的cmath中有两个求反正切的函数atan(double x)与atan2(double y,double x) 他们返回的值是弧度要转化为角度再自己处理下。</p><p>前者接受的是一个正切值（直线的斜率）得到夹角，但是由于正切的规律性本可以有两个角度的但它却只返回一个，因为atan的值域是从-90°~90° 也就是它只处理一四象限，所以一般不用它。</p><p><strong>推荐这个</strong>：第二个atan2(double y,double x) 其中y代表已知点的Y坐标，同理x ,返回值是此点与远点连线与x轴正方向的夹角，这样它就可以处理四个象限的任意情况了，它的值域相应的也就是-180~180了</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">const</span> Point&amp; p1, <span class="keyword">const</span> Point&amp; p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">atan2</span>(p1.y, p1.x) &lt; <span class="built_in">atan2</span>(p2.y, p2.x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>先判断象限，再用外积判断顺序，最后根据长度排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Quadrant</span><span class="params">(<span class="built_in">point</span> a)</span>　　<span class="comment">//象限排序，注意包含四个坐标轴</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x&gt;<span class="number">0</span>&amp;&amp;a.y&gt;=<span class="number">0</span>)  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a.x&lt;=<span class="number">0</span>&amp;&amp;a.y&gt;<span class="number">0</span>)  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a.x&lt;<span class="number">0</span>&amp;&amp;a.y&lt;=<span class="number">0</span>)  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(a.x&gt;=<span class="number">0</span>&amp;&amp;a.y&lt;<span class="number">0</span>)  <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp3</span><span class="params">(<span class="built_in">point</span> a,<span class="built_in">point</span> b)</span>  <span class="comment">//先按象限从小到大排序 再按极角从小到大排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Quadrant(a)==Quadrant(b))<span class="comment">//返回值就是象限</span></span><br><span class="line">        <span class="keyword">return</span> cmp1(a,b);</span><br><span class="line">    <span class="keyword">else</span> Quadrant(a)&lt;Quadrant(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="向量的点乘与叉乘的几何意义"><a href="#向量的点乘与叉乘的几何意义" class="headerlink" title="向量的点乘与叉乘的几何意义"></a>向量的点乘与叉乘的几何意义</h2><p>向量的<strong>点乘（内积）</strong>：</p><p>$$<br>\vec{a} \cdot \vec{b}=|\vec{a}| \cdot |\vec{b}|\cdot cos\theta<br>$$<br>点乘的几何意义是可以用来表征或计算两个向量之间的夹角，以及在b向量在a向量方向上的投影</p><p>向量的<strong>叉乘（外积）</strong>：<br>$$<br>\vec{a} \times \vec{b}=|\vec{a}| \cdot |\vec{b}|\cdot sin\theta<br>$$<br>向量积被定义为：</p><ul><li><p>模长：（在这里θ表示两向量之间的夹角(共起点的前提下)（0° ≤ θ ≤ 180°），它位于这两个矢量所定义的平面上。）</p></li><li><p>方向：a向量与b向量的向量积的方向与这两个向量所在平面垂直，且遵守右手定则。（一个简单的确定满足“右手定则”的结果向量的方向的方法是这样的：若坐标系是满足右手定则的，当右手的四指从a以不超过180度的转角转向b时，竖起的大拇指指向是c的方向。<strong>c</strong> = <strong>a</strong> ∧ <strong>b</strong>）</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="Convex-Hull-%E5%87%B8%E5%8C%85/afa5c98582b08ef4bac175d7bb5c9bda80adcaab.png@968w_1346h.webp" alt="叉乘"></p><p>特别的，在二维中，两个向量的向量积的模的绝对值等于由这两天向量组成的平行四边形的面积。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="Convex-Hull-%E5%87%B8%E5%8C%85/62a0493b8bb7f29f2655190b718be3d029e6750e.png@960w_750h.webp" alt="向量积"></p><p>向量的叉乘，即求同时垂直两个向量的向量，即c垂直于a，同时c垂直于b（a与c的夹角为90°，b与c的夹角为90°）</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><strong>极角排序</strong>：<a href="https://sumygg.com/2013/07/30/Sorting-Points-by-Polar-Angle/" target="_blank" rel="noopener">https://sumygg.com/2013/07/30/Sorting-Points-by-Polar-Angle/</a></p><p><strong>关于极角排序：</strong><a href="https://www.cnblogs.com/aiguona/p/7248311.html" target="_blank" rel="noopener">https://www.cnblogs.com/aiguona/p/7248311.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 凸包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造凸包-增量构造法</title>
      <link href="/archives/7c53.html"/>
      <url>/archives/7c53.html</url>
      
        <content type="html"><![CDATA[<p>在上面的极点法和极边法的复杂度分别是O(n^4^)和O(n^3^)，如果点集S的规模比较大的话，这两种方法就太慢辽。</p><a id="more"></a><p>在引入新算法之前首先来回顾一下经典的算法思想：减治（decrease and conquer），注意不是分治（divided and conquer），二者<a href="https://www.geeksforgeeks.org/decrease-and-conquer/" target="_blank" rel="noopener">稍有区别</a>。简单来讲就是将问题划分为一个个简单的小问题，减而治之，逐个求解，最终就能得到整个问题的解。</p><p>减治法的经典例子就是插入排序（insertion sort）。插入排序的过程可以归结成下图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200315172527.png" alt="img"></p><p>排序的过程中将序列分为两部分：已排序部分（sorted）和未排序部分（unsorted）。每次排序都是从unsorted中拿出一个元素，通过一次<strong>顺序查找</strong>过程在sorted部分中找到位置并插入其中。</p><p>整个插入排序的过程就是逐个元素的去“蚕食”unsorted部分的过程，连续的进行这个操作就会将整个问题解决。这种将大问题分解成小问题的减治过程，又被看成一种递增的、增量式的策略（incremental strategy）。这种思想为解决凸包问题提供了新的思路：从逐个插入新点的角度构造凸包。</p><p>典型流程如下图（标识为：极点/整体规模）：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200311222412367.png" alt="image-20200311222412367"></p><p>插入新的点可能的情况有：</p><blockquote><ul><li>新点对凸包有“贡献”，例如5/5→6/6，6/6→7/7；</li><li>新点也有可能没有“贡献”，例如7/7→7/8；</li><li>还有可能使原先有“贡献”的点失效，极点数量减少，例如7/8→6/9。<br>那么如何对不同情况进行处理呢？</li></ul></blockquote><h3 id="确定新点与现有凸包的关系-in-convex-polygon-test"><a href="#确定新点与现有凸包的关系-in-convex-polygon-test" class="headerlink" title="确定新点与现有凸包的关系~in-convex-polygon test"></a>确定新点与现有凸包的关系~in-convex-polygon test</h3><p>构造过程的核心算法应该是：<strong>判定待定点是否位于某多边形内部（in-convex-polygon test）</strong>。再看上图流程，实际上每步的核心就是判断点位于多边形内部还是外部，若落在外部，则新插入的点就是下一个极点，否则舍弃。</p><p>考虑基本情况，给定一个点和一个多边形，如何高效判断该点与多边形的位置关系呢？</p><ul><li><p>一种思路是：我们可以先对多边形进行一个“<strong>预处理</strong>”，给每个点按序编号，类比<strong>有序向量二分查找</strong>的思想，来逐步缩小规模。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/v2-3e18e3822557820d852899d5c503f62a_720w.jpg" alt="img"></p><p>首先任选一点为基准点（蓝色点），然后用二分法选取其余点的“中点“（预处理已经为所有点排了序），然后判断基准点到终点的有向直线与待定点的位置关系<strong>（to-left test）</strong>。然后可将搜索范围减半，反复上述过程，直到最后退化为平凡情况：三角形与点的位置关系<strong>（in-triangle test）</strong>。</p></li></ul><p>分析一下算法的整体复杂度：整个算法共log(n)步，每步的to-left test或in-triangle test都为常数成本，则整体复杂度为log(n)。至此，我们似乎得到了一个log(n)的“高效”算法，但是这种方法真的可行吗？</p><blockquote><p>注意，每步都会将原凸包规模减半，也就是说凸包是<strong>动态的</strong>，随时可能变化。这种方法和极点法或极边法中静态查找的情况是完全不同的。</p><p>类比插入排序的过程来解释这个问题。为何插入排序的复杂度是n^2^而非nlog(n)？每次插入时，既然sorted部分已经有序，为何不使用二分查找来取代顺序查找（复杂度由n变为log(n)）？这不得不考虑sorted部分的动态性，每次插入后它的结构都会改变，而二分查找必须在静态结构中实现。当然可以使用std::vector这类支持按秩访问（call by rank）的数据结构，但是插入时维护vector的成本依旧是线性复杂度。因此插入排序的总体复杂度是n^2^。要处理的凸包与插入排序中sorted部分本质是一样的，它们都不是静态不变的结构，而要随着算法执行而不断变化。若要每次在log(n)成本下完成待定点的in-convex-polygon test，必须将凸包存储为类似vector的数据结构，但是每次向这种数据结构插入新点的成本依旧是线性的。因此对凸包进行的所谓“预处理”是没有意义的，这种减治策略算法复杂度最低应该为O(n^2^)。</p></blockquote><p>到现在问题依旧没有解决，究竟如何用这种增量式的策略来构造凸包？其实复杂问题中最朴素、最基本的方法反而是最有效的。</p><p>==in-convex-polygon test最基本的方法是什么？就是按一定方向（约定为逆时针）凸包的每条边和待定点做<strong>to-left test</strong>，一旦有一次test为false就能断定点在凸包外面。这实际上就是将in-triangle test推广多边形的情况。因此每次in-convex-polygon test的成本就会变成当前凸包的规模，也就是n。==对于每个新点做一次in-convex-polygon test，构造算法的整体复杂度就是O(n^2^)。算法的复杂度从极边法的O(n^3^)又下降了一个数量级。</p><p><strong>其实增量算法的整个思路可以分成两块：</strong></p><ul><li><strong>1、如何判断凸包与新点的位置关系（in-convex-polygon test）</strong></li><li><strong>2、如何向凸包插入新点</strong></li></ul><p>上面的方法已经解决（黄色部分）了第一个问题。第二个问题看下面部分：</p><h3 id="如何向凸包插入新点-support-line"><a href="#如何向凸包插入新点-support-line" class="headerlink" title="如何向凸包插入新点~support-line"></a>如何向凸包插入新点~support-line</h3><p>现在来讨论如何向凸包插入新点：</p><p>比如下面这个点，应该如何插入凸包之中呢？</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200311230823679.png" alt="新点准备插入现有凸包"></p><p><strong>插入过程</strong>：将新点x插入原凸包的过程，本质上就是寻找两个连接点s和t，将x和t、s分别连接得到新的凸包。注意t和s两点将整个原凸包边界分为两部分：st和ts两个有向段。构造新凸包就要保留远端st、舍弃近端ts。取代近端ts的两条线就是x和t的连线xt和xs，被称为<strong>切线（tangent）</strong>或者<strong>support line（支撑线）</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/v2-8afbf4ebfa808eec9ffff8c111ae6465_720w.jpg" alt="img"></p><p><strong>那如何查找t、s这两个点呢？</strong></p><blockquote><p>我们在凸包上任取一点v，按<u>逆时针</u>方向v点会有一个直接前驱点和直接后继点。考察有向直线xv与点v直接前驱和直接后继的位置关系（两次to left test），记录为一个<strong>pattern表</strong>。</p><p>结果无非是四种情况：v的直接前驱和直接后继相对于有向直线xv的位置是RL，LR，LL，RR。例如上图黄色点v，是R和L；蓝色点v分别是L和R。实际上凸包边界st上所有点的pattern都为RL，ts上所有点的pattern都为LR。关键点在于：点S的pattern是LL，点t的pattern为RR。</p></blockquote><p>因此对凸包边界每个点做<strong>两次to left test</strong>，判断其pattern就可找出s和t，花费时间成本为常数。</p><h3 id="incremental-construction"><a href="#incremental-construction" class="headerlink" title="incremental construction"></a>incremental construction</h3><p>再来回顾整个凸包构造算法的两大问题：in-convex-polygon test和插入新点。分开考虑只是为了将思路简化，实际上这两个问题可以套用一个算法，同时来解决。</p><p>具体做法就是：对于每个待定点x，<u>不必特意去考虑它与凸包的位置关系</u>，<u>而是遍历凸包上每一个点</u>。</p><blockquote><p>对于凸包<strong>边界</strong>上的每一个点，我们都能通过两次to left test迅速判断出pattern。</p><p>对于x位于凸包<strong>外部</strong>的情况，经过遍历凸包的点，我们很容易就能得到s和t的位置，得到两条support line，从而构造出新的凸包；</p><p>而对于x位于凸包<strong>内部</strong>的情况，凸包边界每个点都不可能出现RR或LL的情况，直接舍弃x即可。</p></blockquote><p>每次遍历凸包边界点的复杂度为O(n)，整个构造过程要增量式的逐点考察，自然得到了一个<strong>O(n^2^)</strong>的incremental construction算法。</p><p>这就是所谓增量构造法来构造凸包的过程。构造过程巧妙的避开了特殊处理诸如5/5→6/6、7/7→7/8、7/8→6/9等复杂情况，采用一致的思路逐个考察“新点”，最终完成凸包的构造。</p><h3 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h3><p>待写……..</p><h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p><strong>其实增量算法的整个思路可以分成两块：</strong></p><ul><li><strong>1、如何判断凸包与新点的位置关系（in-convex-polygon test）</strong></li><li><strong>2、如何向凸包插入新点</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 凸包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let’s Build A Simple Interpreter 7</title>
      <link href="/archives/5a757a52.html"/>
      <url>/archives/5a757a52.html</url>
      
        <content type="html"><![CDATA[<p>之前的那几小结，我们都是把interpreter的代码和parser的代码混在一起，而且interpreter在parser识别出一个如加减乘除之类 的特定的语言结构(language construct)后，就会立刻对它进行求值。这种 interpreter 被称为 <strong>语法导向解释器</strong>(syntax-directed interpreter)。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原文链接：<a href="https://ruslanspivak.com/lsbasi-part7/" target="_blank" rel="noopener">https://ruslanspivak.com/lsbasi-part7/</a></p><p>之前的那几小结，我们都是把interpreter的代码和parser的代码混在一起，而且interpreter在parser识别出一个如加减乘除之类 的特定的语言结构(language construct)后，就会立刻对它进行求值。这种 interpreter 被称为 <strong>语法导向解释器</strong>(syntax-directed interpreter)。</p><blockquote><p>他们通常在输 入上做一个 pass 且只适合基础的语言应用。</p></blockquote><p>为了分析更复杂的编程语言 Pascal 的结构， 我们需要建立一个 <strong>中间表示</strong> (intermediate representation, <strong>IR)</strong>。</p><blockquote><p>parser 会 负责构建 IR</p><p>interpreter 会用来解释由 IR 所代表的输入。</p></blockquote><p>事实证明树是一个表示 IR 非常合适的数据结构。关于数的一些术语terminology：</p><ul><li>树是一个包含一个或多个结点组成的层次数据结构。</li><li>树有一个<strong>根结点</strong>，就是顶部结点。</li><li>除根结点外的所有结点有唯一 一个<strong>父结点</strong>。</li><li>下图中结点为*的是一个父结点。结点为 2 和 7 的是它的子结点；子结点从左到右排序。</li><li>没有子结点的结点称为<strong>叶子结点</strong>。</li><li>有一个或多个子结点的非根结点被称为<strong>中间结点</strong>。</li><li>子结点也可以是完全子树。下图中结点＋的左子树（结点为*）就是一个有自己子结点的 完全子树。</li><li>在计算机科学中我们把树倒过来画，根结点在最上边，分枝向下生长。</li></ul><p>下面是表达式 2 * 7 + 3 的带有解释的树形表示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_tree_terminology.png" alt="lsbasi_part7_tree_terminology"></p><p>本系列中我们会用到的 IR 被称为 <strong>抽象语法树</strong> (abstract-syntax tree, AST)。但在深 入了解 AST 之前让我们简单聊聊 <strong>解析树</strong> (parse tree)。</p><blockquote><p>尽管我们不会在解释器和编译 器中用到解析树，但它会通过可视化 parser 执行轨迹的方法，加深你对 parser 如何解释 输入的理解。我们也会将它和 AST 做比较，来表明为什么 AST 比解析树更适合用来做 IR。</p></blockquote><p>那么，什么是解析树呢？</p><ul><li>解析树（有时叫做 <strong>具体语法树<em>concrete syntax tree</em></strong> ）是一个根据我们的语法定义来 表示一门语言的句法结构的树形结构。它基本上展示了你的 parser 如何识别语言结构或者， 换句话说，它展示了你语法的开始符号怎么派生出该编程语言中一个特定的字符串的。</li></ul><p>parser 的调用栈隐式地代表了一个解析树，且当parser 在试图识别一个特定的语言结构时，解析树 就会自动地在内存中构建出来。下面是表达式 2 * 7 + 3 的解析树：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_parsetree_01.png" alt="lsbasi_part7_parsetree_01"></p><blockquote><p>在上面的图片中可以看到：</p><ul><li>解析树记录了 parser 用来识别输入的一系列规则。</li><li>解析树的根结点的标签是语法的开始符号(start symbol)。</li><li>每个中间结点表示一个非终结符(non-terminal)，代表应用了一条语法规则，像我们的情况里的 <code>expr</code>, <code>term</code>和 <code>factor</code>.</li><li>每个叶子结点代表了一个 token.</li></ul></blockquote><blockquote><p>我们不会手动构建解析树且在我们的解释器中用到它，但解析树可以通过可视化 调用过程帮助我们理解 parser 怎么解释输入。</p><p>你可以使用一个名为 <a href="https://github.com/rspivak/lsbasi/blob/master/part7/python/genptdot.py" target="_blank" rel="noopener">genptdot.py</a> 的小应用（我很快写完用来帮助你的），来查看不同的 算术表达式看起来什么样。要使用这个应用你首先需要安装 <a href="http://graphviz.org/" target="_blank" rel="noopener">Graphviz</a>包，然后运行下面的 命令，你可以打开生成的图片文件 parsetree.png 查看你从命令行传入的表达式的解析树：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python genptdot.py <span class="string">"14 + 2 * 3 - 6 / 2"</span> &gt; \</span><br><span class="line">  parsetree.dot &amp;&amp; dot -Tpng -o parsetree.png parsetree.dot</span><br></pre></td></tr></table></figure><p>下面是由表达式 14 + 2 * 3 - 6 / 2 生成的图片 parsetree.png:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_genptdot_01.png" alt="lsbasi_part7_genptdot_01"></p></blockquote><h2 id="抽象语法树-AST"><a href="#抽象语法树-AST" class="headerlink" title="抽象语法树(AST)"></a>抽象语法树(AST)</h2><p>现在我们来聊聊<strong>抽象语法树(AST)</strong>。它是在余下的文章中会大量用到的中间表示(IR)。它是 我们的解释器和未来编译器项目的核心数据结构。</p><p>让我们以把表达式 2 * 7 + 3 的 AST 和解析树放在一起看来开始我们的讨论：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_ast_01.png" alt="lsbasi_part7_ast_01"></p><p>从上面的图片中可以看出，AST 抓住了输入的精髓且更小。</p><p><strong>AST 和解析树最主要的区别有</strong>：</p><blockquote><ul><li>AST 使用操作符/操作(operators/operations )作为根结点，操作数(operands)作为它们的子结点。</li><li>不像解析树，AST <strong>不</strong>使用中间结点来表示语法规则。</li><li>AST 并不把真实句法中的所有结节都表示出来（这就是为什么它是抽象的）──例如，没有 规则结点和括号。</li><li>对于相同的语言结构来说，AST 相比于解析树更紧凑。</li></ul></blockquote><p><strong>抽象语法树是什么</strong>？</p><blockquote><p>抽象语法树(AST)是表示一个语言结构的抽象句法结构的树形表示，它的中间结点和根结点代表了一个操作符，子结点代表了该操作符的操作数。</p></blockquote><p>看一下AST 与解析树对比，显现他的紧凑性：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_ast_02.png" alt="lsbasi_part7_ast_02"></p><p><strong>如何将操作符的优先级(precedence)编码进 AST 呢？</strong></p><blockquote><p>为了把操作符优先级编码进 AST，即，为了表示“X 在 Y 之前发生”你只需要在树中把 X 放在低于 Y 的位置。你在前面 的图片中已经见过到了。</p><ul><li>【例子】：在下面的图片中，左边是表达式 2 * 7 + 3 的 AST。让我们用括号把 7 + 3 围起来以改变 它的优先级。在右边是修改后的表达式 2 * (7 + 3) 的 AST：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_astprecedence_01.png" alt="lsbasi_part7_astprecedence_01"></p></blockquote><h3 id="代码实现AST"><a href="#代码实现AST" class="headerlink" title="代码实现AST"></a>代码实现AST</h3><p>好了，让我们写些代码来实现不同的 AST 结点类 并修改我们的 parser 来生成包含这些结点的 AST 树：</p><ul><li><p>首先，新建一个基本结点类叫做 AST，其他类会从它继承：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AST</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span> <span class="comment">#pass 不做任何事情，一般用做占位语句。因为如果定义一个空函数程序会报错，当你没有想好函数的内容是可以用 pass 填充，使程序可以正常运行。</span></span><br></pre></td></tr></table></figure></li><li><p>回忆一下 AST 表示了<strong>操作符-操作数</strong>模型。到现在为止，我们有4个操作符和整型操作数。操作符有加、减、乘、除。我们原本可以新建单独的类来表示每个操作符如 AddNode, SubNode, MulNode 和 DivNode，但相反我们只会新建一个 BinOp 类来表示所有 4 个<strong>二元操作符*binary operator*</strong> （二元操作符就是作用在两个操作数的操作符）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinOp</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, left, op, right)</span>:</span></span><br><span class="line">    self.left = left</span><br><span class="line">    self.token = self.op = op</span><br><span class="line">    self.right = right</span><br></pre></td></tr></table></figure><ul><li>构造函数的参数是 <code>left</code>, <code>op</code>, 和 <code>right</code>, 其中 <code>left</code> 和 <code>right</code> 分别指向了表示 左操作数和右操作数的结点。 <code>op</code> 保存了指向操作符本身的 token: <code>Token(PLUS, &#39;+&#39;)</code> 表示加操作符， <code>Token(MINUS, &#39;-&#39;)</code> 表示减操作符，等等。</li></ul></li><li><p>为了在 AST 中表示整数，我们定义一个 <code>Num</code> 类，它将保存一个 <code>INTEGER</code> token 和该 token 的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Num</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, token)</span>:</span></span><br><span class="line">    self.token = token</span><br><span class="line">    self.value = token.value</span><br></pre></td></tr></table></figure><ul><li>和你注意到的一样，所有的note保存 token 从而则创建note(all nodes store the token used to create the node)。这主要是为了方便，将来会派上用场。</li></ul></li></ul><p>回忆一下表达式 2 * 7 + 3 的 AST。我们会在代码中手工创建该表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> spi <span class="keyword">import</span> Token, MUL, PLUS, INTEGER, Num, BinOp</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mul_token = Token(MUL, <span class="string">'*'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plus_token = Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mul_node = BinOp(</span><br><span class="line"><span class="meta">... </span>    left=Num(Token(INTEGER, <span class="number">2</span>)),</span><br><span class="line"><span class="meta">... </span>    op=mul_token,</span><br><span class="line"><span class="meta">... </span>    right=Num(Token(INTEGER, <span class="number">7</span>))</span><br><span class="line"><span class="meta">... </span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_node = BinOp(</span><br><span class="line"><span class="meta">... </span>    left=mul_node,</span><br><span class="line"><span class="meta">... </span>    op=plus_token,</span><br><span class="line"><span class="meta">... </span>    right=Num(Token(INTEGER, <span class="number">3</span>))</span><br><span class="line"><span class="meta">... </span>)</span><br></pre></td></tr></table></figure><p>以下是在新定义的结点类下 AST 的样子。下面的图片也遵循了上面手工创建的过程：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_astimpl_01.png" alt="lsbasi_part7_astimpl_01"></p><h2 id="parser-代码"><a href="#parser-代码" class="headerlink" title="parser 代码"></a>parser 代码</h2><p>下面是我们修改过的 parser 代码，在识别输入（算术表达式）时建立和返回一个 AST:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AST</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinOp</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, left, op, right)</span>:</span></span><br><span class="line">    self.left  = left</span><br><span class="line">    self.token = self.op = op</span><br><span class="line">    self.right = right</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Num</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, token)</span>:</span></span><br><span class="line">    self.token = token</span><br><span class="line">    self.value = token.value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lexer)</span>:</span></span><br><span class="line">    self.lexer = lexer</span><br><span class="line">    <span class="comment"># set current token to the first token from the input</span></span><br><span class="line">    self.current_token = self.lexer.get_next_token()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">'Invalid syntax'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">    <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">    <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">    <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">    <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">    <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">        self.current_token = self.lexer.get_next_token()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.error()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""factor : INTEGER | LPAREN expr RPAREN"""</span></span><br><span class="line">    token = self.current_token</span><br><span class="line">    <span class="keyword">if</span> token.type == INTEGER:</span><br><span class="line">        <span class="keyword">return</span> Num(token)</span><br><span class="line">    <span class="keyword">elif</span> token.type == LPAREN:</span><br><span class="line">        self.eat(LPAREN)</span><br><span class="line">        node = self.expr()</span><br><span class="line">        self.eat(RPAREN)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""term : factor ((MUL | DIV) factor)*"""</span></span><br><span class="line">    node = self.factor()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">        token = self.current_token</span><br><span class="line">        <span class="keyword">if</span> token.type == MUL:</span><br><span class="line">        self.eat(MUL)</span><br><span class="line">        <span class="keyword">elif</span> token.type == DIV:</span><br><span class="line">        self.eat(DIV)</span><br><span class="line"></span><br><span class="line">        node = BinOp(left=node, op=token, right=self.factor())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    expr   : term ((PLUS | MINUS) term)*</span></span><br><span class="line"><span class="string">    term   : factor ((MUL | DIV) factor)*</span></span><br><span class="line"><span class="string">    factor : INTEGER | LPAREN expr RPAREN</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    node = self.term()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (PLUS, MINUS):</span><br><span class="line">        token = self.current_token</span><br><span class="line">        <span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">        self.eat(PLUS)</span><br><span class="line">        <span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">        self.eat(MINUS)</span><br><span class="line"></span><br><span class="line">        node = BinOp(left=node, op=token, right=self.term())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.expr()</span><br></pre></td></tr></table></figure><p>让我们看一些算术表达式的 AST 的构建过程。</p><p>如果你看了上面的 parser 代码，可以看到它建立一个 AST 中的结点的时，把变量 node 的当前值做为 BinOp 结点的左子结点，把对 <code>term</code> 或 <code>factor</code> 调用的返回结果做为它 的右子结点，这实际上就是把结点推向左边，下面表达式 1 +2 + 3 + 4 + 5 的树结构就是 这种情况的一个好例子。下面是 parser 如何一步步地构建表达式 1 + 2 + 3 + 4 + 5 的 AST 的图形表示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_astimpl_02.png" alt="lsbasi_part7_astimpl_02"></p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>好了，下面是表达式 2 * 7 + 3 的 AST：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_ast_walking_01.png" alt="lsbasi_part7_ast_walking_01"></p><p><strong>你怎么遍历这个树并恰当地对它所代表的表达式进行求值呢？</strong></p><blockquote><p>你可以使用<strong>后序遍历*postorder traversal*</strong> (深度优先遍历<em>depth-first traversal</em> 的一个特例) 。</p><ul><li>这种方式由根结点开始，递归由左至右访问每个结点的子结点。后序遍历从根结点开始尽可能快地访问离根结点远的结点(The postorder traversal visits nodes as far away from the root as fast as it can)。</li></ul></blockquote><p>下面是后序遍历的伪代码，其中 <code>&lt;&lt; postorder actions &gt;&gt;</code>是一些操作的占位符，如 <code>BinOp</code> 结点的加减乘除操作或 <code>Num</code> 结点返回整数的简单操作：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_ast_visit_postorder.png" alt="lsbasi_part7_ast_visit_postorder"></p><ul><li><p><strong>为什么要使用后续遍历呢？</strong></p><blockquote><p>第一，我们需要对在树中更低的中间结点进行求值， 因为它们代表了优先级更高的操作符，</p><p>第二，我们在对操作数 参与 对应操作符 的运算 之前需要对操作数进行求值。</p></blockquote><p>在下面的图片中，可以看到使用后序遍历时我们会首先对表达式 2*7 进行 求值，而只有在对 14 + 3 求值之后，我们才会得到正确答案 17:</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_ast_walking_02.png" alt="lsbasi_part7_ast_walking_02"></p><p><strong>三种深度优先遍历</strong>：</p><p>为了完整起见，三种深度优先遍历的方式：先序遍历，中序遍历和后序遍历。这 些遍历方式名字的来自于遍历代码中操作的位置：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_ast_visit_generic.png" alt="lsbasi_part7_ast_visit_generic"></p><p>有时你可能需要在所有地方（先序，中序和后序）都执行一些操作。你会在本文的源代码仓 库中找到一些例子。</p><blockquote><ul><li><p>先序遍历<em>preorder traversal</em>,</p><p>在先序遍历中，我们先访问根节点，然后递归使用先序遍历访问左子树，再递归使用先序遍历访问右子树，即：根节点-&gt;左子树-&gt;右子树</p></li><li><p>中序遍历<em>inorder traversal</em>,</p><p>在中序遍历中，我们递归使用中序遍历访问左子树，然后访问根节点，最后再递归使用中序遍历访问右子树，即：<br>左子树-&gt;根节点-&gt;右子树</p></li><li><p>后序遍历 <em>postorder traversal</em>.</p><p>在后序遍历中，我们先递归使用后序遍历访问左子树和右子树，最后访问根节点。 即：<br>左子树-&gt;右子树-&gt;根节点</p></li></ul></blockquote><h2 id="Interpreter"><a href="#Interpreter" class="headerlink" title="Interpreter"></a>Interpreter</h2><p><strong>用代码来遍历和解释由 parser 建立的抽象语法树</strong>：</p><p>好了，让我们写一些代码来遍历和解释由 parser 建立的抽象语法树，好吗？</p><p>下面是实现了<a href="https://en.wikipedia.org/wiki/Visitor_pattern" target="_blank" rel="noopener">访问者模式</a>的源代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeVisitor</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        method_name = <span class="string">'visit_'</span> + type(node).__name__</span><br><span class="line">        visitor = getattr(self, method_name, self.generic_visit)</span><br><span class="line">        <span class="keyword">return</span> visitor(node)</span><br><span class="line"><span class="comment">#generic_visit 是一个备用函数，它会抛出一个异常来表示它遇到了一个实现类中没有相 应 #visit_NodeType 方法的结点。</span></span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">generic_visit</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'No visit_&#123;&#125; method'</span>.format(type(node).__name__))</span><br></pre></td></tr></table></figure><blockquote><p>NodeVisitor一个结点访问器的基类：它遍历抽象语法树并为找到的每个节点调用一个访问器函数。（这个函数<br>可能会返回一个由visit()方法转发 的值）。This class is meant to be subclassed, with the subclass adding visitor methods.</p><p>成员函数：</p><ul><li>1️⃣ visit(node)：访问一个结点。它默认调用self.visit_classname（其中的classname是结点类的名<br>字，或者如果这个方法不存在时，classname就是 generic_visit() ）的方法。</li><li>2️⃣ generic_visit(node)：这个访问器(visitor)对结点的所有子节点调用visit()。<br>【注意：只有这个访问器调用generic_visit() 或者访问它本身，否则自定义访问器的结点的子节点将不会被访问】</li></ul><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getattr(object, name[, default])</span><br></pre></td></tr></table></figure><p>官方文档中说这个函数作用是返回对象的一个属性，第一个参数是对象实例<code>obj</code>,<code>name</code>是个字符串，是对象的成员函数名字或者成员变量，<code>default</code>当对象没有这个属相的时候就返回默认值，如果没有提供默认值就返回异常。</p><p>如：</p><ol><li>提供不默认写法：</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Test</span>(<span class="title">object</span>):</span></span><br><span class="line">...     <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">...             print <span class="string">'I am a test'</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; test = Test()  <span class="comment"># 实例化一个对象</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; func = getattr(test, <span class="string">'func'</span>) <span class="comment"># 使用getattr函数获取func的值</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; func()</span><br><span class="line">I am a test</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; func = getattr(test, <span class="string">'f'</span>)  <span class="comment"># 使用对象没有的属性，则会出现异常</span></span><br><span class="line">Traceback (most recent call last)<span class="symbol">:</span></span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line"><span class="symbol">AttributeError:</span> <span class="string">'Test'</span> object has no attribute <span class="string">'f'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><ol><li>提供默认写法</li></ol><p>如果对象没有该属性可以提供一个默认值。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; func = getattr(test, <span class="string">'f'</span>, None)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; print func</span><br><span class="line">None</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="Interpreter-类的源代码"><a href="#Interpreter-类的源代码" class="headerlink" title="Interpreter 类的源代码"></a>Interpreter 类的源代码</h3><p>下面是 Interpreter 类的源代码，它继承自 NodeVisitor 类且实现了形式为 <code>visit_NodeType</code> 的不同方法，其中 <code>NodeType</code> 会被如 <code>BinOp</code>, <code>Num</code> 等类名替换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(NodeVisitor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parser)</span>:</span></span><br><span class="line">    self.parser = parser</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_BinOp</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> node.op.type == PLUS:</span><br><span class="line">        <span class="keyword">return</span> self.visit(node.left) + self.visit(node.right)</span><br><span class="line">    <span class="keyword">elif</span> node.op.type == MINUS:</span><br><span class="line">        <span class="keyword">return</span> self.visit(node.left) - self.visit(node.right)</span><br><span class="line">    <span class="keyword">elif</span> node.op.type == MUL:</span><br><span class="line">        <span class="keyword">return</span> self.visit(node.left) * self.visit(node.right)</span><br><span class="line">    <span class="keyword">elif</span> node.op.type == DIV:</span><br><span class="line">        <span class="keyword">return</span> self.visit(node.left) / self.visit(node.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_Num</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> node.value</span><br></pre></td></tr></table></figure><p>关于以上代码有两点值得在这里提一下：</p><blockquote><p>第一，<u>操作 AST 结点的访问器(也就是对AST数据的操作)</u>的代码 和 AST 结点(即，AST的数据结构)本身 分离（解耦了）。</p><ul><li>可以看到 AST 结点类(BinOp 和 Num)没有提供任何代码来操作存储在这些结点中的数据，该逻辑被封装在了实现 <code>NodeVisitor</code> 的 <code>Interpreter</code> 类中。（也就是对数据的操作在<code>NodeVisitor</code> 的 <code>Interpreter</code> 类中）。</li></ul><p>第二，在NodeVisitor的访问函数中，不像这样使用一个巨大的if语句:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit</span><span class="params">(node)</span>:</span></span><br><span class="line">    node_type = type(node).__name__</span><br><span class="line">    <span class="keyword">if</span> node_type == <span class="string">'BinOp'</span>:</span><br><span class="line">        <span class="keyword">return</span> self.visit_BinOp(node)</span><br><span class="line">    <span class="keyword">elif</span> node_type == <span class="string">'Num'</span>:</span><br><span class="line">        <span class="keyword">return</span> self.visit_Num(node)</span><br><span class="line">    <span class="keyword">elif</span> ...</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"><span class="comment">#####或者##########</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit</span><span class="params">(node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(node, BinOp):</span><br><span class="line">        <span class="keyword">return</span> self.visit_BinOp(node)</span><br><span class="line">    <span class="keyword">elif</span> isinstance(node, Num):</span><br><span class="line">        <span class="keyword">return</span> self.visit_Num(node)</span><br><span class="line">    <span class="keyword">elif</span> ...</span><br></pre></td></tr></table></figure><p>NodeVisitor 的 visit 方法非常通用，能根据传入的结点类型来调度适当的方法。正如前面提到的，为了利用这一点，我们的解释器继承了 NodeVisitor 类并实现了必要的方法。 因此：</p><ul><li>如果传递给 <code>visit</code> 函数的结点是 <code>BinOp</code>，那么<code>visit</code> 函数就会调用 <code>visit_BinOp</code> 方法。</li><li>如果传递给 <code>visit</code>函数的结点是 <code>Num</code>,那么 <code>visit</code> 函数就会调用<code>visit_Num</code> 方 法，等等。</li></ul></blockquote><p>花此时间研究一下这个方法（Python 的标准模块 <a href="https://docs.python.org/2.7/library/ast.html#module-ast" target="_blank" rel="noopener">ast</a> 也使用了相同的机制来遍历结点）， 因为我们将来会用很多新的 <code>visit_NodeType</code> 方法来扩展我们的解释器。</p><p>现在，让我们手工为表达式 2 * 7 + 3 建立一个 AST 并把它传递给解释器，通过对该表达式求值看看运行中的 visit 方法。下面是你从 Python shell 中尝试的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> spi <span class="keyword">import</span> Token, MUL, PLUS, INTEGER, Num, BinOp</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mul_token = Token(MUL, <span class="string">'*'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plus_token = Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mul_node = BinOp(</span><br><span class="line"><span class="meta">... </span>    left=Num(Token(INTEGER, <span class="number">2</span>)),</span><br><span class="line"><span class="meta">... </span>    op=mul_token,</span><br><span class="line"><span class="meta">... </span>    right=Num(Token(INTEGER, <span class="number">7</span>))</span><br><span class="line"><span class="meta">... </span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_node = BinOp(</span><br><span class="line"><span class="meta">... </span>    left=mul_node,</span><br><span class="line"><span class="meta">... </span>    op=plus_token,</span><br><span class="line"><span class="meta">... </span>    right=Num(Token(INTEGER, <span class="number">3</span>))</span><br><span class="line"><span class="meta">... </span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> spi <span class="keyword">import</span> Interpreter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inter = Interpreter(<span class="literal">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inter.visit(add_node)</span><br><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure><p>如你所见，我把表达式树的根结点传递给了 <code>visit</code> 方法，这一行为触发了树的遍历，遍历调用了 <code>Interpreter</code> 类正确的方法(<code>visit_BinOp</code> 和 <code>visit_Num</code>)并生成了结果。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""" SPI - Simple Pascal Interpreter """</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, PLUS, MINUS, MUL, DIV, LPAREN, RPAREN, EOF = (</span><br><span class="line">    <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'MINUS'</span>, <span class="string">'MUL'</span>, <span class="string">'DIV'</span>, <span class="string">'('</span>, <span class="string">')'</span>, <span class="string">'EOF'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        self.type = type</span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""String representation of the class instance.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">            Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">            Token(PLUS, '+')</span></span><br><span class="line"><span class="string">            Token(MUL, '*')</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Token(&#123;type&#125;, &#123;value&#125;)'</span>.format(</span><br><span class="line">            type=self.type,</span><br><span class="line">            value=repr(self.value)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"></span><br><span class="line"><span class="comment">###############################################################################</span></span><br><span class="line"><span class="comment">#                                                                             #</span></span><br><span class="line"><span class="comment">#  LEXER                                                                      #</span></span><br><span class="line"><span class="comment">#                                                                             #</span></span><br><span class="line"><span class="comment">###############################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lexer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="comment"># client string input, e.g. "4 + 2 * 3 - 6 / 2"</span></span><br><span class="line">        self.text = text</span><br><span class="line">        <span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        self.current_char = self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid character'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Advance the `pos` pointer and set the `current_char` variable."""</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt; len(self.text) - <span class="number">1</span>:</span><br><span class="line">            self.current_char = <span class="literal">None</span>  <span class="comment"># Indicates end of input</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_char = self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">            self.advance()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return a (multidigit) integer consumed from the input."""</span></span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">            result += self.current_char</span><br><span class="line">            self.advance()</span><br><span class="line">        <span class="keyword">return</span> int(result)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">        apart into tokens. One token at a time.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">                self.skip_whitespace()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isdigit():</span><br><span class="line">                <span class="keyword">return</span> Token(INTEGER, self.integer())</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'+'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'-'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'*'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MUL, <span class="string">'*'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'/'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(DIV, <span class="string">'/'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'('</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(LPAREN, <span class="string">'('</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">')'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(RPAREN, <span class="string">')'</span>)</span><br><span class="line"></span><br><span class="line">            self.error()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">###############################################################################</span></span><br><span class="line"><span class="comment">#                                                                             #</span></span><br><span class="line"><span class="comment">#  PARSER                                                                     #</span></span><br><span class="line"><span class="comment">#                                                                             #</span></span><br><span class="line"><span class="comment">###############################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AST</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span>   <span class="comment"># 表示定义留空</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinOp</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, left, op, right)</span>:</span></span><br><span class="line">        self.left = left</span><br><span class="line">        self.token = self.op = op</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Num</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, token)</span>:</span></span><br><span class="line">        self.token = token</span><br><span class="line">        self.value = token.value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lexer)</span>:</span></span><br><span class="line">        self.lexer = lexer</span><br><span class="line">        <span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">        self.current_token = self.lexer.get_next_token()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid syntax'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">        <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">        <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">        <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.lexer.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""factor : INTEGER | LPAREN expr RPAREN"""</span></span><br><span class="line">        token = self.current_token</span><br><span class="line">        <span class="keyword">if</span> token.type == INTEGER:</span><br><span class="line">            self.eat(INTEGER)</span><br><span class="line">            <span class="keyword">return</span> Num(token)</span><br><span class="line">        <span class="keyword">elif</span> token.type == LPAREN:</span><br><span class="line">            self.eat(LPAREN)</span><br><span class="line">            node = self.expr()</span><br><span class="line">            self.eat(RPAREN)</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""term : factor ((MUL | DIV) factor)*"""</span></span><br><span class="line">        node = self.factor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == MUL:</span><br><span class="line">                self.eat(MUL)</span><br><span class="line">            <span class="keyword">elif</span> token.type == DIV:</span><br><span class="line">                self.eat(DIV)</span><br><span class="line"></span><br><span class="line">            node = BinOp(left=node, op=token, right=self.factor())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        expr   : term ((PLUS | MINUS) term)*</span></span><br><span class="line"><span class="string">        term   : factor ((MUL | DIV) factor)*</span></span><br><span class="line"><span class="string">        factor : INTEGER | LPAREN expr RPAREN</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        node = self.term()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (PLUS, MINUS):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">                self.eat(PLUS)</span><br><span class="line">            <span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">                self.eat(MINUS)</span><br><span class="line"></span><br><span class="line">            node = BinOp(left=node, op=token, right=self.term())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.expr()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">###############################################################################</span></span><br><span class="line"><span class="comment">#                                                                             #</span></span><br><span class="line"><span class="comment">#  INTERPRETER                                                                #</span></span><br><span class="line"><span class="comment">#                                                                             #</span></span><br><span class="line"><span class="comment">###############################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeVisitor</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        method_name = <span class="string">'visit_'</span> + type(node).__name__</span><br><span class="line">        visitor = getattr(self, method_name, self.generic_visit)</span><br><span class="line">        <span class="keyword">return</span> visitor(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generic_visit</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'No visit_&#123;&#125; method'</span>.format(type(node).__name__))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(NodeVisitor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parser)</span>:</span></span><br><span class="line">        self.parser = parser</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_BinOp</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node.op.type == PLUS:</span><br><span class="line">            <span class="keyword">return</span> self.visit(node.left) + self.visit(node.right)</span><br><span class="line">        <span class="keyword">elif</span> node.op.type == MINUS:</span><br><span class="line">            <span class="keyword">return</span> self.visit(node.left) - self.visit(node.right)</span><br><span class="line">        <span class="keyword">elif</span> node.op.type == MUL:</span><br><span class="line">            <span class="keyword">return</span> self.visit(node.left) * self.visit(node.right)</span><br><span class="line">        <span class="keyword">elif</span> node.op.type == DIV:</span><br><span class="line">            <span class="keyword">return</span> self.visit(node.left) / self.visit(node.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_Num</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">interpret</span><span class="params">(self)</span>:</span></span><br><span class="line">        tree = self.parser.parse()</span><br><span class="line">        <span class="keyword">return</span> self.visit(tree)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                text = raw_input(<span class="string">'spi&gt; '</span>)</span><br><span class="line">            <span class="keyword">except</span> NameError:  <span class="comment"># Python3</span></span><br><span class="line">                text = input(<span class="string">'spi&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        lexer = Lexer(text)</span><br><span class="line">        parser = Parser(lexer)</span><br><span class="line">        interpreter = Interpreter(parser)</span><br><span class="line">        result = interpreter.interpret()</span><br><span class="line">        print(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>将以上代码保存到名为 <code>spi.py</code> 的文件中，或者直接从 <a href="https://github.com/rspivak/lsbasi/blob/master/part7/python/spi.py" target="_blank" rel="noopener">GitHub</a> 下载。自己试一试，确认 你的新的基于树的解释器可以正确地对算术表达式进行求值。</p><p>下面是某次运行过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python spi.py</span><br><span class="line">spi&gt; <span class="number">7</span> + <span class="number">3</span> * (<span class="number">10</span> / (<span class="number">12</span> / (<span class="number">3</span> + <span class="number">1</span>) - <span class="number">1</span>))</span><br><span class="line"><span class="number">22</span></span><br><span class="line">spi&gt; <span class="number">7</span> + <span class="number">3</span> * (<span class="number">10</span> / (<span class="number">12</span> / (<span class="number">3</span> + <span class="number">1</span>) - <span class="number">1</span>)) / (<span class="number">2</span> + <span class="number">3</span>) - <span class="number">5</span> - <span class="number">3</span> + (<span class="number">8</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line">spi&gt; <span class="number">7</span> + (((<span class="number">3</span> + <span class="number">2</span>)))</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天你学习了关于解析树和 AST，如何构建 AST 以及遍历表示输入的 AST 并解释执行。你还修改了 parser 和 interpreter 并将这两部分解开了。现在 lexer, parser 和 interpreter 之间的接口看起来像这样：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_pipeline.png" alt="lsbasi_part7_pipeline"></p><p><strong>lsbasi_part7_pipeline</strong></p><p>你可以把它读作“parser 从 lexer 中 得到 token 然后返回生成的 AST 给 Interpreter 进行遍历并解释执行所给输入”。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>这就是今天的所有内容，但在总结之前我还想简单地聊一聊递归下降 (recursive-descent) parser，即是仅仅给出它的定义。</p><blockquote><p>定义就是：一个 <strong>递归下降parser</strong> 就 是一个自顶向下的 parser，它使用一组递归过程来处理输入。自顶向下反映了 parser 从 构建解析树的顶部结点开始逐渐构建更低的结点这一事实。</p></blockquote><h2 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h2><p>本节与part5相比主要添加了AST：</p><ol><li><code>Lexer</code>与part5中的是一样的，还是将输入的text分析转换为token。(这也是词法分析器的功能)</li><li><code>Parser</code>相比part5，<ul><li>它添加了构造AST的内容：添加了三个类：<ul><li><code>AST()</code>：是一个基类</li><li><code>BinOp(AST)</code>：继承于<code>AST()</code>，主要功能是实现<strong>二元操作符<em>binary operator</em></strong> 。（这里只有四种：加、减、乘、除法）</li><li><code>Num(AST)</code>：继承于<code>AST()</code>，它主要是表示AST中的整数integer token（它将保存一个 <code>INTEGER</code> token 和该 token 的值）</li></ul></li><li>第二个变化就是实现语法解析的这三个函数<code>term</code>、<code>factor</code>、<code>expr</code>中的返回的不在是result变量了，而是返回一个结点node。</li></ul></li><li><code>Interpreter</code>：通过词法分析、语法分析之后，开始解释语法分析之后的算式，计算出它的结果，用<code>Interpreter</code>来解释：<ul><li>增添了<strong>访问者模式</strong>：将 对数据的操作(对数据的操作在interpreter中完成：访问、解释) 和 数据结构(数据结构 在parser中的三个类中构建) 进行分离（解耦合）。使得操作集合可相对自由地演化。<ul><li>这里通过创建 <code>NodeVisitor()</code>类 实现访问者模式。实现了通过什么方式去<strong>访问</strong>生成的AST</li><li>又通过<code>Interpreter</code>（继承于 <code>NodeVisitor()</code>类）来实现<strong>解释</strong>生成的AST</li></ul></li></ul></li></ol><p>最后，再次提醒一下：之前的那几小结，我们都是把interpreter的代码和parser的代码混在一起，但这一小节我们把interpreter的代码和parser的代码<strong>分开了</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Let&#39;s Build A Simple Interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let’s Build A Simple Interpreter 6</title>
      <link href="/archives/167c.html"/>
      <url>/archives/167c.html</url>
      
        <content type="html"><![CDATA[<p>新增了<strong>括号运算(parenthesized expressions)</strong></p><a id="more"></a><p>原文链接：<a href="https://ruslanspivak.com/lsbasi-part6/" target="_blank" rel="noopener">https://ruslanspivak.com/lsbasi-part6/</a></p><p>本文在前面的基础上，新增了<strong>括号运算(parenthesized expressions)</strong>，如： 7 + 3 * (10 / (12 / (3 + 1) - 1))</p><p>所以需要在part5中的语法基础上，进行修改，修改后的语法如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part6_grammar.png" alt="lsbasi_part6_grammar"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part5_grammar.png" alt="lsbasi_part5_grammar"></p><p>从上面的图可以看出来,在part6中，<code>expr</code>和<code>term</code>和part5中一样，<u>唯一变的是<code>factor</code>的<strong>产生式 (production)</strong>。</u></p><blockquote><p>它新添加了两个 terminal ：</p><ul><li>LPAREN：表示一个左括号 left parenthesis ‘( ‘</li><li>RPAREN：表示一个右括号 right parenthesis ‘)’</li></ul><p>还新添加了一个非终端符：<code>expr</code></p><ul><li><code>expr</code>添加在两个括号之间</li></ul></blockquote><p>下面是<code>factor</code>的语法图：（这里用到了<u>递归</u>）</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part6_factor_diagram.png" alt="lsbasi_part6_factor_diagram"></p><p>然后，再放一下没有改变的（与part5相同）<code>expr</code>、<code>term</code>的语法图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part6_expr_term_diagram.png" alt="img"></p><p>现在看一下算式：2 * (7 + 3) 的分解过程吧：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part6_decomposition.png" alt="img"></p><p>现在把语法转换成代码。</p><p>下面这两条是代码中主要改变的部分：</p><blockquote><ol><li><code>Lexer</code>被修改，使其在原来的基础上可以返回另外两个token：左括号LPAREN 、右括号RPAREN</li><li><code>Interpreter</code>类的<code>factor</code>被修改，修改之后不仅可以解析整数integer，还可以解析括号表达式(parenthesized expressions)</li></ol></blockquote><p>下面就是本小节的代码部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, PLUS, MINUS, MUL, DIV, LPAREN, RPAREN, EOF = (</span><br><span class="line">    <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'MINUS'</span>, <span class="string">'MUL'</span>, <span class="string">'DIV'</span>, <span class="string">'('</span>, <span class="string">')'</span>, <span class="string">'EOF'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        self.type = type</span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""String representation of the class instance.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">            Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">            Token(PLUS, '+')</span></span><br><span class="line"><span class="string">            Token(MUL, '*')</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Token(&#123;type&#125;, &#123;value&#125;)'</span>.format(</span><br><span class="line">            type=self.type,</span><br><span class="line">            value=repr(self.value)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lexer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="comment"># client string input, e.g. "4 + 2 * 3 - 6 / 2"</span></span><br><span class="line">        self.text = text</span><br><span class="line">        <span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        self.current_char = self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid character'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Advance the `pos` pointer and set the `current_char` variable."""</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt; len(self.text) - <span class="number">1</span>:</span><br><span class="line">            self.current_char = <span class="literal">None</span>  <span class="comment"># Indicates end of input</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_char = self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">            self.advance()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return a (multidigit) integer consumed from the input."""</span></span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">            result += self.current_char</span><br><span class="line">            self.advance()</span><br><span class="line">        <span class="keyword">return</span> int(result)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">        apart into tokens. One token at a time.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">                self.skip_whitespace()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isdigit():</span><br><span class="line">                <span class="keyword">return</span> Token(INTEGER, self.integer())</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'+'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'-'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'*'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MUL, <span class="string">'*'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'/'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(DIV, <span class="string">'/'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'('</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(LPAREN, <span class="string">'('</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">')'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(RPAREN, <span class="string">')'</span>)</span><br><span class="line"></span><br><span class="line">            self.error()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lexer)</span>:</span></span><br><span class="line">        self.lexer = lexer</span><br><span class="line">        <span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">        self.current_token = self.lexer.get_next_token()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid syntax'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">        <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">        <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">        <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.lexer.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""factor : INTEGER | LPAREN expr RPAREN"""</span></span><br><span class="line">        token = self.current_token</span><br><span class="line">        <span class="keyword">if</span> token.type == INTEGER:</span><br><span class="line">            self.eat(INTEGER)</span><br><span class="line">            <span class="keyword">return</span> token.value</span><br><span class="line">        <span class="keyword">elif</span> token.type == LPAREN:</span><br><span class="line">            self.eat(LPAREN)</span><br><span class="line">            result = self.expr()</span><br><span class="line">            self.eat(RPAREN)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""term : factor ((MUL | DIV) factor)*"""</span></span><br><span class="line">        result = self.factor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == MUL:</span><br><span class="line">                self.eat(MUL)</span><br><span class="line">                result = result * self.factor()</span><br><span class="line">            <span class="keyword">elif</span> token.type == DIV:</span><br><span class="line">                self.eat(DIV)</span><br><span class="line">                result = result / self.factor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Arithmetic expression parser / interpreter.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        calc&gt; 7 + 3 * (10 / (12 / (3 + 1) - 1))</span></span><br><span class="line"><span class="string">        22</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        expr   : term ((PLUS | MINUS) term)*</span></span><br><span class="line"><span class="string">        term   : factor ((MUL | DIV) factor)*</span></span><br><span class="line"><span class="string">        factor : INTEGER | LPAREN expr RPAREN</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = self.term()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (PLUS, MINUS):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">                self.eat(PLUS)</span><br><span class="line">                result = result + self.term()</span><br><span class="line">            <span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">                self.eat(MINUS)</span><br><span class="line">                result = result - self.term()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># To run under Python3 replace 'raw_input' call</span></span><br><span class="line">            <span class="comment"># with 'input'</span></span><br><span class="line">            text = raw_input(<span class="string">'calc&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        lexer = Lexer(text)</span><br><span class="line">        interpreter = Interpreter(lexer)</span><br><span class="line">        result = interpreter.expr()</span><br><span class="line">        print(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Let&#39;s Build A Simple Interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let’s Build A Simple Interpreter 5</title>
      <link href="/archives/173c.html"/>
      <url>/archives/173c.html</url>
      
        <content type="html"><![CDATA[<p>本文为这一系列的part5，第五小节。这次将写一个可移植性加减乘除混合运算的解释器。</p><a id="more"></a><p>原文链接：<a href="https://ruslanspivak.com/lsbasi-part5/" target="_blank" rel="noopener">https://ruslanspivak.com/lsbasi-part5/</a></p><p>本文为这一系列的part5，第五小节。这次将写一个可移植性加减乘除混合运算的解释器。</p><p>在开始写代码之前，我们需要知道一些，比如：<strong>结合律</strong>、操作符(operator)的<strong>优先级(precedence)</strong></p><h2 id="结合律-associativity"><a href="#结合律-associativity" class="headerlink" title="结合律(associativity)"></a>结合律(associativity)</h2><p>比如，7+3+1等同于(7+3)+1 ，7 - 3 - 1 等同于 (7 - 3) - 1。这没有什么奇怪的。但是再比如： 7 - 3 - 1 与 7 - (3 - 1) 的结果就不一样了。</p><p>其实：加、减、乘、除 这些操作符(operator)是<strong>左结合(left-associative)</strong>。</p><ul><li>比如， 7 + 3 + 1 中的 <strong>操作数(operand)</strong> 3，它的左右都是 加号 ，但是这个操作数3是与它左边的加号“+”结合的， 所以加法是左结合。</li><li>那加减乘除混合时，如 7 + 5 * 2 是否还是遵循左结合律呢？很显然，不遵循，因为 (7 + 5) * 2 不等于 7 + 5 * 2 。</li></ul><p>由此可知：</p><p>​ <u>加法</u>和<u>减法</u>是一类，所以它们在一起组成的运算是左结合；<u>乘法</u>和<u>除法</u>是一类，所以他们在一起组成的运算是左结合。（即，左结合律只适用于同一类的操作符(operator)）</p><h2 id="优先级-precedence"><a href="#优先级-precedence" class="headerlink" title="优先级(precedence)"></a>优先级(precedence)</h2><p>那我们如何规定这种加减乘除（这两类操作符(operator)）同时出现时的运算规则呢？（实际上我们都知道，但是这里是为实现代码来做出一种运算规则）</p><p>在 7 + 5 * 2中，如果<u>操作符“<em>”</em></u>能先比<u>操作符“+”</u>到他的<u>操作数5</u>，就说，操作符“”有<strong>更高的优先级(higher precedence)</strong>。</p><p>在实际中我们也在用，也知道。乘除的优先级要高于加减法。</p><p>好了，现在我们开始用表格来表示操作符的结合律与优先级：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part5_precedence.png" alt="随着箭头方向优先级升高"></p><p>由上表可知：+ and - 是优先级相同，都是左结合；* and / 优先级相同，也都是左结合；</p><p>我们还可以根据上面的优先级表格来制定一个语法规则：</p><ol><li>优先级相同的每一级都定义一个非终端符(non-terminal)。其中每个<strong>产生式(production)</strong>的body中应该包含:算数运算符(arithmetic operators) &amp; 非终端符(这里的非终端又参与构成下一较高的优先级的规则(产生式)的一部分)</li><li>创建一个表示 基本表达式的非终端符<code>factor</code>，本文中指integer。一般的规则是：如果你有N个优先级，那么你就需要N+1个非终端符（一类是每一层优先级的一个非终端符，一类是表示基本表达式单元）</li></ol><h2 id="构建语法-grammars"><a href="#构建语法-grammars" class="headerlink" title="构建语法(grammars)"></a>构建语法(grammars)</h2><p>现在根据上面的规则来构建语法：</p><p>由规则1，我们将定义两个非终结符(non-terminal)，一个是leve1的non-terminal叫做<code>expr</code>，另一个是level2的non-terminal叫做term。然后根据规则2，我们需要定义一个叫做<code>factor</code>的non-terminal来作为一个基本的表达式单元，integers。</p><p>这个语法的<strong>开始符号（<em>start symbol</em> ）</strong>叫做<code>expr</code>。它的产生式(production)的body含有：</p><ul><li><p>1️⃣表示level2的操作符(在这指的是+ and - )，</p></li><li><p>2️⃣和一个非终端符<code>term</code>(这个term是下一层优先级（更高的）level1 的一个产生式)</p></li></ul><blockquote><p><strong>开始符号（S）</strong>：最大的语法单位 或 最重要的语法单位。（如上面的那个英文句子中的，最大的语法单位是：句子。）</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part5_cfg_expr.png" alt="start symbol（开始符）:expr"></p><p>非终端符<code>term</code>的production(产生式)的body包含:</p><ul><li><p>1️⃣表示level1的操作符(在这指的是 * and /)。</p></li><li><p>2️⃣还有一个非终端符<code>factor</code>来表示基本的表达式单元，integers</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part5_cfg_term.png" alt="term"></p></li></ul><p>非终端符<code>factor</code>包含：</p><ul><li><p>1️⃣一个integer</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part5_cfg_factor.png" alt="factor"></p></li></ul><p>上面的三幅图是语法、语法图的一部分，这在之前的文章中也出现过。但现在需要将上面的三幅图结合在一起来考虑结合律和优先级（ associativity and precedence ）</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part5_grammar.png" alt="img"></p><p>下面是本文的语法对应的语法图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-5/20200318213222.png" alt="grammar"></p><p>上面语法图的每一个小方框都是其他语法图的：函数调用（“method call”）。</p><blockquote><p>如果你以表达式 7 + 5 * 2 为例并从顶 层图 <code>expr</code> 开始逐步分解到最底层的图 <code>factor</code>, 你应该可以看到位于中间的图的高优 先级操作符*和/会比上面的图的操作符+和-先执行。</p></blockquote><p>为了解释清楚运算符的优先级，让我们看看使用上面语法和句法图来分解相同算术表达式 7 + 5 * 2 的过程。这只是另一种展示高优先级运算符 先于 低优先级运算符执行这个事实的 方式。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-5/lsbasi_part5_exprdecomp-1584538315811.png" alt="img"></p><h3 id="语法转换成代码"><a href="#语法转换成代码" class="headerlink" title="语法转换成代码"></a>语法转换成代码</h3><p>让我们使用<a href="http://ruslanspivak.com/lsbasi-part4/" target="_blank" rel="noopener">part 4</a>中的准则把该语法转化成代码，看看它怎么工作，先看一张上面放过的语法图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part5_grammar-1583931621458.png" alt="语法图"></p><p>下面是能处理可以包含任意数量加减乘除操作符的算术表达式的计算器的完整代码。</p><blockquote><p>相比于<a href="http://ruslanspivak.com/lsbasi-part4/" target="_blank" rel="noopener">part 4</a>代码的主要变化有：</p><ul><li><code>Lexer</code> 类现在可以把+,-,*和/都 token 化了（没什么新方法，我们只是把前面文章中 的代码合并到一个类中来支持所有这些 token）</li><li>回想语法中的每条规则（产生式）R都要变成一个同名的方法，且对该规则的引用都要变 成一个方法调用 <code>R()</code> 这一点。现在 <code>Interpreter</code> 类有了三个方法来对应语法中的非 终结符： <code>expr</code>, <code>term</code>, <code>factor</code>.</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, PLUS, MINUS, MUL, DIV, EOF = (</span><br><span class="line">    <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'MINUS'</span>, <span class="string">'MUL'</span>, <span class="string">'DIV'</span>, <span class="string">'EOF'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        <span class="comment"># token type: INTEGER, PLUS, MINUS, MUL, DIV, or EOF</span></span><br><span class="line">        self.type = type</span><br><span class="line">        <span class="comment"># token value: non-negative integer value, '+', '-', '*', '/', or None</span></span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""String representation of the class instance.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">            Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">            Token(PLUS, '+')</span></span><br><span class="line"><span class="string">            Token(MUL, '*')</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Token(&#123;type&#125;, &#123;value&#125;)'</span>.format(</span><br><span class="line">            type=self.type,</span><br><span class="line">            value=repr(self.value)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lexer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="comment"># client string input, e.g. "3 * 5", "12 / 3 * 4", etc</span></span><br><span class="line">        self.text = text</span><br><span class="line">        <span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        self.current_char = self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid character'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Advance the `pos` pointer and set the `current_char` variable."""</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt; len(self.text) - <span class="number">1</span>:</span><br><span class="line">            self.current_char = <span class="literal">None</span>  <span class="comment"># Indicates end of input</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_char = self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">            self.advance()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return a (multidigit) integer consumed from the input."""</span></span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">            result += self.current_char</span><br><span class="line">            self.advance()</span><br><span class="line">        <span class="keyword">return</span> int(result)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">        apart into tokens. One token at a time.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">                self.skip_whitespace()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isdigit():</span><br><span class="line">                <span class="keyword">return</span> Token(INTEGER, self.integer())</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'+'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'-'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'*'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MUL, <span class="string">'*'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'/'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(DIV, <span class="string">'/'</span>)</span><br><span class="line"></span><br><span class="line">            self.error()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lexer)</span>:</span></span><br><span class="line">        self.lexer = lexer</span><br><span class="line">        <span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">        self.current_token = self.lexer.get_next_token()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid syntax'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">        <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">        <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">        <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.lexer.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""factor : INTEGER"""</span></span><br><span class="line">        token = self.current_token</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        <span class="keyword">return</span> token.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""term : factor ((MUL | DIV) factor)*"""</span></span><br><span class="line">        result = self.factor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == MUL:</span><br><span class="line">                self.eat(MUL)</span><br><span class="line">                result = result * self.factor()</span><br><span class="line">            <span class="keyword">elif</span> token.type == DIV:</span><br><span class="line">                self.eat(DIV)</span><br><span class="line">                result = result / self.factor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Arithmetic expression parser / interpreter.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        calc&gt;  14 + 2 * 3 - 6 / 2</span></span><br><span class="line"><span class="string">        17</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        expr   : term ((PLUS | MINUS) term)*</span></span><br><span class="line"><span class="string">        term   : factor ((MUL | DIV) factor)*</span></span><br><span class="line"><span class="string">        factor : INTEGER</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = self.term()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (PLUS, MINUS):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">                self.eat(PLUS)</span><br><span class="line">                result = result + self.term()</span><br><span class="line">            <span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">                self.eat(MINUS)</span><br><span class="line">                result = result - self.term()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># To run under Python3 replace 'raw_input' call</span></span><br><span class="line">            <span class="comment"># with 'input'</span></span><br><span class="line">            text = raw_input(<span class="string">'calc&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        lexer = Lexer(text)</span><br><span class="line">        interpreter = Interpreter(lexer)</span><br><span class="line">        result = interpreter.expr()</span><br><span class="line">        print(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>将以上代码保存到名为 <code>calc5.py</code> 中，或者直接从 <a href="https://github.com/rspivak/lsbasi/blob/master/part5/calc5.py" target="_blank" rel="noopener">GitHub</a> 上下载。和以往一样，自己尝 试一下，确认解释器可以对包含不同优先级操作符的算术表达式进行求值。</p><h2 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h2><p>代码中有三个类(class)，他们中的函数及作用：</p><ol><li><p><code>Token</code>：</p><ul><li><p><code>__init__</code>：初始化实例</p></li><li><p><code>__str__</code>：字符串形式</p></li><li><p><code>__repr__</code>：字符串形式</p><blockquote><p>在Python中，所有以“_<em>”双下划线包起来的方法，都统称为“Magic Method”（魔术方法）,例如类的初始化方法 __init_</em></p><table><thead><tr><th><strong><strong>repr</strong>(self)</strong></th><th>定义当被 repr() 调用时的行为</th></tr></thead><tbody><tr><td><strong><strong>str</strong>(self)</strong></td><td>定义当被 str() 调用时的行为</td></tr></tbody></table></blockquote></li></ul></li><li><p><code>Lexer</code>用于词法分析：</p><ul><li><code>__init__</code>：初始化实例</li><li><code>error</code>：错误提示</li><li><code>advance</code>：使pos前进一个位置</li><li><code>skip_whitespace</code>：略过空格</li><li><code>integer</code>：识别整数（可以识别多位数）</li><li><code>get_next_token</code>：获得一个token（其实我觉得叫做：<code>get_token_and_to_next</code>更合适）</li></ul></li><li><p><code>Interpreter</code>用于语法分析：</p><ul><li><code>__init__</code>：初始化实例</li><li><code>error</code>：错误提示</li><li><code>eat</code>：负责检测当前的token.type与传入的token_type是否相同。若相同，则将当前的token“吃了”，然后把当前token的下一个token分配给current_token。</li><li>下面就是语法分析的核心了，由上面的分析直到，它由：<code>expr</code>、<code>term</code>、<code>factor</code>构成。</li></ul></li></ol><p>梳理完毕。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Let&#39;s Build A Simple Interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let’s Build A Simple Interpreter 4</title>
      <link href="/archives/3b16.html"/>
      <url>/archives/3b16.html</url>
      
        <content type="html"><![CDATA[<p>听而易忘，见而易忘，做而易懂</p><a id="more"></a><p>原文链接：<a href="https://ruslanspivak.com/lsbasi-part4/" target="_blank" rel="noopener">https://ruslanspivak.com/lsbasi-part4/</a></p><p>在前面的文章中你学会了怎样识别和解释包含任意数量的加减操作的算术表达式，例如“7 - 3 + 2 - 1”。还学会了句法图以及它们如何被用来表示一门编程语言的语法。</p><p>今天你将会学习解析(parse)和解释(interpret)包含任意乘除操作的算术表达式，例如“7 * 4 / 2 * 3”。在这篇文章中使用的是整数除法，所以对于表达式“9 / 4”来说，结果是一个 整数：2。</p><p>我今天会讲很多另一个表示编程语言句法的广泛使用的表示法，叫 <strong>上下文无关语法</strong> (context-free grammars, 简记为 grammars)或 <strong>BNF</strong> (Backus-Naur Form)。为了这篇文章的目的，我不会使用纯 <a href="https://en.wikipedia.org/wiki/Backus–Naur_Form" target="_blank" rel="noopener">BNF</a> 记法，而更像是一个修改过的 <a href="https://en.wikipedia.org/wiki/Extended_Backus–Naur_Form" target="_blank" rel="noopener">EBNF</a> 记法。</p><p>以下是一些使用语法的原因：</p><ol><li>语法使用了一种简明的方式来描述一门编程语言的句法。不像语法图，语法非常紧凑。 在以后的文章中，你会看到我越来越多地使用语法。</li><li>语法可以做为文档保存。</li><li>即使对从头开始写解析器(parser)来说，语法也是一个好的入手点。很多时候通过遵循 一套简单的规则你就可以把语法转化成代码。</li><li>有一套工具，叫解析器生成器(parser generator)，可以把语法做为输入并自动根据它为你生成一个解析器。我会以后在这个系列中谈到这些工具。</li></ol><h2 id="语法机制"><a href="#语法机制" class="headerlink" title="语法机制"></a>语法机制</h2><p>现在，我们来聊聊语法的机制方面：</p><p>下面的语法描述了算术表达式，像“7 * 4 / 2 * 3”这样的（这只是该语法可以生成的许多表达式<strong>之一</strong>）：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200310202232.png" alt="BNF-1"></p><p>语法是由一系列规则组成的，也被称为<strong>产生式(production)</strong>。我们的语法中有两条规则(产生式)：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200310202500.png" alt=""></p><ul><li><p>1、一条规则由一个非终结符(叫做 <strong>head</strong>或生成式的<strong>左</strong>边) <strong>+</strong> 一个分号（:）<strong>+</strong> <u>一系列终结符 和/或 非终结符</u>(叫做 <strong>body</strong> 或 <strong>右边</strong>)：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200310204653.png" alt=""></p></li><li><p>2、在上面展示的语法中，像 MUL, DIV, 或 INTEGER 这样的 token 被称为 <strong>终结符(terminals)</strong>, <code>expr</code> <code>factor</code> 这样的变量被称为 <strong>非终结符(not-terminals)</strong>.</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200310204953.png" alt=""></p></li></ul><p>第一条规则左边的非终结符被叫做 <strong>开始符号(start symbol)</strong>. 在我们的语法中，开始符号是 <em>expr</em>:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200310205155.png" alt=""></p><p>你可以这么理解 <code>expr</code> 这条规则：“expr 是一个 factor 后面可选地跟一个乘或除运算符再跟 另一个 factor，后面也相应可选地跟一个乘或除运算符再跟另一个 factor，如此重复”。</p><p>factor 是什么？对于本文来说 factor 就是一个整数。</p><h3 id="语法中的符号"><a href="#语法中的符号" class="headerlink" title="语法中的符号"></a>语法中的符号</h3><p>让我们快速地过一遍语法中的符号及它们的意义。</p><ul><li><p><code>|</code>多选一。竖线表示“或”。所以 <code>(MUL | DIV)</code> 表示 MUL 或 DIV</p></li><li><p><code>(...)</code>被括号包围表示把终结符 和/或 非终结符组成一组，就像 <code>(MUL | DIV)</code></p></li><li><p><code>(...)*</code>分组中的内容被匹配 0 或 多次。</p></li></ul><p>语法通过解释可以组成什么样的句子来定义一门语言。通过语法派生出算术表达式的方式为：首先从开始符号 <code>expr</code> 开始，然后反复地使用所包含的非终结符的规则替换该非终结符， 直到生成一个<u>只包含终结符的</u>句子。语法能组成的句子构成了一门语言。</p><p>下面举例说明：</p><ul><li><p>例1，下面是语法如何派生出表达式 <code>3</code>:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200310210521.png" alt=""></p></li><li><p>例2，下面是语法如何派生出表达式 <code>3 * 7</code>:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200310210557.png" alt=""></p></li><li><p>例3，下面是语法如何派生出表达式 <code>3 * 7 / 2</code>:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part4_derive3.png" alt="img"></p></li></ul><h2 id="将语法变成代码"><a href="#将语法变成代码" class="headerlink" title="将语法变成代码"></a>将语法变成代码</h2><p>下面是一些我们在把语法转化成源代码时会用到的==四个准则==。按照这些准则，你真的就可以把语法翻译成一个可工作的 parser:</p><ol><li>对于语法中定义的每个规则 R，将它做成一个有相同名字的方法，对该规则的引用就变成了一个方法调用：R()。该方法的方法体遵循该规则的步骤，过程中使用相同的准则。</li><li>多选一 <code>(a1|a2|aN)</code> 变成 <strong>if-elif-else</strong> 语句</li><li>可选组 <code>(...)*</code> 变成一个可以执行 0 或多次的 <strong>while</strong> 循环（can loop over zero or more times）</li><li>每个 Token 记为 T 变成一个 <code>eat</code> 方法调用: <code>eat(T)</code>. <code>eat</code> 方法的工作是 当它匹配到当前的<code>向前看</code> (lookahead) token 就消耗掉它，然后从 lexer 中得到一个新 token 并将它赋值给内部变量 <code>current_token</code>.</li></ol><p>这些准则看上去像这样：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200310211240.png" alt=""></p><p>让我们继续并遵循上述准则把我们的语法转化为代码。</p><p>我们的语法中有两条规则： <code>expr</code> 和 <code>factor</code>. 我们从 <code>factor</code> 规则（生成式）开始。 根据准则，需要新建一个名为 factor 的方法（准则1)，它调用了一次 <code>eat</code> 方法来消耗INTEGER token （准则4)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span>   <span class="comment">#factor就是指的integer型数值</span></span><br><span class="line">    self.eat(INTEGER)</span><br></pre></td></tr></table></figure><p><code>expr</code> 规则变成了 <code>expr</code> 方法（还是准则1）。规则体(body)开始的 <code>factor</code> 引用 变成了对 <code>factor()</code> 方法的调用。可行组 <code>(...)*</code> 变成了一个 <code>while</code> 循环，多选一 <code>(MUL|DIV)</code> 变成了一个 <code>if-elif-else</code> 语句。把这些片段合并在一起就得到了下面的<code>expr</code> 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.factor() <span class="comment">#语法准则中的第一个factor</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">        token = self.current_token</span><br><span class="line">        <span class="keyword">if</span> token.type == MUL:</span><br><span class="line">            self.eat(MUL)</span><br><span class="line">            self.factor()</span><br><span class="line">        <span class="keyword">elif</span> token.type == DIV:</span><br><span class="line">            self.eat(DIV)</span><br><span class="line">            self.factor()</span><br></pre></td></tr></table></figure><p>原作者将本文的代码放在了文件 <code>parser.py</code> 中，它包含了 lexer 和 parser 但没有interpreter。你可以直接从 <a href="https://github.com/rspivak/lsbasi/blob/master/part4/parser.py" target="_blank" rel="noopener">GitHub</a>下载并尝试一下。它包含有一个 interpreter 提示符，你可以输入表达式来查看它是否合法，即查看根据语法建立的 parser 是否可以识别出表达式。</p><p>下面是在我笔记本上的一次尝试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ python parser.py</span><br><span class="line">calc&gt; <span class="number">3</span></span><br><span class="line">calc&gt; <span class="number">3</span> * <span class="number">7</span></span><br><span class="line">calc&gt; <span class="number">3</span> * <span class="number">7</span> / <span class="number">2</span></span><br><span class="line">calc&gt; <span class="number">3</span> *</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"parser.py"</span>, line <span class="number">155</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    main()</span><br><span class="line">  File <span class="string">"parser.py"</span>, line <span class="number">151</span>, <span class="keyword">in</span> main</span><br><span class="line">    parser.parse()</span><br><span class="line">  File <span class="string">"parser.py"</span>, line <span class="number">136</span>, <span class="keyword">in</span> parse</span><br><span class="line">    self.expr()</span><br><span class="line">  File <span class="string">"parser.py"</span>, line <span class="number">130</span>, <span class="keyword">in</span> expr</span><br><span class="line">    self.factor()</span><br><span class="line">  File <span class="string">"parser.py"</span>, line <span class="number">114</span>, <span class="keyword">in</span> factor</span><br><span class="line">    self.eat(INTEGER)</span><br><span class="line">  File <span class="string">"parser.py"</span>, line <span class="number">107</span>, <span class="keyword">in</span> eat</span><br><span class="line">    self.error()</span><br><span class="line">  File <span class="string">"parser.py"</span>, line <span class="number">97</span>, <span class="keyword">in</span> error</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">'Invalid syntax'</span>)</span><br><span class="line">Exception: Invalid syntax</span><br></pre></td></tr></table></figure><p>这里再次提起语法图。这是相同的 <code>expr</code> 规则（也叫，产生式(production)）对应的句法图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200310212342.png" alt="expr"></p><p>下面是原作者的关于本文的源码。下面是可以处理包含任意数量整数 乘除（整数除法）操作的合法的算术表达式的计算器代码。这里把词法分析器重构 到了一个单独的类 <code>Lexer</code> 中，并让 <code>Interpreter</code> 类使用 <code>Lexer</code> 实例做为参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, MUL, DIV, EOF = <span class="string">'INTEGER'</span>, <span class="string">'MUL'</span>, <span class="string">'DIV'</span>, <span class="string">'EOF'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        <span class="comment"># token type: INTEGER, MUL, DIV, or EOF</span></span><br><span class="line">        self.type = type</span><br><span class="line">        <span class="comment"># token value: non-negative integer value, '*', '/', or None</span></span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""String representation of the class instance.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">            Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">            Token(MUL, '*')</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Token(&#123;type&#125;, &#123;value&#125;)'</span>.format(</span><br><span class="line">            type=self.type,</span><br><span class="line">            value=repr(self.value)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"></span><br><span class="line"><span class="comment">#词法分析</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lexer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="comment"># client string input, e.g. "3 * 5", "12 / 3 * 4", etc</span></span><br><span class="line">        self.text = text</span><br><span class="line">        <span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        self.current_char = self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid character'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Advance the `pos` pointer and set the `current_char` variable."""</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt; len(self.text) - <span class="number">1</span>:</span><br><span class="line">            self.current_char = <span class="literal">None</span>  <span class="comment"># Indicates end of input</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_char = self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">            self.advance()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return a (multidigit) integer consumed from the input."""</span></span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">            result += self.current_char</span><br><span class="line">            self.advance()</span><br><span class="line">        <span class="keyword">return</span> int(result)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#不如叫做：get_token_and_next</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">        apart into tokens. One token at a time.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">                self.skip_whitespace()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isdigit():</span><br><span class="line">                <span class="keyword">return</span> Token(INTEGER, self.integer())</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'*'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MUL, <span class="string">'*'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'/'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(DIV, <span class="string">'/'</span>)</span><br><span class="line"></span><br><span class="line">            self.error()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lexer)</span>:</span></span><br><span class="line">        self.lexer = lexer</span><br><span class="line">        <span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">        self.current_token = self.lexer.get_next_token()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid syntax'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">        <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">        <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">        <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.lexer.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return an INTEGER token value.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        factor : INTEGER</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        token = self.current_token</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        <span class="keyword">return</span> token.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Arithmetic expression parser / interpreter.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        expr   : factor ((MUL | DIV) factor)*</span></span><br><span class="line"><span class="string">        factor : INTEGER</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = self.factor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == MUL:</span><br><span class="line">                self.eat(MUL)</span><br><span class="line">                result = result * self.factor()</span><br><span class="line">            <span class="keyword">elif</span> token.type == DIV:</span><br><span class="line">                self.eat(DIV)</span><br><span class="line">                result = result / self.factor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># To run under Python3 replace 'raw_input' call</span></span><br><span class="line">            <span class="comment"># with 'input'</span></span><br><span class="line">            text = raw_input(<span class="string">'calc&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        lexer = Lexer(text)</span><br><span class="line">        interpreter = Interpreter(lexer)</span><br><span class="line">        result = interpreter.expr()</span><br><span class="line">        print(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>将以上代码保存到名为 <code>calc4.py</code> 中，或者直接从 <a href="https://github.com/rspivak/lsbasi/blob/master/part4/calc4.py" target="_blank" rel="noopener">GitHub</a> 上下载。和以往一样，自己尝 试一下，确认它能工作。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Let&#39;s Build A Simple Interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let’s Build A Simple Interpreter 3</title>
      <link href="/archives/f957.html"/>
      <url>/archives/f957.html</url>
      
        <content type="html"><![CDATA[<p>实现加减法混合运算</p><a id="more"></a><p>原文链接：<a href="https://ruslanspivak.com/lsbasi-part3/" target="_blank" rel="noopener">https://ruslanspivak.com/lsbasi-part3/</a></p><p>目前为止，你已经学习了如何解释整数相加或相减的算术表达式如“7+3”或“12-9”。今天我 会聊一聊怎样解析（识别）并解释包含多位整数的加减法的算术表达式，如“7 - 3 + 2 - 1”。</p><h2 id="语法图"><a href="#语法图" class="headerlink" title="语法图"></a>语法图</h2><p>本文中的算术表达式可以用如下的语法图(syntax diagram)表示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part3_syntax_diagram-1583822487945.png" alt="语法图"></p><blockquote><p><strong>语法图(syntax diagram)</strong>：就是程序语言句法规则的图形表示。基本上，语法图从视觉上向你展示了在你的程序语言中哪些语句是允许的哪些是不允许的。</p></blockquote><p>句法图很容易阅读：只需跟随箭头所指示的路径即可。一些路径表示选择，一些路径表示循环。</p><p>你可以这样阅读上面的句法图：一个 term 后面可以跟一个加号或减号，后面又跟另一个 term， 相应地它后面又可以跟一个加号或减号，后面又跟另一个 term，如此循环。你已经读懂了 这幅图片，真的。<u>你可能会疑惑什么是“term”。在这篇文章中“term”就是一个整数。</u></p><h3 id="语法图的用途"><a href="#语法图的用途" class="headerlink" title="语法图的用途"></a>语法图的用途</h3><p>本文中的语法图主要有两个用途：</p><ul><li>从图形上表示一个编程语言的标准（语法）。</li><li>用来帮助你编写parser(语法分析器)，你可以通过下面简单的规则将图映射到代码。</li></ul><h2 id="语法分析器"><a href="#语法分析器" class="headerlink" title="语法分析器"></a>语法分析器</h2><p>你已经学过了从 token 流中识别组合的过程叫 <strong>parsing</strong>. 且解释器或编译器中执行这部分任务的叫 <strong>parser</strong>. parsing也被称为 <strong>语法分析</strong> (syntax analysis)，parser也相应地被称为<strong>语法分析器</strong>(syntax analyzer)，你应该也猜到这点了。</p><p>根据上面的句法图，下面所有的算术表达式都是合法的：</p><ul><li>3</li><li>3 + 4</li><li>7 - 3 + 2 - 1</li></ul><p>因为在不同的程序语言中算术表达式的句法规则都相似，我们可以使用 Python shell 来 “测试”我们的句法图。启动 Python shell 自己试一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> + <span class="number">4</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">7</span> - <span class="number">3</span> + <span class="number">2</span> - <span class="number">1</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>一切正常。</p><p>但表达式“3+”就不是合法的算术表达式，因为根据句法图加号后面必须跟一个 term（整数）， 否则就是句法错误。两次启动 Python shell 自己查看结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> +</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    <span class="number">3</span> +</span><br><span class="line">      ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><p>使用 Python shell 来做测试是挺不错的，不过我们还是把上面的句法图映射到代码，用我 们自己的解释器来测试，是吧？</p><p>从前面的文章（<a href="http://ruslanspivak.com/lsbasi-part1/" target="_blank" rel="noopener">第一部分</a>和<a href="http://ruslanspivak.com/lsbasi-part2/" target="_blank" rel="noopener">第二部分</a>）你知道了 parser 和 interpreter 都在 <code>expr</code> 方 法中。再重复一下，parser只是识别出结构并保证它符合某些规范，interpreter在parser成功识别后对表达式进行求值。</p><p>下面的代码片段展示了与句法图相对应的 parser 的代码。语法图中的矩形盒子变成了解析一个整数的 <code>term</code> 方法， <code>expr</code> 方法则只是跟随了语法图的指示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span>    </span><br><span class="line">    self.eat(INTEGER)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span>    </span><br><span class="line"><span class="comment"># set current token to the first token taken from the input  </span></span><br><span class="line">self.current_token = self.get_next_token()    </span><br><span class="line">        </span><br><span class="line">self.term()    </span><br><span class="line"><span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (PLUS, MINUS):</span><br><span class="line">token = self.current_token</span><br><span class="line">        <span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">self.eat(PLUS)</span><br><span class="line">self.term()</span><br><span class="line"><span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">self.eat(MINUS)</span><br><span class="line">self.term()</span><br></pre></td></tr></table></figure><p>可以看到 <code>expr</code> 方法首先调用了 <code>term</code> 方法。然后是一个可能执行 0 或多次的循环。 在循环中，parser 根据 token （是加号还是减号）来做选择。</p><p><strong>Parser 本身并不解释任何事</strong>：如果识别到一个表达式它就沉默，否则就抛出一个句法错误。 让我们修改 <code>expr</code> 方法来添加 interpreter 代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Return an INTEGER token value"""</span></span><br><span class="line">    token = self.current_token</span><br><span class="line">    self.eat(INTEGER)</span><br><span class="line">    <span class="keyword">return</span> token.value</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Parser / Interpreter"""</span></span><br><span class="line">    <span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">    self.current_token = self.get_next_token()</span><br><span class="line"></span><br><span class="line">    result = self.term()</span><br><span class="line">    <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (PLUS, MINUS):</span><br><span class="line">token = self.current_token</span><br><span class="line"><span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">    self.eat(PLUS)</span><br><span class="line">    result = result += self.term()</span><br><span class="line"><span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">    self.eat(MINUS)</span><br><span class="line">    result = result - self.term()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>因为 interpreter 需要对表达式进行求值，所以 <code>term</code> 方法被修改为返回一个整数值， <code>expr</code> 方法被修改为在适当的地方执行加减法并返回解释的结果。</p><p>让我们继续前进，来看一下现在解释器的完整代码怎么样？</p><p>下面是你新版计算器的源代码，它可以处理包含任意多个整数的加减操作的合法算术表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Token的类型：'INTEGER', 'PLUS', 'MINUS', 'EOF'</span></span><br><span class="line"><span class="comment"># Token的值(value)：整数，'+', '-', or None</span></span><br><span class="line">INTEGER, PLUS, MINUS, EOF = <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'MINUS'</span>, <span class="string">'EOF'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义Token类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        self.type = type</span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Token( &#123;type&#125;, &#123;value&#125; ) '</span> .format(</span><br><span class="line">            type = self.type ,</span><br><span class="line">            value = repr(self.value) <span class="comment">#repr与下面的__repr__不一样，下面的是重构的。</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        self.currrent_token = <span class="literal">None</span> <span class="comment">#此时还没有token实例所以是None</span></span><br><span class="line">        self.current_char =self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="comment">##########################################################</span></span><br><span class="line">    <span class="comment">#                       Lexer code                       #</span></span><br><span class="line">    <span class="comment">##########################################################</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid syntax'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt; len(self.text) <span class="number">-1</span> :</span><br><span class="line">            self.current_char =<span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_char = self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">            self.advance()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span></span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">            result += self.current_char</span><br><span class="line">            self.advance()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> int(result)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#词法分析(分析之后形成一个个的token)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">                self.skip_whitespace()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment">#识别整数</span></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isdigit():</span><br><span class="line">                <span class="keyword">return</span> Token(INTEGER, self.integer() )</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 识别是否为+ - 运算符号</span></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'+'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'-'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line"></span><br><span class="line">            self.error()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    <span class="comment">##########################################################</span></span><br><span class="line">    <span class="comment">#               Parser / Interpreter code                #</span></span><br><span class="line">    <span class="comment">##########################################################</span></span><br><span class="line">    <span class="comment">#比较当前的token的类型与传来的类型是否相同</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.currrent_token.type == token_type:</span><br><span class="line">            self.currrent_token = self.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#返回一个整型的token的value</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">        token = self.currrent_token</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        <span class="keyword">return</span> token.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.currrent_token = self.get_next_token()</span><br><span class="line"></span><br><span class="line">        result = self.term()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.currrent_token.type <span class="keyword">in</span> (PLUS , MINUS):</span><br><span class="line">            <span class="comment">#循环是为了算不止一次的加or减法，从而达到混合运算的目的</span></span><br><span class="line">            token = self.currrent_token</span><br><span class="line">            <span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">                self.eat(PLUS)</span><br><span class="line">                result = result + self.term()</span><br><span class="line">            <span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">                self.eat(MINUS)</span><br><span class="line">                result = result - self.term()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># To run under Python3 replace 'raw_input' call</span></span><br><span class="line">            <span class="comment"># with 'input'</span></span><br><span class="line">            text = input(<span class="string">'calc&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        interpreter = Interpreter(text)</span><br><span class="line">        result = interpreter.expr()</span><br><span class="line">        print(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>将以上代码保存到名为 <code>calc3.py</code> 中，或者直接从 <a href="https://github.com/rspivak/lsbasi/blob/master/part3/calc3.py" target="_blank" rel="noopener">GitHub</a> 上下载。试一试。亲眼看一下 它可以处理之前展示给你的句法图中包含的算术表达式规则。</p><h2 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h2><ol><li>输入字符串表达式（如“2+8-6+1”)，存入变量text中</li><li>将text进行词法分析，执行此功能的是<code>get_next_token()</code>函数，词法分析会生成一个个的token</li><li>然后对词法分析之后的token按照规定的语法，进行语法分析，相应函数为<code>expr()</code></li><li>最后输出结果</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Let&#39;s Build A Simple Interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3、布尔逻辑和逻辑门</title>
      <link href="/archives/87ef.html"/>
      <url>/archives/87ef.html</url>
      
        <content type="html"><![CDATA[<p>计算机最早的是机电设备，一般使用十进制计数，比如用齿轮数来代表十进制。但是其实只用开/关两种状态已经足够表示信息了，将其称为<strong>二进制（Binary）</strong>。</p><a id="more"></a><p>在计算机中，当电流流过时，为闭合状态，表示true（1），当没有电流流过时，为断开状态，表示false（0）。但是其实晶体管可以不只是开/关状态，还可以让不同大小的电流通过，一些早期电子计算机，通过对不同电流大小进行划分，可以使用三进制、五进制等等。但问题是，状态越多就越难区分信号，如果存在电噪音，可能就会使状态十分混乱。所以为了让信号更加清晰，可以只使用“开”和“关”两种状态。</p><p>另一个使用二进制的原因是，有一整个数学分支专门处理“真”和“假”，它已解决了所有法则和运算，即<strong>布尔代数（Boolean Algebra）</strong>。</p><h1 id="布尔代数（Boolean-Algebra）与逻辑门"><a href="#布尔代数（Boolean-Algebra）与逻辑门" class="headerlink" title="布尔代数（Boolean Algebra）与逻辑门"></a>布尔代数（Boolean Algebra）与逻辑门</h1><p>在布尔代数中，变量的值是true和false，能够对其进行逻辑操作。布尔代数中有三个<strong>基本操作：</strong>NOT、AND和OR。</p><h2 id="NOT-GATE"><a href="#NOT-GATE" class="headerlink" title="NOT GATE"></a>NOT GATE</h2><p><strong>NOT</strong>：把输出端（就像水龙头左边部分送水，它送电）接在上面的电极，如果打开输出，电流就可以流过，然后“接地”，输出就没有电流，所以输出是off。当输入关闭时，电流没法接地，就流过了输出，所以输出是on。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310011249234.png" alt="NOT GATE"></p><p>就像是水龙头一样：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310014800881.png" alt="水龙头关着"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310015120188.png" alt="水龙头开着"></p><p>​</p><p>​ <strong>NOT操作：</strong>把布尔值进行翻转，所以NOT操作的真值表为</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310011832488.png" alt="NOT 真值表"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310020424245.png" alt="NOT GATE的表示图"></p><h2 id="AND-GATE"><a href="#AND-GATE" class="headerlink" title="AND GATE"></a>AND GATE</h2><p><strong>AND</strong>：为了实现“AND 门”，我们需要2个晶体管连接在一起，这样有2个输入和1个输出。如果只打开A，不打开B，电流无法留到output，所以输出是false；如果只打开B，不打开A，也一样，电流无法留到output；只有当A、B都打开了，output才有电流。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310012335375.png" alt="image-20200310012335375"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310020520507.png" alt="AND GATE表示图"></p><h2 id="OR-GATE"><a href="#OR-GATE" class="headerlink" title="OR GATE"></a>OR GATE</h2><p><strong>OR</strong>：实现OR 门除了晶体管还需要额外的线将两个晶体管(transistor)并联起来，即得到OR GATE</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/v2-fda2d5cd50eb2f760f0a2ac72eb5efe5_720w.jpg" alt="OR GATE"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310020006112.png" alt="image-20200310020006112"></p><p>左侧电极为电源，下方两个电极分别表示两个输入，右侧电极为输出。只要任意一个输入开启，就能使得电源和输出电极接通，使得输出开启；当两个输入都关闭时，就使得电源和输出电极保持断开状态，使得输出保持关闭。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310020600225.png" alt="OR GATE表示图"></p><p>由此通过上方的三个组件（NOT门、AND门和OR门）可以构建出更加复杂的组件。另一个常见的布尔操作叫做<strong>异或操作</strong>。</p><h2 id="XOR-异或"><a href="#XOR-异或" class="headerlink" title="XOR(异或)"></a>XOR(异或)</h2><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310020826408.png" alt="XOR"></p><p>我们有两个输入，A和B，还有一个输出。先放一个OR门。因为OR和XOR的逻辑表很像，只有一个不同点就是：当两个输入都为true时，XOR输出false，而OR输出true。通过对AND操作真值表取反，再和OR操作真值表进行对比，可以发现，第二三行都为true，而第一四行结果不同，因此只要在这两个结果后面加个AND就能得到XOR的真值表。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>操作真值表：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310021526100.png" alt="XOR操作真值表"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310021854665.png" alt="NOT操作真值表"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/v2-eb0326d9127258653005333d2d1c59a6_720w.jpg" alt="AND操作真值表"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/v2-088dbb26ce45d8e512140426f6e3bb62_720w.jpg" alt="OR操作真值表"></p><p>对应的罗基本表示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310022102365.png" alt="逻辑门的表示图"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学速成课 </tag>
            
            <tag> 布尔逻辑和逻辑门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let’s Build A Simple Interpreter 2</title>
      <link href="/archives/d57d.html"/>
      <url>/archives/d57d.html</url>
      
        <content type="html"><![CDATA[<p>If you learn only methods, you’ll be tied to your methods. But if you learn<br>principles, you can devise your own methods.</p><a id="more"></a><p>原文地址：<a href="https://ruslanspivak.com/lsbasi-part2/" target="_blank" rel="noopener">https://ruslanspivak.com/lsbasi-part2/</a></p><p>这是第二个版本V2.0，第二个版本较第一个版V1.0，它可以做到：</p><ol><li>处理输入字符串中任何位置的空白符</li><li>处理输入中的多位数</li><li>两个整数相减（版本V1.0中只有加法）</li></ol><p>下面先给出V2.0的新版计算器的源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, PLUS, MINUS, EOF = <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'MINUS'</span>, <span class="string">'EOF'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line"><span class="comment"># token type: 'INTEGER', 'PLUS', 'MINUS', or 'EOF'</span></span><br><span class="line">self.type  = type</span><br><span class="line"><span class="comment"># token value: non-negative integer value, '+', '-', or None</span></span><br><span class="line">self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""String representation of class instance</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Examples:</span></span><br><span class="line"><span class="string">    Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">    Token(PLUS, '+')</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">f'Token(<span class="subst">&#123;self.type&#125;</span>, <span class="subst">&#123;self.value&#125;</span>)'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">return</span> self.__str__()</span><br><span class="line"><span class="comment">##__repr__() 与 __str__() 的主要区别在于，前者在交互式步骤中显示结果，后者在 print 函数中显示结果。</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line"><span class="comment"># client string input, e.g. "3 + 5", "12 - 5", etc</span></span><br><span class="line">self.text = text</span><br><span class="line"><span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">self.pos  = <span class="number">0</span></span><br><span class="line"><span class="comment"># current token instance</span></span><br><span class="line">self.current_token = <span class="literal">None</span></span><br><span class="line">self.current_char  = self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">raise</span> Exception(<span class="string">'Error parsing input'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">########新增#######</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""Advance the 'pos' pointer and set the 'current_char' variable."""</span></span><br><span class="line">self.pos += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> self.pos &gt;= len(self.text):</span><br><span class="line">    self.current_char = <span class="literal">None</span>  <span class="comment"># Indicates end of input</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    self.current_char = self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">    self.advance()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""Return a (multidigit) integer consumed from the input."""</span></span><br><span class="line">result = <span class="string">''</span></span><br><span class="line"><span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">    result += self.current_char</span><br><span class="line">    self.advance()</span><br><span class="line"><span class="keyword">return</span> int(result)</span><br><span class="line">  <span class="comment">##新增 完毕#####</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">apart into tokens.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">self.skip_whitespace()</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> self.current_char.isdigit():</span><br><span class="line"><span class="keyword">return</span> Token(INTEGER, self.integer())</span><br><span class="line">    <span class="keyword">if</span> self.current_char == <span class="string">'+'</span>:</span><br><span class="line">self.advance()</span><br><span class="line"><span class="keyword">return</span> Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line">    <span class="keyword">if</span> self.current_char == <span class="string">'-'</span>:</span><br><span class="line">self.advance()</span><br><span class="line"><span class="keyword">return</span> Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line"></span><br><span class="line">    self.error()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line"><span class="comment"># compare the current token type with the passed token</span></span><br><span class="line"><span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line"><span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line"><span class="comment"># otherwise raise an exception.</span></span><br><span class="line"><span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">    self.current_token = self.get_next_token()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    self.error()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""Parser / Interpreter</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">expr -&gt; INTEGER PLUS INTEGER</span></span><br><span class="line"><span class="string">expr -&gt; INTEGER MINUS INTEGER</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># set current token to the first token from the input</span></span><br><span class="line">self.current_token = self.get_next_token()</span><br><span class="line"></span><br><span class="line"><span class="comment"># we expect the current token to be an integer</span></span><br><span class="line">left = self.current_token</span><br><span class="line">self.eat(INTEGER)</span><br><span class="line"></span><br><span class="line"><span class="comment"># we expect the current token to be either a '+' or '-'</span></span><br><span class="line">op = self.current_token</span><br><span class="line"><span class="keyword">if</span> op.type == PLUS:</span><br><span class="line">    self.eat(PLUS)</span><br><span class="line"><span class="keyword">elif</span> op.type == MINUS:</span><br><span class="line">    self.eat(MINUS)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    self.error()</span><br><span class="line"></span><br><span class="line"><span class="comment"># we expect the current token to be an integer</span></span><br><span class="line">right = self.current_token</span><br><span class="line">self.eat(INTEGER)</span><br><span class="line"><span class="comment"># after the above call the self.current_token is set to</span></span><br><span class="line"><span class="comment"># EOF token</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># at this point either the INTEGER PLUS INTEGER or</span></span><br><span class="line"><span class="comment"># the INTEGER MINUS INTEGER sequence of tokens</span></span><br><span class="line"><span class="comment"># has been successfully found and the method can just</span></span><br><span class="line"><span class="comment"># return the result of adding or subtracting two integers,</span></span><br><span class="line"><span class="comment"># thus effectively interpreting client input</span></span><br><span class="line"><span class="keyword">if</span> op.type == PLUS:</span><br><span class="line">    result = left.value + right.value</span><br><span class="line"><span class="keyword">elif</span> op.type == MINUS:</span><br><span class="line">    result = left.value - right.value</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    self.error()</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># To run under Python3 replace 'raw_input' call with 'input'</span></span><br><span class="line">    text = input(<span class="string">'calc&gt; '</span>)</span><br><span class="line"><span class="keyword">except</span> EOFError:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">interpreter = Interpreter(text)</span><br><span class="line">result      = interpreter.expr()</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>把以上代码保存到名为 <code>calc2.py</code> 中，或者直接从 <a href="https://github.com/rspivak/lsbasi/blob/master/part2/calc2.py" target="_blank" rel="noopener">GitHub</a> 上下载。试一试。亲眼看一下 它可以按预期运行：它可以处理输入中的任何位置的空白符；它接受多位整数，除了整数相 加还可以处理整数相减。</p><p>下面可以再笔记本上次尝试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python calc2.py</span><br><span class="line">calc&gt; <span class="number">27</span> + <span class="number">3</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line">calc&gt; <span class="number">27</span> - <span class="number">7</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line">calc&gt;</span><br></pre></td></tr></table></figure><p>与<a href="http://ruslanspivak.com/lsbasi-part1/" target="_blank" rel="noopener">第一部分</a>相比代码的主要变化有：</p><ol><li><code>get_next_token</code> 方法做了一点重构。增加指针 <code>pos</code> 的逻辑被重构到了方法 <code>advance</code> 中。</li><li>增加了两个方法： <code>skip_whitespace</code> 用来忽略空白符， <code>integer</code> 用来处理输入中的多位整数。</li><li><code>expr</code> 方法在修改后，除了可以识别 INTEGER -&gt; PLUS -&gt; INTEGER 这个组合(phrase) 之外，还可以识别INTEGER -&gt; MINUS -&gt; INTEGER。而且在成功识别相应的组合后，也可以进行相应的加减操作。</li></ol><p>在<a href="http://ruslanspivak.com/lsbasi-part1/" target="_blank" rel="noopener">第一部分</a>你尝到了两个重要的概念，即 <strong>token</strong> 和 <strong>词法分析器</strong> 。今天我想聊一聊 <strong>lexeme</strong> 、 <strong>parsing</strong> 和 <strong>parser</strong> 。</p><p>你已经知道 token 了。但为了叙述方便，需要介绍一下 lexeme。什么是 lexeme？ lexeme 是组成 token 的一个字符序列。在下面的图片中是一些 token 和 lexeme 的例子， 希望它能把两者之间的关系表达清楚：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part2_lexemes.png" alt="img"></p><p>现在还记得 <code>expr</code> 方法吗？我以前说过这是真正解释算术表达式的地方。但在解释一个表达式之前，你需要知道它是哪种组合，比如相加或相减。这是 <code>expr</code> 方法本质上做的事： 它从 <code>get_next_token</code> 方法得到的 token 流中找到结构，然后解释它识别出的组合，产 生算术表达式的结果。</p><p>又到了做练习的时间了。</p><ol><li>扩展计算器以处理两个整数相乘</li><li>扩展计算器以处理两个整数相除</li><li>修改代码以使它可以解释包含任意个数字的加减操作，如“9 - 5 + 3 + 11”</li></ol><p>本节检测：</p><ol><li>什么是 lexeme？</li><li>在 token 流中找到结构的过程叫什么？或者这么问，在 token 流中识别出特定组合的过程叫什么？</li><li>解释器（编译器）做 parsing 工作的部分叫什么？</li></ol><hr><p><strong>梳理</strong>：</p><ol><li>首先输入一个表达式，如“3+9”，送给解释器<strong><code>Interpreter</code></strong></li><li>开始对这个表达式拆分成一个个的token，这一步叫做词法分析，由<strong>词法分析器</strong>(lexical analyzer)来完成。在本文中，函数<strong><code>get_next_token</code></strong>就相当于词法分析器。<ul><li>词法分析器<code>get_next_token</code>处理完之后的是一个个的<code>token(type , value)</code></li></ul></li><li>然后开始进行语法分析（由于本文中只实现了加法、减法），所以这里的语法分析就是分析：加、减法的表达式。执行这个步骤的是<strong><code>expr</code></strong>函数，其中<code>expr</code> 方法使用了辅助方法<strong><code>eat</code></strong>来验证传给token的类型与当前类型是否相匹配。与现有语法规则（即，加法规则和减法规则）不匹配，<code>eat</code>就会抛出异常。</li><li>语法分析完成之后，就直接得出算式的结果。（这也很符合解释器的特性嘛：便捷式边执行，不会生成目标代码）</li></ol><p>其他的函数：</p><p><code>Interpreter</code></p><ul><li><code>error(self)</code>：当有错误的时候，就调用它</li><li><code>advance(self)</code>：增加指针pos的作用，即，将指向下一个token</li><li><code>skip_whitespace(self)</code>：跳过空格，V2.0新增加的功能</li><li><code>integer(self)</code>：为了可以算多位数的加减法。<ul><li>这里要注意：如3和233是两个整数类型的token，但是值得注意的是这篇文章中的token是按照输入的一串字符串（如“3+155”）每一个都当成一个token。也就是说本来155是一个token，但是从细节上看，在代码实现中155是被当成了三次“token”然后经过<code>integer</code>函数才形成了最终形体155这个token。</li></ul></li></ul><hr><p>在本系列的下一篇文章中你会扩展你的计算器来处理更复杂的算术表达式。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Let’s Build A Simple Interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let’s Build A Simple Interpreter 1</title>
      <link href="/archives/427485bf.html"/>
      <url>/archives/427485bf.html</url>
      
        <content type="html"><![CDATA[<hr><hr><p>为什么要你学解释器和编译器？这里你三条理由。</p><a id="more"></a><ol><li>要写一个解释器或编译器，你必须同时用到很多技术。编写一个解释器或编译器会帮助 你提高这些技能并且成为一个更好的软件开发者。而且，你将学到的这些技能在开发任 何软件时都有可能用到，而不仅仅是解释器或编译器。</li><li>你确实想要知道计算机如何工作。一般解释器和编译器看上去都像魔法一样。但你不应 该对这些魔法感到舒服。你想要揭开解释器和编译器的神秘面纱，理解它们如何工作并 控制所有一切。</li><li>你想要创造自己的编程语言或者领域特定语言。如果是这样，你就需要为这个语言创建 一个解释器或编译器。最近，创建新语言再度兴起。你几乎每天都可以看到一门新语言 的诞生：Elixir, Go, Rust 等。</li></ol><p>原文链接：<a href="https://ruslanspivak.com/lsbasi-part1/" target="_blank" rel="noopener">https://ruslanspivak.com/lsbasi-part1/</a></p><p>好了，但什么是<strong>解释器</strong>和<strong>编译器</strong>呢？</p><h1 id="解释器与编译器"><a href="#解释器与编译器" class="headerlink" title="解释器与编译器"></a>解释器与编译器</h1><p>解释器与编译器都是“高级语言与机器之间的翻译官”。都是讲代码翻译成机器可以执行的二进制机器码，只不过在运行原理和翻译过程不同。</p><p>那它们的区别在于：</p><ul><li>编译器：先整体编译完，然后一次性执行。比如C语言代码被编译成二进制代码（exe程序），在windows平台上执行。</li><li>解释器：解释一句后就提交计算机执行一句，即便捷式边执行。比如php，postscritp，javascript就是典型的解释性语言。</li></ul><blockquote><p>用一个通俗的例子来讲：我们去饭馆吃饭，点了八菜一汤。编译器的方式就是厨师把所有的菜给你全做好了，一起给你端上来，至于你在哪吃，怎么吃，随便。解释器的方式就是厨师做好一个菜给你上一个菜，你就吃这个菜，而且必须在饭店里吃。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200309170643.png" alt="解释器与编译器的区别"></p><p>编译器与解释器的工作流程的差别：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20160918194226830.jpg" alt="编译器与解释器的工作流程的差别"></p><p>编译器与解释器的各自的特点：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200309171531.png" alt="各自特点"></p><h1 id="构造解释器V1-0"><a href="#构造解释器V1-0" class="headerlink" title="构造解释器V1.0"></a>构造解释器V1.0</h1><p>该系列文章的作者使用 Python 编写Pascal语言的解释器。</p><p>第一版V1.0，构造的计算器有诸多限制。如：</p><ul><li>只输入一位的数字</li><li>现阶段仅支持加法操作</li><li>输入中不允许有空白符</li></ul><p>这些约束使得构建一个计算器很简单，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Token types：</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, PLUS, EOF = <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'EOF'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line"><span class="comment"># token type: INTEGER, PLUS, or EOF</span></span><br><span class="line">self.type  = type</span><br><span class="line"><span class="comment"># token value: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, '+', or None</span></span><br><span class="line">self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""String representation of the class instance.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Examples:</span></span><br><span class="line"><span class="string">    Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">    Token(PLUS, '+')</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">'Token(&#123;type&#125;, &#123;value&#125;)'</span>.format(</span><br><span class="line">    type=self.type,</span><br><span class="line">    value=repr(self.value)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">return</span> self.__str__()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line"><span class="comment"># client string input, e.g. "3+5"</span></span><br><span class="line">self.text = text</span><br><span class="line"><span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">self.pos  = <span class="number">0</span></span><br><span class="line"><span class="comment"># current token instance</span></span><br><span class="line">self.current_token = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">raise</span> Exception(<span class="string">'Error parsing input'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">apart into tokens. One token at a time.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">text = self.text</span><br><span class="line"></span><br><span class="line"><span class="comment"># is self.pos index past the end of the self.text ?</span></span><br><span class="line"><span class="comment"># if so, then return EOF token because there no more</span></span><br><span class="line"><span class="comment"># input left to convert into tokens</span></span><br><span class="line"><span class="keyword">if</span> self.pos &gt; len(text) - <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get a character at the position self.pos and decide</span></span><br><span class="line"><span class="comment"># what token to create based on the single character</span></span><br><span class="line">current_char = text[self.pos]</span><br><span class="line"></span><br><span class="line"><span class="comment"># if the character is a digit then convert it to</span></span><br><span class="line"><span class="comment"># integer, create an INTEGER token, increment self.pos</span></span><br><span class="line"><span class="comment"># index to point to the next character after the digit,</span></span><br><span class="line"><span class="comment"># and return the INTEGER token</span></span><br><span class="line"><span class="keyword">if</span> current_char.isdigit():</span><br><span class="line">    token     = Token(INTEGER, int(current_char))</span><br><span class="line">    self.pos += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> token</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> current_char == <span class="string">'+'</span>:</span><br><span class="line">    token     = Token(PLUS, current_char)</span><br><span class="line">    self.pos += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> token</span><br><span class="line"></span><br><span class="line">self.error()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line"><span class="comment"># compare the current token type with the passed token</span></span><br><span class="line"><span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line"><span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line"><span class="comment"># otherwise raise an exception.</span></span><br><span class="line"><span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">    self.current_token = self.get_next_token()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    self.error()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""expr -&gt; INTEGER PLUS INTEGER"""</span></span><br><span class="line"><span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">self.current_token = self.get_next_token()</span><br><span class="line"></span><br><span class="line"><span class="comment"># we expect the current token to be a single-digit integer</span></span><br><span class="line">left = self.current_token</span><br><span class="line">self.eat(INTEGER)</span><br><span class="line"></span><br><span class="line"><span class="comment"># we expect the current token to be a '+' token</span></span><br><span class="line">op = self.current_token</span><br><span class="line">self.eat(PLUS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># we expect the current token to be a single-digit integer</span></span><br><span class="line">right = self.current_token</span><br><span class="line">self.eat(INTEGER)</span><br><span class="line"><span class="comment"># after the above call the self.current_token is set to</span></span><br><span class="line"><span class="comment"># EOF token</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># at this point INTEGER PLUS INTEGER sequence of tokens</span></span><br><span class="line"><span class="comment"># has been successfully found and the method can just</span></span><br><span class="line"><span class="comment"># return the result of adding two integers, thus</span></span><br><span class="line"><span class="comment"># effectively interpreting client input</span></span><br><span class="line">result = left.value + right.value</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># To run under Python3 replace 'raw_input' call with 'input'</span></span><br><span class="line">    text = input(<span class="string">'calc&gt; '</span>)</span><br><span class="line"><span class="keyword">except</span> EOFError:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">interpreter = Interpreter(text)</span><br><span class="line">result = interpreter.expr()</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>把以上代码保存到名为 <code>calc1.py</code> 中，或者直接从 <a href="https://github.com/rspivak/lsbasi/blob/master/part1/calc1.py" target="_blank" rel="noopener">GitHub</a> 上下载。在你开始仔细研究代 码之前，在命令行上运行这个计算器并看它实现运行。把玩一下！下面是在我笔记本上的一 次尝试（如果你想在 Python3 下运行，就需要把 <code>raw_input</code> 替换为 ==input==）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ python calc1.py</span><br><span class="line">calc&gt; 3+4</span><br><span class="line">7</span><br><span class="line">calc&gt; 3+5</span><br><span class="line">8</span><br><span class="line">calc&gt; 3+9</span><br><span class="line">12</span><br><span class="line">calc&gt;</span><br></pre></td></tr></table></figure><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>假设我们在命令行输入一个表达式“3+5”。你的解释器得到一个字符串 “3+5”。为了使解释器真正理解如何处理这个字符串，需要先把输入的 “3+5” 拆分成被叫做 <strong>token</strong> 的部件。</p><blockquote><p><strong>词法分析</strong>：（<strong>lexical analysis</strong>，简称<strong>lexer</strong>，亦称<strong>scanner</strong> 或 <strong>tokenizer</strong>）</p><p>​ 词法分析也称为 <strong>分词</strong> ，此阶段编译器从左向右扫描源文件，将其字符流分割成一个个的 <strong>词</strong> （ <strong>token</strong> 、 <strong>记号</strong> ，后文中将称为 <strong>token</strong> ）。</p><p><strong>Token</strong>：</p><p>​ 所谓 <strong>token</strong> ，就是源文件中不可再进一步分割的一串字符，类似于英语中单词，或汉语中的词。</p></blockquote><p>这里的 <strong>token</strong> 就是一个有类型的值的对象（即，token还存着值的类型）。例如对于字符串“3”来说，token 类型为 <code>INTEGER</code> ， 相应的值是整数 3 。</p><p>解释器<code>Interpreter</code>要做的第一步就是读取输入的字符串并把他转化成 token <strong>流</strong>。解释器中做这个工作的部分被称为 <strong>词法分析器</strong>(lexical analyzer)，简称 <strong>lexer</strong> 。也可以称它为： <strong>scanner</strong> 或 <strong>tokenizer</strong> 。他们的含义是一样的：表示解释器或编译器中将输入的字符串转化为 token 流的部分。</p><p>那是如何转化为token流呢？</p><ul><li>解释器 <code>Interpreter</code>中的 <code>get_next_token</code> 方法就是你的词法分析器。你每次调用它，就会从输入到解释器的字符流中得到下一个 token。让我们仔细看一下这个方法，看看它是怎么把字符转化 为 token 的。输入被存放在变量 <code>text</code> 中，它保存了输入的字符串， <code>pos</code> 是指向该字符串的一个索引（把字符串看作是一个字符数组）。 <code>pos</code> 的初值被设为 0, 指向字符‘3’。 该方法首先检查该字符是不是数字，若是数字，就递增 <code>pos</code> 并返回一个类型为 <code>INTEGER</code> 值 为整数 3 的 token：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part1_lexer1-1583746666076.png" alt="img"></p><p>现在 <code>pos</code> 指向了 <code>text</code> 中的字符‘+’，下次你调用这个方法时，它会先测试 <code>pos</code> 位 置的字符是否是数字，然后再测试它是否是加号，此时它是加号。这样该方法就递增 <code>pos</code> 并返回一个类型为 <code>PLUS</code> 值为‘+’的 token：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part1_lexer2.png" alt="img"></p><p>现在 <code>pos</code> 指向了字符‘5’。当你再次调用 <code>get_next_token</code> 时，它会检查 <code>pos</code> 位置 是否是一个数字，此时是的，因此它递增 <code>pos</code> 并返回一个类型为 <code>INTEGER</code> 值为‘5’的 token：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part1_lexer3.png" alt="img"></p><p>现在索引 <code>pos</code> 越过了字符串“3+5”的末尾，接下来每次调用 <code>get_next_token</code> 方法都会 返回 <code>EOF</code> token：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part1_lexer4.png" alt="img"></p><p>自己动手试试看看你的计算器的 lexer 组件怎么工作的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> calc1 <span class="keyword">import</span> Interpreter</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>interpreter = Interpreter(<span class="string">'3+5'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>interpreter.get_next_token()</span><br><span class="line">Token(INTEGER, <span class="number">3</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>interpreter.get_next_token()</span><br><span class="line">Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>interpreter.get_next_token()</span><br><span class="line">Token(INTEGER, <span class="number">5</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>interpreter.get_next_token()</span><br><span class="line">Token(EOF, <span class="literal">None</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>此时你的解释器已经可以从输入的字符流中获得 token 流了，解释器需要对它做点什么： 它需要从使用 lexer <code>get_next_token</code> 得到的字符流中找到结构。你的解释器期望从 流中找到如下的结构： INTEGER -&gt; PLUS -&gt; INTEGER. 即，它试着找到这样一个 token 序 列：整数后跟一个加号再跟一个整数。</p><p>负责查找和解释这个结构的方法是 <code>expr</code>. 这个方法验证一个 token 序列是否遵从期望的 token 序列，即 INTEGER -&gt; PLUS -&gt; INTEGER. 当确定遵从这个结构后，它就把 PLUS 左 边和右边 token 的值相加来生成结果，从而成功地解释了你传给解释器的算术表达式。</p><p><code>expr</code> 方法使用了辅助方法 <code>eat</code> 来验证传给 <code>eat</code> 的 token 类型与当前的 token 类 型相匹配。在匹配到传入的 token 类型后， <code>eat</code> 方法会取得下一个 token 并把它赋值 给变量 <code>current_token</code>, 这样实际上是“吃掉”了当前匹配的 token 并把想象中的 token 流中的指针向前移动了。如果 token 流中的结构不遵从期望的 INTEGER PLUS INTEGER 序 列， <code>eat</code> 方法就会抛出一个异常。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>回顾一下你的解释器为了对一个算术表达式求值都做了什么：</p><ol><li>解释器接<code>Interpreter</code>收一个输入字符串，假设为“3+5”</li><li>解释器调用了 <code>expr</code> 方法来从词法解析器 <code>get_next_token</code> 返回的 token 流中寻找一个结构。这个结构就是一个 <em>INTEGER PLUS INTEGER</em> 的形式。当确认了这个结构以后，它就使用把两个 INTEGER token 相加的方式来解释这个输入，因为此时解释器已经清楚 地知道它要做的就是把 3 和 5 两个整数相加。</li></ol><p>祝贺你。你刚刚学会了怎么构造你的第一个解释器！</p><p>现在是时候做此练习了。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_exercises2.png" alt="img"></p><p>你不会觉得你刚刚读了这篇文章就足够了，是吧？好了，自己动手做下面的练习：</p><ol><li>修改代码使得允许输入多位整数，例如“12+3”</li><li>增加一个跳过空白符的方法，使你的计算器可以处理包含空白符的输入如 “ 12 + 3”</li><li>修改代码使得它可以处理‘-’而非‘+’的情况</li></ol><p>检查你的理解。</p><ol><li>什么是解释器？</li><li>什么是编译器？</li><li>解释器和编译器的区别是什么？</li><li>什么是 token？</li><li>将输入拆分成 token 的过程叫什么？</li><li>解释器中做词法分析的部分叫什么？</li><li>解释器或编译器的这个部分还有什么其他常见的名字？</li></ol><p>相关文章链接：</p><p>编译器与解释器：<a href="https://www.liujiangblog.com/course/python/9" target="_blank" rel="noopener">https://www.liujiangblog.com/course/python/9</a></p><p>Let’s Build A Simple Interpreter. Part 1：<a href="https://feng-qi.github.io/2018/01/23/lets-build-a-simple-interpreter-part-01/" target="_blank" rel="noopener">https://feng-qi.github.io/2018/01/23/lets-build-a-simple-interpreter-part-01/</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Let’s Build A Simple Interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2、电子计算机</title>
      <link href="/archives/d84f.html"/>
      <url>/archives/d84f.html</url>
      
        <content type="html"><![CDATA[<p>这个系列的课程还是值得大家去看一看的。这个系列的视频叫《计算机科学速成课》。虽然叫速成课，我们也要做到心中有数，它肯定不是让你看了这些内容你就什么都知道了。这是科普性的视频。这个视频都是被翻译好的，再次感谢这些翻译者。</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>视频在B站上都有全集的，传送门：<a href="https://www.bilibili.com/video/av21376839" target="_blank" rel="noopener">https://www.bilibili.com/video/av21376839</a></p><p>在GitHub上的地址：<a href="https://github.com/1c7/crash-course-computer-science-chinese" target="_blank" rel="noopener">https://github.com/1c7/crash-course-computer-science-chinese</a></p><p>这门课总共有40节，每节课的标题为：</p><ol><li>计算机早期历史</li><li>电子计算</li><li>布尔逻辑与逻辑电路</li><li>二进制</li><li>算术逻辑单元</li><li>寄存器 &amp; 内存</li><li>中央处理器</li><li>指令和程序</li><li>高级 CPU 设计</li><li>编程史话</li><li>编程语言</li><li>编程原理：语句和函数</li><li>算法初步</li><li>数据结构</li><li>阿兰·图灵</li><li>软件工程</li><li>集成电路、摩尔定律</li><li>操作系统</li><li>内存 &amp; 储存介质</li><li>文件系统</li><li>压缩</li><li>命令行界面</li><li>屏幕 &amp; 2D 图形显示</li><li>冷战和消费主义</li><li>个人计算机革命</li><li>图形用户界面</li><li>3D 图形</li><li>计算机网络</li><li>互联网</li><li>万维网</li><li>网络安全</li><li>黑客与攻击</li><li>加密</li><li>机器学习与人工智能</li><li>计算机视觉</li><li>自然语言处理</li><li>机器人</li><li>计算机中的心理学</li><li>教育型科技</li><li>奇点，天网，计算机的未来</li></ol><h1 id="计算机早期历史"><a href="#计算机早期历史" class="headerlink" title="计算机早期历史"></a>计算机早期历史</h1><p>这一张图大致说明了计算机早期发展的历史。图片来源：请查看图片本身链接。</p><p>后面的课会较详细的讲解。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/5c2dbf8e0001443913279329.png" alt="计算机历史"></p><h1 id="电子计算机"><a href="#电子计算机" class="headerlink" title="电子计算机"></a>电子计算机</h1><h2 id="继电器"><a href="#继电器" class="headerlink" title="继电器"></a>继电器</h2><p>在1937年最大的机电计算机之一是哈佛的马克一号(Harvard Mark Ⅰ)，是IBM在1944年给二战的同盟国建造的。该机器的大脑(CPU的基础器件)是“<strong>继电器</strong>”。</p><ul><li><strong>继电器</strong>：是用电控制的机械开关，继电器里有根“控制线路”控制着电路的开关，“控制线路”连着一个线圈，当线圈通电时，会产生感应磁场，由此由此能够吸引上方的金属臂，从而闭合电路，得到高电平。它的<strong>性能：</strong>1940年一个好的继电器1秒能翻转50次。哈佛马克一号1秒能做3次加减法运算，一次乘法需要6秒，除法需要15秒，三角函数需要一分钟以上。它的<strong>缺点：</strong>控制开关的金属臂是“有质量的”，因此无法快速开关。并且金属臂的反复移动就会存在磨损（任何会动的机械都会随时间磨损），哈佛马克一号平均每天需要更换一个故障继电器。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200308033154957.png" alt="继电器"></p><h2 id="真空管"><a href="#真空管" class="headerlink" title="真空管"></a>真空管</h2><p>在1904年，英国物理学家John Ambrose Fleming开发了新的电子组件——<strong>热电子管（Thermionic valve）</strong>。</p><ul><li><strong>热电子管</strong>：把两个电极装在一个气密的真空玻璃灯泡中。其中一个点击A可以加热，从而发射电子，称为<strong>热电子发射（Thermionic emission）</strong>；另一个电极B会吸引电子，来形成电流。但只有当电极B带正电时才能吸引电子，否则当电极B带负电荷或者中性电荷时，电子就无法跨越真空区。</li></ul><p>美国发明家Lee de Forest在此基础上加入了第三个控制电极。通过向控制电极施加正电荷，就能吸引电子，从而闭合电路；而通过施加负电荷，就能闭合电路。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/v2-94062a34bd644ef937224efaa2ebdf6c_720w.png" alt="img"></p><p><strong>特点：</strong></p><p><em>每秒可开闭数千次。</em></p><p><em>和继电器相同的是，可以通过一个控制线路来控制断开或闭合电路，并且真空管内没有会动的组件，因此存在更少的磨损。</em></p><p><em>比较脆弱，会像灯泡一样烧坏，并且体积比较大。</em></p><p><strong>真空管的出现，标志着计算机从机电转向电子</strong>，电子数值积分计算机ENIAC，在1946年于宾夕法尼亚大学设计制造，这是世上第一个真正的通用可编程电子计算机，每秒可执行5000次十位加减法。但是由于存在大量的真空管，因此ENIAC运行半天左右就会出现一次故障。</p><h2 id="晶体管"><a href="#晶体管" class="headerlink" title="晶体管"></a>晶体管</h2><p><strong>晶体管：</strong>类似于继电器和真空管，晶体管也是一个用于控制电路闭合断开的开关。晶体管有两个电极，这两个电极之间通过半导体材料隔开。控制线连接到一个“门”电极，通过改“门”的电荷，我们可以控制半导体的导电性，由此来控制电流是否流动。当控制线路通电时，两个电极接通，否则两个电极断开。</p><p><strong>特点：</strong></p><p><em>每秒可开关10000次。</em></p><p><em>相比玻璃制成的真空管，晶体管是固体的，并且体积远小于继电器和真空管。</em></p><p>第一个消费者可购买的，完全由晶体管构成的计算机是1957年发布的IBM 608，它有3000个晶体管，每秒执行4500次加减法，或80次左右的乘除法。</p><p>如今，计算机里的晶体管小于50nm，并且每秒可切换上百万次，工作几十年。很多晶体管和半导体开发在圣克拉拉谷，位于旧金山和圣河西之间，由于制造半导体最常见的材料是硅，由此这个地方被称为“硅谷”。并且William Shockley搬过去创建了肖克利半导体，里面的员工后来成立了仙童半导体，而这里面的员工后来创立了英特尔。</p><hr><p>所以，计算机的大脑基础单元的发展路径，可概括为：<strong>继电器-&gt;电子管-&gt;晶体管</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《计算机科学速成课》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo之 Yilia主题配置</title>
      <link href="/archives/460671de.html"/>
      <url>/archives/460671de.html</url>
      
        <content type="html"><![CDATA[<p>Yilia主题配置</p><a id="more"></a><h2 id="在左侧显示总文章数"><a href="#在左侧显示总文章数" class="headerlink" title="在左侧显示总文章数"></a>在左侧显示总文章数</h2><p>将themes\yilia\layout_partial\left-col.ejs文件的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;nav <span class="class"><span class="keyword">class</span></span>=<span class="string">"header-menu"</span>&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">    &lt;% <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> theme.menu)&#123; %&gt;</span><br><span class="line">        &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%- url_for(theme.menu[i]) %&gt;"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">i</span> %&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;%&#125;%&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/u</span>l&gt;</span><br><span class="line">&lt;<span class="regexp">/nav&gt;</span></span><br></pre></td></tr></table></figure><p>后面加上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;nav&gt;</span><br><span class="line">    总文章数 &lt;%=site.posts.length%&gt;</span><br><span class="line">&lt;<span class="regexp">/nav&gt;</span></span><br></pre></td></tr></table></figure><h2 id="字数、阅读时长添加"><a href="#字数、阅读时长添加" class="headerlink" title="字数、阅读时长添加"></a>字数、阅读时长添加</h2><p>首先安装 <a href="https://github.com/willin/hexo-wordcount" target="_blank" rel="noopener">hexo-wordcount</a></p><p>使用如下命令安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-wordcount  <span class="comment">#如果安装了cnpm，可换为cnpm安装</span></span><br></pre></td></tr></table></figure><blockquote><p>Node 版本7.6.0之前,请安装 2.x 版本 (Node.js v7.6.0 and previous)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copynpm install hexo-wordcount@2 --save</span><br></pre></td></tr></table></figure><p>然后在 <code>themes\yilia\layout\_partial\left-col.ejs</code>中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copy&lt;nav&gt;</span><br><span class="line">    总字数 &lt;span class&#x3D;&quot;post-count&quot;&gt;&lt;%&#x3D; totalcount(site, &#39;0,0.0a&#39;) %&gt;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;nav&gt;</span><br></pre></td></tr></table></figure><p>添加位置在如下代码的下面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copy&lt;nav&gt;</span><br><span class="line">    总文章数 &lt;%&#x3D;site.posts.length%&gt;</span><br><span class="line">&lt;&#x2F;nav&gt;</span><br></pre></td></tr></table></figure><p>编辑 <code>themes\yilia\layout\_partial\article.ejs</code></p><p>在header下面加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div align&#x3D;&quot;left&quot; class&#x3D;&quot;post-count&quot;&gt;   &lt;!--其中align可以在：right、center、left--&gt;</span><br><span class="line">    字数：&lt;%&#x3D; wordcount(post.content) %&gt;字 | 预计阅读时长：&lt;%&#x3D; min2read(post.content) %&gt;分钟</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>即可显示单篇字数和预计阅读时长。</p><h2 id="置顶文章"><a href="#置顶文章" class="headerlink" title="置顶文章"></a>置顶文章</h2><p><strong>安装插件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure><p><strong>配置置顶标准</strong></p><p>打开：/themes/*/layout（/_macro）/post.ejs 直接在最前面加入以下代码即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (page.top) &#123; %&gt;</span><br><span class="line">  &lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">"fa fa-thumb-tack"</span>&gt;&lt;<span class="regexp">/i&gt;</span></span><br><span class="line"><span class="regexp">  &lt;font color=7D26CD&gt;置顶&lt;/</span>font&gt;</span><br><span class="line">  &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"post-meta-divider"</span>&gt;|&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;% &#125; %&gt;</span></span><br></pre></td></tr></table></figure><p><strong>配置文章</strong></p><p>然后在需要置顶的文章的Front-matter中加上top选项即可 top后面的数字越大，优先级越高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 2019</span><br><span class="line">date: 2019-02-14 16:10:03</span><br><span class="line">top: 5</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h2 id="增加不蒜子统计"><a href="#增加不蒜子统计" class="headerlink" title="增加不蒜子统计"></a>增加不蒜子统计</h2><p>利用这个统计，可以知道你博客的访问量。</p><p><strong>安装不蒜子脚本</strong>：</p><p>在themes\yilia\layout\ _partial\after-footer.ejs最后添加：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="单篇文章点击量："><a href="#单篇文章点击量：" class="headerlink" title="单篇文章点击量："></a>单篇文章点击量：</h3><p>在themes/yilia/layout/_partial/article.ejs中 在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%- partial(&#39;post&#x2F;title&#39;, &#123;class_name: &#39;article-title&#39;&#125;) %&gt;</span><br></pre></td></tr></table></figure><p>后面插入如下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--显示阅读次数--&gt;</span><br><span class="line">&lt;% <span class="keyword">if</span> (!index &amp;&amp; post.comments)&#123; %&gt;</span><br><span class="line">  &lt;br/&gt;</span><br><span class="line">  &lt;a <span class="class"><span class="keyword">class</span></span>=<span class="string">"cloud-tie-join-count"</span> href=<span class="string">"javascript:void(0);"</span> style=<span class="string">"color:gray;font-size:14px;"</span>&gt;</span><br><span class="line">  &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"icon-sort"</span>&gt;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;span id="busuanzi_container_page_pv" style="color:#ef7522;font-size:14px;"&gt;</span></span><br><span class="line"><span class="regexp">            阅读数: &lt;span id="busuanzi_value_page_pv"&gt;&lt;/</span>span&gt;次 &amp;nbsp;&amp;nbsp;</span><br><span class="line">  &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>a&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line">&lt;!--显示阅读次数完毕--&gt;</span><br></pre></td></tr></table></figure><h2 id="增加版权声明"><a href="#增加版权声明" class="headerlink" title="增加版权声明"></a>增加版权声明</h2><p><strong>配置yilia</strong>：</p><p>在themes/yilia/layout/_partial/article.ejs中，标注的位置添加代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"article-entry"</span> itemprop=<span class="string">"articleBody"</span>&gt;</span><br><span class="line">  &lt;% <span class="keyword">if</span> (post.excerpt &amp;&amp; index)&#123; %&gt;</span><br><span class="line">    &lt;%- post.excerpt %&gt;</span><br><span class="line">    &lt;% <span class="keyword">if</span> (theme.excerpt_link) &#123; %&gt;</span><br><span class="line">      &lt;a <span class="class"><span class="keyword">class</span></span>=<span class="string">"article-more-a"</span> href=<span class="string">"&lt;%- url_for(post.path) %&gt;#more"</span>&gt;&lt;%= theme.excerpt_link %&gt; &gt;&gt;&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">    &lt;% &#125; %&gt;</span></span><br><span class="line"><span class="regexp">  &lt;% &#125; else &#123; %&gt;</span></span><br><span class="line"><span class="regexp">    &lt;%- post.content %&gt;</span></span><br><span class="line"><span class="regexp">  &lt;% &#125; %&gt;</span></span><br><span class="line"><span class="regexp">  &lt;-- 在此处添加代码--&gt; &lt;-- 在此处添加代码--&gt; &lt;-- 在此处添加代码--&gt; &lt;-- 在此处添加代码--&gt;</span></span><br><span class="line"><span class="regexp">  &lt;% if ((theme.reward_type === 2 || (theme.reward_type === 1 &amp;&amp; post.reward)) &amp;&amp; !index)&#123; %&gt;</span></span><br><span class="line"><span class="regexp">  &lt;div class="page-reward"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;a href="javascript:;" class="page-reward-btn tooltip-top"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="tooltip tooltip-east"&gt;</span></span><br></pre></td></tr></table></figure><p>在目录：themes/yilia/source-src/css中创建新文件：declare.scss，并添加如下CSS代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.declare &#123;</span><br><span class="line">    background-color: #eaeaea;</span><br><span class="line">    margin-top: <span class="number">2</span>em;</span><br><span class="line">    border-left: 3px solid #ff1700;</span><br><span class="line">    padding: <span class="number">.5</span>em <span class="number">1</span>em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，为themes/yilia/source-src/css/main.scss，添加如下代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">"./declare"</span>;</span><br></pre></td></tr></table></figure><p><strong>配置显示</strong>：</p><p>现在该让其显示出来，在themes/yilia/_config.yml，中加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#版权基础设定：0-关闭声明； 1-文章对应的md文件里有declare: true属性，才有版权声明； 2-所有文章均有版权声明</span><br><span class="line">#当前应用的版权协议地址。</span><br><span class="line">#版权协议的名称</span><br><span class="line">#版权协议的Logo</span><br><span class="line"></span><br><span class="line">declare_type: 1</span><br><span class="line">licensee_url: https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by-nc-sa&#x2F;4.0&#x2F;</span><br><span class="line">licensee_name: &#39;知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议&#39;</span><br><span class="line">licensee_img: https:&#x2F;&#x2F;i.creativecommons.org&#x2F;l&#x2F;by-nc-sa&#x2F;4.0&#x2F;88x31.png</span><br></pre></td></tr></table></figure><p>然后在需要进行版权声明的文章的md文件头部，设置属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare:true</span><br></pre></td></tr></table></figure><p>即可。</p><h2 id="在主页时文章显示摘要"><a href="#在主页时文章显示摘要" class="headerlink" title="在主页时文章显示摘要"></a>在主页时文章显示摘要</h2><p>在你 MD 格式文章正文插入 <code>&lt;!-- more --&gt;</code> 即可，只会显示它之前的，此后的就不显示，点击文章标题，，或者点击下面的<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200302193556416.png" alt="image-20200302193556416">按钮，即可进入全文。</p><p>如：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200302180731556.png" alt="image-20200302180731556"></p><h2 id="文章显示目录"><a href="#文章显示目录" class="headerlink" title="文章显示目录"></a>文章显示目录</h2><p>增加文章目录 TOC ( table of content )，方便阅读文章，在 <code>themes/yilia/_config.yml</code> 中进行配置 <code>toc: 2</code> 即可，它会将你 Markdown 语法的标题，生成目录，目录查看在右下角。</p><h2 id="头像设置"><a href="#头像设置" class="headerlink" title="头像设置"></a>头像设置</h2><p><strong>设置存放位置</strong>：</p><p>头像/图标图片的存放位置是<code>/themes/yilia/source/</code>下任意位置，可以自己新建一个文件夹存放，我存放在<code>assets</code>文件夹下。（我之前放在img中，但是不知道为什么，它就显示不出来）</p><p><strong>配置修改</strong>：</p><p>配置文件为<code>/themes/yilia/_config.yml</code>。设置头像为配置文件中<code>avatar</code>一项，设置图标为配置文件中<code>favicon</code>一项，设置路径的根目录为<code>/themes/yilia/source/</code>。例如，我的头像存放的地址是<code>/themes/yilia/source/assets/me.png</code>，设置则为<code>avatar: /assets/me.png</code>。（图标同理）</p><h2 id="提交网页"><a href="#提交网页" class="headerlink" title="提交网页"></a>提交网页</h2><h3 id="sitemap方式提交网页"><a href="#sitemap方式提交网页" class="headerlink" title="sitemap方式提交网页"></a>sitemap方式提交网页</h3><p>在 Hexo 根目录打开命令行工具，执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;your_hexo_path&#125;&#x2F;public</span><br></pre></td></tr></table></figure><p>文件夹，可以看到文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sitemap.xml</span><br></pre></td></tr></table></figure><p>sitemap 的初衷是给搜索引擎看的，为了提高搜索引擎对自己站点的收录效果，我们最好手动到 google 和百度等搜索引擎提交 sitemap.xml。</p><p>baidu提交网址：<a href="https://ziyuan.baidu.com/?castk=LTE%3D" target="_blank" rel="noopener">https://ziyuan.baidu.com/?castk=LTE%3D</a></p><h3 id="百度自动推送方式提交网页"><a href="#百度自动推送方式提交网页" class="headerlink" title="百度自动推送方式提交网页"></a>百度自动推送方式提交网页</h3><p>在本机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;博客根目录&gt;&#x2F;themes&#x2F;yilia&#x2F;layout&#x2F;_partial</span><br></pre></td></tr></table></figure><p>目录下打开article.ejs文件，定位到如下这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">        var sUrl &#x3D; url.replace(&#x2F;index\.html$&#x2F;, &#39;&#39;);</span><br><span class="line">        sUrl &#x3D; &#x2F;^(http:|https:)\&#x2F;\&#x2F;&#x2F;.test(sUrl) ? sUrl : &#39;https:&#39; + sUrl;</span><br><span class="line">      %&gt;</span><br></pre></td></tr></table></figure><p>在它前面加上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!- 百度自动推送方式提交 --&gt;</span><br><span class="line">&lt;% if (1)&#123; %&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">  (function()&#123;</span><br><span class="line">      var bp &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">      var curProtocol &#x3D; window.location.protocol.split(&#39;:&#39;)[0];</span><br><span class="line">      if (curProtocol &#x3D;&#x3D;&#x3D; &#39;https&#39;) &#123;</span><br><span class="line">          bp.src &#x3D; &#39;https:&#x2F;&#x2F;zz.bdstatic.com&#x2F;linksubmit&#x2F;push.js&#39;;</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">          bp.src &#x3D; &#39;http:&#x2F;&#x2F;push.zhanzhang.baidu.com&#x2F;push.js&#39;;</span><br><span class="line">      &#125;</span><br><span class="line">      var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0];</span><br><span class="line">      s.parentNode.insertBefore(bp, s);</span><br><span class="line">  &#125;)();</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line">&lt;!- 百度自动推送方式提交结束 --&gt;</span><br></pre></td></tr></table></figure><p>即完成了新增博客文章页面（不包括其他页面）的自动推送方式提交。</p><h2 id="链接提交"><a href="#链接提交" class="headerlink" title="链接提交"></a>链接提交</h2><p>百度站长平台的链接提交方式分为自动提交和手动提交两种，此处只讲自动提交，手动提交按照要求操作即可。</p><h3 id="主动推送"><a href="#主动推送" class="headerlink" title="主动推送"></a>主动推送</h3><h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><p>主动推送最为快速的提交方式，是被百度收录最快的推送方式。主动推送可以通过安装插件实现：</p><p><strong>首先安装插件：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-baidu-url-submit --save</span><br></pre></td></tr></table></figure><p>修改站点根目录下的配置文件_config.yml，添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">baidu_url_submit:</span><br><span class="line">  count: 20 ## 提交最新的20个链接</span><br><span class="line">  host: www.dongshuyan.com ## 百度站长平台中注册的域名</span><br><span class="line">  token:  ## 16位准入秘钥</span><br><span class="line">  path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里</span><br></pre></td></tr></table></figure><p><strong>准入秘钥获取</strong>:</p><p>在如下图的网址中：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/e8d810a8-af7b-40ce-8a7d-1db0e61a8a14-3316715.jpg" alt="img"></p><p>下拉，找到这里：<br><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/a94c8872-d402-4ce3-afc2-ea2705e95aeb-3316715.jpg" alt="img"><br>点击进去就是准入秘钥。</p><p><strong>检查</strong>:</p><p>其次，记得查看根目录下的_config.yml文件中url的值， 必须包含是百度站长平台注册的域名， 比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;</span><br><span class="line">url: http:&#x2F;&#x2F;dongshuyan.com</span><br><span class="line">root: &#x2F;</span><br><span class="line">permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure><p><strong>最后，加入新的deployer</strong></p><p>最后，加入新的deployer:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- type: git ## 这是我原来的deployer</span><br><span class="line">  repo:</span><br><span class="line">  branch:</span><br><span class="line">- type: baidu_url_submitter ## 添加这里内容即可</span><br></pre></td></tr></table></figure><p>这里的”-“,必不可少！ 否则报错。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>其主动推送的实现原理如下：<br>新链接的产生， hexo generate 会产生一个文本文件，里面包含最新的链接<br>新链接的提交， hexo deploy 会从上述文件中读取链接，提交至百度搜索引擎</p><h3 id="自动推送"><a href="#自动推送" class="headerlink" title="自动推送"></a>自动推送</h3><p>装自动推送JS代码的网页，在页面被访问时，页面URL将立即被推送给百度。</p><p>修改主题目录下的layout/post.ejs文件，末尾添加自动推送代码，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">(function()&#123;</span><br><span class="line">    var bp &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">    var curProtocol &#x3D; window.location.protocol.split(&#39;:&#39;)[0];</span><br><span class="line">    if (curProtocol &#x3D;&#x3D;&#x3D; &#39;https&#39;) &#123;</span><br><span class="line">        bp.src &#x3D; &#39;https:&#x2F;&#x2F;zz.bdstatic.com&#x2F;linksubmit&#x2F;push.js&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        bp.src &#x3D; &#39;http:&#x2F;&#x2F;push.zhanzhang.baidu.com&#x2F;push.js&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0];</span><br><span class="line">    s.parentNode.insertBefore(bp, s);</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>出处：(<a href="http://dongshuyan.com/2019/05/24/hexo博客注意事项/#14-Hexo添加百度统计" target="_blank" rel="noopener">http://dongshuyan.com/2019/05/24/hexo博客注意事项/#14-Hexo添加百度统计</a>)</p><h2 id="添加百度统计和谷歌统计代码"><a href="#添加百度统计和谷歌统计代码" class="headerlink" title="添加百度统计和谷歌统计代码"></a>添加百度统计和谷歌统计代码</h2><h3 id="百度统计"><a href="#百度统计" class="headerlink" title="百度统计"></a>百度统计</h3><p>首先打开<a href="https://ziyuan.baidu.com/site/index" target="_blank" rel="noopener">百度站长平台</a>，注册账户。</p><p>然后登陆 百度统计》管理》新增站点。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200303193303556.png" alt="image-20200303193303556"></p><p>然后复制生成的代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> _hmt = _hmt || [];</span></span><br><span class="line"><span class="actionscript">(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> hm = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span></span><br><span class="line"><span class="actionscript">  hm.src = <span class="string">"https://hm.baidu.com/hm.js?这里是你的专属字符串"</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> s = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"script"</span>)[<span class="number">0</span>]; </span></span><br><span class="line">  s.parentNode.insertBefore(hm, s);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这一段代码，最重要的就是你那段专属的字符串。</p><p><strong>开始配置：</strong></p><p>首先，打开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">themes&#x2F;yilia&#x2F;_config.yml</span><br></pre></td></tr></table></figure><p>里面</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">baidu_analytics:</span> <span class="string">''</span></span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">baidu_analytics:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>然后，打开：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">themes/yilia/layout/_partial/baidu-analytics.ejs</span><br></pre></td></tr></table></figure><p>你会看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (theme.baidu_analytics)&#123; %&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var _hmt &#x3D; _hmt || [];</span><br><span class="line">(function() &#123;</span><br><span class="line">var hm &#x3D; document.createElement(&quot;script&quot;);</span><br><span class="line">hm.src &#x3D; &quot;https:&#x2F;&#x2F;hm.baidu.com&#x2F;hm.js?&lt;%&#x3D; theme.baidu_analytics %&gt;&quot;;</span><br><span class="line">var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0]; </span><br><span class="line">s.parentNode.insertBefore(hm, s);</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>这里，我们直接用你的<code>专属字符串</code>去替换<code>&lt;%= theme.baidu_analytics %&gt;</code>就行了。替换后为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (theme.baidu_analytics)&#123; %&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var _hmt &#x3D; _hmt || [];</span><br><span class="line">(function() &#123;</span><br><span class="line">var hm &#x3D; document.createElement(&quot;script&quot;);</span><br><span class="line">hm.src &#x3D; &quot;https:&#x2F;&#x2F;hm.baidu.com&#x2F;hm.js?你的专属字符串&quot;;</span><br><span class="line">var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0]; </span><br><span class="line">s.parentNode.insertBefore(hm, s);</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><h3 id="谷歌统计"><a href="#谷歌统计" class="headerlink" title="谷歌统计"></a>谷歌统计</h3><p>参考：<a href="http://yansheng836.coding.me/article/eda67a25.html" target="_blank" rel="noopener">http://yansheng836.coding.me/article/eda67a25.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Yilia主题配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo之Matery主题配置</title>
      <link href="/archives/514b.html"/>
      <url>/archives/514b.html</url>
      
        <content type="html"><![CDATA[<p>最近的三天一直在折腾hexo框架的博客，先是使用yilia主题，但是用来一天觉得我不适合这个主题，随即看到了matery主题。</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E4%B9%8BMatery%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/qqpyimg1583400714.jpg" alt="img"></p><p>今天又折腾了白天一天时间，我这个是直接克隆的<a href="https://sunhwee.com/about" target="_blank" rel="noopener">hongweiの博客</a>，这是一个大佬呀，还要多多向他学习。</p><p>然后，只把一些简单的配置弄好了。现在梳理一下：</p><p><strong>已完成的配置：</strong></p><ul><li><input checked disabled type="checkbox"><p>404页面</p></li><li><input checked disabled type="checkbox"><p>简历</p></li><li><input checked disabled type="checkbox"><p>建站时间</p></li><li><input checked disabled type="checkbox"><p>设置个人域名（已购买域名，单还需要审核，明天再去弄。）</p></li><li><input checked disabled type="checkbox"><p>不蒜子设置</p></li></ul><ul><li><input checked disabled type="checkbox"> 添加评论插件</li><li><input checked disabled type="checkbox"> 网站SEO优化</li><li><input disabled type="checkbox"> 百度收录站点 1.验证网站所有权</li><li><input disabled type="checkbox"> 谷歌收录站点</li><li><input checked disabled type="checkbox"> 优化你的URL</li><li><input disabled type="checkbox"> 添加代码块复制功能</li><li><input disabled type="checkbox"> 添加文章更新时间功能</li></ul><p><strong>非必要配置（已经取消）：</strong></p><ul><li><input checked disabled type="checkbox"><p>添加网易云音乐BGM</p></li><li><input checked disabled type="checkbox"><p>添加鼠标点击烟花爆炸效果</p></li><li><input checked disabled type="checkbox"><p>添加页面樱花飘落效果</p></li><li><input checked disabled type="checkbox"><p>添加鼠标点击文字特效</p></li><li><input checked disabled type="checkbox"><p>添加页面雪花飘落动效</p></li><li><input checked disabled type="checkbox"><p>优化网站加载速度</p></li><li><input checked disabled type="checkbox"><p>数学公式渲染和代码高亮</p></li><li><input disabled type="checkbox"><p>其他搜索引擎收录你的站点</p></li><li><input disabled type="checkbox"><p>添加动漫人物</p></li><li><input disabled type="checkbox"><p>增加emoji支持</p></li><li><input disabled type="checkbox"><p>添加博客动态标签</p></li><li><input disabled type="checkbox"><p>添加博客天气插件</p></li><li><input checked disabled type="checkbox"><p>GitHub&amp;coding pages双部署</p></li><li><input checked disabled type="checkbox"><p>修复Valine评论的头像不显示问题</p></li></ul><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h2><p>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 <a href="https://github.com/ele828/hexo-prism-plugin" target="_blank" rel="noopener">hexo-prism-plugin</a> 的 Hexo 插件来做代码高亮，安装命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -S hexo-prism-plugin</span><br></pre></td></tr></table></figure><p>然后，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并新增 <code>prism</code> 插件相关的配置，主要配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">prism_plugin:</span></span><br><span class="line">  <span class="attr">mode:</span> <span class="string">'preprocess'</span>    <span class="comment"># realtime/preprocess</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">'tomorrow'</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">false</span>    <span class="comment"># default false</span></span><br><span class="line">  <span class="attr">custom_css:</span></span><br></pre></td></tr></table></figure><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><h2 id="1、Cannot-set-property-39-lastIndex-39-of-undefined"><a href="#1、Cannot-set-property-39-lastIndex-39-of-undefined" class="headerlink" title="1、Cannot set property &#39;lastIndex&#39; of undefined"></a>1、<code>Cannot set property &#39;lastIndex&#39; of undefined</code></h2><p>运行<code>hexo g</code>出现Cannot set property ‘lastIndex’ of undefined</p><p>解决方法：修改配置文件的 _config.yml，注意不是主题里面的配置文件，把 <code>auto_detect</code> 设置为<code>false</code> 即可。</p><h2 id="2、代码显示异常"><a href="#2、代码显示异常" class="headerlink" title="2、代码显示异常"></a>2、代码显示异常</h2><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E4%B9%8BMatery%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/image-20200307011749942.png" alt="image-20200307011749942"></p><p>解决方法：</p><ul><li>首先，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>。</li></ul><p>然后<code>hexo clean</code>&amp; <code>hexo g</code>&amp; <code>hexo s</code></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E4%B9%8BMatery%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/image-20200307012129958.png" alt="image-20200307012129958"></p><p>好了。</p><p><strong>注</strong>：作者给的解决方案比我这个要多一步，我在这里贴出来，供大家参考。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E4%B9%8BMatery%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/image-20200307012313539.png" alt="image-20200307012313539"></p><h2 id="3、目录定位内容有偏差"><a href="#3、目录定位内容有偏差" class="headerlink" title="3、目录定位内容有偏差"></a>3、目录定位内容有偏差</h2><p>我反复的去测试，后来发现，可能有两个原因会导致这个问题的出现：</p><ol><li><p>网页没有刷新完全的时候，点击目录他有可能不会跳转。</p><p><strong>解决方法</strong>：</p><ul><li>法一：等待网页刷新完全。</li><li>法二：手动的去停止网页的刷新（这个来的比较快一点，哈哈）</li></ul></li><li><p>你的文章的标题格式有问题，比如，我用Typora软件来写文章，这个软件就是所写即所得。但是这样你就不容易发现格式细节处的错误。</p><p><u>错误示范</u>：</p><p>我先写了一个一级标题，<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E4%B9%8BMatery%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/image-20200308024217913.png" alt="image-20200308024217913"></p><p>然后，我又点击引用，就变成这样了：<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E4%B9%8BMatery%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/image-20200308024438170.png" alt="image-20200308024438170">这种写法在Typora中，是不会认为它是一级标题的。</p><p>我们打开源码查看他的格式：<code>&gt; # 配置</code>。他的格式是这样的。就是这里<u>出错了</u>，在matery主题中这样写它仍然会识别成标题，然后就导致从这个标题开始后面的标题，在你点击这些标题的时候，它会定位错误。</p><p><strong>解决方法</strong>：我们一定要遵循Markdown格式的语法，一定要，一定要。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matery主题配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tsinghua_Online_Judge_练习</title>
      <link href="/archives/d4fa.html"/>
      <url>/archives/d4fa.html</url>
      
        <content type="html"><![CDATA[<h1 id="CG2017-PA1-1-Convex-Hull-凸包"><a href="#CG2017-PA1-1-Convex-Hull-凸包" class="headerlink" title="CG2017 PA1-1 Convex Hull (凸包)"></a>CG2017 PA1-1 Convex Hull (凸包)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><hr><p>Description (描述)</p><p>After learning Chapter 1, you must have mastered the convex hull very well. Yes, convex hull is at the kernel of computational geometry and serves as a fundamental geometric structure. That’s why you are asked to implement such an algorithm as your first programming assignments.</p><p>Specifically, given a set of points in the plane, please construct the convex hull and output an encoded description of all the extreme points.</p><p>经过了第一章的学习，想必你对于凸包的认识已经非常深刻。是的，凸包是计算几何的核心问题，也是一种基础性的几何结构。因此你的第一项编程任务，就是来实现这样的一个算法。</p><p>具体地，对于平面上的任意一组点，请构造出对应的凸包，并在经过编码转换之后输出所有极点的信息。</p><p>Input (输入)</p><p>The first line is an integer <strong>n &gt; 0</strong>, i.e., the total number of input points.</p><p>The k-th of the following <strong>n</strong> lines gives the k-th point:</p><p>pk = (xk, yk), k = 1, 2, …, n</p><p>Both xk and yk here are integers and they are delimited by a space.</p><p>第一行是一个正整数首行为一个正整数<strong>n &gt; 0</strong>，即输入点的总数。</p><p>随后<strong>n</strong>行中的第k行给出第k个点：</p><p>pk = (xk, yk), k = 1, 2, …, n</p><p>这里，xk与yk均为整数，且二者之间以空格分隔。</p><p>Output (输出)</p><p>Let <strong>{ s1, s2, …, sh }</strong> be the indices of all the extreme points, <strong>h ≤ n</strong>. Output the following integer as your solution:</p><p>( s1 * s2 * s3 * … * sh * h ) mod (n + 1)</p><p>若 <strong>{ s1, s2, …, sh }</strong> 为所有极点的编号, <strong>h ≤ n</strong>，则作为你的解答，请输出以下整数：</p><p>( s1 * s2 * s3 * … * sh * h ) mod (n + 1)</p><p>Sample Input (输入样例)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line"></span><br><span class="line">10</span><br><span class="line">7 9</span><br><span class="line">-8 -1</span><br><span class="line">-3 -1</span><br><span class="line">1 4</span><br><span class="line">-3 9</span><br><span class="line">6 -4</span><br><span class="line">7 5</span><br><span class="line">6 6</span><br><span class="line">-6 10</span><br><span class="line">0 8</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://dsa.cs.tsinghua.edu.cn/oj/attachment/9f51/9f516d08f38b1bbde0ab6aec6bfccb92211dc802.png" alt="img"></p><p>Sample Output (输出样例)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"></span><br><span class="line">7   &#x2F;&#x2F; ( 9 x 2 x 6 x 7 x 1 x 5 ) % (10 + 1)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://dsa.cs.tsinghua.edu.cn/oj/attachment/cb9d/cb9dbfbef90751cc0bc372041f543118dc6c9f1a.png" alt="img"></p><p>Limitation (限制)</p><ul><li><p>3 ≤ <strong>n</strong> ≤ 10^5</p></li><li><p>Each coordinate of the points is an integer from (-10^5, 10^5). There are no duplicated points. Each point is selected uniformly randomly in (-10^5, 10^5) x (-10^5, 10^5).</p></li><li><p>All points on extreme edges are regarded as extreme points and hence should be included in your solution.</p></li><li><p>Time Limit: 2 sec</p></li><li><p>Space Limit: 512 MB</p></li><li><p>3 ≤ <strong>n</strong> ≤ 10^5</p></li><li><p>所有点的坐标均为范围(-10^5, 10^5)内的整数，且没有重合点。每个点在(-10^5, 10^5) x (-10^5, 10^5)范围内均匀随机选取</p></li><li><p>极边上的所有点均被视作极点，故在输出时亦不得遗漏</p></li><li><p>时间限制：2 sec</p></li><li><p>空间限制：512 MB</p></li></ul><p>Hint (提示)</p><p>Use the CH algorithms presented in the lectures.</p><p>课程中讲解过的凸包算法</p><h2 id="Graham-Scan算法解答"><a href="#Graham-Scan算法解答" class="headerlink" title="Graham Scan算法解答"></a><a href="https://renjikai.com/cg2017-pa1-1-convex-hull/" target="_blank" rel="noopener">Graham Scan算法解答</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x, y, id;</span><br><span class="line">    <span class="built_in">point</span>() :x(<span class="number">0</span>), y(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">point</span>(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y) :x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> ==(<span class="keyword">const</span> <span class="built_in">point</span>&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x == p.x &amp;&amp; y == p.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;PP; <span class="comment">//PP: Polar Point</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">point</span>&gt; points;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">area2</span><span class="params">(<span class="built_in">point</span> p, <span class="built_in">point</span> q, <span class="built_in">point</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    |p.x p.y 1|</span></span><br><span class="line"><span class="comment">    |q.x q.y 1| == 2*DirectedTriangleArea(p,q,s)</span></span><br><span class="line"><span class="comment">    |s.x s.y 1|</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> p.x * q.y - s.x * q.y</span><br><span class="line">        + q.x * s.y - q.x * p.y</span><br><span class="line">        + s.x * p.y - p.x * s.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">toLeftTest</span><span class="params">(<span class="built_in">point</span> p, <span class="built_in">point</span> q, <span class="built_in">point</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//When return value large than 0, S is on the left side of ray PQ</span></span><br><span class="line">    <span class="keyword">return</span> area2(p, q, s) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">toLeftTest2</span><span class="params">(<span class="built_in">point</span> p, <span class="built_in">point</span> q, <span class="built_in">point</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//When return value large than 0, S is on the left side of ray PQ</span></span><br><span class="line">    <span class="keyword">return</span> area2(p, q, s) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">point</span>&amp; p1, <span class="keyword">const</span> <span class="built_in">point</span>&amp; p2)</span> </span>&#123; <span class="comment">// Sort according to polar angle</span></span><br><span class="line">    <span class="keyword">return</span> PP == p1 || !(PP == p2) &amp;&amp; toLeftTest(PP, p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">point</span> <span class="title">LTL</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">point</span>&gt;&amp; points)</span> </span>&#123; <span class="comment">//Lowest then leftmost</span></span><br><span class="line">    <span class="built_in">point</span> ltl = points[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (points[i].y &lt; ltl.y || points[i].y == ltl.y &amp;&amp; points[i].x &lt; ltl.x)</span><br><span class="line">            ltl = points[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ltl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">point</span>&gt; <span class="title">grahamScan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PP = LTL(points);</span><br><span class="line">    sort(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">point</span>&gt; S, T;</span><br><span class="line">    S.push_back(points[<span class="number">0</span>]); S.push_back(points[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = points.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; <span class="number">1</span>; i--)T.push_back(points[i]);</span><br><span class="line">    <span class="keyword">while</span> (!T.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (toLeftTest2(S[S.<span class="built_in">size</span>() - <span class="number">2</span>], S[S.<span class="built_in">size</span>() - <span class="number">1</span>], T[T.<span class="built_in">size</span>() - <span class="number">1</span>])) &#123;</span><br><span class="line">            S.push_back(T[T.<span class="built_in">size</span>() - <span class="number">1</span>]);</span><br><span class="line">            T.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> S.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">point</span> tmp;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tmp.x &gt;&gt; tmp.y;</span><br><span class="line">        tmp.id = i;</span><br><span class="line">        points.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">point</span>&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (points.<span class="built_in">size</span>() &gt; <span class="number">2</span>)result = grahamScan();</span><br><span class="line">    <span class="keyword">else</span> result = points;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; result[i].id &lt;&lt; endl;//debug</span></span><br><span class="line">        res = ((res % (n + <span class="number">1</span>)) * (result[i].id % (n + <span class="number">1</span>))) % (n + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    res = ((res % (n + <span class="number">1</span>)) * (result.<span class="built_in">size</span>() % (n + <span class="number">1</span>))) % (n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分数：92.5<br>使用Graham Scan算法。凸包板子题。</p>]]></content>
      
      
      <categories>
          
          <category> OJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>32、黑客&amp;攻击</title>
      <link href="/archives/622.html"/>
      <url>/archives/622.html</url>
      
        <content type="html"><![CDATA[<p>黑客入侵最常见的方式不是通过技术，而是欺骗别人，这个称为<strong>社会工程学（Social Engineering）</strong>，通过欺骗别人来让人泄露秘密，或让人配置电脑系统来变得易于攻击。最常见的攻击是<strong>网络钓鱼（Phishing）</strong>，其次还有<strong>假托（Pretexting）</strong>，攻击者给某个公司打电话，假装是IT部门的人，攻击者的第一通电话一般会叫人转接，这样另一个接的时候，电话看起来就像内部的，然后让别人把电脑配置得易于入侵，或者让他们泄露机密信息，比如密码或网络配置。</p><a id="more"></a><p>邮件里带<strong>木马（trojan horse）</strong>也是常见手段，木马通常会伪装成无害的东西，比如照片或发票，但实际上是恶意软件，有的会偷数据，有的会加密文件。</p><p>如果攻击者无法用木马或电话欺骗，攻击者只能被迫使用其他手段，方法之一就是暴力破解，尝试所有可能的密码，直到进入系统，大多数现代系统会加长等待时间来抵御这种攻击，每次失败就加长等待时间，甚至超过一定次数后，完全封锁。现在出现了一种攻破方法称为<strong>NAND镜像</strong>，如果能物理接触到电脑，可以往内存上接几根线，复制整个内存，然后暴力尝试密码，直到设备让你等待。这时只要把复制的内容覆盖掉内存，本质上重置了内存，就不用等待，可以继续尝试密码。</p><p>如果无法物理接触到设备，就需要远程攻击，比如通过互联网，这一般需要攻击者利用系统漏洞，来获得某些能力或访问权限，称为<strong>漏洞利用（Exploit）</strong>。一种常见的漏洞利用叫<strong>缓冲区溢出（Buffer Overflow）</strong>，这里的缓冲区是指预留的一块内存空间，比如我们在系统登录界面输入用户名和密码，而系统是用缓冲区来存储输入值的，假设缓冲区大小为10，并且缓冲区前后肯定还有其他数据，当用户输入用户名和密码时，这些值就会被复制到缓冲区中来进行验证，而该方法会溢出缓冲区，比如输入超过10个字符的密码，会覆盖掉相邻的数据，有时会让程序或系统崩溃，因为重要值被垃圾数据覆盖掉了。这里只是让系统崩溃，但是攻击者可以输入有意义的新值到程序的内存中，比如把<code>is_admin</code>标志位的值改为true，有了任意修改内存的能力，黑客就可以绕过登录这类东西，甚至使用那个程序劫持整个系统。</p><p>有许多方法阻止缓冲区溢出，最简单的方法就是复制到内存之前先检查长度，称为<strong>边界检查（Bounds checking</strong>），许多现代编程语言都自带边界检查，程序也会随机存放变量在内存中的位置，这样黑客就不知道应该覆盖内存的哪部分，使得更容易让程序崩溃，而不是获得访问权限。程序也可以在缓冲区后，预留一些不用的空间，然后跟踪里面的值，看是否发生变化，来判断是否有攻击，这些不用的内存空间称为<strong>金丝雀（Canaries）</strong>。</p><p>另一种经典手段是<strong>代码注入（Code Injection）</strong>，最常用于攻击用数据库的网站。假设网页上有登录提示，当用户点击“登录”，输入文本就会发送服务器，服务器就会运行代码，检查用户名是否存在，如果存在就看密码是否匹配。为此服务器会执行一段sql查询代码，比如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">password</span> <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> username=<span class="string">'___'</span>;</span><br></pre></td></tr></table></figure><p>这里语句就是要从<code>users</code>表中查找<code>username</code>为<code>___</code>的密码<code>password</code>。 这里的<code>___</code>就是用户输入的用户名。由此攻击者就能把sql命令输入到用户名中，比如<code>whatever&#39;;DROP TABLE users;&#39;</code>，这时上面的查询语句就会变成</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">password</span> <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> username=<span class="string">'whatever'</span>;<span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">users</span>;';</span><br></pre></td></tr></table></figure><p>如果服务器存在用户名<code>wharever</code>，数据库就会返回密码， 当然我们无法得知密码是什么，所以服务器会拒绝我们；如果不存在用户名<code>wharever</code>，服务器会返回空密码或者直接错误，服务器也会拒绝我们。 但是我们关心的是后面的代码<code>DROP TABLE users;</code><strong>这个是我们注入的命令</strong>，这个命令是删掉users这张表。如今几乎所有服务器都会防御这种手段。</p><p>程序员需要认识到从外界输入的信息都是危险的，必须要好好检查，很多用户名和密码表单，不会让你直接输入特殊符号，比如分号或括号，来作为第一道防御。好的服务器也会清理输入，比如修改或删除特殊字符，然后才放到数据库查询语句中。</p><p>当软件制造者不知道的新漏洞被发现时，称为<strong>0day漏洞（Zero Day Vulnerability）</strong>，黑客就会抢在白帽程序员做出补丁之前尽可能利用漏洞。</p><p>如果有足够多的电脑有漏洞，让恶意程序可以自动地在电脑之间互相传播，称为<strong>蠕虫（Worm）</strong>。如果黑客拿下大量电脑，这些电脑可以组成<strong>僵尸网络（Botnet）</strong>，可以用于很多目的，比如发大量垃圾邮件等，用别人电脑的计算能力来挖比特币，或发起DDOS来攻击服务器。DDOS就是僵尸网络里的所有电脑发一大堆垃圾信息到服务器上，造成服务器的阻塞。</p><center>完~~~</center>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《计算机科学速成课》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 博客框架搭建</title>
      <link href="/archives/7f7e.html"/>
      <url>/archives/7f7e.html</url>
      
        <content type="html"><![CDATA[<center>搭建这个博客起因是2020年的二月末的某一天晚上，无聊逛B站，然后就看到了一个博客搭建教程，随机就有了这一系列的文章了。</center><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我的是在windows操作系统上面，在其他的系统上面大同小异。也参考了很多文章及视频教程。主要参考的是：</p><p><a href="https://www.codesheep.cn" target="_blank" rel="noopener"><strong>程序羊</strong></a>的视频：<a href="https://www.bilibili.com/video/av44544186?from=search&amp;seid=12981624311298276946" target="_blank" rel="noopener">https://www.bilibili.com/video/av44544186?from=search&amp;seid=12981624311298276946</a></p><p>文章：</p><ul><li><p><a href="https://ouwen666.gitee.io/2020/01/29/Hexo+Gitee搭建个人博客" target="_blank" rel="noopener">https://ouwen666.gitee.io/2020/01/29/Hexo+Gitee搭建个人博客</a></p><p>作者部署的是gitee</p></li><li><p><a href="https://godweiyang.com/2018/04/13/hexo-blog/#toc-heading-6" target="_blank" rel="noopener">https://godweiyang.com/2018/04/13/hexo-blog/#toc-heading-6</a></p><p>含有个性化配置</p></li></ul><p><strong>注</strong>：文中的指令都是在<code>cmd</code>（Windows中的命令提示符）中完成的。如果在这之前电脑上就已经安装了<code>Git bash</code>，那么也可以在<code>Git bash</code>中运行指令。</p><h2 id="下面会用得到的命令"><a href="#下面会用得到的命令" class="headerlink" title="下面会用得到的命令"></a>下面会用得到的命令</h2><ul><li><p><code>npm install</code>=<code>npm i</code>。在git clone项目的时候，项目文件中并没有 node_modules文件夹，项目的依赖文件可能很大。直接执行，npm会根据package.json配置文件中的依赖配置下载安装。</p></li><li><p><code>-global</code>=<code>-g</code>，全局安装，安装后的包位于系统预设目录下</p></li><li><p><code>--save</code>=<code>-S</code>，安装的包将写入package.json里面的dependencies，dependencies：生产环境需要依赖的库</p></li></ul><h1 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h1><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>博客框架<code>Hexo</code>是基于<code>Node.js</code>制作的静态博客，我们待会要用到Node.js里面的<a href="https://www.npmjs.cn/" target="_blank" rel="noopener">npm</a>(node package manager)包管理器来安装插件。</p><p>可以点击<a href="https://nodejs.org/en/" target="_blank" rel="noopener">这里</a>进入其官网。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200301192702158.png" alt="image-20200301192702158"></p><p>进入之后，按照操作系统进行下载安装。如上图是Windows系统64位的版本，上面官方推荐下载的版本。</p><p>安装选项就按默认的，一直点击<code>Next</code>。</p><p>然后，检验是否安装成功：用<code>Win+R</code>命令打开命令提示符，输入<code>node -v</code> 和<code>npm -v</code> ，出现版本号，则说明安装成功。</p><h3 id="添加cnpm"><a href="#添加cnpm" class="headerlink" title="添加cnpm"></a>添加cnpm</h3><p><strong>注</strong>：因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，如果npm的服务器在中国就好了，所以我们乐于分享的淘宝团队干了这事。来自官网：“这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。”</p><p>所以我们可以利用<code>npm</code>安装<code>cnpm</code>，再<code>cmd</code>中输入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install cnpm -g –registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>再输入：<code>cnpm -v</code>来检验是否安装成功。</p><p>此时，假设我们<code>Node.js</code>安装成功。</p><h2 id="安装Hexo框架"><a href="#安装Hexo框架" class="headerlink" title="安装Hexo框架"></a>安装Hexo框架</h2><p>我们要利用<code>Hexo</code>框架模型来搭建我们的博客。点击<a href="https://hexo.io/" target="_blank" rel="noopener">这里</a>可以进入其官网。下载该框架也仍然是在<code>cmd</code>（Windows中的“命令提示符”）中输入指令完成的。</p><ol><li><p>在上一步我们安装了<code>cnpm</code>，现在我们要用它来安装<code>hexo</code>，用<code>cnpm</code>安装的速度更快一些，也可以用<code>npm</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>检验是否安装成功，当运行之后出现版本号则安装成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><p>现在，我们的<code>Hexo</code>框架已经安装成功了。</p></li></ol><h3 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h3><p>想要看到博客运行起来，我们现在还需要对<code>Hexo</code>框架进行初始化。</p><p>在你的电脑上找一个合适的位置，创建一个文件夹，名字可以随便取，可以用Blog等等的名字，随个人喜好取名。为了便于演示，假设你取的名字叫做：<code>blog</code></p><p>注意，初始化是在我们创建的这个<code>blog</code>文件夹中初始化的，所以，我们的命令提示符（cmd）左边的路径要在这个<code>blog</code>文件夹中。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200301215807657.png" alt="image-20200301215807657"></p><center>进入刚刚创建的文件夹中</center>然后，在输入指令 ：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>初始化完成后，我们的<code>blog</code>文件夹中，就会生成这些文件：</p><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li>_config.yml: 博客的配置文件</li></ul><p>在安装一些必要的包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>初始化完成，在打开<code>hexo</code>服务器：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><p>我们，打开浏览器，输入：localhost:4000，就可以看到你的博客的雏形已经好了。</p><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>加入你觉得这个主题你不喜欢，想要找一个其他的主题，你可以进入Hexo的官网的<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题</a>板块，来选择你喜欢的主题：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200301221159332.png" alt="image-20200301221159332"></p><p>假如，你想更换为<code>3-hexo</code>，那就点击它，会跳转到该主题的创作者的GitHub上：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200301221422653.png" alt="image-20200301221422653"></p><p>安装<code>3-hexo</code>主题，其中命令的<code>themes/3-hexo</code>指的是该主题的安装位置：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/yelog/hexo-theme-3-hexo.git themes/3-hexo</span><br></pre></td></tr></table></figure><p>安装完之后，我们需要运行：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean          # 清除所有记录 </span><br><span class="line">$ hexo generate       # 生成静态网页 简写：hexo g</span><br><span class="line">$ hexo server         # 启动服务 简写：hexo s</span><br></pre></td></tr></table></figure><p>然后，我们就能在本地localhost:4000中，查看修改好的主题了。</p><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>如果你不想只在本地上查看你的博客，也想有自己的博客网址链接，那我们可以下载Git，把博客内容部署到<code>GitHub</code>或者<code>gitee</code>上面。我们这里以GitHub为例。</p><p>Git的官网点击<a href="https://git-scm.com/" target="_blank" rel="noopener">这里</a>。然后按照你的电脑的操作系统下载相应的版本。安装选项还是全部默认，只不过最后一步添加路径时选择<code>Use Git from the Windows Command Prompt</code>，这样我们就可以直接在命令提示符里打开git了。</p><p>安装完成后在命令提示符中输入<code>git --version</code>验证是否安装成功。</p><h3 id="GitHub账号"><a href="#GitHub账号" class="headerlink" title="GitHub账号"></a>GitHub账号</h3><p>如果你没有GitHub账号，我们现在去创建一个吧。点击<a href="https://github.com/" target="_blank" rel="noopener">这里</a>创建。创建完成之后，我们新建一个github仓库：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200301223129140.png" alt="image-20200301223129140"></p><p>注意你的仓库名字不要随便起，待会我们要用到。加入你GitHub名字叫“AAA”，那么仓库个名字就一定是：<code>AAA.github.io</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200301223729456.png" alt="image-20200301223729456"></p><h1 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h1><h2 id="将博客部署在github中"><a href="#将博客部署在github中" class="headerlink" title="将博客部署在github中"></a>将博客部署在github中</h2><p>目前，还不能部署到GitHub上。还需要下载<code>hexo-deployer-git</code>插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install hexo-deployer-git --save  <span class="comment">#通过cpnm安装git插件</span></span><br></pre></td></tr></table></figure><p>如果，你是刚刚才下载的Git，则还需要设置你的姓名和邮箱：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"Firstname Lastname"</span> // 名字使用英文输入</span><br><span class="line">git config --global user.email <span class="string">"your_email@example.com"</span></span><br></pre></td></tr></table></figure><p>还有你的SSH Key，创建公开密钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><p>​ 把生成的密钥添加到GitHub中去：</p><ol><li>找到生成的密钥：如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，我的在：<code>C:\Users\xxxx\.ssh</code>（xxxx是我的一个目录）。里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是<strong>私钥</strong>，不能泄露出去，<code>id_rsa.pub</code>是<strong>公钥</strong>，可以放心地告诉任何人。</li><li>在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个SSH，名字随便，把公钥复制进去。</li></ol><p>到这里，我们的git与远程的GitHub已经建立起关系了。</p><p>我们还需要把<code>blog</code>文件夹中的设置文件，即：<code>_config.yml</code>，将最后一行进行修改,：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: https://github.com/longlongqin/longlongqin.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>​ repository修改为你自己的github项目地址，在实际操作过程中，repository: <a href="mailto:git@github.com">git@github.com</a>:longlongqin/longlongqin.github.io.git,也是可以的。</p><p>修改之后，我们才能部署到GitHub上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deployer</span><br><span class="line"><span class="comment">## 初次使用这个命令，需要输入github的用户名username和密码password</span></span><br></pre></td></tr></table></figure><p>​ 这里，就是利用刚下载的插件：<code>hexo-deployer-git</code></p><p>现在我们可以访问我们在github服务器上的博客网址，网址就是我们刚刚创建仓库的名字，比如我的仓库名是：<code>longlongqin.github.io</code>，我们复制粘贴它到浏览器，然后你就可以看到你的博客内容了。😊</p><h2 id="Git提交到多个仓库"><a href="#Git提交到多个仓库" class="headerlink" title="Git提交到多个仓库"></a>Git提交到多个仓库</h2><p><a href="https://yuxiang.ren/2017/08/25/hexo博客自动部署到多台服务器/" target="_blank" rel="noopener">https://yuxiang.ren/2017/08/25/hexo%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%88%B0%E5%A4%9A%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/</a></p><h2 id="部署在gitee"><a href="#部署在gitee" class="headerlink" title="部署在gitee"></a>部署在gitee</h2><h3 id="部署在gitee上的坑"><a href="#部署在gitee上的坑" class="headerlink" title="部署在gitee上的坑"></a>部署在gitee上的坑</h3><p>在gitee上面，和在GitHub上面部署差不多，但是有些地方我们还是要注意的。</p><h4 id="仓库命名问题"><a href="#仓库命名问题" class="headerlink" title="仓库命名问题"></a>仓库命名问题</h4><p>在创建gitee仓库时，最好也是将仓库名字命名为你的账号的用户名，比如我的：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200302144640624.png" alt="image-20200302144640624"></p><p>​ 当然，你也可以命名为其他名字，但是换成其他名字之后，可能会带来一系列其他的问题，比如图片无法显示。其实我之前命名成其他名字，就出现了很大的问题：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200302015639908.png" alt="image-20200302015639908"></p><p>这种情况是因为，他找不到资源，加载错误：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200302015741200.png" alt="image-20200302015741200"></p><p>熬了一个晚上，终于发现了。在官方文档中有：</p><blockquote><p><strong>网站在子目录的情况</strong></p></blockquote><p>如果你的网站在一个子目录（例如<a href="https://link.jianshu.com/?t=http://example.org/blog" target="_blank" rel="noopener">http://example.org/blog</a>） 设置<code>url</code>为<code>http://example.org/blog</code>并且设置<code>root</code>为<code>/blog/</code></p><p>说来也奇怪，在GitHub上面，和本地运行的时候都是好好的。就是在gitee上面出错了。o(︶︿︶)o 唉</p><p>解决它的办法就是：</p><p>​ 将root添加上缺少的那一级目录，即可</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://yoursite.com/child</span></span><br><span class="line"></span><br><span class="line"><span class="attr">root:</span> <span class="string">/blog/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:post_title/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line"></span><br><span class="line"> <span class="attr">trailing_index:</span> <span class="literal">false</span>   <span class="comment"># Set to false to remove trailing 'index.html' from permalinks</span></span><br><span class="line"></span><br><span class="line"> <span class="attr">trailing_html:</span> <span class="literal">true</span>     <span class="comment"># Set to false to remove trailing '.html' from permalinks</span></span><br></pre></td></tr></table></figure><p>这一篇帖子里面也有人遇到了同样的问题，最后也是通过root的修改解决的。：<a href="https://gitee.com/oschina/git-osc/issues/IFVWV?from=project-issue" target="_blank" rel="noopener">https://gitee.com/oschina/git-osc/issues/IFVWV?from=project-issue</a></p><h4 id="gitee-pages刷新"><a href="#gitee-pages刷新" class="headerlink" title="gitee pages刷新"></a>gitee pages刷新</h4><p>除了仓库名字需要注意，我们还需要注意，gitee个人版似乎不能自动刷新，所以你<strong>每次</strong><code>hexo d</code>之后，需要手动的刷新<code>gitee pages</code>，才能显示你新提交的内容。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200302145524039.png" alt="image-20200302145524039"></p><h1 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h1><h2 id="编辑器推荐"><a href="#编辑器推荐" class="headerlink" title="编辑器推荐"></a>编辑器推荐</h2><p>推荐使用<code>Typora</code>这款软件，点击<a href="https://www.typora.io/" target="_blank" rel="noopener">这里</a>进入官网，他可以写Markdown格式的内容，这个软件的方便之处在于直接将markdown语法呈现出其效果，并且已经集成了很多方便的功能，你无需记住插入代码的语法格式，无需记住插入图片的语法格式，这使得我可以专心写博客而无法关心学习markdown语法。有很多md编辑器，他们分成两个界面，一个界面是md源代码，另外一个界面实时更新显示其效果，而Typora是浑然一体的，真正所见即所得，就跟在使用word一样方便。</p><p>不仅如此，它还可以导出PDF、Word、HTML、图片等格式。</p><p>待续……</p><h2 id="图片问题"><a href="#图片问题" class="headerlink" title="图片问题"></a>图片问题</h2><p><a href="http://etrd.org/2017/01/23/hexo中完美插入本地图片/" target="_blank" rel="noopener">http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/</a></p><h1 id="Hexo的操作指令"><a href="#Hexo的操作指令" class="headerlink" title="Hexo的操作指令"></a>Hexo的操作指令</h1><p>我们刚开始，对于<code>Hexo</code>的指令不太熟悉，我们可以在他的官网上去查找相应的操作指令。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200301222120697.png" alt="image-20200301222120697"></p><h2 id="文章的front-matter"><a href="#文章的front-matter" class="headerlink" title="文章的front-matter"></a><a href="https://hexo.io/zh-cn/docs/front-matter" target="_blank" rel="noopener">文章的front-matter</a></h2><h3 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code>的值。</p><table><thead><tr><th align="left">配置选项</th><th align="left">默认值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">title</td><td align="left"><code>Markdown</code> 的文档标题</td><td align="left">文章标题，强烈建议填写此选项</td></tr><tr><td align="left">date</td><td align="left">文档创建时的日期时间</td><td align="left">发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td align="left">author</td><td align="left">根 <code>_config.yml</code>中的 <code>author</code></td><td align="left">文章作者</td></tr><tr><td align="left">img</td><td align="left"><code>featureImages</code>中的某个值</td><td align="left">文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td align="left">top</td><td align="left"><code>true</code></td><td align="left">（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页</td></tr><tr><td align="left">password</td><td align="left">无</td><td align="left">文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td align="left">toc</td><td align="left"><code>true</code></td><td align="left">是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td align="left">mathjax</td><td align="left"><code>false</code></td><td align="left">是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文档中也需要开启才行</td></tr><tr><td align="left">summary</td><td align="left">无</td><td align="left">文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则进程会自动截取文章的部分内容作为摘要</td></tr><tr><td align="left">categories</td><td align="left">无</td><td align="left">文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td align="left">tags</td><td align="left">无</td><td align="left">文章标签，一篇文章可以多个标签</td></tr></tbody></table><p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量，举例来说：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hello</span> <span class="string">World</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2013</span><span class="string">/7/13</span> <span class="number">20</span><span class="string">:46:25</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h3 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a>分类和标签</h3><p>只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而标签没有顺序和层次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">- Diary</span><br><span class="line">tags:</span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br></pre></td></tr></table></figure><blockquote><p><strong>分类方法的分歧</strong></p><p>如果您有过使用 WordPress 的经验，就很容易误解 Hexo 的分类方式。WordPress 支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是 Hexo 不支持指定多个同级分类。下面的指定方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - Diary</span><br><span class="line">  - Life</span><br></pre></td></tr></table></figure><p>会使分类<code>Life</code>成为<code>Diary</code>的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。</p><p>如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">- [Diary, PlayStation]</span><br><span class="line">- [Diary, Games]</span><br><span class="line">- [Life]</span><br></pre></td></tr></table></figure><p>此时这篇文章同时包括三个分类： <code>PlayStation</code> 和 <code>Games</code> 分别都是父分类 <code>Diary</code> 的子分类，同时 <code>Life</code> 是一个没有子分类的分类。</p></blockquote><h3 id="JSON-Front-matter"><a href="#JSON-Front-matter" class="headerlink" title="JSON Front-matter"></a>JSON Front-matter</h3><p>除了 YAML 外，你也可以使用 JSON 来编写 Front-matter，只要将 <code>---</code> 代换成 <code>;;;</code> 即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;title&quot;: &quot;Hello World&quot;,</span><br><span class="line">&quot;date&quot;: &quot;2013&#x2F;7&#x2F;13 20:46:25&quot;</span><br><span class="line">;;;</span><br></pre></td></tr></table></figure><h1 id="配置过程遇到的问题"><a href="#配置过程遇到的问题" class="headerlink" title="配置过程遇到的问题"></a>配置过程遇到的问题</h1><h2 id="Hexo博客中文章图片不显示的坑"><a href="#Hexo博客中文章图片不显示的坑" class="headerlink" title="Hexo博客中文章图片不显示的坑"></a>Hexo博客中文章图片不显示的坑</h2><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/qqpyimg1583424159.gif" alt="img"></p><p>这个是真的坑，搞了好久，终于看到一篇博文，才解决了这个问题。放一下这篇文章的<a href="https://myfavs.win/2019/08/08/%E8%AE%B0%E5%BD%95-Hexo-%E5%9B%BE%E7%89%87%E7%9A%84%E5%9D%91/" target="_blank" rel="noopener">传送门</a>。</p><h2 id="在coding中SSL证书申请失败的坑"><a href="#在coding中SSL证书申请失败的坑" class="headerlink" title="在coding中SSL证书申请失败的坑"></a>在coding中SSL证书申请失败的坑</h2><p>在搭建到coding中步骤其实和在github中比较相似，就是给仓库命名原则的时候需要注意，尽量让仓库名字与你的用户名相同，即和在github中命名规则相似。</p><p>如果你之前都很顺利，那么在SSL证书申请时，需要注意了：你会遇到证书申请一直失败的情况。这是为什么呢？是这样的：</p><ul><li><p>第一次尝试，查资料说是如果之前你已经在github oages上部署了，你自己买的域名也已经解析过了。此时直接在coding pages中申请ssl的话，会失败。</p><p>解决的办法就是：先把用于解析github pages的那两条暂停了，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200306234025834.png" alt="image-20200306234025834"></p></li><li><p>然后，我再试试，还是申请失败。出现类似于下面的错误：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200306234233629.png" alt="image-20200306234233629"></p></li><li><p>继续去查。嗯，找到了，申请失败是因为我的域名在国外无法解析，这是我的DNS设置导致的。</p><p>解决办法：在解析的时候，需要将<strong>线路类型</strong>改成<strong>默认</strong>。去试一试，等待一小会</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200306234452437.png" alt="image-20200306234452437"></p><p>哇，终于申请成功了。</p><p>#Hexo博客备份</p><p>有时候我们外出，自己的电脑没有带，这时候想写博客怎么办。这也是有办法的，就是我们要先备份我们的博客。这里我们可以备份到github或者gitee.</p><p>拿github举例：</p><ul><li><p>首先，我们先要在GitHub上面建立一个仓库，仓库名字自取，仓库是public还是private，按照自己的心情来就好了。</p></li><li><p>然后，我们要在本地关联远程仓库：</p><p>我们进入你的本地博客所在的目录，比如我的在<code>D:\Blog</code>，然后，打开你的Git bash，按顺序输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init    <span class="comment">#初始化本地仓库</span></span><br><span class="line">git remote add origin &lt;你的远程仓库的SSH或HTTPS链接&gt;  <span class="comment">#关联远程仓库（ssh的链接比较快一点）</span></span><br></pre></td></tr></table></figure><p>关联完成，然后我们还需要，将本地的推送到远端，同样，按顺序输入一下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .  <span class="comment">#这个‘.’表示将整个文件夹都一起添加到暂存区（不然还要一个个输入文件名）</span></span><br><span class="line">git commit -m <span class="string">"输入你这次提交的说明"</span> </span><br><span class="line">git push origin master  <span class="comment">#推送到远程仓库</span></span><br></pre></td></tr></table></figure><p>好了，记得按时将本地的备份到远程仓库。</p></li></ul><p>至此，本地备份已经完成。如果你想同时备份到gitee和github上面，你可以参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/1163625339727712" target="_blank" rel="noopener">这里</a>。</p><h1 id="在另外一台电脑上写博客"><a href="#在另外一台电脑上写博客" class="headerlink" title="在另外一台电脑上写博客"></a>在另外一台电脑上写博客</h1><p>前提是我们把博客备份在github、gitee等上面。</p><p>然后在新电脑上面：</p><ol><li>安装 Git、nodejs</li><li>把你远程的博客备份，clone下来到一个指定的位置（位置自己定）</li><li>在本地的博客仓库运行：<code>npm install</code>，来 安装依赖包</li></ol><p>好了，你可开始写博客了。</p><h1 id="优化技巧"><a href="#优化技巧" class="headerlink" title="优化技巧"></a>优化技巧</h1><h2 id="优化文章URL"><a href="#优化文章URL" class="headerlink" title="优化文章URL"></a>优化文章URL</h2><p><code>seo</code>搜索引擎优化认为，网站的最佳结构是<strong>用户从首页点击三次就可以到达任何一个页面</strong>，但是我们使用<code>hexo</code>编译的站点打开文章的<code>url</code>是：<code>sitename/year/mounth/day/title</code>四层的结构，这样的<code>url</code>结构很不利于<code>seo</code>，爬虫就会经常爬不到我们的文章，于是，我们需要优化一下网站文章<code>url</code></p><p>方案一：</p><p>我们可以将<code>url</code>直接改成<code>sitename/title</code>的形式，并且<code>title</code>最好是用英文，在根目录的配置文件下修改<code>permalink</code>如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://sunhwee.com</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:title.html</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br></pre></td></tr></table></figure><p>方案二：</p><p>使用插件优化<code>url</code></p><p>插件<code>hexo-abbrlink</code>实现了这个功能，它将原来的<code>URL</code>地址重新进行了进制转换和再编码。</p><p>安装<code>hexo-abbrlink</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>配置博客根目录下的_config.yml文件。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># permalink: :title/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">archives/:abbrlink.html</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>  <span class="comment"># 算法：crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>    <span class="comment"># 进制：dec(default) and hex</span></span><br></pre></td></tr></table></figure><p>运行<code>hexo clean</code>和<code>hexo g</code>命令来重新生成文件看看，可以清楚的看到，<code>URL</code>结构成功变为了3层。</p><p>来源: 洪卫の博客<br>作者: 洪卫<br>文章链接: <a href="https://sunhwee.com/posts/6e8839eb.html#toc-heading-59" target="_blank" rel="noopener">https://sunhwee.com/posts/6e8839eb.html#toc-heading-59</a><br>本文章著作权归作者所有，任何形式的转载都请注明出处。</p><h1 id="其他参考文章"><a href="#其他参考文章" class="headerlink" title="其他参考文章"></a>其他参考文章</h1><p>列表：<br><a href="http://dongshuyan.com/2019/05/24/hexo博客注意事项/#14-Hexo添加百度统计" target="_blank" rel="noopener">http://dongshuyan.com/2019/05/24/hexo%E5%8D%9A%E5%AE%A2%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/#14-Hexo添加百度统计</a></p><p><a href="https://www.dazhuanlan.com/2019/10/16/5da6352aa2a2e/" target="_blank" rel="noopener">网络编程系列 Hexo + Github搭建个人博客 · 花田半亩</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo主题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
