<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>鸟哥私房菜linux</title>
      <link href="/archives/7a585be8.html"/>
      <url>/archives/7a585be8.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red>鸟哥私房菜</red></p></center><center><red>http://linux.vbird.org/linux_basic/</red></center><a id="more"></a><h1 id="5️⃣Linux的档案权限与目录配置"><a href="#5️⃣Linux的档案权限与目录配置" class="headerlink" title="5️⃣Linux的档案权限与目录配置"></a>5️⃣Linux的档案权限与目录配置</h1><table><thead><tr><th>元件</th><th>内容</th><th>叠代物件</th><th>r</th><th>w</th><th>x</th></tr></thead><tbody><tr><td>档案</td><td>详细资料data</td><td>文件资料夹</td><td>读到文件内容</td><td>修改文件内容</td><td>执行文件内容</td></tr><tr><td>目录</td><td>档名</td><td>可分类抽屉</td><td>读到档名</td><td>修改档名</td><td>进入该目录的权限(key)</td></tr></tbody></table><hr><ul><li><p>由一般用户切换为“root”身份：<code>su -</code>；返回一般用户身份：<code>exit</code></p></li><li><p>查看文件<code>ls</code>;</p></li><li><p>复制：<code>cp</code></p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp 源档案名字 目的档案(档案副本的名称)</span><br></pre></td></tr></table></figure></blockquote></li></ul><h2 id="改变档案属性与权限"><a href="#改变档案属性与权限" class="headerlink" title="改变档案属性与权限"></a>改变档案属性与权限</h2><p>1、必须要进入档案所在目录中；2、所修改成的群组、所属者必须存在；3、只有root才有权限</p><p><strong>改变所属群组：chgrp</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp [-R] dirname/filename ...</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">选项与参数：</span><br><span class="line">-R : 进行递回(recursive)的持续变更，亦即连同级目录下的所有档案、目录</span><br><span class="line">     都更新成为这个群组之意。常常用在变更某一目录内所有的档案之情况。</span><br></pre></td></tr></table></figure></blockquote><hr><p><strong>改变档案拥有者：chown</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown [-R] 帐号名称 档案或目录</span><br><span class="line">chown [-R] 帐号名称:群组名称  档案或目录  <span class="comment">//:可以换为. 但是推荐使用:</span></span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">选项与参数：</span><br><span class="line">-R : 进行递回(recursive)的持续变更，亦即连同次目录下的所有档案都变更</span><br></pre></td></tr></table></figure></blockquote><hr><p><strong>改变权限：chmod</strong></p><ul><li><p><strong>使用数字改编权限</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chmod [-R] xyz 档案或目录</span><br><span class="line">-----------------------</span><br><span class="line">选项与参数：</span><br><span class="line">xyz : 就是刚刚提到的数字类型的权限属性，为rwx 属性数值的相加。</span><br><span class="line">-R : 进行递回(recursive)的持续变更，亦即连同次目录下的所有档案都会变更</span><br></pre></td></tr></table></figure><blockquote><p>Linux档案的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限，先复习一下刚刚上面提到的资料：档案的权限字元为：『-rwxrwxrwx』，这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p><blockquote><p>r:4<br>w:2<br>x:1</p></blockquote><p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是：</p><blockquote><p>owner = rwx = 4+2+1 = 7</p><p>group = rwx = 4+2+1 = 7</p><p>others= — = 0+0+0 = 0</p></blockquote></blockquote></li><li><p><strong>符号类型改变档案权限</strong></p><p>因为有三种身份：(1)user (2)group (3)others。那么我们就可以由<strong>u, g, o</strong>来代表三种身份的权限。</p><blockquote><p>此外，<strong>a</strong>则代表all亦即全部的身份！</p></blockquote><p>也就是可以使用底下的方式来看：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="%E9%B8%9F%E5%93%A5%E7%A7%81%E6%88%BF%E8%8F%9C/image-20200412180918390.png" alt="image-20200412180918390"></p><p>eg：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="%E9%B8%9F%E5%93%A5%E7%A7%81%E6%88%BF%E8%8F%9C/image-20200412181035669.png" alt="image-20200412181035669"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++/LearnCpp-chapter6</title>
      <link href="/archives/2faa8a4b.html"/>
      <url>/archives/2faa8a4b.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapter6</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h2 id="6-2-用户自定义namespace"><a href="#6-2-用户自定义namespace" class="headerlink" title="6.2 用户自定义namespace"></a>6.2 用户自定义namespace</h2><p>在<a href="https://www.learncpp.com/cpp-tutorial/2-9-naming-collisions-and-an-introduction-to-namespaces/" target="_blank" rel="noopener">2.9 – Naming collisions and an introduction to namespaces</a>中讲解了命名冲突和命名空间的内容。现在再次看一下<strong>命名冲突</strong>。</p><blockquote><p>下面的<code>foo.cpp</code>和<code>goo.cpp</code>两个源文件，中的函数有着不同的功能，但是它们的名字却是一样的：</p></blockquote><p><code>foo.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this dosomething() adds the value of its parameters</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dosomething</span><span class="params">(intx, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>goo.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this dosomething() subtracts the value of its parameters</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dosomething</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="comment">//forward declaration for dosomething</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; dosometing(<span class="number">4</span>, <span class="number">3</span>) &lt;&lt;<span class="string">'\n'</span>; <span class="comment">//which dosometing will we get?</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，编译器会将<code>foo.cpp</code>和<code>goo.cpp</code>都编译在同一个程序中。因为它们俩里面中的函数的名字、参数都一样，而且又在同一个范围中(global scope)，这将会造成“命名冲突”。结果就是，链接器工作时，将会发生错误：</p><p><code>goo.cpp:3: multiple definition of &quot;doSomething(int, int)&quot;; foo.cpp:3: first defined here</code></p><hr><p>一个较好的解决办法就是，将你的函数放在你自己定义的“<em><em>命名空间</em>namespace</em> **”中。</p><hr><ul><li><p><strong>定义自己的namespace</strong></p><p>C++允许我们使用关键字<em>namespace</em>来定义自己的命名空间。由用户自定义的命名空间，叫：<strong>user-defined namespaces</strong>。而 由C++提供的命名空间，如 <code>global namespace</code>；或者由库提供的，如<code>namespace std</code>；它们就不是user-defined namespaces。</p><blockquote><p><strong>命名空间的标识符</strong>通常 <strong>不大写</strong>。</p></blockquote><p>下面是对上面命名冲突的函数的改写：</p><p><code>foo.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> foo <span class="comment">//定义一个命名空间，名字为：foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//this dosomething() belongs to namespace foo</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dosomething</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>goo.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> goo  <span class="comment">//定义一个命名空间，名字为：goo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//this dosomething() belongs namespace goo</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dosomething</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dosomething</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">//提前对函数dosomething()进行声明</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;dosomething(<span class="number">4</span>, <span class="number">3</span>)&lt;&lt;<span class="string">'\n'</span>; <span class="comment">//which dosomething will we get?</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这个两个<code>dosomething()</code>函数都分别属于不同的命名空间了。让我们来运行一下。</p><p>😂，新问题又出现了：</p><blockquote><p><code>ConsoleApplication1.obj : error LNK2019: unresolved external symbol &quot;int __cdecl doSomething(int,int)&quot; (?doSomething@@YAHHH@Z) referenced in function _main</code></p></blockquote><p>在这个改版中，其实编译器是满意的(因为我们已经进行提前声明)。但是链接器找不到一个在<em>global namespace</em>中的<code>dosomething</code>的定义。</p><blockquote><p>这是因为我们虽然为两个<code>dosomething</code>分别声明在不同的命名空间，可惜的是这两个命名空间都不属于 全局命名空间 中。</p></blockquote><hr><p><strong>这里有两个解决方案：1.使用<em>scope resolution operator<em>；2.通过</em>using statements</em></strong></p><hr></li><li><p>*<em>使用范围解析操作符(::)访问名称空间 *</em></p><blockquote><p>【<strong>范围解析操作符：<em>scope resolution operator(::)</em></strong>】</p></blockquote><p>告诉编译器在特定名称空间中查找标识符的最佳方法是使用<em>scope resolution operator(::)</em></p><blockquote><p>“::”，它告诉编译器：应该在该操作符的 左操作数表示的范围中查找 操作符右边的操作数(也就是要找的标识符)</p></blockquote><p>下面是一个例子：</p><p><em>对于后面的示例，为了便于阅读，我们将把示例压缩为一个文件解决方案。</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> foo <span class="comment">// define a namespace named foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This doSomething() belongs to namespace foo</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> goo <span class="comment">// define a namespace named goo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This doSomething() belongs to namespace goo</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x - y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; foo::doSomething(<span class="number">4</span>, <span class="number">3</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// use the doSomething() that exists in namespace foo</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以注意到main函数中的这个语句：<code>std::cout &lt;&lt; foo::doSomething(4, 3) &lt;&lt; &#39;\n&#39;;</code>，就是用了“范围解析符 :: ”。</p><p>该标识符的左操作数：foo，表示命名空间的名字。右操作数表示标识符。</p><p><strong>所以，<code>foo::dosomething(4,3)</code>，就表示：调用的函数<code>dosomething()</code>是来源于命名空间foo中的。</strong></p></blockquote></li></ul><hr><center><p center large>小结</p></center><p>解决命名冲突的步骤为：</p><ol><li>为这些同名的函数，均设置自己的命名空间；</li><li>在使用这个同名函数的时候，还需要加上“范围解析符 :: ”</li></ol><hr><ul><li><p><strong>没有前缀的范围解析符</strong></p><blockquote><p><strong>格式：<code>:: 标识符</code></strong></p><p><strong>没有前缀的范围解析符，<u>就相当于它的范围是全局命名空间</u></strong>。</p></blockquote><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="comment">//this print lives in the global namespace</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"there"</span>&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> foo</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="comment">// this print lives in the foo namespace</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">foo::<span class="built_in">print</span>(); <span class="comment">// call foo::print()</span></span><br><span class="line">::<span class="built_in">print</span>(); <span class="comment">// call print() in global namespace (same as just calling print() in this case)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>允许多个命名空间块：Multiple namespace blocks allowed</strong></p><blockquote><p>在多个位置(跨多个文件，或同一文件中的多个位置)声明名称空间块是合法的。<strong><u>命名空间内的所有声明都被认为是命名空间的一部分</u>。</strong></p></blockquote><hr></li></ul><p>例子1（多文件中）：</p><p><code>circle.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(CIRCLE_H)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CIRCLE_H</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> basicMath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> pi&#123; <span class="number">3.14</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>growth.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(GROWTH_H)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GROWTH_H</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> basicMath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// the constant e is also part of namespace basicMath</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> e&#123; <span class="number">2.7</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"circle.h"</span> <span class="comment">// for basicMath::pi</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"growth.h"</span> <span class="comment">// for basicMath::e</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; basicMath::pi &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; basicMath::e &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p>3.14</p><p>2.7</p><blockquote><p>标准库充就分利用了这个特性，因为每个标准库头文件都将其声明包含在该头文件中包含的 命名空间std 块中。否则，整个标准库必须在一个头文件中定义!</p></blockquote><p><em>【note】：尽管你可以利用这个功能，将你写的函数添加到<code>std namespace</code>中，但是<code>std namespace</code>有一个规则，那就是禁止用户将自己的函数扩展到它的里面。</em></p><hr><ul><li><p>例子2</p><p>如果你将你的代码分离再多个文件中，你就必须在头文件和原文件中使用命名空间。</p><p><code>add.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(ADD_H)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD_H</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> basicMath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// function add() is part of namespace basicMath</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>add.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"add.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> basicMath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// define the function add()</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"add.h"</span> <span class="comment">// for basicMath::add()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; basicMath::add(<span class="number">4</span>, <span class="number">3</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li><p>如果在<code>add.cpp</code>中省略了<em>namespace</em>，将会导致链接器找不到<code>basicMath::add</code>。</p><p><em>因为这个源文件在缺少namespace时，对add的定义是在全局命名空间中的。</em></p></li><li><p>如果在<code>add.h</code>中省略<em>namespace</em>，将会导致在“main.cpp”中不能使用<code>basicMath::add</code></p><p><em>因为这个头文件在缺少namespace时，对add的声明是在全局命名空间中的。</em></p></li></ol></blockquote></li></ul><hr><ul><li><p><strong>嵌套命名空间</strong></p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> foo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> goo <span class="comment">// goo is a namespace inside the foo namespace</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; foo::goo::add() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>所以，当我们要调用函数<code>add</code>的时候，<strong>我们使用格式为：<code>foo::goo::add</code></strong></p></blockquote><hr><p>在C++17中，嵌套的命名空间也可以这样声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> foo::goo <span class="comment">// goo is a namespace inside the foo namespace (C++17 style)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; foo::goo::add() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>给命名空间设置别名：namespace aliases</strong></p><p>在使用嵌套的命名空间的函数或变量时，我们需要将命名空间层级都全部写完整，这样会很麻烦，如果我们给这个嵌套的命名空间起一个别名就省事多了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> foo</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">namespace</span> goo</span><br><span class="line">&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">namespace</span> boo = foo::goo; <span class="comment">// boo now refers to foo::goo</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; boo::add() &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// This is really foo::goo::add()</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// The boo alias ends here</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="6-3-局部变量"><a href="#6-3-局部变量" class="headerlink" title="6.3 局部变量"></a>6.3 局部变量</h2><p>在 <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-local-scope/" target="_blank" rel="noopener">2.4 – Introduction to local scope</a>,介绍了局部变量，它是在函数中的形参。</p><h3 id="局部变量的块范围"><a href="#局部变量的块范围" class="headerlink" title="局部变量的块范围"></a>局部变量的块范围</h3><p>标识符的范围决定了标识符在源码中可获得的区域。范围是一个“编译时间”的属性。</p><blockquote><p>局部变量的 <strong>块范围(block scope)</strong>，中的范围就是：从他们定义开始，到这个块结束 的这个范围。</p></blockquote><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i &#123;<span class="number">5</span>&#125;; <span class="comment">//i enters scope here</span></span><br><span class="line">    <span class="keyword">double</span> d &#123;<span class="number">4.0</span>&#125;; <span class="comment">// d enters scope here</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">// i and d go out of scope here</span></span><br></pre></td></tr></table></figure><p>虽然函数的形参没有被定义在函数体的内部，但是对于典型函数而言，形参可以被看成，是属于函数体块的范围内。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">//x and y enter scope here</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将x、y中较大者分配给max</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span>&#123;(x&gt;y) ? x : y&#125;; <span class="comment">//max enters scope here</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;<span class="comment">// x, y and max leave scope here</span></span><br></pre></td></tr></table></figure><hr><h3 id="同一范围内的变量名不相同"><a href="#同一范围内的变量名不相同" class="headerlink" title="同一范围内的变量名不相同"></a>同一范围内的变量名不相同</h3><p>下面的函数在编译时会出错，因为该范围内的变量名相同了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunction</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123;&#125;; <span class="comment">//编译时会出错，因为这里的x和形参x之间命名冲突了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="局部变量的自动存储期"><a href="#局部变量的自动存储期" class="headerlink" title="局部变量的自动存储期"></a>局部变量的自动存储期</h3><blockquote><p>变量的<strong>存储期(storage duration),也叫持续时长(duration)</strong>决定了什么时间以及如何创造和销毁它。通常，变量的存储器直接决定了它的<strong>“生命周期(lifetime)”</strong></p></blockquote><p>例如，局部变量的存储器，意味着它在被定义时就被创建，然后在他被定义的范围块的尾部被销毁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i &#123;<span class="number">5</span>&#125;; <span class="comment">//i created and initialized here</span></span><br><span class="line">    <span class="keyword">double</span> d &#123;<span class="number">4.0</span>&#125;; <span class="comment">//d created and initialized here</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// i and d are destoryed here</span></span><br></pre></td></tr></table></figure><p>由于这个原因，局部变量 有时也被称为：<strong>自动变量</strong></p><hr><h3 id="嵌套快中的局部变量"><a href="#嵌套快中的局部变量" class="headerlink" title="嵌套快中的局部变量"></a>嵌套快中的局部变量</h3><p>局部变量可以被定义在嵌套块中，这和在函数体块中的局部变量工作流程相同：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> <span class="comment">//外部块</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123;<span class="number">5</span>&#125;; <span class="comment">//x enters scope and is created here</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//嵌套块</span></span><br><span class="line">        <span class="keyword">int</span> y &#123;<span class="number">7</span>&#125;; <span class="comment">//y enters scope and is created here</span></span><br><span class="line">    &#125; <span class="comment">// y goes out of scope and is destroyed here</span></span><br><span class="line">    <span class="comment">//此时，y就不能再被用了，因为它不属于现在所在的范围</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// x goes out of scope and is destoryed here</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：<strong>变量x的范围是整个mian函数块中，自然，在嵌套块中，变量x也是有效的</strong>，即也可以访问它。</p></blockquote><hr><h3 id="局部变量的无连接"><a href="#局部变量的无连接" class="headerlink" title="局部变量的无连接"></a>局部变量的无连接</h3><p>标识符的另一个属性就是：<strong>“连接(linkage)”</strong>。一个标识符的<em>linkage</em>决定了该标识符的其他声明是否引用的是相同的对象。</p><blockquote><p><strong>局部变量没有<em>关联性</em>，也就是说对一个标识符的每一个声明都代表不同的对象</strong></p></blockquote><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x &#123;<span class="number">2</span>&#125;; <span class="comment">// local variable, no linkage</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x &#123;<span class="number">3</span>&#125;; <span class="comment">//这个标识符x与上面的标识符x，表示的是不同对象(尽管他们名字相同)</span></span><br><span class="line">        <span class="comment">//但是现在嵌套外部的变量x被隐藏起来了(在6.5节会讲到变量隐藏)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="变量定义的范围"><a href="#变量定义的范围" class="headerlink" title="变量定义的范围"></a>变量定义的范围</h3><p>如果一个变量仅在嵌套块中使用，那它就应该旨在嵌套块中被定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//don't define y here</span></span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//y只在这个块中被使用，所以在这里定义它</span></span><br><span class="line">        <span class="keyword">int</span> y&#123;<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;y&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>所以，我们尽量把变量定义在，使用它的范围内部</strong>。</p></blockquote><hr><h2 id="6-4-全局变量"><a href="#6-4-全局变量" class="headerlink" title="6.4 全局变量"></a>6.4 全局变量</h2><h3 id="全局变量的声明"><a href="#全局变量的声明" class="headerlink" title="全局变量的声明"></a>全局变量的声明</h3><p>通常，全局变量声明是在：<strong>头文件的下面，在其他代码的上面</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在函数外面声明的变量是全局变量</span></span><br><span class="line"><span class="keyword">int</span> g_x &#123;&#125;; <span class="comment">// global variable g_x</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// global variables can be seen and used everywhere in the file</span></span><br><span class="line">    g_x = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// global variables can be seen and used everywhere in the file</span></span><br><span class="line">    g_x = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// g_x goes out of scope here</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果*****/</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><blockquote><p>按照惯例， 在全局变量名字加上前缀“g”或者“g_”，来便于是显示的说明它是 全局变量</p></blockquote><hr><h3 id="全局变量的file-scope-amp-静态持续时间"><a href="#全局变量的file-scope-amp-静态持续时间" class="headerlink" title="全局变量的file scope&amp;静态持续时间"></a>全局变量的file scope&amp;静态持续时间</h3><blockquote><p>file scope也叫：<strong>全局范围(global scope)</strong>或者<strong>全局命名空间范围(global namespace scope)</strong></p><blockquote><p>因为全局变量是在函数外部定义的，所以也被视为“全局命名空间(global namespace)”的一部分。所以，才有<em>global namespace scope</em>这个叫法。</p></blockquote></blockquote><p>也就是说，它们从被定义开始，到所在文件的结束期间 都是有效的。</p><hr><p>全局变量在程序开始被创建，在程序结束时被销毁。这成为“<strong>静态持续时间(static duration)</strong>”</p><blockquote><p>有着‘static duration’的变量，也被称为：“<strong>静态变量(static variable)</strong>”</p></blockquote><hr><p><u><strong>局部变量默认是不被初始化的，全局变量默认是被初始化为0的</strong></u></p><ul><li><p><strong>全局变量的初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g_x; <span class="comment">//没有显示的初始化变量(所以默认初始化为0)</span></span><br><span class="line"><span class="keyword">int</span> g_y&#123;&#125;; <span class="comment">//初始化为0</span></span><br><span class="line"><span class="keyword">int</span> g_z&#123;<span class="number">3</span>&#125;; <span class="comment">//显示的初始化为3</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="常量局部变量"><a href="#常量局部变量" class="headerlink" title="常量局部变量"></a>常量局部变量</h3><p>与局部变量一样，全局变量也可以是常量。只要是常量，那它就必须被初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_x; <span class="comment">//error:常量型的变量必须要被初始化</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> g_w; <span class="comment">//error:常量型的变量必须要被初始化（constexpr，表示它是 编译时常量）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_y &#123;<span class="number">1</span>&#125;; <span class="comment">//正确，初始化了</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> g_z &#123;<span class="number">2</span>&#125;; <span class="comment">//正确，初始化了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dosomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//全局变量在这个文件中的每一个地方都是有效的(可以被看见和使用)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_z &lt;&lt; <span class="string">'\n'</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dosomething();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//全局变量在这个文件中的每一个地方都是有效的(可以被看见和使用)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_z &lt;&lt; <span class="string">'\n'</span>;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// g_y and g_z goes out of scope here</span></span><br></pre></td></tr></table></figure><hr><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Non-constant global variables(非常量的全局变量)</span></span><br><span class="line"><span class="keyword">int</span> g_x;                 <span class="comment">// defines non-initialized global variable (zero initialized by default)</span></span><br><span class="line"><span class="keyword">int</span> g_x &#123;&#125;;              <span class="comment">// defines explicitly zero-initialized global variable</span></span><br><span class="line"><span class="keyword">int</span> g_x &#123; <span class="number">1</span> &#125;;           <span class="comment">// defines explicitly initialized global variable</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Const global variables</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_y;           <span class="comment">// error: const variables must be initialized</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_y &#123; <span class="number">2</span> &#125;;     <span class="comment">// defines initialized global constant</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Constexpr global variables</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> g_y;       <span class="comment">// error: constexpr variables must be initialized</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> g_y &#123; <span class="number">3</span> &#125;; <span class="comment">// defines initialized global const</span></span><br></pre></td></tr></table></figure><hr><h2 id="6-5-变量被隐藏"><a href="#6-5-变量被隐藏" class="headerlink" title="6.5 变量被隐藏"></a>6.5 变量被隐藏</h2><h3 id="局部变量被隐藏"><a href="#局部变量被隐藏" class="headerlink" title="局部变量被隐藏"></a>局部变量被隐藏</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// outer block</span></span><br><span class="line"><span class="keyword">int</span> apples &#123; <span class="number">5</span> &#125;; <span class="comment">// 嵌套外部的apples</span></span><br><span class="line">    </span><br><span class="line">    &#123;<span class="comment">// nested block</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;apples&lt;&lt;<span class="string">'\n'</span>; <span class="comment">//这里的apples是嵌套外部的</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> apples &#123;<span class="number">0</span>&#125;; <span class="comment">//在嵌套内部定义变量apples</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//现在的apples指的是嵌套内部 的apples.嵌套外部的apples现在被隐藏起来了</span></span><br><span class="line">        apples = <span class="number">10</span>; <span class="comment">//现在被赋值的apples指的是嵌套内部的apples</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; apples &lt;&lt;<span class="string">'\n'</span>'</span><br><span class="line">    &#125; <span class="comment">//嵌套块内部的apples被销毁</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;apples&lt;&lt;<span class="string">'\n'</span>; <span class="comment">//这个apples指的是嵌套外部的apples(因为现在，嵌套内部的apples已经被销毁)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125; <span class="comment">//嵌套外部的apples被销毁</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">10</span><br><span class="line">5</span><br></pre></td></tr></table></figure><hr><h3 id="全局变量被隐藏"><a href="#全局变量被隐藏" class="headerlink" title="全局变量被隐藏"></a>全局变量被隐藏</h3><p>就像局部变量中的，嵌套块中的变量可以将嵌套外部的同名变量以藏起来 一样。<strong>局部变量可以将全局中的同名变量隐藏起来:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a &#123;<span class="number">5</span>&#125;; <span class="comment">//全局变量</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"global variable a："</span>&lt;&lt;a&lt;&lt;<span class="string">'\n'</span>;<span class="comment">//此时，全局变量a还没有被隐藏。即，这里的变量a，指的是全局变量</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a &#123;<span class="number">7</span>&#125;; <span class="comment">//此时，全局变量a就被这里的局部变量a 隐藏起来了</span></span><br><span class="line">    </span><br><span class="line">    ++a; <span class="comment">//局部变量a加1，而不是全局变量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"local variable a: "</span> &lt;&lt; a &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    foo();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// 局部变量a被销毁</span></span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local variable a: 8</span><br><span class="line">global variable a: 5</span><br></pre></td></tr></table></figure><hr><p>然而啊，全局变量是属于全局的命名空间。所以，我们可以使用 <em>范围解析符(::)</em>（不带前缀的，即默认是在全局命名空间）来告诉编译器我们使用的是全局变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a &#123;<span class="number">5</span>&#125;; <span class="comment">//全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a &#123;<span class="number">7</span>&#125;; <span class="comment">//此时，将全局变量a隐藏起来了</span></span><br><span class="line">    ++a； <span class="comment">//局部变量a加1，而不是全局变量</span></span><br><span class="line">        </span><br><span class="line">    --(::a); <span class="comment">//此时是对于全局变量，减一</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"local variable a: "</span> &lt;&lt; a &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"global variable a: "</span> &lt;&lt; ::a &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;       </span><br><span class="line">&#125;<span class="comment">//local a 被销毁</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local variable a: 8</span><br><span class="line">global variable a: 4</span><br></pre></td></tr></table></figure><hr><h3 id="避免变量被隐藏"><a href="#避免变量被隐藏" class="headerlink" title="避免变量被隐藏"></a>避免变量被隐藏</h3><p>通常应该避免局部变量的隐藏，因为它会在使用或修改错误的变量时导致无意的错误。一些编译器会在变量被隐藏时发出警告。</p><hr><h2 id="6-6-内部连接"><a href="#6-6-内部连接" class="headerlink" title="6.6 内部连接"></a>6.6 内部连接</h2><p>在 <a href="https://www.learncpp.com/cpp-tutorial/local-variables/" target="_blank" rel="noopener">6.3 – Local variables</a>中，讲到：“一个标识符的连接决定了该名称的其他声明是否引用同一对象”和“局部变量的无连接”</p><p>全局变量和函数标识符有：<strong>内部链接(internal linkage)</strong>和<strong>外部链接(external linkage)</strong>。本节主要讲内部链接。</p><hr><p>一个标识若是内部连接，那它就只能在这一个文件中有效(可以被看到和使用)；而不可以在其他文件中看到和使用【<strong>也就是说，它没有暴露给链接器</strong>】。也就是说，如果有两个文件，它们分别含有一个相同名字的标识符(而且这这个同名的标识符是 内部连接)，那么这个同名的标识符就被看待成相互独立的。</p><hr><h3 id="全局变量内部连接"><a href="#全局变量内部连接" class="headerlink" title="全局变量内部连接"></a>全局变量内部连接</h3><p>全局变量是内部链接时，也被称为：<strong>内部变量(<em>internal variables</em>)</strong>。</p><blockquote><p>让 非常量的全局变量 成为内部变量，需要使用<strong>关键字<code>static</code></strong>；（因为非常量的全局变量默认是 外部链接 的）</p><p>而 常量的全局变量 <strong>默认</strong>的就是 内部变量。</p></blockquote><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> g_x; <span class="comment">//非常量的全局变量默认是 外部链接。但是加上关键字static后，就变成内部连接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_y &#123;<span class="number">1</span>&#125;; <span class="comment">//const 的全局变量默认是 内部连接</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> g_z &#123;<span class="number">2</span>&#125;; <span class="comment">//constexpr 的全局变量默认是 内部连接</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>const</code>和<code>constexpr</code>的全局变量默认是 内部连接(所以，不需要加 关键字<code>static</code>)</p></blockquote><hr><h3 id="一个定义规则和内部连接"><a href="#一个定义规则和内部连接" class="headerlink" title="一个定义规则和内部连接"></a>一个定义规则和内部连接</h3><p>还记得在 <a href="https://www.learncpp.com/cpp-tutorial/forward-declarations/" target="_blank" rel="noopener">2.7 – Forward declarations and definitions</a>,中讲到一个定义的规则：<em>在文件或程序中，*</em>一个*<em>对象或者函数只能有一个定义</em>。</p><p>然而，这一个我们却在一个程序中对一个对象或函数进行了“多次定义”，这是否违背了上面的规则呢？</p><blockquote><p>答：不违背。因为本节中我们将它们设置为内部连接，此时虽然它们的名字相同，但是相互独立（即，它们相当于不同的对象或函数，只是名字相同。就好像两个同名的人一样）。所以不违背上面的定义规则。</p></blockquote><hr><h3 id="函数内部连接"><a href="#函数内部连接" class="headerlink" title="函数内部连接"></a>函数内部连接</h3><p>因为“连接(linkage)”是标识符的属性(标识符不仅仅只代表变量(☄⊙ω⊙)☄，因为函数的名字也是标识符)。所以，函数标识符也具有 内部连接 的属性。</p><p>如：</p><p><code>add.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个函数前使用关键字static，表示它现在只在这个文件中有效</span></span><br><span class="line"><span class="comment">//如果，企图通过函数提前声明从，从另一个文件访问它，将失败</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="comment">//对函数add，提前声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序，在链接器连接时，将会出错。因为函数add在<code>main.cpp</code>中不可访问</p><hr><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Internal global variables definitions:</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> g_x;          <span class="comment">// defines non-initialized internal global variable (zero initialized by default)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> g_x&#123; <span class="number">1</span> &#125;;     <span class="comment">// defines initialized internal global variable</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_y &#123; <span class="number">2</span> &#125;;     <span class="comment">// defines initialized internal global const variable</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> g_y &#123; <span class="number">3</span> &#125;; <span class="comment">// defines initialized internal global constexpr variable</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Internal function definitions:</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;;     <span class="comment">// defines internal function</span></span><br></pre></td></tr></table></figure><hr><h2 id="6-7-外部连接"><a href="#6-7-外部连接" class="headerlink" title="6.7 外部连接"></a>6.7 外部连接</h2><p>一个标识符具有 <strong>外部连接(external linkage)</strong>的属性，那么它就可以在整个程序中(不仅仅只在一个文件中)被看见和访问。（在其他文件中，可以通过<em>提前声明</em>来访问它）</p><blockquote><p>所以，具有外部连接属性的表示符，才是真正的“全局”变量</p></blockquote><hr><h3 id="函数默认是外部链接"><a href="#函数默认是外部链接" class="headerlink" title="函数默认是外部链接"></a>函数默认是外部链接</h3><p>在 <a href="https://www.learncpp.com/cpp-tutorial/programs-with-multiple-code-files/" target="_blank" rel="noopener">2.8 – Programs with multiple code files</a>中，讲到我们可以从其他文件中调用函数，这是因为这个函数默认是“外部链接”的。</p><p>在从其他文件中调用函数时，我们必须要对这个函数进行 <strong>提前声明(forward declaration)</strong></p><blockquote><p>因为，<strong>提前声明</strong>可以告诉编译器这个函数的存在；而链接器则是将函数调用连接到实际的函数定义</p></blockquote><p>如：</p><p><code>a.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> <span class="comment">//这个函数默认是 外部连接，所以他可以在整个程序(包括其他文件)中被看见</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hi"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span></span>; <span class="comment">//对函数进行提前声明，使得该函数在这个文件中可以被访问</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sayHi(); <span class="comment">//这里是从其他文件中调用此函数，链接器将把这个调用连接到函数定义</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hi</span><br></pre></td></tr></table></figure><hr><h3 id="全局变量外部连接"><a href="#全局变量外部连接" class="headerlink" title="全局变量外部连接"></a>全局变量外部连接</h3><p>全局变量具有外部连接属性时，也称为：<strong>外部变量(external variables)</strong></p><blockquote><p>非常量的全局变量默认是 外部变量；</p><p>常量的全局变量 要想成为外部变量，需要使用<strong>关键字<code>extern</code></strong></p></blockquote><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g_x &#123;<span class="number">2</span>&#125;; <span class="comment">//非常量的全局变量默认是 外部变量；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> g_y &#123;<span class="number">3</span>&#125;;<span class="comment">//const 的全局变量可以被定义成 外部变量，需要加关键字extern</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> g_z &#123;<span class="number">3</span>&#125;; <span class="comment">//constexpr 的全局变量可以被定义成 外部变量,需要加关键字extern</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>默认情况下，非const全局变量是外部变量(如果使用，extern关键字将被忽略)。</p></blockquote><hr><h3 id="extern提前声明变量"><a href="#extern提前声明变量" class="headerlink" title="extern提前声明变量"></a><code>extern</code>提前声明变量</h3><p>要实际使用在另一个文件中定义的外部全局变量，我们需要在使用它的文件中对全局变量进行<em>提前声明</em>。对于变量，在创建一个<strong>提前声明时，也是需要使用关键字<code>extern</code>的(</strong>没有初始化值)：</p><p>如：</p><p><code>a.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量的定义</span></span><br><span class="line"><span class="keyword">int</span> g_x &#123;<span class="number">2</span>&#125;; <span class="comment">//非常量的全局变量默认是 外部链接</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> g_y &#123;<span class="number">3</span>&#125;; <span class="comment">//常量的全局变量是内部连接，但使用关键字extern后，变为 外部链接</span></span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> g_x; <span class="comment">//对变量g_x的提前声明。它的定义在其他文件中</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> g_y; <span class="comment">//对常量变量g_y的提前声明。它的定义在其他文件中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>&lt;&lt; g_x; <span class="comment">//结果为2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="函数提前声明不用extern"><a href="#函数提前声明不用extern" class="headerlink" title="函数提前声明不用extern"></a>函数提前声明不用<code>extern</code></h3><p><strong>函数的提前声明不需要关键字<code>extern</code></strong></p><blockquote><p>编译器能搞告诉你这个函数在哪定义，也可以根据是否提供函数体来进行提前声明。</p></blockquote><p><strong>变量的提前声明必须要用关键字<code>extern</code></strong>，</p><blockquote><p>来帮助区分 <strong>变量定义</strong> 和 <strong>变量提前声明</strong>(它们看起来是一样的):</p></blockquote><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非常量</span></span><br><span class="line"><span class="keyword">int</span> g_x; <span class="comment">//变量的定义(如果需要，可进行初始化)</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> g_x; <span class="comment">//变量的提前声明(提前声明  不带初始化)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> g_y &#123;<span class="number">1</span>&#125;;<span class="comment">//定义变量(常量的定义必须要进行初始化)</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> g_y; <span class="comment">//提前声明(提前声明  不带初始化)</span></span><br></pre></td></tr></table></figure><hr><h3 id="file范围VS-global范围"><a href="#file范围VS-global范围" class="headerlink" title="file范围VS.global范围"></a>file范围VS.global范围</h3><p>看下面的例子：</p><p><code>global.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g_x &#123;<span class="number">2</span>&#125;; <span class="comment">//（非常量的变量）默认是外部连接</span></span><br><span class="line"><span class="comment">//g_x goes out scope here</span></span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> g_x; <span class="comment">//对变量g_x的提前声明。可以在此文件中使用g_x</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_x; <span class="comment">//应该输出 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//g_x的提前声明 goes out of scope here</span></span><br></pre></td></tr></table></figure><blockquote><p>变量g_x的<strong>文件范围(file scope)</strong>是在<code>global.cpp</code>中。它在该文件中定义之后，就可以被使用。</p><p>但是它<strong>不能<u>直接</u>在其他文件中使用</strong>。如果要在其他文件中使用g_x，我们要在其他文件中对它进行提前声明(记得要使用关键字<code>extern</code>)</p></blockquote><hr><p>也就是说，“文件范围”通常用于具有<em>内部连接</em>属性的全局变量；“全局范围”更多用于具有<em>外部连接</em>属性的全局变量(因为，它被提前声明之后，就可以在其他地方使用)</p><hr><h3 id="全局变量初始化顺序问题"><a href="#全局变量初始化顺序问题" class="headerlink" title="全局变量初始化顺序问题"></a>全局变量初始化顺序问题</h3><p>全局变量的初始化是程序启动的一部分，在执行<code>mian</code>函数之前，这个过程分为两部分：</p><ul><li><p>第一部分，称为 <strong><em>static initialization</em>静态初始化</strong>。</p><blockquote><p>在静态初始化中，带有constexpr初始化器(包括字面值(literal))的全局变量被初始化为给定的值[因为，constexpr和字面值常量定义时自带有初始值]；</p><blockquote><p>eg,</p><p><code>const a {1};</code>那么a就被初始化为1</p><p><code>constexpr a{1};</code>那么a就被初始化为1</p></blockquote><p>定义时没有给定初始值的全局变量<strong>(也使常量的全局变量，但没有显示初始化为0)</strong>被默认初始化为0。</p><blockquote><p><code>const a {};</code>那么a就默认被初始化为0</p><p><code>constexpr a{};</code>那么a就默认被初始化为0</p></blockquote></blockquote></li><li><p>第二部分，称为 <strong><em>dynamic initialization</em>动态初始化</strong>。</p><blockquote><p>这部分，比较复杂，它的要点是：初始化那些“不带有constexpr初始化器的全局变量”(即，就是 非常量的全局变量)。</p></blockquote></li></ul><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_something &#123;init()&#125;; <span class="comment">//非常量的变量初始化</span></span><br></pre></td></tr></table></figure><blockquote><p>在单位件的程序中，全局变量按照定义的顺序被初始化</p></blockquote><p>这个规则有几个例外。考虑到这一点，<strong>您需要小心不要让变量依赖于其他变量的初始化值，这些变量要到稍后才会初始化</strong>。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initx</span><span class="params">()</span></span>;  <span class="comment">// forward declaration</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inity</span><span class="params">()</span></span>;  <span class="comment">// forward declaration</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> g_x&#123; initx() &#125;; <span class="comment">// g_x is initialized first</span></span><br><span class="line"><span class="keyword">int</span> g_y&#123; inity() &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initx</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g_y; <span class="comment">// g_y isn't initialized when this is called</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g_x &lt;&lt; <span class="string">' '</span> &lt;&lt; g_y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******结果*******/</span></span><br><span class="line"><span class="number">0</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><hr><p>再多文件程序中，<strong>不同文件之间的初始化顺序是没有规定的</strong>。</p><blockquote><p>例如，有两个文件<code>a.cpp</code>和<code>b.cpp</code>，它们两个文件谁先被初始化是不确定的。</p></blockquote><p>所以，如果在<code>a.cpp</code>中有一个变量的值是依赖于<code>b.cpp</code>。那么就有50%的可能这些变量还没有被初始化。</p><hr><p>注意：C++中，全局变量的动态初始化会造成很多问题。所以避免使用。</p><hr><p>小结：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// External global variable definitions:</span></span><br><span class="line"><span class="keyword">int</span> g_x;                       <span class="comment">// defines non-initialized external global variable (zero initialized by default)</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> g_x&#123; <span class="number">1</span> &#125;;     <span class="comment">// defines initialized const external global variable</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> g_x&#123; <span class="number">2</span> &#125;; <span class="comment">// defines initialized constexpr external global variable</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Forward declarations</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> g_y;                <span class="comment">// forward declaration for non-constant global variable</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> g_y;          <span class="comment">// forward declaration for const global variable</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> g_y;      <span class="comment">// not allowed: constexpr variables can't be forward declared</span></span><br></pre></td></tr></table></figure><hr><h2 id="6-8-全局常量-amp-内联变量"><a href="#6-8-全局常量-amp-内联变量" class="headerlink" title="6.8 全局常量&amp;内联变量"></a>6.8 全局常量&amp;内联变量</h2><blockquote><p><strong>Global constants and inline variables</strong></p></blockquote><p>一些符号常量需(如，阿伏伽德罗常数，重力系数…)要在整个程序中使用。比较好的方法是在一个地方对他们进行声明，而不是在每个需要它们的文件中重新定义这些常量。</p><h3 id="全局常量作为内部变量"><a href="#全局常量作为内部变量" class="headerlink" title="全局常量作为内部变量"></a>全局常量作为内部变量</h3><p>在c++中有多种方法可以促进这一点。在c++ 17之前，以下可能是最简单和最常见的方法:</p><ol><li><p>首先，创建一个头文件来存放这些常量；</p></li><li><p>在这个头文件中，定义一个命名空间（在 <a href="https://www.learncpp.com/cpp-tutorial/user-defined-namespaces/" target="_blank" rel="noopener">6.2 – User-defined namespaces</a>讲解过命名空间）；</p></li><li><p>然后，将常量加入这个命名空间中（请确保它们的类型是<code>constexpr</code>）；</p></li><li><p>在你要用这些变量的文件中，加上这个头文件<code>#include &quot;xxx&quot;</code></p></li></ol><hr><p>eg:</p><p><code>constants.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONSTANTS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONSTANTS_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义你自己的命名空间(用来存储常量)</span></span><br><span class="line"><span class="keyword">namespace</span> constants</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//默认情况下，常量有 内部连接</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">double</span> pi &#123;<span class="number">3.14159</span>&#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">double</span> my_gravity &#123;<span class="number">9.2</span>&#125;;</span><br><span class="line">    <span class="comment">//....常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"constants.h"</span> <span class="comment">//：在这个文件中包含每个常量的副本</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"enter a radius: "</span>;</span><br><span class="line">    <span class="keyword">int</span> radius&#123;&#125;; <span class="comment">//radius：半径</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt;radius;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"the circumference is: "</span> &lt;&lt;<span class="number">2</span>* radius* constants::pi;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：在<code>main.cpp</code>文件中，要想访问<code>constants</code>中的常量，我们需要使用 <strong>范围解析符(::)</strong>。</p><p><code>a::b</code> 范围解析操作符的 左操作数a,表示命名空间名称；右操作符b表示命名空间a中的变量或者函数名字。</p><p><code>::b</code> 这种形式表示 <strong>其命名空间是全局命名空间</strong>。</p></blockquote><hr><h3 id="全局常量作为外部变量"><a href="#全局常量作为外部变量" class="headerlink" title="全局常量作为外部变量"></a>全局常量作为外部变量</h3><p>当作为内部变量时，可能会出现以下问题：</p><p>虽然这很简单(对于较小的程序也很好)，但是每当constants.h被包含到不同的代码文件中时，每个变量都会被复制到包含代码文件中。因此，如果将constants.h包含到20个不同的代码文件中，那么每个变量都会重复20次。头文件保护不会阻止这种情况的发生，因为它们只会阻止头文件不止一次被包含到一个包含文件中，而不会阻止头文件一次被包含到多个不同的代码文件中。这带来了两个挑战:</p><blockquote><p><strong>头文件保护符(header guards)</strong>只能确保在单个文件中包含的头文件只包含一次；</p></blockquote><ul><li>当修改一个常量值时，就可能需要重新编译那些包含这个常量的文件，这可能导致大型项目的重建时间很长。</li><li>如果常量的size很大，并且不能进行优化。这将花费很多内存。</li></ul><hr><p>一个解决上面的办法就是，将这些常量设为<strong>“外部变量(external variables)”</strong>。</p><blockquote><p>因此，我们可以将变量只初始化一次就可以在整个程序中使用。</p></blockquote><p><code>constants.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> constants</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//actual global variables</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">double</span> pi &#123;<span class="number">3.14159</span>&#125;;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">const</span> my_gravity &#123;<span class="number">9.2</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在<code>constants.cpp</code>文件中定义这些常量，来确保它们只被定义一次；</p></blockquote><p><code>constants.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONSTANTS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONSTANTS_H</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> constants</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// since the actual variables are inside a namespace, the forward declarations need to be inside a namespace as well</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">double</span> pi;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">double</span> avogadro;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">double</span> my_gravity;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><blockquote><p>需要在头文件<code>constants.h</code>中对这些常量进行 提前声明</p></blockquote><p><code>main.cpp</code></p><blockquote><p>使用的方法不变</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"constants.h"</span> <span class="comment">// include all the forward declarations</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a radius: "</span>;</span><br><span class="line">    <span class="keyword">int</span> radius&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; radius;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The circumference is: "</span> &lt;&lt; <span class="number">2</span> * radius * constants::pi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>因为全局符号常量在命名空间中(为了避免与全局命名空间中的标识符发生 命名冲突)，所以，就不需要在它名字中使用<code>g_</code>前缀</p></blockquote><p>现在，这些符号常量只用在<code>constants.cpp</code>中实例化一次(而不是每次constants.h被<code>#include</code>中都被实例化一次)，所以，对constants.cpp所做的任何修改都只需要重新编译constants.cpp即可。</p><p>然而，这种方法也有几个缺点。</p><ul><li><strong>首先，这些常量现在只在实际定义它们的文件(constants.cpp)中被认为是 编译时常量</strong>，<strong>而不是在其他地方使用它们</strong>。这意味着在constants.cpp之外的地方，它们不能在任何需要编译时常量的地方使用。</li><li>其次，编译器可能无法对它们进行尽可能多的优化。</li></ul><hr><h3 id="全局常量作为内联变量"><a href="#全局常量作为内联变量" class="headerlink" title="全局常量作为内联变量"></a>全局常量作为内联变量</h3><p>在C++17中，有一个新概念叫做：<strong><em>inline variable</em>(内联变量)</strong></p><blockquote><p><strong>inline</strong>意为：允许多个定义。</p></blockquote><p>所以，一个内联变量就可以在多个文件中被多次定义。(这并不违背 <strong>单定义规则</strong>)</p><blockquote><p><strong>内联全局变量</strong> 默认是 <strong>外部连接</strong></p></blockquote><hr><p>内联变量有两个重要的限制，必须遵守：</p><ul><li>内联变量的所有定义必须相同（否则，将产生未定义的行为）；</li><li>内敛变量的定义(不是提前声明)必须出现在每一个使用这些变量的文件中。</li></ul><blockquote><p>编译器将会把内联变量的所有定义合并为一个变量的定义。这就允许我们在头文件中定义变量，并将它们当作<code>a.cpp</code>文件中只有一个定义。</p><p>这些变量在它们被包含的文件中，依然保持这 constexpr 的性质</p></blockquote><p>这样，我们就可以在头文件中定义全局变量，而不用担心重复变量:</p><p><code>constants.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONSTANTS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONSTANTS_H</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// define your own namespace to hold constants</span></span><br><span class="line"><span class="keyword">namespace</span> constants</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> pi &#123; <span class="number">3.14159</span> &#125;; <span class="comment">// note: now inline constexpr</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> avogadro &#123; <span class="number">6.0221413e23</span> &#125;;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> my_gravity &#123; <span class="number">9.2</span> &#125;; <span class="comment">// m/s^2 -- gravity is light on this planet</span></span><br><span class="line">    <span class="comment">// ... other related constants</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"constants.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a radius: "</span>;</span><br><span class="line">    <span class="keyword">int</span> radius&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; radius;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The circumference is: "</span> &lt;&lt; <span class="number">2</span> * radius * constants::pi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们可以在尽可能多的代码文件中包含<code>constants.h</code>，但是这些变量只会被实例化一次，并在所有代码文件中共享。</p></blockquote><hr><p>如果你需要全局常量，并且你的编译器支持C++17，那建议最好使用 <strong>内联变量</strong></p><hr><h2 id="6-9-非常量的全局变量evil"><a href="#6-9-非常量的全局变量evil" class="headerlink" title="6.9 非常量的全局变量evil"></a>6.9 非常量的全局变量evil</h2><p>最大的问题就是：<strong>当你使用全局变量(not-const)时，它可能在任何地方就被修改，但是你却不能轻松的直到在哪被改的。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g_mode; <span class="comment">//声明全局变量(将默认被初始化为0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dosomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_mode = <span class="number">2</span>; <span class="comment">//这里修改全局变量g_mode为2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_mode =<span class="number">1</span>; <span class="comment">//note:这将全局g_mode变量设置为1。而不是声明一个本地g_mode变量!</span></span><br><span class="line">    dosomething();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//程序猿希望这里输出的g_mode的值是1，但是实际上它的值是2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(g_mode == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"no threat detected.\n"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"lanunching nuclear missiles...\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>局部变量要安全得多，因为其他函数不能直接影响它们。</strong></p></blockquote><hr><h3 id="保护你的全局变量"><a href="#保护你的全局变量" class="headerlink" title="保护你的全局变量"></a>保护你的全局变量</h3><p>如果你非要使用全局变量：</p><ul><li><strong>那我们可以对变量名使用前缀”g_”或“g”，来帮助我们识别它是全局变量。</strong></li><li>最好也将其<strong>放在你自己创建的命名空间，从而避免一些命名冲突。</strong></li></ul><hr><h2 id="6-10-静态局部变量"><a href="#6-10-静态局部变量" class="headerlink" title="6.10 静态局部变量"></a>6.10 静态局部变量</h2><p>术语<code>static</code>是c++语言中最容易混淆的术语之一，这在很大程度上是因为静态在不同的上下文中有不同的含义。</p><p>在之前的课程中，我们讨论了<strong>全局变量具有静态持续时间</strong>，<strong>这意味着它们在程序启动时创建，在程序结束时销毁。</strong></p><p>我们还讨论了<strong><code>static</code>关键字如何提供全局标识符内部链接</strong>，<strong>这意味着标识符只能在定义它的文件中使用。</strong></p><hr><p>我们将探讨<strong>应用于局部变量时静态关键字的用法</strong>。</p><p>在 <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-local-scope/" target="_blank" rel="noopener">2.4 – Introduction to local scope</a>, 您了解到，默认情况下 局部变量具有 <em>自动持续时间</em>，<strong>这意味着它们是在定义时创建的，并在块退出时销毁。</strong></p><blockquote><p>但<strong>关键字<code>static</code></strong>，可以将<strong><em>自动持续时间(attomatic duration)</em></strong>转变成 <strong><em>静态持续时间(static duration)</em></strong> 。从而，静态变量即使已经超出它所在的范围时，他依然没有被销毁。</p><blockquote><p>这意味着变量现在在程序开始时创建，并在程序结束时销毁(就像全局变量一样)。</p></blockquote></blockquote><p>例如：</p><p><em>默认是 automatic duration</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrementAndPrint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value&#123; <span class="number">1</span> &#125;; <span class="comment">// 默认是 automatic duration</span></span><br><span class="line">    ++value;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125; <span class="comment">// value is destroyed here</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    incrementAndPrint();</span><br><span class="line">    incrementAndPrint();</span><br><span class="line">    incrementAndPrint();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果**********/</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>每次</strong>调用函数<code>incrementAndPrint()</code>时，都将穿件一个叫value的变量，它被初始化为1</p></blockquote><hr><p>现在使用<code>static</code>关键字，将默认的 <em>atuomatic duration</em> 转变为 <em>static duration</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrementAndPrint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_value&#123; <span class="number">1</span> &#125;; <span class="comment">// 由于使用关键字 static,所以现在是 static duration。  所以这个变量将只会被初始化一次（不会像上面那个例子，每次调用都会被除初始化）</span></span><br><span class="line">    ++s_value;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s_value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125; <span class="comment">// s_value is not destroyed here, but becomes inaccessible because it goes out of scope</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    incrementAndPrint();</span><br><span class="line">    incrementAndPrint();</span><br><span class="line">    incrementAndPrint();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****结果****/</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><blockquote><p>在这个程序中，<strong>因为s_value被声明为静态的</strong>，<u><strong>所以s_value只创建一次(在程序启动时)(并且初始化为零)。</strong></u>然后在第一次遇到变量定义时使用我们提供的初始化值(1)初始化变量(但在后续调用时不会重新初始化)。</p></blockquote><blockquote><p>就像我们使用“g_” 作为全局变量的前缀一样，使用 “ s_”作为静态(静态持续时间)局部变量的前缀也是很常见的。</p></blockquote><hr><p><strong>静态变量提供了全局变量的一些好处(它们直到程序结束时才被销毁)</strong>，同时，限制为它们只在它自己的块中才能被看见，这使得即使您经常更改它们的值，这也使它们可以安全使用。</p><hr><h3 id="全局、局部变量使用static"><a href="#全局、局部变量使用static" class="headerlink" title="全局、局部变量使用static"></a>全局、局部变量使用<code>static</code></h3><p>全局变量使用关键字<code>static</code>：这会使得全局变量变为 <strong><em>internal linkage(内部连接)</em></strong>，即，使得该变量不能再其他文件中使用。</p><p>局部变量使用关键字<code>statci</code>：这使得局部变量变为 <strong><em>static duration(静态持续时间)</em></strong>,即，使得该变量将 只被创建一次，而且直到程序结束才会被销毁。</p><hr><h2 id="6-11-总结scope-duration-linkage"><a href="#6-11-总结scope-duration-linkage" class="headerlink" title="6.11 总结scope/duration/linkage"></a>6.11 总结scope/duration/linkage</h2><h3 id="总结scope"><a href="#总结scope" class="headerlink" title="总结scope"></a>总结scope</h3><p>标识符的范围决定了它能够被访问的区间：</p><ul><li>具有 <strong>block scope(块范围)</strong> / <strong>local scope(局部范围)</strong> 的变量 只能在它们被声明的块中(包括嵌套块)被访问，这些有：<ul><li>局部变量；</li><li>函数的形参；</li><li>在块中声明的用户定义类型定义（如，枚举(enum)、类(class)）;</li></ul></li><li>具有 <strong>global scope(全局范围)</strong> / <strong>file scope(文件范围)</strong>的变量 可以再文件中的任何地方被访问，这些有：<ul><li>全局变量；</li><li>函数；</li><li>在命 名空间内 或 全局范围 内声明的用户定义类型定义(如枚举(enum)、类(class))</li></ul></li></ul><hr><h3 id="总结duration"><a href="#总结duration" class="headerlink" title="总结duration"></a>总结duration</h3><p>变量的持续时间决定了它们何时被创建与销毁：</p><ul><li>具有 <strong>automatic duration(自动持续时间)</strong>的变量 在定义时被创建，在离开它所在的块时被销毁，这些有：<ul><li>局部变量；</li><li>函数的形参；</li></ul></li><li>具有 <strong>static duration(静态持续时间)</strong>的变量 在程序开始时被创建， 在程序结束时被销毁。这些有：<ul><li>全局变量；</li><li>静态局部变量；</li></ul></li><li>具有 <strong>dynamic duration(动态持续时间)</strong>的变量 由程序员请求创建和销毁。这些有：<ul><li>动态分配的变量；</li></ul></li></ul><hr><h3 id="总结linkage"><a href="#总结linkage" class="headerlink" title="总结linkage"></a>总结linkage</h3><p>标识符的 <strong><em>linkage</em>(连接)</strong> 决定了 一个标识符的多个实例是否引用同一个标识符。</p><ul><li>标识符 没有 连接 时，意味着这个标识符仅指其自身。这些有：<ul><li>局部变量；</li><li>在块中声明的用户定义类型定义(如枚举和类)；</li></ul></li><li>具有 <strong><em>intrnal linkage</em>(内部连接)</strong> 的标识符 只能在它所声明的文件中 被访问。这些有：<ul><li>静态全局变量(static global variables) [初始化 或 未初始化 ]；</li><li>静态函数（static functions）;</li><li>在未命名的命名空间中声明的函数；</li><li>在未命名的命名空间中声明的用户定义类型定义(如枚举和类)；</li></ul></li><li>具有 <strong><em>external linkage(外部连接)</em></strong> 的标识符 可以在 在声明的文件内的任何地方访问，也可以其他文件(通过提前声明)进行访问。这包括:<ul><li>函数；</li><li>非常量的全局变量(初始化 或 未初始化)；</li><li>外部常量全局变量；</li><li>内联常量全局变量；</li><li>在 命名空间内 或 全局范围内声明的用户定义类型定义(如枚举和类)；</li></ul></li></ul><hr><blockquote><p>NOTE:</p><p>默认情况下， 函数是 外部连接；它可通过使用关键字<code>static</code>变成 内部连接。</p></blockquote><hr><h3 id="变量的-scope-duratio-linkage"><a href="#变量的-scope-duratio-linkage" class="headerlink" title="变量的 scope/duratio /linkage"></a>变量的 scope/duratio /linkage</h3><table><thead><tr><th align="left">Type</th><th align="left">Example</th><th align="left">Scope</th><th align="left">Duration</th><th align="left">Linkage</th><th align="left">Notes</th></tr></thead><tbody><tr><td align="left">Local variable</td><td align="left">int x;</td><td align="left">Block</td><td align="left">Automatic</td><td align="left">None</td><td align="left"></td></tr><tr><td align="left">Static local variable</td><td align="left">static int s_x;</td><td align="left">Block</td><td align="left">Static</td><td align="left">None</td><td align="left"></td></tr><tr><td align="left">Dynamic variable</td><td align="left">int *x { new int };</td><td align="left">Block</td><td align="left">Dynamic</td><td align="left">None</td><td align="left"></td></tr><tr><td align="left">Function parameter</td><td align="left">void foo(int x)</td><td align="left">Block</td><td align="left">Automatic</td><td align="left">None</td><td align="left"></td></tr><tr><td align="left">External non-constant global variable</td><td align="left">int g_x;</td><td align="left">File</td><td align="left">Static</td><td align="left">External</td><td align="left">Initialized or uninitialized</td></tr><tr><td align="left">Internal non-constant global variable</td><td align="left">static int g_x;</td><td align="left">File</td><td align="left">Static</td><td align="left">Internal</td><td align="left">Initialized or uninitialized</td></tr><tr><td align="left">Internal constant global variable</td><td align="left">constexpr int g_x { 1 };</td><td align="left">File</td><td align="left">Static</td><td align="left">Internal</td><td align="left">Const or constexpr, Must be initialized</td></tr><tr><td align="left">External constant global variable</td><td align="left">extern constexpr int g_x { 1 };</td><td align="left">File</td><td align="left">Static</td><td align="left">External</td><td align="left">Const or constexpr, Must be initialized</td></tr><tr><td align="left">Inline constant global variable</td><td align="left">inline constexpr int g_x { 1 };</td><td align="left">File</td><td align="left">Static</td><td align="left">External</td><td align="left">Const or constexpr, Must be initialized</td></tr></tbody></table><hr><h3 id="总结提前声明"><a href="#总结提前声明" class="headerlink" title="总结提前声明"></a>总结提前声明</h3><p>你可以在其他文件中对一个 函数/变量 进行提前声明：</p><table><thead><tr><th align="left">Type</th><th align="left">Example</th><th align="left">Notes</th></tr></thead><tbody><tr><td align="left">Function forward declaration</td><td align="left">void foo(int x);</td><td align="left">Prototype only, no function body</td></tr><tr><td align="left">Non-constant global variable forward declaration</td><td align="left">extern int g_x;</td><td align="left">Must be uninitialized</td></tr><tr><td align="left">Const global variable forward declaration</td><td align="left">extern const int g_x;</td><td align="left">Must be uninitialized</td></tr><tr><td align="left">Constexpr global variable forward declaration</td><td align="left">extern constexpr int g_x;</td><td align="left"><u>Not allowed, constexpr cannot be forward declared</u></td></tr></tbody></table><hr><h3 id="什么是存储类说明符"><a href="#什么是存储类说明符" class="headerlink" title="什么是存储类说明符?"></a>什么是存储类说明符?</h3><p>当关键字<code>static</code> 、<code>extern</code>用作标识符声明的一部分时,它们就被称为：<strong>storage class specifier（存储类说明符）</strong>。它们设置标识符的存储的 <em>duration</em> 和 <em>linkage</em></p><p>C++支持4中存储类说明符：</p><table><thead><tr><th align="left">Specifier</th><th align="left">Meaning</th><th align="left">Note</th></tr></thead><tbody><tr><td align="left">extern</td><td align="left">static (or thread_local) storage duration and external linkage</td><td align="left"></td></tr><tr><td align="left">static</td><td align="left">static (or thread_local) storage duration and internal linkage</td><td align="left"></td></tr><tr><td align="left">thread_local</td><td align="left">thread storage duration</td><td align="left">Introduced in C++11</td></tr><tr><td align="left">mutable</td><td align="left">object allowed to be modified even if containing class is const</td><td align="left"></td></tr><tr><td align="left">auto</td><td align="left">automatic storage duration</td><td align="left">Deprecated in C++11</td></tr><tr><td align="left">register</td><td align="left">automatic storage duration and hint to the compiler to place in a register</td><td align="left">Deprecated in C++17</td></tr></tbody></table><blockquote><p>术语 <em>storage class specifier</em> 通常只在正式文档中使用。</p></blockquote><hr><h2 id="6-12-using-语句"><a href="#6-12-using-语句" class="headerlink" title="6.12 using 语句"></a>6.12 using 语句</h2><p>如果你经常使用标准库，那么在使用标准库中的所有内容之前输入std::会变得重复。C++提供了一种可选择的办法，叫做：<strong><em>using statements</em></strong></p><h3 id="using的声明"><a href="#using的声明" class="headerlink" title="using的声明"></a>using的声明</h3><p>一种简化的方法是使用using声明语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="comment">// this using declaration tells the compiler that cout should resolve to std::cout</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!"</span>; <span class="comment">// so no std:: prefix is needed here!</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// the using declaration expires here</span></span><br></pre></td></tr></table></figure><blockquote><p>using 的声明：<code>using std::cout</code>告诉编译器我们将要使用 命名空间std 中的<code>cout</code>。所以当编译器看到cout时，它会假设我们指的是std::cout。</p><p>如果std::cout与cout的其他一些使用之间存在命名冲突，则首选std::cout。</p></blockquote><p>上面的例子，看起来似乎没有简化多少。但如果我们要多次使用<code>cout</code>时，使用 <code>using statements</code>就可以简化很多。</p><blockquote><p>注意，如果你多次使用<code>std::cout</code>和<code>std::cin</code>的话，你需要对他们两个分别使用<code>using statements</code></p></blockquote><hr><h3 id="using-指令"><a href="#using-指令" class="headerlink" title="using 指令"></a>using 指令</h3><p>另一种方法就是使用：<code>using directive</code>语句。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">//这个using指令 告诉编译器我们可以使用 命名空间std 中的任何东西</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world!"</span>; <span class="comment">// 所以，前缀 std:: 就可以省略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个using 指令 ：<code>using namespace std</code>告诉编译器我们想使用 命名空间std 中的任何东西。所以当编译器发现了一个名字它不认识时，它就会检查 命名空间std。</p><p>结果就是，当编译器遇到<code>cout</code>(编译器不认识cout)，编译器就会查看 命名空间std 然后找到cout。</p><hr><p>如果std::cout与cout的其他一些使用之间存在命名冲突，编译器将把它<strong>标记为错误</strong>(而不是选择其中之一)。</p></blockquote><p>下面来看一下 using 指令 造成的歧义：</p><ul><li><p>eg1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> a</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x&#123; <span class="number">10</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> b</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x&#123; <span class="number">20</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> a;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> b;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面例子中，编译器无法在mian函数中决定使用<code>a::x</code>还是<code>b::x</code>。然后就会出现“不明确的符号”错误。</p><p>要想解决这个冲突，我们可以加上前缀使用。即显示标明使用的是哪一个命名空间中的x。</p></blockquote></li><li><p>eg2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // imports the declaration of std::cout</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cout</span><span class="params">()</span> <span class="comment">// declares our own "cout" function</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">// makes std::cout accessible as "cout"</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, world!"</span>; <span class="comment">// uh oh!  Which cout do we want here?  The one in the std namespace or the one we defined above?</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>eg2中，编译器无法判断我们使用的<code>cout</code>是引用的 <code>std::cout</code>还是 cout函数。并出现“不明确的符号”错误。</p><hr><p>解决方法：</p><ol><li><p>使用<code>using declaration</code> 来替代 <code>using directive</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="comment">//告诉编译器， cout 指的是 std::cout</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, world!"</span>; <span class="comment">//所以cout表示的是 std::cout</span></span><br></pre></td></tr></table></figure></li><li><p>显示的使用前缀：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, world!"</span>; <span class="comment">//告诉编译器使用的是std::cout</span></span><br></pre></td></tr></table></figure></li></ol></blockquote></li></ul><hr><h3 id="取消or替换-using语句"><a href="#取消or替换-using语句" class="headerlink" title="取消or替换 using语句"></a>取消or替换 using语句</h3><p>一旦，using语句被声明，那就没有办法在声明它的范围内使用另一个using语句替换或取消它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Foo;</span><br><span class="line">    <span class="comment">//此时无法使用一个其他的 using语句来 取消或替换 “using namespace Foo;”</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//using namespace Foo ends here</span></span><br></pre></td></tr></table></figure><p>对应它的最好办法就是，显示的限制 using语句 的范围：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> Foo; <span class="comment">//在这里调用Foo::中的东西</span></span><br><span class="line">    &#125; <span class="comment">//using namespace Foo 过期</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span><span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，<strong>可以显式地使用范围解析操作符(::)来避免所有这些麻烦。</strong></p><hr><h2 id="6-13-typedef与类型别名"><a href="#6-13-typedef与类型别名" class="headerlink" title="6.13 typedef与类型别名"></a>6.13 typedef与类型别名</h2><center>**优先使用类型别名，而不是typedefs，并大量使用它们来记录类型的含义**</center><p><code>typedef</code>允许程序猿去创建一个数据类型的别名。然后可以使用别名来替换这个类型真正的名字。</p><blockquote><p>Typedef的字面意思是“<strong>类型定义”</strong></p></blockquote><p>我们可以使用关键字<code>typedef</code>，来进行 类型定义：</p><blockquote><p><code>typedef a b</code> ：其中<code>a</code>表示类型的名字，<code>b</code>表示类型被替换成的别名.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> <span class="keyword">distance_t</span>; <span class="comment">//定义distance_t 作为 double类型 的别名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面两个语句是等价的:</span></span><br><span class="line"><span class="keyword">double</span> howFar;</span><br><span class="line"><span class="keyword">distance_t</span> howFar;</span><br></pre></td></tr></table></figure><blockquote><p>按照惯例，typedef名称是使用“_t”后缀声明的。这有助于指示标识符代表的是类型，而不是变量或函数，还有助于防止与其他标识符的命名冲突。</p></blockquote><hr><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>为了帮助解决这些问题，我们引入了一种改进的typedefs语法，它模仿了变量的声明方式。这种语法称为 <strong>type alias(类型别名)</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> <span class="keyword">distance_t</span>; <span class="comment">//定义distance_t 作为 double类型的 别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">distance_t</span> = <span class="keyword">double</span>; <span class="comment">//定义distance_t 作为 double类型的 别名【推荐】</span></span><br></pre></td></tr></table></figure><blockquote><p>上面两个语句在功能上等价。</p><p>【NOTE】虽然使用了关键字<code>using</code>（在这里是重载的意义），但这和 与命名空间相关的 using语句 没有关系。</p></blockquote><hr><h4 id="为易读性使用类型别名"><a href="#为易读性使用类型别名" class="headerlink" title="为易读性使用类型别名"></a>为易读性使用类型别名</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GradeTest</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>我们可以看到返回值是一个整数，但是这个整数是什么意思呢?一个字母等级?遗漏了多少问题?学生的身份证号码?一个错误代码?谁知道!Int不能告诉我们任何东西。写成下面形式，便于理解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> testScore_t = <span class="keyword">int</span>;</span><br><span class="line"><span class="function">testScore_t <span class="title">GradeTest</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="使用类型别名编写与平台无关的代码"><a href="#使用类型别名编写与平台无关的代码" class="headerlink" title="使用类型别名编写与平台无关的代码"></a>使用类型别名编写与平台无关的代码</h4><p>比如，在一些平台中，<code>int</code>类型占2个字节；但在其他平台中，可能占4个字节。所以，在4字节平台中写的代码在2字节平台中可能会出错。</p><p>所以，使用类型别名可以帮助我们避免出错，也更清楚地说明了对变量大小的假设。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> INT_2_BYTES</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">int8_t</span> = <span class="keyword">char</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">int16_t</span> = <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">int32_t</span> = <span class="keyword">long</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">int8_t</span> = <span class="keyword">char</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">int16_t</span> = short;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">int32_t</span> = <span class="keyword">int</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><blockquote><p>如果，在一个机器中，整数是2个字节。那么<code>INT_2_BYTES</code>将被定义。此时，就使用的是上部定义的这几个。</p><p>如果，在一个机器中，整数是4个字节。那么<code>INT_2_BYTES</code>将不被定义。此时，就使用的是下部定义的这几个。</p><hr><p>这种情况下：通过使用char、short、int和long的组合，这对于正在编译程序的机器是合适的</p><p><code>int_8</code>将处理 1字节的整数；</p><p><code>int16_t</code>将处理 2字节的整数；</p><p><code>int32_t</code>将处理 4字节的整数。</p></blockquote><hr><h2 id="6-14-关键字auto"><a href="#6-14-关键字auto" class="headerlink" title="6.14 关键字auto"></a>6.14 关键字<code>auto</code></h2><p>看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d &#123;<span class="number">5.0</span>&#125;;</span><br></pre></td></tr></table></figure><p>如果C++早就知道<code>5.0</code>是double类型的数字，那为什么我们还要显示的指定<code>d</code>是double类型的呢？如果我们可以让一个变量根据我们初始化它的值来设想它的类型，这不是很好吗?</p><h3 id="初始化变量的类型推断"><a href="#初始化变量的类型推断" class="headerlink" title="初始化变量的类型推断"></a>初始化变量的类型推断</h3><p>当初始化一个变量，关键字<code>auto</code>可以用来代替类型，以告诉编译器从初始化器的类型推断变量的类型。这种就叫作：<strong><em>type inference</em>(类型推断)</strong>, 英文中也可以叫作：<strong><em>type deduction</em></strong></p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> d &#123;<span class="number">5.0</span>&#125;; <span class="comment">//因为5.0是一个double类型的数字，所以它的类型将被推断为double</span></span><br><span class="line"><span class="keyword">auto</span> i &#123;<span class="number">1</span>+<span class="number">2</span>&#125;; <span class="comment">//因为1+2的结果是int类型，所以，i 将被推断为int类型</span></span><br></pre></td></tr></table></figure><p>也可以用在函数返回值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sum&#123;add(<span class="number">5</span>,<span class="number">6</span>)&#125;; <span class="comment">//add() 返回一个int, 所以sum的类型将被推断为int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="在C-14中函数的类型推断"><a href="#在C-14中函数的类型推断" class="headerlink" title="在C++14中函数的类型推断"></a>在C++14中函数的类型推断</h3><p>在C++14中，关键字<code>auto</code>被扩展到可以从函数体中的返回语句推断出函数的返回类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为<code>x+y</code>的值是int类型，编译器将会推断这个函数应该返回一个int类型。当使用<code>auto</code>返回类型时，所有的返回语句就必须返回相同的类型，否则将会出错。</p></blockquote><p>但是不推荐对函数的返回类型使用关键字<code>auto</code>。</p><blockquote><p>因为没有上下文来帮助指示函数返回的类型。用户实际上必须深入函数体本身来确定函数返回的类型。它不那么直观，因此更容易出错。</p></blockquote><hr><h3 id="后置返回类型语法"><a href="#后置返回类型语法" class="headerlink" title="后置返回类型语法"></a>后置返回类型语法</h3><p>关键字<code>auto</code>也可以被用来<strong>后置返回类型(trailing return syntax)</strong>。即，在函数原型之后指定返回的类型。</p><blockquote><p>这是C++11新增的<strong>一种函数声明</strong>的方法。</p></blockquote><p>下面的两个对函数声明的语句是等价的：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">auto add(int x, int y) -&gt; int;//在这种情况下，auto不执行类型推断——使用后置返回类型只是语法的一部分。</span><br></pre></td></tr></table></figure><hr><p>那为什么要用后置类型返回语句呢？其中的好处之一就是：可以让函数的声明时的名字对齐😊，如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto add(int x, int y) -&gt; int;</span><br><span class="line">auto divide(double x, double y) -&gt; double;</span><br><span class="line">auto printSomething() -&gt; void;</span><br><span class="line">auto generateSubstring(const std::string &amp;s, int start, int len) -&gt; std::string;</span><br></pre></td></tr></table></figure><hr><h3 id="函数形参的类型推断"><a href="#函数形参的类型推断" class="headerlink" title="函数形参的类型推断"></a>函数形参的类型推断</h3><blockquote><p><strong>在C++20时引入的</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">auto</span> x, <span class="keyword">auto</span> y)</span> <span class="comment">//only valid in C++20</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    add(<span class="number">2</span>, <span class="number">3</span>);    <span class="comment">//int</span></span><br><span class="line">    add(<span class="number">1.1</span>, <span class="number">2.2</span>); <span class="comment">//double</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在C++20之前</strong>，这种形式是无效的。因为编译器在 编译时(complie time) 不能推断函数形参的类型。</p><blockquote><p>在C++20之前，如果你想要创建一个使用各种不同类型的泛型函数，你需要使用<code>function templates</code>，而不是现在用的<code>type inference</code></p></blockquote><hr><h3 id="6-15-强制类型转换-隐式"><a href="#6-15-强制类型转换-隐式" class="headerlink" title="6.15 强制类型转换(隐式)"></a>6.15 强制类型转换(隐式)</h3><blockquote><p>类型转换有两种形式：</p><ul><li><strong>implicit type conversion</strong>（隐式类型转换）：编译器会自动将一种数据类型转换为另一种数据类型</li><li><strong>explicit type conversion</strong>（显示类型转换）：开发人员使用转换操作符来指导转换。</li></ul></blockquote><p>将值从一种数据类型转换为另一种数据类型的过程称为<strong><em>type conversion</em>(类型转换)</strong>。类型转换可以在许多不同的情况下发生:</p><ul><li><p>当用不同数据类型的值 分配 或 初始 化一个变量时:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d&#123;<span class="number">3</span>&#125;;  <span class="comment">// initialize double variable with integer value 3</span></span><br><span class="line">d = <span class="number">6</span>;    <span class="comment">// assign double variable the integer value 6</span></span><br></pre></td></tr></table></figure></li><li><p>当传递一个值给一个函数时，但函数参数是不同的数据类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">long</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">doSomething(<span class="number">3</span>); <span class="comment">// pass integer value 3 to a function expecting a long parameter</span></span><br></pre></td></tr></table></figure></li><li><p>当从一个函数返回一个值时，该函数的返回类型是不同的数据类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3.0</span>; <span class="comment">// Return double value 3.0 back to caller through float return type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用不同类型的操作数的 二元操作符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> division&#123; <span class="number">4.0</span> / <span class="number">3</span> &#125;; <span class="comment">// division with a double and an integer</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p><strong>隐式类型转换</strong>(也称为<strong>自动类型转换</strong>或<strong>强制转换</strong>)在希望是这种数据类型，但提供了另一种数据类型。乳沟编译器能够辨认出类型转换中的两种类型，挠他就转换。否则，报错。</p><blockquote><p>隐式类型转换有两种基本类型：<strong>提升</strong>和<strong>转换</strong>。</p></blockquote><ul><li><p><strong><em>Numeric promotion</em>数值提升</strong></p><p>每当将一个基本数据类型的值转换为来自同一族的更大的基本数据类型的值时，这称为<strong>数值提升</strong>(或<strong>加宽</strong>，尽管这个术语通常用于整数)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//an int can be widened into a long, or a float promoted into a double:</span></span><br><span class="line"><span class="keyword">long</span> l&#123; <span class="number">64</span> &#125;; <span class="comment">// widen the integer 64 into a long</span></span><br><span class="line"><span class="keyword">double</span> d&#123; <span class="number">0.12f</span> &#125;; <span class="comment">// promote the float 0.12 into a double</span></span><br></pre></td></tr></table></figure><p>虽然术语数值推广涵盖了任何类型的提升，但在c++中还有两个具有特定含义的术语:</p><ul><li><strong>Integral promotion(整型提升)</strong>：可以将[ <code>bool</code> , <code>char</code>, <code>unsigned char</code>, <code>signed char</code>, <code>unsigned short</code>, and <code>signed short</code> ]这些类型转换为 <code>int</code>或者是<code>unsigned int</code></li><li><strong>Floating point promotion(浮点型提升)</strong>：可以将<code>float</code>类型转换为<code>double</code></li></ul><p>整型提升 和 浮点型提升 通常是将 较小的数据类型转换为<code>int</code>/<code>unsigned int</code>或<code>double</code>。</p><hr></li><li><p><strong>Numeric conversions(数值转换)</strong></p><p>当我们将一个值从较大的类型转换为类似的较小类型时，或者在不同类型之间转换时，这称为数值转换。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d&#123; <span class="number">3</span> &#125;; <span class="comment">// convert integer 3 to a double (between different types)</span></span><br><span class="line">short s&#123; <span class="number">2</span> &#125;; <span class="comment">// convert integer 2 to a short (from larger to smaller type within same type family)</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>数值提升</strong>是安全的；但是<strong>数值转换</strong>可能会丢失数据。</p><blockquote><p>因此，导致执行隐式转换的代码通常会导致编译器发出警告。</p></blockquote></blockquote><p>eg,将一个值转换为的类型没有足够大的范围来支持这个值，就会出现意想不到的结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i&#123; <span class="number">30000</span> &#125;;</span><br><span class="line">    <span class="keyword">char</span> c = i; <span class="comment">// chars have range -128 to 127</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(c);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果**********/</span></span><br><span class="line"><span class="number">48</span></span><br></pre></td></tr></table></figure><blockquote><p>在本例中，我们将一个大整数分配给一个char(其范围为-128到127)。这会导致char溢出，并产生一个意外的结果: 48</p></blockquote><p>但是，只要值符合较小类型的范围，从较大的整数或浮点类型转换为较小的类似类型通常就可以工作。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> i&#123; <span class="number">2</span> &#125;;</span><br><span class="line">    short s = i; <span class="comment">// convert from int to short</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">double</span> d&#123; <span class="number">0.1234</span> &#125;;</span><br><span class="line">    <span class="keyword">float</span> f = d;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********结果**************/</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">0.1234</span></span><br></pre></td></tr></table></figure><p>对于浮点值，由于较小类型的精度损失，可能会出现一些舍入。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">0.123456789</span>; <span class="comment">// double value 0.123456789 has 9 significant digits, but float can only support about 7</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">9</span>) &lt;&lt; f &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// std::setprecision defined in 头文件“iomanip”中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************结果************/</span></span><br><span class="line"><span class="number">0.123456791</span></span><br></pre></td></tr></table></figure><p>只要值符合浮点类型的范围，就可以将整数转换为浮点数。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> i&#123; <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">float</span> f = i;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************结果**************/</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>只要值符合整数的范围，就可以将浮点数转换为整数，但是任何小数值都会丢失。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> i = <span class="number">3.5</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***在本例中，丢失了分数值(.5)，结果如下:****/</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>计算算术表达式</strong></p><p>当计算表达式时，编译器将每个表达式分解成单独的子表达式。算术运算符要求它们的<strong>操作数必须是相同的类型</strong>。为了确保这一点，编译器使用以下规则:</p><ul><li><p>如果一个操作数是一个比<code>int</code>更窄的整数，它将经历整数提升(如上所述)到<code>int</code>或<code>usigned int</code>。</p></li><li><p>如果操作数仍然不匹配，那么编译器会找到优先级最高的操作数，并隐式地将另一个操作数转换为匹配的操作数。</p><blockquote><p>操作数的优先级如下:</p><ul><li>long double (highest)</li><li>double</li><li>float</li><li>unsigned long long</li><li>long long</li><li>unsigned long</li><li>long</li><li>unsigned int</li><li>int (lowest)</li></ul></blockquote></li></ul><p>我们可以通过使用typeid操作符(包含在头中)看到通常的算术转换，该操作符可用于显示表达式的结果类型。</p><p>eg1:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt; // for typeid()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    short a&#123; <span class="number">4</span> &#125;;</span><br><span class="line">    short b&#123; <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(a + b).name() &lt;&lt; <span class="string">" "</span> &lt;&lt; a + b &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// show us the type of a + b</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*因为short是整数，所以它们在被添加之前要经过整数提升到int。添加两个int的结果是一个int，正如您所期望的:*/</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><blockquote><p>注意:编译器可能会显示一些稍微不同的内容，因为typeid.name()的格式由编译器决定。</p></blockquote><p>eg2:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt; // for typeid()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d&#123; <span class="number">4.0</span> &#125;;</span><br><span class="line">    short s&#123; <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(d + s).name() &lt;&lt; <span class="string">' '</span> &lt;&lt; d + s &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// show us the type of d + s</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****结果*************/</span></span><br><span class="line"><span class="keyword">double</span> <span class="number">6.0</span></span><br></pre></td></tr></table></figure><p>在这种情况下，<code>short</code>将被 <em>数值提升</em> 为<code>int</code>。但是，<code>int</code>与<code>double</code>还是不匹配。又因为<code>double</code>在类型的层次结构中更高。所以，整型的2将被转换为double 类型的 2.0 。然后就相当于是两个double类型的相加，结果还是double类型.</p></li></ul><hr><h2 id="强制类型转换-显式-amp-static-cast"><a href="#强制类型转换-显式-amp-static-cast" class="headerlink" title="强制类型转换(显式) &amp; static_cast"></a>强制类型转换(显式) &amp; <code>static_cast</code></h2><p>显式的类型转换是使用 <strong>type casting operator(类型转换操作符)</strong>。（通常是程序员来做的一个显式的的类型转换）</p><p>在C++中，类型转换大致分为5种： <code>C-style casts</code>, <code>static casts</code>, <code>const casts</code>, <code>dynamic casts</code>, and <code>reinterpret casts</code>. 后四个有时被称为<strong>命名类型转换(named casts)</strong>。</p><p>在本节课中，我们将介绍c风格的类型转换和静态类型转换。我们将在以后的课程中讨论指针和继承时再保存动态类型转换。</p><blockquote><p>通常应该避免使用<code>Const casts</code>和<code>reinterpret casts</code>，因为它们只在极少数情况下有用，如果使用不当可能会有害。</p></blockquote><hr><h3 id="C-style-casts"><a href="#C-style-casts" class="headerlink" title="C-style casts"></a>C-style casts</h3><p>在标准的C语言中，类型转换是通过 <strong>操作符<code>()</code></strong>来完成的。括号内是将要转换的目标类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i1 &#123; <span class="number">10</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> i2 &#123; <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">float</span> f &#123; (<span class="keyword">float</span>)i1 / i2 &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>在上面的程序中，我们使用浮点c风格的强制转换来告诉编译器将<code>i1</code>转换为浮点值。</p><p>因为运算符<code>/</code>的左操作数现在变为浮点值，右操作符也将被转换为浮点值。并且除法将使用浮点除法而不是整数除法!</p></blockquote><hr><p><strong>使用强制类型转换来清除隐式类型转换</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i &#123; <span class="number">48</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// explicit conversion from int to char, so that a char is assigned to variable ch</span></span><br><span class="line"><span class="keyword">char</span> ch = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(i);</span><br></pre></td></tr></table></figure><blockquote><p>当我们这样做时，我们显式地告诉编译器这个转换是有意的，并且我们接受对结果的责任。因为这个<code>static_cast</code>的输出类型是char，所以对变量ch的赋值不会产生任何类型不匹配，因此没有警告。</p></blockquote><p>下面的程序，编译器将会抱怨将double转换成int可能会导致数据丢失:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i &#123; <span class="number">100</span> &#125;;</span><br><span class="line">i = i / <span class="number">2.5</span>;</span><br></pre></td></tr></table></figure><p>告诉编译器，我们明确的意思是这样做:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i &#123; <span class="number">100</span> &#125;;</span><br><span class="line">i = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(i / <span class="number">2.5</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="6-17-未命名-内联-命名空间"><a href="#6-17-未命名-内联-命名空间" class="headerlink" title="6.17 未命名/内联 命名空间"></a>6.17 未命名/内联 命名空间</h2><h3 id="未命名-匿名-命名空间"><a href="#未命名-匿名-命名空间" class="headerlink" title="未命名(匿名) 命名空间"></a>未命名(匿名) 命名空间</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> <span class="comment">// unnamed namespace</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="comment">// can only be accessed in this file</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    doSomething(); <span class="comment">// we can call doSomething() without a namespace prefix</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果**********/</span></span><br><span class="line">v1</span><br></pre></td></tr></table></figure><blockquote><p>在未命名的命名空间中声明的所有内容都被视为父命名空间的一部分。因此，尽管<code>doSomething</code>函数是在未命名的命名空间中定义的，但函数本身可以从父命名空间(在本例中是<code>global namespace</code>)访问，这就是为什么我们可以从main调用doSomething而不需要任何限定符。</p></blockquote><p>这可能使未命名的命名空间看起来毫无用处。但未命名名称空间的另一个影响是：未命名命名空间内的所有标识符都被视为具有<strong>内部链接</strong>，<u>这意味着未命名命名空间的内容就不能在其他文件中看到</u>。</p><hr><p><strong>对于函数</strong>，<u>这实际上等同于将未命名的命名空间中的所有函数定义为<strong>静态函数</strong></u>。下面的程序与上面的程序实际上是相同的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="comment">// can only be accessed in this file</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    doSomething(); <span class="comment">// we can call doSomething() without a namespace prefix</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong><code>unnamed namespace</code></strong>通常用于 当你有很多内容想要确保在给定文件中保持局部时，使用<code>unnamed namespace</code>要比单独将所有声明标记为<code>static</code>更容易。</p><hr><h3 id="内联-命名空间"><a href="#内联-命名空间" class="headerlink" title="内联 命名空间"></a>内联 命名空间</h3><blockquote><p><strong>Inline namespaces</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    doSomething();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是假设你对doSomething不满意，你想通过改变它的行为方式来改进它。但如果这样做，就有可能破坏使用旧版本的现有程序。你是怎么处理的?</p><ul><li><p>一种方法是用不同的名称创建函数的新版本。但是经过许多更改之后，您可能会得到一组名称几乎相同的函数(doSomething、doSomething_v2、doSomething_v3等)。</p></li><li><p>【推荐】另一种方法是使用<strong>内联命名空间</strong>。<u>内联命名空间是通常用于版本化内容的名称空间</u>。与未命名的命名空间非常相似，<u>在内联命名空间中声明的任何内容都被认为是父名称空间的一部分</u>。<u>然而，内联命名空间并不是 内部链接。</u></p><blockquote><p>使用关键字<code>inline</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">namespace</span> v1 <span class="comment">// declare an inline namespace named v1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> v2 <span class="comment">// declare a normal namespace named v2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v2\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    v1::doSomething(); <span class="comment">// calls the v1 version of doSomething()</span></span><br><span class="line">    v2::doSomething(); <span class="comment">// calls the v2 version of doSomething()</span></span><br><span class="line"> </span><br><span class="line">    doSomething(); <span class="comment">// calls the inline version of doSomething() (which is v1)</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********结果********/</span></span><br><span class="line">v1</span><br><span class="line">v2</span><br><span class="line">v1</span><br></pre></td></tr></table></figure><blockquote><p>可以看出，当有 <strong>内联函数</strong>存在时，<u>如果不加前缀，<strong>则默认调用的是 内联函数版本</strong></u></p></blockquote><p>在上面的例子中，调用<code>doSomething</code>将得到<code>doSomething</code>的v1(内联版本)。希望使用新版本的调用者可以<strong>显式</strong>地调用<code>v2::dosomething()</code>。</p><blockquote><p>这保留了现有程序的功能，同时允许更新的程序利用更新的/更好的变体。</p></blockquote><hr></li></ul><h2 id="6-x-Chapter-6-summary-and-quiz"><a href="#6-x-Chapter-6-summary-and-quiz" class="headerlink" title="6.x Chapter 6 summary and quiz"></a>6.x Chapter 6 summary and quiz</h2><p><a href="https://www.learncpp.com/cpp-tutorial/chapter-6-summary-and-quiz/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/chapter-6-summary-and-quiz/</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转载他人的方法</title>
      <link href="/archives/9f0a1d82.html"/>
      <url>/archives/9f0a1d82.html</url>
      
        <content type="html"><![CDATA[<a id="more"></a><ol><li><strong>WSL 使用指南</strong>：<a href="https://zhuanlan.zhihu.com/p/36482795" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/36482795</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GIT 学习</title>
      <link href="/archives/18085cf9.html"/>
      <url>/archives/18085cf9.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red></red>Git学习笔记</p></center><a id="more"></a><p>Git的三种状态：</p><blockquote><p>committed（已提交）：数据已经安全的保存在本地数据库（仓库）；</p><p>modified（已修改）：修改了文件，<strong>但还没有保存到数据库</strong>；</p><p>staged（已暂存）：对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</p></blockquote><p>Git项目的三个工作区域概念：</p><blockquote><p><strong>Git仓库（Git directory 或 repository）：</strong>是Git用来保存项目的元数据和对象数据库的地方。是Git最重要部分，从其他计算机克隆仓库时，拷贝的就是这里的数据。</p><p><strong>工作目录（working directory）：</strong>对项目的某个版本独立提取出来的内容。这些从Git仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</p><p><strong>暂存区域（staging area）：</strong>是一个文件，保存了下一次将提交的文件列表信息，一般在Git仓库目录中，有时也被称作“索引”。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/1576831394522.png" alt="1576831394522"></p><p>基本的 Git 工作流程如下：</p><blockquote><p>1.在工作目录中修改文件；</p><p>2.暂存文件，将文件的快照放入暂存区域；</p><p>3.提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目。</p></blockquote><h1 id="初始设置："><a href="#初始设置：" class="headerlink" title="初始设置："></a>初始设置：</h1><h2 id="设置姓名和邮箱："><a href="#设置姓名和邮箱：" class="headerlink" title="设置姓名和邮箱："></a>设置姓名和邮箱：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Firstname Lastname&quot; &#x2F;&#x2F; 名字使用英文输入</span><br><span class="line">git config --global user.email &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><p>这个命令，会在“<code>~/.gitconfig</code>”中以如下形式输出设置文件。我的电脑上，这个文件夹的位置在<code>C:\Users\ACER</code></p><h2 id="设置SSH-key"><a href="#设置SSH-key" class="headerlink" title="设置SSH key:"></a>设置<code>SSH key</code>:</h2><p>创建公开密钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，我的在：<code>C:\Users\ACER\.ssh</code></p><p>里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是<strong>私钥</strong>，不能泄露出去，<code>id_rsa.pub</code>是<strong>公钥</strong>，可以放心地告诉任何人。</p><h2 id="初始化Git仓库："><a href="#初始化Git仓库：" class="headerlink" title="初始化Git仓库："></a>初始化Git仓库：</h2><p>在该仓库中，打开Git bash，然后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><h2 id="关联远程仓库："><a href="#关联远程仓库：" class="headerlink" title="关联远程仓库："></a>关联远程仓库：</h2><p>在远程仓库（如：<code>github、gitee</code>）中有一个新仓库什么都没有，我们可以：</p><p>克隆一份到本地；也可以把一个已有的本地仓库与之关联。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git remote add &lt;远程仓库名字&gt; &lt;远程仓库的SSH或HTTPS&gt;</span><br><span class="line"></span><br><span class="line">如：git remote add origin git@github.com:michaelliao&#x2F;learngit.git</span><br><span class="line">其中：</span><br><span class="line">远程仓库名字：origin（是git的默认叫法，也可以写成其他的）</span><br><span class="line">远程仓库的SSH：git@github.com:longlongqin&#x2F;learngit.git</span><br></pre></td></tr></table></figure><ul><li><input checked disabled type="checkbox"> <strong>当需要将<u>一个仓库</u>同时在<code>github 和 gitee</code>上关联时：</strong></li></ul><ol><li><p>假如在<code>gitee</code>上关联之前，已经在<code>GitHub</code>上关联过了。</p><p>比如事先在GitHub上：<code>git remote add origin git@github.com:longlongqin/LearnGit.git</code>，关联了一个叫<code>origin</code>的远程仓库。</p><p>然后，我现在要在gitee上关联一个仓库：</p><p><code>git remote add origin git@gitee.com:longlongqin/LearnGit.git</code></p><p>出现<u>报错</u>：fatal: remote origin already exists.说明，本地库已经关联了一个叫做<code>origin</code>的远程仓库了，所以才会报错。</p></li><li><p>所以，我们知道，不能将github和gitee上的仓库名字都叫一样的名字。他们之间的名字要区分。</p></li></ol><blockquote><ul><li><p>先，删除关联的已有的GitHub远程库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure></li><li><p>再开始重新关联github和gitee的仓库，这次要将他们的仓库名字区分开：</p><p>/*gitee中的LearnGit仓库起名：<code>gitee</code>；</p><p>/*github中的LearnGit仓库起名：<code>github</code>；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote gitee origin git@gitee.com:longlongqin&#x2F;LearnGit.git</span><br><span class="line">git remote github origin git@github.com:longlongqin&#x2F;LearnGit.git</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>检查一下，是否成功：</p><p>​ 我们用<code>git remote -v</code>查看远程库信息，可以看到两个远程库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">giteegit@gitee.com:longlongqin&#x2F;LearnGit.git (fetch)</span><br><span class="line">giteegit@gitee.com:longlongqin&#x2F;LearnGit.git (push)</span><br><span class="line">githubgit@github.com:longlongqin&#x2F;LearnGit.git (fetch)</span><br><span class="line">githubgit@github.com:longlongqin&#x2F;LearnGit.git (push)</span><br></pre></td></tr></table></figure><p>成功。</p><h2 id="取消关联远程仓库："><a href="#取消关联远程仓库：" class="headerlink" title="取消关联远程仓库："></a>取消关联远程仓库：</h2><p>在<strong><em>关联远程仓库</em></strong>一节中，关联远程仓库，我们也可以取消以经关联的远程仓库，让他们取消关联：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm &lt;要取消关联的远程仓库的名字&gt;</span><br></pre></td></tr></table></figure><h1 id="时光穿梭机"><a href="#时光穿梭机" class="headerlink" title="时光穿梭机"></a>时光穿梭机</h1><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><blockquote><p>1、<strong>没有<code>git add</code>时</strong>（即，对文件做了修改，但是没添加到暂存区）：==用<code>git checkout -- &lt;file&gt;</code> (==file前面有一个<strong>空格</strong>)</p><p>2、<strong>已经<code>git add</code>时</strong>（即，对文件做了修改，并且添加到暂存区）：</p><ul><li>先<code>git reset HEAD &lt;file&gt;</code>把暂存区的修改撤销掉，即：回退到没有git add时的状态</li><li>然后，再<code>git checkout -- &lt;file&gt;</code>。</li></ul><p>3、<strong>已经<code>git commit</code>时</strong>（即，对文件做了修改，不仅添加到暂存区，而且还提交到本地仓库中了）：进行==<strong>版本回退</strong>==</p></blockquote><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>版本之间的切换，<strong>版本</strong>指的是<code>git commit</code>之后带有哈希值的状态。</p><p><strong>版本回退</strong>：</p><ul><li><p><code>git reset --hard commit_id</code> 可以回退到版本号为commit_id的那个版本。</p></li><li><p><code>git reset --hard head^</code> 回退到当前版本的上一个版本。</p></li></ul><p><strong>转回到新版本</strong>：</p><p>因为<code>git log</code>显示的是从此刻<code>head指针</code>所在的状态到之前的状态的提交日志。而<code>git reflog</code>用来记录你的每一次命令。</p><p>所以转回到比当前所在的状态要新的状态需要：</p><ol><li><code>git reflog</code>,找到你想要回去的那个较新的状态的commit 的id</li><li><code>git reset --hard &lt;commit_id&gt;</code> 回到想要回器的那个版本。</li></ol><h1 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h1><ul><li><code>rm &lt;file&gt;</code>从工作区中删除文件（和手动删除文件效果一样。）</li></ul><p><code>git rm &lt;file&gt;</code>将文件从工作区删除，并且还添加到了暂存区（即，把删除的这个状态同步到暂存区了）。</p><p>[^小提示]: 先手动删除文件，然后使用git rm<file>和git add<file>效果是一样的。</file></file></p><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><h2 id="添加远程仓库："><a href="#添加远程仓库：" class="headerlink" title="添加远程仓库："></a>添加远程仓库：</h2><blockquote><p>关联一个远程仓库：<code>git remote add origin git@github.com:path/repo-name.git</code></p><p>关联后，<strong>第一次</strong>推送master分支的所有内容：<code>git push origin master</code></p></blockquote><h2 id="远程仓库克隆："><a href="#远程仓库克隆：" class="headerlink" title="远程仓库克隆："></a>远程仓库克隆：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;你想要克隆内容的公开密钥的密码&gt;</span><br></pre></td></tr></table></figure><p>公开的密钥密码，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200218130632774.png" alt="image-20200218130632774"></p><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><h2 id="创建与合并分支："><a href="#创建与合并分支：" class="headerlink" title="创建与合并分支："></a>创建与合并分支：</h2><ul><li><p><strong>查看分支</strong>：<code>git branch</code></p></li><li><p><strong>新建分支</strong>：<code>git branch &lt;name&gt;</code></p></li><li><p><strong>创建并切换分支</strong>：<code>git checkout -b &lt;name&gt;</code> or <code>git switch -c &lt;name&gt;</code></p></li><li><p><strong>切换分支</strong>：<code>git checkout &lt;name&gt;</code> or <code>git switch &lt;name&gt;</code></p></li><li><p><strong>删除分支</strong>：<code>git branch -d &lt;name&gt;</code><em>不能删除当前所在的分支</em></p></li><li><p><strong>合并分支</strong>：<code>git merge &lt;name&gt;</code> <em>用于合并分支到<strong>当前</strong>分支</em></p></li></ul><blockquote><p><code>git merge --no-ff &lt;name&gt;</code> 其中参数–no-ff：表示在历史记录中明确记录下本次分支合并。</p><p><strong>注意</strong>：输入此命令之后，会启动编辑器，用于录入合并提交的信息。</p></blockquote><h2 id="解决冲突："><a href="#解决冲突：" class="headerlink" title="解决冲突："></a>解决冲突：</h2><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p><p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p><p>用<code>git log --graph</code>命令可以看到分支合并图。</p><h2 id="分支管理策略："><a href="#分支管理策略：" class="headerlink" title="分支管理策略："></a>分支管理策略：</h2><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p><p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p><p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p><p>所以，团队合作的分支看起来就像这样：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/0.png" alt="0"></p><p>小结：</p><p>Git分支十分强大，在团队开发中应该充分应用。</p><p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p><h2 id="合并分支的两种方式："><a href="#合并分支的两种方式：" class="headerlink" title="合并分支的两种方式："></a>合并分支的两种方式：</h2><p><strong>git 的 <code>merge</code> 与 <code>merge no-ff</code> 的不同之处</strong>： <code>no-ff merge</code>可以看到合并历史。</p><blockquote><ol><li><p>新建分支<code>dev1</code>，修改<code>readme.txt</code>，然后在<code>dev1</code>分支下<code>git add readme.txt</code> <code>git commit -m &quot;dev1 branch commit&quot;</code></p></li><li><p>回到<code>master</code>分支，执行merge即<code>git merge dev1</code></p></li><li><p>删除分支</p></li><li><p>查看日志即<code>git log --graph --pretty=oneline --abbrev-commit</code></p></li><li><p>新建分支<code>dev2</code>，修改<code>readme.txt</code>，然后在<code>dev2</code>分支下<code>git add readme.txt</code> <code>git commit -m &quot;dev2 branch commit&quot;</code></p></li><li><p>回到<code>master</code>分支，执行merge即<code>git merge --no-ff -m &quot;dev2 merged with mo-ff&quot; dev2</code></p></li><li><p>删除分支</p></li><li><p>查看日志即<code>git log --graph --pretty=oneline --abbrev-commit</code></p></li><li><p>比较两次合并，可以看出不同之处，<code>no-ff</code>的模式会记录分支历史、</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://app.yinxiang.com/FileSharing.action?hash=1/792dd8c14a3b3fed2cf0044d82d01671-16494" alt="img"></p></li></ol></blockquote><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查 Git 的某一项配置：</span></span><br><span class="line">git <span class="built_in">config</span>  &lt;key&gt; </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/1576832423904.png" alt="1576832423904"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//列出所有 Git 当时能找到的配置：</span></span><br><span class="line"> git <span class="built_in">config</span> --<span class="built_in">list</span> </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/1576832563424.png" alt="1576832563424"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取帮助：3种方法</span></span><br><span class="line">$ git help &lt;verb&gt;</span><br><span class="line">$ git &lt;verb&gt; --help</span><br><span class="line">$ man git-&lt;verb&gt;</span><br></pre></td></tr></table></figure></blockquote><h1><a href="#" class="headerlink" title="###############################################"></a>###############################################</h1><h1 id="Git-其他指令："><a href="#Git-其他指令：" class="headerlink" title="Git 其他指令："></a>Git 其他指令：</h1><h2 id="查看工作区状态status："><a href="#查看工作区状态status：" class="headerlink" title="查看工作区状态status："></a>查看<code>工作区</code>状态<code>status</code>：</h2><p><code>git status</code>查看的是工作区的状态。</p><blockquote><p><code>git diff</code> 查看工作区与暂存区的区别。</p><p><code>git diff head</code>查看工作区与本地仓库的区别。</p></blockquote><h2 id="查看文件内容："><a href="#查看文件内容：" class="headerlink" title="查看文件内容："></a>查看文件内容：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;name&gt;</span><br></pre></td></tr></table></figure><h2 id="提交："><a href="#提交：" class="headerlink" title="提交："></a>提交：</h2><h3 id="工作区提交到暂存区："><a href="#工作区提交到暂存区：" class="headerlink" title="工作区提交到暂存区："></a>工作区提交到暂存区：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &quot;filename&quot;</span><br></pre></td></tr></table></figure><h3 id="暂存区提交到本地仓库："><a href="#暂存区提交到本地仓库：" class="headerlink" title="暂存区提交到本地仓库："></a>暂存区提交到本地仓库：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;message&quot; &#x2F;&#x2F;message是对此次提交的一个说明语句</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br><span class="line">&#x2F;&#x2F;此命令可以更加详细的记述提交信息（运行此命令后，会自动打开Git设置好的编辑器）</span><br></pre></td></tr></table></figure><blockquote><p>执行此命令后，编辑器就会启动，显示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with &#39;#&#39; will be ignored, and an empty message aborts the commit.</span><br><span class="line">#</span><br><span class="line"># On branch dev</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#modified:   readme.txt</span><br><span class="line">#</span><br></pre></td></tr></table></figure><p>在编辑器中记述提交信息的格式如下：</p><p>● 第一行：用一行文字简述提交的更改内容</p><p>● 第二行：空行</p><p>● 第三行以后：记述更改的原因和详细内容</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200218142052540.png" alt="image-20200218142052540"></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend :修改上一条提交时写的信息</span><br></pre></td></tr></table></figure><h3 id="本地仓库提交-推送-到远程仓库："><a href="#本地仓库提交-推送-到远程仓库：" class="headerlink" title="本地仓库提交(推送)到远程仓库："></a>本地仓库提交(推送)到远程仓库：</h3><center>git push</center><p><strong>情况一：</strong></p><p>注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以git pull是&lt;远程分支&gt;:&lt;本地分支&gt;，而git push是&lt;本地分支&gt;:&lt;远程分支&gt;。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程仓库名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure><p><strong>情况二：（推荐）</strong></p><p>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程仓库名字&gt; &lt;将本地的分支推送到远程仓库的分支（本地分支和远程分支的名字一样）&gt;</span><br><span class="line"></span><br><span class="line">如：git push origin master</span><br><span class="line">上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。</span><br></pre></td></tr></table></figure><p><strong>情况三：</strong></p><p>下面命令将本地的<code>master</code>分支推送到<code>origin</code>远程仓库，同时指定<code>origin</code>为默认仓库，后面就可以不加任何参数使用<code>git push</code>了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u &lt;远程仓库名字&gt; &lt;将本地的分支推送到远程仓库的分支（本地分支和远程分支的名字一样）&gt;</span><br></pre></td></tr></table></figure><p><strong>情况四：</strong></p><p>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push origin :&lt;远程分支&gt;</span><br><span class="line"></span><br><span class="line"># 等同于:git push origin --<span class="keyword">delete</span> master</span><br></pre></td></tr></table></figure><h2 id="获取最新的远程仓库的分支："><a href="#获取最新的远程仓库的分支：" class="headerlink" title="获取最新的远程仓库的分支："></a>获取最新的远程仓库的分支：</h2><p>加入在远程仓库中的一个分支中的内容更新了，而本地的这个分支（和远程的这个分支名字相同）不是最新的，可以用<code>git pull</code>来同步。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;远程仓库名&gt; &lt;需要更新的分支（这个分支名：本地的和远程的名字一样）&gt;</span><br></pre></td></tr></table></figure><p>如：</p><p><code>git pull origin feature-D</code>，表示：从远程仓库<code>origin</code>中的“<code>feature-D</code>”分支进行对本地的分支“<code>feature-D</code>”更新。</p><h2 id="查看提交历史："><a href="#查看提交历史：" class="headerlink" title="查看提交历史："></a>查看提交历史：</h2><ul><li><p><code>git log</code> 查看提交（commit）历史（以便确定要回退到哪个版本）。</p><p>​ 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数，即：<code>git log --pretty=oneline</code></p></li></ul><blockquote><ul><li><p><code>git log &lt;filename&gt;</code> ：显示特定文件(filename)的提交历史</p></li><li><p><code>git log -p</code> ：文件的前后差别就会显示在提交信息之后</p></li><li><p><code>git log -p &lt;filename&gt;</code> ：只查看 “filename”文件的提交日 志以及提交前后的差别。</p></li><li><p><code>git log --graph</code>：以图表形式查看分支，例如下图：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200222002143874.png" alt="image-20200222002143874"></p></blockquote><ul><li><code>git reflog</code> 查看历史的每一次的命令（以便确定要回到未来的哪个版本）。</li></ul><h2 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git:"></a>自定义Git:</h2><h3 id="修改GIT默认编辑器："><a href="#修改GIT默认编辑器：" class="headerlink" title="修改GIT默认编辑器："></a>修改GIT默认编辑器：</h3><p>GIT默认编辑器为Vi，假如我想用<code>Notepad++</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitconfig--globalcore.editor&quot;Notepad++&quot;&#x2F;&#x2F;设置Editor使用Notepad++</span><br></pre></td></tr></table></figure><h3 id="Git显示颜色："><a href="#Git显示颜色：" class="headerlink" title="Git显示颜色："></a>Git显示颜色：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global color.ui true</span><br></pre></td></tr></table></figure><h1 id="-1"><a href="#-1" class="headerlink" title="##################################################"></a>##################################################</h1><h1 id="学习廖雪峰教学中的问题："><a href="#学习廖雪峰教学中的问题：" class="headerlink" title="学习廖雪峰教学中的问题："></a>学习廖雪峰教学中的问题：</h1><p>1、与教学步骤中的命令区别于：“–”</p><p>（1）<code>git diff head --readme.txt</code>：</p><p>问题：在我自己电脑上面运行没反应？</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200112221142249.png" alt="image-20200112221142249"></p><p><strong>解决：</strong></p><p>运行<code>：git diff head readme.txt</code>,即去掉那个“–”。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200112221407621.png" alt="image-20200112221407621"></p><p>（2）<code>git checkout --readme.txt</code></p><p>问题：在于我的电脑上多了“–”会运行失败。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200112222013881.png" alt="image-20200112222013881"></p><p>解决：去掉“–”：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200112222046360.png" alt="image-20200112222046360"></p><hr><h1 id="GitHub使用技巧"><a href="#GitHub使用技巧" class="headerlink" title="GitHub使用技巧"></a><a href="https://www.zhihu.com/question/20084458" target="_blank" rel="noopener">GitHub使用技巧</a></h1><h2 id="搜索："><a href="#搜索：" class="headerlink" title="搜索："></a>搜索：</h2><h3 id="1）、在不同地方搜索"><a href="#1）、在不同地方搜索" class="headerlink" title="1）、在不同地方搜索"></a>1）、在不同地方搜索</h3><h4 id="1、按照name搜索"><a href="#1、按照name搜索" class="headerlink" title="1、按照name搜索"></a>1、<strong>按照<code>name</code>搜索</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in:name &lt;something&gt;    &#x2F;&#x2F;假设想搜索的东西叫：something</span><br></pre></td></tr></table></figure><h4 id="2、按照readme搜索"><a href="#2、按照readme搜索" class="headerlink" title="2、按照readme搜索"></a>2、按照<code>readme</code>搜索</h4><p>也可以按照<code>readme.md</code>中包含<something>的查找项目：</something></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in:readme &lt;something&gt;   &#x2F;&#x2F;假设想搜索的东西叫：something</span><br></pre></td></tr></table></figure><h4 id="3、按照descriptin搜索"><a href="#3、按照descriptin搜索" class="headerlink" title="3、按照descriptin搜索"></a>3、按照<code>descriptin</code>搜索</h4><p>假设我们现在要学习<something>的项目，我们搜索项目描述(description)里面包含<something>的项目:</something></something></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in:description &lt;something&gt;   &#x2F;&#x2F;假设想搜索的东西叫：something</span><br></pre></td></tr></table></figure><h4 id="4、直接搜索"><a href="#4、直接搜索" class="headerlink" title="4、直接搜索"></a>4、直接搜索</h4><p>直接在搜索栏中搜索：加入想搜索与<code>CJSON</code>有关的内容：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200219151224327.png" alt="image-20200219151224327"></p><h3 id="2）、添加约束条件"><a href="#2）、添加约束条件" class="headerlink" title="2）、添加约束条件"></a>2）、添加约束条件</h3><h4 id="star数量"><a href="#star数量" class="headerlink" title="star数量"></a><strong><code>star</code>数量</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stars: &gt; 500     &#x2F;&#x2F; star 数量大于500的项目</span><br><span class="line">stars: 10..20    &#x2F;&#x2F; star 数量在10-20之间的仓库</span><br></pre></td></tr></table></figure><h4 id="fork数量"><a href="#fork数量" class="headerlink" title="fork数量"></a><code>fork</code>数量</h4><p>同理，我们也可以按照fork的数量来进行搜索:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in:name React  forks:&gt;3000</span><br></pre></td></tr></table></figure><hr><h4 id="language编程语言"><a href="#language编程语言" class="headerlink" title="language编程语言"></a><code>language</code>编程语言</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">language:python   &#x2F;&#x2F;比如，把语言限制为Python</span><br></pre></td></tr></table></figure><h4 id="仓库push的时间"><a href="#仓库push的时间" class="headerlink" title="仓库push的时间"></a>仓库<code>push</code>的时间</h4><p>假如在这些项目里面，我们想要找到最近才更新的项目，意思是更新时间就在最近，我们可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pushed:&gt;2020-01-01  &#x2F;&#x2F;项目的最近一次更新时间限制到2020-01-01之后</span><br></pre></td></tr></table></figure><hr><h4 id="仓库持有者"><a href="#仓库持有者" class="headerlink" title="仓库持有者"></a>仓库持有者</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user：&lt;username&gt;</span><br></pre></td></tr></table></figure><h4 id="仓库大小"><a href="#仓库大小" class="headerlink" title="仓库大小"></a>仓库大小</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size:&gt;&#x3D;5000 &#x2F;&#x2F; 仓库大于5000KB的仓库</span><br></pre></td></tr></table></figure><h4 id="仓库create时间"><a href="#仓库create时间" class="headerlink" title="仓库create时间"></a>仓库<code>create</code>时间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">created:&gt;2019-01-01     &#x2F;&#x2F; 2019年以后创建的仓库</span><br></pre></td></tr></table></figure><h4 id="license协议"><a href="#license协议" class="headerlink" title="license协议"></a><code>license</code>协议</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">license:apache-2.0  &#x2F;&#x2F; 使用 apache-2.0 协议的仓库</span><br></pre></td></tr></table></figure><h4 id="组织机构代码"><a href="#组织机构代码" class="headerlink" title="组织机构代码"></a>组织机构代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org:spring-cloud  &#x2F;&#x2F; 列出org 的 spring-cloud  仓库</span><br></pre></td></tr></table></figure><h3 id="3）、组合搜索"><a href="#3）、组合搜索" class="headerlink" title="3）、组合搜索"></a>3）、组合搜索</h3><p>将1）和2）中可以随机组合进行精确搜索,比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in:description &lt;something&gt; language:python  &#x2F;&#x2F;将编程语言限制为python</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in:readme &lt;something&gt; stars:&gt;3000 forks:&gt;3000</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in:description 微服务 language:python pushed:&gt;2020-01-01</span><br><span class="line">&#x2F;*pushed:&gt;2020-01-01的意思是我们把项目的最后更新时间限制到2020-01-01*&#x2F;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in:name React  forks:&gt;3000</span><br></pre></td></tr></table></figure><p>等等</p><h2 id="奇特搜索："><a href="#奇特搜索：" class="headerlink" title="奇特搜索："></a>奇特搜索：</h2><h3 id="awesome搜索"><a href="#awesome搜索" class="headerlink" title="awesome搜索"></a><code>awesome</code>搜索</h3><p><strong>1、awesome-awesome搜索</strong></p><p>直接使用<code>awesome-awesome</code>可以搜索出很多优质项目。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awesome-awesome</span><br></pre></td></tr></table></figure><p><strong>2、<code>awesome name</code>搜索</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awesome &lt;name&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnCpp chapterO</title>
      <link href="/archives/67343d3.html"/>
      <url>/archives/67343d3.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapterO</red></p></center><center><red>https://www.learncpp.com</red></center><p>未完待续~~</p><a id="more"></a><h2 id="O-1-Bit-flags-and-bit-manipulation-via-std-bitset"><a href="#O-1-Bit-flags-and-bit-manipulation-via-std-bitset" class="headerlink" title="O.1 Bit flags and bit manipulation via std::bitset"></a>O.1 Bit flags and bit manipulation via std::bitset</h2><p>在现代计算机体系结构中，最小的可寻址内存单元是<strong>字节</strong>。由于所有对象都需要有唯一的内存地址，这意味着对象的大小必须至少为一个字节。对于大多数变量类型，这是可以的。<strong>然而，对于布尔值，这有点浪费</strong>。布尔类型只有两种状态:真(1)，或假(0)。这一组状态只需要存储一位。然而，如果一个变量必须至少是一个字节，而一个字节是8位，这意味着一个布尔值使用1位，而其他7位不使用。</p><hr><ul><li><p><strong>位操作：bit manipulation</strong></p><p>在对象内部，修改单个bit的过程，叫位操作。</p><blockquote><p>位操作在加密和压缩算法中也很有用。</p></blockquote></li><li><p>但是，我们可以将对象视为单个位的集合，而不是将其视为持有单个值的对象。当对象的个别位用作布尔值时，这些位称为<strong>位标志：bit flag</strong>。</p><blockquote><p>在计算中，标志是作为某个函数或进程的信号的值。类似地，在现实生活中，邮箱标志用于指示邮箱中有内容，因此不必打开邮箱进行检查。</p></blockquote><p>为了定义一组位标志，我们通常使用适当大小的无符号整数(8位、16位、32位等等，这取决于我们有多少个标志)，或者std::bitset。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt; //for std::bitset</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;8&gt; mybitset &#123;&#125;; <span class="comment">//8 bits in size means room for 8 flags</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>位操作</strong>是少数几种<strong>应该明确使用无符号整数(或std::bitset)的操作</strong>之一。</p></blockquote></li></ul><hr><ul><li><p><strong>位编号和位的位置：Bit numbering and bit positions</strong></p><p>给定一个bits 序列，通常从右到左开始进行编号(编号的开头是0，不是1)。每一个数字表示一个<strong><em>bit positon</em>：位的位置</strong>。eg：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">76543210  Bit position</span><br><span class="line">00000101  Bit sequence</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>通过<code>std::bitset</code>操作位</strong></p><p>在 <a href="https://www.learncpp.com/cpp-tutorial/literals/" target="_blank" rel="noopener">4.12 – Literals</a>，我们介绍了如何使用<code>std::bitset</code>来输出二进制形式的结果。现在我们来介绍<code>std::bitset</code>的其他功能：</p><p><code>std::bitset</code>提供了4个关键的功能，对做位操作很有用:</p><ul><li><p><code>text()</code>：允许我们查询一个位是0还是1；</p></li><li><p><code>set()</code>：允许我们将一个 位(bit)设置成 on，即将其设置为1；</p></li><li><p><code>reset()</code>：允许我们将一个 位(bit)设置成 off，即将其设置为 0；</p></li><li><p><code>flip()</code>：允许我们将一个 位(bit) 由0设置为1，或者由1设置为0；</p><blockquote><p>这些函数中的每一个都带有一个位位置参数，该参数指示我们将要操作的位 的位置。</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;8&gt; bits&#123;<span class="number">0b0000'0101</span>&#125;; <span class="comment">//we need 8 bits, start with bit pattern 0000 0101</span></span><br><span class="line">    <span class="built_in">bit</span>.<span class="built_in">set</span>(<span class="number">3</span>); <span class="comment">//set bit position 3 to 1 (now we have 0000 1101)</span></span><br><span class="line">    <span class="built_in">bit</span>.flip(<span class="number">4</span>); <span class="comment">//flip bit 4(now we have 0001 1101)</span></span><br><span class="line">    <span class="built_in">bit</span>.reset(<span class="number">4</span>); <span class="comment">//set bit 4 back to 0 (now we have 0000 1101)</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"All the bits: "</span>&lt;&lt;bits&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"bit 3 has valude: "</span> &lt;&lt;<span class="built_in">bit</span>.test(<span class="number">3</span>) &lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>:;<span class="built_in">cout</span> &lt;&lt;<span class="string">"bit 4 has valud: "</span>&lt;&lt;<span class="built_in">bit</span>.test(<span class="number">4</span>) &lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********输出结果********/</span></span><br><span class="line">All the bits: <span class="number">00001101</span></span><br><span class="line"><span class="built_in">bit</span> <span class="number">3</span> has valude: <span class="number">1</span></span><br><span class="line"><span class="built_in">bit</span> <span class="number">4</span> has valude: <span class="number">0</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="O-2-位操作符"><a href="#O-2-位操作符" class="headerlink" title="O.2 位操作符"></a>O.2 位操作符</h2><p>C++提供了<strong>“位操作符(bitwise operator)”</strong>：</p><table><thead><tr><th align="left">Operator</th><th align="left">Symbol</th><th align="left">Form</th><th align="left">Operation</th></tr></thead><tbody><tr><td align="left">left shift</td><td align="left">&lt;&lt;</td><td align="left">x &lt;&lt; y</td><td align="left">all bits in x shifted left y bits</td></tr><tr><td align="left">right shift</td><td align="left">&gt;&gt;</td><td align="left">x &gt;&gt; y</td><td align="left">all bits in x shifted right y bits</td></tr><tr><td align="left">bitwise NOT</td><td align="left">~</td><td align="left">~x</td><td align="left">all bits in x flipped</td></tr><tr><td align="left">bitwise AND</td><td align="left">&amp;</td><td align="left">x &amp; y</td><td align="left">each bit in x AND each bit in y</td></tr><tr><td align="left">bitwise OR</td><td align="left">|</td><td align="left">x | y</td><td align="left">each bit in x OR each bit in y</td></tr><tr><td align="left">bitwise XOR</td><td align="left">^</td><td align="left">x ^ y</td><td align="left">each bit in x XOR each bit in y</td></tr></tbody></table><blockquote><p>在下面的例子中，我们将主要使用4位二进制值。这是为了方便和保持例子简单。在实际的程序中，使用的位的数量是基于对象的大小(例如，一个2字节的对象将存储16位)。</p><p>为了可读性，我们还将在代码示例之外省略0b前缀(例如，我们将使用0101而不是0b0101)。</p></blockquote><hr><ul><li><p><strong>位操作符：<code>&lt;&lt;</code>左移、<code>&gt;&gt;</code>右移</strong></p><p>按位左移(&lt;&lt;)操作符将位移到左边。左操作数是要移位的位的表达式，而右操作数是要左移的位的整数。</p><blockquote><p>如：<code>x&lt;&lt;1</code>表示，将变量x左移一个位置。从右边移进来的新位接受一个 值0。</p><p>eg，</p><p><code>0011&lt;&lt;1</code> 是 0110</p><p><code>0011&lt;&lt;2</code> 是 1100</p><p><code>0011&lt;&lt;3</code> 是 1000</p></blockquote><p>同理，按位右移(&gt;&gt;)操作符原理也一样：</p><blockquote><p><code>1100&gt;&gt;1</code> 是 0110</p><p><code>1100&gt;&gt;2</code> 是 0011</p><p><code>1100&gt;&gt;3</code> 是 0001</p></blockquote><hr><p>下面是一个示例程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;4&gt; x&#123;<span class="number">0b1100</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;x&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (x&gt;&gt;<span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//右移一个位置，结果是0110</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (x&lt;&lt;<span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//左移一个位置，结果是1000</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******结果******/</span></span><br><span class="line"><span class="number">1100</span></span><br><span class="line"><span class="number">0110</span></span><br><span class="line"><span class="number">1000</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>位操作：NOT <code>~</code></strong></p><p>这个操作符功能就是将每个位的数由0变为1，或由1变为0：</p><blockquote><p>如：<code>~0100</code> 是 1011；<code>~0000 0100</code> 是 1111 1011</p></blockquote><p>上面例子中，虽然：0100 和000 0100是一样的，就像十进制的7和07一样；但是经过<code>~</code>操作符之后，它们位数不一样，就会产生不一样的结果。</p></li></ul><hr><ul><li><p><strong>位操作：OR <code>|</code></strong></p><p>它的形式是对两个表达式进行每个位上的或运算，如：<code>0b0101 | 0b0110</code>。更加直观的形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 1 0 1 OR</span><br><span class="line">0 1 1 0</span><br><span class="line">---------   &#x2F;&#x2F;结果为</span><br><span class="line">0 1 1 1</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (<span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;&#123;<span class="number">0b0101</span>&#125; | <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;&#123;<span class="number">0b0110</span>&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********结果********/</span></span><br><span class="line"><span class="number">0111</span></span><br></pre></td></tr></table></figure><blockquote><p>也可进行多个表达式的运算，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0 1 1 1 OR</span><br><span class="line">0 0 1 1 OR</span><br><span class="line">0 0 0 1</span><br><span class="line">--------</span><br><span class="line">0 1 1 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;只要对应的列有1，它的结果中对应的那一列就是1</span><br></pre></td></tr></table></figure><p>它写成程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (<span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;&#123; <span class="number">0b0111</span> &#125; | <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;&#123; <span class="number">0b0011</span> &#125; | <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;&#123; <span class="number">0b0001</span> &#125;);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********结果*********/</span></span><br><span class="line"><span class="number">0111</span></span><br></pre></td></tr></table></figure></blockquote></li></ul><hr><ul><li><p><strong>位操作：AND <code>&amp;</code></strong></p><p>它的形式为：<code>0b0101 &amp; 0b0110</code>,更加直观的形式（也可以有多个表达式一起运算）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 1 0 1 AND</span><br><span class="line">0 1 1 0</span><br><span class="line">--------</span><br><span class="line">0 1 0 0</span><br></pre></td></tr></table></figure><blockquote><p>每一列中只有全部为1时，结果中对应的列才是1.</p></blockquote><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (<span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;&#123; <span class="number">0b0001</span> &#125; &amp; <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;&#123; <span class="number">0b0011</span> &#125; &amp; <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;&#123; <span class="number">0b0111</span> &#125;);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直观的表示为：</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> AND</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> AND</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">--------  <span class="comment">//结果为</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>位操作：XOR <code>^</code></strong></p><p>它的形式为：<code>0b0001 ^ 0b0011 ^ 0b0111</code></p><p>更加直观的看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 1 XOR</span><br><span class="line">0 0 1 1 XOR</span><br><span class="line">0 1 1 1</span><br><span class="line">--------</span><br><span class="line">0 1 0 1</span><br></pre></td></tr></table></figure><blockquote><p>每一列如果有<strong>奇数个1</strong>，则结果中对应的列就是1；否则就是0.</p></blockquote></li></ul><hr><ul><li><p><strong>位的赋值操作符</strong></p><p>与算术赋值运算符相似，C++提供位的赋值操作符，为了方便修改变量：</p><table><thead><tr><th align="left">Operator</th><th align="left">Symbol</th><th align="left">Form</th><th align="left">Operation</th></tr></thead><tbody><tr><td align="left">Left shift assignment</td><td align="left">&lt;&lt;=</td><td align="left">x &lt;&lt;= y</td><td align="left">Shift x left by y bits</td></tr><tr><td align="left">Right shift assignment</td><td align="left">&gt;&gt;=</td><td align="left">x &gt;&gt;= y</td><td align="left">Shift x right by y bits</td></tr><tr><td align="left">Bitwise OR assignment</td><td align="left">|=</td><td align="left">x |= y</td><td align="left">Assign x | y to x</td></tr><tr><td align="left">Bitwise AND assignment</td><td align="left">&amp;=</td><td align="left">x &amp;= y</td><td align="left">Assign x &amp; y to x</td></tr><tr><td align="left">Bitwise XOR assignment</td><td align="left">^=</td><td align="left">x ^= y</td><td align="left">Assign x ^ y to x</td></tr></tbody></table><p>比如，<code>x= x&gt;&gt;1</code>，可以写成：<code>x&gt;&gt;=1</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;4&gt; bits&#123;<span class="number">0b0100</span>&#125;;</span><br><span class="line">    bits &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; bits;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果*********/</span></span><br><span class="line"><span class="number">0010</span></span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>总结：</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnCpp chapter5</title>
      <link href="/archives/b6a3dbf1.html"/>
      <url>/archives/b6a3dbf1.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapter5</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h2 id="5-1-操作符优先级-amp-结合律"><a href="#5-1-操作符优先级-amp-结合律" class="headerlink" title="5.1 操作符优先级 &amp; 结合律"></a>5.1 操作符优先级 &amp; 结合律</h2><center>Operator precedence and associativity</center><p>下面是<strong>操作符的优先级 及 结合律</strong></p><blockquote><p>【note】</p><ol><li>下面表格的操作符优先级：<strong>level 1是最高优先级；level 17 优先级最低</strong></li><li>结合律：<ul><li><strong>L-&gt;R</strong>：即，从左向右结合</li><li><strong>R-&gt;L</strong> ：即。从右向左结合</li></ul></li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter5/image-20200403103620634.png" alt="1~8 level"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter5/image-20200403103654067.png" alt="9~17 level"></p><hr><p>注意一个<strong>连等号到表达式</strong>：</p><p><strong><code>x=y=z;</code>由上表可知，该表达式其实是这样的：<code>x=(y=z);</code></strong></p><hr><h2 id="5-2-算数运算符"><a href="#5-2-算数运算符" class="headerlink" title="5.2 算数运算符"></a>5.2 算数运算符</h2><center>Arithmetic operators</center><ul><li><p><strong>一元操作符(<em>Unary arithmetic operators</em></strong>)：<strong><code>+</code>、<code>-</code>：</strong></p><blockquote><p><strong>unary minus</strong>：返回 操作数乘以-1 之后的值。</p><p><strong>unary plus</strong>：返回 操作数本身。</p><p>这两个操作符都应该放在操作数的前面(e.g. -x , 而不是 - x)</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter5/image-20200403130245848.png" alt="一元操作符 + -"></p><p>eg: <code>x=5 - -3;</code>.第一个减号表示二元操作符，减法；第二个减号表示一元操作符。</p></li></ul><hr><ul><li><p><strong>二元运算符：<em>Binary arithmetic operators</em></strong></p><p>二元操作符有左、右 两个<strong>操作数(operand)</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter5/image-20200403130913816.png" alt="二元操作符"></p></li></ul><hr><ul><li><p><strong>整数与浮点数 的除法</strong></p><ol><li><p>左右两个操作数<strong>至少有一个是 浮点型值</strong>，它们的运算结果依然是一个浮点型的值。</p><blockquote><p>For example, <code>7.0 / 4 = 1.75</code>, <code>7 / 4.0 = 1.75</code>、<code>7.0 / 4.0 = 1.75</code></p></blockquote></li><li><p>做有<strong>两个操作数均为 整型值</strong>，它的运算结果依然是 整型值。</p><blockquote><p>For example, <code>7 / 4 = 1</code></p></blockquote></li></ol></li></ul><hr><ul><li><p><strong>用<code>static_cast&lt;&gt;</code>对整数进行浮点除法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123;<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> y&#123;<span class="number">4</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"int/int="</span>&lt;&lt;x/y&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"double / int = "</span>&lt;&lt;<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(x)/y&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"int / double = "</span>&lt;&lt;x/ <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(y)&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"double / double = "</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(x) / <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(y)&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****结果*****/</span></span><br><span class="line"><span class="keyword">int</span> / <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">double</span> / <span class="keyword">int</span> = <span class="number">1.75</span></span><br><span class="line"><span class="keyword">int</span> / <span class="keyword">double</span> = <span class="number">1.75</span></span><br><span class="line"><span class="keyword">double</span> / <span class="keyword">double</span> = <span class="number">1.75</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>除以<code>0</code></strong></p><p>如果除以0(或者 0.0)将会使程序崩溃。因为这个结果在数学中是没有定义的。</p></li></ul><hr><ul><li><p><strong>赋值操作符</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter5/image-20200403133616428.png" alt="赋值操作符"></p></li></ul><hr><h2 id="5-3-取模-amp-幂运算"><a href="#5-3-取模-amp-幂运算" class="headerlink" title="5.3 取模 &amp; 幂运算"></a>5.3 取模 &amp; 幂运算</h2><ul><li><p><strong>取模操作符：The modulus operator</strong></p><p><strong><em>取模操作符*，又称 *取余操作符</em></strong>。</p><blockquote><p>【note】：<u><strong>取余运算结果的符号，只和第一个操作数相一致。</strong></u></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123; <span class="number">6</span> &#125;, y&#123; <span class="number">-4</span> &#125;; <span class="comment">//第一个操作数符号为 正</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x%y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> z&#123; <span class="number">-6</span> &#125;, w&#123; <span class="number">4</span> &#125;; <span class="comment">//第一个操作数符号为 负</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; z%w ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="built_in">std</span>::numeric_limits &lt;<span class="built_in">std</span>::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span> );</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter5/image-20200403134914381.png" alt="取余结果的符号与“被除数”的符号相同"></p></blockquote></li></ul><hr><ul><li><p><strong>幂运算符<code>^</code></strong></p><p>您将注意到<code>^</code>运算符(在数学中通常用于表示求幂)是c++中的位<strong>XOR操作</strong>。在C++中不包含“幂运算操作符”。如果要用，就需要加上<strong>头文件<code>cmath</code></strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">double</span> x&#123; <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">3.0</span>, <span class="number">4.0</span>)&#125;; <span class="comment">//3 to the 4th power(3的4次方)</span></span><br></pre></td></tr></table></figure><blockquote><p>【Note】注意，<strong>pow()函数的参数(和返回值)是double类型的</strong>。所以，就算传入的是整数类型的，它的计算还是会有误差的(因为浮点数计算本身就会有误差)</p></blockquote><hr><p>所以，如果你想对整数进行幂运算，可以自己设计函数，使其结果比较精确：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt; //for std::int_fast64_t</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//note: exp(幂数) 不能是负数[因为用的是while循环]</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="keyword">int_fast64_t</span> <span class="title">powint</span> <span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> <span class="built_in">exp</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">int_fast64_t</span> result &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">exp</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">exp</span> &amp; <span class="number">1</span>)</span><br><span class="line">            result *= base;</span><br><span class="line">        <span class="built_in">exp</span> &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        base *= base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;powint(<span class="number">7</span>,<span class="number">12</span>); <span class="comment">//7的12次幂</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="5-4-递增-递减操作符"><a href="#5-4-递增-递减操作符" class="headerlink" title="5.4 递增/递减操作符"></a>5.4 递增/递减操作符</h2><table><thead><tr><th align="left">Operator</th><th align="left">Symbol</th><th align="left">Form</th><th align="left">Operation</th></tr></thead><tbody><tr><td align="left">Prefix increment (pre-increment)</td><td align="left">++</td><td align="left">++x</td><td align="left">Increment x, then return x</td></tr><tr><td align="left">Prefix decrement (pre-decrement)</td><td align="left">––</td><td align="left">––x</td><td align="left">Decrement x, then return x</td></tr><tr><td align="left">Postfix increment (post-increment)</td><td align="left">++</td><td align="left">x++</td><td align="left">Copy x, then increment x, then return the copy</td></tr><tr><td align="left">Postfix decrement (post-decrement)</td><td align="left">––</td><td align="left">x––</td><td align="left">Copy x, then decrement x, then return the copy</td></tr></tbody></table><hr><ul><li><p><strong>副作用：side effects</strong></p><center>c++不定义函数参数或操作符操作数的求值顺序。</center><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> x+y;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123;<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> valude = add(x, ++x); <span class="comment">//结果是5+6,还是6+6?</span></span><br><span class="line">    <span class="comment">//这取决于编译器计算函数参数的顺序</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;value; <span class="comment">// value could be 11 or 12, depending on how the above line evaluates!</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>【副作用】：<strong>c++没有定义函数参数求值的顺序。</strong></p><p>这种就会产生不确定性，因为还要<strong>取决于编译器对函数的参数计算的顺序</strong>。所以，不同的编译器可能会产生不同的结果。</p><p>所以，结果可能为：11 或者 12</p></blockquote></li></ul><hr><h2 id="5-5-逗号“-”-amp-条件-运算符"><a href="#5-5-逗号“-”-amp-条件-运算符" class="headerlink" title="5.5 逗号“,” &amp; 条件 运算符"></a>5.5 逗号“<code>,</code>” &amp; 条件 运算符</h2><h3 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h3><center>逗号操作符适用于for循环，其他情况不推荐用</center><table><thead><tr><th align="left">Operator</th><th align="left">Symbol</th><th align="left">Form</th><th align="left">Operation</th></tr></thead><tbody><tr><td align="left">Comma</td><td align="left">,</td><td align="left">x, y</td><td align="left">Evaluate x then y, returns value of y</td></tr></tbody></table><p><strong>comma operator (,)</strong>：允许您在允许单个表达式的情况下计算多个表达式的值。<strong>逗号运算符对左操作数求值，然后对右操作数求值，<u>然后返回右操作数的结果</u></strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> y&#123;<span class="number">2</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; (++x, ++y); <span class="comment">//先计算左操作符，在计算右操作符，但是返回右操作符的结果</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******结果**********/</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><hr><ul><li><p><strong>逗号操作符是所有操作符中最低的</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">z = (a,b); <span class="comment">//计算(a,b)，然后将返回的结果赋值给z</span></span><br><span class="line">z = a , b; <span class="comment">//由于“=”操作符优先于“,”操作符，所以，先计算“z=a”;然后在计算b，计算完之后，b没用就被抛弃了</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>逗号用作分隔符时，它此时代表的不是操作符</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// Comma used to separate parameters in function definition</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    add(x, y); <span class="comment">// Comma used to separate arguments in function call</span></span><br><span class="line">    int z(3), w(5); // Comma used to separate multiple variables being defined on the same line (don't do this)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h3><p>条件操作符是一个 <strong>三元操作符</strong></p><table><thead><tr><th align="left">Operator</th><th align="left">Symbol</th><th align="left">Form</th><th align="left">Operation</th></tr></thead><tbody><tr><td align="left">Conditional</td><td align="left">? :</td><td align="left">c ? x : y</td><td align="left">If c is nonzero (true) then evaluate x, otherwise evaluate y</td></tr></tbody></table><p>形式：<code>(condition) ? expression1 : expression2;</code></p><blockquote><p>当<code>condition</code>的结果是正确的(或者非零数字)，就执行<code>expression1</code>，否则，执行<code>expression2</code></p></blockquote><hr><ul><li><p><strong>由于条件操作符优先级较低，有时需要括号</strong></p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (x&gt;y) ? x : y;</span><br><span class="line"><span class="comment">//由于“&lt;&lt;”的优先级高于“条件操作符”,所以，等同于以下形式：</span></span><br><span class="line">(<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (x&gt;y)) ? x : y;</span><br><span class="line"><span class="comment">//想要按照我们设计的正确执行，则需要适当加上括号</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;((x&gt;y) ? x : y);</span><br></pre></td></tr></table></figure></li></ul><hr><p>【注意】与在函数内部定义的变量在函数结束时死亡非常相似，在if或else语句中定义的变量在if或else语句结束时死亡。因此，在我们试图打印它时，类大小已经被破坏了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> inBigClassroom &#123; <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (inBigClassroom)</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> classSize &#123; <span class="number">30</span> &#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> classSize &#123; <span class="number">20</span> &#125;;</span><br><span class="line">    <span class="comment">//此时，if/else已经执行结束，所以，其内部定义的变量classSize也已经被销毁</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The class size is: "</span> &lt;&lt; classSize; <span class="comment">//因为classSize被销毁，所以会编译出错</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li><p><strong>条件编译的两个表达式的类型</strong></p><p>条件编译的两个表达式，<strong>要么具有相同的类型</strong>；<strong>要么第二个表达式的类型可以转化为第一个表达式的类型</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (x != <span class="number">5</span> ? x : <span class="string">"x is 5"</span>); <span class="comment">// won't compile</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为，表达式1：x 是integer 类型；表达式2："x is 5"是string类型。所以表达式2要转换为表达式1的类型，但是转换失败。所以编译就不成功</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="5-6-关系运算符-amp-浮点数的比较"><a href="#5-6-关系运算符-amp-浮点数的比较" class="headerlink" title="5.6 关系运算符 &amp; 浮点数的比较"></a>5.6 关系运算符 &amp; 浮点数的比较</h2><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><table><thead><tr><th align="left">Operator</th><th align="left">Symbol</th><th align="left">Form</th><th align="left">Operation</th></tr></thead><tbody><tr><td align="left">Greater than</td><td align="left">&gt;</td><td align="left">x &gt; y</td><td align="left">true if x is greater than y, false otherwise</td></tr><tr><td align="left">Less than</td><td align="left">&lt;</td><td align="left">x &lt; y</td><td align="left">true if x is less than y, false otherwise</td></tr><tr><td align="left">Greater than or equals</td><td align="left">&gt;=</td><td align="left">x &gt;= y</td><td align="left">true if x is greater than or equal to y, false otherwise</td></tr><tr><td align="left">Less than or equals</td><td align="left">&lt;=</td><td align="left">x &lt;= y</td><td align="left">true if x is less than or equal to y, false otherwise</td></tr><tr><td align="left">Equality</td><td align="left">==</td><td align="left">x == y</td><td align="left">true if x equals y, false otherwise</td></tr><tr><td align="left">Inequality</td><td align="left">!=</td><td align="left">x != y</td><td align="left">true if x does not equal y, false otherwise</td></tr></tbody></table><blockquote><p>这些操作符的值分别为布尔值true(1)和false(0)。</p></blockquote><hr><h3 id="浮点数的比较"><a href="#浮点数的比较" class="headerlink" title="浮点数的比较"></a>浮点数的比较</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d1&#123; <span class="number">100.0</span> - <span class="number">99.99</span> &#125;; <span class="comment">// should equal 0.01 ?</span></span><br><span class="line">    <span class="keyword">double</span> d2&#123; <span class="number">10.0</span> - <span class="number">9.99</span> &#125;; <span class="comment">// should equal 0.01 ?</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (d1 == d2)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"d1 == d2"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (d1 &gt; d2)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"d1 &gt; d2"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (d1 &lt; d2)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"d1 &lt; d2"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****结果*****/</span></span><br><span class="line">d1 &gt; d2</span><br></pre></td></tr></table></figure><p>我们可以看到，在我们的调试模式下，d1 = 0.0100000000000005116 而 d2 = 0.0099999999999997868.</p><blockquote><p>【Note】：在两个浮点数非常接近时，如果使用<code>==</code>和<code>!=</code>对浮点数之间比较，结果会不太准确。</p></blockquote><hr><ul><li><p><strong>使用<code>epsilon</code>准确比较浮点数</strong></p><p>我们可以使用<code>epsilon</code>来相对准确的比较两个 足够接近的 浮点型数值。</p><blockquote><p><code>epsilon</code>：通常被定义为一个小的正数(如，0.00000001，即1e-8)</p></blockquote><p>现在，我们来比较两个”close enough”的浮点数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; //for std::abs()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//epsilon is an absolute value</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isAlmostEqual</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> epsilon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//if the distance between a and b is less than epsilon, then a and b are "close enough"</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">abs</span>(a-b) &lt;= epsilon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这个函数可以工作，但它不是很好。0.00001的epsilon值对于1.0左右的输入是合适的，对于0.0000001左右的输入是太大了，对于10,000这样的输入是太小了。这意味着每次我们调用这个函数时，我们必须选择一个适合我们输入的。如果我们知道我们要根据输入的比例来缩放，我们也可以修改函数来做到这一点。</p><p><strong>改进1：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; //std::abs</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; //std::max</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//return true if the difference between a and b is within epsilon</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">approximatelyEqual</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b, <span class="keyword">double</span> epsilon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(a-b) &lt;= ( <span class="built_in">std</span>::<span class="built_in">max</span>( <span class="built_in">std</span>::<span class="built_in">abs</span>(a),<span class="built_in">std</span>::<span class="built_in">abs</span>(b) ) * epsilon ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这种情况下，<code>epsilon</code>不再是一个绝对值，<strong>现在是相对于a或b大小的量级</strong>。</p></blockquote><p><strong>再改进2【推荐】</strong>：</p><p><strong>当浮点数足够接近于0时</strong>，上面的方法还是不太行的。</p><blockquote><p>改进方法就是：<strong>同时使用相对值和绝对值</strong>：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return true if the difference between a and b is less than absEpsilon, or within relEpsilon percent of the larger of a and b</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">approximatelyEqualAbsRel</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> absEpsilon, <span class="keyword">double</span> relEpsilon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Check if the numbers are really close -- needed when comparing numbers near zero.</span></span><br><span class="line">    <span class="keyword">double</span> diff&#123; <span class="built_in">std</span>::<span class="built_in">abs</span>(a - b) &#125;;</span><br><span class="line">    <span class="keyword">if</span> (diff &lt;= absEpsilon)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Otherwise fall back to Knuth's algorithm(相对值方法，即“改进1”的方法)</span></span><br><span class="line">    <span class="keyword">return</span> (diff &lt;= (<span class="built_in">std</span>::<span class="built_in">max</span>(<span class="built_in">std</span>::<span class="built_in">abs</span>(a), <span class="built_in">std</span>::<span class="built_in">abs</span>(b)) * relEpsilon));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这个算法中，我们首先检查a和b在绝对值上是否接近，这处理了a和b都接近于零的情况。<strong>absEpsilon参数应该设置为非常小的值(例如1e-12)</strong>。如果失败了，我们就回到Knuth的算法，即，使用相对的epsilon。</p></blockquote></li></ul><p>完整的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; //std::max</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;     //std::abs</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果a和b之间的差值在a和b之间较大值的百分之几内，则返回true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">approximatelyEqual</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b,<span class="keyword">double</span> epsilon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(a-b) &lt;= (<span class="built_in">std</span>::<span class="built_in">max</span>(<span class="built_in">std</span>::<span class="built_in">abs</span>(a), <span class="built_in">std</span>::<span class="built_in">abs</span>(b)) * epsilon ));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//针对于接近于0 的浮点数的比较</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">approximatelyEqualAbsRel</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b,<span class="keyword">double</span> absEpsilon, <span class="keyword">double</span> relEspilon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//check if the numbers are really close -- need when comparing numbers near zero.</span></span><br><span class="line">    <span class="keyword">double</span> diff &#123;<span class="built_in">std</span>::<span class="built_in">abs</span>(a-b)&#125;;</span><br><span class="line">    <span class="keyword">if</span> (diff &lt;= absEpsilon)</span><br><span class="line">        <span class="keyword">return</span> ture;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//otherwise fall back to 相对值法</span></span><br><span class="line">    <span class="keyword">return</span> (diff &lt;= (<span class="built_in">std</span>::<span class="built_in">max</span>(<span class="built_in">std</span>::<span class="built_in">abs</span>(a), <span class="built_in">std</span>::<span class="built_in">abs</span>(b)) * relEspilon));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//a is really close to 1.0, but has rounding errors</span></span><br><span class="line">    <span class="keyword">double</span> a&#123;<span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; approximatelyEqual(a, <span class="number">1.0</span>, <span class="number">1e-8</span>);<span class="comment">//compare "almost 1.0" to 1.0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; approximatelyEqual(a<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">1e-8</span>); <span class="comment">//compare "almost 0.0" to 0.0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; approximatelyEqualAbsRel(a<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">1e-12</span>, <span class="number">1e-8</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// compare "almost 0.0" to 0.0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********结果*********/</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>可以看出，<strong>在对于接近于0的浮点数，与 0.0比较时。<code>approximatelyEqualAbsRel</code>要更加准确。</strong></p></blockquote><p><strong>使用<code>approximatelyEqualAbsRel</code>方法，就可以解决大多数情况</strong>。它也涵盖了<code>approximatelyEqual</code>函数的功能。</p><hr><h2 id="5-7-逻辑操作符"><a href="#5-7-逻辑操作符" class="headerlink" title="5.7 逻辑操作符"></a>5.7 逻辑操作符</h2><table><thead><tr><th align="left">Operator</th><th align="left">Symbol</th><th align="left">Form</th><th align="left">Operation</th></tr></thead><tbody><tr><td align="left">Logical NOT</td><td align="left">!</td><td align="left">!x</td><td align="left">true if x is false, or false if x is true</td></tr><tr><td align="left">Logical AND</td><td align="left">&amp;&amp;</td><td align="left">x &amp;&amp; y</td><td align="left">true if both x and y are true, false otherwise</td></tr><tr><td align="left">Logical OR</td><td align="left">||</td><td align="left">x || y</td><td align="left">true if either x or y are true, false otherwise</td></tr></tbody></table><hr><ul><li><p><strong>NOT：！</strong></p><p>需要注意的是，<strong>NOT 操作符的优先级很高，在level 3</strong>。所以，你很有可能会犯这种错误：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123;<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> y&#123;<span class="number">7</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!x&gt;y) <span class="comment">//正确写法：if (!(x&gt;y))</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x is not greater than y\n"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x is equal to or greater than y\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果************/</span></span><br><span class="line">x is equal to <span class="keyword">or</span> greater than y</span><br></pre></td></tr></table></figure><p>可以看出，结果不正确。在这里就是因为，<code>if(!x&gt;y)</code>中，由于<code>!</code>优先级高于<code>&gt;</code>。所以，先计算“!x”，其实，就相当于：<code>if ( (!x) &gt; y )</code></p></li></ul><hr><ul><li><p><strong>AND： &amp;&amp;</strong></p><ul><li><p>如果逻辑操作符<code>&amp;&amp;</code>要返回“true”，那么所有的操作数都必须是‘true’；</p></li><li><p>但如果<code>&amp;&amp;</code>返回是“false”，只要有一个操作数是‘false’即可。</p><blockquote><p>特殊的，如果第一个操作数是‘false’的话，就不会再继续看后面操作符是‘false’还是‘true’，即图签终止了。这种情况叫做：“<strong>short circuit evaluation</strong>”</p></blockquote></li></ul><p>相似的，逻辑操作符 或<code>||</code>，如果要返回“true”的话，也是只要有一个操作数是‘true’即可。</p></li></ul><hr><blockquote><p><strong>逻辑操作符<code>&amp;&amp;</code>的优先级高于<code>||</code></strong>，所以，在使用如：<code>value1 || value2 &amp;&amp; value3</code>时，要更加小心，<strong>使用括号才会更加安全</strong>。</p></blockquote><hr><ul><li><p><strong>德摩根定律：De Morgan’s law</strong></p><p>德摩根定律告诉我们，可以这样使用逻辑操作符<code>!</code>：</p><p><code>!(x &amp;&amp; y)</code> 等同于 <code>!x || !y</code></p><p><code>!(x || y)</code>等同于 <code>!x &amp;&amp; !y</code></p><blockquote><p>换句话说，当您分发逻辑NOT时，您还需要转换为逻辑AND逻辑OR，反之亦然!</p></blockquote></li></ul><hr><ul><li><p><strong>逻辑操作符，异或<code>XOR</code></strong></p><table><thead><tr><th align="left">Left operand</th><th align="left">Right operand</th><th align="left">Result</th></tr></thead><tbody><tr><td align="left">false</td><td align="left">false</td><td align="left">false</td></tr><tr><td align="left">false</td><td align="left">true</td><td align="left">true</td></tr><tr><td align="left">true</td><td align="left">false</td><td align="left">true</td></tr><tr><td align="left">true</td><td align="left">true</td><td align="left">false</td></tr></tbody></table></li></ul><blockquote><p>即，<strong>真假 为 真</strong>，<strong>其他结果都是 假</strong></p></blockquote><p>C++没有提供专门提供 异或操作符，但是我们可以使用：</p><ol><li><p><strong>当操作数是布尔型</strong>的，即true，false，而不是integer，可以使用<code>!=</code>来实现异或：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a != b) <span class="comment">//a XOR b ,假定a、b是booleans</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="comment">//多个操作数</span></span><br><span class="line"><span class="keyword">if</span> (a != b != c != d)  <span class="comment">// a XOR b XOR c XOR d, assuming a, b, c, and d are Booleans</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li><li><p><strong>当操作数不是布尔型</strong>时，<strong>使用<code>static_cast</code>转化为bool</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(a) != <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(b) != <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(c)) <span class="comment">// a XOR b XOR c XOR d, for any type that can be converted to bool</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机科学速成课(总)</title>
      <link href="/archives/3ae1bc73.html"/>
      <url>/archives/3ae1bc73.html</url>
      
        <content type="html"><![CDATA[<center><red>计算机科学速成课</red></center><a id="more"></a><h1 id="参考文章-："><a href="#参考文章-：" class="headerlink" title="###参考文章###："></a>###参考文章###：</h1><p>*<em>计算机科学速成课 *</em>：</p><p>笔记：<a href="https://www.cnblogs.com/livil/p/10155073.html" target="_blank" rel="noopener">https://www.cnblogs.com/livil/p/10155073.html</a> 和<a href="https://zhuanlan.zhihu.com/p/103505933" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/103505933</a> 或 <a href="https://www.imooc.com/article/271502" target="_blank" rel="noopener">https://www.imooc.com/article/271502</a></p><p>字幕：<a href="https://github.com/1c7/Crash-Course-Computer-Science-Chinese/blob/master/(字幕)全40集中英字幕文本" target="_blank" rel="noopener">https://github.com/1c7/Crash-Course-Computer-Science-Chinese/blob/master/(字幕)全40集中英字幕文本</a></p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/5c2dbf8e0001443913279329.jpg" alt="5c2dbf8e0001443913279329" style="zoom:150%"><h1 id="2、电子计算机"><a href="#2、电子计算机" class="headerlink" title="2、电子计算机"></a>2、电子计算机</h1><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/1528749-20181221121908992-643367848.png" alt="img" style="zoom:200%"><h1 id="3、布尔逻辑和逻辑门"><a href="#3、布尔逻辑和逻辑门" class="headerlink" title="3、布尔逻辑和逻辑门"></a>3、布尔逻辑和逻辑门</h1><p>计算机最早是机电设备，一般用十进制计数。也有一些是三进制、五进制的。【也就是x进制表示有x种状态。】</p><p>二进制中的 1或0 叫做：位（bit）；1字节（byte）=8位(bits)</p><h1 id="5、算数逻辑单元（ALU）"><a href="#5、算数逻辑单元（ALU）" class="headerlink" title="5、算数逻辑单元（ALU）"></a>5、算数逻辑单元（ALU）</h1><p>：是计算机的数学大脑，是计算机里负责运算的组件。</p><blockquote><p>ALU有2个单元：1个<strong>算数单元</strong>和1个<strong>逻辑单元</strong>。</p><p>算数单元：负责计算机里的所有数字操作。如加减法。</p></blockquote><h2 id="1）算数单元"><a href="#1）算数单元" class="headerlink" title="1）算数单元"></a>1）算数单元</h2><h3 id="半加器-A-half-adder"><a href="#半加器-A-half-adder" class="headerlink" title="(半加器)A half adder:"></a>(半加器)A half adder:</h3><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200220151049446.png" alt="image-20200220151049446" style="zoom:150%"><p>半加器如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200211204327584.png" alt="image-20200211204327584"></p><p>将其抽象化，把“把假期”封装成一个单独组件：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200211204510442.png" alt="image-20200211204510442"></p><h3 id="全加器（Full-Adder）"><a href="#全加器（Full-Adder）" class="headerlink" title="全加器（Full Adder）:"></a>全加器（Full Adder）:</h3><p>如果想要处理多位二进制数加法时，就需要<strong>全加器（Full Adder）</strong>，因为半加器计算完当前位的结果后，会输出进位，意味着计算下一位的结果时，要将两个输入以及前一位的进位相加。我们可以得到<strong>全加器</strong>的真值表：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-f41514f0f20020dd462462f3d58bbcc4_r.jpg" alt="preview"></p><center>全加器真值表</center>![image-20200211205005097](https://longlongqin.gitee.io/image_save/images/assets/image-20200211205005097.png)<p>我们这里可以使用半加器来实现全加器。我们可以将一个半加器结果当做是INPUT A 和INPUT B相加后的结果，然后将SUM当做是新的INPUT A，而PRE CARRY当做是新的INPUT B输入到新的半加器中，可以发现其SUM结果和全加器SUM结果相同。而全加器的CARRY只要对这两个半加器的CARRY进行OR运算就可以了。（<strong>注意：</strong>这两个半加器不会同时出现进位）</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-cd2bf02b43475d66ab37e88a47df4eb2_hd.jpg" alt="img"></p><p>同样我们也可以对全加器进行抽象，得到一个包含三个输入和两个输出的独立部件。</p><p>由此我们可以进行两个8位数字相加，表示为A和B:</p><ol><li>对A和B的第一位进行相加时，由于不存在进位，所以值使用一个半加器就能实现，这个半加器的SUM就为该位的结果，CARRY就为进位。</li><li>后续的7位二进制相加，由于每一个都涉及了上一位的进位，所以后续需要7个全加器，并且每个全加器的CARRY要连接到下一个全加器的输入，而每个全加器的SUM就为该位的结果。</li><li>最后一个全加器有CARRY的输出，如果该CARRY为1，就表示相加结果太大了，超出了8位，所以出现了<strong>溢出（overflow）</strong>【<strong>溢出：</strong>一般来说 “溢出” 的意思是, 两个数字的和太大了，超过了用来表示的位数，这会导致错误和不可预期的结果。】。</li></ol><p>由此，我们就构建出了一个<strong>8位加法器（8-bit adder）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-232e40f98a8adcf998b256bfe5c52bae_hd.jpg" alt="img"></p><p>通过连接1个半加器和n-1个全加器，就能构建n位加法器。通过叠加更多的加法器，能够避免溢出的出现，但是会出现更多的逻辑门，而且每次进位都要一些时间，而计算是串行的，所以消耗的时间也越长，到如今的每秒几十亿次运算时就会造成影响，所以现代计算机用的加法电路有所不同，称为<strong>超前进位加法器（Carry-Look-Ahead Adder）。</strong></p><p><strong>ALU通常支持以下操作：</strong>加法、带进位的加法、减法、带借位的减法、取反、增1、减1、数字无改变通过。这些操作也是由逻辑门构成的。<strong>注意：</strong>简单的ALU并==不==支持乘法，而是把乘法用多次加法来实现，而更好的处理器有专门做乘法的算数单元。</p><h2 id="2）逻辑单元"><a href="#2）逻辑单元" class="headerlink" title="2）逻辑单元"></a>2）逻辑单元</h2><p><strong>逻辑单元：</strong>执行逻辑操作，比如AND、OR和NOT操作，也能做简单的数值测试，比如数字是不是负数。</p><p>对整个8位ALU进行抽象，用一个特殊的V形符号进行表示。其中有两个<strong>8位输入</strong>，并且有一个4位<strong>操作码（Operation Code）</strong>来告诉ALU对输入执行什么操作，比如1000表示加法命令，1100表示减法命令，然后有一个<strong>8位输出</strong>。同时ALU会输出一系列1位<strong>标志（FLAG）</strong>，来表示特定状态，比如我们可以计算A-B，然后通过ZERO来判断结果是否为零来判断A与B是否相等，通过NEGATIVE来判断A是否小于B；然后OVERFLOW连接到加法器的进位，来判断是否出现溢出。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-324be370be80687e69aeb12d8173dccd_hd.jpg" alt="img"></p><hr><h1 id="6、寄存器-amp-内存"><a href="#6、寄存器-amp-内存" class="headerlink" title="6、寄存器&amp;内存"></a>6、寄存器&amp;内存</h1><p>上节中介绍的ALU进行计算后得到的结果需要对其进行存储，可能还要进行多个连续操作，这就需要用到计算机内存了。计算机使用的是<strong>随机存取存储器（Random Access Memory, RAM）</strong>，其只能在<u>有电</u>的情况下存储东西。另一种存储称为<strong>持久存储（Persistent Memory）</strong>，电源关闭时数据也不会丢失，它用来存其他东西。</p><blockquote><p>随机存取存储器(RAM)：只能在有电的时候存储东西。【 <strong>内存</strong>的一个重要特性：可以随时访问任何位置。所以叫“<strong>随机存取存储器(RAM)</strong>”】</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213205406365.png" alt="image-20200213205406365"></p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212233032303.png" alt="image-20200212233032303">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212233049692.png" alt="image-20200212233049692">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212233107576.png" alt="image-20200212233107576"></p></blockquote><p>放入数据的动作叫“<strong>写入</strong>”，拿出数据的动作叫“<strong>读取</strong>”。</p><p>这一节中首先构建能够存储1位的存储器，然后对其扩展来得到内存模块。</p><p>之前构建的都是单向电路，我们同样可以构建回向电路，把输出连回输入。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-81c6dd82241ba3a7de60809922f4e8f7_hd.jpg" alt="img"></p><blockquote><p>1、当将OR门构建成回向电路时，可以分析其电路特性：</p><ul><li>A和B初始为0时，输出结果为0</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://pic1.zhimg.com/80/v2-3dd54ae2c78016bfd6eba69be1f34e98_hd.jpg" alt="img"></p><center>存储0的电路</center>- 将A修改为1时，输出结果为1，此时B的输入就变为了1。随后输出始终保持为1，不论A如何变化。<p>所以这个电路能够永久记录1，并且无法将1变回0。</p><p>2、同理可以分析下AND门构建成回向电路时的特点</p><ul><li><p>A和B初始化为1，则输出结果为1</p></li><li><p>将A修改为0时，输出结果为0，此时B的输入就变成了0。随后输入始终保持为0，无论A如何变化。</p></li></ul><p>所以这个电路能够永久记录0，并且无法将0变回1。</p></blockquote><p>所以我们就得到了能够存储1和0的电路，为了得到有用的Memory，需要将两个电路结合起来，可以得到<strong>AND-OR锁存器（AND-OR Latch）</strong>，上方的是SET输入，下方的是RESET输入，当SET=1、RESET=0，就能将输出设置为1，当RESET=1，就能将输出设置为0，当SET=0、RESET=0，则输出最后放入的内容。由此能够存储1位的信息（该信息存储在OR门上方的输入电极中）！</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200220160959766.png" alt="image-20200220160959766"></p><p>这叫”锁存”, 因为它”锁定”了一个值，放入数据的动作叫 “写入” ，拿出数据的动作叫 “读取”。</p><p>对其进行SET和RESET进行合并，并添加其他门控单元，可以得到一个<strong>门锁（GATE LATCH）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212230438229.png" alt="image-20200212230438229"></p><center>门锁</center>其中DATE INPUT表示数据输入，WRITE ENABLE表示允许写入线，用来控制是否保存当前输入的数据。对这个电路进行分析。<p>可以将门锁进行<u>抽象</u>，得到一个能够存储<strong>一个bit</strong>的部件。当允许写入线为0时，输出保持不变，当允许写入线为1时，输出就是数据输入，并且能够将数据输入进行存储。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212230837936.png" alt="image-20200212230837936"></p><center>门锁的抽象</center>如果我们并排8个锁存器，就能存储8位信息。一组这样的锁存器称为**寄存器（Register）**，寄存器能够存一个数字，这个数字的位数称为寄存器的**位宽（Width）**。<p>写入寄存器之前，要先启动里面所有的锁存器，可以将所有锁存器的允许写入线都连接在一起，把它设为1，然后用8条数据线发送数据，然后将允许写入线设回0，就能将8位数据存储在寄存器中。</p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212231015481.png" alt="image-20200212231015481"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212231043071.png" alt="image-20200212231043071"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212231125590.png" alt="image-20200212231125590"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212231159981.png" alt="image-20200212231159981"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212231218808.png" alt="image-20200212231218808">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212231232434.png" alt="image-20200212231232434"></p></blockquote><h2 id="寄存器："><a href="#寄存器：" class="headerlink" title="寄存器："></a>寄存器：</h2><p>上面是只能存储1bit的“<strong>锁存器</strong>”，如果我们并排放8个锁存器，就可以存8位(bits)信息。</p><p>一组这样的锁存器叫做“<strong>寄存器</strong>”。</p><p>1、<strong>位宽</strong></p><p>寄存器能存一个数字，这个数字有多少位，叫做“<strong>位宽</strong>”。</p><p>$早期电脑用8位寄存器，然后是16位、32位。如今都有64位宽的寄存器。$</p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213201814518.png" alt="image-20200213201814518">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213201940951.png" alt="image-20200213201940951">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213202116937.png" alt="image-20200213202116937">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213202136340.png" alt="image-20200213202136340"></p><p>所以，如64位的寄存器只需要129条线就可以了。【64条是“数据输入线”、“64条数据输出线”、“一条启用写入线”】。</p><p>如果要存256位，就需要513条线。减少线数的方法就是：<strong>矩阵</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213202534237.png" alt="image-20200213202534237">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213202641868.png" alt="image-20200213202641868"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213202711027.png" alt="image-20200213202711027"></p><p>所以，对于一个256位的存储：只需要35条。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213202942105.png" alt="image-20200213202942105">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213203005839.png" alt="image-20200213203005839"></p><p>如果想要访问特定的锁存器（即寻找其地址），（由于行数和列数均只有16，所以均可以用4个二进制位来表示。）就有行号和列号来对应。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213203515940.png" alt="image-20200213203515940">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213203551017.png" alt="image-20200213203551017">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213203634252.png" alt="image-20200213203634252">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213203648070.png" alt="image-20200213203648070"></p><blockquote><p><strong>多路复用器</strong>：有不同大小。通常包含一定数目的数据输入，有一个单独的输出。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213203948627.png" alt="image-20200213203948627"></p></blockquote><p>把256位内存当成一个整体，抽象化一下：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204207689.png" alt="image-20200213204207689">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204308742.png" alt="image-20200213204308742">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204324322.png" alt="image-20200213204324322"></p><p>一个256位内存也不能做什么大事，所以继续扩大：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204433307.png" alt="image-20200213204433307">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204508271.png" alt="image-20200213204508271">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204556045.png" alt="image-20200213204556045">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204731314.png" alt="image-20200213204731314">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204837880.png" alt="image-20200213204837880"></p><p>再次，看成一个整体：</p><p>下图中：我们有256个地址，每个地址能读或写一个8位(bit)的值。<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204931499.png" alt="image-20200213204931499">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213205132085.png" alt="image-20200213205132085">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213205150693.png" alt="image-20200213205150693">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213205208450.png" alt="image-20200213205208450">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213205234980.png" alt="image-20200213205234980">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213205253990.png" alt="image-20200213205253990"></p></blockquote><p>这一节用锁存器做了一块<strong>静态随机存取存储器（Static Random-Access Memory，SRAM）</strong>，还有很多其他类型的RAM，比如DRAM、闪存和NVRAM，它们的功能和SRAM相似，但是使用不同的电路存放单个位。但是根本上，这些技术都是矩阵层层嵌套来存储大量信息。</p><h1 id="7、中央处理器-CPU"><a href="#7、中央处理器-CPU" class="headerlink" title="7、中央处理器(CPU)"></a>7、中央处理器(CPU)</h1><p>CPU负责执行程序，程序由一个个操作组成，这些操作叫“指令(instruction)”。</p><p>如果是<strong>数学指令</strong>，比如加减，CPU会让ALU进行数学运算。如果是<strong>内存指令</strong>，CPU会和内存通信，然后读写值。</p><h1 id="9、高级CPU设计"><a href="#9、高级CPU设计" class="headerlink" title="9、高级CPU设计"></a>9、高级CPU设计</h1><p>RAM是CPU之外的独立组件，意味着数据要用线来传递，这个线叫做“<strong>总线（BUS）</strong>”。</p><p>$总线可能只有几厘米，虽然电信号传输速度接近光速，但是CPU每秒可以处理上亿条指令，很小的延迟也会造成问题。$</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214194800104.png" alt="image-20200214194800104">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214195130456.png" alt="image-20200214195130456"></p><h2 id="提升性能方法一：缓存"><a href="#提升性能方法一：缓存" class="headerlink" title="提升性能方法一：缓存"></a>提升性能方法一：缓存</h2><p>一条“从内存读数据”的指令可能需要多个时钟周期，而此时CPU空等数据。解决延迟的方法之一是给CPU加一点RAM,叫：“<strong>缓存(Cache)</strong>”。因为处理器的空间不大，所以缓存一般只有KB或MB，而RAM都是GB起步。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214195534052.png" alt="image-20200214195534052"></p><p>缓存提高了速度：当CPU从RAM拿数据时，RAM不用传一个，可以传一批。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214195800275.png" alt="image-20200214195800275"></p><p>虽然花的时间多一点，但数据可以存在缓存。这很实用，因为数据常常是一个个按顺序处理。比如：算餐厅的当日收入时，先取RAM地址为100 的交易额，RAM与其只给一个值，不如直接给一批值，把地址为100~200的数据都复制到缓存中。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214200104046.png" alt="image-20200214200104046"></p><p>当处理器要下一个交易额（地址为101的）时，缓存就会告诉处理器：“我已经有这个数据了，现在就给你”。就不用再去RAM取数据了。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214200354398.png" alt="image-20200214200354398">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214200419065.png" alt="image-20200214200419065"></p><p>当想要的数据已经在缓存中时，这种状态叫“<strong>缓存命中</strong>（Cache Hit）”；如果不在，则叫“<strong>缓存未命中（Cache Miss）</strong>”。</p><p>缓存也可以当临时空间，存一些中间值，适合长的或者复杂的运算。继续餐馆的例子：假设CPU算完了一天的销售额，想把结果存到地址为150的地方。就像之前，数据不是直接存到RAM中，而是存在缓存中。这样不但存起来快一些、如果还要接着计算，取值也会快一些。</p><p>但是这会导致：缓存和RAM中的数据不一致。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214201154364.png" alt="image-20200214201154364"></p><p>因此缓存里每块空间有一个特殊标记，叫：“<strong>脏位（Dirty Bit）</strong>”。</p><p>同步一般发生在：当缓存满了而CPU又需要缓存的时候。在清理缓存腾出空间之前，会先检查“脏位”，如果是“脏”的话，在加载新内容之前，会把数据写回RAM。</p><p>![演示 (3)](<a href="https://longlongqin.gitee.io/image_save/images/assets/演示" target="_blank" rel="noopener">https://longlongqin.gitee.io/image_save/images/assets/演示</a> (3).gif)</p><h2 id="提升性能方法二：“指令流水线”"><a href="#提升性能方法二：“指令流水线”" class="headerlink" title="提升性能方法二：“指令流水线”"></a>提升性能方法二：“指令流水线”</h2><blockquote><p>指令流水线：instruction pipelining</p></blockquote><p>例如：如果你想要洗一整个的床单，但只有一个洗衣机和一个烘干机。</p><blockquote><p>选择一：按顺序，先放洗衣机洗30分钟，然后在烘干机30分钟。共计1小时。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214203334316.png" alt="image-20200214203334316"></p><p>选择二：像一中一样，先放一批床单到洗衣机30分钟，然后把它放到烘干机中。但是这时候要等30分钟才能烘干。此时，可以放另一批床单到 洗衣机（此时，洗衣机，烘干机在同时工作），依次，直到洗完所有床单。效率是一的2倍。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214203636909.png" alt="image-20200214203636909"></p></blockquote><p>处理器也可以这样设计，CPU是按顺序处理的：<strong>(读)取指(令)——&gt;解码——&gt;执行</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214203831692.png" alt="image-20200214203831692"></p><p>不断重复：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214203857837.png" alt="image-20200214203857837"></p><p>但是每个阶段都是用的CPU的不同部分，意味着可以并行处理：“执行”一个指令时，同时“解码”下一个指令，同时，“读取”下下条指令。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214204249010.png" alt="image-20200214204249010"></p><p>这样的流水线，每一个时钟周期执行1个指令，吞吐量乘3.</p><p>但是，和缓存一样，这也会带来一些问题：</p><blockquote><p>问题1：指令之间的依赖关系。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214204538900.png" alt="image-20200214204538900">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214204559995.png" alt="image-20200214204559995"></p><p>因此流水线处理器，要先弄清楚<em>数据依赖性</em>。必要时停止流水线，避免出问题。高端的CPU，会最小化流水线的停工时间，这叫“<strong>乱序执行</strong>”。</p><p>问题二：“条件跳转”，比如之前的JUMP NEGATIVE（类似循环跳转）。这些指令会改变程序的执行流。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205017629.png" alt="image-20200214205017629">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205037500.png" alt="image-20200214205037500"></p><p>空等会造成延迟。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205050629.png" alt="image-20200214205050629"></p><p>​ 技巧：“<strong>推测执行</strong>”</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205158772.png" alt="image-20200214205158772">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205214800.png" alt="image-20200214205214800">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205239401.png" alt="image-20200214205239401"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205303755.png" alt="image-20200214205303755">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205314350.png" alt="image-20200214205314350">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205323242.png" alt="image-20200214205323242">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205340699.png" alt="image-20200214205340699"></p><p>为了尽可能减少清空流水线的次数，CPU厂商开发复杂的方法：“<strong>分支预测</strong>”。现在这种猜测的正确率超过90%。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205504704.png" alt="image-20200214205504704"></p><p>在理想情况下，CPU在一个时钟周期完成一个指令。但是“<strong>超标量处理器</strong>”的出现，一个时钟周期可以完成多个指令。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205918942.png" alt="image-20200214205918942"></p><p>用“<strong>多核处理器</strong>”【双核、四核处理器：意思是一个CPU芯片里，有多个独立的处理单元，”看起来就像有多个独立的CPU”。但因为他们整合紧密，可以共享一些资源如，缓存，使得多核可以合作运算。】。当多核不够时，可以用多个CPU。</p></blockquote><h1 id="10、早期的计算机编程"><a href="#10、早期的计算机编程" class="headerlink" title="10、早期的计算机编程"></a>10、早期的计算机编程</h1><p>​ 之前的程序是用<strong>插线板</strong>编程，到后来（1940年代晚期到1950年代初）<strong>内存</strong>的价格下降，容量上升，使得程序存入内存变得可行。程序存入内存中易于修改、方便CPU快速读取，这类机器叫做：“<strong>存储程序计算机（Stored-program Computers）</strong>”。内存足够时，还可以存储程序需要的数据（包括运行时产生的数据）。这种将程序和数据存储在一起的存储结构，叫“<strong>冯诺依曼结构</strong>”。</p><p>​ 冯诺依曼计算机的标志是，一个处理器（有算数逻辑单元）+数据寄存器+指令寄存器+指令地址寄存器+内存（负责存数据和指令）。</p><h1 id="11、编程语言发展史"><a href="#11、编程语言发展史" class="headerlink" title="11、编程语言发展史"></a>11、编程语言发展史</h1><p>​ 计算机只能处理二进制，其实，“<strong>机器语言（Machine Language）</strong>”或“<strong>机器码（Machine Code）</strong>”。在计算机早起，还必须要用机器码 些好吃呢供需，一般会先对程序进行高层次的功能描述，称为“<strong>伪代码（Pseudo-code）</strong>”，只是助于程序员理解无法让计算机运行，然后根据指令表将伪代码转换成二进制机器码，然后将机器码送入计算机中运行。</p><p>​ 在1940-1950年，程序员开发出一种新语言，更可读、更高层次，每个操作码分配一个简单名字，称为<strong>助记符（Mnemonics）</strong>，助记符后跟数据，形成完整的指令。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200215202238984.png" alt="image-20200215202238984"></p><p>所以与其写0和1的机器码，程序员可以直接写“LOAD_A 14”，这个语言称为<strong>汇编语言（Assembly Language）</strong>。当然计算机无法理解“LOAD_A 14”，所以程序员们写了一个程序来将文字指令自动转换成二进制指令，这个程序称为<strong>汇编器（Assembler）</strong>，$汇编器读取汇编语言写的程序，然后转换成机器码$。</p><p>随着发展，汇编器有越来越多的功能使得编程更加容易，其中一个功能就是自动分析JUMP地址。如下图，JUMP后面跟的是内存中的真实地址，如果我们在上方对程序进行修改，则后面的所有地址都会改变。所以<u>汇编器不用固定跳转地址</u>，而是让你插入可跳转的标签，当程序传入汇编器，汇编器就会自己推算出跳转地址，这样就程序员就无序过分关注细节。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-c044bd0bbaf2c1bc95398ca38ea36153_hd.jpg" alt="img"></p><p>​ $汇编代码例子$</p><p>汇编只是修饰了一下机器码，一般来说，<u>一条汇编指令对应一条机器指令</u>，所以汇编码和底层硬件连接很密切，程序员仍需要思考使用什么寄存器和内存地址。为了释放电脑的潜力，霍普设计了一个高级编程语言，叫做Arithmetic Language Version 0，简称A0。一行高级编程语言，可能会转换成几十条二进制指令。为此做到这种复杂转换，霍普在1952年创造了第一个<strong>编译器（Compiler）</strong>，编译器专门把高级语言转换成低级语言（比如汇编 或 机器码）。由此，高级编程语言就不用管寄存器或内存位置，编译器会解决这些细节。</p><p>在1950年，大多数编程语言和编译器只能运行在一种计算机中，如果更换计算机，就要重写所有代码，因此1959年开发一种通用编程语言，可以在不同机器上通用，最后诞生了一门高级、易于使用的语言<strong>普通面向商业语言（Common Business-Oriented Language，COBOL）</strong>。为了兼容不同底层硬件，每个计算机架构需要一个COBOL编译器，由此无论运行的计算机是什么，这些编译器可以接收相同的COBOL代码。如今大多数编程语言都是如此，不必接触CPU特有的汇编码和机器码。</p><h1 id="12、编程原理-语句和函数"><a href="#12、编程原理-语句和函数" class="headerlink" title="12、编程原理-语句和函数"></a>12、编程原理-语句和函数</h1><p><code>a=5;</code>是一个编程语言的<strong>语句</strong>。</p><p>程序由一个个指令组成。</p><h1 id="13、算法入门"><a href="#13、算法入门" class="headerlink" title="13、算法入门"></a>13、算法入门</h1><p><strong>算法</strong>：<strong>解决问题的具体步骤。</strong></p><h1 id="14、数据结构"><a href="#14、数据结构" class="headerlink" title="14、数据结构"></a>14、数据结构</h1><p>数据是以什么形式存在内存里呢？<strong>我们希望数据是结构化的，方便读取</strong>，由此发明了数据结构。</p><h2 id="14-1-数组Array"><a href="#14-1-数组Array" class="headerlink" title="14.1 数组Array"></a>14.1 数组Array</h2><p>一个变量只能存储一个值，而一个数组变量能够保存多个同类型值，并且数组的值是一个个连续存在内存中的。</p><p>为了取出数组中的某个值，我们需要指定一个<strong>下标（Index）</strong>。大多数编程语言中，数组的下标都从0开始。下图是数组保存在内存中的形式，为了简单，假设编译器从内存地址1000开始保存数组，数组中的内容就像图中那样顺序保存在内存中。定义该数组变量为<code>j</code>，则<code>j[0]</code>会取内存地址1000的数据来获得第一个元素的值， <code>j[5]</code> 则会去内存地址1000加5个偏移量得到内存地址1005中保存的数据。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-05e5d5a5004692369a9475bf3d6f886a_hd.jpg" alt="img"></p><p><strong>缺点：</strong>创建数组时就要固定大小，不能动态增加大小，并且数组在内存中是按顺序存储的，在中间插入一个值很困难。</p><h3 id="14-2-字符串String"><a href="#14-2-字符串String" class="headerlink" title="14.2 字符串String"></a>14.2 字符串String</h3><p>类似于数组，其实就是字母、数字、标点符号等构成的数组。我们在第4节中有讨论了计算机怎么存储字符的，通过ASCII或者Unicode编码，将字符转换为对应的二进制数。</p><p>写代码时，可以直接用引号括起来构建字符串<code>j=&quot;Hello World&quot;</code>， 其在内存中的存储形式如下图。<strong>注意：</strong>字符串在内存中以<strong>二进制0</strong>结尾，表示字符串结尾，用来给别的函数指示什么时候字符串结束了。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-b8b2ba66353be16cf7a7c96f744c9879_hd.jpg" alt="img"></p><h3 id="14-3-矩阵Matrix"><a href="#14-3-矩阵Matrix" class="headerlink" title="14.3 矩阵Matrix"></a>14.3 矩阵Matrix</h3><p>之前保存的都是一维数组，但是像电子表格或屏幕像素，都需要保存二维信息，所以这里就需要用到矩阵。</p><p>可以将矩阵看成是数组的数组，比如一个3x3矩阵， 相当于就是一个长度为3的数组，而这个数组中的每个元素又是一个长度为3的数组。矩阵保存在内存中的形式如下图所示，这里使用的是<u>行优先存储</u>，即优先将矩阵的每一行保存在内存的相邻位置，当一行保存完后，再保存下一行。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-45786350b76ab13bf59f20d2d2a0f432_hd.jpg" alt="img"></p><center>矩阵例子</center>![img](https://longlongqin.gitee.io/image_save/images/assets/v2-f4e8c5b992abea5477f71fcf39702a68_hd.jpg)<center>内存中的矩阵</center>为了获取一个值，需要两个小标，比如`j[2][1]`表示从内存地址1000偏移`2*3+1=7`位置，得到元素12。这里偏移量的计算方法是`行索引*列元素个数+列索引`。<p>我们不仅能构建二维矩阵，我们可以构建任意维度的矩阵。</p><h3 id="14-4-结构体Struct"><a href="#14-4-结构体Struct" class="headerlink" title="14.4 结构体Struct"></a>14.4 结构体Struct</h3><p>目前我们只将单个数字或字符存在数组或矩阵中，在数组中保存的都是相同类型的元素。<u>如果我们想把几个有关系的变量存储在一起，并且这些变量都是不同类型的</u>，我们就需要用到结构体。</p><p>…..</p><h1 id="16、软件工程"><a href="#16、软件工程" class="headerlink" title="16、软件工程"></a>16、软件工程</h1><p>为了写大型程序，程序员用各种工具和方法，所有这些形成了软件工程学科。</p><p>将大项目分解成小<strong>函数</strong>可以让很多人同时工作，由此他们无需关心整个项目，只要关心自己的函数就好了。</p><p>但是这种抽象程度还是不够，大型项目中可能还是会存在大量的函数，因此需要将函数打包成层级，将相关代码放在一起，打包成<strong>对象（Object）</strong>。比如汽车软件中，可能有几个和定速巡航有关的函数，因此我们可以包装一个“定速巡航对象”来打包这些函数，我们还可以更进一步，“定速巡航”只是引擎软件的一部分，可能还有“火花塞点火”、“燃油泵”和“散热器”等等，因此我们可以做一个“引擎对象”来打包所有子对象，并且除了子对象，引擎对象还会包含自己的函数，比如“开关引擎”，也会有自己的变量，比如汽车行驶里程数。总的来说，对象可以包含其他对象、函数和变量。然后当你想调用一个比较底层对象的函数时，只需要层层向下调用就行，比如<code>Car.Engine.CruiseControl.setCruiseSpeed(55)</code>。这种将函数打包成对象的思想称为<strong>面向对象编程（Object Oriented Programming）</strong>。相同的想法都是通过封装组件来隐藏复杂度。</p><p>把大型软件拆成一个个更小单元，会更适合团队合作。但是各个团队之间的代码是相互交织的，比如团队A实现的某个函数需要团队B的代码支持，因此团队需要<strong>文档（Documentation）</strong>来帮助理解代码都做什么，以及定义好的<strong>程序编程接口（Application Programming Interface，API）</strong>。这样，即使程序员不知道具体的实现细节，也能直接使用API调用相应的函数。并且API能控制哪些函数和数据是对外开放的，哪些是仅供对象内部使用的，面向对象的编程语言可以指定函数时<code>public</code>或<code>private</code>来设置权限，避免用户调用错了函数造成bug。如果标志为private，表示只有同一个对象内的其他函数能调用它， 所以在这个例子中，只有内部函数比如<code>setRPM</code>能够调用 <code>fireSparkPlug</code>函数，并且由于<code>setRPM</code>函数是public的，所以其他对象可以调用它。</p><blockquote><p><strong>面向对象编程的核心：</strong>隐藏复杂度，选择性的公布功能。</p></blockquote><p>现代软件开发者会使用专门的工具来写代码，工具里集成了很多功能帮助写代码、整理、编译和测试，这些软件称为<strong>集成开发环境（Integrated Development Environments，IDE）</strong>。</p><p>程序员一个重要的工作部分是给代码写文档，一般放在一个叫<code>README</code>的文件中， 文档也能直接写成注释放在源代码中。</p><p>除了IDE，还有一个重要软件帮助团队协作，称为<strong>源代码管理（Source Control）</strong>。比较大型的公司会将代码放在一个中心服务器上，称为<strong>代码仓库（Code Repository）</strong>。当程序员想改一段代码时，可以check out获得代码，然后开发者在自己电脑上编辑代码，当代码没有问题，所有测试都通过时，就能将代码放回代码仓库了，称为<strong>提交（Commit）</strong>。当代码被check out，并且可能被改过了，其他开发者就不会动这段代码，避免代码冲突和重复劳动。代码的主版本（master）应该总是编译正常，尽可能少bug。并且源代码管理可以跟踪所有变化，当出现bug时，全部或部分代码可以<strong>回滚（Rolled Back）</strong>到之前的稳定版本，并且也能记录下代码修改者。</p><p>测试代码一般由个人或小团队完成，测试可统称为<strong>质量保证测试（Quality Assurance Testing，QA）</strong>。<strong>“alpha version”</strong>软件一般很粗糙，错误很多，经常只在公司内部操作，而<strong>“beta version”</strong>软件指的是软件接近完成，但不是完全测试通过，公司有时会向公众发布beta版，以帮助发现问题，用户就像免费的QA团队。</p><h1 id="17、集成电路-amp-摩尔定律"><a href="#17、集成电路-amp-摩尔定律" class="headerlink" title="17、集成电路&amp;摩尔定律"></a>17、集成电路&amp;摩尔定律</h1><p>过去计算机的飞速发展，强烈依赖于硬件的发展。</p><p>大约1940年代-1960年代中期，计算机都由独立部件组成，称为<strong>分立元件（Discrete Components）</strong>，然后不同组件再用线连在一起。比如ENIAC有1万7千多个真空管，7万个电阻，1万个电容，7千个二极管，5百万个手工焊点。如果想要提升性能，就要加更多部件，这就导致了更多更复杂的电线，这个称为<strong>数字暴政（Tyranny of Numbers）</strong>问题。</p><p>到1950年代中期，晶体管开始商业化，开始用于计算机中，晶体管比电子管更小更快更可靠，但晶体管依然是分立元件。1959年，IBM把709计算机从原本的电子管全部换成晶体管，诞生了IBM 7090，速度快6倍，价格只有一半。晶体管标志着计算机2.0时代的到来，但是晶体管的出现还是没有解决数字暴政的问题，有十几万个独立元件的计算机不但难设计，而且难生产。</p><h2 id="集成电路（Integrated-Circuits，IC）："><a href="#集成电路（Integrated-Circuits，IC）：" class="headerlink" title="集成电路（Integrated Circuits，IC）："></a>集成电路（Integrated Circuits，IC）：</h2><p>到1960年代，这个问题的严重性达到顶点，解决方法就是引入一层新抽象，封装复杂性。突破性进展在1958年，与其把多个独立部件用电线连起来，拼装出计算机，我们把多个组件包在一起，变成一个新的独立组件，这个称为<strong>集成电路（Integrated Circuits，IC）</strong>。几个月后，仙童半导体就让集成电路变成现实，之前使用锗来做集成电路，但是锗很稀少且不稳定，仙童半导体使用<strong>硅</strong>，因为硅的蕴藏量丰富，也更稳定可靠。</p><p>起初，一个IC只有几个晶体管，但是也足以将逻辑门封装成独立组件，可以组合出无数种设计，但是最终还是要连起来，创造出更大更复杂的电路，比如计算机。所以创造出了<strong>印刷电路板（Printed Circuit Boards，PCB）</strong>，可以大规模生产，无需焊接或用一堆线，它通过蚀刻金属线的方式将零件连接到一起。把PCB和IC结合使用，可以大幅减少独立组件和电线，但做到相同的功能，而且更小更便宜更可靠。</p><p>不过即使组件再小，塞5个以上的晶体管还是很困难，为了实现更复杂设计，出现了全新的制作工艺——<strong>光刻（Photolithography）</strong>。简单来说，就是用光把复杂图案印到材料上，比如半导体。它只有几个基础操作，但是可以制作出复杂电路。</p><blockquote><ul><li>首先，我们从一片硅开始，称为<strong>晶圆（Wafer）</strong>，长得和薄饼干一样。并且硅是半导体，有时导电有时不导电，我们就可以控制导电时机，所以硅是做晶体管的绝佳材料。我们可以用晶圆做基础，把复杂金属电路放上去，来集成所有东西。</li><li>在硅片顶部加一层薄薄的<strong>氧化层（Oxide Layer）</strong>作为保护层，然后加一层特殊化学品称为<strong>光刻胶（Photoresist）</strong>，光刻胶被光照射后，就变得可溶，可以用一种特殊化学药剂洗掉。然后我们会在光刻胶上加一层<strong>光掩膜（Photomask）</strong>，当用强光照射时，挡住光的部分光刻胶就不会变化，而光照射到的地方，光刻胶就会发生化学变化，洗掉变化的光刻胶后，就会暴露出部分氧化层。然后通常用酸能洗掉氧化层暴露出的部分，就能蚀刻到硅层。然后再用另一种化学试剂清洗掉剩余的光刻胶，这样只剩下氧化层和晶圆了。我们想修改硅暴露出来的区域，让它们导电性更好，所以我们使用<strong>掺杂（Doping）</strong>，通过将磷渗透进暴露的硅，来改变电学性质。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-43b8796ff46c3bf12da90361caf3a74b_hd.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-b19ae3a9f85fb157495ee4a2a986c4b1_hd.jpg" alt="img"></p><ul><li>我们还需要几轮光刻法来做晶体管。还是叠加上氧化层、光刻胶和新的光掩膜，这样就能在掺杂区域上方开缺口，然后进行清洗蚀刻，再用另一种元素进行掺杂，把硅转换成另一种形式。为了控制深度，时机很重要，不要超过之前掺杂的区域，这样所有需要的组件都有了。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-0261b1e130471a85ebaea8f5df038bab_hd.jpg" alt="img"></p><ul><li>最后，在氧化层上做通道，这样可以用细小金属导线连接不同晶体管。首先用光刻胶和光掩膜，在氧化层上蚀刻出小通道。然后用新的处理方法称为<strong>金属化（Metalization）</strong>，在氧化层上放一层薄薄的金属，比如铝或铜，再加上光刻胶和光掩膜，然后融掉暴露的光刻胶，暴露出金属。最终清洗，只保留晶圆、氧化层和金属化，这样就做出了一个晶体管。它有三根线分别连接着硅的三个不同区域，每个区域的掺杂方式不同，这个叫<strong>双极型晶体管（Bipolar Junction Transistor）</strong>。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-b2d6dce62f3352d950dc12e238fc0099_hd.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-f099fd3eea9861f0ef822f76299e616c_hd.jpg" alt="img"></p><center>晶体管</center></blockquote><p>相同方法，光刻可以在一片硅上制作其他电子元件，比如电阻电容，而且相互连接的电路也做好了。</p><p><strong>并且通过调节光掩膜和光源之间的距离</strong>，光可以投射成任意角度，我们可以把光掩膜聚焦到极小的区域，制作出非常精细的细节，这样一片晶圆就能做出很多IC，整块都做完后，就可以切割然后包进微型芯片中，芯片的核心都是一小片IC。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-77dbe69c1ca5bcacd2c735dccfe11c7a_hd.jpg" alt="img"></p><p>随着光刻技术发展，晶体管变小，密度变高。1960年初，IC很少能超过5个晶体管，但到了1960年中期，市场上已经开始出现超过100个晶体管的IC。</p><h2 id="摩尔定律（Moore’s-Law）"><a href="#摩尔定律（Moore’s-Law）" class="headerlink" title="摩尔定律（Moore’s Law）:"></a>摩尔定律（Moore’s Law）:</h2><p>1965年，戈登·摩尔看到了发展趋势，提出<strong>摩尔定律（Moore’s Law）</strong>：<strong>每两年左右，得益于材料和制造技术的发展，同样大小的空间，能塞进两倍量的晶体管。</strong></p><p>晶体管更小密度更高，要移动的电荷量就越少，能快速切换状态，耗电更少。并且电路更紧凑，意味着信号延迟更低，导致时钟速度更快。</p><p>集成电路的出现，尤其是用来做微处理器，开启了<strong>计算机3.0时代</strong>。</p><p>到了2010年，一个IC中有10亿个晶体管。为了达到这种密度，光刻的分辨率从大约一万纳米，发展到如今的14纳米。</p><p>现代工程师设计电路时，不是手工一个个设计晶体管的，从1970年代开始，<strong>超大规模集成（Very-large-scale Integration，VLSI）</strong>软件用来自动生成芯片设计。用比如<strong>逻辑综合（Logic Synthesis）</strong>可以放一整个高级组件，比如内存缓存，软件会自动生成电路，做到尽可能高效，许多人认为这是<strong>计算机4.0时代</strong>的开始。</p><p><u>但是摩尔定律现在迎来了终结，进一步做小，会迎来两个问题：</u></p><ol><li>用光掩膜把图案弄到晶圆上，因为光的波长，精度已经到达极限。所以科学家在研制波长更短的光源，投射更小的形状。</li><li>当晶体管非常小，电极之间可能只距离几个原子，电子就会跳过间隙，称为<strong>量子隧道贯穿（Quantum Tunneling）</strong>，由此晶体管就不能正常工作了。</li></ol><h1 id="18、操作系统"><a href="#18、操作系统" class="headerlink" title="18、操作系统"></a>18、操作系统</h1><p>40 50年代的电脑，每次只能运行一个程序，程序员在打孔纸上写程序，然后再放入计算机中进行计算，一开始计算机速度比较慢，通常一个程序需要运行几天时间，所以放程序的时间还能忍受。但是随着计算机运算速度的告诉发展后，放程序的时间比程序运行时间还要长，我们就需要一种方式，让计算机自动运行，于是诞生了<strong>操作系统（Operation Systems，OS）</strong>。</p><p><strong>操作系统其实也是程序</strong>，<u>但它有操作硬件的特殊权限，可以运行和管理其他程序</u>。操作系统一般是开机第一个启动的程序，然后其他所有程序都由操作系统启动。从1950年代开始有操作系统，那时计算机开始变得更加强大， 第一个操作系统主要加强了程序加载方式，取代了手工加载程序的过程。</p><p>之前只能一次给一个程序，现在可以一次多个程序，当计算机运行完一个程序后，就会自动运行下一个程序，这样就不用浪费时间找下一个程序的纸卡，这称为<strong>批处理（Batch Processing）</strong>。</p><p>随着计算机的发展，计算机出现在大学和政府办公室，人们开始分享软件，但是有个问题。在哈佛1号和ENIAC那个时代，计算都是一次性的，程序员只需要给特定一台机器写代码，其中处理器、读卡器和打印机都是已知并且不会改变的。但是随着计算机越来越普遍，计算机配置并不总是相同的，比如计算机可能有相同的CPU但是不同的打印机等等，这样程序员不仅要担心程序，还要担心程序怎么和不同型号的打印机进行交互，以及计算机连着的其他设备，统称为<strong>外部设备（Peripherals）</strong>。和早期的外部设备交互是非常底层的，程序员需要了解设备的硬件细节，但是程序员又很少能拿到所有型号的设备来测试代码。所以一般是阅读手册然后尽可能编写代码。</p><p>所以为了能够更好地写软件，<em>操作系统就充当软件和硬件之间的媒介</em>。更具体的，操作系统提供API来抽象硬件，叫<strong>设备驱动程序（Device Drivers）</strong>。这样程序员可以通过标准化机制和<strong>输入输出硬件（Input &amp; Output，I/O）</strong>进行交互，而无需关注硬件型号以及具体硬件细节。</p><p>到1950年代末尾，电脑已经运行非常快了，处理器经常需要等待较慢的机械设备（比如打印机和读卡器），程序就阻塞在I/O上，而处理器什么都没有进行处理。英国曼彻斯特大学开始研发世界上第一台超级计算机Atlas，由于机器运算非常快，所以需要一种方式来尽可能利用更多的算力。他们于1962年年设计了一个程序叫Atlas Supervisor，<u>使得操作系统不仅能进行批处理，并且通过<strong>调度（Scheduling）</strong>还能在单个CPU上同时运行几个程序。</u></p><blockquote><p>比如我们需要调用print函数让Atlas打印一个变量值，由于打印机比CPU慢很多，所以print函数需要运行比较长的时间。与其等待打印机完成打印，Atlas会将该程序进行休眠，然后运行其他等待的并且可运行的程序。最终当打印机打印完后，会报告给Atlas，则Atlas会将之前的程序标记为“可运行”状态，然后在某个时刻会安排给CPU继续运行print函数下一行代码。由此，Atlas能够在CPU上运行一个程序，同时另一个程序在打印数据（这里是让打印机自己在打印，所以无需CPU进行参与），同时另一个程序读数据（这里只需要使用读卡器，不需要CPU）。</p></blockquote><p>Atlas配有4台读取器、4台打印机和8个磁带驱动器。使多个程序可以同时运行，在单个CPU上共享时间。操作系统的这种能力称为<strong>多任务处理（Multitasking）</strong>。但是同时运行多个程序存在一个<strong>问题</strong>，每个程序都会占用一些内存，当切换到另一个程序后，我们不能丢失这些内存中的数据。<strong>所以我们给每个程序分配专属内存块</strong>，比如我们计算机一共有10000个内存地址，然后程序A分配到了0-999的内存地址，程序B分配到1000到1999，以此类推。如果一个程序请求更多内存，操作系统就会决定是否同意，如果同意，就要决定分配哪些内存块，这就使得程序A可能会分配到非连续的内存块，使得程序员能难进行跟踪。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-352e87bdb554469c2ed3a5c8a26956bf_hd.jpg" alt="img"></p><center>内存中程序分配</center>**处理分配的内存不连续的情况--动态内存分配**<p>$如果同意，就要决定分配哪些内存块，这就使得程序A可能会分配到非连续的内存块，使得程序员能难进行跟踪。$</p><p>为了隐藏这种复杂性，操作系统会把内存地址进行虚拟化，称为<strong>虚拟内存（Virtual Memory）</strong>。程序可以假定内存总是从地址0开始，而实际的物理位置，被操作系统隐藏和抽象了。以程序B为例，它分配了内存地址1000到1999，但是对于程序B而言，它能看到的地址是0到999，操作系统会自动处理虚拟内存和物理内存之间的映射，所以程序B要地址42，实际需要物理地址1042。对于程序A，它被分配了分散的物理内存块，但是程序A并不知道，它所能看到的是连续的从0到1999的地址，当程序A读内存地址999时，会被映射到物理地址999，而当程序A读内存地址1000，则会被映射到物理地址2000。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-ab782154333eb8168c2a4d3da20a9895_hd.jpg" alt="img"></p><center>虚拟内存例子</center>这种机制使得程序的内存大小可以灵活增减，称为**动态内存分配（Dynamic Memory Allocation）**。对程序而言，内存看起来是连续的，为操作系统同时运行多个程序提供了极大的灵活性，程序员只需要根据连续的虚拟内存地址进行编程，无需考虑程序在实际物理内存中不连续的物理内存块。<p>同时给每个程序分配一个专用的内存块，可以使得隔离起来更方便。如果一个程序出错了，在内存中胡乱写数据，它只能在自己分配的内存块中进行操作，不会影响到其他程序的数据，这个称为<strong>内存保护（Memory Protection）</strong>。这对于防止恶意软件是否有效。Atlas是第一台提供虚拟内存和内存保护功能的操作系统。</p><p>到1970年代，大学会购买电脑给学生使用，此时计算机不仅能同时运行多个程序，还能让多个用户同时访问。多个用户使用<strong>终端（Terminal）</strong>来访问计算机（这里的终端只有键盘和屏幕，然后连接到计算机），终端本身并不具有处理能力。这样计算机不仅要能处理多个程序，还要处理多个用户，为了确保其中一人不会占满计算机资源，开发了<strong>分时操作系统（Time-Sharing）</strong>，指的是每个用户只能用一小部分处理器、内存等，因为计算机很快，所以即使只有一小部分资源，也足以完成很多任务。</p><p>早期分时操作系统中，最有影响力的是1969年发布的Multics，它是第一个从设计时就考虑到安全性的操作系统。开发人员不希望恶意用户访问不该访问的数据，这使得操作系统的复杂度远超当时的平均水平，通常内存的一半都要用来运行操作系统，这种过度设计使得Multics未能获得商业成功。所以研究员们重新打造了一个操作系统Unix，他们想把操作系统分成两部分：</p><blockquote><ol><li>操作系统的核心功能，比如内存管理，多任务和输入输出处理，这个称为<strong>内核（Kernel）</strong>。</li><li>一些有用的工具，但是他们不是内核的一部分，比如程序和运行库。</li></ol></blockquote><p>紧凑的内核意味着功能没有之前那么全面。当内核出现崩溃时，Multics有很多操作来进行恢复，但是Unix是没有办法恢复的，会直接调用一个panic函数，最初只能无限循环打印panic。这种简单性意味着Unix可以再更便宜的硬件上运行。1971年发布之后，就有人写了不同编程语言的编译器，甚至文字处理器，使得Unix迅速成为1970-80年代最流行的操作系统之一。</p><p>到1980年代早期，个人电脑逐渐出现，这些电脑比大型主机简单很多，主机一般在大学、公司和政府，因此操作系统也要变得简单。于1981年微软发布的磁盘操作系统MS-DOS只有160kb，虽然缺少多任务和保护内存这样的功能，意味着程序经常使系统崩溃，用户可以直接重启。即使在1985年发布的早期windos，也一样缺少内存保护功能，当程序错误时，就会出现蓝屏。</p><p>现代的操作系统包含了<strong>多任务</strong>、<strong>虚拟内存</strong>和<strong>内存保护机制</strong>，因此可以同时运行多个程序。</p><h1 id="19、内存-amp-存储介质"><a href="#19、内存-amp-存储介质" class="headerlink" title="19、内存&amp;存储介质"></a>19、内存&amp;存储介质</h1><p>一般来说，电脑<strong>内存</strong>是<strong>非永久性的（Non-Permanent）</strong>，如果电脑关机，则内存中的所有数据都会丢弃，所以内存叫<strong>易失性存储器（Volatile Memory）</strong>，还存在另一种<strong>存储器（Storage）</strong>，存储器（storage）和内存（memory）存在一定的不同。任何写入storage的数据，就会一直保存，直到被覆盖或删除，断点也不会丢失，称为<strong>非易失性（Non-volatile）</strong>。过去是易失性的速度快，非易失性的速度慢，但随着技术发展，两者的差异越来越小。</p><p>最早的存储介质是打孔纸卡以及打孔纸带，到1940年代，纸卡标准是80列x12行，能够存储960位数据。纸卡用了十几年，因为不用电而且便宜耐用，但是读取速度较慢，只能写入一次，对于存临时值，纸卡不好用，我们需要更大更灵活的存储方式。</p><h2 id="延迟线存储器："><a href="#延迟线存储器：" class="headerlink" title="延迟线存储器："></a>延迟线存储器：</h2><p>1944年时，出现了<strong>延迟线存储器（Delay Line Memory）</strong>。<strong>原理</strong>：假设你有一个装满液体（如水银）的管子，管子一端放着扬声器，另一端放着麦克风，当扬声器发出脉冲时，就会在管子内产生压力波，经过一段时间后压力波会传递到麦克风，然后麦克风将压力波转换为电信号，通过在麦克风后面接一个<strong>放大器（AMPLIFIER）</strong>，然后连回扬声器，我们就能用压力波的传播延迟来存储数据。假设有压力波代表1，没有代表0，扬声器发出一系列压力波，因为传播延时的原因，这些压力波会存在管子内，当撞击到麦克风后，又会通过扬声器重新回到管子，所以就能将数据保存在管子内。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200222172929235.png" alt="image-20200222172929235"></p><p>在1949年的EDVAC计算机中使用了延迟线存储器，总共有128条延迟线，每条能存352位，一共能保存45000位。这使得EDVAC成为最早的<strong>存储程序计算机</strong>之一。</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>但延迟线存储器的<strong>缺点</strong>是，每个时刻只能读一位数据，如果想访问一个特定的位，就要等待它从循环中出现，所以又被称为<strong>顺序存储器Sequential Memory）</strong>或者<strong>循环存储器（Cyclic-Access Memory）</strong>。而我们想要<strong>随机存取存储器（Random Access Memory）</strong>，可以随时访问任何位置。并且增加内存密度也是一个挑战，如果要将压力波变得更紧密，就会使其混在一起，所以出现了其他类型的延迟线存储器，比如<strong>磁致伸缩延迟存储器（Magnetostrictive Delay Lines）</strong>，它通过金属线的振动来代表数据。</p><h2 id="磁芯存储器："><a href="#磁芯存储器：" class="headerlink" title="磁芯存储器："></a>磁芯存储器：</h2><p>但是延迟线存储器在1950年代中期就过时了。因为出现了新技术，于是出现了，<strong>磁芯存储器（Magnetic Core Memory）</strong>，它用了环状磁圈，如果给磁芯绕上电线并施加电流，就能将其磁化在一个方向，如果关掉电流，磁芯还会保持磁化，如果施加了相反方向的电流，则磁化方向会翻转。这样我们就能通过磁化方向来存储0和1，就能用来存储1位。通过将磁芯排列成网格状，有线路负责选择行和列，也有电线贯穿每个磁芯，用于读写1位。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-c8e58ebec8d54b77be564e81463cd7de_hd.jpg" alt="img"></p><center>磁芯存储器</center>如果要存的数据超过1bit，就需要把磁芯存储器排列成网格：<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200222173626986.png" alt="image-20200222173626986"></p><p>1953年麻省理工的Whirlwind1计算机第一次大规模使用磁芯内存，磁芯排列使用32x32，用了16块板子，大约能存储16000位。不像延迟线存储器，磁芯存储器能随时访问任何一位，因此从1950年代中期成为主流，流行了20多年，将存储成本从1美元1位降低到了1美分左右。</p><h2 id="磁带："><a href="#磁带：" class="headerlink" title="磁带："></a>磁带：</h2><p>到1951年，UNIVAC电脑推出了一种新存储——<strong>磁带（Magnetic Tape）</strong>。磁带是纤薄柔软的一长条卷在轴上的磁性带子，磁带可以在<strong>磁带驱动器</strong>内前后移动，里面有一个缠绕了电线的<strong>写头（Write Head）</strong>，通过电流来产生磁场，导致磁带的一小部分被磁化，电流方向决定了极性，代表1和0。同样还有一个读头（Read Head），可以非破坏地检测极性来确定数据。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-1d9ac11988c8c3e7e54dc2c032bc21a4_hd.jpg" alt="img"></p><h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><p>磁带的主要缺点是访问速度，磁带是连续的，必须倒带或快进到特定位置。</p><p>50 60年代出现了类似的技术<strong>磁鼓存储器（Magnetic Drum Memory）</strong>,有一个金属圆管，盖满了磁性材料来记录数据，圆管会持续旋转，周围有数十个读写头，等圆管转到了正确的位置，读写头就会读或写数据。</p><p>但到了1970年代磁鼓存储器就不再生产了，但是磁鼓导致了<strong>硬盘（Hard Disk Drives）</strong>的发展，磁盘的好处是薄，可以叠在一起来提供更多表面积来存储数据。要访问某个特定位，一个读写磁头会上下移动，找到正确的磁盘，然后磁头会滑进去，就和磁鼓存储器一样，磁盘也会高速旋转，所以读写头要等到正确的部分旋转过来，这个称为<strong>寻道时间（Seek Time）</strong>。</p><p>以下是<strong>内存层次结构（Memory Hierarchy）</strong>，有一小部分高速且昂贵的内存，一部分稍慢且相对便宜的内存，还有更慢且更便宜的内存，这种混合可以在成本和速度之间取得平衡。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200222174311987.png" alt="image-20200222174311987"></p><p>其次还有<strong>软盘（Floppy Disk）</strong>，除了磁盘是软的，其他都一样。</p><p>后面出现的<strong>光盘（Compact Disk，CD）</strong>以及DVD，它们不使用磁性来保存数据，而是使用表面的小坑来造成光的不同反射，通过光学传感器捕获并解码为1和0。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200222174429795.png" alt="image-20200222174429795"></p><center>光盘表面</center>如今成本下降了更多的存储技术在朝**固态（Solid State）**前进，**机械硬盘（hard disk drive，HDD）**被**固态硬盘（Solid State Drive，SSD）**逐渐代替。由于SSD没有机械活动部件，里面都是集成电路。因为不存在机械活动，所以磁头不用等磁盘旋转，所以固态速度快很多，但是仍然比RAM慢很多，<u>所以现代计算机仍然使用存储层次结构</u>。<h1 id="20、文件系统"><a href="#20、文件系统" class="headerlink" title="20、文件系统"></a>20、文件系统</h1><p>上一节中介绍的数据存储。存储器可以在断电状态下长时间存上万亿位，所以非常适合用来存一整块有关系的<u>数据</u>（或者称为<strong>文件（Files）</strong>），比如文本文件、音乐文件、照片和视频。这一节将讨论文件是什么以及计算机是怎么管理文件的。</p><p>随意排列文件的数据是没有问题的，但按格式排列会更好，这个称为<strong>文件格式（File Format）</strong>。</p><p>首先看一个最简单的文件格式——<strong>文本文件（Txt File，txt）</strong>。就像其他文件一样，文本文件只是一长串二进制数，可以通过ASCII编码将其解码成对应文本。</p><h2 id="波形文件："><a href="#波形文件：" class="headerlink" title="波形文件："></a>波形文件：</h2><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200223201711965.png" alt="image-20200223201711965"></p><center>波形文件（WAV）</center>**波形文件（Wave File，WAV）**用于存音频数据。在正确读取数据之前，我们需要知道一些信息比如码率，以及是单声道还是立体声，这种描述数据的数据称为**元数据（Meta Data）**。元数据保存在文件开头，在实际数据之前，因此也叫**文件头（Header）**。以下是WAV文件的前44个字节，有些部分会根据数据进行变化。<p>[^元数据]: <strong>元数据</strong>（<strong>Metadata</strong>），又称<strong>中介数据</strong>、<strong>中继数据</strong>，为描述<a href="https://baike.baidu.com/item/数据/5947370" target="_blank" rel="noopener">数据</a>的数据（data about data），主要是描述数据<a href="https://baike.baidu.com/item/属性/1405051" target="_blank" rel="noopener">属性</a>（property）的<a href="https://baike.baidu.com/item/信息/111163" target="_blank" rel="noopener">信息</a>，用来支持如指示存储位置、<a href="https://baike.baidu.com/item/历史/360" target="_blank" rel="noopener">历史</a>数据、<a href="https://baike.baidu.com/item/资源/9089683" target="_blank" rel="noopener">资源</a>查找、文件记录等功能。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200223201307602.png" alt="image-20200223201307602"></p><center>WAV格式的数据的元数据</center>而音频数据就紧跟在元数据之后，也是一长串二进制数，这些数字代表每秒捕获多次的声音幅度。麦克风首先会对声音进行每秒上千次采样，每次采样可以用一个数字表示，声压越高数字越大，称为**振幅(Amplitude)**，这就是WAV文件中存储的数据。播放声音时，扬声器就会产生相同的波形。<h2 id="位图-Bitmap"><a href="#位图-Bitmap" class="headerlink" title="位图(Bitmap)"></a>位图(Bitmap)</h2><p>再来谈谈<strong>位图</strong>，其后缀为bmp，用于保存图片。。计算机中，图片由多个<strong>像素(Pixel)</strong>方块组成，每个像素由三种颜色组成：红、绿、蓝，叫<strong>“加色三原色”</strong>，混合在一起能产生其他颜色。类似于WAV文件，BMP文件开头也是元数据，有图片宽度、图片高度和颜色深度等等。现在假设图片宽高均为4个像素，颜色深度为24，也就是8位(bit)红色、8位绿色和9位蓝色，则每个颜色有0-255程度，然后依次保存每个位置的三原色数值。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200223202632500.png" alt="image-20200223202632500"></p><center>位图的元数据</center>![image-20200223203327886](https://longlongqin.gitee.io/image_save/images/assets/image-20200223203327886.png)<center>位图的数据</center>通过以上例子，可以知道，文件底层都是二进制数，为了知道文件是什么，文件格式就十分重要。<h2 id="计算机如何存储文件："><a href="#计算机如何存储文件：" class="headerlink" title="计算机如何存储文件："></a>计算机如何存储文件：</h2><p>最简单存储多个文件的方法是将文件<strong>连续存储</strong>，但是这样怎么知道文件开头和结尾在哪呢？存储器并没有文件的概念，它只是用来存储大量二进制数。所以我们需要特殊文件来记录其他文件的位置，这里称为<strong>目录文件（Directory File）</strong>，它通常保存在存储器最开头，方便寻找。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-46682a86deaa95c83bba62ae802f8120_hd.png" alt="img"></p><center>storage</center>在目录文件中，存有其它所有文件的名字，格式为`文件名+点+扩展名`， 扩展名有助于得知文件类型。目录文件还保存了文件的元数据，比如创建时间、最后修改时间、文件所有者、是否能读写，最重要的是记录了文件起始位置和长度。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200223203721221.png" alt="image-20200223203721221"></p><center>目录文件</center>如果要添加、删除文件或者更改文件名，必须更新整个目录文件。<p>目录文件以及对目录文件的管理，是最基本的<strong>文件系统（File System）</strong>的例子，文件系统专门负责管理文件。刚刚的例子叫<strong>平面文件系统（Flat File System）</strong>，因为所有文件都在同一层次。存在一个<strong>缺点</strong>：当我们想要对中间文件增加数据时，就会覆盖后续文件的数据。所以现代文件系统会做两个处理：</p><ol><li>将空间划分成一块块，会出现一些<strong>预留空间（Slack Space）</strong>，可以方便改动。同时文件数据都对齐到了相同大小，可以方便管理。使用这种方案，目录文件就要记录文件在哪些块中。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200223204243036.png" alt="image-20200223204243036"></p><ol start="2"><li>拆分文件保存在多个块中。假设todo.txt文件中加了一些数据，使得文件太大无法存在一个块中，则文件系统会分配一个没使用的块来容纳额外的数据，<u>则目录文件对每个文件就会记录不止一个块，而是多个块</u>。通过分配块，文件就可以轻松增加减小。如果想要删除carrie.bmp，只要在目录文件中删除对应记录就行，让这一块空间变成可用的，这样就不需要进行擦除，只需要直接删除记录就行。<strong>在那一块被新数据覆盖之前，数据还是保存在原处的。所以恢复删除数据是有可能的。</strong></li></ol><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200223204550449.png" alt="image-20200223204550449"></p><p>当文件过大，保存在若干个块中，这个称为<strong>碎片（Fragmentation）</strong>，碎片是增删改文件导致的，无法避免，但是会造成性能下降。解决方法是通过<strong>碎片整理（Defragmentation）</strong>，计算机会将数据来回一定，排列成正确的顺序，就能很方便地进行读写。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200223204701481.png" alt="image-20200223204701481"></p><center>碎片整理前</center>![image-20200223204733889](https://longlongqin.gitee.io/image_save/images/assets/image-20200223204733889.png)<center>碎片整理后</center>随着容量爆炸式增长，文件数量飞速增加，平面文件系统逐渐应付不来，所以出现了**分层文件系统（Hirerarchical File System）**，这里最大的变化就是每个文件夹中都有一个目录文件，并且目录文件不仅要指向文件，还要指向目录，还需要增加额外的元数据来区分文件和目录。<p><strong>优点</strong>：这种文件系统不仅可以做出无限深的文件夹，也可以让我们很轻松地移动文件，我们不需要移动任何数据块，只需要在两个目录文件中删增记录就行。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200223204831349.png" alt="image-20200223204831349"></p><center>分层文件</center>文件系统使我们不必关心文件在磁盘中的具体位置。<h1 id="21、压缩"><a href="#21、压缩" class="headerlink" title="21、压缩"></a>21、压缩</h1><p>之前介绍了文件格式，如何编码文字、声音和图片，但是它们的效率并不高，我们希望文件能小一点，这样就能保存大量文件，同时传输也会快一些，解决方法就是<strong>压缩（Compression）</strong>，把数据占用的空间压得更小，为此我们需要用更少的bit来表示数据。</p><p>以压缩图片为例，图片一般存成一长串像素值，为了知道一行在哪里结束，图像要有元数据，写明尺寸等属性。每个像素的颜色是三原色的组合，每个颜色用一个字节保存，数字范围是0~255（一个字节=8 bits，2^8^=256），由此一张<code>4*4</code>（16个像素）大小的图像，其中每个像素3个字节。则这个图片需要<code>4*4*3=</code>48字节。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200226140325517.png" alt="image-20200226140325517"></p><p>—》存成一长串像素值：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200226151330368.png" alt="image-20200226151330368"></p><center>图片一般存成一长串像素值</center>![img](https://longlongqin.gitee.io/image_save/images/assets/v2-202fff7eae740ec4451258a92c96eda0_720w.jpg)<center>前五个像素的表示</center>## 无损压缩：<p>一种压缩方法是减少重复信息，最简单的方法叫<strong>游程编码（Run-Length Encoding）</strong>，适合经常出现相同值的文件。比如上图中有7个连续相同的黄色像素块，我们可以插入一个额外字节来表示7个连续黄色像素，然后删掉后面重复的数据。为了让计算机分辨哪些字节时长度，那些字节是颜色，格式需要保持一致，所以我们需要给所有像素前面都标上长度。在这个例子中现在只需要24个字节，并且不损失任何信息。这个方法称为<strong>无损压缩（Lossless Compression）</strong>，没有丢失任何数据。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-315b1a99dd4902cb5d8a9c9d7a81cde1_720w.png" alt="img"></p><center>游程编码</center>另一种无损压缩方法叫做**DFTBA**，它用更紧凑的方式来表示数据块。首先我们需要一个字典，来保存代码和数据之间的对应关系。我们可以将图像看成一块一块，而不是一个个像素，为了简单，我们将2个像素当成一个块，由此我们可以得到下图的4个像素对，我们会对些像素对生成**紧凑代码（Compact Codes）**。这些块出现频率不同，我们通过霍夫曼树的方法对每一种情况进行编码，使得频率最高的块代码最短。然后我们就能通过code代替块来对图像进行压缩。这个例子中将48字节的数据压缩成了14位，但是同样也要把字典保存下来，所以还需要将字典加到数据前面，所以总共有30字节。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-e40dfa25fd9f55ddb49ac3c558b2415f_720w.jpg" alt="img"></p><center>使用霍夫曼树生成的块的编码</center>![img](https://longlongqin.gitee.io/image_save/images/assets/v2-557e83d3f9b5d120457fb8fe3fc9df87_720w.png)<center>压缩结果</center>![img](https://longlongqin.gitee.io/image_save/images/assets/v2-e688a0f2a014255ed2e3c9ba38855ed5_720w.png)<center>加上字典后的压缩结果</center>## 有损压缩：<p>“消除冗余”和“使用更紧凑表示方法”通常会组合起来一起使用，几乎所有无损压缩格式都用到它们。</p><p>无损压缩对于文本数据十分重要，但是有其他一些数据即使丢失了一部分也不会造成很大影响，通常会丢失人们无法注意到的信息，大部分<strong>有损压缩技术（Lossy Compression）</strong>都用到了这点。</p><p>以声音为例，人类听力并不是完美的，有些频率我们可以捕获，但是类似于超声波这类的频率我们根本听不见，所以录制音乐时，超声波数据是可以丢弃的，其次人类对人声十分敏感，所以应该尽可能保持原样。<strong>有损音频压缩（Lossy Audio Compressors）</strong>通过不同精度编码不同频段，这样人类听不出什么区别，也不会明显影响体验。比如电话中也用到了这个技术，这就使得在电话中的声音和现实中有所差别，用过这个技术才使得更多人同时打电话。如果网速变慢，压缩算法就会删掉更多的数据。压缩音频文件MP3和没压缩音频文件WAV或FLAC大小可以相差10倍。</p><p>这种删除人类无法感知的数据的方法称为<strong>感知编码（Perceptual Coding）</strong>。这也是各种有损压缩图像格式的基础，比如JPEG，人类的视觉系统也不是完美的，我们比较善于看到尖锐的对比，比如物体的边缘，但我们无法看出颜色的细微变化。JPEG由此将图像分解成8x8大小的像素块，然后删掉大量高频空间数据。比如以下这张图片，其中一个8x8像素，由于每个像素都有细微差异，所以无损压缩技术很难对其压缩，但是人眼很难看出这些细微差别，所以我们可以删除很多像素值，这样只占10%的原始数据，并且图像看起来没有什么区别。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-0dcede4590c5d2552a8fe9e4d5a45c95_720w.jpg" alt="img"></p><center>原图；8x8原始像素块；8x8压缩像素块；压缩图像</center>视频只是一长串连续图片，所以图片的很多方面也适用于视频，但视频也可以做一些小技巧，因为帧与帧之间有很多相同的像素，称为**时间冗余（Temporal Redundancy）**。我们不需每一帧都保存这些像素，可以只保存变化了的部分。更高级的视频压缩格式会更进一步，他们找出帧和帧之间相似的补丁，然后对他们应用简单变换，比如移动、旋转、变亮和变暗，这样就不用重复保存这些相似的补丁，直接对其进行变换就行。MPEG-4视频是常见的标准，可以比原文件小20倍到200倍。但是当压缩太严重时，没有足够空间更新补丁内的像素，就会出现以下问题。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-759970de261a610b53e2e652fc6f572c_720w.jpg" alt="img"></p><center>过度压缩造成的错误</center># 23、屏幕&2D图像显示<p>早期的文本任务通过打印机显示，因为屏幕分辨率较低，无法显示清晰的文字，而将计算结果的文字打印在纸上，有更高的对比度和分辨率，屏幕一般只用于跟踪程序的运行情况，比如寄存器的值，可以节约纸，并且屏幕更新很快，对临时值很匹配。</p><p>最早最有影响力的是<strong>阴极射线管（Cathode Ray Tube，CRT）</strong>，原理是将电子发射到有磷光体涂层的屏幕上，当电子撞击涂层时，会发光几分之一秒。并且因为电子是带电粒子，所以路径可以通过磁场进行控制。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-739424da713eed4b346efb1dc7543358_720w.jpg" alt="img"></p><center>CRT</center>这样就有两种方法来绘制图形：<ol><li>引导电子束描绘出形状，称为<strong>矢量扫描（Vector Scanning）</strong>。因为发光只持续一小会儿，如果重复速度足够快，就能得到清晰的图像。</li><li>第二种方法是按照固定路径，一行行从上到下、从左到右不断重复，只在特定的点打开电子束来绘制图形。这种方法称为<strong>光栅扫描（Raster Scanning）</strong>。用这种方法可以用很多小线段绘制图形，甚至文字。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-ec5217cfd4e2ebb1de1126112a830c20_720w.jpg" alt="img"></p><center>矢量扫描和光栅扫描</center>随着屏幕的发展，我们终于可以在屏幕上显示清晰的点，称为**像素（Pixel）**。**液晶显示器（Liquid Crystal Display，LCD）**也使用光栅扫描，每秒更新多次像素里红绿蓝的颜色。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-818d25d7f9bfa6d121e602a746837223_720w.jpg" alt="img"></p><center>LCD</center>但是早期计算机不使用像素，因为内存中需要保存像素对应的值，使其占用太多内存，所以需要一些特殊技巧来渲染图形，知道内存发展到足够用的地步。<p>所以早期计算机不保存大量像素值，而是直接保存符号，其中80x25个符号是最经典的，若干每个字符用8个字节表示，一共也才16000位。为此，需要特殊的硬件来从内存读取字符，转换成光栅图形，这样才能显示到屏幕上，这个称为<strong>字符生成器（Character Generator）</strong>，基本算是第一代显卡。</p><p>显卡内部有一小块<strong>只读存储器（Read Only Memory，ROM）</strong>存着每个字符的图形，称为<strong>点阵图案（Dot Matrix Patter）</strong>。如果显卡看到某个字符对应的二进制代码，它就会把该字符的点阵图案通过光栅扫描的方式显示在屏幕的适当位置。为了显示，字符生成器会访问内存中一块特殊区域，这块区域专为图形保留，称为<strong>屏幕缓冲区（Screen Buffer）</strong>，程序想显示文字时，就直接修改保存在这个区域的值就行。字符生成器这种方案用的内存很少，但只能画字符到屏幕上，无法绘制任意形状。</p><p>传统的ASCII编码的字符集太小，做不了很复杂的事情，因此对ASCII进行扩展增加更多的新字符，比如用于DOS的IBM CP437字符集，有些系统还会用额外的bit来定义字体颜色和背景颜色。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-9d82eef96cc809355690e396d46873bf_720w.jpg" alt="img"></p><center>IBM CP437字符集</center>为了绘制任意形状，同时不会占用太多内存，就要使用CRT上的**矢量模式**。所有东西都是由一系列线条组成的，完全不需要有文本的概念，如果要显示文字，直接用画线的形式进行显示。我们使用一个早期适量显示系统Vectrex的命令为例<ol><li>首先使用RESET命令来清空屏幕， 同时将电子枪的绘图点移动到坐标(0,0)，也就是屏幕左上角，并将线的亮度设为0。</li><li>调用MOVE_TO 50 50，就会将绘图点移动到坐标(50,50)。然后使用INTENSITY 100将强度设为100， 然后反复调用以上命令就会绘制出对应图形。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-4820ddaa8ce054742f05ea0afbbabab9_720w.jpg" alt="img"></p><p>这些命令也就占160位，比直接保存一个像素矩阵好很多。</p><p>类似于之前的字符生成器把内存里的字符转换成图形一样，这些矢量指令也保存在内存中，通过<strong>矢量图形卡（Vector Graphics Card）</strong>画在屏幕上。然后通过数百个命令按序保存在屏幕缓冲区中，就能绘制出十分复杂的图形。并且因为这些矢量都在内存中，程序就可以更新这些值，让图形随时间进行变化，就出现了动画。</p><p>1962年诞生的Sketchpad是一个巨大的里程碑，它是一个交互式图形界面，用于计算机辅助设计（CAD），它被认为是第一个完整的图形程序。为了与图形界面进行交互，Sketchpad使用了输入设备——<strong>光笔</strong>，就是一个有线连着电脑的触控笔，笔尖用光线传感器，可以检测到显示器的刷新，并且通过判断刷新时间，电脑也可以知道笔所在的位置。使用光笔和各种按钮，用户可以画线和其他各种简单图案。</p><p><u>最早真正使用像素的计算机和显示器出</u>现于1960年代末。内存中的位对应屏幕上的像素，称为<strong>位图显示（Bitmapped Display）</strong>，通过对像素的控制，我们能够完全绘制任意的图形。可以将图形想象成是一个巨大像素值矩阵，之前计算机将像素数据保存在内存中一个特殊区域，称为<strong>帧缓冲区（Frame Buffer）</strong>，但是后来保存在特殊的高速<strong>视频内存（Video RAM，VRAM）</strong>中，这个VRAM是在显卡上，这样访问速度更快。</p><p>在一个分辨率是60x35的8位灰度屏幕上，我们可用的颜色范围是0到255。如果我们想把(10,10)处的像素设为白色，可以使用frambuffer [10] [10]=255， 如果我们想要从(30,0)到(30,35)画一条直线，可以使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FOR y&#x3D;0 TO 35</span><br><span class="line">    framebuffer[30][y]&#x3D;255</span><br><span class="line">NEXT</span><br></pre></td></tr></table></figure><p>使用相同方法，通过修改像素值就可以绘制任意图像。并且程序可以操纵帧缓冲区内的像素数据，来实现交互式图形。</p><h1 id="28、计算机网络"><a href="#28、计算机网络" class="headerlink" title="28、计算机网络"></a>28、计算机网络</h1><p>第一个计算机网络出现在1950-1960年代，通常在公司或研究室内部使用，方便信息交换，称为<strong>球鞋网络（Sneakernet）</strong>，第二个好处在于共享物理资源，比如，与其每台电脑配一台打印机，不如大家共享一台联网的打印机。并且早期网络也会共享存储空间，因为为每台计算机都配存储器太过昂贵。</p><p>计算机近距离构成的小型网络称为<strong>局域网（Local Area Network，LAN）</strong>，局域网能小到是同一间房间内的两台计算机，或者大到校园内的上千台电脑。</p><p>尽管开发和部署了很多不同的LAN技术，其中最著名的是<strong>“以太网（Ethernet）”</strong>，以太网的最简单形式是：一条以太网电线连接数台计算机，当一台计算机要传数据给另一台计算机时它以<strong>电信号</strong>形式，将数据传入电缆中，由于电缆是共享的，所以连接在同一个网络里的其他计算机都能看到数据，但是所有计算机都不知道这些数据是给自己的还是给别人的。<u>为了解决这个问题</u>，以太网需要每台计算机有唯一的<strong>媒体访问控制地址（Media Access Control Address，MAC Address）</strong>，然后将MAC地址作为数据的前缀发送到网络中，所以计算机只需要监听以太网电缆，只要看到自己的MAC地址，才去接收处理数据。现在制造的每台计算机都自带唯一的MAC地址，用于以太网和无线网络。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://pic4.zhimg.com/80/v2-bd0dfa011a483016ac431b355610fefb_720w.jpg" alt="img"></p><center>以太网</center>但是共享载体有个很大的**弊端**：当网络流量比较小时，计算机可以等待载体清空，然后再传输他们的数据。但随着网络流量上升，两台计算机想同时写入数据的概率也会上升，这称为**冲突（Collision）**，就会使得传输的数据混乱。幸好计算机能够监听电线里的信号来检测冲突，最简单的解决方案就是看到冲突就停止传输，等待网络空闲后再试一次，问题是其他计算机也是这样打算的，其他等待的计算机可能在任何停顿间隙就闯入开始传输数据，这就导致了越来越多的冲突。<p>以太网的<strong>解决方法</strong>是：当计算机检测到冲突后，就会在重传之前等待一小段时间（因为要举例，假设是 1 秒好了），当然 如果所有计算机用同样的等待时间 是不行的，它们会在一秒后再次冲突。所以加入一个随机时间 一台计算机可能等1.3秒，另一台计算机等待1.5秒 。要是运气好 等1.3秒的计算机会醒来发现载体是空闲的 然后开始传输 ，当1.5秒的计算机醒来后 会发现载体被占用会等待其他计算机完成 ，来相互避开。当然这个并不能完全解决问题，还需要用到<strong>另一个技巧</strong>。如果一台计算机在传输数据期间检测到冲突，就等待“1秒+随机时间”，但是如果再次发生冲突，就表明有网络拥塞，这次不等1秒，而是等2秒 ，如果再次发生冲突 等4秒 然后8秒 16秒等等，直到成功传输。因为计算机的退避，冲突次数会大幅减少，使得数据能够再次流动起来，网络就变得顺畅了。<u>这种指数级增加等待时间的方法</u>称为<strong>指数退避（Exponential Backoff）</strong>，很多以太网和WiFi都用到这个技术。</p><p>但是即使有了以上的技术，想用一根网线连接整个大学的计算机还是不可能的，为了减少冲突同时提高效率，我们<u>需要减少同一载体中设备的数量</u>，载体和其中的设备总称为<strong>冲突域（Collision Domain）</strong>。以之前以太网为例，一根电缆连接了6台计算机，这个称为一个冲突域。为了减少冲突，我们可以用<strong>交换机（Switch）</strong>将它拆成两个冲突域。交换机位于两个更小的网络之间，在必要时才在两个网络之间传输数据，并且交换机会记录一个<strong>列表</strong>，写着哪个MAC地址位于哪边网络，所以当MAC A想要传数据给MAC C，交换机就不会将数据传到另一边的网络，同理如果MAC E传输数据给MAC F，交换机也不会将数据传到上面的网络，这使得两边的传输能同时进行。但是如果MAC F想传数据给A，数据就会通过交换机，使得两个网络都会被短暂占用。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/v2-059e0333f1ad801bb826f3f89afeb0a7_720w.jpg" alt="img"></p><center>一个以太网中加入一个交换机</center>即使最大型的网络——**互联网（Internet）**也是这样构建起来的，本质还是多个连在一起的稍小一点的网络，使得不同网络间可以传递数据。而大型网络有一个特点，从一台主机到另一台主机通常有多条线路（**解决的主要问题**），这就引出了另一个话题——**路由（Routing）（用来选择合适路线的方法）**。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/v2-618cd9d33b6ca884945143c2d8e3810e_720w.jpg" alt="img"></p><center>大型网络，两台主机之间存在多条线路</center>连接两台相隔遥远的计算机或网络，最简单的方法是分配一条专门的<u>通信线路</u>，早期的电话系统就是这样运作的，这种方法称为**电路交换（Circuit Switching）**，因为是对整个电路进行修改，来连接到正确目的地，所以这种方法不灵活且价格昂贵，并且总有闲置的路线。但是好处是你可以最大限度随意使用，无需共享。因此军队、银行和其他一些机构依然会购买专门线路来连接数据中心。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229164213580.png" alt="image-20200229164213580"></p><center>电路交换</center>传输数据的另一种方法是**报文交换（Message Switching）**，就像邮政系统一样。不像之前A和B之间有一条专有线路，这里消息会经过好几个站点，就类似于邮寄信封，信封会通过一个个中转站最终到达收件人手中，每个站点都知道下一站要发往哪里，因为站点都有自己一个**表格**，用来记录到达各个目的地，信件要如何传递。报文交换的**好处**是你可以用不同的路由，使得通信更可靠。比如如果其中一个城市由于降雪无法接收邮件时，就能换到另一个城市继续传递数据。这里，城市就相当于网络中的路由器一样。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229163941432.png" alt="image-20200229163941432"></p><center>报文交换</center>> 交换机是连接若干个主机的机器，用来解决冲突域问题。 > > 路由器是连接主机、路由器、交换机的机器，用来构建数据传输的线路。<p>信息沿着路由跳转的次数称为<strong>跳数（Hop Count）</strong>，通过记录跳数，可以分辨出路由问题。比如当路由A认为到达目的地最快的下一个路由是B，就将信息传递给路由B，而路由B则认为到达目的地最快的下一个路由是A，又将信息传递回给了路由A，这就使得信息在路由A和B之间踢皮球，但是这种错误可以通过在信息中实时记录的跳数来解决，如果某条信息的跳数很大，就说明路由有出问题，这个称为<strong>跳数限制（Hop Limit）</strong>。</p><p>而报文交换的<strong>缺点</strong>之一就是当报文较大时，会堵塞网络，因为这里要求将<u>整个报文</u>从一个路由传到下一个路由后，才能继续传递其他报文，当传输大报文时，其他报文要么等待它传递完，要么选择另一条效率较低的路线。<u><strong>解决</strong></u>方法就是将大报文分成很多小块，称为<strong>数据包（Packet）</strong>。和报文交换一样，每个数据包都有网络中的目的地址，因此路由器知道要发送到哪里，这个地址的具体格式由<strong>互联网协议（Internet Protocol，IP）</strong>定义。每个联网的计算机都需要一个<strong>IP地址（IP Address）</strong>，例如<code>172.217.7.238</code>。</p><blockquote><p>MAC地址用来标识每条计算机，而IP地址是对数据包而言的。</p></blockquote><p>路由器会平衡与其他路由器之间的负载，来确保传输可以快速可靠，称为<strong>拥塞控制 （Congestion Control）</strong>。有时候一个报文的多个数据包会经过不同线路，使得到达顺序也可能不相同，这对一些软件来说是存在问题的。幸运的是，在IP之上还有其他协议，<u>比如TCP/IP可以解决乱序问题</u>。</p><p>将数据拆分成多个小数据包，然后通过灵活的路由传递，非常高效且容错率高，这种方法称为<strong>分组交换（Packet Switching）</strong>。它的好处是可以去中心化，就没有单点失败问题。</p><p>如今全球的路由器协同工作，找出最高效的线路，用各种标准协议传输数据，比如<strong>因特网控制信息协议（Internet Control Message Protocol，ICMP）</strong>和<strong>边界网关协议（Border Gateway Protocol，BGP）</strong>。</p><p>网络是一堆管子组成的吗？ 额 算是吧。</p><h1 id="29、互联网"><a href="#29、互联网" class="headerlink" title="29、互联网"></a>29、互联网</h1><p>任意计算机都和一个巨大的分布式网络连接在一起，称为<strong>互联网（Internet）</strong>。</p><p>当你在家中通过计算机观看网上视频时，你的计算机首先需要连接到<strong>局域网LAN</strong>，这个局域网是由家里WiFi路由器连接的所有设备组成的。然后家里的局域网再通过路由器连接到<strong>广域网（Wide Area Network，WAN</strong>），广域网的路由器一般属于你的<strong>互联网服务提供商（Internet Service Provider，ISP）</strong>。在广域网里，首先会有一个区域性路由器，比如覆盖你所在街区的一个路由器，然后该路由器会连接到一个更大的广域网中，比如覆盖你所在的城市，可能再跳跃几次，最终会到达互联网主干，一般由一群超大型、带宽超高的路由器组成。</p><blockquote><p>即首先会连接到你家里的WiFi路由器构建的局域网，然后该路由器再连接到ISP提供的广域网中，该广域网是由很多层层递进的路由器构成的。</p></blockquote><p>比如要从YouTube中获得视频，数据包首先会到达互联网主干，沿着主干到达对应保存该视频文件的YouTube服务器，可能这里会跳4次到达互联网主干，然后跳两次穿过互联网主干，最终再跳4次到达YouTube服务器，所以总共会跳跃10次。</p><p>我们可以通过<code>traceroute</code>来看跳跃了几次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Windows上的Traceroute</span><br><span class="line">1.按开始按钮</span><br><span class="line">2.输入“ CMD”，然后按“ Enter”</span><br><span class="line">3.在命令提示符下，键入“ tracert dftba.com”</span><br><span class="line"></span><br><span class="line">在Mac上的Traceroute</span><br><span class="line">1.点击“转到”下拉菜单</span><br><span class="line">2.点击“实用程序”</span><br><span class="line">3.打开终端</span><br><span class="line">4.键入“ traceroute dftba.com”</span><br><span class="line"></span><br><span class="line">Linux上的Traceroute</span><br><span class="line">1.通过键入CTRL + Alt + T打开终端</span><br><span class="line">2.输入：“ traceroute dftba.com”</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229165556176.png" alt="image-20200229165556176"></p><center>通过traceroute查看到dftba.com中转的次数</center>经历了11次中转。<p>但是数据包到底是怎么传递过去的呢？如果传输时数据包丢失了，会发生什么？当我们在浏览器中输入网址时，浏览器怎么知道服务器的地址是什么呢？</p><p>就像上节介绍的，互联网是一个巨大分布式网络，如果要发送的数据较大，分组传输就会将数据拆成一个个较小的数据包进行传输。其中数据包要想在互联网上进行传输，就要符合<strong>互联网协议（Internet Protocol，IP）</strong>。类似于邮寄手写信一般，每封信都需要一个地址，并且地址必须是唯一的，并且信的大小和重量也是有限制的，否则信件就无法送达。IP数据包也是如此，因为IP是一个非常底层的协议，数据包的头部只包含目标地址（IP地址），意味着当数据包到达对方电脑时，计算机不知道要把数据包交给哪个程序（比如QQ或微信），因此需要在IP之上，开发更高级的协议。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229170514722.png" alt="image-20200229170514722"></p><center>数据包的结构</center>最简单常见的协议称为用户数据报协议（User Datagram Protocol，UDP）。UDP也有头部，位于data payload里面，在data之前。UDP头部里面包含了很多有用的信息，其中之一就是**端口号（Port Number）**，每个想访问网络的程序都要向操作系统申请一个端口号。所以当数据包到达时，接收方的操作系统会读取UDP头部里的端口号，来确定该数据包是要交给哪个软件的。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229170831643.png" alt="image-20200229170831643"></p><center>UDP</center>比如 Skype 会申请端口 3478，当一个数据包到达时接收方的操作系统会读 UDP 头部，读里面的端口号如果看到端口号是 3478，就把数据包交给 Skype。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229171417934.png" alt="image-20200229171417934"></p><center>端口号</center>![image-20200229170954885](assets/image-20200229170954885.png)<blockquote><p>IP协议通过IP地址把数据包送到正确的计算机内；UDP通过数据包里的端口号送到正确的程序。</p></blockquote><p>同时UDP的头部中还有<strong>校验和（Checksum）</strong>，通过对数据求和来检查数据是否正确。假设UDP数据包里原始数据是<code>89 111 33 32 58 41</code>， 最简单的计算校验和的方式就是，在发送数据包之前，计算机会把所有数据加在一起，计算出校验和364。在UDP中，校验和是以16位形式存储的，如果计算出来的和超过16位能表示的最大值，则高位数会被丢弃，只保留低位。当接收方计算机接收到这个数据包时，也会重复以上过程，如果计算出来的校验和和UDP中保存的校验和相同，代表数据是正常的，否则数据是出错的。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/v2-9211cf69881af0f8ba2e4a8e8b5ce8ee_720w.jpg" alt="img"></p><p>但是，UDP不提供数据修复或数据重发机制，当接收方知道数据损坏后，一般只是丢弃这个数据包。并且当发送方使用UDP协议发送数据包时，是无法得知数据包是否到达目的地的。有些程序并不在意以上问题，因为UDP十分简单且快速。比如<u>视频</u>通常使用UDP协议，当数据包丢失时，也就造成视频卡顿。</p><p>但是有些数据不能接受数据包丢失的问题，比如发送电子邮件时，所有数据必须到达，所以就需要<strong>传输控制协议（Transmission Control Protocol，TCP）</strong>。和UDP一样，它的头部也保存在数据之前，人们通常将<u>IP协议和TCP协议</u>统称为<strong>TCP/IP协议</strong>。TCP的头部中也包含端口号和校验和，并且TCP协议还提供更高级的功能：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/v2-969988861bec7064179dd4e99b60dbf8_720w.png" alt="img"></p><center>TCP</center>1. TCP的数据包是<u>有序号</u>的，使得接收方可以通过这个序号将数据包排成正确顺序，即使到达时间不同。 2. TCP要求接收方的电脑收到数据包并校验和检查无误后，需要给发送方发送一个**确认码（Acknowledgement，ACK）**，代表数据包已经正确接收。当发送方接收到确认码后，就知道上一个数据包成功抵达了，发送方就会发送下一个数据包，如果这次发送方过了一段时间没有接收到确认码，则会重新发送一次。即使这里只是由于确认码延迟了，使得接收方那里有重复的数据包，但是通过序列号，可以直接删除重复的数据包。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229171954069.png" alt="image-20200229171954069"></p><p>并且数据包并不会一个个数据包进行传输，而是<strong>同时发送多个数据包</strong>，同时接收多个<strong>确认码(ACK)</strong>，这将大大提高效率，不用浪费时间等待确认码。并且通过确认码的成功率和来回时间，我们可以推测网络的拥塞程度，TCP通过这个信息，来调整同时发包数量来解决拥塞问题。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/v2-061760eadb27bb199a2a917547852efc_720w.jpg" alt="img"></p><p>简而言之，TCP可以处理乱序和丢包问题，并且可以根据拥塞情况自动调整传输率。</p><p>但是由于确认码数据包的存在，使得TCP需要传输的数据包数量翻了一倍，并且并没有传输更多信息，这对时间要求很高的程序代价太高，所以这类程序就会使用UDP协议（比如射击类游戏）。</p><p>当计算机访问一个网站时，需要两个东西<code>：IP地址（目标网站的地址）</code>和 <code>端口号（对应于你使用的计算机浏览器）</code>（例如：例如 <code>172.217.7.238 的 80 端口</code> 这是谷歌的 IP 地址和端口号）。但是通过IP地址访问网站十分不方便，所以互联网提供一个特殊服务，来将<strong>域名（Domain Name）</strong>和IP地址一一对应，称为<strong>域名系统（Dimain Name System，DNS）</strong>，一般DNS服务器都是由ISP提供的。当你在浏览器中输入网站域名时，浏览器就会去访问DNS服务器，DNS就会去查表，如果域名存在，则会返回浏览器对应IP地址，然后浏览器就会给这个IP地址发送TCP请求。</p><p>因为当前域名特别多，所以DNS不会将其保存成列表形式，而是将其保存成树状结构。最顶层是<strong>顶级域名（Top Level Domain，TLD）</strong>，比如<code>.com</code>和<code>.gov</code>；下一层是<strong>二级域名（Second Level Domain）</strong>， 比如<code>google.com</code>和<code>dftba.com</code>；再下一层是<strong>子域名（Sub-domain）</strong>，比如<code>images.google.com</code>等等。由于这个树结构特别大，因此这些数据分布在很多DNS服务器上，不同服务器负责树的不同部分。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229172611126.png" alt="image-20200229172611126"></p><center>域结构<center><p>总结上两节（28、29）的内容，其实计算机网络分成很多层次，接下来从最底层到最高层：</p><ol><li><strong>物理层（Physical Layer）</strong>，比如线路中的电信号，以及无线网络中的无线信号。</li><li><strong>数据链路层（Data Link Layer）</strong>负责操控物理层，其中包含MAC地址、冲突检测、指数回退以及其他一些底层协议。</li><li><strong>网络层（Network Layer）</strong>负责各种报文交换和路由技术。</li><li><strong>传输层（Transport Layer）</strong>负责在计算机之间进行点到点的传输，还会检测和修复错误，比如UDP和TCP协议。</li><li><strong>会话层（Session Layer）</strong>会使用TCP和UDP来创建连接，传递信息，然后关掉连接。</li></ol><p>以上是<strong>开放式系统互联通信参考模型（Open System Interconnection model，OSI）</strong>下的5层，这个框架将网络通信划分成了很多层，每一层处理各自的问题。这种抽象可以使得分工改进多个层，而无需考虑整体复杂性。并且OSI还有额外两层：<strong>表示层（Presentation Layer）</strong>和<strong>应用层（Application Layer）</strong>，在下一节中进行介绍。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229172753982.png" alt="image-20200229172753982"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229172822261.png" alt="image-20200229172822261"></p><h1 id="30、万维网"><a href="#30、万维网" class="headerlink" title="30、万维网"></a>30、万维网</h1><p>前两节介绍的东西共同组成了互联网，这一节将向上抽象一层，来讨论<strong>万维网（World Wide Web）</strong>。万维网和互联网的概念完全不同，万维网是运行于互联网之上的，还有其他比如Skype、Instagram等也是运行在互联网之上的。<strong>互联网是用来传输数据的管道</strong>，各种程序都会使用到，<u>其中传输最多数据的程序就是万维网</u>，我们可以使用特殊的程序——<strong>浏览器（Web Browser）</strong>来访问万维网。</p><p>万维网的最基本单位是单个页面，里面包含内容，也有访问其他页面的链接，这些链接称为<strong>超链接（Hyperlink）</strong>。这些超链接形成巨大的互联网络，这也是万维网名字的由来。并且由于文字超链接的强大，它有一个特殊的名字——<strong>超文本（Hypertext）</strong>。如今超文本最常指向的是另一个页面，这些页面会被获取并由浏览器进行渲染。</p><p>为了使网页能够互相连接，每个网页需要一个唯一的地址，这个地址称为<strong>统一资源定位器（Uniform Resource Locator，URL）</strong>，比如<code>thecrashcourse.com/courses</code>就是一个页面URL。</p><p>当你访问<code>thecrashcourse.com</code>网址时，计算机首先会进行DNS查询，这里输入一个域名，然后DNS就会返回给浏览器对应的计算机IP地址。然后浏览器就会打开一个TCP连接到这个IP地址对应的计算机上，而这个计算机运行着一个特殊的软件——<strong>网络服务器（Web Server）</strong>，网络服务器的标准端口是80。此时，你的计算机就连接到了<code>thecrashcourse.com</code>对应的服务器了，下一步是向服务器请求<code>courses</code> 页面，这里就会用到<strong>超文本传输协议（Hypertext Transfer Protocol，HTTP）</strong>。</p><p>HTTP的第一个标准是1991年创建的HTTP 0.9，只有一个指令<code>GET</code> 。因为这里我们想要获取<code>courses</code>页面， 我们可以直接向服务器发送指令<code>GET/courses</code>， 该指令以ASCII编码发送到服务器，服务器会返回该网址对应的页面，然后浏览器就会将其渲染到屏幕上。如果用户点击了另一个链接，计算机就会重新发送一个GET请求。在之后的版本中，HTTP添加了新的状态码，会将其放在请求页面的前面，比如状态码200表示网页被正确找到了，状态码400-499代表客户端出错。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/v2-5c297a37758affab1974f221b51a678d_720w.jpg" alt="img"></p><p>因为超文本的存储和发送都是以普通文本形式进行的，编码可能是ASCII或者UTF-8，这样就无法表明什么是链接，什么只是普通的文本了，所以必须开发一种标记方法，因此出现了<strong>超文本标记语言（Hypertext Markup Language，HTML）</strong>，第一代HTML创建于1990年的0.8版本，有18种指令。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/v2-d1f17935f645f06fc006ff22a4d68d4b_720w.jpg" alt="img"></p><center>制作一个简单的网页</center>综上，网络浏览器可以和网络服务器沟通，不仅获取网页和媒体，并且还负责显示。<p>随着后期万维网日益繁荣，人们越来越需要搜索。起初人们会维护一个目录，来链接到其他网站，但是随着网络越来越大，人工编辑目录变得很不方便，所以开发了搜索引擎。</p><p>最早的搜索引擎是JumpStation，它有3个部分：</p><ol><li><p>通过爬虫来将新链接添加进自己的列表中。</p></li><li><p>不断扩张的索引，用来记录访问过的网页上出现了哪些词。</p></li><li><p>查询索引的搜索算法，比如输入了某个关键字，则包含这个关键字的网页就会显示出来。</p></li></ol><p>早期的搜索引擎的排名方式直接取决于搜索词在页面上的出现次数，但是有的网页会通过在页面中重复该关键字来提高排名。Google成名的很大原因就是提出了一种算法来解决这个问题，与其信任页面上的内容，搜索引擎会看其他网页有没有连接到这个网页。</p><p>最后提一个概念——<strong>网络中立性（Network Neutrality）</strong>，它指的是要对所有数据包都平等对待，速度和优先级都应该一样。</p><h1 id="31、计算机安全"><a href="#31、计算机安全" class="headerlink" title="31、计算机安全"></a>31、计算机安全</h1><p>计算机安全的范围和计算能力的发展速度一样快，我们可以把计算机安全，看成是保护系统和数据的<strong>保密性、完整性和可用性</strong>。</p><blockquote><p><strong>保密性（Secrecy）：</strong>只有有权限的人才能<strong>读取</strong>计算机系统和数据，比如黑客泄露别人的信用卡信息，就是攻击保密性。</p><p><strong>完整性（Integrity）：</strong>只有有权限的人才能<strong>使用和修改</strong>系统和数据，比如黑客假冒你发送邮件，就是攻击完整性。</p><p><strong>可用性（Availability）：</strong>有权限的人应该随时可以访问系统和数据，<strong>拒绝服务攻击（DDOS</strong>）就是黑客发送大量的假请求到服务器上，使得网站很慢或者直接挂掉，这就是攻击可用性。</p></blockquote><p>为了实现这三个目标，安全专家会从抽象层面想想敌人可能是谁，这个称为<strong>威胁模型分析（Threat Model）</strong>。模型会对攻击者有个大致的描述：能力如何、目标是什么、可能使用什么手段。攻击手段又称为<strong>攻击矢量（Attack Vector）</strong>。威胁模型分析能够让你为特定情境做好准备，不被可能的攻击手段所淹没。换句话说，要怎么保护，具体看要对抗谁。</p><p>通常威胁模型分析中，会以能力水平进行区分。在给定的威胁模型下，安全架构师要提供解决方案，来保持系统安全。</p><p>有很多保护计算机系统、网络和数据的方法。很多安全问题可以总结成<strong>两个问题</strong>：</p><ol><li>你是谁？</li><li>你能访问什么？</li></ol><p>权限应该给适合的人而拒绝错误的人，所以为了区分谁是谁，我们使用<strong>身份认证（Authentication）</strong>来让计算机得知使用者是谁。通常身份认证有三种，各有利弊：</p><ol><li><strong>你知道什么：</strong>这个是基于某种只有用户和计算机知道的秘密，比如用户名和密码。这是如今使用最广最容易实现的方法。但是如果黑客知道了你的密码就惨了，或者可以通过暴力攻击试了密码的所有可能来获取你的密码，有些系统会在你尝试若干次错误后阻止你继续尝试。即使增长密码也很容易破解，所以现在很多网站都要求大小写字母加特殊字符，来增加可能的密码。</li><li><strong>你有什么：</strong>这是基于用户特定的物体，比如钥匙和锁。这种方法可以避免被人猜中密码的问题，而且通常需要人在现场，所以远程攻击就更加困难了。</li><li><strong>你是什么：</strong>这是基于你，通过你自己的特征展示给计算机来进行验证，比如指纹识别器和红膜扫描仪，这些方法特别的安全，但是最好的识别技术十分昂贵。“你知道什么”和“你有什么”是确定性的，但是来自传感器的数据每次都不相同，所以“你是什么”是概率性的，系统可能认不出你，或者将其他人认成了你。并且这种方法另一个问题就是无法重设，你无法修改自己的指纹或者虹膜。</li></ol><p>每种方法都有优缺点，一般建议使用两种或两种以上的认证方式。</p><p>当系统知道了你是谁，接下来就需要知道你能访问什么，这个称为<strong>访问控制（Access Control）</strong>，因此需要一个规范，来说明谁能访问什么、修改什么和使用什么。这个可以通过<strong>权限（Permission）</strong>或<strong>访问控制列表（Access Control List，ACL）</strong>来实现，其中描述了用户对每个文件、文件夹和程序的访问权限。</p><blockquote><p>读权限：允许用户查看文件内容。</p><p>写权限：允许用户修改文件内容。</p><p>执行权限：运行用户运行文件。</p></blockquote><p>有些阻止需要不同层次的权限，则ACL的正确配置就十分重要。假设我们有三个访问级别：<strong>公开、机密和顶级机密</strong>。有个经典模型称为<strong>Bell-LaPadula模型</strong>，其中包含两条规则：</p><ol><li>用户不能<strong>read up</strong>，即不能读等级更高的信息。</li><li>用户不能<strong>write down</strong>，即用户不能写更低权限的信息，这样能避免高级别的信息不会泄漏到低级别的文件中。</li></ol><p>通过身份认证和权限控制，可以让计算机知道你是谁和你能访问什么，但是必须先保证做这些事的软硬件必须是可信的。但是仍然无法保证程序或计算机系统的安全，因为安全软件在理论上可能是安全的，但是实现时可能会不小心留下漏洞。但是我们有办法减少漏洞出现的可能性，比如一发现漏洞就马上修补。</p><p>大部分漏洞都是具体实现时出错了，所以为了减少执行错误，就要减少执行。系统级安全的圣杯之一是安全内核或可信计算机基础：一组尽可能少的操作系统软件，这个安全性是接近可验证的。</p><p>构建安全内核的挑战在于，要决定内核应该有什么（代码越少越好）。当最小化代码数量后，要是能保证代码是安全的，那就很好了。现在最好的验证代码安全性的手段是<strong>独立安全监察和质量验证（Independent Verification and Validation）</strong>，让一群安全行业内的软件开发者来审计代码，这也是为什么安全型代码几乎都是开源的。</p><p>但是即使这样，还是有可能被黑客攻破，因此程序开发者需要控制损失的最大程度，这个称为<strong>隔离（Ioslation）</strong>。要实现隔离，可以<strong>“沙盒”（sandbox）</strong>程序，操作系统通过给每个程序独立的内存块，使得别的程序是无法触及的，这样就能把程序放到沙盒中，即使沙盒被破坏了，也不会影响别的程序执行。并且一台计算机可以运行多个<strong>虚拟机（Virtual Machine）</strong>，使得每个虚拟机都在自己的沙盒中。</p><h1 id="32、黑客-amp-攻击"><a href="#32、黑客-amp-攻击" class="headerlink" title="32、黑客&amp;攻击"></a>32、黑客&amp;攻击</h1><p>黑客入侵最常见的方式不是通过技术，而是欺骗别人，这个称为<strong>社会工程学（Social Engineering）</strong>，通过欺骗别人来让人泄露秘密，或让人配置电脑系统来变得易于攻击。最常见的攻击是<strong>网络钓鱼（Phishing）</strong>，其次还有<strong>假托（Pretexting）</strong>，攻击者给某个公司打电话，假装是IT部门的人，攻击者的第一通电话一般会叫人转接，这样另一个接的时候，电话看起来就像内部的，然后让别人把电脑配置得易于入侵，或者让他们泄露机密信息，比如密码或网络配置。</p><p>邮件里带<strong>木马（trojan horse）</strong>也是常见手段，木马通常会伪装成无害的东西，比如照片或发票，但实际上是恶意软件，有的会偷数据，有的会加密文件。</p><p>如果攻击者无法用木马或电话欺骗，攻击者只能被迫使用其他手段，方法之一就是暴力破解，尝试所有可能的密码，直到进入系统，大多数现代系统会加长等待时间来抵御这种攻击，每次失败就加长等待时间，甚至超过一定次数后，完全封锁。现在出现了一种攻破方法称为<strong>NAND镜像</strong>，如果能物理接触到电脑，可以往内存上接几根线，复制整个内存，然后暴力尝试密码，直到设备让你等待。这时只要把复制的内容覆盖掉内存，本质上重置了内存，就不用等待，可以继续尝试密码。</p><p>如果无法物理接触到设备，就需要远程攻击，比如通过互联网，这一般需要攻击者利用系统漏洞，来获得某些能力或访问权限，称为<strong>漏洞利用（Exploit）</strong>。一种常见的漏洞利用叫<strong>缓冲区溢出（Buffer Overflow）</strong>，这里的缓冲区是指预留的一块内存空间，比如我们在系统登录界面输入用户名和密码，而系统是用缓冲区来存储输入值的，假设缓冲区大小为10，并且缓冲区前后肯定还有其他数据，当用户输入用户名和密码时，这些值就会被复制到缓冲区中来进行验证，而该方法会溢出缓冲区，比如输入超过10个字符的密码，会覆盖掉相邻的数据，有时会让程序或系统崩溃，因为重要值被垃圾数据覆盖掉了。这里只是让系统崩溃，但是攻击者可以输入有意义的新值到程序的内存中，比如把<code>is_admin</code>标志位的值改为true，有了任意修改内存的能力，黑客就可以绕过登录这类东西，甚至使用那个程序劫持整个系统。</p><p>有许多方法阻止缓冲区溢出，最简单的方法就是复制到内存之前先检查长度，称为<strong>边界检查（Bounds checking</strong>），许多现代编程语言都自带边界检查，程序也会随机存放变量在内存中的位置，这样黑客就不知道应该覆盖内存的哪部分，使得更容易让程序崩溃，而不是获得访问权限。程序也可以在缓冲区后，预留一些不用的空间，然后跟踪里面的值，看是否发生变化，来判断是否有攻击，这些不用的内存空间称为<strong>金丝雀（Canaries）</strong>。</p><p>另一种经典手段是<strong>代码注入（Code Injection）</strong>，最常用于攻击用数据库的网站。假设网页上有登录提示，当用户点击“登录”，输入文本就会发送服务器，服务器就会运行代码，检查用户名是否存在，如果存在就看密码是否匹配。为此服务器会执行一段sql查询代码，比如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">password</span> <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> username=<span class="string">'___'</span>;</span><br></pre></td></tr></table></figure><p>这里语句就是要从<code>users</code>表中查找<code>username</code>为<code>___</code>的密码<code>password</code>。 这里的<code>___</code>就是用户输入的用户名。由此攻击者就能把sql命令输入到用户名中，比如<code>whatever&#39;;DROP TABLE users;&#39;</code>，这时上面的查询语句就会变成</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">password</span> <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> username=<span class="string">'whatever'</span>;<span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">users</span>;';</span><br></pre></td></tr></table></figure><p>如果服务器存在用户名<code>wharever</code>，数据库就会返回密码， 当然我们无法得知密码是什么，所以服务器会拒绝我们；如果不存在用户名<code>wharever</code>，服务器会返回空密码或者直接错误，服务器也会拒绝我们。 但是我们关心的是后面的代码<code>DROP TABLE users;</code><strong>这个是我们注入的命令</strong>，这个命令是删掉users这张表。如今几乎所有服务器都会防御这种手段。</p><p>程序员需要认识到从外界输入的信息都是危险的，必须要好好检查，很多用户名和密码表单，不会让你直接输入特殊符号，比如分号或括号，来作为第一道防御。好的服务器也会清理输入，比如修改或删除特殊字符，然后才放到数据库查询语句中。</p><p>当软件制造者不知道的新漏洞被发现时，称为<strong>0day漏洞（Zero Day Vulnerability）</strong>，黑客就会抢在白帽程序员做出补丁之前尽可能利用漏洞。</p><p>如果有足够多的电脑有漏洞，让恶意程序可以自动地在电脑之间互相传播，称为<strong>蠕虫（Worm）</strong>。如果黑客拿下大量电脑，这些电脑可以组成<strong>僵尸网络（Botnet）</strong>，可以用于很多目的，比如发大量垃圾邮件等，用别人电脑的计算能力来挖比特币，或发起DDOS来攻击服务器。DDOS就是僵尸网络里的所有电脑发一大堆垃圾信息到服务器上，造成服务器的阻塞。</p></center></center>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《计算机科学速成课》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnCpp chapter3</title>
      <link href="/archives/5fc07ec4.html"/>
      <url>/archives/5fc07ec4.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red>LearnCpp-chapter3</red></p></center><center><red>https://www.learncpp.com</red></center><p>未完待续~~</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnCpp chapter4</title>
      <link href="/archives/c1a4eb67.html"/>
      <url>/archives/c1a4eb67.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapter4</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h2 id="4-1-基本的数据类型"><a href="#4-1-基本的数据类型" class="headerlink" title="4.1 基本的数据类型"></a>4.1 基本的数据类型</h2><ul><li><p>内存最小的单位是一个<strong>二进制数(binary digit)</strong>，即<strong>位(bit)</strong>。它可以存储一个0或者1。</p><blockquote><p>就像传统的电灯开关一样——灯开着(1)，灯关着(0)</p></blockquote></li><li><p>由连续的单元组成的内存，叫<strong>内存地址(memory addresses)</strong>，简称<strong>地址(addresses)</strong></p></li><li><p>现代计算机中，“位”是没有它自己的内存地址的。而是用一个“<strong>字节(byte)</strong>”来表示一个内存地址。</p><blockquote><p>因为内存地址是比较有限的，而且需要逐“位”访问数据的情况很少。</p><p><strong>字节</strong>是作为一个单位来操作的一组”位(bit)”。现代标准规定：一个字节由<strong>8个</strong>连续的<strong>位</strong>组成。</p></blockquote><p>下面的图片显示了一些连续的内存地址，以及相应的数据字节:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/MemoryAddresses.png" alt="MemoryAddresses"></p></li><li><p><strong>数据类型(Data types)</strong>，简称“<strong>类型(type)</strong>”</p><ul><li><p>我们使用<strong>数据类型</strong>来告诉编译器如何以某种有意义的方式解释内存的内容。</p><blockquote><p>如：当我们声明一个变量的类型为 整型(integer)时，就相当于告诉内存“<strong>这个变量使用的内存段将被解释为一个整数值</strong>”</p></blockquote></li><li><p>给对象(object)一个值(value)时，编译器和CPU就负责将您的值 编码(encode)为该数据类型的适当的位序列，并存储在内存中。<u>【记住：内存只存储<strong>位(bits)</strong>】</u></p><blockquote><p>如：给一个整型对象赋一个值,65。这个值就被转换为bits：<code>0100 0001</code>，并被存储在分配给对象的内存中。</p></blockquote></li><li><p>当这个对象被求值，产生一个值时，这个 位序列(sequence of bits) 被重新构造成原来的值。</p><blockquote><p>意思就是：<code>0100 0001</code>被转换回 值65.</p><p>幸运的是，这些转换工作都是由 编译器 和 CPU 来完成的。</p></blockquote></li></ul></li><li><p><strong>基本数据类型(fundamental data types)</strong>，但通常被非正式地称为<strong>基本类型(basic types)</strong>、<strong>基本类型(primitive types)</strong>或<strong>内置类型(built-in types)</strong>。</p><p>下面是一些基本数据类型：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200330175227962.png" alt="fundamental data types"></p><blockquote><p>1、注意：<strong>integer vs integral</strong>：<em>integral</em>即比<em>integer</em>范围更广</p><ul><li><strong>integer：表示整数，即正整数、负整数、0；</strong></li><li><strong>integral：包含了 integer、boolean(布尔型)、字符类型</strong>。</li></ul><p>他们两个名字比较相近，是因为：<u>integral类型在内存中存储形式是和integer一样</u>。</p><hr><p>2、 <strong><code>_t</code>后缀</strong></p><p>这个后缀，表示“类型”的意思。</p></blockquote></li></ul><h2 id="4-2-Void"><a href="#4-2-Void" class="headerlink" title="4.2 Void"></a>4.2 Void</h2><ul><li><p>void是最简单的类型，<strong>void</strong>，即“没有类型”</p></li><li><p>变量不能定义为void类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> value; <span class="comment">// won't work, variables can't be defined with a void type</span></span><br></pre></td></tr></table></figure></li><li><p>void用途：</p><ol><li><p><strong>Functions that do not return a value（函数不返回值）</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeValue</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">// void here means no return value</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The value of x is: "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="comment">// no return statement, because this function doesn't return a value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Functions that do not take parameters(函数中不带参数)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">void</span>)</span> <span class="comment">// void here means no parameters</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者这种形式【在C++中，推荐写这种形式】</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="comment">// empty function parameters is an implicit void</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="4-3-对象大小-amp-sizeof操作符"><a href="#4-3-对象大小-amp-sizeof操作符" class="headerlink" title="4.3 对象大小&amp;sizeof操作符"></a>4.3 对象大小&amp;sizeof操作符</h2><p><strong>对象的大小</strong>：</p><ul><li><p>对象的大小取决于它的数据类型</p></li><li><p>通常通过<strong>变量名访问内存</strong>，<strong>而不是直接通过内存地址</strong>。</p></li><li><p>1个bit(位)可以容纳2个可能的值，0或1；…….</p><blockquote><p><strong>即，具有n位(bits)的对象，可以容纳2^n 个可能的值。</strong></p></blockquote><p>因此，对象的大小限制了它可以存储的唯一值的个数。</p></li><li><p>每次定义一个对象时，<strong>只要该对象存在，就会使用一小部分空闲内存</strong>。</p></li></ul><p><strong>基本数据类型的大小</strong>：</p><ul><li><p>给定数据类型的大小<strong>取决于编译器 和/或 计算机体系结构!</strong></p><p>C++只保证每个基本数据类型的大小都是最小的：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200331095627896.png" alt="image-20200331095627896"></p><blockquote><p><strong>然而，这些类型的大小在不同的计算机上可能会不一样。</strong>比如，有些机器上的int大小为4 bytes</p></blockquote></li></ul><p><strong>操作符“sizeof”</strong></p><p>为了能够在计算机上直到类型的大小，C++提供了<strong>“sizeof”</strong>操作符来确认类型的大小。</p><blockquote><p><strong>sizeof：是一个一元操作符，它接受 类型 或 变量，然后返回它的大小(bytes)</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"bool:\t\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">bool</span>) &lt;&lt; <span class="string">"bytes\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"char:\t\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">char</span>) &lt;&lt; <span class="string">"bytes\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"wchar_t:\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">wchar_t</span>) &lt;&lt; <span class="string">"bytes\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"char16_t:\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">char16_t</span>) &lt;&lt; <span class="string">" bytes\n"</span>; <span class="comment">// C++11 only</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"char32_t:\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">char32_t</span>) &lt;&lt; <span class="string">" bytes\n"</span>; <span class="comment">// C++11 only</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"short:\t\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(short) &lt;&lt; <span class="string">" bytes\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"int:\t\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="string">" bytes\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"long:\t\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span>) &lt;&lt; <span class="string">" bytes\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"long long:\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>) &lt;&lt; <span class="string">" bytes\n"</span>; <span class="comment">// C++11 only</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"float:\t\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">float</span>) &lt;&lt; <span class="string">" bytes\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"double:\t\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">double</span>) &lt;&lt; <span class="string">" bytes\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"long double:\t"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">double</span>) &lt;&lt; <span class="string">" bytes\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//避免在visual studio 中运行时 闪过</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>运行结果会因为不同类型的机器or编译器，而出现差异。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200331101214364.png" alt="image-20200331101214364"></p><h2 id="4-4-有符号整型"><a href="#4-4-有符号整型" class="headerlink" title="4.4 有符号整型"></a>4.4 有符号整型</h2><ul><li>C++中有四种整型的类型：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200331101704637.png" alt="image-20200331101704637"></p><ul><li><p><strong>Signed integers(有符号整型)</strong></p><p>如：+1、-1、0这种都属于 有符号整型。</p><ul><li><p><strong>定义有符号整型：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【推荐】</span></span><br><span class="line">short s;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">long</span> i;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//除了int，其它类型也可以这样写：</span></span><br><span class="line">short <span class="keyword">int</span> s;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">long</span> liong i;</span><br><span class="line"><span class="comment">//这种【不推荐】，使用“int”后缀不利于观看</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以使用 signed前缀</span></span><br><span class="line"><span class="keyword">signed</span> shrt s;</span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">long</span> i;</span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">long</span> <span class="keyword">long</span> i;</span><br><span class="line"><span class="comment">//【不推荐】，因为signed冗余，不利于辨认</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>有符号整型的范围</strong></p><p>数据类型可以容纳的一组特定值，叫做：<strong>range(范围)</strong></p><blockquote><p>整型变量的“<strong>范围</strong>”的决定因素：</p><ol><li>该类型本身的大小；</li><li>该类型是否是 有符号 的。</li></ol><p>比如，大小为1字节的有符号整型，它的范围是：-128~127(包含范围的两端)，即它可以存储2^8=256 个可能的整数。</p></blockquote></li></ul><p>这是一个包含不同大小有符号整数范围的表:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200331104055635.png" alt="image-20200331104055635"></p><blockquote><p>小结，一个有 <strong>n</strong>-bits的 有符号变量，它可存储值的范围是：<strong>-(2^n-1^) ~ (2^n-1^ -1)</strong></p></blockquote><ul><li><p><strong>整数溢出</strong>，简称：<strong>溢出</strong></p><p>如果我们把值280,存储在 1个字节的有符号整型 中，他就会发生 <strong>溢出</strong>现象。此时，<strong>数据丢失是因为对象没有足够的内存来存储所有东西。</strong></p></li></ul><h2 id="4-5-无符号整型"><a href="#4-5-无符号整型" class="headerlink" title="4.5 无符号整型"></a>4.5 无符号整型</h2><center>不推荐使用</center><p><strong>无符号整型：unsigned integer。</strong>不能存储“负数”，<strong>可以存储：0 和 正整数</strong></p><ul><li><p><strong>定义无符号整型变量</strong></p><p>要定义无符号整数，我们使用<strong>unsigned</strong>关键字。按照惯例，这是放在前面的类型:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> short us;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ui;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> ul;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br></pre></td></tr></table></figure></li><li><p><strong>无符号整型范围</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200331105315653.png" alt="Unsigned integer range"></p><blockquote><p>一个有 n-bits 的无符号整型变量，它可存储的范围是：<strong>0 ~ (2^n^)-1</strong></p></blockquote><p>当不需要负数时，无符号整数非常适合于网络和内存很少的系统，<strong>因为无符号整数可以存储更多的正数而不占用额外的内存。</strong></p></li></ul><ul><li><p><strong>无符号整数的溢出：Unsigned integer overflow</strong></p><p>无符号整数不会溢出。<em>如果一个值超过范围，那么它会除以一个比这个范围大的数，然后将余数存起来。</em></p><ul><li><p><strong>正数溢出</strong></p><blockquote><p>如，在 1byte的范围中，存储数据。</p><ul><li>280在 范围为 1个字节 的整型中存储，因280&gt;255。所以，它会除以256(比 1个字节的范围的最大值大1，即比255大1的数，256)。280/256=24，<strong>所以存储的是24</strong>.</li><li>存储256。256&gt;255。则进行 256/256 = 0，<strong>即相当于存储 0</strong></li><li>存储257。257&gt;255。则进行 257/256 = 1，<strong>即相当于存储 1</strong></li></ul></blockquote><p>看一个程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> short x&#123; <span class="number">65535</span> &#125;; <span class="comment">// 最大的16位无符号值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x was: "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    x = <span class="number">65536</span>; <span class="comment">// 65536 is out of our range, so we get wrap-around</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x is now: "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    x = <span class="number">65537</span>; <span class="comment">// 65537 is out of our range, so we get wrap-around</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x is now: "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200331131152778.png" alt="image-20200331131152778"></p><hr></li></ul></li></ul><ul><li><p><strong>负数溢出</strong></p><p>虽然，无符号整数的范围是0~255(假如在 1byte的范围).但是我们不小心在无符号整型中输入了 负数，应该怎么办呢？</p><p>比如，当输入 -1 时。-1不在 0~255这个范围中。此时就循环到这个范围的顶部（最大值处），即 255。所以，在 1 byte 的范围的无符号整数中，<strong>输入 -1 ，存储的是 255。</strong></p><p><strong>输入-2，存储的是254。（从最顶部往回循环）</strong></p></li></ul><h2 id="4-6-固定宽度的整数和size-t"><a href="#4-6-固定宽度的整数和size-t" class="headerlink" title="4.6 固定宽度的整数和size_t"></a>4.6 固定宽度的整数和size_t</h2><p>之前讲了整型变量的最低size，其实他们可以按照不同的系统变得更大。</p><ul><li><p>为什么不固定整型变量的大小？</p><p>因为在C语言中，为了提高性能，C故意保持整数的大小是开放的，这样编译器实现者就可以为 int 选择一个在目标计算机架构上表现最好的大小。</p></li><li><p><strong>固定宽度的整型</strong></p><p>为了实现跨平台，C99定义了一系列的<strong>固定宽度的整型</strong>(在头文件<code>stdint.h</code>中)，使得在任何平台中的大小都一致。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200331142942242.png" alt="Fixed-width integers"></p><blockquote><p><strong>在C++11中的头文件<code>cstdint</code>中，也包含了上述的固定宽度整型。他们在命名空间<code>std</code>中定义的。</strong></p><p>如;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="keyword">int16_t</span> <span class="title">i</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>应该避免上述固定宽度的整数，因为它们可能不是在所有目标体系结构上定义的。</p></li></ul><hr><ul><li><p><strong>fast &amp; least 整型</strong>：快类型 &amp; 小类型</p><p>为了帮助解决上述缺点，c++ 11还定义了两个可选的整数集。</p><ol><li><p>*<em>fast type *</em></p><p><strong>无符号</strong>格式为： std::<strong>int_fast#_t</strong> ；<strong>有符号</strong>格式：std::<strong>uint_fast#_t</strong></p><p>它提供一个整型，它提供一个在你的机器上<u>表现得性能最好的宽度</u>，但是它的宽度最小是“# <strong>bits</strong>”（# = 8，16，32，or 64 <strong>bit</strong>）</p><blockquote><p>如：<code>std::int_fast32_t</code>将会给你一个最小为 32bits 的无符号整型</p></blockquote></li><li><p><strong>least type</strong></p><p><strong>无符号</strong>格式为： std::<strong>int_least#_t</strong> ；<strong>有符号</strong>格式：std::<strong>uint_least#_t</strong></p><p>它提供一个整型类型，它提供一个<u>最接近于</u>“# <strong>bits</strong>”的宽度，但是它的宽度最小是“# <strong>bits</strong>”（# = 8，16，32，or 64 <strong>bit</strong>）</p></li></ol><blockquote><p>小结：<strong><u>比较：<code>int#\_t</code>、<code>int_fast#_t</code>、<code>int_least#_t</code>的差异</u></strong>：</p><ul><li><code>int#_t</code>的bits(位数)是固定的，即有“# bits”；</li><li><code>int_fast#_t</code> 和 <code>int_least#_t</code>的bits(位数)最少有““# bits”；</li></ul><p>example：</p><p><code>int16_t</code>：是固定的16位的整型；</p><p><code>int_fast16_t</code>：可能转变成了64位的整型。（因为在你的机器上，64位整型最快了）</p><p><code>int_least16_t</code>：可能转变成了32位的整型。（假设因为你的系统中没有16位的整型，而32位此时<strong>是最接近</strong>16位 的整型了）</p></blockquote></li></ul><hr><ul><li><p>注意：<strong><code>std::int8_t</code>和<code>std::uint8_t</code><u>是char类型</u>，而不是integer</strong></p><p>在C++中，很多编译器对<code>std::int8_t</code>和<code>std::uint8_t</code>（以及相应的fast 和 least 整型）的定义和对待方式 是与 <code>signed char</code>(有符号字符类型) 的方式相同。</p><p>但是，在某些系统中，它确实是整型的，而不是char类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">int8_t</span> myint = <span class="number">65</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; myint;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************/</span></span><br><span class="line">运行结果是： A</span><br></pre></td></tr></table></figure><blockquote><p>所以，我们要<strong>避免使用这几个整型类型</strong>。</p></blockquote></li></ul><hr><p><strong>最佳使用整型</strong></p><ul><li>当整型的大小不做要求时，使用<strong><code>int</code></strong>；</li><li>如果需要一个保证为特定大小的变量，并且希望<strong>提高性能</strong>，使用<strong><code>int_fast#_t</code></strong>；</li><li>如果您需要一个保证为特定大小的变量，并且希望<strong>优先考虑内存保护而不是性能</strong>，使用 <strong><code>int_least#_t</code></strong></li></ul><p><strong>尽量不要使用这些</strong>：</p><ul><li>无符号整型，Unsigned types；</li><li>8 bits 的固定宽度的整型类型；</li><li>任何特定于编译器的固定宽度整数（例如，visual studio 定义了 __int8 ，__int16 等等）</li></ul><hr><p><strong><code>std::size_t</code></strong>是什么？</p><blockquote><p>是一个无符号整数类型，通常用于表示对象的大小或长度。</p></blockquote><p>sizeof返回一个<code>std::size_t</code>类型的值。</p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************/</span></span><br><span class="line">结果是： <span class="number">4</span>  【这个<span class="number">4</span>，就是 <span class="built_in">std</span>::<span class="keyword">size_t</span>类型的】</span><br></pre></td></tr></table></figure><ul><li><p><code>size_t</code>本身大小也是不固定的，它确保是无符号的，并且至少是16位。但是在大多数系统中，它的大小将等于应用程序的地址宽度。</p><blockquote><p>比如，在32位应用程序中，<code>size_t</code>是一个 32 bits 的无符号整型；在64位应用程序中，<code>size_t</code>是一个 64 bits 的无符号整型。</p></blockquote></li></ul><h2 id="4-7-科学计数法"><a href="#4-7-科学计数法" class="headerlink" title="4.7 科学计数法"></a>4.7 科学计数法</h2><p><strong>scientific notation</strong></p><p>科学计数法的形式：<strong>a×10^exponent^</strong>。其中, a：只能是0~9的数（不包括0，但包括9）</p><blockquote><p>如：1.2×10^4^ 、 5.9736 x 10^24^</p></blockquote><p>在C++中，我们用字母<code>e</code>（大写<code>E</code>也可以）来代表 10；</p><blockquote><p>1.2×10^4^ -&gt; 1.2e4 ； 5.9736 x 10^24^ -&gt; 5.9736e24</p><p>小于1的分数0.05表示为： 5e-2</p></blockquote><hr><ul><li><p><strong>有效数字：significant digits</strong></p><blockquote><p><em>有效数字的数量定义了数字的精度。</em>(有效数字越多，数字越精确。)</p></blockquote><p>e前面的数就是有效数字，如<code>5.9736e24</code>的有效数字是：5.9736，即，5个有效数字</p></li></ul><h2 id="4-8-浮点数float"><a href="#4-8-浮点数float" class="headerlink" title="4.8 浮点数float"></a>4.8 浮点数<code>float</code></h2><center>永远不要假设浮点数是精确的。</center><ul><li><p>三种浮点型数据：<strong><code>float</code>、<code>double</code>、<code>long double</code></strong></p><blockquote><p>与整数一样，c++没有定义这些类型的实际大小(但它确实保证了最小大小)。在现代体系结构中，浮点表示几乎总是遵循IEEE 754二进制格式。在这种格式中：</p><p><code>float</code>：4字节；</p><p><code>double</code>：8字节，</p><p><code>long double</code>：可以等于一个<code>double</code>(<strong>8字节</strong>)、<strong>80 bits(通常填充为12字节)</strong>或者 <strong>16字节</strong>。</p></blockquote><p>浮点型数据通常是 <strong>有符号的(sign)</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200331194441574.png" alt="image-20200331194441574"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x&#123;<span class="number">5</span>&#125;; <span class="comment">//整型</span></span><br><span class="line"><span class="keyword">double</span> y&#123;<span class="number">5.0</span>&#125;; <span class="comment">//5.0是一个浮点型(没有后缀，默认情况下是double类型)</span></span><br><span class="line"><span class="keyword">float</span> z&#123;<span class="number">5.0f</span>&#125;; <span class="comment">//5.0是一个浮点型，f后缀表示浮点类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********/</span></span><br><span class="line">【注】浮点型数据默认是：<span class="keyword">double</span>类型的，加上后缀“f”表示是 <span class="keyword">float</span>类型</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>浮点型数据的输出</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">5.0</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">6.7f</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">9876543.21</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************/</span></span><br><span class="line">输出结果：</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6.7</span></span><br><span class="line"><span class="number">9.87654e+06</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>第一个，即使我们输入的是5.0，但它输出的依然是 5。【默认情况下，如果小数部分为0,std::cout将不会打印数字的小数部分。】</li><li>第二个输出正常；</li><li>第三个输出是科学记数的形式。</li></ul></blockquote></li></ul><hr><ul><li><p><strong>浮点型的范围</strong></p><p>根据 IEEE 754的表示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200331195509853.png" alt="image-20200331195509853"></p></li></ul><hr><ul><li><p><strong>浮点型的精度</strong></p><ul><li>浮点型的默认精度是6：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">9.87654321f</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">987.654321f</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">987654.321f</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">9876543.21f</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">0.0000987654321f</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******输出**********/</span></span><br><span class="line"><span class="number">9.87654</span></span><br><span class="line"><span class="number">987.654</span></span><br><span class="line"><span class="number">987654</span></span><br><span class="line"><span class="number">9.87654e+006</span></span><br><span class="line"><span class="number">9.87654e-005</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：<strong>根据编译器的不同，指数的位数会被填充</strong>。比如：“9.87654e+006”的指数位置就被填充为3位。</p><p><strong>显示的最小指数位数是特定于编译器的，在Visual Studio 中填充为 <code>3 位</code></strong></p></blockquote></li></ul><ul><li><p>浮点变量的精度位数取决于大小(浮点数的精度小于双精度)和存储的特定值(某些值的精度高于其他值)。</p><p>用 <code>iomanip</code>头文件中的函数 <em>std::setprecison</em>来覆盖std::cout显示的默认精度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt; // for std::setprecision()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">16</span>); <span class="comment">// show 16 digits of precision</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">3.33333333333333333333333333333333333333f</span> &lt;&lt;<span class="string">'\n'</span>; <span class="comment">// f suffix means float</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">3.33333333333333333333333333333333333333</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// no suffix means double</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******输出*********/</span></span><br><span class="line"><span class="number">3.333333253860474</span></span><br><span class="line"><span class="number">3.333333333333334</span></span><br></pre></td></tr></table></figure><blockquote><p>可以看出，<strong><code>double</code>类型的比<code>float</code>类型的精度更高</strong>。</p></blockquote></li></ul><ul><li><p>精度不仅影响小数部分，他还影响比较大的数的精度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt; // for std::setprecision()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> f &#123; <span class="number">123456789.0f</span> &#125;; <span class="comment">// f has 10 significant digits</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">9</span>); <span class="comment">// to show 9 digits in f</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********结果**********/</span></span><br><span class="line"><span class="number">123456792</span></span><br></pre></td></tr></table></figure><blockquote><p>123456789.0 的有效数字是10个，但是浮点型通常有7位精度(123456792的结果只能精确到7位有效数字)。</p><p>我们失去了一些精度!当由于无法精确地存储数字而丢失精度时，这称为<strong>rounding error(舍入误差)</strong>。</p></blockquote><p>小结：<strong>通常情况推荐使用<code>double</code></strong></p></li></ul><hr><ul><li><p><strong>无限循环 &amp; 非数字 ：NaN and Inf</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> zero &#123;<span class="number">0.0</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> posinf &#123; <span class="number">5.0</span> / zero &#125;; <span class="comment">// positive infinity</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; posinf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">double</span> neginf &#123; <span class="number">-5.0</span> / zero &#125;; <span class="comment">// negative infinity</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; neginf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">double</span> nan &#123; zero / zero &#125;; <span class="comment">// not a number (mathematically invalid)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; nan &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******结果************/</span></span><br><span class="line"><span class="number">1.</span>#INF</span><br><span class="line"><span class="number">-1.</span>#INF</span><br><span class="line"><span class="number">1.</span>#IND</span><br></pre></td></tr></table></figure><blockquote><p>INF代表无穷，IND代表不确定。</p><p>请注意，输出Inf和NaN的结果是特定于平台的，因此您的结果可能会有所不同。</p></blockquote></li></ul><hr><p>总结：</p><ol><li><strong>浮点数用于存储非常大或非常小的数字，包括那些具有小数部分的数字。</strong></li><li>浮点数通常有较小的<strong>舍入误差</strong>，即使该数的有效位数比精度小。很多时候，这些数据的舍入误差没有被注意到，因为它们非常小，而且由于输出而被截断。但是，<strong>对浮点数的比较可能不会得到预期的结果。对这些值执行数学运算将导致舍入误差增大。</strong></li></ol><hr><h2 id="4-9-布尔型bool"><a href="#4-9-布尔型bool" class="headerlink" title="4.9 布尔型bool"></a>4.9 布尔型<code>bool</code></h2><p>实际上，<em>Boolean values</em>(布尔值)存储的布尔变量，不是以<code>true</code>、<code>false</code>的形式。<strong>而是以整型类型存储的，即<em>true</em>对应整型<em>1</em>；<em>false</em>对应整型<em>0</em>。</strong></p><blockquote><p>即，布尔值被认为是一个整型类型。</p></blockquote><hr><ul><li><p><strong>输出布尔值</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="literal">true</span>&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="literal">false</span>&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">bool</span> b&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;b&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;!b&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************结果***********/</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><hr><p>如果你想输出“<em>true</em>、<em>false</em>”。你可以用<code>std::boolalpah</code>：</p><blockquote><p><code>std::noboolalpha</code>是关闭作用</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="literal">false</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha; <span class="comment">//print bools as ture or false</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="literal">true</span>&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="literal">false</span>&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果**********/</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>整型与布尔型的转换：Integer to Boolean conversion</strong></p><ul><li><p>*<u>不能</u>用整型数字来初始化bool变量*</p><p><code>bool b{4};</code> //error: 不允许这样转换</p></li><li><p>但是，整型变量可以转换为布尔型：</p><blockquote><p>整型 <em>0</em> 可以被转换为<em>false<em>；其他的非0 的整型可以被转换为</em>true</em></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha; <span class="comment">// print bools as true or false</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> b1 = <span class="number">4</span> ; <span class="comment">// copy initialization allows implicit conversion from int to bool</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b1 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> b2 = <span class="number">0</span> ; <span class="comment">// copy initialization allows implicit conversion from int to bool</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b2 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果**********/</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><ul><li><p><strong>输入布尔型值</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> b &#123;&#125;; <span class="comment">// default initialize to false (0)</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a boolean value: "</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; b;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"You entered: "</span> &lt;&lt; b;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter a Boolean value: true</span><br><span class="line">You entered: 0</span><br></pre></td></tr></table></figure><p>发现，<strong>布尔型值的输入，只接受：<em>0</em> 和<em>1</em></strong> (不是 true 或者 false)。所以，如果输入的值是<em>0</em> 和<em>1</em>之外的其他值，都是失败的，即false，所以是0。</p><blockquote><p>因为在C++11或者更新的标准中，<strong>一个失败的输入也会使变量变为0，所以b也会被赋值为0。</strong></p></blockquote></li></ul><hr><h2 id="4-11-char类型"><a href="#4-11-char类型" class="headerlink" title="4.11 char类型"></a>4.11 <code>char</code>类型</h2><p>char数据类型是<strong>整数类型</strong>，这意味着<u>底层值存储为整数</u>，并且保证<u>大小为1字节</u>。</p><p>但是，与将布尔值解释为true或false类似，<u>将char值解释为ASCII字符</u>。</p><blockquote><p><strong>ASCII</strong>是美国信息交换标准代码的缩写，它定义了一种特殊的方式来将英文字符(加上一些其他符号)表示为0到127之间的数字(称为ASCII码或代码点)。</p><p><strong>字符文字总是放在单引号之间</strong>。例如，ASCII码97被解释为字符“a”。</p></blockquote><p>下面是完整的ASCII字符表:</p><table><thead><tr><th align="left">Code</th><th align="left">Symbol</th><th align="left">Code</th><th align="left">Symbol</th><th align="left">Code</th><th align="left">Symbol</th><th align="left">Code</th><th align="left">Symbol</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">NUL (null)</td><td align="left">32</td><td align="left">(space)</td><td align="left">64</td><td align="left">@</td><td align="left">96</td><td align="left">`</td></tr><tr><td align="left">1</td><td align="left">SOH (start of header)</td><td align="left">33</td><td align="left">!</td><td align="left">65</td><td align="left">A</td><td align="left">97</td><td align="left">a</td></tr><tr><td align="left">2</td><td align="left">STX (start of text)</td><td align="left">34</td><td align="left">”</td><td align="left">66</td><td align="left">B</td><td align="left">98</td><td align="left">b</td></tr><tr><td align="left">3</td><td align="left">ETX (end of text)</td><td align="left">35</td><td align="left">#</td><td align="left">67</td><td align="left">C</td><td align="left">99</td><td align="left">c</td></tr><tr><td align="left">4</td><td align="left">EOT (end of transmission)</td><td align="left">36</td><td align="left">$</td><td align="left">68</td><td align="left">D</td><td align="left">100</td><td align="left">d</td></tr><tr><td align="left">5</td><td align="left">ENQ (enquiry)</td><td align="left">37</td><td align="left">%</td><td align="left">69</td><td align="left">E</td><td align="left">101</td><td align="left">e</td></tr><tr><td align="left">6</td><td align="left">ACK (acknowledge)</td><td align="left">38</td><td align="left">&amp;</td><td align="left">70</td><td align="left">F</td><td align="left">102</td><td align="left">f</td></tr><tr><td align="left">7</td><td align="left">BEL (bell)</td><td align="left">39</td><td align="left">’</td><td align="left">71</td><td align="left">G</td><td align="left">103</td><td align="left">g</td></tr><tr><td align="left">8</td><td align="left">BS (backspace)</td><td align="left">40</td><td align="left">(</td><td align="left">72</td><td align="left">H</td><td align="left">104</td><td align="left">h</td></tr><tr><td align="left">9</td><td align="left">HT (horizontal tab)</td><td align="left">41</td><td align="left">)</td><td align="left">73</td><td align="left">I</td><td align="left">105</td><td align="left">i</td></tr><tr><td align="left">10</td><td align="left">LF (line feed/new line)</td><td align="left">42</td><td align="left">*</td><td align="left">74</td><td align="left">J</td><td align="left">106</td><td align="left">j</td></tr><tr><td align="left">11</td><td align="left">VT (vertical tab)</td><td align="left">43</td><td align="left">+</td><td align="left">75</td><td align="left">K</td><td align="left">107</td><td align="left">k</td></tr><tr><td align="left">12</td><td align="left">FF (form feed / new page)</td><td align="left">44</td><td align="left">,</td><td align="left">76</td><td align="left">L</td><td align="left">108</td><td align="left">l</td></tr><tr><td align="left">13</td><td align="left">CR (carriage return)</td><td align="left">45</td><td align="left">-</td><td align="left">77</td><td align="left">M</td><td align="left">109</td><td align="left">m</td></tr><tr><td align="left">14</td><td align="left">SO (shift out)</td><td align="left">46</td><td align="left">.</td><td align="left">78</td><td align="left">N</td><td align="left">110</td><td align="left">n</td></tr><tr><td align="left">15</td><td align="left">SI (shift in)</td><td align="left">47</td><td align="left">/</td><td align="left">79</td><td align="left">O</td><td align="left">111</td><td align="left">o</td></tr><tr><td align="left">16</td><td align="left">DLE (data link escape)</td><td align="left">48</td><td align="left">0</td><td align="left">80</td><td align="left">P</td><td align="left">112</td><td align="left">p</td></tr><tr><td align="left">17</td><td align="left">DC1 (data control 1)</td><td align="left">49</td><td align="left">1</td><td align="left">81</td><td align="left">Q</td><td align="left">113</td><td align="left">q</td></tr><tr><td align="left">18</td><td align="left">DC2 (data control 2)</td><td align="left">50</td><td align="left">2</td><td align="left">82</td><td align="left">R</td><td align="left">114</td><td align="left">r</td></tr><tr><td align="left">19</td><td align="left">DC3 (data control 3)</td><td align="left">51</td><td align="left">3</td><td align="left">83</td><td align="left">S</td><td align="left">115</td><td align="left">s</td></tr><tr><td align="left">20</td><td align="left">DC4 (data control 4)</td><td align="left">52</td><td align="left">4</td><td align="left">84</td><td align="left">T</td><td align="left">116</td><td align="left">t</td></tr><tr><td align="left">21</td><td align="left">NAK (negative acknowledge)</td><td align="left">53</td><td align="left">5</td><td align="left">85</td><td align="left">U</td><td align="left">117</td><td align="left">u</td></tr><tr><td align="left">22</td><td align="left">SYN (synchronous idle)</td><td align="left">54</td><td align="left">6</td><td align="left">86</td><td align="left">V</td><td align="left">118</td><td align="left">v</td></tr><tr><td align="left">23</td><td align="left">ETB (end of transmission block)</td><td align="left">55</td><td align="left">7</td><td align="left">87</td><td align="left">W</td><td align="left">119</td><td align="left">w</td></tr><tr><td align="left">24</td><td align="left">CAN (cancel)</td><td align="left">56</td><td align="left">8</td><td align="left">88</td><td align="left">X</td><td align="left">120</td><td align="left">x</td></tr><tr><td align="left">25</td><td align="left">EM (end of medium)</td><td align="left">57</td><td align="left">9</td><td align="left">89</td><td align="left">Y</td><td align="left">121</td><td align="left">y</td></tr><tr><td align="left">26</td><td align="left">SUB (substitute)</td><td align="left">58</td><td align="left">:</td><td align="left">90</td><td align="left">Z</td><td align="left">122</td><td align="left">z</td></tr><tr><td align="left">27</td><td align="left">ESC (escape)</td><td align="left">59</td><td align="left">;</td><td align="left">91</td><td align="left">[</td><td align="left">123</td><td align="left">{</td></tr><tr><td align="left">28</td><td align="left">FS (file separator)</td><td align="left">60</td><td align="left">&lt;</td><td align="left">92</td><td align="left">\</td><td align="left">124</td><td align="left">|</td></tr><tr><td align="left">29</td><td align="left">GS (group separator)</td><td align="left">61</td><td align="left">=</td><td align="left">93</td><td align="left">]</td><td align="left">125</td><td align="left">}</td></tr><tr><td align="left">30</td><td align="left">RS (record separator)</td><td align="left">62</td><td align="left">&gt;</td><td align="left">94</td><td align="left">^</td><td align="left">126</td><td align="left">~</td></tr><tr><td align="left">31</td><td align="left">US (unit separator)</td><td align="left">63</td><td align="left">?</td><td align="left">95</td><td align="left">_</td><td align="left">127</td><td align="left">DEL (delete)</td></tr></tbody></table><hr><ul><li><p><strong>初始化字符</strong></p><ol><li><p>使用字符 初始化：</p><p><code>char cha2{&#39;a&#39;};</code> <em>// initialize with code point for ‘a’ (stored as integer 97) (preferred)</em></p></li><li><p>使用整型数值 初始化：</p><p><code>char cha1{97};</code> <em>// initialize with integer 97 (‘a’) (not preferred)</em></p></li></ol></li></ul><hr><ul><li><p><strong>输出字符型</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch1&#123; <span class="string">'a'</span> &#125;; <span class="comment">// (preferred)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ch1; <span class="comment">// cout prints a character</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">char</span> ch2&#123; <span class="number">98</span> &#125;; <span class="comment">// code point for 'b' (not preferred)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ch2; <span class="comment">// cout prints a character</span></span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">'c'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******结果********/</span></span><br><span class="line">abc</span><br></pre></td></tr></table></figure><p>【注意】固定宽度我的整型：<code>int8_t</code>类型，是被当做有符号的char类型对待的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int8_t</span> a&#123; <span class="number">97</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200401174509017.png" alt="image-20200401174509017"></p></li></ul><hr><ul><li><p><strong>通过类型转换将字符打印为整数</strong></p><ul><li>一种(糟糕的)方法是将char赋值给一个整数，然后输出这个整数:</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch&#123;<span class="number">97</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> a&#123;ch&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果*********/</span></span><br><span class="line"><span class="number">97</span></span><br></pre></td></tr></table></figure><hr><ul><li><p>另一种较好的方法就是：<strong><em>type case</em>：强制类型转换</strong>，其格式为：</p><p><code>static_cast&lt;new_type&gt;(expression)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch1&#123;<span class="number">97</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> ch2&#123;<span class="string">'a'</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt; (ch1) &lt;&lt;<span class="string">'\n'</span>; <span class="comment">//强制类型转换</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt; (ch2) ; <span class="comment">//强制类型转换</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********结果********/</span></span><br><span class="line"><span class="number">97</span></span><br><span class="line"><span class="number">97</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，变量ch仍然是一个char，并且仍然保持相同的值。知识在本次输出时，输出的是整型类型的值。</p></li></ul><hr><p><strong><u>知识点</u>：</strong></p><blockquote><p>当您看到c++语法(不包括预处理器)使用<em>尖括号&lt;&gt;</em>时，<strong>尖括号之间的内容很可能是类型</strong>。这就是c++处理需要参数化类型的概念的典型方式。</p></blockquote></li></ul><hr><ul><li><p>【<strong>注意</strong>】：std::cin将<strong>允许您输入多个字符</strong>。<strong>然而，变量ch只能包含一个字符</strong>。因此，只有第一个输入字符被提取到变量ch中，<strong>其余的用户输入留在std::cin使用的输入缓冲区中，可以通过后续调用std::cin来提取。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Input a keyboard character: "</span>; <span class="comment">// assume the user enters "abcd" (without quotes)</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">char</span> ch&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; ch; <span class="comment">// ch = 'a', "bcd" is left queued.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="string">" has ASCII code "</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(ch) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Note: The following cin doesn't ask the user for input, it grabs queued input!</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; ch; <span class="comment">// ch = 'b', "cd" is left queued.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="string">" has ASCII code "</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(ch) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200401202849307.png" alt="image-20200401202849307">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200401202925333.png" alt="image-20200401202925333"></p></li></ul><hr><ul><li><p><strong><code>char</code>的大小、范围以及默认的sign(符号)</strong></p><ul><li><p><strong>size</strong>：C++中char类型通常为：1 byte；</p></li><li><p><strong>sign</strong>：默认情况下，char类型是 signed 或者 unsigned；</p><blockquote><p>如果使用字符来保存ASCII字符，则不需要指定符号(因为有符号和无符号字符都可以保存0到127之间的值)。</p><hr><p>一个有符号的字符可以容纳-128到127之间的数字；无符号字符可以容纳0到255之间的数字。</p></blockquote></li></ul></li></ul><hr><ul><li><p><strong>转义符：escape sequences</strong></p><p>转义符<strong>以 “\” 开头</strong>,<strong>后面跟着一个 字母 或 数字</strong>；</p><table><thead><tr><th align="left">Name</th><th align="left">Symbol</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">Alert</td><td align="left">\a</td><td align="left">Makes an alert, such as a beep</td></tr><tr><td align="left">Backspace</td><td align="left">\b</td><td align="left">Moves the cursor back one space</td></tr><tr><td align="left">Formfeed</td><td align="left">\f</td><td align="left">Moves the cursor to next logical page</td></tr><tr><td align="left">Newline</td><td align="left">\n</td><td align="left">Moves cursor to next line</td></tr><tr><td align="left">Carriage return</td><td align="left">\r</td><td align="left">Moves cursor to beginning of line</td></tr><tr><td align="left">Horizontal tab</td><td align="left">\t</td><td align="left">Prints a horizontal tab</td></tr><tr><td align="left">Vertical tab</td><td align="left">\v</td><td align="left">Prints a vertical tab</td></tr><tr><td align="left">Single quote</td><td align="left">\’</td><td align="left">Prints a single quote</td></tr><tr><td align="left">Double quote</td><td align="left">\”</td><td align="left">Prints a double quote</td></tr><tr><td align="left">Backslash</td><td align="left">\</td><td align="left">Prints a backslash.</td></tr><tr><td align="left">Question mark</td><td align="left">?</td><td align="left">Prints a question mark. No longer relevant. You can use question marks unescaped.</td></tr><tr><td align="left">Octal number</td><td align="left">(number)</td><td align="left">Translates into char represented by octal (<em>octal</em>：8进制)</td></tr><tr><td align="left">Hex number</td><td align="left">\x(number)</td><td align="left">Translates into char represented by hex number(<em>hex</em>：16进制)</td></tr></tbody></table></li></ul><hr><ul><li><p><strong>单引号</strong> VS <strong>双引号</strong> 的区别</p><ul><li><p>单个字符总是放在 单引号 中。(e.g. ‘a’, ‘+’, ‘5’)。<code>char</code>类型的只能接收一个符号(e.g. 字母 a, + , 数字 5)</p><p><code>char ch(&#39;56&#39;);</code> <em>// a char can only hold one symbol</em></p></li><li><p>放在双引号(例如“Hello, world!”)之间的文本称为<strong>字符串<em>string</em></strong>。一个 <em>string</em>是连续字符的集合(因此，一个字符串可以包含多个符号)。</p><p><code>std::cout &lt;&lt; &quot;hello world&quot; ;</code> <em>// “Hello, world!” is a string literal</em></p></li></ul><hr><p>知识点：<strong><em>string</em>类型在C++中，不是基本数据类型</strong></p></li></ul><hr><ul><li><em>char</em>的其他类型：<strong><code>wchar_t</code>、<code>char16_t</code>、<code>char32_t</code></strong><ul><li><code>wchar_t</code>：应避免使用(除非是在windows API接口时使用)。它的大小是在实现时才确定的，它并不可靠。</li><li><code>char16_t</code>、<code>char32_t</code>在C++11中添加，以提供对16位和32位Unicode字符的显式支持。在c++ 20中添加了<code>char8_t</code>。</li></ul></li></ul><hr><h2 id="4-12-字面常量"><a href="#4-12-字面常量" class="headerlink" title="4.12 字面常量"></a>4.12 字面常量</h2><ul><li><p><strong><em>constant</em></strong>：是固定的值，不可被改变。</p><blockquote><p>C++中有两种<em>constant</em>：<strong>字面常量</strong>、<strong>符号常量</strong>。</p></blockquote></li></ul><ul><li><p><strong>literal constant：字面常量</strong>，简称：<strong>literal</strong>。是直接将值插入代码中的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="number">5</span>; <span class="comment">//5是一个整型literal</span></span><br><span class="line"><span class="keyword">bool</span> mynameisqin&#123;<span class="literal">true</span>&#125;; <span class="comment">//true 是一个布尔型literal</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="number">3.4</span>; <span class="comment">//3.4 是一个双精度浮点型的literal</span></span><br></pre></td></tr></table></figure><p>上面这些都是常数，因为他们不能动态的被改变。</p><p>就像对象分类型一样，常量也是有类型的：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200402103515525.png" alt="常量的类型"></p></li></ul><hr><ul><li><p><strong>literal 的后缀</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200402103708146.png" alt="literal 的后缀"></p><p>example：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> value1 &#123;<span class="number">5u</span>&#125;; <span class="comment">//5的类型是 unsigned int</span></span><br><span class="line"><span class="keyword">long</span> value2 &#123;<span class="number">6L</span>&#125;; <span class="comment">// 6的类型是 long</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*默认情况，浮点类型是 double ；如果想定义其为float类型，可以添加后缀类实现*/</span></span><br><span class="line"><span class="keyword">float</span> f1 &#123;<span class="number">5.0f</span>&#125;; <span class="comment">//5.0 的类型是 float</span></span><br><span class="line"><span class="keyword">float</span> f2 &#123;<span class="number">4.1</span>&#125;; <span class="comment">//4.1的类型是   double</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>string literals</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world"</span>; <span class="comment">//这种是 C分割的 string literal</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello"</span> <span class="string">" world"</span>; <span class="comment">//C++将会把它们连接起来</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>Scientific notation for floating point literals：浮点型literal 的科学计数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> pi &#123;<span class="number">3.14159</span>&#125;; <span class="comment">//3.14159是一种一般形式</span></span><br><span class="line"><span class="keyword">double</span> avogadro &#123;<span class="number">6.02e23</span>&#125;; <span class="comment">//6.02e23 是双精度浮点型literal 的科学计数法形式</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>Octal and hexadecimal literals：八进制 &amp; 十六进制 的 literal</strong></p><ol><li><p><strong>八进制：octal</strong></p><p>八进制是以8为底，它可用的数为： 0, 1, 2, 3, 4, 5, 6, 7。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200402105451740.png" alt="八进制与十进制的对应"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*八进制的前缀是，数字“0”，不是字母“o”*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123;<span class="number">012</span>&#125;; <span class="comment">//"0"表示这个数字是八进制数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr></li><li><p><strong>十六进制：hexadecimal</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter4/image-20200402110146793.png" alt="十六进制与十进制的对应"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*十六进制数的前缀是：数字0和字母x，即 0x*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x&#123;<span class="number">0xF</span>&#125;; <span class="comment">//0x表示这个数是十六进制数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>十六进制通常用来<strong>表示内存地址</strong> 或 <strong>内存中的原始值</strong>。</p><blockquote><p>因为相对于二进制，16进制表示起来更加简洁。如：二进制的数<code>0011 1010 0111 1111 1001 1000 0010 0110</code>，单用16进制表示的话，就是<code>3A7F 9826</code></p></blockquote><hr><p>在C++14之前，无法给变量赋一个二进制的literal，但是，16进制对为我们提供了一个有用的解决方法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bin&#123;&#125;;</span><br><span class="line">    bin = <span class="number">0x01</span>; <span class="comment">// assign binary 0000 0001 to the variable</span></span><br><span class="line">    bin = <span class="number">0x02</span>; <span class="comment">// assign binary 0000 0010 to the variable</span></span><br><span class="line">    bin = <span class="number">0x04</span>; <span class="comment">// assign binary 0000 0100 to the variable</span></span><br><span class="line">    bin = <span class="number">0x08</span>; <span class="comment">// assign binary 0000 1000 to the variable</span></span><br><span class="line">    bin = <span class="number">0x10</span>; <span class="comment">// assign binary 0001 0000 to the variable</span></span><br><span class="line">    bin = <span class="number">0x20</span>; <span class="comment">// assign binary 0010 0000 to the variable</span></span><br><span class="line">    bin = <span class="number">0x40</span>; <span class="comment">// assign binary 0100 0000 to the variable</span></span><br><span class="line">    bin = <span class="number">0x80</span>; <span class="comment">// assign binary 1000 0000 to the variable</span></span><br><span class="line">    bin = <span class="number">0xFF</span>; <span class="comment">// assign binary 1111 1111 to the variable</span></span><br><span class="line">    bin = <span class="number">0xB3</span>; <span class="comment">// assign binary 1011 0011 to the variable</span></span><br><span class="line">    bin = <span class="number">0xF770</span>; <span class="comment">// assign binary 1111 0111 0111 0000 to the variable</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><hr><ul><li><p><strong>C++14中 二进制的literal</strong></p><p>在C++14中，使用数字0和字母b，即“0b”。给变量分配二进制的literal：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bin&#123;&#125;;</span><br><span class="line">    bin = <span class="number">0b1</span>;  <span class="comment">// assign binary 0000 0001 to the variable</span></span><br><span class="line">    bin = <span class="number">0b11</span>; <span class="comment">// assign binary 0000 0011 to the variable</span></span><br><span class="line">    bin = <span class="number">0b1010</span>; <span class="comment">// assign binary 0000 1010 to the variable</span></span><br><span class="line">    bin = <span class="number">0b11110000</span>; <span class="comment">// assign binary 1111 0000 to the variable</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*但是二进制数比较长，所以用“ ' ”来当做分隔符，便于读认*/</span></span><br><span class="line">#Include &lt;iostream&gt;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> bin &#123;<span class="number">0b1011'0010</span>&#125;;</span><br><span class="line">     <span class="keyword">long</span> value &#123;<span class="number">0'132'673'462</span>&#125;;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>输出 十进制、八进制、十六进制、二进制数</strong></p><blockquote><p>decimal、octal、hexadecimal、binary</p></blockquote><p>C++默认输出是十进制数，但是我们可以转换输出格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x &#123;<span class="number">12</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt;<span class="string">'\n'</span>; <span class="comment">//默认十进制</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::hex&lt;&lt;x &lt;&lt;<span class="string">'\n'</span>; <span class="comment">//16进制</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt;<span class="string">'\n'</span>; <span class="comment">//x变量的值现在被转换为16进制了</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::oct&lt;&lt; x &lt;&lt;<span class="string">'\n'</span>; <span class="comment">//8进制</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::dec&lt;&lt; x &lt;&lt;<span class="string">'\n'</span>; <span class="comment">//十进制</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****输出*******/</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line">c</span><br><span class="line">c</span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><hr><p><strong>输出二进制</strong>：输出二进制数比较麻烦一点。<strong>需要添加头文件：<code>&lt;bitset&gt;</code></strong>。</p><blockquote><p><code>std::bitset&lt;num&gt;</code>：表示我们存储的位数为num。它可以被初始化成一个 无符号整数值(可以使10，8，16，2进制的形式)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt; //for std::bitset</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// std::bitset&lt;8&gt; means we want to store 8 bits</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;8&gt; bin1&#123; <span class="number">0b1100'0101</span> &#125;; <span class="comment">// binary literal for binary 1100 0101</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;8&gt; bin2&#123; <span class="number">0xC5</span> &#125;; <span class="comment">// hexadecimal literal for binary 1100 0101</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; bin1 &lt;&lt; <span class="string">' '</span> &lt;&lt; bin2 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;4&gt;&#123; <span class="number">0b1010</span> &#125; &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// we can also print from std::bitset directly(输出完之后，被抛弃)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出*/</span></span><br><span class="line"><span class="number">11000101</span> <span class="number">11000101</span></span><br><span class="line"><span class="number">1010</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="4-13-const-constexpr-symbolic-constants"><a href="#4-13-const-constexpr-symbolic-constants" class="headerlink" title="4.13 const, constexpr, symbolic constants"></a>4.13 const, constexpr, symbolic constants</h2><p><strong>常量 变量：其值不能被修改，情形修改会出错</strong></p><ul><li><p>使用<strong>关键字<code>const</code></strong>，来表示该变量是常量：</p><blockquote><p>放在变量类型的前面、后面 都可以</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> gravity &#123;<span class="number">9.8</span>&#125;; <span class="comment">//放在类型的前面【推荐】</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> sidesInSquare &#123;<span class="number">4</span>&#125;; <span class="comment">//放在类型后面【不推荐】</span></span><br></pre></td></tr></table></figure></li></ul><hr><p><red><strong>常量变量(const variable)</strong>必须在定义时要初始化(即要赋值给他们)。赋值完成，它的值就不能被改变.</red></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******常量变量的值被改变*************/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> a &#123;<span class="number">5.0</span>&#125;;</span><br><span class="line">a = <span class="number">1.0</span>;  <span class="comment">//编译出错，因为常量变量的值被改变</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******常量变量不初始化********/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> a; <span class="comment">//compiler error, must be initialized upon definition</span></span><br></pre></td></tr></table></figure><hr><ul><li><p><strong>runtime VS compile time constants</strong></p><blockquote><p><strong>runtime</strong>：程序运行时；</p><p><strong>compile time</strong>：编译器运行时。</p></blockquote><ul><li><strong>runtime constants</strong>：初始化值只能在运行时解析的常量；</li><li><strong>compile-time constants</strong>：初始化值可以在编译时解析的；</li></ul><p>当您声明一个const变量时，编译器将隐式地跟踪它是运行时常量还是编译时常量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">getNumberOfBits</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> numberOfBits&#123; <span class="number">3</span> &#125;; <span class="comment">// Compile-time constant</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;numberOfBits&gt; b&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> otherNumberOfBits&#123; getNumberOfBits() &#125;; <span class="comment">// Run-time constant</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;otherNumberOfBits&gt; b2&#123;&#125;; <span class="comment">// Error[因为此时需要的是编译时常量，而不是运行时常量]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>常量表达式：constexpr</strong></p><p>为了提供更多的特性，c++ 11引入了新的<strong>关键字constexpr，它确保常量必须是 “编译时常量”:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">double</span> gravity &#123;<span class="number">9.8</span>&#125;; <span class="comment">//正确，9.8是编译时的字面常量</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> sum &#123;<span class="number">4</span>+<span class="number">5</span>&#125;; <span class="comment">//正确，4+5的值时编译时的字面常量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"enter your age:"</span>;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; age;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> myage &#123;age&#125;; <span class="comment">//错误，因为“age”是一个运行时常量</span></span><br></pre></td></tr></table></figure></li></ul><hr><p>【小结】：常量变量必须在定义时，对它初始化。</p><ul><li>当一个变量的值需要是 编译时常量时，推荐使用<code>constexpr</code>来声明它。</li><li>当一个变量的值需要是 运行时常量时，推荐使用<code>const</code>来声明它。</li></ul><hr><ul><li><p><strong>符号常量：symbolic constants</strong></p><p><strong>symbolic constant</strong>：是 字面常量(literal constant)的值 的名字。</p><hr><p>两种方法声明符号常量：</p><ol><li><p>使用<strong>“宏(macro)”</strong>定义：【不推荐】</p><p><code>#define identifier substitution_text</code></p><p>如：<code>#define a 10;</code></p></li><li><p>使用关键字<code>constexpr</code>变量：【推荐】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> maxstudentperclass &#123;<span class="number">30</span>&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> maxnamelength &#123;<span class="number">30</span>&#125;;</span><br></pre></td></tr></table></figure></li></ol></li></ul><hr><ul><li><p><strong>在多文件程序中使用符号常量</strong></p><p>在许多应用程序中，需要在整个代码中使用给定的符号常量(而不仅仅是在一个位置)。这些参数可以包括物理或数学常数(如pi或阿伏伽德罗常数)，或特定于应用程序的“调优”值(如摩擦系数或重力系数)。<strong>与其每次需要时都重新定义它们，不如在中心位置声明一次并在需要的地方使用它们。</strong>这样，如果你需要改变它们，你只需要在一个地方改变它们。</p><p>有很多种方法来实现它，这里使用比较简单的一种：</p><ol><li>首先，<strong>创建一个头文件</strong>来写相关的常量；</li><li>在这个头文件中，<strong>声明一个名称空间</strong>；</li><li>将你要用到的<strong>常量写在这个命名空间</strong>中；</li><li>在你需要这些常量的时候，<strong><code>#include</code>这个头文件</strong>。</li></ol><p>example：</p><ul><li><p>constants.h (C++11/14):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONSTANTS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONSTANTS_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//define your own namespace to hold constansts</span></span><br><span class="line"><span class="keyword">namespace</span> constants</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">double</span> pi &#123;<span class="number">3.14159</span>&#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">double</span> avogadro &#123;<span class="number">6.0221413e23</span>&#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">double</span> my_gravity &#123;<span class="number">9.2</span>&#125;;</span><br><span class="line">    <span class="comment">//.........other related constants</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li><li><p>In C++17, prefer “inline constexpr” instead:</p><p>constants.h (C++17 or newer):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONSTANTS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONSTANTS_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// define your own namespace to hold constants</span></span><br><span class="line"><span class="keyword">namespace</span> constants</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> pi &#123;<span class="number">3.14159</span>&#125;;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> avogadro &#123; <span class="number">6.0221413e23</span> &#125;;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> my_gravity &#123; <span class="number">9.2</span> &#125;; <span class="comment">// m/s^2 -- gravity is light on this planet</span></span><br><span class="line">    <span class="comment">// ... other related constants</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li></ul><p>使用<strong>“作用域解析符<code>::</code>”</strong>,在其他文件访问你的常量：</p><p><em>main.cpp</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"constants.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"enter a radius: "</span>;</span><br><span class="line">    <span class="keyword">int</span> radius&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; radius;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> circumference &#123;<span class="number">2.0</span>*radius*constants::pi&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"the circumference is: "</span> &lt;&lt;circumference &lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnCpp chapter2</title>
      <link href="/archives/28c74e52.html"/>
      <url>/archives/28c74e52.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red>LearnCpp chapter2</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h2 id="2-1-函数"><a href="#2-1-函数" class="headerlink" title="2.1 函数"></a>2.1 函数</h2><p>当你读一本书的时候，突然有人给你打电话。然后你就用“书签”夹在当前阅读位置，去接电话。等你电话接完，再回到你放书签的那个地方继续读书。</p><p><strong>函数调用(function call)</strong>是一个表达式。它告诉CPU中断当前函数并在这里“放一个书签”，然后执行另一个函数(就是函数调用中提及的那个函数)。当调用结束后，CPU就返回到“书签”的位置，然后再继续执行。</p><blockquote><p><strong>caller</strong>：发起函数调用的函数叫做caller；</p><p><strong>callee(called function)</strong>：被调用的函数叫做callee(called function)。</p></blockquote><p><strong>int main()的返回值</strong>：</p><p>在int main()函数最后，会有返回值，这个值是返回到操作系统的，为了让操作系统知道这个程序执行成功与否。main函数的返回值，有一个特定名字叫做：<strong><u>status code （状态码）</u></strong></p><blockquote><p>一般 <code>return 0;</code> 表示程序执行成功。</p><p>返回非零值，表示程序执行错误。</p></blockquote><p>【<strong>Note</strong>】：<strong>C++规定，main函数必须是int型的。即： int main()</strong></p><h2 id="2-3-函数的形参与实参"><a href="#2-3-函数的形参与实参" class="headerlink" title="2.3 函数的形参与实参"></a>2.3 函数的形参与实参</h2><ul><li><p><strong>形参(parameter)</strong>：是指函数定义中参数；(形参初始化是通过调用者传来的值(即，实参)来初始化的 )</p><p><strong>实参(argument)</strong>：函数调用时的实际参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printValues</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">//函数定义时的参数x,y，即这里的x,y是形参</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printValues(<span class="number">6</span>, <span class="number">7</span>); <span class="comment">//调用函数。即，6和7是实参</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>实参与形参如何一起工作？</strong></p><p>当调用一个函数时，函数所有的parameters都被创建为变量，并且每个arguments的值都被复制到匹配的parameters中。这个过程称为<strong>pass by value(按值传递)</strong>。</p></li><li><p><strong>关于函数参数求值顺序的警告</strong></p><p>在C++中，没有规定实参匹配的顺序（顺序：从左→右，还是从右→左），因为匹配顺序不重要。</p><p>但是，如果实参是函数调用，那就需要注意了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someFunction(a(), b()); <span class="comment">// a() or b() may be called first</span></span><br></pre></td></tr></table></figure><ul><li>是从右→左，还是从右→左：<strong>取决于a()和b()的功能</strong>。</li></ul><p>如果你想要规定谁先的话，你可以显示的规定匹配顺序，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> avar&#123; a() &#125;; <span class="comment">// a() will always be called first</span></span><br><span class="line"><span class="keyword">int</span> bvar&#123; b() &#125;; <span class="comment">// b() will always be called second</span></span><br><span class="line"> </span><br><span class="line">someFunction(avar, bvar); <span class="comment">// it doesn't matter whether avar or bvar are copied first because they are just values</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="2-4-局部范围"><a href="#2-4-局部范围" class="headerlink" title="2.4 局部范围"></a>2.4 局部范围</h2><ul><li><strong>局部变量Local variables</strong>：函数的形参，和它内部定义的变量 属于“局部变量”。如：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// function parameters x and y are local variables</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> z&#123; x + y &#125;; <span class="comment">// z is a local variable too</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>局部变量生命周期</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// x and y are created and enter scope here</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// x and y are visible/usable within this function only</span></span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125; <span class="comment">// y and x go out of scope and are destroyed here</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a&#123; <span class="number">5</span> &#125;; <span class="comment">// a is created, initialized, and enters scope here</span></span><br><span class="line">    <span class="keyword">int</span> b&#123; <span class="number">6</span> &#125;; <span class="comment">// b is created, initialized, and enters scope here</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// a and b are usable within this function only</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(a, b) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// calls function add() with x=5 and y=6</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// b and a go out of scope and are destroyed here</span></span><br></pre></td></tr></table></figure><blockquote><p>执行过程：</p><ol><li><p>程序开始执行于main()函数；</p></li><li><p>main()函数的变量a被创建并赋值为5；（初始化）★</p></li><li><p>main()函数的变量b被创建并赋值为6；（初始化）★</p></li><li><p>函数add()被调用，并传入实参5，6；</p></li><li><p>add()函数的变量x被创建，并初值为5;（初始化）★</p></li><li><p>add()函数的变量y被创建，并初值为6;（初始化）★</p></li><li><p>操作符“+”计算表达式”x+y”，产生值11；</p></li><li><p>add函数将值11复制回调用者main()函数；</p></li><li><p>add函数的x、y被摧毁；★</p></li><li><p>main()函数在控制台上打印出11；</p></li><li><p>main()函数返回0到操作系统；</p></li><li><p>main()函数的a、b被摧毁。★</p></li></ol></blockquote><p>由此可知，<strong>局部变量的生命周期</strong>：是从他开始<u>被创建</u>（如上述的第2步，变量a被创建）一直到执行完这个它所在的函数（如上述的第9步）被摧毁。</p><p><strong>【Note】</strong>：变量的创建和摧毁发生在程序的<strong>运行期间（runtime）</strong>。所以生命周期是一个runtime属性。</p></li><li><p><strong>局部范围</strong></p><p><strong>标识符的范围</strong>决定了在源代码中标识符可以被访问的位置。范围是一个<strong>编译期间(compile-time)</strong>的属性。（当使用的标识符不在范围内时，编译器会报错）</p><p><strong>局部变量的范围</strong>：开始于它的<u>定义</u>，结束于<u>定义它们的花括号集合的末尾</u>。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// x is not in scope anywhere in this function</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello!\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// x can not be used here because it's not in scope yet</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> x&#123; <span class="number">0</span> &#125;; <span class="comment">// x enters scope here and can now be used</span></span><br><span class="line"> </span><br><span class="line">    doSomething();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// x goes out of scope here and can no longer be used</span></span><br></pre></td></tr></table></figure><h2 id="2-5-为什么要用函数"><a href="#2-5-为什么要用函数" class="headerlink" title="2.5 为什么要用函数"></a>2.5 为什么要用函数</h2></li></ul><p><strong>使用函数的优势</strong>：</p><ul><li><strong>有组织性Organization</strong>：随着程序越来越复杂，若将全部的代码都写在main()函数中，势必会增加复杂性。一个函数就像一个小型程序。将它与main函数分开写，我们就不必去考其余代码。</li><li><strong>可重用性Reusability</strong>：一个函数可以被调用无数次。就可以避免这种情况：如果写在main函数中，要调用n次这个功能，就要重新写这个功能n次。</li><li><strong>便于测试Testing</strong>：因为函数减少了代码冗余，所以首先要测试的代码就更少了。另外，因为函数是自包含的，所以一旦我们测试了一个函数以确保它可以工作，我们就不需要再次测试它，除非我们修改它。这减少了我们必须一次测试的代码量，使得查找bug(或者在第一时间避免bug)变得更加容易。</li><li><strong>可扩展性Extensibility</strong>：</li><li><strong>抽象化Abstraction</strong>：在每次用这个函数时，我们只需要知道它的名字。输入和输出。不必知道它是如何工作的。</li></ul><p><strong>如何高效的使用函数？</strong></p><ul><li>在一个程序中<u>出现多次的语句</u>通常应该构成一个函数。例如，如果我们以相同的方式多次读取来自用户的输入，那么这就是一个很好的函数候选。如果我们以相同的方式输出多次，这也是一个很好的候选函数。</li><li>一个函数通常应该执行一个(且仅一个)任务。</li><li>当一个函数变得太长、太复杂或难以理解时，可以将其分解为多个子函数。这就是所谓的<strong>重构refactoring</strong>。</li></ul><h2 id="2-6-空白与基本格式"><a href="#2-6-空白与基本格式" class="headerlink" title="2.6 空白与基本格式"></a>2.6 空白与基本格式</h2><h3 id="空白"><a href="#空白" class="headerlink" title="空白"></a>空白</h3><p><strong>空白Whitespace</strong>：是一个术语，指的是用于格式化目的的字符。在c++中，这主要指<strong>空格</strong>、<strong>制表符(tab)</strong>和<strong>换行</strong>。c++编译器通常会忽略空白，只有少数例外(在处理文本时)。因此，<strong>我们说c++是一种与空白无关的语言。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*下面这三个都是一样的作用*/</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>               &lt;&lt;            <span class="string">"Hello world!"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span></span><br><span class="line">&lt;&lt; <span class="string">"Hello world!"</span>;</span><br></pre></td></tr></table></figure><p>【注意】</p><ul><li>在<strong>文本</strong>中，不允许换行：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这种是不被允许的</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello</span></span><br><span class="line"><span class="string">    world!"</span> ;</span><br></pre></td></tr></table></figure><ul><li><p>但是这种情况是可以的：文本只是被空白(空格、制表符(tab)、换行)分离，他将会被连接：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的hello与world都是被双引号包含起来的</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello "</span></span><br><span class="line">     <span class="string">"world!"</span>; <span class="comment">// prints "Hello world!"</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h3><ol><li><p><strong>缩进(indentation)</strong>可以用：<strong>空格spaces</strong>或者<strong>tabs（制符表）</strong>。</p><blockquote><p>如果用制符表，建议将其调整为4个空格的缩进，3个也可以。</p></blockquote></li><li><p><strong>大花括号（brace）</strong>：</p><ul><li><p>Google中的C++风格：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>另一种风格：这一种不容易出错，更容易找出花括号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在大花括号中的每条语句，应该从其所在花括号算起隔开一个tab的距离，开始写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!\n"</span>;       <span class="comment">// tabbed in one tab (4 spaces)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Nice to meet you.\n"</span>;  <span class="comment">// tabbed in one tab (4 spaces)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>每一行的字符不要过长，一般不超过80个字符</p></li><li><p>如果一行别操作符(如，&lt;&lt; 、+)分割(split)。这个操作符应该被卸载下一行的开头：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">3</span> + <span class="number">4</span></span><br><span class="line">    + <span class="number">5</span> + <span class="number">6</span></span><br><span class="line">    * <span class="number">7</span> * <span class="number">8</span>;</span><br></pre></td></tr></table></figure></li><li><p>通过对齐值或注释或在代码块之间添加间距，使用空白使代码更易于阅读。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不易读</span></span><br><span class="line">cost = <span class="number">57</span>;</span><br><span class="line">pricePerItem = <span class="number">24</span>;</span><br><span class="line">value = <span class="number">5</span>;</span><br><span class="line">numberOfItems = <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//易读</span></span><br><span class="line">cost          = <span class="number">57</span>;</span><br><span class="line">pricePerItem  = <span class="number">24</span>;</span><br><span class="line">value         = <span class="number">5</span>;</span><br><span class="line">numberOfItems = <span class="number">17</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不易读</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!\n"</span>; <span class="comment">// cout lives in the iostream library</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"It is very nice to meet you!\n"</span>; <span class="comment">// these comments make the code hard to read</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Yeah!\n"</span>; <span class="comment">// especially when lines are different lengths</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//易读</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!\n"</span>;                  <span class="comment">// cout lives in the iostream library</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"It is very nice to meet you!\n"</span>;  <span class="comment">// these comments are easier to read</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Yeah!\n"</span>;                         <span class="comment">// especially when all lined up</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不易读</span></span><br><span class="line"><span class="comment">// cout lives in the iostream library</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!\n"</span>;</span><br><span class="line"><span class="comment">// these comments make the code hard to read</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"It is very nice to meet you!\n"</span>;</span><br><span class="line"><span class="comment">// especially when all bunched together</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Yeah!\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//易读</span></span><br><span class="line"><span class="comment">// cout lives in the iostream library</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!\n"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// these comments are easier to read</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"It is very nice to meet you!\n"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// when separated by whitespace</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Yeah!\n"</span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-7-提前声明与定义"><a href="#2-7-提前声明与定义" class="headerlink" title="2.7 提前声明与定义"></a>2.7 提前声明与定义</h2><p>一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of 3 and 4 is: "</span> &lt;&lt; add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在vs 2013中运行，会出现：</p><p><code>add.cpp(5) : error C3861: &#39;add&#39;: identifier not found</code></p><p><strong>原因：</strong>因为编译器是按照顺序进行编译的。当编译器在main函数的第5行中调用add函数，他不知道add是什么。因为目前为止还没有定义add函数（因为add函数的定义在第9行）</p><hr><p><strong>如何解决呢？</strong></p><ol><li><p>法一：<strong>调整代码顺序</strong>：让被调用的函数在调用者之前【在复杂程序中，不实用】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of 3 and 4 is: "</span> &lt;&lt; add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>如果在一个复杂的程序中，会调用很多函数，还有嵌套型的调用。如果去一个个个去找出调用顺序，然后去调整代码。这样是很乏味低效的。</strong></p></blockquote></li><li><p>法二<strong>[推荐]</strong>：<strong>提前声明forward declaration</strong>：在使用函数之前，先声明它。（然后就不用关注代码实现的顺序了）</p><blockquote><p>提前向声明<strong>允许我们在实际定义标识符之前告诉编译器标识符的存在。</strong></p></blockquote><p>为了编写一个函数的提前向声明，我们使用一个称为<strong>函数原型(function prototype)</strong>的声明语句。函数原型包括：函数的 返回<strong>类型</strong>、<strong>名字</strong>、<strong>形参</strong>，以<strong>分号(semicolon)</strong>结束。但是不包含函数<strong>主体(function body)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="comment">// forward declaration of add() (using a function prototype)</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of 3 and 4 is: "</span> &lt;&lt; add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// this works because we forward declared add() above</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// even though the body of add() isn't defined until here</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="忘记定义函数主题"><a href="#忘记定义函数主题" class="headerlink" title="忘记定义函数主题"></a>忘记定义函数主题</h3><ol><li><p>如果<strong>声明</strong>了函数，但<strong>没定义</strong>函数，而且这个函数<strong>没有被调用</strong>，那么这个程序<strong>可以被编译&amp;运行</strong>；</p></li><li><p>如果<strong>声明</strong>了函数，但<strong>没定义</strong>函数，而且而且这个函数<strong>有被调用</strong>，那么这个程序<strong>可以被编译</strong>，但<strong>链接会出错</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="comment">// forward declaration of add() using function prototype</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of 3 and 4 is: "</span> &lt;&lt; add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// note: No definition for function add</span></span><br></pre></td></tr></table></figure><p>上面程序在visual studio 中，会出现：编译成功，链接失败</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Compiling...</span><br><span class="line">add.cpp</span><br><span class="line">Linking...</span><br><span class="line">add.obj : error LNK2001: unresolved external symbol &quot;int __cdecl add(int,int)&quot; (?add@@YAHHH@Z)</span><br><span class="line">add.exe : fatal error LNK1120: 1 unresolved externals</span><br></pre></td></tr></table></figure></li></ol><h3 id="声明-VS-定义"><a href="#声明-VS-定义" class="headerlink" title="声明 VS. 定义"></a>声明 VS. 定义</h3><ul><li><p><strong>定义(define)</strong>：实现(函数或类型）或者是 实例化(对于变量）标识符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// implements function add()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> z&#123; x + y &#125;; <span class="comment">// instantiates variable z</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于<strong>链接器(linker)</strong>来说<strong>定义（define）</strong>是必要的的。</p></blockquote></li></ul><h4 id="单定义规则"><a href="#单定义规则" class="headerlink" title="单定义规则"></a>单定义规则</h4><p><strong>单定义规则（one definition rule）</strong>简称：<strong>ODR</strong>：在C++中非常有名的规则，主要分三部分：</p><ol><li><p>在给定的文件中（这里翻译不准确），每个函数、对象、类型、模板<u>只能有一次定义</u>。</p></li><li><p>在整个程序中，一个对象或者函数只能被定义一次；</p></li><li><p>类型、模板、内置函数、变量 被允许在不同的文件中有相同的定义。</p><hr></li></ol><p><strong>违背第1条，将会使编译器发出重新定义错误；</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// violation part1 of ODR, we've already defined function add</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> x; <span class="comment">// violation of ODR, we've already defined x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在visual studio中，会出现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">project3.cpp(9): error C2084: function &#39;int add(int,int)&#39; already has a body</span><br><span class="line">project3.cpp(3): note: see previous definition of &#39;add&#39;</span><br><span class="line">project3.cpp(16): error C2086: &#39;int x&#39;: redefinition</span><br><span class="line">project3.cpp(15): note: see declaration of &#39;x&#39;</span><br></pre></td></tr></table></figure></li></ul><p><strong>违背第2条，将会使连接器发出重新定义的错误；</strong></p><p><strong>违背第3条，将会产生未定义的行为。</strong></p><hr><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p><strong>声明(declaration)</strong>：是一个语句。它告诉编译器这里存在一个标识符和它的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="comment">// tells the compiler about a function named "add" that takes two int parameters and returns an int.  No body!</span></span><br><span class="line"><span class="keyword">int</span> x; <span class="comment">// tells the compiler about an integer variable named x</span></span><br></pre></td></tr></table></figure><blockquote><p>对<strong>编译器(complier)</strong>而言<strong>声明(declaeation)</strong>是必要的。</p></blockquote><p>在C++中，所有的<strong>定义</strong>也用作<strong>声明</strong>。上述例子中的<code>int x</code>是 定义，也是声明。</p><p>多数情况下，<strong>定义</strong>符合我们的目的，因为定义能同时满足“编译器”和“链接器”的要求。</p><hr><p><red>【所有的<strong>定义</strong>都是<strong>声明</strong>，但所有的<strong>声明</strong>并不一定是<strong>定义</strong>。这些不是定义的声明有一个名字：<u><strong>纯声明(pure declarations)</strong></u>】</red></p><ul><li>一个典型的例子就是：<u>函数原型(function prototype)</u>，它满足编译器的要求，但不满足链接器的要求。</li><li>其他类型的纯声明包含：提前声明变量 和 类型声明。</li></ul><p><strong>单定义规则不适用于纯声明。</strong>所以，你可以对一些标识符声明n多次都可以（虽然声明n次，会有很多次是冗余的）</p><hr><p>小结：</p><p>在很多编程语言中，“声明”就是指“纯声明”；“定义”就是指“定义也可以用于声明”。所以，<code>int x;</code>是一个定义（虽然他既是定义，也是声明）</p><h2 id="2-9-命名冲突-amp-命名空间"><a href="#2-9-命名冲突-amp-命名空间" class="headerlink" title="2.9 命名冲突&amp;命名空间"></a>2.9 命名冲突&amp;命名空间</h2><h3 id="命名冲突"><a href="#命名冲突" class="headerlink" title="命名冲突"></a>命名冲突</h3><p><strong>命名冲突：naming collision</strong> (or <strong>naming conflict</strong>).</p><blockquote><p>将两个同名的标识符放在同一个程序中，编译器或者链接器无法区分它们时，就会报错。这种情况就是：<strong>命名冲突</strong></p></blockquote><p>例如：</p><blockquote><p>a.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFcn</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>main.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFcn</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> * x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当编译器编译这个程序时，它将会<strong>单独的</strong>编译<em>a.cpp</em>和<em>main.cpp</em>，每个cpp文件都编译成功。但是，当链接时，链接器将会链接<em>a.cpp</em>和<em>main.cpp</em>中所有的定义到一起，此时就发现函数<em>myFun</em>命名冲突了。【注意，虽然函数<em>myFun</em>没有被调用，但在链接时还是会出错】</p><p>命名冲突一般出现在以下两种情况：</p><ol><li>一个函数(或全局变量)的两个(或多个)定义被引入到不同的文件中，这些文件被编译到同一个程序中。这将导致一个<strong>链接器错误</strong>，如上所示。</li><li>一个函数(或全局变量)的两个(或多个)定义被引入到同一个文件中(通常通过#include)。这将导致<strong>编译器错误</strong>。</li></ol><p>对于<strong>局部变量</strong>，C++提供一种局部范围的机制，它使定义在函数内部的局部变量不会冲突。但这种机制对于函数的名字无效。</p><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p><strong>命名空间：namespace</strong></p><p><strong>命名空间：</strong>之所以出来这样一个东西，是因为人类可用的单词数太少，并且不同的人写的程序不可能所有的变量都没有重名现象，对于库来说，这个问题尤其严重，如果两个人写的库文件中出现同名的变量或函数(不可避免)，使用起来就有问题了。为了解决这个问题，引入了名字空间这个概念，通过使用 namespace xxx；你所使用的库函数或变量就是在该名字空间中定义的，这样一来就不会引起不必要的冲突了。</p><blockquote><p>注意，在同一命名空间中，所有的名字必须是独一无二的。</p></blockquote><h4 id="全局命名空间"><a href="#全局命名空间" class="headerlink" title="全局命名空间"></a>全局命名空间</h4><p>在C++中，任何没有定义在 类、函数、或 命名空间 的名字，都被默认的归为“<strong>全局命名空间(global namespace)</strong>”，有时也叫“<strong>全局范围(global scope)</strong>”</p><h4 id="std-命名空间"><a href="#std-命名空间" class="headerlink" title="std 命名空间"></a>std 命名空间</h4><p>在最初设计c++时，c++标准库中的所有标识符(包括std::cin和std::cout)都可以在没有std::前缀的情况下使用(它们是全局命名空间的一部分)。</p><p>但是，这意味着标准库中的任何标识符都可能与你自己定义的标识符的名字(也在全局名称空间中定义)发生冲突。</p><p>为了避免这种冲突，C++将所有标准库中的所有函数都移入一个叫做<strong>“std(是standard的简称)”的命名空间</strong>，即：<strong>std namespace</strong></p><blockquote><p>所以，你看到的<em>std::cout</em>，这并不是它的名字，它实际上只是<em>cout</em>，<em>std</em>只是命名空间的名字，而<em>cout</em>是std namespace中的一部分。</p></blockquote><p><strong>【注】：如果你使用一个命名空间中的标识符，你必须告诉编译器，这个标识符是在这个命名空间内。</strong></p><hr><ol><li><p><strong>显示的命名空间限定符 std::</strong></p><p>最直接的方法是：告诉编译器我们使用<em>cout</em>是来自 <em>std</em>这个namespace(命名空间)的。可以使用前缀 “std::” 来完成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!"</span>; <span class="comment">// when we say cout, we mean the cout defined in the std namespace</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>‘::’</strong> 是一个操作符，叫做<strong>“作用域解析符(scope resolution operator)”</strong>。</p><p>在它左边的标识符表示：所在命名空间的名称；在它右边的标识符表示：这个命名空间的一个 标识符。</p><p>【注】如果“::”的左边没有东西，则默认为它在<strong>全局命名空间( global namespace )</strong>中。</p></blockquote><p>std::cout就表示<em>cout</em>是在 std namsoace 中。</p></li></ol><ol start="2"><li><p><strong>using namespace std</strong></p><p>另一种方法是：用<strong>使用指令(using directive)**</strong><code>using namespace std</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">// this is a using directive telling the compiler to check the std namespace when resolving identifiers with no prefix</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!"</span>; <span class="comment">// cout has no prefix, so the compiler will check to see if cout is defined locally or in namespace std</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>using directive</strong>：告诉编译器 当试图解析一个没有使用<u>命名空间前缀(namespace prefix)</u>的标识符时，检查一个指定的命名空间。</p></blockquote><p><strong>【不推荐此方法】</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // imports the declaration of std::cout</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">// makes std::cout accessible as "cout"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cout</span><span class="params">()</span> <span class="comment">// declares our own "cout" function</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, world!"</span>; <span class="comment">// Compile error!  Which cout do we want here?  The one in the std namespace or the one we defined above?</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况，将不会被编译。因为编译器不知道我们到底想用我们自己定义的cout函数，还是想用 std命名空间 中的cout函数。</p><p>并且，虽然标识符名称现在可能不冲突，但在将来的语言修订中，它可能与添加到std名称空间的新标识符发生冲突。</p></li></ol><h2 id="2-10-预处理器"><a href="#2-10-预处理器" class="headerlink" title="2.10 预处理器"></a>2.10 预处理器</h2><p>在编译之前，代码要经过一个阶段，叫做“<strong>翻译(translation)</strong>”。在翻译阶段会发生许多事情，以使您的代码准备好被编译(如果您感兴趣，可以在<a href="https://en.cppreference.com/w/cpp/language/translation_phases" target="_blank" rel="noopener">这里</a>找到翻译阶段的列表)。应用翻译的代码文件称为<strong>翻译单元(translation unit)</strong>。</p><p>最值得注意的是：翻译阶段包含<strong>预处理器(preprocessor)</strong>。最好将预处理器看作是一个单独的程序，它处理每个代码文件中的文本部分。</p><p>当预处理器运行时，它从头到尾的扫描源码文件，寻找预处理程序指令。</p><blockquote><p><strong>预处理指令(preprocessor directives)，也称作directives</strong>：<u>是以“#”符号开始，以换行符结束的指令(不是分号，即不要加分号)</u>。</p></blockquote><ul><li><strong>“使用指令(using directives)”</strong>不是预处理指令，所以不会被预处理器处理。所以当提起“directive”，通常指的是“preprocessor directive”</li></ul><h4 id="include"><a href="#include" class="headerlink" title="include"></a>include</h4><p>当你<em>#include*一个文件，预处理器将会把</em>#include*指令 替换为 include file的内容。（include file 的内容将会被预处理，然后被编译）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, world!"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当预处理器运行时，预处理器将会把<code>#include &lt;iostream&gt;</code>替换为 名为“iostream”的文件。</p></blockquote><h4 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h4><p><strong>宏定义：Macro defines</strong></p><p><em>#include</em> 指令可以用来创建<strong>宏</strong>。在C++中，<strong>宏</strong>是定义如何将 ‘输入文本’ 转换为 ‘替换输出文本’。</p><p>宏有两种基本类型：1️⃣<strong>对象式宏</strong>(<em>object-like macros</em>)。2️⃣<strong>函数式宏</strong>( <em>function-like macros</em>)</p><ol><li><p>函数式宏</p><p>函数式宏的作用类似于函数，并具有类似的用途。</p></li><li><p>对象式宏</p><p>可以被定义成以下两种形式：</p><ul><li><p>#define identifier</p></li><li><p>#define identifier substitution_text</p><blockquote><p>此处，identifier：宏名【一般是大写字母，用下划线表示空格】；substitution_text：替换文本(替换输出文本)</p></blockquote></li></ul><p>1.带有输出文本(substitution_text)：当预处理器处理此条指令时，宏名 将会被替换为‘输出文本’。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_NAME <span class="meta-string">"Alex"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"My name is: "</span> &lt;&lt; MY_NAME;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预处理程序将上述转换为以下内容:</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"My name is: "</span> &lt;&lt; <span class="string">"Alex"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.不带输出文本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USE_YEN</span></span><br></pre></td></tr></table></figure><p>如你所想，这条宏指令工作方式：标识符的任何进一步出现都将被删除，并将被nothing替换!</p></li></ol><h4 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h4><p><strong>条件编译：conditional compilation</strong></p><p>使用<strong>条件编译的预处理指令</strong>可以设置在什么条件下编译，什么条件下不编译。比较常见的条件编译指令有以下三个：<em>#ifdef*、</em>#ifndef<em>、</em>#endif*</p><ul><li><p><strong><em>#ifdef</em></strong> 预处理指令允许预处理器检查这个标识符(identifier)是否已经被 #define(定义了)。如果被定义，那么在<em>#ifdef*和</em>#endif*之间的代码将会被编译；如果没被定义，这些代码将会被忽略。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_JOE</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PRINT_JOE</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Joe\n"</span>; <span class="comment">// if PRINT_JOE is defined, compile this code</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PRINT_BOB</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Bob\n"</span>; <span class="comment">// if PRINT_BOB is defined, compile this code</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><em>ifndef</em></strong>指令和<em>ifdef*指令的作用是相反的。即，如果这个标识符没有被 #define，那么在</em>#ifndef<em>和</em>#endif*之间的代码才会被编译</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PRINT_BOB</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Bob\n"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是“Bob”,因为PRINT_BOB没有被 #define，所有才会执行。</p></li><li><p><strong><em>#if 0</em></strong> ：条件编译的另一个常见用法是使用<em>#if 0</em>来排除正在编译的代码块(就像它在一个注释块中一样):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Joe\n"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0 <span class="comment">// Don't compile anything starting here</span></span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Bob\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Steve\n"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// until this point</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>【注】<strong>对象式宏</strong>不会影响<strong>预处理器的其他指令</strong></p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO 9 <span class="comment">// Here's a macro substitution</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> FOO <span class="comment">// This FOO does not get replaced because it’s part of another preprocessor directive</span></span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; FOO; <span class="comment">// This FOO gets replaced with 9 because it's part of the normal code</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="宏定义的范围"><a href="#宏定义的范围" class="headerlink" title="宏定义的范围"></a>宏定义的范围</h4><p>指令在编译之前，从上到下逐个文件地解析。</p><ol><li><strong>同一文件中</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_NAME <span class="meta-string">"Alex"</span></span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"My name is: "</span> &lt;&lt; MY_NAME;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然，上面的代码表面上看起来：<em>#define MY_NAME “Alex”</em>是定义在函数<em>foo</em>内部的。<strong>但是预处理器将不会注意，因为它不懂C++中的概念，例如函数。所以，这个程序的执行流程与#define MY_NAME “Alex”在函数foo之前或之后定义的行为相同。</strong>但是，一般情况下，我们习惯于将 <code>#define identifiers</code>这种宏定义放在函数的外面。</p><ol start="2"><li><strong>同一项目的不同文件中</strong></li></ol><p>预处理程序完成后，将丢弃该文件中定义的所有标识符。这意味着指令仅从<strong>定义点</strong>到<strong>定义它们的文件末尾</strong>有效。<u>在一个代码文件中定义的指令不会影响同一项目中的其他代码文件。</u></p><p>example：</p><p><code>function.cpp:</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PRINT</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Printing!"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PRINT</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Not printing!"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>; <span class="comment">// forward declaration for function doSomething()</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    doSomething();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行的结果是：Not printing!</p><p><strong>因为文件之间的宏定义互不影响。</strong></p><h2 id="2-11-头文件"><a href="#2-11-头文件" class="headerlink" title="2.11 头文件"></a>2.11 头文件</h2><p><strong>头文件：Header files</strong></p><p>当程序变得越来越大了，对每个函数都进行提前声明是很乏味无趣的。如果能够将所有的 提前声明 放在一个地方，然后在需要时导入它们，这不是很好吗?</p><blockquote><p><strong>code files</strong>：<strong>源文件(后缀 .cpp)</strong>；<strong>header files</strong>：<strong>头文件(后缀 .h 或 .hpp)</strong></p></blockquote><p>头文件的主要用途就是：将 声明 引入 源文件 中。</p><h4 id="使用标准库头文件"><a href="#使用标准库头文件" class="headerlink" title="使用标准库头文件"></a>使用标准库头文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, world!"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序使用<em>std::cout</em>。但是这个程序没有提供关于<em>std::cout</em>的声明或者定义，那编译器是如何知道<em>std::cout</em>是什么呢？</p><p>答：因为<em>std::cout<em>在头文件“iostream” 中 已经提前声明过了。当我们<code>#include &lt;iostream&gt;</code>时，我们就请求预处理器将头文件“iostream”中的所有内容(当然也包含</em>std::cout</em>)都复制过来。</p><blockquote><p><strong>注意：</strong><red>当<code>#include xxx</code>时，xxx头文件的所有内容都被引入到当前文件中。</red></p></blockquote><p><strong>头文件通常只包含：函数和对象的声明，不包含它们的定义</strong>。</p><blockquote><p>如 <em>std::cout</em>在头文件“iostream”中<u>声明</u>， 但 <u>定义</u>为c++标准库的一部分，在链接器阶段自动链接到程序中。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter2/IncludeLibrary.png" alt="IncludeLibrary"></p></blockquote><h4 id="创建自己的头文件"><a href="#创建自己的头文件" class="headerlink" title="创建自己的头文件"></a>创建自己的头文件</h4><p>步骤：</p><ol><li><strong>头文件保护符(header guaed)</strong></li><li>然后添加头文件(后缀 .h)进行声明；相应的也要添加源文件(后缀 .cpp)进行定义。【注意头文件、源文件的名字要一样】</li></ol><p>创建完之后：</p><p><code>add.h</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1) We really should have a header guard here, but will omit it for simplicity (we'll cover header guards in the next lesson)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2) This is the content of the .h file, which is where the declarations go</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="comment">// function prototype for add.h -- don't forget the semicolon!</span></span><br></pre></td></tr></table></figure><p><code>add.cpp</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"add.h"</span> <span class="comment">// Insert contents of add.h at this point.  Note use of double quotes here.【不是标准库的头文件，一般用双引号""】</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of 3 and 4 is "</span> &lt;&lt; add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序的编译、链接过程：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter2/IncludeHeader.png" alt="IncludeHeader"></p><h4 id="头文件的-lt-gt-amp-””"><a href="#头文件的-lt-gt-amp-””" class="headerlink" title="头文件的&lt;&gt;&amp;””"></a>头文件的&lt;&gt;&amp;””</h4><p><strong>尖括号</strong>：<strong>Angled brackets</strong> ，即<strong>&lt;&gt;</strong>。尖括号用来告诉预处理程序我们包含了编译器包含的头文件，所以它应该在<u>系统目录中查找那个头文件</u>。</p><p><strong>双引号</strong>：<strong>double-quotes</strong>，即<strong>“”</strong>。双引号告诉预处理器这是一个用户定义的头文件，所以它应该在当前目录中寻找这个头文件。如果没找到，它会检查其他的包含路径(已指定为compiler/IDE设置的一部分的路径)。如果还是失败的话，它将去系统目录中寻找这个头文件。</p><h4 id="“iostream”没-h-后缀？"><a href="#“iostream”没-h-后缀？" class="headerlink" title="“iostream”没 .h 后缀？"></a>“iostream”没 .h 后缀？</h4><ol><li><p>好奇，为什么“iostream”(或者其他标准库头文件)没有后缀 .h？</p><p>答：因为<em>iostream.h</em>是另一个头文件</p></li><li><p><em>iostream.h</em>与<em>iostream</em>：</p><p>在C++最开始创建的时候，所有标准库都是有 .h 后缀的。但是，后来ANSI委员会修改C++，将所有的标准库放在 <em>std 命名空间</em> 中，进而避免与用户自定义的标识符 冲突。</p><p>但是为题来了，将这些标准库移入<em>std 命名空间</em> 后，以前的程序将无法运行。为了解决这个问题，一个新的头文件：<em>iostream</em>出现，这个新头文件包含了 <em>iostream.h</em>的所有内容。然后，旧的程序依然可以用<code>#include &lt;iostream.h&gt;</code>，新程序就用<code>#include &lt;iostream&gt;</code></p></li></ol><h4 id="头文件路径建议"><a href="#头文件路径建议" class="headerlink" title="头文件路径建议"></a>头文件路径建议</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/myHeader.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../moreHeaders/myOtherHeader.h"</span></span></span><br></pre></td></tr></table></figure><p>这种设置成路径形式的头文件，假设现在路径没问题。但是很有可能在某一天，你的文件位置就不小心的被移动了，这时候就用不了了。</p><p>【建议】将你平常会用到的很多不同的文件放在比较固定的地方，然后在你的 compiler/IDE 这个固定地方的位置。这样当它在当前目录中找不到它们时，它就会去你设置的固定位置找。这通常可以通过在IDE项目设置中设置包含路径或搜索目录来实现。</p><blockquote><p>visual studio设置方法：</p><p>在“解决方案”中，点击project的“属性”，然后看到“VC++目录”中的“包含目录(include directories)”，在这里面添加你要使用的头文件的目录。</p></blockquote><p>这种方法的优点是，如果要更改目录结构，只需更改单个编译器或IDE设置，而不必更改每个代码文件。</p><h2 id="2-12-头文件保护符"><a href="#2-12-头文件保护符" class="headerlink" title="2.12 头文件保护符"></a>2.12 头文件保护符</h2><p><strong>头文件保护符：header guards</strong></p><h3 id="重复定义"><a href="#重复定义" class="headerlink" title="重复定义"></a>重复定义</h3><p><strong>duplicate definition：重复定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变量重定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x; <span class="comment">// this is a definition for variable x</span></span><br><span class="line">    <span class="keyword">int</span> x; <span class="comment">// compile error: duplicate definition</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数重定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> <span class="comment">// this is a definition for function foo</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> <span class="comment">// compile error: duplicate definition</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; foo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种比较容易修复。</p><hr><p>但是在头文件中，很容易出现一个头文件中的定义被include不止一次。这通常发生在 一个头文件 又#include 其他头文件：</p><p><code>square.h</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在头文件中，不建议出现 定义；但是这里为了方便举例</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSquareSides</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>geometry.h</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"square.h"</span></span></span><br></pre></td></tr></table></figure><p><code>main.cpp</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"square.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"geometry.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个程序。首先，在<code>main.cpp</code>中<em>#include square.h</em> ，它(<em>square.h</em>)将<code>getSquareSides</code>函数的定义复制到main.cpp中。然后，<code>main.cpp</code>又<em>#include geometry.h</em> ，它(<em>geometry.h</em>)又包含了<em>square.h</em>，所以也会将<em>square.h</em>中的内容(包括<code>getSquareSides</code>函数)复制到<em>geometry.h</em>，进而也就被复制到<em>main.cpp</em>中。</p><p>所以，当解析完所有的<em>#include</em>之后，main.cpp就变成这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSquareSides</span><span class="params">()</span>  <span class="comment">// from square.h</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSquareSides</span><span class="params">()</span> <span class="comment">// from geometry.h (via square.h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，就会出现重复定义，编译也会出错。每个单独的文件没问题，但是因为main.cpp最终#include了两次square.h的内容，所以我们遇到了问题。如何解决呢？？？答：使用<strong>header guard</strong></p><h3 id="头文件保护符"><a href="#头文件保护符" class="headerlink" title="头文件保护符"></a>头文件保护符</h3><p><strong>头文件保护符(header guard)</strong>是<strong>条件编译(conditional compilation)</strong>的指令，它的形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SOME_UNIQUE_NAME_HERE <span class="comment">//SOME_UNIQUE_NAME_HERE：你可以用任何名字代替它</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOME_UNIQUE_NAME_HERE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里是写关于 声明 的代码</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>当这个头文件被<em>#included</em>时，预处理器检查<code>SOME_UNIQUE_NAME_HERE</code>是否被定义过。</p><ul><li>如果这是我们第一次包含这个头文件，<code>SOME_UNIQUE_NAME_HERE</code>还没有被创建。然后就会定义<code>SOME_UNIQUE_NAME_HERE</code>，而且会包含文件的内容。</li><li>如果这个头文件之前已经被包含到这个文件中，那么<code>SOME_UNIQUE_NAME_HERE</code>是已经被定义过的，而且其内容也以经被包含在这个文件中。所以这个头文件的内容将会被忽略（由于<strong><code>#ifndef</code></strong>）。</li></ul><hr><p><strong>每一个头文件都应该要有头文件保护符</strong>。</p><hr><p><strong>好的头文件保护符命名规则</strong>：</p><p><code>&lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H</code>或者<code>&lt;FILE&gt;_&lt;LARGE RANDOM NUMBER&gt;_H</code>或者<code>&lt;FILE&gt;_&lt;CREATION DATE&gt;_H</code></p><hr><p>请注意，头文件保护的目标是防止<strong>源文件</strong>多次接收到被保护的<strong>头文件</strong>。根据设计，头文件保护<strong>不</strong>会阻止将给定的头文件(一次)包含到单独的源码文件中。这也会导致意想不到的问题：</p><p><code>square.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SQUARE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE_H</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSquareSides</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSquarePerimeter</span><span class="params">(<span class="keyword">int</span> sideLength)</span></span>; <span class="comment">// forward declaration for getSquarePerimeter</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>square.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"square.h"</span>  <span class="comment">// square.h is included once here</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSquarePerimeter</span><span class="params">(<span class="keyword">int</span> sideLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sideLength * getSquareSides();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"square.h"</span> <span class="comment">// square.h is also included once here</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a square has "</span> &lt;&lt; getSquareSides() &lt;&lt; <span class="string">" sides\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a square of length 5 has perimeter length "</span> &lt;&lt; getSquarePerimeter(<span class="number">5</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，square.h包含在main.cpp和square.cpp中。这意味着square.h的内容将被包含一次到square.cpp中，一次到main.cpp中。</p><blockquote><p>细节：</p><p>当<code>square.h</code>被包含在<code>square.cpp</code>中时，在<code>square.cpp</code>结束之前，<code>SQUARE_H</code>都一直被定义。（这阻止了<code>square.h</code>被多次包含于<code>square.cpp</code>。也真是头文件保护符起作用的）。然而，一旦<code>square.cpp</code>结束后，<code>SQUARE_H</code>将不再被定义。这就意味着当预处理器运行<code>main.cpp</code>时，<code>SQUARE_H</code>在<code>main.cpp</code>中最初是没有定义的。</p><p>结果就是，<code>square.cpp</code>和<code>main.cpp</code>都复制了<em>getSquareSides</em>的定义。这个程序将<strong>可以被编译</strong>，但是会<strong>链接出错</strong>（链接器会抱怨为什么会有不止一个的<em>getSquareSides</em>的定义）</p></blockquote><p><strong>最好的解决办法就是：将函数的<u>定义</u>放在源文件中(即 .cpp文件中)，头文件中只含有<u>声明</u>。</strong></p><h3 id="pragma-once"><a href="#pragma-once" class="headerlink" title="#pragma once"></a>#pragma once</h3><p><code>#program once</code>的作用和头文件标识符相同，但是它更加短。</p><blockquote><p>但是，<code>#program once</code>不是C++官方原生的一部分，所以<strong>不是所有的编译器都支持它</strong>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let’s Build A Simple Interpreter-10</title>
      <link href="/archives/2f66ae56.html"/>
      <url>/archives/2f66ae56.html</url>
      
        <content type="html"><![CDATA[<p>今天的改进内容：</p><ol><li>如何进行语法Fenix和解释Pascal的程序头部；</li><li>如何进行语法分析Pascal的变量声明；</li><li>将更新解释器，用<em>DIV</em>关键字来表示整数的出发、用品”<strong>/</strong>“来表示浮点数的除法；</li><li>添加Pascal语言的注释功能</li></ol><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-10/lsbasi_part10_intro.png" alt="img"></p><a id="more"></a><h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p>在进行细致的讲解之前，我们先下载本节的解释器的<a href="https://github.com/rspivak/lsbasi/blob/master/part10/python/spi.py" target="_blank" rel="noopener">源码：spy.py</a>和一个简单的Pascal语言的<a href="https://github.com/rspivak/lsbasi/blob/master/part10/python/part10.pas" target="_blank" rel="noopener">程序：part10.pas</a>。然后再在命令提示符(Windows10系统 可直接在左下角搜索框中搜索“cmd”)中进行输入：<code>python spi.py part10.pas</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-10/image-20200325134921750.png" alt="image-20200325134921750"></p><p>好了。现在来看看今天要改进的内容，我们将学习：</p><ol><li>如何进行语法Fenix和解释Pascal的程序头部；</li><li>如何进行语法分析Pascal的变量声明；</li><li>将更新解释器，用<em>DIV</em>关键字来表示整数的出发、用品”<strong>/</strong>“来表示浮点数的除法；</li><li>添加Pascal语言的注释功能</li></ol><h2 id="更新后的语法规则"><a href="#更新后的语法规则" class="headerlink" title="更新后的语法规则"></a>更新后的语法规则</h2><p>更新后的语法规则，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-10/lsbasi_part10_grammar1.png" alt="lsbasi_part10_grammar1"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-10/lsbasi_part10_grammar2.png" alt="lsbasi_part10_grammar2"></p><blockquote><p>这里给出一个简单地Pascal语言的程序，便于理解其语法：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PROGRAM</span> Part10;</span><br><span class="line"><span class="keyword">VAR</span></span><br><span class="line">   number     : INTEGER;</span><br><span class="line">   a, b, c, x : INTEGER;</span><br><span class="line">   y          : REAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> <span class="comment">&#123;Part10&#125;</span></span><br><span class="line">   <span class="keyword">BEGIN</span></span><br><span class="line">      number := <span class="number">2</span>;</span><br><span class="line">      a := number;</span><br><span class="line">      b := <span class="number">10</span> * a + <span class="number">10</span> * number <span class="keyword">DIV</span> <span class="number">4</span>;</span><br><span class="line">      c := a - - b</span><br><span class="line">   <span class="keyword">END</span>;</span><br><span class="line">   x := <span class="number">11</span>;</span><br><span class="line">   y := <span class="number">20</span> / <span class="number">7</span> + <span class="number">3.14</span>;</span><br><span class="line">   <span class="comment">&#123; writeln('a = ', a); &#125;</span></span><br><span class="line">   <span class="comment">&#123; writeln('b = ', b); &#125;</span></span><br><span class="line">   <span class="comment">&#123; writeln('c = ', c); &#125;</span></span><br><span class="line">   <span class="comment">&#123; writeln('number = ', number); &#125;</span></span><br><span class="line">   <span class="comment">&#123; writeln('x = ', x); &#125;</span></span><br><span class="line">   <span class="comment">&#123; writeln('y = ', y); &#125;</span></span><br><span class="line"><span class="keyword">END</span>.  <span class="comment">&#123;Part10&#125;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="1-program"><a href="#1-program" class="headerlink" title="1. program"></a>1. program</h3><p>程序定义的语法规则，包括：保留字“<strong><em>PROGRAM</em></strong>”、程序的<strong>名字</strong>、一个以点“<strong>.</strong>”结尾的<strong>block</strong>。如：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PROGRAM</span> Part10;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">END</span>.</span><br></pre></td></tr></table></figure><blockquote><p>上面是一个完整的Pascal程序</p></blockquote><h3 id="2-block"><a href="#2-block" class="headerlink" title="2. block"></a>2. block</h3><p>block包含：一个<strong>声明规则</strong>、<strong>复合语句</strong>，如：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例1</span></span><br><span class="line"><span class="keyword">VAR</span></span><br><span class="line">   number : INTEGER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例2</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><h3 id="3-declarations"><a href="#3-declarations" class="headerlink" title="3. declarations"></a>3. declarations</h3><p>Pascal的声明有几个部分，每个部分都是可选的。本节中，我们只讨论变量声明的部分。变量声明规则：要么有一个变量声明的子规则，要么是空的。</p><h3 id="4-VAR"><a href="#4-VAR" class="headerlink" title="4. VAR"></a>4. VAR</h3><p>Pascal是静态类语言，也就是说在使用每一个变量之前，都需要明确的声明它的类型。变量的声明在程序中用<strong>VAR</strong>保留字，如：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">VAR</span></span><br><span class="line">   number     : INTEGER;</span><br><span class="line">   a, b, c, x : INTEGER;</span><br><span class="line">   y          : REAL;</span><br></pre></td></tr></table></figure><h3 id="5-type-spec"><a href="#5-type-spec" class="headerlink" title="5. type_spec"></a>5. type_spec</h3><p>在本节中，数据类型是两种：INTEGER 和 REAL(float)，常出现在变量声明部分：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">VAR</span></span><br><span class="line">   a : INTEGER;</span><br><span class="line">   b : REAL;</span><br></pre></td></tr></table></figure><blockquote><p>本节中没有进行设计类型检查，这将会在后续文章中添加</p></blockquote><h3 id="6-term"><a href="#6-term" class="headerlink" title="6. term"></a>6. term</h3><p>term规则更新之后，将整数、浮点数的出发分开表示：DIV、/</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span> / <span class="number">7</span> = <span class="number">2.85714285714</span> <span class="comment">//浮点数出发</span></span><br><span class="line"><span class="number">20</span> <span class="keyword">DIV</span> <span class="number">7</span> = <span class="number">2</span>           <span class="comment">//整数除法</span></span><br></pre></td></tr></table></figure><h3 id="7-factor"><a href="#7-factor" class="headerlink" title="7. factor"></a>7. factor</h3><p>更新之后可以处理整数、浮点数的常量。</p><hr><p>以下是今天的完整语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">program : PROGRAM variable SEMI block DOT</span><br><span class="line"></span><br><span class="line">block : declarations compound_statement</span><br><span class="line"></span><br><span class="line">declarations : VAR (variable_declaration SEMI)+</span><br><span class="line">             | empty</span><br><span class="line"></span><br><span class="line">variable_declaration : ID (COMMA ID)* COLON type_spec</span><br><span class="line"></span><br><span class="line">type_spec : INTEGER | REAL</span><br><span class="line"></span><br><span class="line">compound_statement : BEGIN statement_list END</span><br><span class="line"></span><br><span class="line">statement_list : statement</span><br><span class="line">               | statement SEMI statement_list</span><br><span class="line"></span><br><span class="line">statement : compound_statement</span><br><span class="line">          | assignment_statement</span><br><span class="line">          | empty</span><br><span class="line"></span><br><span class="line">assignment_statement : variable ASSIGN expr</span><br><span class="line"></span><br><span class="line">empty :</span><br><span class="line"></span><br><span class="line">expr : term ((PLUS | MINUS) term)*</span><br><span class="line"></span><br><span class="line">term : factor ((MUL | INTEGER_DIV | FLOAT_DIV) factor)*</span><br><span class="line"></span><br><span class="line">factor : PLUS factor</span><br><span class="line">       | MINUS factor</span><br><span class="line">       | INTEGER_CONST</span><br><span class="line">       | REAL_CONST</span><br><span class="line">       | LPAREN expr RPAREN</span><br><span class="line">       | variable</span><br><span class="line"></span><br><span class="line">variable: ID</span><br></pre></td></tr></table></figure><h2 id="更新Lexer"><a href="#更新Lexer" class="headerlink" title="更新Lexer"></a>更新Lexer</h2><p>总结一下，lexer的改变：</p><ol><li>新的tokens</li><li>新的保留字</li><li>添加处理Pascal语言的注释，用<em>skip_comment</em></li><li>更新<em>integer</em></li><li>更新<em>get_next_token</em> ，使其能够返回新添加的tokens</li></ol><p>让我们深入研究一下上面提到的变化:</p><ol><li><p>为了处理程序头、变量的声明、整数与浮点数常量以及它们的除法。我们需要添加新的tokens，我们还需要更新“INTEGER”的含义：表示一个整数类型，而不是一个整数常量。</p><p>下面是更新后全部的<strong>tokens</strong>:</p><ul><li>PROGRAM (reserved keyword)</li><li>VAR (reserved keyword)</li><li>COLON (:)</li><li>COMMA (,)</li><li>INTEGER (we change it to mean integer type and not integer constant like 3 or 5)</li><li>REAL (for Pascal REAL type)</li><li>INTEGER_CONST (for example, 3 or 5)</li><li>REAL_CONST (for example, 3.14 and so on)</li><li>INTEGER_DIV for integer division (the <strong><em>DIV</em></strong> reserved keyword)</li><li>FLOAT_DIV for float division ( forward slash / )</li></ul></li><li><p>全部的<strong>保留字</strong>token：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RESERVED_KEYWORDS = &#123;</span><br><span class="line">    <span class="string">'PROGRAM'</span>: Token(<span class="string">'PROGRAM'</span>, <span class="string">'PROGRAM'</span>),</span><br><span class="line">    <span class="string">'VAR'</span>: Token(<span class="string">'VAR'</span>, <span class="string">'VAR'</span>),</span><br><span class="line">    <span class="string">'DIV'</span>: Token(<span class="string">'INTEGER_DIV'</span>, <span class="string">'DIV'</span>),</span><br><span class="line">    <span class="string">'INTEGER'</span>: Token(<span class="string">'INTEGER'</span>, <span class="string">'INTEGER'</span>),</span><br><span class="line">    <span class="string">'REAL'</span>: Token(<span class="string">'REAL'</span>, <span class="string">'REAL'</span>),</span><br><span class="line">    <span class="string">'BEGIN'</span>: Token(<span class="string">'BEGIN'</span>, <span class="string">'BEGIN'</span>),</span><br><span class="line">    <span class="string">'END'</span>: Token(<span class="string">'END'</span>, <span class="string">'END'</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>处理<strong>注释</strong>，添加一个<em>skip_comment</em> 函数来处理注释，它的原理就是在找到右花括号“｛”之前，丢弃所有字符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">skip_comment</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> self.current_char != <span class="string">'&#125;'</span>:</span><br><span class="line">        self.advance()</span><br><span class="line">    self.advance()  <span class="comment"># the closing curly brace</span></span><br></pre></td></tr></table></figure></li><li><p>重新命名<strong><em>integer</em>函数</strong>为<strong><em>number</em>函数</strong>，，使其能够处理整型常量和浮点型常量，如3和3.14：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">number</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Return a (multidigit) integer or float consumed from the input."""</span></span><br><span class="line">    result = <span class="string">''</span></span><br><span class="line">    <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">        result += self.current_char</span><br><span class="line">        self.advance()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.current_char == <span class="string">'.'</span>:</span><br><span class="line">        result += self.current_char</span><br><span class="line">        self.advance()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (</span><br><span class="line">            self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span></span><br><span class="line">            self.current_char.isdigit()</span><br><span class="line">        ):</span><br><span class="line">            result += self.current_char</span><br><span class="line">            self.advance()</span><br><span class="line"></span><br><span class="line">        token = Token(<span class="string">'REAL_CONST'</span>, float(result))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        token = Token(<span class="string">'INTEGER_CONST'</span>, int(result))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> token</span><br></pre></td></tr></table></figure></li><li><p>更新<strong><em>get_next_token</em>函数</strong>，使其能够返回新增的tokens：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> self.current_char == <span class="string">'&#123;'</span>:</span><br><span class="line">            self.advance()</span><br><span class="line">            self.skip_comment()</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> self.current_char.isdigit():</span><br><span class="line">            <span class="keyword">return</span> self.number()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.current_char == <span class="string">':'</span>:</span><br><span class="line">            self.advance()</span><br><span class="line">            <span class="keyword">return</span> Token(COLON, <span class="string">':'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.current_char == <span class="string">','</span>:</span><br><span class="line">            self.advance()</span><br><span class="line">            <span class="keyword">return</span> Token(COMMA, <span class="string">','</span>)</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> self.current_char == <span class="string">'/'</span>:</span><br><span class="line">            self.advance()</span><br><span class="line">            <span class="keyword">return</span> Token(FLOAT_DIV, <span class="string">'/'</span>)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></li></ol><h2 id="更新Parser"><a href="#更新Parser" class="headerlink" title="更新Parser"></a>更新Parser</h2><p>总结Parser的变化：</p><ol><li>新的<strong>抽象语法树结点（AST nodes）</strong>：<em>Program</em>, <em>Block</em>, <em>VarDecl</em>, <em>Type</em></li><li>对应新的语法规则的函数：<em>block</em>, <em>declarations</em>, <em>variable_declaration</em>, 和 <em>type_spec</em>.</li><li>更新已经存在的paeser中的方法：<em>program</em>, <em>term</em>, and <em>factor</em></li></ol><p>让我们深入研究一下上面提到的变化:</p><ol><li><p>新的<strong>AST nodes</strong>：</p><ul><li><p><em>Program</em> AST node：表示一个程序，也是我们的根节点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Program</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, block)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.block = block</span><br></pre></td></tr></table></figure></li><li><p><em>Block</em> AST node：包含声明与复合语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Block</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, declarations, compound_statement)</span>:</span></span><br><span class="line">        self.declarations = declarations</span><br><span class="line">        self.compound_statement = compound_statement</span><br></pre></td></tr></table></figure></li><li><p><em>VarDecl</em> AST node：表示一个变量声明，它包含一个边梁节点和变量的类型结点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VarDecl</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, var_node, type_node)</span>:</span></span><br><span class="line">        self.var_node = var_node</span><br><span class="line">        self.type_node = type_node</span><br></pre></td></tr></table></figure></li><li><p><em>Type</em> AST node：表示一个变量类型（INTEGER or REAL）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Type</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, token)</span>:</span></span><br><span class="line">        self.token = token</span><br><span class="line">        self.value = token.value</span><br></pre></td></tr></table></figure></li></ul></li><li><p>对应<strong>新增的语法规则的函数(方法)</strong>：<em>block</em>, <em>declarations</em>, <em>variable_declaration</em>, 和 <em>type_spec</em>.【这些方法负责解析新的语言结构和构造新的AST nodes】：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">block</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""block : declarations compound_statement"""</span></span><br><span class="line">    declaration_nodes = self.declarations()</span><br><span class="line">    compound_statement_node = self.compound_statement()</span><br><span class="line">    node = Block(declaration_nodes, compound_statement_node)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">declarations</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""declarations : VAR (variable_declaration SEMI)+</span></span><br><span class="line"><span class="string">                    | empty</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    declarations = []</span><br><span class="line">    <span class="keyword">if</span> self.current_token.type == VAR:</span><br><span class="line">        self.eat(VAR)</span><br><span class="line">        <span class="keyword">while</span> self.current_token.type == ID:</span><br><span class="line">            var_decl = self.variable_declaration()</span><br><span class="line">            declarations.extend(var_decl)</span><br><span class="line">            self.eat(SEMI)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> declarations</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">variable_declaration</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""variable_declaration : ID (COMMA ID)* COLON type_spec"""</span></span><br><span class="line">    var_nodes = [Var(self.current_token)]  <span class="comment"># first ID</span></span><br><span class="line">    self.eat(ID)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> self.current_token.type == COMMA:</span><br><span class="line">        self.eat(COMMA)</span><br><span class="line">        var_nodes.append(Var(self.current_token))</span><br><span class="line">        self.eat(ID)</span><br><span class="line"></span><br><span class="line">    self.eat(COLON)</span><br><span class="line"></span><br><span class="line">    type_node = self.type_spec()</span><br><span class="line">    var_declarations = [</span><br><span class="line">        VarDecl(var_node, type_node)</span><br><span class="line">        <span class="keyword">for</span> var_node <span class="keyword">in</span> var_nodes</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">return</span> var_declarations</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">type_spec</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""type_spec : INTEGER</span></span><br><span class="line"><span class="string">                 | REAL</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    token = self.current_token</span><br><span class="line">    <span class="keyword">if</span> self.current_token.type == INTEGER:</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.eat(REAL)</span><br><span class="line">    node = Type(token)</span><br><span class="line">    <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure></li><li><p>更新已有的<em>program</em>, <em>term</em>, 和, <em>factor</em> 方法来适应语法的改变：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">program</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""program : PROGRAM variable SEMI block DOT"""</span></span><br><span class="line">    self.eat(PROGRAM)</span><br><span class="line">    var_node = self.variable()</span><br><span class="line">    prog_name = var_node.value</span><br><span class="line">    self.eat(SEMI)</span><br><span class="line">    block_node = self.block()</span><br><span class="line">    program_node = Program(prog_name, block_node)</span><br><span class="line">    self.eat(DOT)</span><br><span class="line">    <span class="keyword">return</span> program_node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""term : factor ((MUL | INTEGER_DIV | FLOAT_DIV) factor)*"""</span></span><br><span class="line">    node = self.factor()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, INTEGER_DIV, FLOAT_DIV):</span><br><span class="line">        token = self.current_token</span><br><span class="line">        <span class="keyword">if</span> token.type == MUL:</span><br><span class="line">            self.eat(MUL)</span><br><span class="line">        <span class="keyword">elif</span> token.type == INTEGER_DIV:</span><br><span class="line">            self.eat(INTEGER_DIV)</span><br><span class="line">        <span class="keyword">elif</span> token.type == FLOAT_DIV:</span><br><span class="line">            self.eat(FLOAT_DIV)</span><br><span class="line"></span><br><span class="line">        node = BinOp(left=node, op=token, right=self.factor())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""factor : PLUS factor</span></span><br><span class="line"><span class="string">              | MINUS factor</span></span><br><span class="line"><span class="string">              | INTEGER_CONST</span></span><br><span class="line"><span class="string">              | REAL_CONST</span></span><br><span class="line"><span class="string">              | LPAREN expr RPAREN</span></span><br><span class="line"><span class="string">              | variable</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    token = self.current_token</span><br><span class="line">    <span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">        self.eat(PLUS)</span><br><span class="line">        node = UnaryOp(token, self.factor())</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">        self.eat(MINUS)</span><br><span class="line">        node = UnaryOp(token, self.factor())</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="keyword">elif</span> token.type == INTEGER_CONST:</span><br><span class="line">        self.eat(INTEGER_CONST)</span><br><span class="line">        <span class="keyword">return</span> Num(token)</span><br><span class="line">    <span class="keyword">elif</span> token.type == REAL_CONST:</span><br><span class="line">        self.eat(REAL_CONST)</span><br><span class="line">        <span class="keyword">return</span> Num(token)</span><br><span class="line">    <span class="keyword">elif</span> token.type == LPAREN:</span><br><span class="line">        self.eat(LPAREN)</span><br><span class="line">        node = self.expr()</span><br><span class="line">        self.eat(RPAREN)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        node = self.variable()</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure></li></ol><p>现在来看看我们的<strong>抽象语法树<em>Abstract Syntax Tree</em></strong>，下面是一个Pascal程序：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PROGRAM</span> Part10AST;</span><br><span class="line"><span class="keyword">VAR</span></span><br><span class="line">   a, b : INTEGER;</span><br><span class="line">   y    : REAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> <span class="comment">&#123;Part10AST&#125;</span></span><br><span class="line">   a := <span class="number">2</span>;</span><br><span class="line">   b := <span class="number">10</span> * a + <span class="number">10</span> * a <span class="keyword">DIV</span> <span class="number">4</span>;</span><br><span class="line">   y := <span class="number">20</span> / <span class="number">7</span> + <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">END</span>.  <span class="comment">&#123;Part10AST&#125;</span></span><br></pre></td></tr></table></figure><p>它的解析树为：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-10/lsbasi_part10_ast-1585124028847.png" alt="lsbasi_part10_ast"></p><p>在图中可以看到我们添加的新节点。</p><h2 id="更新Interpreter"><a href="#更新Interpreter" class="headerlink" title="更新Interpreter"></a>更新Interpreter</h2><p>现在，剩下的就是向解释器类添加新的访问者方法。下面是将要新增的四个访问方法（对应新增的四种结点）：</p><ul><li><em>visit_Program</em></li><li><em>visit_Block</em></li><li><em>visit_VarDecl</em></li><li><em>visit_Type</em></li></ul><ol><li><p>其中对于<em>VarDecl</em>和<em>Type</em>，解释器对他们什么都不做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_Program</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    self.visit(node.block)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_Block</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> declaration <span class="keyword">in</span> node.declarations:</span><br><span class="line">        self.visit(declaration)</span><br><span class="line">    self.visit(node.compound_statement)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_VarDecl</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    <span class="comment"># Do nothing</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_Type</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    <span class="comment"># Do nothing</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li><li><p>更新<em>visit_BinOp</em> 方法，使其能够准确的解释整数和浮点数的除法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_BinOp</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> node.op.type == PLUS:</span><br><span class="line">        <span class="keyword">return</span> self.visit(node.left) + self.visit(node.right)</span><br><span class="line">    <span class="keyword">elif</span> node.op.type == MINUS:</span><br><span class="line">        <span class="keyword">return</span> self.visit(node.left) - self.visit(node.right)</span><br><span class="line">    <span class="keyword">elif</span> node.op.type == MUL:</span><br><span class="line">        <span class="keyword">return</span> self.visit(node.left) * self.visit(node.right)</span><br><span class="line">    <span class="keyword">elif</span> node.op.type == INTEGER_DIV:</span><br><span class="line">        <span class="keyword">return</span> self.visit(node.left) // self.visit(node.right)</span><br><span class="line">    <span class="keyword">elif</span> node.op.type == FLOAT_DIV:</span><br><span class="line">        <span class="keyword">return</span> float(self.visit(node.left)) / float(self.visit(node.right))</span><br></pre></td></tr></table></figure></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下，在本文中，扩展了Pascal解释器的哪些部分：</p><ul><li>添加新的语法规则和更新现有的规则；</li><li>添加新token，并相应地添加新方法去处理这些tokens，更新了现有的方法；</li><li>parser中：为新的语法结构添加新的AST nodes；</li><li>向我们的递归下降解析器添加与新语法规则相对应的新方法，并更新一些现有的方法；</li><li>interpreter中添加新的访问方法，更新了一个现存的访问方法</li></ul><p>我们也出去了一些“HACKS”(part9 中提到的)：</p><ul><li>本文的解释器可以处理程序头部(<strong><em>PROGRAM</em></strong> header)</li><li>变量可以用VAR关键字来声明</li><li>将整数与浮点数的除法分开来</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Let’s Build A Simple Interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LSBASI整理</title>
      <link href="/archives/6fc94bb0.html"/>
      <url>/archives/6fc94bb0.html</url>
      
        <content type="html"><![CDATA[<center><red>持续更新</red></center><a id="more"></a><h2 id="part-3"><a href="#part-3" class="headerlink" title="part 3"></a><a href="https://www.longlongqin.top/archives/f957.html">part 3</a></h2><ul><li>实现了<strong>加减混合运算</strong>，并引入<strong>语法图概念</strong></li></ul><h2 id="part-4"><a href="#part-4" class="headerlink" title="part 4"></a><a href="https://www.longlongqin.top/archives/3b16.html">part 4</a></h2><ul><li>实现了整数的<strong>乘除混合运算</strong>，引入<strong>上下文无关语法(context-free-grammars)，即BNF</strong></li></ul><h2 id="part-5"><a href="#part-5" class="headerlink" title="part 5"></a><a href="https://www.longlongqin.top/archives/173c.html">part 5</a></h2><ul><li>实现了<strong>加减乘除混合运算</strong>，引入<strong>结合律(associativity)</strong>和<strong>优先级(precedence)</strong></li></ul><h2 id="part-6"><a href="#part-6" class="headerlink" title="part 6"></a><a href="https://www.longlongqin.top/archives/167c.html">part 6</a></h2><ul><li>新增<strong>括号运算</strong></li></ul><h2 id="part-7"><a href="#part-7" class="headerlink" title="part 7"></a><a href="https://www.longlongqin.top/archives/5a757a52.html">part 7</a></h2><ul><li>从本小节开始，将<code>interpreter</code>和<code>parser</code>分开来实现。并引入<strong>抽象语法树(AST)</strong>和<strong>解析树(parse tree)</strong>概念</li></ul><h2 id="part-8"><a href="#part-8" class="headerlink" title="part 8"></a><a href="https://www.longlongqin.top/archives/ae12.html">part 8</a></h2><ul><li>新增<strong>一元操作符(unary operators)</strong>：“+”，“-”</li></ul><h2 id="part-9"><a href="#part-9" class="headerlink" title="part 9"></a><a href="https://www.longlongqin.top/archives/8632918.html">part 9</a></h2><h2 id="整体分析"><a href="#整体分析" class="headerlink" title="整体分析"></a>整体分析</h2><p>整体分析，不管是part x，都一起分析，看看他的整体结构：</p><h3 id="Lexer"><a href="#Lexer" class="headerlink" title="Lexer"></a>Lexer</h3><ul><li><p>token类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">INTEGER       = <span class="string">'INTEGER'</span> <span class="comment">#用于表示整数类型</span></span><br><span class="line">REAL          = <span class="string">'REAL'</span>  <span class="comment">#表示浮点型</span></span><br><span class="line">INTEGER_CONST = <span class="string">'INTEGER_CONST'</span> <span class="comment">#整型常量</span></span><br><span class="line">REAL_CONST    = <span class="string">'REAL_CONST'</span>  <span class="comment">#浮点型常量</span></span><br><span class="line">PLUS          = <span class="string">'PLUS'</span></span><br><span class="line">MINUS         = <span class="string">'MINUS'</span></span><br><span class="line">MUL           = <span class="string">'MUL'</span></span><br><span class="line">INTEGER_DIV   = <span class="string">'INTEGER_DIV'</span> <span class="comment">#整型数的除法</span></span><br><span class="line">FLOAT_DIV     = <span class="string">'FLOAT_DIV'</span> <span class="comment">#浮点数的除法</span></span><br><span class="line">LPAREN        = <span class="string">'LPAREN'</span> <span class="comment">#左小括号</span></span><br><span class="line">RPAREN        = <span class="string">'RPAREN'</span> <span class="comment">#右小括号</span></span><br><span class="line">ID            = <span class="string">'ID'</span> <span class="comment">#表示有效的标识符</span></span><br><span class="line">ASSIGN        = <span class="string">'ASSIGN'</span> <span class="comment">#这种token表示两个字符，“:=”,用于赋值语句</span></span><br><span class="line">BEGIN         = <span class="string">'BEGIN'</span> </span><br><span class="line">END           = <span class="string">'END'</span></span><br><span class="line">SEMI          = <span class="string">'SEMI'</span> <span class="comment"># 表示分号，用于标记复合语句中的一个句子的结尾</span></span><br><span class="line">DOT           = <span class="string">'DOT'</span> <span class="comment">#点，用于Pascal语言中program的定义</span></span><br><span class="line">PROGRAM       = <span class="string">'PROGRAM'</span> </span><br><span class="line">VAR           = <span class="string">'VAR'</span></span><br><span class="line">COLON         = <span class="string">'COLON'</span> <span class="comment">#冒号</span></span><br><span class="line">COMMA         = <span class="string">'COMMA'</span> <span class="comment">#逗号</span></span><br><span class="line">EOF           = <span class="string">'EOF'</span></span><br></pre></td></tr></table></figure></li><li><p>保留字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RESERVED_KEYWORDS = &#123;</span><br><span class="line">    <span class="string">'PROGRAM'</span>: Token(<span class="string">'PROGRAM'</span>, <span class="string">'PROGRAM'</span>),</span><br><span class="line">    <span class="string">'VAR'</span>: Token(<span class="string">'VAR'</span>, <span class="string">'VAR'</span>),</span><br><span class="line">    <span class="string">'DIV'</span>: Token(<span class="string">'INTEGER_DIV'</span>, <span class="string">'DIV'</span>),</span><br><span class="line">    <span class="string">'INTEGER'</span>: Token(<span class="string">'INTEGER'</span>, <span class="string">'INTEGER'</span>),</span><br><span class="line">    <span class="string">'REAL'</span>: Token(<span class="string">'REAL'</span>, <span class="string">'REAL'</span>),</span><br><span class="line">    <span class="string">'BEGIN'</span>: Token(<span class="string">'BEGIN'</span>, <span class="string">'BEGIN'</span>),</span><br><span class="line">    <span class="string">'END'</span>: Token(<span class="string">'END'</span>, <span class="string">'END'</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>词法分析器的结构：</p><ol><li><p>有一个<code>___init__</code>的函数，在创建实例的时候，就会自动调用这个方法；</p></li><li><p>一个提示错误的函数<code>error</code>；</p></li><li><p>然后开始处理“词”，这里有一个函数<code>advance</code>用于向前进一步(pos会➕1）：</p><ul><li><p><code>peek</code>：为了在以相同的字符开头时，区分是“保留字”还是“标识符”。</p><blockquote><p>在这里，我们可以在不消耗下一个字符的情况下去查看缓冲区：就是利用peek_pos移动查看下一个字符，而真正的pos不动。</p></blockquote></li><li><p><code>skip_comment</code>：处理注释；</p></li><li><p><code>skip_whitespace</code>：处理空格；</p></li><li><p><code>number</code>：在part10之前，叫做integer，因为现在不仅有整型数据，还有浮点型的。所以改名为number。</p></li><li><p><code>_id</code>：处理“标识符”和“保留字”</p></li></ul></li><li><p><code>get_next_token</code>：词法分析器的核心部分，前面的都是设计，现在才开始识别出一个个的token，下面就是列出识别token的种类：</p><blockquote><p>其实这里叫做：<code>get_token_and_go_next</code>比较直观，这个函数是，先识别出一个token，然后再继续寻找下一个token</p></blockquote><ol><li>左括号token：<strong>“{”</strong></li><li><strong>保留字</strong>token、<strong>标识符</strong>token。（用函数<code>_id()</code>来完成）</li><li><strong>整型变量</strong>token</li><li>赋值符号<strong>“:=”</strong>token</li><li>冒号<strong>“:”</strong>token</li><li>分号<strong>“;”</strong>token</li><li>逗号<strong>“,”</strong>token</li><li><strong>加、减、乘</strong> token</li><li>除法token<ul><li>整数除法：<strong>“DIV”</strong> token</li><li>浮点数除法：<strong>“/”</strong> token</li></ul></li><li>左小括号<strong>“(”</strong> token ； &amp; 右小括号<strong>“)”</strong> token</li><li>点<strong>“.”</strong> token</li></ol></li></ol></li></ul><h3 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h3><p>​ 语法分析，主要是分析词法分析器传过来的一个个token，分析它们之间的运算关系，即语法：</p><p>它们之间的关系，即语法，用<strong>抽象语法树</strong>来表示：</p><ol><li>一个基类：<code>AST</code>。（后面的继承于它）</li><li>一个二元操作符类：<code>BinOp(AST)</code>（表示加减乘除运算）</li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Let&#39;s Build A Simple Interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的云书签</title>
      <link href="/archives/eaabd222.html"/>
      <url>/archives/eaabd222.html</url>
      
        <content type="html"><![CDATA[<p center large><center><green>搜集学习资料&好用的工具</green></center></p><a id="more"></a><hr><h2 id="Ⅰ-CS-学习"><a href="#Ⅰ-CS-学习" class="headerlink" title="Ⅰ CS 学习"></a><red>Ⅰ CS 学习</red></h2><h3 id="00全科资料"><a href="#00全科资料" class="headerlink" title="00全科资料"></a>00全科资料</h3><h4 id="1-面试笔记集合"><a href="#1-面试笔记集合" class="headerlink" title="1. 面试笔记集合"></a>1. 面试笔记集合</h4><table><thead><tr><th>资源</th><th>描述</th></tr></thead><tbody><tr><td><strong><a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">CS-Notes</a></strong>、<a href="https://cyc2018.github.io/CS-Notes/#/" target="_blank" rel="noopener">网页版</a>、【<a href="https://github.com/longlongqin/CS-Notes" target="_blank" rel="noopener">备用链接</a>】</td><td>📚 技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计、Java、Python、C++</td></tr><tr><td><strong><a href="https://github.com/linw7/Skill-Tree" target="_blank" rel="noopener">准备秋招，欢迎来树上取果实</a></strong></td><td>这里将以最短的篇幅，最清晰的层级结构去总结那些对C++后台开发最为核心的内容。</td></tr><tr><td><strong><a href="https://github.com/zhengjianglong915/note-of-interview" target="_blank" rel="noopener">《互联网面试笔记》</a></strong></td><td>收集和分析互联网常见面试题，并将这些面试知识整理成文方便大家查阅。主要是面向java程序员，但基础知识部分不同语言程序员(c,c++,python等）都可以参考</td></tr><tr><td><strong><a href="https://github.com/huihut/interview" target="_blank" rel="noopener">C/C++笔记</a></strong></td><td>C/C++ 技术面试基础知识总结，包括语言、程序库、数据结构、算法、系统、网络、链接装载库等知识及面试经验、招聘、内推等信息。 <a href="https://interview.huihut.com" target="_blank" rel="noopener">https://interview.huihut.com</a></td></tr></tbody></table><hr><h4 id="2-教程集合"><a href="#2-教程集合" class="headerlink" title="2. 教程集合"></a>2. 教程集合</h4><ol><li><p><a href="https://github.com/Ewenwan/ShiYanLou" target="_blank" rel="noopener"><strong>学习C &amp; C++</strong></a></p><blockquote><p>学习C &amp; C++ &amp; python&amp;汇编语言 LLVM编译器 数据结构 算法 操作系统 单片机 linux 面试</p></blockquote></li></ol><hr><h3 id="01实用网站"><a href="#01实用网站" class="headerlink" title="01实用网站"></a>01实用网站</h3><ol><li><p><strong><a href="https://www.geeksforgeeks.org/" target="_blank" rel="noopener">geeksforgeeks</a></strong></p><blockquote><p>是印度的一家致力于计算机科学的百科全书，根据不同的用户计算机水平而发布不同的难度等级，从基础到专家级，内容涵盖了编程、算法、面试问题等。​</p></blockquote></li><li></li></ol><hr><h3 id="02项目练习"><a href="#02项目练习" class="headerlink" title="02项目练习"></a>02项目练习</h3><p><a href="https://github.com/tuvtran/project-based-learning#cc" target="_blank" rel="noopener">基于项目学习</a>（project-based-learning)</p><hr><h3 id="03编程相关书籍"><a href="#03编程相关书籍" class="headerlink" title="03编程相关书籍"></a>03编程相关书籍</h3><ol><li><a href="https://github.com/EbookFoundation/free-programming-books" target="_blank" rel="noopener">英文版</a></li><li><a href="https://github.com/justjavac/free-programming-books-zh_CN" target="_blank" rel="noopener">中文版</a></li></ol><hr><h3 id="04科目"><a href="#04科目" class="headerlink" title="04科目"></a>04科目</h3><h4 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h4><p>适合回顾知识点：<a href="https://oi-wiki.org/" target="_blank" rel="noopener">https://oi-wiki.org/</a></p><hr><table><thead><tr><th>学习教程</th><th>描述</th><th>状态</th></tr></thead><tbody><tr><td><a href="https://www.cnblogs.com/skywang12345/p/3603935.html" target="_blank" rel="noopener"><strong>数据结构与算法系列</strong></a></td><td>博客园中的一个博主写的</td><td><strong><u>再看</u>👁️</strong></td></tr><tr><td><strong><a href="https://github.com/nonstriater/Learn-Algorithms" target="_blank" rel="noopener">算法学习笔记</a></strong></td><td>这里的内容是学习算法过程的一些记录，希望能一直坚持下去。</td><td></td></tr><tr><td><a href="https://github.com/xiufengcheng/DATASTRUCTURE" target="_blank" rel="noopener">备用</a></td><td></td><td></td></tr></tbody></table><hr><table><thead><tr><th>可视化工具</th><th>描述</th></tr></thead><tbody><tr><td><strong><a href="https://visualgo.net/zh" target="_blank" rel="noopener">Visualgo</a></strong></td><td>可视化的观察数据结构的操作</td></tr><tr><td><strong><a href="http://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">David Galles可视化演示(JS)</a></strong></td><td>旧金山大学David Galles可视化演示(JS)</td></tr><tr><td><a href="https://github.com/algorithm-visualizer/algorithm-visualizer" target="_blank" rel="noopener"><strong>可以从代码中可视化算法</strong></a></td><td>算法可视化工具是一个交互式的在线平台，可以从代码中可视化算法。</td></tr><tr><td><a href="https://github.com/xiufengcheng/DATASTRUCTURE#可视化" target="_blank" rel="noopener"><strong>更多可视化工具</strong></a></td><td></td></tr></tbody></table><hr><h4 id="2-learn-OpenGL"><a href="#2-learn-OpenGL" class="headerlink" title="2. learn OpenGL"></a>2. learn OpenGL</h4><p>中文教学网址：<a href="https://learnopengl-cn.github.io/intro/" target="_blank" rel="noopener">https://learnopengl-cn.github.io/intro/</a></p><hr><h4 id="3-C-C"><a href="#3-C-C" class="headerlink" title="3. C/C++"></a>3. C/C++</h4><hr><p><strong>C语言相关：</strong></p><p><a href="https://wizardforcel.gitbooks.io/lcthw/content/" target="_blank" rel="noopener"><strong>笨办法学C</strong></a></p><hr><center>官方文档</center><ul><li><a href="https://en.cppreference.com/w/" target="_blank" rel="noopener"><strong>cppreference</strong></a></li></ul><hr><center>相关网站</center><table><thead><tr><th>网站</th><th>描述</th></tr></thead><tbody><tr><td><strong><a href="http://www.cplusplus.com/" target="_blank" rel="noopener">Cplusplus</a></strong></td><td>这也是一个学习 C++ 的优秀网站，除了提供相应的教程之外，还有一个很棒的论坛。和其它网站相比，它的价值更多体现在参考上，因为里面解释了许多编程概念，如果对某个特定的东西感到困惑，那么这些概念将会很有帮助。</td></tr><tr><td><strong><a href="https://www.tutorialspoint.com/cplusplus/index.htm" target="_blank" rel="noopener">TutorialsPoint</a></strong></td><td>Tutorialspoint 是一个顶级网站，之所以这么说，是因为你想学的任何技术（包括 C++），它几乎都提供了详细的教程。保存好就对了，超级有用。</td></tr><tr><td><strong><a href="https://github.com/fffaraz/awesome-cpp" target="_blank" rel="noopener">Awesome C++</a></strong></td><td>GitHub 上的 Awesome-XXX 系列的资源整理，awesome-cpp 就是 fffaraz 发起维护的 C++ 资源列表，内容包括：标准库、Web 应用框架、人工智能、数据库、图片处理、机器学习、日志、代码分析等</td></tr></tbody></table><hr><center>学习路线</center><p><a href="http://www.renrenstudy.com/default/cplus-advanced-learning/" target="_blank" rel="noopener">C++学习进阶(陈皓)</a></p><center>学习教程</center><table><thead><tr><th>资料</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.learncpp.com/cpp-tutorial/syntax-and-semantic-errors/" target="_blank" rel="noopener">LearnCpp</a></td><td>一个很好地C++学习网站</td></tr><tr><td><a href="https://www.cnblogs.com/nihaoCPP/p/3925336.html" target="_blank" rel="noopener">你好，C++</a></td><td>辅助学习文章阅读（有时间可以看）</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><hr><h2 id="Ⅱ-关注的博客"><a href="#Ⅱ-关注的博客" class="headerlink" title="Ⅱ 关注的博客"></a>Ⅱ 关注的博客</h2><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><ol><li><a href="http://linux.vbird.org/linux_basic/" target="_blank" rel="noopener"><strong>鳥哥的 Linux 私房菜</strong></a></li></ol><hr><h2 id="Ⅲ-Github中的资源"><a href="#Ⅲ-Github中的资源" class="headerlink" title="Ⅲ Github中的资源"></a>Ⅲ Github中的资源</h2><center>[github仓库排名](https://gitstar-ranking.com/repositories)</center><ol><li><p><a href="https://github.com/kamranahmedse/developer-roadmap" target="_blank" rel="noopener">web开发人员的路线图</a></p></li><li><p><strong>自学计算机课程的参考</strong></p><ul><li><p><strong><a href="https://github.com/ossu/computer-science-cn" target="_blank" rel="noopener">计算机技术与科学自学之旅</a></strong>(中文)</p><blockquote><p>开源社区大学计算机科学课程中文项目（OSSU CS CN)旨在为英语能力有待提高的中文学习者提供全中文的在线本科计算机科学学习课程。消除学习者在自学计算机课程中遇到的语言障碍。请注意本课程并不是英文课程的对照翻译，而是在其基础上结合地区实际情况提供全中文的在线教育。<strong>值得注意的是，我们仍然推荐学有余力者在学习完本课程后系统学习和掌握英语技能。</strong></p></blockquote></li><li><p><strong><a href="https://github.com/ossu/computer-science" target="_blank" rel="noopener">computer-science</a></strong></p><blockquote><p>通往免费自学计算机科学教育的道路!</p></blockquote></li></ul></li></ol><h2 id="Ⅱ-工具"><a href="#Ⅱ-工具" class="headerlink" title="Ⅱ 工具"></a><red>Ⅱ 工具</red></h2><h3 id="01写作相关"><a href="#01写作相关" class="headerlink" title="01写作相关"></a>01写作相关</h3><ol><li><p><strong>编辑器</strong></p><ul><li><p><strong><a href="https://github.com/mdnice/markdown-nice" target="_blank" rel="noopener">公众号排版(支持Markdown)</a></strong>：<strong>推荐</strong>【分为：Google插件 &amp; 在线版】</p><ul><li><a href="https://mdnice.com/" target="_blank" rel="noopener">在线版</a></li></ul></li><li><p><strong><a href="https://www.135editor.com/" target="_blank" rel="noopener">135编辑器</a></strong>：</p><blockquote><p>一款强大的微信公众号文章排版</p></blockquote></li></ul></li><li><p><strong>插件</strong></p><ul><li><p><a href="https://yiban.io/" target="_blank" rel="noopener">壹伴</a>：</p><blockquote><p>壹伴运营神器_新媒体小编最喜欢的微信排版工具</p></blockquote></li></ul></li><li><p><strong><a href="https://urlify.cn/" target="_blank" rel="noopener">短链生成</a></strong></p></li><li><p><strong><a href="https://squoosh.app/" target="_blank" rel="noopener">图片压缩</a></strong></p></li><li><p><strong><a href="http://tools.jb51.net/static/colorpicker/" target="_blank" rel="noopener">RGB及其它类型颜色查询</a></strong></p></li><li><p><strong>无版权图片</strong></p><ol><li><p><a href="https://pixabay.com/images/search/" target="_blank" rel="noopener"><strong>Pixabay</strong></a>：</p><blockquote><p>Pixabay是一个支持中文搜索的免费可商用图库。</p></blockquote></li><li><p><a href="https://gratisography.com/" target="_blank" rel="noopener"><strong>Gratisography</strong></a>：</p><blockquote><p>Gratisography是一个免费高分辨率摄影图片库，所有的图片都可以用于个人或者商业用途，每周更新图片你只需要点击即可下载。</p></blockquote></li><li><p><a href="https://unsplash.com/" target="_blank" rel="noopener"><strong>Unsplash</strong></a>：</p><blockquote><p>每天更新一张高质量的图片素材，全是生活中的景象作品，清新的生活气息图片。</p></blockquote></li><li><p><a href="https://www.pexels.com/" target="_blank" rel="noopener"><strong>Pexels</strong></a>：</p><blockquote><p>根据英文关键词搜索图片，还能根据不同颜色分类查找，匹配的图片复古自带滤镜，风格简约，图片质量很高，素材丰富。</p></blockquote></li><li><p><a href="https://visualhunt.com/" target="_blank" rel="noopener"><strong>VisualHunt</strong></a>：</p><blockquote><p>可以通过颜色来查找图片。</p></blockquote></li><li><p><a href="https://www.photock.jp/" target="_blank" rel="noopener"><strong>Photock</strong></a>：</p><blockquote><p>天空、水、河、海、草坪、火、山、动物、建筑、夜景、日本景点、日本历史文化图片等等。</p></blockquote></li><li><p><a href="http://pngimg.com/" target="_blank" rel="noopener"><strong>pngimg</strong></a>：</p><blockquote><p>全部都是无背景图片，非常适合那些需要png透明底配图的。而且它分类也很细，找起来方便。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/image-20200323143423265.png" alt="image-20200323143423265"></p></blockquote></li><li><p><a href="https://www.foodiesfeed.com/" target="_blank" rel="noopener"><strong>Foodiesfeed</strong></a>：</p><blockquote><p>专注于<u>美食</u>的图片网站，高清无水印，根据分类选择匹配关键词。</p></blockquote></li><li><p><a href="https://www.everypixel.com/" target="_blank" rel="noopener"><strong>Everypixel</strong></a>：</p><blockquote><p>Everypixel 是一款帮助用户寻找免费图片素材的搜索引擎，选择免费或付费，利用AI和图片分析技术筛选图片，并查看图片来源网站。</p></blockquote></li><li><p><a href="https://www.howtostartanllc.org/free-stock-photos/" target="_blank" rel="noopener">https://www.howtostartanllc.org/free-stock-photos/</a></p><blockquote><p>这是一个汇总了很多个免费图片网站的导航。</p></blockquote></li></ol></li></ol><hr><h3 id="02-云同步备份功能"><a href="#02-云同步备份功能" class="headerlink" title="02 云同步备份功能"></a>02 云同步备份功能</h3><ol><li><p><a href="https://www.jianguoyun.com/" target="_blank" rel="noopener"><strong>坚果云</strong></a></p><blockquote><p>可以实现本地与云端实时同步，还带有历史版本回退功能。缺点：每月上传只有1G容量，只能同步体积较小的文件。</p></blockquote></li><li><p><a href="https://www.fangcloud.com/" target="_blank" rel="noopener"><strong>亿方云</strong></a>：</p><blockquote><p>可以实现本地与云端实时同步，还带有历史版本回退功能。功能和坚果云类似。</p></blockquote></li></ol><hr><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li><a href="https://github.com/mdnice/markdown-resume" target="_blank" rel="noopener">Markdown 简历排版</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> forme </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>凸包总结</title>
      <link href="/archives/bf113a1c.html"/>
      <url>/archives/bf113a1c.html</url>
      
        <content type="html"><![CDATA[<h2 id="凸包的相关“test”测试"><a href="#凸包的相关“test”测试" class="headerlink" title="凸包的相关“test”测试"></a><a href="https://www.longlongqin.top/archives/510d.html">凸包的相关“test”测试</a></h2><p><strong>一些定义：</strong></p><ul><li><p><strong>凸包[Convex Hull]</strong>：简单理解为将很多钉子围住的“皮筋”。</p></li><li><p><strong>极点(Extreme Point)</strong>：有一个点集S。如果存在通过点P的直线L，使得点集S中除了点P之外的其他的点都在这个直线的同一侧，则这个点P就是<strong>极点(Extreme Points)</strong>。</p></li><li><p><strong>极边(Extreme Edge)</strong>：两个极点连成的边，剩余的所有点均会在该边的一侧。</p></li></ul><h3 id="To-Left-Test"><a href="#To-Left-Test" class="headerlink" title="To-Left Test"></a>To-Left Test</h3><p>To-Left测试是相对于另外这两个点所确定的那条<strong>有向</strong>直线而言的，任何一条有向直线不仅会把平面分成两部分，我们还可以知道哪一边是左边，哪一边是右边。To-Left，其实就是说这个点相对于刚才的那条有向线而言到底是位于它的左侧(就是true)，还是右侧(就是false)。</p><blockquote><p>这里用到了行列式来求三角形面积（请看下面手写证明）。下图中的这个行列式实际上算的是它的”面积(指：有向面积）”的<strong>两倍</strong>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ToLeft</span> <span class="params">(Point p, Point q, Point s)</span> <span class="comment">//判断点s对于线段pq的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Area2(p,q,s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Area2</span><span class="params">(Point p, Point q, Point s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.x*q.y - p.y*q.x + q.x*s.y - q.y*s.x</span><br><span class="line">            +s.x * p.y - s.y *p.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>行列式来求三角形面积的证明：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="%E5%87%B8%E5%8C%85%E6%80%BB%E7%BB%93/v2-7c2f030cc1b9012bfefe41f0598ec6e9_720w.jpg" alt="img"></p></blockquote><center>图片来源于：https://zhuanlan.zhihu.com/p/35543479</center><h3 id="In-Trangle-Test"><a href="#In-Trangle-Test" class="headerlink" title="In-Trangle Test"></a>In-Trangle Test</h3><p>其实这个算法就是判断点是否在三角形内部。</p><p>这个测试最直接的理解为：使用了三次<em>To-Left Test</em>，三角形有三条边，所以每一条边都测试一次：</p><ul><li>三次<em>To-Left Test</em>结果相同的（均为true或者是false），则证明在三角形内部。</li><li>三次结果中有一次不相同，则证明在三角形外部。</li></ul><h3 id="判断极边"><a href="#判断极边" class="headerlink" title="判断极边"></a>判断极边</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//判断极边的核心</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkEdge</span><span class="params">(Point S[], <span class="keyword">int</span> n, <span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> lEmpty =TRUE, REmpty = TRUE;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n&amp;&amp;(LEmpty||REmpty); k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k!=p &amp;&amp; k!=q)</span><br><span class="line">            ToLeft(S[p], S[q], S[k]) ? LEmpty=FALSE: REmpty=FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(LEmpty || REmpty)</span><br><span class="line">        S[p].extreme =S[q].extreme= TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="in-convex-polygon-test"><a href="#in-convex-polygon-test" class="headerlink" title="in-convex-polygon test"></a>in-convex-polygon test</h3><p><strong>判定待定点是否位于某多边形内部（in-convex-polygon test）</strong></p><p>实现的方法就是：按一定方向（约定为逆时针）凸包的每条边和待定点做ToLeft test，一旦有一次test为false就说明改点在凸包外面。</p><h2 id="构造凸包的方法"><a href="#构造凸包的方法" class="headerlink" title="构造凸包的方法"></a>构造凸包的方法</h2><h3 id="1-利用极点法"><a href="#1-利用极点法" class="headerlink" title="1 利用极点法"></a>1 利用<strong>极点法</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extremePoint</span> <span class="params">(<span class="built_in">point</span> S[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>; s&lt;n; s++)</span><br><span class="line">        S[s].extreme = TRUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>; p&lt;n; p++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> q=p+<span class="number">1</span>; q&lt;n; q++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> r=q+<span class="number">1</span>; r&lt;n; r++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>; s&lt;n; s++)</span><br><span class="line">                &#123;</span><br><span class="line"><span class="keyword">if</span>(s==p || s==q || s==r ||!S[s].extreme)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(Intriangle(S[p],S[q],S[r],S[s]))</span><br><span class="line">                        S[s].extreme = FALSE;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n^4)</p></blockquote><h3 id="2-利用极边法"><a href="#2-利用极边法" class="headerlink" title="2 利用极边法"></a>2 利用<strong>极边法</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> markEE（<span class="built_in">point</span> S[], <span class="keyword">int</span> n）</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++) <span class="comment">//将所有点的初始状态都设置成：非极点</span></span><br><span class="line">        S[K].extreme = FALSE; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p=<span class="number">0</span>; p&lt;n; p++) <span class="comment">//遍历每条边，看他是否是极边</span></span><br><span class="line">        <span class="keyword">for</span>(q=p+<span class="number">1</span>; q&lt;n; q++)</span><br><span class="line">            checkEdge(S,n,p,q) <span class="comment">//判断极边的核心</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//判断极边的核心</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkEdge</span><span class="params">(Point S[], <span class="keyword">int</span> n, <span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> lEmpty =TRUE, REmpty = TRUE;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n&amp;&amp;(LEmpty||REmpty); k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k!=p &amp;&amp; k!=q)</span><br><span class="line">            ToLeft(S[p], S[q], S[k]) ? LEmpty=FALSE: REmpty=FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(LEmpty || REmpty)</span><br><span class="line">        S[p].extreme =S[q].extreme= TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n^3)</p></blockquote><h3 id="3-incremental-construction（增量构造）"><a href="#3-incremental-construction（增量构造）" class="headerlink" title="3 incremental construction（增量构造）"></a>3 incremental construction（增量构造）</h3><p>详细讲解：<a href="https://www.longlongqin.top/archives/7c53.html">https://www.longlongqin.top/archives/7c53.html</a></p><p><strong>该算法的核心步骤就是：</strong>复杂度 O(n^2)</p><ol><li><p>判定新加入点与凸包的位置关系：用<strong>in-convex-polygon test</strong></p><blockquote><p>in-convex-polygon test在上面有讲</p></blockquote></li><li><p>向凸包插入新点：<strong>support-line</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200311230823679.png" alt="新点准备插入现有凸包"></p><p>如上面的点x，如何插入现有凸包当中呢？</p><p><strong>插入过程：</strong>插入过程其实就是寻找两个连接点s和t，然后将新点x与t、s分别连接得到新的凸包。t、s两个点将原凸包的边界分成两部分：st和ts两个邮箱线段。构造新凸包就要保留远端st，舍弃近端ts。取代ts的是x和s、t的连接线xt和xs。其中xt、xs被称为<strong>切线（tangent）</strong>或者<strong>support line（支撑线）</strong>。（配合下图理解）</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/v2-8afbf4ebfa808eec9ffff8c111ae6465_720w.jpg" alt="img"></p><ul><li><p>现在就是<strong>如何找到t、s这两个点？</strong></p><p>在凸包上任取一点v，按<strong>逆</strong>时针方向v点会有一个直接前驱点和直接后继点。考察有向直线xv与点v直接前驱和直接后继的位置关系（两次to left test），记为一个<strong>pattern表</strong>。</p><p>【结果无非是四种情况：v的直接前驱和直接后继相对于有向直线xv的位置是RL，LR，LL，RR。例如上图黄色点v，是R和L；蓝色点v分别是L和R。实际上凸包边界st上所有点的pattern都为RL，ts上所有点的pattern都为LR。关键点在于：点S的pattern是LL，点t的pattern为RR。】</p></li></ul></li></ol><p>说了这么多，其实我们可以将上面的两步合为一步：<strong><u>对于每个待定点x，不必特意去考虑它与凸包的位置关系，而是遍历凸包上每一个点。</u></strong></p><blockquote><p>对于凸包<strong>边界</strong>上的每一个点，我们都能通过两次to left test迅速判断出pattern。</p><p>对于x位于凸包<strong>外部</strong>的情况，经过遍历凸包的点，我们很容易就能得到s和t的位置，得到两条support line，从而构造出新的凸包；</p><p>而对于x位于凸包<strong>内部</strong>的情况，凸包边界每个点都不可能出现RR或LL的情况，直接舍弃x即可。</p></blockquote><h3 id="4-Jarvis-March"><a href="#4-Jarvis-March" class="headerlink" title="4 Jarvis March"></a>4 Jarvis March</h3><p>详细讲解：<a href="https://longlongqin.top/archives/9c7f.html" target="_blank" rel="noopener">https://longlongqin.top/archives/9c7f.html</a></p><p>又称：Gift Wrapping</p><p>算法步骤：</p><ol><li>初始化所有点，设置点集的初态为 <strong>非极点</strong></li><li>找到开始的第一个极点：用<strong>LTL方法</strong></li><li>寻找下一个极点：用<strong><em>ToLeft test</em></strong>寻找下一个极点</li><li>循环步骤3，直到找到所有极点</li></ol><p>也就是：首先从任何一个极点（用LTL确定）开始，然后找到一条以这个极点为端点的极边。然后沿着这个极边的另一个端点<strong>（endpoint）</strong>出发，再找出下一条极边。如此反复操作，最终会找到一条以最初极点为endpoint的极边，得到一个封闭的环，凸包也构造完成。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200312175230158.png" alt="image-20200312175230158"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LTL</span><span class="params">(Point S[], <span class="keyword">int</span> n)</span> <span class="comment">//寻找最下and最左的点作为第一个极点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ltl = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;n; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S[k].y &lt; S[ltl].y || (S[k].y==S[ltl].y &amp;&amp; S[k].x&lt;S[ltl].x) )</span><br><span class="line">            ltl = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ltl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Javis</span> <span class="params">(Point S[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; k++)</span><br><span class="line">    S[k].extreme=FALSE; <span class="comment">//1.将所有点标记为非极点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ltl = LTL(S, n); <span class="comment">//2.找到ltl</span></span><br><span class="line">    <span class="keyword">int</span> k = ltl; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        S[k].extreme = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">-1</span>; <span class="comment">//要找的下一个极点用s表示</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t=<span class="number">0</span>; t&lt;n; t++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (t!=k &amp;&amp; t!=s &amp;&amp; ( s==<span class="number">-1</span> || !ToLeft(S[K],S[s],S[t]) ) )</span><br><span class="line">                s = t; </span><br><span class="line">        &#125;  </span><br><span class="line">        S[k].succ = s; <span class="comment">//新的极边确定</span></span><br><span class="line">        k = s； <span class="comment">//更新k的值，变为下一次查找的边的起点</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(k != ltl) <span class="comment">//如果循环回到了原来的点，则结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度：Jarvis March算法算法的复杂度<strong>更准确的表示为O(nh)。</strong>h（凸包边界的点的个数）又由最终输出结果，即凸包本身来决定，输出结果决定了构造过程的复杂度，这就是所谓的“输出敏感性”。这种类型的算法又被称为output sensitive algorithm。这种特性在其它凸包算法中也会体现。</p><h3 id="5-Graham-Scan"><a href="#5-Graham-Scan" class="headerlink" title="5 Graham Scan"></a>5 Graham Scan</h3><p>详细讲解；<a href="https://longlongqin.top/archives/3478.html" target="_blank" rel="noopener">https://longlongqin.top/archives/3478.html</a></p><p><strong>算法流程：</strong></p><ol><li><p><strong>预排序(presorting)</strong>：即找到某个基准点，然后将其余所有的点按照相对于基准点的<strong>极坐标</strong>排序。它主要做了三个事情：</p><blockquote><p>1、<strong>找出基准点</strong>：用<strong>lowest-then-leftmost point（LTL）</strong>，然后对其他点按照极坐标排序：根据极角排序的方法，在：（<a href="https://longlongqin.top/archives/510d.html#补：根据极角排序）" target="_blank" rel="noopener">https://longlongqin.top/archives/510d.html#补：根据极角排序）</a></p><p>2、<strong>找出起始边</strong>：从排好序的点集，选取前两个点，就是起始边。</p><p>3、<strong>将起始边 与 剩下的n-2条边分别存储在不同的栈(stack)中：</strong>如下图</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="%E5%87%B8%E5%8C%85%E6%80%BB%E7%BB%93/image-20200314181609764.png" alt="栈：T和S"></p></blockquote></li><li><p><strong>Scan扫描</strong></p><p>这一步是算法的核心。</p><p>scan的过程主要关注三个点：<strong>栈S的栈顶（S[0]）、次栈顶（S[1]）和栈T的栈顶（T[0]）</strong>。也就下图红色标注的三个点：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/20180207210925858.jpg" alt="img"></p><ul><li>可以观察到，每次待处理的S[0]和S[1]构成的边一定是一条极边（如上图点1和点2），算法<strong>关键步骤</strong>就是对边这条极边和T[0]做to left test，判断T[0]位于边S[0]S[1]的左边还是右边。若在左边则继续拓展，若在右边则否定掉此前认定的极边。无论结果如何，每次判定都会将问题规模缩小一个单元，算法结束时T最终肯定为空。T空后，<strong>S中存留下的点正是凸包的极点</strong>，这些点自底而上正是凸包边界点的逆时针遍历，也得到了整个凸包构造问题的解。</li></ul></li></ol><p><strong>复杂度：</strong></p><p>Graham Scan算法复杂度由三部分决定：</p><ul><li>persorting，采用一般排序算法，复杂度是O(nlogn)</li><li>逐步迭代，O(n)：算法一步步纳入新点，会迭代n步。</li><li>scan，O(?)</li></ul><p><strong>所以算法的总体复杂度：O(nlogn + n * ?) ，可见scan的复杂度决定了算法总体的复杂度。</strong></p><ul><li>算法一步步纳入新点，会迭代n步。但是在每个点上都有可能做回溯操作，所以scan的复杂度是不确定的。我们来以上图最坏情况为例，到第8个点时判定为false，舍弃点7，回溯。下一步判断也为false，舍弃点6，回溯。如此回溯直到算法开始的点2。这次scan倒退了高达O(n)个点，如果每次scan都是如此那么算法整体复杂度就为：O(nlogn + n * n) = O(n^2)了，那这种算法的意义也就不大了。</li></ul><p>其实上述分析并非错误，只是不够精确。O(n^2)确实是Graham Scan算法的一个<strong>上界</strong>，但是这个上界并不是紧的。</p><p>问题就出在分析假定了每次都会出现回退高达O(n)个点。</p><p><strong>代码部分：</strong><a href="https://longlongqin.top/archives/d4fa.html" target="_blank" rel="noopener">https://longlongqin.top/archives/d4fa.html</a></p><h2 id="6-Divide-And-Conquer"><a href="#6-Divide-And-Conquer" class="headerlink" title="6 [Divide And Conquer]"></a>6 [Divide And Conquer]</h2><p>详细讲解：<a href="https://longlongqin.top/archives/f32f.html" target="_blank" rel="noopener">https://longlongqin.top/archives/f32f.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 凸包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记</title>
      <link href="/archives/7b67faab.html"/>
      <url>/archives/7b67faab.html</url>
      
        <content type="html"><![CDATA[<center>陈皓——程序员练级攻略</center><h2 id="提及的书籍-amp-手册等"><a href="#提及的书籍-amp-手册等" class="headerlink" title="提及的书籍&amp;手册等"></a>提及的书籍&amp;手册等</h2><p>书籍列表：<a href="https://github.com/git-zjx/programmer_training_strategy" target="_blank" rel="noopener">https://github.com/git-zjx/programmer_training_strategy</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo中插入pdf</title>
      <link href="/archives/448ac7f1.html"/>
      <url>/archives/448ac7f1.html</url>
      
        <content type="html"><![CDATA[<p>法1：安装hexo-pdf插件</p><p>法2：利用html语法：可以轻松设定尺寸</p><a id="more"></a><h2 id="安装hexo-pdf插件"><a href="#安装hexo-pdf插件" class="headerlink" title="安装hexo-pdf插件"></a>安装hexo-pdf插件</h2><h3 id="hexo-pdf"><a href="#hexo-pdf" class="headerlink" title="hexo-pdf"></a><a href="https://github.com/superalsrk/hexo-pdf" target="_blank" rel="noopener">hexo-pdf</a></h3><p>Hexo tag for embeded pdf</p><h4 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save hexo-pdf</span><br></pre></td></tr></table></figure><h4 id="Normal-PDF"><a href="#Normal-PDF" class="headerlink" title="Normal PDF"></a>Normal PDF</h4><p>pdf链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf http:&#x2F;&#x2F;7xov2f.com1.z0.glb.clouddn.com&#x2F;bash_freshman.pdf %&#125;</span><br></pre></td></tr></table></figure><p>本地（<u>我的失败了，还没找到原因</u>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf .&#x2F;bash_freshman.pdf %&#125;</span><br></pre></td></tr></table></figure><h4 id="Google-drive"><a href="#Google-drive" class="headerlink" title="Google drive"></a>Google drive</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf https:&#x2F;&#x2F;drive.google.com&#x2F;file&#x2F;d&#x2F;0B6qSwdwPxPRdTEliX0dhQ2JfUEU&#x2F;preview %&#125;</span><br></pre></td></tr></table></figure><h4 id="Slideshare"><a href="#Slideshare" class="headerlink" title="Slideshare"></a>Slideshare</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf http:&#x2F;&#x2F;www.slideshare.net&#x2F;slideshow&#x2F;embed_code&#x2F;key&#x2F;8Jl0hUt2OKUOOE %&#125;</span><br></pre></td></tr></table></figure><p>示例：图片来源于网络</p><div class="row"><embed src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/PDF/Google_Cpp_Style_guide_CN.pdf" width="100%" height="550" type="application/pdf"></div><hr><h2 id="利用html语法"><a href="#利用html语法" class="headerlink" title="利用html语法"></a>利用html语法</h2><h3 id="首先修改-config-yml文件"><a href="#首先修改-config-yml文件" class="headerlink" title="首先修改_config.yml文件"></a>首先修改_config.yml文件</h3><p><strong>将_config.yml中的post_asset_folder选项置为true</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><p>关于这个选项的功能说明如下:</p><blockquote><p>当您设置post_asset_folder为true参数后，在建立文件时，Hexo<br>会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。</p></blockquote><h3 id="然后新建一篇文章"><a href="#然后新建一篇文章" class="headerlink" title="然后新建一篇文章"></a>然后新建一篇文章</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new</span><br></pre></td></tr></table></figure><blockquote><p>由于上一步已经将post_asset_folder选项设为了true<br>所以这一步新建文章时会创建一个md文件和一个同名的文件夹<br>为了方便叙述，我用test作为文件和文件夹名</p></blockquote><h3 id="编辑test-md"><a href="#编辑test-md" class="headerlink" title="编辑test.md"></a>编辑test.md</h3><blockquote><p>用vim或者别的编辑器打开test.md</p><p>test.md文件中加入如下代码</p><p><code>&lt;object data=&quot;./test/test.pdf&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;</code></p><p>关于这句代码简单的解释<br>data表示你要上传的pdf的路径,使用相对路径，将你要上传的pdf放入第二步生成的test文 件夹<br>type和width就不说了，这里注意height不能设成100%，不然太矮了，显示效果不好<br>可以用浏览器预览，通过F12预估一下高度。我最后代码如下，供参考</p><p><code>&lt;object data=&quot;https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/PDF/Google_Cpp_Style_guide_CN.pdf &quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;877px&quot;&gt;</code></p></blockquote><p>这里不一定非用object标签，embed、iframe标签也一样</p><p>具体参考:<a href="https://blog.csdn.net/qappleh/article/details/80250492" target="_blank" rel="noopener">网页链接</a></p><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><u><strong>注意</strong></u>：</h2><p><u>用html方法，在我的主题中，如果它后面有文字，会显示不出来，原因不详。</u>所以实例我放在文章底部展示了</p><hr><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://github.com/superalsrk/hexo-pdf" target="_blank" rel="noopener">hexo-pdf官方教程</a></p><p><a href="http://miracle778.site/pdf-test/pdf-test.html" target="_blank" rel="noopener">hexo中插入pdf解决方法</a></p><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p><a href="http://lingr7.coding.me/2019/10/02/theme-hexo-pdf%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7-%E8%A7%A3%E5%86%B3hexo-pdf%E6%96%87%E4%BB%B6%E6%98%BE%E7%A4%BA%E4%B8%8D%E5%85%A8%E7%9A%84%E9%97%AE%E9%A2%98.html" target="_blank" rel="noopener">theme-hexo-pdf使用技巧—-解决hexo-pdf文件显示不全的问题</a></p><object data="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/PDF/Google_Cpp_Style_guide_CN.pdf" width="100%" height="877px"></object>]]></content>
      
      
      <categories>
          
          <category> hexo博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo显示pdf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnCpp chapter1</title>
      <link href="/archives/a0a78e77.html"/>
      <url>/archives/a0a78e77.html</url>
      
        <content type="html"><![CDATA[<center><p center large><red>LearnCpp-chapter1</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h2 id="0-5-介绍compiler-linker-and-libraries"><a href="#0-5-介绍compiler-linker-and-libraries" class="headerlink" title="0.5 介绍compiler, linker, and libraries"></a>0.5 介绍compiler, linker, and libraries</h2><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter1/Development-min.png" alt="Development-min"></p><h3 id="Step-4-Compiling-your-source-code"><a href="#Step-4-Compiling-your-source-code" class="headerlink" title="Step 4: Compiling your source code"></a>Step 4: Compiling your source code</h3><p>为了编译C++程序，我们需要一个编译器。编译器主要是对每一个<code>.cpp</code>文件做两件事情：</p><ol><li>它检查你的代码是否符合C++的规则。如果不符合，就会报错（同时返回相应的行号）来帮助你确定什么需要修改，同时停止编译</li><li>它将C++源代码翻译成机器代码文件（叫做：<red><strong>object file</strong></red>）。<strong>object file</strong>的名字通常是这种形式：<u><em>name*</em>.o<strong>*</strong></u> 或者 <u>*name.obj***</u>（其中name与<code>.cpp</code>文件的name是对应的）。</li></ol><p>例如：下面的三个.cpp的源文件，编译之后形成：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter1/CompileSource-min.png" alt="The compilation process"></p><hr><h3 id="Step-5-Linking-object-files-and-libraries"><a href="#Step-5-Linking-object-files-and-libraries" class="headerlink" title="Step 5: Linking object files and libraries"></a>Step 5: Linking object files and libraries</h3><p><strong>编译器compiler **编译完成后，生成若干的 object files。接下来就需要</strong>链接器Linker**出马了。linker的工作主要有三方面：</p><ol><li><p>将所有的object files（编译之后生成的）合并成为一个<em>可执行程序executable program</em></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter1/LinkingObjects-min.png" alt="LinkingObjects-min"></p></li><li><p>此外，linker还可以链接<strong>库文件library files</strong>（library files是一个已经预编译好的代码经过“打包”，在其他程序中重用）</p><blockquote><p>C++有有一个扩充的库，叫做：标准库<strong>C++ Standard Library</strong>。它提供额外的功能性库，比如我们常用的<em>iostream library</em></p><p>你可以有选择性的去链接其他库，比如当你想写一个播放声音的程序。你肯定不想从头到尾的去写如何去读取文件、检查文件是否有效….. 这时候，我们只需要下载相关的库进行利用就方便很多了。</p></blockquote></li><li><p>连接器会确保所有的跨文件依赖项都正确的解析了。</p><blockquote><p>例如：</p><p>如果你在一个.cpp文件中定义了”A”，然后在另一个.cpp文件中去使用”A”。linker就会将这两个文件联系起来。如果链接不成功，就会报错并且连接终止</p></blockquote></li></ol><p>只要linker成功的完成所有的“object files 和 libraries ”的链接工作，你就会得到一个可执行文件，然后你就可以运行它。</p><table><thead><tr><th align="left">Makefile</th></tr></thead><tbody><tr><td align="left">【注】有些开发环境使用<strong>Makefile</strong>，它是一个描述如何构建一个程序的文件（哪一个文件要编译&amp;链接，或者以不同方式处理）它是一个强大的工具。但是在本系列课程我们不回去讲解它。</td></tr></tbody></table><h3 id="Steps-6-amp-7-Testing-and-Debugging"><a href="#Steps-6-amp-7-Testing-and-Debugging" class="headerlink" title="Steps 6 &amp; 7: Testing and Debugging"></a>Steps 6 &amp; 7: Testing and Debugging</h3><p>如果你的可执行程序没有按照预期的工作，那么你就需要调试。</p><h2 id="Integrated-development-environments-IDEs"><a href="#Integrated-development-environments-IDEs" class="headerlink" title="Integrated development environments (IDEs)"></a>Integrated development environments (IDEs)</h2><p><u>【note】step3、4、5、7（editor, compiler, linker, debugger）都是需要软件的。</u></p><p>当然，你可以每一部分都是用独立的软件，但是有这样的一个软件包：<u><strong>integrated development environment (IDE)集成开发环境</strong></u> 将上面四步一体化。</p><hr><h2 id="0-6-compling-your-first-program"><a href="#0-6-compling-your-first-program" class="headerlink" title="0.6 compling your first program"></a>0.6 compling your first program</h2><p><strong>Console projects</strong></p><p>控制台项目没有<strong>graphical user interface (GUI)图形用户界面</strong>，它在控制台中打印text，从输入设备键盘读取信息。并且被编译成独立的可执行文件。</p><p><strong>Workspaces / solutions</strong></p><p>当创建一个项目时，许多IDE会自动给这个项目创建一个 “workspace” 或 “solution” 。</p><p><strong>workspace or solution</strong>：是一个可以容纳多个相关的项目的container。（例如，你正在写一个游戏，你想有一个单人 与 多人分开的可执行文件，那就需要创建两个项目。<strong>但是</strong>将这两个项目分开始没有意义的，因为它们属于同一个游戏的。所以，<u>最好的就是每一个都被配置为单个工作空间/解决方案中的 一个单独项目</u>。）</p><h2 id="0-8-C-中常见问题"><a href="#0-8-C-中常见问题" class="headerlink" title="0.8 C++中常见问题"></a>0.8 C++中常见问题</h2><h3 id="General-run-time-issues"><a href="#General-run-time-issues" class="headerlink" title="General run-time issues"></a>General run-time issues</h3><ol><li><p><strong>当执行程序时，控制台窗口闪烁，然后立即关闭？</strong></p><ul><li>1、首先确保下面的这几行在你的源程序的最上部（visio studio 用户，请确认如果有 #include “pch.h” or #include “stdafx.h” ，那么让它在最顶顶顶部的）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>2、在main()函数中的结束部分（<u>但要在return 语句之前</u>）添加如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">clear</span>(); <span class="comment">// reset any error flags</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>); <span class="comment">// ignore any characters in the input buffer until we find an enter character</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>(); <span class="comment">// get one more char from the user</span></span><br></pre></td></tr></table></figure><p><u>避免使用</u>：<code>system(&quot;pause&quot;)</code> 因为它只能在特定的操作系统中使用</p></li><li><p><strong>运行程序，得到窗口，但没有输出？</strong></p><p>有可能是你的xx安全管家等拦截的。试着关闭它们，然后重新运行</p></li><li><p><strong>程序编译成功，但是没有正确工作？</strong></p><p>去debug它</p></li></ol><h3 id="General-compile-time-issues"><a href="#General-compile-time-issues" class="headerlink" title="General compile-time issues"></a>General compile-time issues</h3><ol><li><p><strong>当编译程序时，得到一个未解析的外部符号：_main or _WinMain@16 ？</strong></p><p>说明你的编译器找不到main()函数。</p></li></ol><h3 id="Visual-Studio-issues"><a href="#Visual-Studio-issues" class="headerlink" title="Visual Studio issues"></a>Visual Studio issues</h3><ol><li><p><strong>使用Microsoft Visual c++进行编译时，得到C1010 fatal error，并且伴随着提示信息，如：”c:\vcprojects\test.cpp(263) :fatal error C1010: unexpected end of file while looking for precompiled header directive”</strong></p><p>答：这种问题出现在：当microsoft visual c++编译器被设置为使用预编译头文件，但您的c++代码文件中有一个(或多个)没有将<code>#include “stdafx.h”</code> or <code>#include “pch.h”</code>作为代码文件的第一行。</p><p>建议：</p><ol><li><p>在创建项目时，将预编译头 <em>precompiled headers</em>选项关闭。</p></li><li><p>如果您希望保持打开预编译头文件，要修复这个问题，只需找到产生错误的文件(在上面的错误中，test.cpp是罪魁祸首)，并在文件的<u>最顶部</u>添加以下行:</p><p><code>#include “pch.h”</code>或者<code>#include “stdafx.h”</code>【老版本的VS使用“stdafx.h” ，当其中一个不起作用，可以换成另外一个】</p><blockquote><p>注意，每一个C++文件都是从这一行开始的。如果不想从这一行开始，那就在创建项目的时候关闭“预编译头文件”选项</p></blockquote></li></ol></li><li><p>出现错误：<strong>“1MSVCRTD.lib(exe_winmain.obj) : error LNK2019: unresolved external symbol _WinMain@16 referenced in function “int __cdecl invoke_main(void)” (?invoke_main@@YAHXZ)”</strong></p><p>答：您可能已经创建了一个Windows图形化应用程序，而不是控制台应用程序。重新创建项目，并确保将其创建为Windows(或Win32)控制台项目。</p></li></ol><h2 id="0-9-配置编译器-“生成（build）”配置"><a href="#0-9-配置编译器-“生成（build）”配置" class="headerlink" title="0.9 配置编译器:“生成（build）”配置"></a>0.9 配置编译器:“生成（build）”配置</h2><p><strong>debug configuration</strong> ：可以帮助你调试你的程序，而且也是IDE默认的。但是它会关掉所有的优化，包含调试信息（这会让你的项目变得很大、很慢）。</p><p><strong>release configuration</strong>：当你将你的程序发布给公众的时候使用release模式。这个模式会优化项目的大小和它的性能，而且不会包含额外的调试信息。所以这种模式适用于：测试你的代码的性能.</p><h2 id="0-10-配置编译器-编译器扩展"><a href="#0-10-配置编译器-编译器扩展" class="headerlink" title="0.10 配置编译器:编译器扩展"></a>0.10 配置编译器:编译器扩展</h2><p>c++标准定义了关于程序在特定环境下应该如何表现的规则。在大多数情况下，编译器将遵循这些规则。然而，许多编译器实现自己对语言的更改，通常是为了增强与该语言的其他版本(例如C99)的兼容性，或者是出于历史原因。这些特定于编译器的行为称为<strong>编译器扩展（Compiler extensions）</strong>。</p><p>编写使用编译器扩展的程序允许你编写与c++标准不兼容的程序。使用非标准扩展的程序通常无法在其他编译器上编译(这些编译器不支持相同的扩展)，或者即使它们支持，也可能无法正确运行。</p><p>注意，编译器扩展通常是默认启用的，这对初学者是不友好的，因为它会让初学者觉得某些行为是符合官方C++的标准，但是实际上是因为编译器只是过于宽松。</p><p>因为，编译器扩展从来都不是必须的，如果开启可能让你误以为你写的代码是符合C++标准的。<u>所以，建议，建议关闭编译器扩展。</u></p><h2 id="0-11-配置编译器-warning和error"><a href="#0-11-配置编译器-warning和error" class="headerlink" title="0.11 配置编译器:warning和error"></a>0.11 配置编译器:warning和error</h2><p>出现error提示：说明你写的代码可能不符合C++语言的标准。</p><p>出现warning提示：说明编译器认为你的代码的某些地方<u>可能</u>有些错误，但是编译器不能百分百确定。</p><blockquote><p>好习惯：</p><p>不要让warning提示堆积，要尽你所能的去解决warning提示。</p></blockquote><p>在大多数情况下出现的warning是需要我们尽量去解决的。但在极少数情况的warning提示，我们需要明确告诉编译器不要产生这个警告。C++官方不支持这样，但是有很多单独的编译器（如：visio studio xx 和GCC）会提供解决方案：利用不可移植 <u># pragma 指令</u> 来暂时的关闭这个警告。</p><blockquote><p>好习惯：</p><p>将你的经高级别调到最大，特别是在你学习的时候，他会帮你识别潜在的问题。</p></blockquote><h3 id="将warnings视为errors"><a href="#将warnings视为errors" class="headerlink" title="将warnings视为errors"></a>将warnings视为errors</h3><p>如果在你学习的时候，最好告诉编译器让它把warning当做error对待，然后你就不得不去解决出现的warning了。</p><h2 id="0-12-配置编译器-选择一个C-标准"><a href="#0-12-配置编译器-选择一个C-标准" class="headerlink" title="0.12 配置编译器: 选择一个C++标准"></a>0.12 配置编译器: 选择一个C++标准</h2><p>C++的标准有很多，如：C++98, C++03, C++11, C++14, C++17, 等. 通常情况，编译器的标准都是默认的，而不是最新的C++标准。如果你想使用指定的标准版本，需要手动设置。</p><h3 id="正在制定中的标准的名字"><a href="#正在制定中的标准的名字" class="headerlink" title="正在制定中的标准的名字"></a>正在制定中的标准的名字</h3><p>有一些语言标准是按照他最终定案时候的年份（如，C++17是在2017年完成的）。但是，当一个新的语言标准正在制定ing的时候，我们不能确定它最终完成的时间。这个时候这个语言标准的名字 将会被最终完成时候的名字替代，（如，<em>C++11</em>在制作ing时，名字为<em>C++1x</em>，当最终完成的时候“<em>C++1x</em>”就会被替换），比如下面的一些：</p><ul><li>c++1x = C++11</li><li>c++1y = C++14</li><li>c++1z = C++17</li><li>c++2a = C++20</li></ul><p>所以，如果你看见C++1Z，这就代表C++17</p><p><u>【注意】</u>：在VS xxxx系列的IDE中，是不能设置全局的语言标准的，你只能一个一个项目的去设置</p><h2 id="1-1-语句与程序结构"><a href="#1-1-语句与程序结构" class="headerlink" title="1.1 语句与程序结构"></a>1.1 语句与程序结构</h2><p><strong>Statements and the structure of a program</strong></p><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p><strong>语句(Statements)</strong>是一种指令类型，它使程序执行某些操作。它是最小的独立计算单元。在C++中，一个单独的语句就可能会被编译成很多机器语言指令。</p><p>下面列出了很多种语句：</p><ol><li>Declaration statements(声明语句)</li><li>Jump statements（循环语句）</li><li>Expression statements（表达式语句）</li><li>Compound statements（复合语句）</li><li>Selection statements (conditionals) (条件语句)</li><li>Iteration statements (loops) （循环语句）</li><li>Try blocks</li></ol><h3 id="函数与main函数"><a href="#函数与main函数" class="headerlink" title="函数与main函数"></a>函数与main函数</h3><p><strong>函数</strong>是按照顺序执行的语句集合。</p><blockquote><p>每一个C++程序都必须要有一个<code>main</code>函数。一个程序开始执行的时候，开始于main函数中的第一条语句，然后按照顺序执行余下语句。</p></blockquote><p>说到函数，你可能会看到<em>main()</em> 或者 <em>doSomething()</em>，后面的括号其实起了一个说明作用。这个括号就说明他前面的那个字符是一个函数的名字。</p><h4 id="分析“hello-world”"><a href="#分析“hello-world”" class="headerlink" title="分析“hello world”"></a>分析“hello world”</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!"</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>第一行：一个预处理指令。这个预处理器指令指示，我们希望使用iostream库的内容，它是c++标准库的一部分，允许我们从控制台上读写文本。我们需要这一行以便在第5行上使用std::cout。排除这一行将导致第5行出现编译错误，因为编译器不知道std::cout是什么。</li><li>第2行是空的，编译器会忽略它。这一行的存在只是为了帮助使程序对人类更具可读性(通过分隔#include预处理指令和程序的后续部分)。</li><li>第3行告诉编译器我们要编写(定义)一个名为main的函数。每个c++程序必须有一个主函数，否则它将无法编译。</li><li>第4行和第7行告诉编译器哪些行是主函数的一部分。第4行上的左大括号和第7行上的右大括号之间的所有内容都被认为是主函数的一部分。这叫做函数体</li><li>第5行是main函数中的第一个语句，也是运行程序时执行的第一个语句。cout(代表“字符输出”)和&lt;&lt;操作符允许我们将字母或数字发送到要输出的控制台。在本例中，我们向它发送文本“Hello world!”，将输出到控制台。此语句创建程序的可见输出。</li><li>第6行是一个返回语句。当可执行程序完成运行时，程序将一个值发送回操作系统，以指示它是否成功运行。按照惯例，这个特殊的return语句将0的值返回给操作系统，这意味着“一切正常!”这是执行的程序中的最后一条语句。</li></ul></blockquote><p>结尾，<strong>什么是C++ 标准库？</strong></p><ul><li>答：一个标准库文件是一个 预编译代码的集合，它被“打包”起来，以供其他程序重用。</li></ul><h2 id="1-2-注释"><a href="#1-2-注释" class="headerlink" title="1.2 注释"></a>1.2 注释</h2><p><strong>正确的注释</strong>：</p><ul><li>At the library, program, or function level, use comments to describe <em>what</em>.</li><li>Inside the library, program, or function, use comments to describe <em>how</em>.</li><li>At the statement level, use comments to describe <em>why</em>.</li></ul><h2 id="1-3-—-Introduction-to-variables"><a href="#1-3-—-Introduction-to-variables" class="headerlink" title="1.3 — Introduction to variables"></a>1.3 — Introduction to variables</h2><p><strong>data：数据</strong></p><blockquote><p>data就是可以被电脑移动、存储、处理的任何信息。</p><p>计算机上的数据通常以一种便于存储或处理的格式存储(因此人类无法读懂)，这种格式就是：二进制（binary）</p></blockquote><p><strong>Objects and variables：对象和数据</strong></p><ul><li><p><strong>RAM(random access memory)</strong>：随机存取存储器。在程序中，你可以把RAM看作一列邮箱，它可以在程序运行时存储数据。存储在内存中的单个数据，称为<strong>value</strong></p></li><li><p>在C++中，不允许直接访问内存。但可以通过object来访问内存。一旦创建object，编译器就自动的决定这个object存放在内存中的位置。</p><blockquote><p><strong>object</strong>：是具有value和其他相关属性的存储区域。</p></blockquote><p>这样，我们就可以说，获取这个object的value，编译器直到这个value存储在内存的具体位置。也就是说，<u>我们可以只关注使用object(对象)来存储和检索value，而且不用担心它在内存中的存储位置。</u></p></li><li><p>object(对象)可以命名也可以不命名。有名字的object叫做：<strong>variable(变量)</strong>。这个object的名字，叫做：<strong>标识符(identifier)</strong>。</p><blockquote><p>在一般编程中，对象通常指内存中的变量、数据结构或函数。在c++中，“对象”的定义较窄，将函数排除在外。</p></blockquote></li></ul><p><strong>Variable instantiation：变量实例化</strong></p><ul><li><p>为了创建一个变量，需要用一种特殊的声明：<strong>定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x; <span class="comment">// define a variable named x, of type int</span></span><br></pre></td></tr></table></figure><ol><li><p>在编译时，当编译器看到这个语句，它会告诉自己我们需要定义一个变量，变量名字叫x，类型为int。从此之后，只要编译器看到标识符x，它就知道我们在引用这个变量。</p></li><li><p>程序运行时(称为：<strong>runtime</strong>)，该变量将会被<strong><u>实例化</u></strong>。<u>变量在用来存储values之前，必须要先实例化。</u></p><blockquote><p><strong>实例化</strong>：对象(object)将会被创建，并且会分配一个内存地址。</p></blockquote><p>为了便于举例，假设变量x是在内存位置140处实例化的。当程序使用变量x时，它将访问内存位置140中的值。实例化的对象有时也称为<strong>实例</strong>。</p></li></ol></li></ul><p><strong>Data types：数据类型</strong></p><ul><li><strong>Data types(更通用的称呼：type)</strong>：它告诉编译器变量将会存储什么类型的value</li></ul><p>在c++中，变量的类型必须在编译时(当程序被编译时)已知，如果不重新编译程序，就不能更改该类型。这意味着一个整型变量只能包含整型值。如果希望存储其他类型的值，则需要使用不同的变量。</p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><ol><li><strong>Data</strong> is any sequence of symbols (numbers, letters, etc…) that can be interpreted to mean something.</li><li>A <strong>value</strong> is a single piece of data stored in memory.【值是存储在内存中的单个数据块。】</li><li>A <strong>variable</strong> is a named region of memory.【变量是一个命名的内存区域。】</li><li>An <strong>identifier</strong> is the name that a variable is accessed by.【标识符是变量被访问的名称】</li><li>A <strong>type</strong> tells the program how to interpret a value in memory.【类型是告诉程序如何解释内存中的值】</li></ol><h2 id="1-4-变量赋值与初始化"><a href="#1-4-变量赋值与初始化" class="headerlink" title="1.4 变量赋值与初始化"></a>1.4 变量赋值与初始化</h2><p><strong>定义变量</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x; <span class="comment">// define an integer variable named x</span></span><br><span class="line"><span class="keyword">int</span> y, z; <span class="comment">// define two integer variables, named y and z</span></span><br></pre></td></tr></table></figure><p><strong>变量赋值：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">width</span>; <span class="comment">// define an integer variable named width</span></span><br><span class="line"><span class="built_in">width</span> = <span class="number">5</span>; <span class="comment">// copy assignment of value 5 into variable width</span></span><br></pre></td></tr></table></figure><p><strong>初始化变量</strong>：(定义&amp;赋值同时进行)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>; <span class="comment">//初始化变量a为1</span></span><br></pre></td></tr></table></figure><blockquote><p>C++初始化变量的形式有三种：</p><ol><li><p>使用<strong>“=”</strong> <strong>copy initialization</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">width</span> = <span class="number">5</span>; <span class="comment">// copy initialization of value 5 into variable width</span></span><br></pre></td></tr></table></figure></li><li><p>使用括号<strong>“()”</strong> <strong>direct initialization</strong> 【这种在一些高级数据类型上，性能较好】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">width</span><span class="params">(<span class="number">5</span>)</span></span>; <span class="comment">// direct brace initialization of value 5 into variable width (preferred)</span></span><br></pre></td></tr></table></figure></li><li><p><red>使用大括号<strong>“{}”</strong> <strong>Brace initialization</strong>(<strong>uniform initialization</strong>)[推荐这种]</red></p><blockquote><p>这种可以用于对象初始化<u>一系列</u>的数据</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*推荐第一种形式*/</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">width</span>&#123; <span class="number">5</span> &#125;; <span class="comment">// direct brace initialization of value 5 into variable width (preferred)</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">height</span> = &#123; <span class="number">6</span> &#125;; <span class="comment">// copy brace initialization of value 6 into variable height</span></span><br></pre></td></tr></table></figure><p>另外，空初始化：用空的花括号对数据进行<strong>Zero initialization</strong>。它表示对该变量初始化为0，或者为空。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">width</span>&#123;&#125;; <span class="comment">//zero initialization to value 0</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><p>对于上述三种初始化方法，看一下下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1.2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">b</span><span class="params">(<span class="number">2.8</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> c&#123; <span class="number">3.1</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span>.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">cin</span>.ignore(numeric_limits&lt;streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line">    <span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter1/image-20200325231749396.png" alt="第三种初始化方法更严谨"></p><p>从运行结果可以看出，第1和2种方法只会基于<strong>“警告”</strong>，它们运行结果就是只把整数部分初始化给响应变量；而第三种就直接提示<strong>“出错”</strong>。</p><hr><p>变量初始化是很有必要的。如果不初始化，编译器可能报错的ヾ(≧O≦)〃嗷~</p><h2 id="1-5介绍输入输出流：cout-cin-endl"><a href="#1-5介绍输入输出流：cout-cin-endl" class="headerlink" title="1.5介绍输入输出流：cout cin endl"></a>1.5介绍输入输出流：cout cin endl</h2><ol><li><p><strong>std::endl 与 ‘\n’</strong></p><p><strong>使用’\n’的效率比std::endl高</strong>。因为：</p></li></ol><ul><li><strong>std::endl</strong>做两件事：1、将光标一刀下一行；2、它“刷新”输出(确保它立即显示在屏幕上)</li><li><strong>‘\n’</strong>只做一件事：1、将光标一刀下一行；</li></ul><ol start="2"><li><p>&lt;&lt; 、&gt;&gt;</p><p>&lt;&lt;： insertion operator (<code>&lt;&lt;</code>)</p><p>&gt;&gt;： extraction operator (<code>&gt;&gt;</code>)</p></li></ol><h2 id="1-6-未初始化-amp-未定义"><a href="#1-6-未初始化-amp-未定义" class="headerlink" title="1.6 未初始化&amp;未定义"></a>1.6 未初始化&amp;未定义</h2><ol><li><p><strong>初始化、赋值、未初始化：</strong></p><p>不像其他语言，C/C++在定义的时候，不会自动的给变量赋值(比如说 0)。所以说，如果一个变量被编译器分配到一个内存地址，如果他没有被人为的赋值，它默认的值就是这个内存地址原来存储的值（也叫“垃圾值”）。</p><ul><li>Initialization = 在对象被定义的同时给它赋值；</li><li>Assignment = 在对象被定义之<strong>后</strong>，再赋值给它；</li><li>Uninitialized = 对象只是被定义，但是还没有被赋值。</li></ul><blockquote><p>所以，我们应该<u><strong>记住要初始化对象</strong></u>（因为现在，初始化对象的成本与带来的好处相比，成本不值一提）。</p><p>不初始化对象，可能会出现无法预料的错误。</p></blockquote></li><li><p><strong>未初始化行为，可能带来以下症状</strong>：</p><ul><li>程序每次运行都会有不同的结果；</li><li>程序每次运行都会出现一个相同的错误结果；</li><li>程序结果不稳定：有时结果正确，有时结果是错误的；</li><li>程序似乎工作，但是稍后的结果不正确；</li><li>程序崩溃；</li><li>程序可以在一些编译器上运行，但在其他编译器中不能运行；</li></ul></li></ol><h2 id="1-7-关键字-amp-标识符"><a href="#1-7-关键字-amp-标识符" class="headerlink" title="1.7 关键字&amp;标识符"></a>1.7 关键字&amp;标识符</h2><p><strong>关键字：</strong></p><p>C++17中的关键字（<strong>keywords</strong> 或者 <strong>reserved words</strong>）有84个关键字。</p><p><strong>标识符：</strong></p><p>变量、函数、类、模块、或任何其他用户自定义项目的 <strong>的名字</strong> 叫做：标识符。</p><p>命名规则：</p><ol><li>标识符名字不能和保留字重名；</li><li>标识符只能由字母、下划线、数字；</li><li>标识符必须以 字母 或 数字 开头（“以下划线开头”的一般都是操作系统的保留字；库，或者是编译器使用的）；</li><li>C++对大小写敏感，所以wa和WA和Wa和wA互不相同。</li></ol><h2 id="1-8-常量-amp-操作符"><a href="#1-8-常量-amp-操作符" class="headerlink" title="1.8 常量&amp;操作符"></a>1.8 常量&amp;操作符</h2><p><strong>常量(literal，literal constant)</strong>：是一个已直接插入源代码的固定值。</p><blockquote><p>常量与变量都有一个value（和一个type）。但是，<strong>常量的值不可更改</strong>。</p></blockquote><p><strong>操作符(Operators)</strong>：在数学中，操作是一种数学计算，包括0个或多个输入值(称为<strong>操作数<em>operands</em></strong>)，它们产生一个新值(称为输出值)。要执行的特定操作由一个称为操作符的结构(通常是一个符号或一对符号)表示。</p><p>操作符分为三类：</p><ul><li><strong>一元操作符(Unary operators)</strong>：只有一个操作数；</li><li><strong>二元操作符(Binary operators)</strong>：有两个操作数（左边、右边各一个）；</li><li><strong>三元操作符(Ternary operators)</strong>：有三个操作数。在C++中只有一个三元操作符。</li></ul><h2 id="1-9-表达式"><a href="#1-9-表达式" class="headerlink" title="1.9 表达式"></a>1.9 表达式</h2><ol><li><p><strong>表达式与语句的区别</strong>？</p><p>当我们需要程序执行某个操作时，使用<strong>语句</strong>；当我们需要程序计算有一个值的时候，使用<strong>表达式</strong>。</p></li><li><p>表达式、语句、表达式语句？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x; <span class="comment">//语句不含表达式</span></span><br><span class="line"><span class="keyword">int</span> x=<span class="number">5</span>; <span class="comment">//语句包含表达式</span></span><br><span class="line">x=<span class="number">5</span>;  <span class="comment">//表达式语句</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="总结chapter-1"><a href="#总结chapter-1" class="headerlink" title="总结chapter 1"></a>总结chapter 1</h1><ul><li><p><strong>语句(statement)</strong>：是一种指令，它通常使程序执行某些操作，语句以分号（semicolon）结尾。</p></li><li><p><strong>预处理指令(Preprocessor directives)</strong>：告诉编译器执行一种特殊任务。在本章中，用到的是”<code>#include &lt;iostream&gt;</code>“</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let’s Build A Simple Interpreter-9</title>
      <link href="/archives/8632918.html"/>
      <url>/archives/8632918.html</url>
      
        <content type="html"><![CDATA[<p><yellow>今天要学习的内容：</yellow></p><ol><li>如何parse and interpret 一个Pascal程序的<strong>定义 definition</strong></li><li>如何parse and interpret <strong>复合语句compound statements</strong></li><li>如何parse and interpret <strong>赋值语句(包括变量)assignment statements, including variables.</strong></li><li>介绍符号表，以及如何存储和查找变量。</li></ol><a id="more"></a><p>原文链接：<a href="https://ruslanspivak.com/lsbasi-part9/" target="_blank" rel="noopener">https://ruslanspivak.com/lsbasi-part9/</a></p><p>本节源代码：<a href="https://github.com/rspivak/lsbasi/tree/master/part9/python" target="_blank" rel="noopener">https://github.com/rspivak/lsbasi/tree/master/part9/python</a></p><p>下面是一个简单的 Pascal程序，来介绍新概念：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        number := <span class="number">2</span>;</span><br><span class="line">        a := number;</span><br><span class="line">        b := <span class="number">10</span> * a + <span class="number">10</span> * number / <span class="number">4</span>;</span><br><span class="line">        c := a - - b</span><br><span class="line">    <span class="keyword">END</span>;</span><br><span class="line">    x := <span class="number">11</span>;</span><br><span class="line"><span class="keyword">END</span>.</span><br></pre></td></tr></table></figure><p>今天所学内容与前面的part1~8相比有了很大的飞跃，现在不再是像以前一样只是一个计算器了。我们要提升一下档次了😊</p><h2 id="新的语法树及规则"><a href="#新的语法树及规则" class="headerlink" title="新的语法树及规则"></a><red>新的语法树及规则</red></h2><p>现在，来看看新语言结构的<em>语法树syntax diagrams</em> 以及其对应的<em>语法规则grammar rules</em></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-9/lsbasi_part9_syntax_diagram_01.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-9/lsbasi_part9_syntax_diagram_02.png" alt="img">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-9/lsbasi_part9_syntax_diagram_03.png" alt="img"></p><h3 id="pascal语法"><a href="#pascal语法" class="headerlink" title="pascal语法"></a><red>pascal语法</red></h3><p>一个Pascal语法由一下组成&lt;<red>这不是完整的定义，会在后面文章慢慢扩展</red>&gt;：</p><ul><li><strong>BEGIN</strong>开头</li><li>中间是<strong>复合语句<em>compound statement</em></strong></li><li>一个<strong>点(dot) “.”</strong>结束</li></ul><h4 id="compound-statement"><a href="#compound-statement" class="headerlink" title="compound statement"></a><red><em>compound statement</em></red></h4><p><em>compound statement</em>是一个block(区块)：</p><ul><li>它标有BEGIN 和 END ，中间可能(也可能没有)包含有<u>一段语句</u>或<u>其他的复合语句<em>compound statement</em></u></li><li>所有嵌入在复合语句中的句子，除了最后一个，其他的都要以分号“;”结尾</li><li>在block中的最后一个句子(last statement)可能或可能没有 中断分号“;”</li></ul><p>如下面所示：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">“<span class="keyword">BEGIN</span> <span class="keyword">END</span>”</span><br><span class="line">“<span class="keyword">BEGIN</span> a := <span class="number">5</span>; x := <span class="number">11</span> <span class="keyword">END</span>”</span><br><span class="line">“<span class="keyword">BEGIN</span> a := <span class="number">5</span>; x := <span class="number">11</span>; <span class="keyword">END</span>”</span><br><span class="line">“<span class="keyword">BEGIN</span> <span class="keyword">BEGIN</span> a := <span class="number">5</span> <span class="keyword">END</span>; x := <span class="number">11</span> <span class="keyword">END</span>”</span><br></pre></td></tr></table></figure><h4 id="statement-list"><a href="#statement-list" class="headerlink" title="statement list"></a><red><em>statement list</em></red></h4><p>一个<strong><em>statement list</em></strong> 含有0个或多个语句，其位于<em>compound statement</em>内。如上面的例子</p><h4 id="statement"><a href="#statement" class="headerlink" title=" statement"></a><red><em>statement</em></red></h4><p>一个<em>statement<em>可以是一个 *compound statement</em>， 一个赋值语句<em>assignment statement</em>，或者是一个空语句*empty</em> statement。</p><h4 id="assignment-statement"><a href="#assignment-statement" class="headerlink" title="assignment statement"></a><red><em>assignment statement</em></red></h4><p>一个赋值语句的组成：<u>一个变量</u> 后面跟着 <u>一个指定的token（two characters, ‘:’ and ‘=’）</u> 后面跟着 <u>一个表达式</u>。如下所示：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“a := <span class="number">11</span>”</span><br><span class="line">“b := a + <span class="number">9</span> - <span class="number">5</span> * <span class="number">2</span>”</span><br></pre></td></tr></table></figure><h4 id="varible"><a href="#varible" class="headerlink" title="varible"></a><red><em>varible</em></red></h4><p>一个 <strong>变量<em>variable</em></strong>是一个<u>标识符<em>identifier</em></u>。我们将用ID token来表示variables，这个token的value是变量的名字(如，‘a’、‘number’、‘x’…..)。在下面的一个block的代码中的‘a’、‘b’就是变量：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“<span class="keyword">BEGIN</span> a := <span class="number">11</span>; b := a + <span class="number">9</span> - <span class="number">5</span> * <span class="number">2</span> <span class="keyword">END</span>”</span><br></pre></td></tr></table></figure><h4 id="empty-statement"><a href="#empty-statement" class="headerlink" title="empty statement"></a><red><strong><em>empty</em></strong> statement</red></h4><p>一个空语句表示一个语法规则，这个语法规则没有更深层的产生式<em>productions<em>。我们使用</em>empty_statement<em>语法规则来描述语法分析中末尾的</em>statement_list</em> ；同时也允许一个空的复合语句<em>compound statements</em>表示为：‘BEGIN END’</p><h4 id="factor"><a href="#factor" class="headerlink" title="factor"></a><red><em>factor</em></red></h4><p><em>factor</em>的规则更新为处理变量。</p><h3 id="完整的语法"><a href="#完整的语法" class="headerlink" title="完整的语法"></a>完整的语法</h3><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> : compound_statement DOT</span><br><span class="line"></span><br><span class="line">compound_statement : <span class="keyword">BEGIN</span> statement_list <span class="keyword">END</span></span><br><span class="line"></span><br><span class="line">statement_list : statement</span><br><span class="line">               | statement SEMI statement_list</span><br><span class="line"></span><br><span class="line">statement : compound_statement</span><br><span class="line">          | assignment_statement</span><br><span class="line">          | empty</span><br><span class="line"></span><br><span class="line">assignment_statement : variable ASSIGN expr</span><br><span class="line"></span><br><span class="line">empty :</span><br><span class="line"></span><br><span class="line">expr: term ((PLUS | MINUS) term)*</span><br><span class="line"></span><br><span class="line">term: factor ((MUL | DIV) factor)*</span><br><span class="line"></span><br><span class="line">factor : PLUS factor</span><br><span class="line">       | MINUS factor</span><br><span class="line">       | INTEGER</span><br><span class="line">       | LPAREN expr RPAREN</span><br><span class="line">       | variable</span><br><span class="line"></span><br><span class="line">variable: ID</span><br></pre></td></tr></table></figure><p>上面的语法中，</p><ul><li>在<em>compound_statement</em> rule 中没有用“*”来表示重复（0或多次），而是明确的制定了 <em>statement_list</em> rule。这是另一种方法来表示“0或多次”的操作。这在后面的语法分析器（如<a href="http://www.dabeaz.com/ply/" target="_blank" rel="noopener">PLY</a>）会派上用场。</li><li>我还将规则：“(PLUS | MINUS) factor”也细分成两个规则。</li></ul><h2 id="修改lexer-parser-interpreter"><a href="#修改lexer-parser-interpreter" class="headerlink" title="修改lexer,parser,interpreter"></a><red>修改lexer,parser,interpreter</red></h2><p>为了支持更新后的语法，我们需要修改我们的此番分析器、语法分析器和解释器。</p><h3 id="lexer的改变"><a href="#lexer的改变" class="headerlink" title="lexer的改变"></a><red>lexer的改变</red></h3><p>下面是我们此番分析器有改动的地方：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-9/lsbasi_part9_lexer.png" alt="img"></p><ol><li><p>为了支持Pascal程序的定义、复合语句、赋值语句、变量。我们需要新的token类型：（Pascal program’s definition, compound statements, assignment statements, and variables）</p><ul><li>BEGIN (标记复合语句的开始)</li><li>END (标记复合语句的结束)</li><li>DOT (一个token表示 点，用于Pascal程序的定义)</li><li>ASSIGN (一个token表示两个字符， ‘:=’)在Pascal中，赋值操作符不同于其他语言（如C语言用 “=”）</li><li>SEMI (一个token表示分号‘ ; ’ 。用来标记在复合语句中的一个句子的结尾)</li><li>ID（一个token表示 有效的标识符。）</li></ul></li><li><p>有时候，为了区分不同token（它们都以相同的字符为开头，如：‘:’ vs ‘:=’ or ‘==’ vs ‘=&gt;’），我们需要在不消耗下一个字符的情况下去查看输入缓冲区。为了这个特殊的目的，我介绍一种查看方法<em>peek</em> method，这种方法将帮助我们标记赋值语句。这个方法不是必要的，但是还是想早一点介绍一下，并且它也使得<em>get_next_token</em>函数简洁一些。</p><p>它所做的目的就是：从文本缓冲区返回下一个字符，但不增加<em>self.pos</em>的值。下面是这个方法的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">    peek_pos = self.pos + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> peek_pos &gt; len(self.text) - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> self.text[peek_pos]</span><br></pre></td></tr></table></figure></li><li><p>因为pascal中的 变量 和 保留字 都是 标识符。所以我们需要用一个方法来区分它们，方法为：<strong><em>_id</em></strong>。它工作的原理：词法分析器对这个字母、数字序列进行检查，看这个序列是否是保留字<em>reserved keyword</em>，如果是，就返回一个预先构造的token来表示这个保留字；如果不是，就返回一个新的ID token（它的值就是这个字符串）（lexeme）.下面是它的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RESERVED_KEYWORDS = &#123;</span><br><span class="line">    <span class="string">'BEGIN'</span>: Token(<span class="string">'BEGIN'</span>, <span class="string">'BEGIN'</span>),</span><br><span class="line">    <span class="string">'END'</span>: Token(<span class="string">'END'</span>, <span class="string">'END'</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_id</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Handle identifiers and reserved keywords"""</span></span><br><span class="line">    result = <span class="string">''</span></span><br><span class="line">    <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isalnum():</span><br><span class="line">        result += self.current_char</span><br><span class="line">        self.advance()</span><br><span class="line"></span><br><span class="line">    token = RESERVED_KEYWORDS.get(result, Token(ID, result))</span><br><span class="line">    <span class="keyword">return</span> token</span><br></pre></td></tr></table></figure></li><li><p>词法分析器的函数<em>get_next_token</em>的改变:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> self.current_char.isalpha():</span><br><span class="line">            <span class="keyword">return</span> self._id()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.current_char == <span class="string">':'</span> <span class="keyword">and</span> self.peek() == <span class="string">'='</span>:</span><br><span class="line">            self.advance()</span><br><span class="line">            self.advance()</span><br><span class="line">            <span class="keyword">return</span> Token(ASSIGN, <span class="string">':='</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.current_char == <span class="string">';'</span>:</span><br><span class="line">            self.advance()</span><br><span class="line">            <span class="keyword">return</span> Token(SEMI, <span class="string">';'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.current_char == <span class="string">'.'</span>:</span><br><span class="line">            self.advance()</span><br><span class="line">            <span class="keyword">return</span> Token(DOT, <span class="string">'.'</span>)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></li></ol><h3 id="parser的改变"><a href="#parser的改变" class="headerlink" title="parser的改变"></a><red>parser的改变</red></h3><p>下面是它的总的变化：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-9/lsbasi_part9_parser.png" alt="img"></p><ol><li><p>新的AST结点：</p><ul><li><p><strong><em>Compound</em> AST node</strong>：表示一个复合语句，在它的孩子的变量中包含着语句节点的列表；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compound</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="string">"""Represents a 'BEGIN ... END' block"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.children = []</span><br></pre></td></tr></table></figure></li><li><p><strong><em>Assign</em> AST node</strong>：表示赋值语句。它的左孩子的值是<strong><em>Var</em> node</strong>，右孩子结点存储着由expr解析器返回的结点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Assign</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, left, op, right)</span>:</span></span><br><span class="line">        self.left = left</span><br><span class="line">        self.token = self.op = op</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure></li><li><p><strong><em>Var</em> AST node</strong>：表示一个变量，它的value就是着这个变量的名字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Var</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="string">"""The Var node is constructed out of ID token."""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, token)</span>:</span></span><br><span class="line">        self.token = token</span><br><span class="line">        self.value = token.value</span><br></pre></td></tr></table></figure></li><li><p><strong><em>NoOp</em> node</strong>：用来表示一个空语句。如<code>‘BEGIN END’</code> 是一个有效的复合语句但没有句子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoOp</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>我们之前讲过，在我们的递归的语法分析器中每一个语法的规则都有相应的函数(method)。这次将增加7个新的函数。这些函数都是用于语法分析中新的语法和新的AST结点。下面就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">program</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""program : compound_statement DOT"""</span></span><br><span class="line">    node = self.compound_statement()</span><br><span class="line">    self.eat(DOT)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compound_statement</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    compound_statement: BEGIN statement_list END</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    self.eat(BEGIN)</span><br><span class="line">    nodes = self.statement_list()</span><br><span class="line">    self.eat(END)</span><br><span class="line"></span><br><span class="line">    root = Compound()</span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">        root.children.append(node)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">statement_list</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    statement_list : statement</span></span><br><span class="line"><span class="string">                   | statement SEMI statement_list</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    node = self.statement()</span><br><span class="line"></span><br><span class="line">    results = [node]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> self.current_token.type == SEMI:</span><br><span class="line">        self.eat(SEMI)</span><br><span class="line">        results.append(self.statement())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.current_token.type == ID:</span><br><span class="line">        self.error()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">statement</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    statement : compound_statement</span></span><br><span class="line"><span class="string">              | assignment_statement</span></span><br><span class="line"><span class="string">              | empty</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> self.current_token.type == BEGIN:</span><br><span class="line">        node = self.compound_statement()</span><br><span class="line">    <span class="keyword">elif</span> self.current_token.type == ID:</span><br><span class="line">        node = self.assignment_statement()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        node = self.empty()</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">assignment_statement</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    assignment_statement : variable ASSIGN expr</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    left = self.variable()</span><br><span class="line">    token = self.current_token</span><br><span class="line">    self.eat(ASSIGN)</span><br><span class="line">    right = self.expr()</span><br><span class="line">    node = Assign(left, token, right)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">variable</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    variable : ID</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    node = Var(self.current_token)</span><br><span class="line">    self.eat(ID)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">empty</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""An empty production"""</span></span><br><span class="line">    <span class="keyword">return</span> NoOp()</span><br></pre></td></tr></table></figure></li><li><p><strong><em>factor</em></strong> 函数的修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""factor : PLUS  factor</span></span><br><span class="line"><span class="string">              | MINUS factor</span></span><br><span class="line"><span class="string">              | INTEGER</span></span><br><span class="line"><span class="string">              | LPAREN expr RPAREN</span></span><br><span class="line"><span class="string">              | variable</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    token = self.current_token</span><br><span class="line">    <span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">        self.eat(PLUS)</span><br><span class="line">        node = UnaryOp(token, self.factor())</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        node = self.variable()</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure></li><li><p><strong><em>parse</em></strong> ：更新之后，它从程序的定义开始语法的分析：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self)</span>:</span></span><br><span class="line">    node = self.program()</span><br><span class="line">    <span class="keyword">if</span> self.current_token.type != EOF:</span><br><span class="line">        self.error()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure></li></ol><p>下面是一个简单的程序：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        number := <span class="number">2</span>;</span><br><span class="line">        a := number;</span><br><span class="line">        b := <span class="number">10</span> * a + <span class="number">10</span> * number / <span class="number">4</span>;</span><br><span class="line">        c := a - - b</span><br><span class="line">    <span class="keyword">END</span>;</span><br><span class="line">    x := <span class="number">11</span>;</span><br><span class="line"><span class="keyword">END</span>.</span><br></pre></td></tr></table></figure><p>它的解析树为（为了简洁，下面的树中变量的名字所在结点就是<strong><em>Var</em> node</strong>， <strong>Assign node</strong>赋值结点表示为 ‘:=’ ）：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://ruslanspivak.com/lsbasi-part9/lsbasi_part9_full_ast.png" alt="img"></p><h3 id="interpreter的改变"><a href="#interpreter的改变" class="headerlink" title="interpreter的改变"></a><red>interpreter的改变</red></h3><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-9/lsbasi_part9_interpreter.png" alt="img"></p><p>为了解释新的AST结点，我们需要在interpreter中添加相应的visitor 函数：</p><ul><li>visit_Compound</li><li>visit_Assign</li><li>visit_Var</li><li>visit_NoOp</li></ul><p>其中，<code>visit_Compound</code>：遍历它的孩子节点，<code>visit_NoOp</code>：什么都不做。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_Compound</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> node.children:</span><br><span class="line">        self.visit(child)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_NoOp</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><code>visit_Assign</code>：当我们给变量赋值时，需要将该变量的值存到某个地方，待用。这也就是此函数的功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_Assign</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    var_name = node.left.value</span><br><span class="line">    self.GLOBAL_SCOPE[var_name] = self.visit(node.right)</span><br></pre></td></tr></table></figure><blockquote><p>这个函数存储了一个键-值对key-value pair（一个变量名、一个变量的值），存储在<em>symbol table</em> GLOBAL_SCOPE。</p><ul><li><p>what is <em>symbol table</em>?</p><p><strong><em>symbol table</em></strong>是一个抽象数据类型（abstract data type (<strong>ADT</strong>)），用于跟踪源码中各种符号。目前的符号类型还只有变量，我们用Python字典趋势线符号表的ADT。</p><p>（在这里用符号字表 实现的笨拙：因为它不是一个带有特殊方法的独立类，而是一个简单的Python字典，而且它的另外职责是 内存空间。在后面的文章中，原作者将会带我们了解symbol tables的细节）</p></li></ul></blockquote><ul><li><p>让我们来看一下“a := 3;” 的AST，和它的 symbol table （<em>visit_Assign</em> 函数处理前和处理后的）：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-9/lsbasi_part9_ast_st01-1584541191100.png" alt="lsbasi_part9_ast_st01"></p></li></ul><p>现在让我们看看句子：“b := a + 7;”的AST：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-9/lsbasi_part9_ast_only_st02.png" alt="lsbasi_part9_ast_only_st02"></p><p><code>visit_Var</code>：可以看出，赋值语句得到右半部分：“a + 7” 提及变量a，所以我们要先知道变量a的value，这就是visit_Var函数要干的事情：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_Var</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    var_name = node.value</span><br><span class="line">    val = self.GLOBAL_SCOPE.get(var_name)</span><br><span class="line">    <span class="keyword">if</span> val <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> NameError(repr(var_name))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> val</span><br></pre></td></tr></table></figure><blockquote><p>visit 一个 <em>Var</em> 结点：它首先得到变量的名字；然后这个变量名字作为进入<em>GLOBAL_SCOPE</em> dictionary的key🔑去寻找变量的value，如果找到了 就返回变量地值，如果找不到就NameError函数伺候。</p><p>下面是“b := a + 7;”的AST和符号表（赋值前和复制后）</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-9/lsbasi_part9_ast_st02.png" alt="lsbasi_part9_ast_st02"></p></blockquote><hr><p>上面就是今天所有需要进行的update了。</p><p>At the end of the main program, we simply print the contents of the symbol table GLOBAL_SCOPE to standard output.</p><p>Let’s take our updated interpreter for a drive both from a Python interactive shell and from the command line. Make sure that you downloaded both the source code for the interpreter and the <a href="https://github.com/rspivak/lsbasi/blob/master/part9/python/assignments.txt" target="_blank" rel="noopener">assignments.txt</a> file before testing:</p><p>Launch your Python shell:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ python</span><br><span class="line">&gt;&gt;&gt; from spi import Lexer, Parser, Interpreter</span><br><span class="line">&gt;&gt;&gt; text &#x3D; &quot;&quot;&quot;\</span><br><span class="line">... BEGIN</span><br><span class="line">...</span><br><span class="line">...     BEGIN</span><br><span class="line">...         number :&#x3D; 2;</span><br><span class="line">...         a :&#x3D; number;</span><br><span class="line">...         b :&#x3D; 10 * a + 10 * number &#x2F; 4;</span><br><span class="line">...         c :&#x3D; a - - b</span><br><span class="line">...     END;</span><br><span class="line">...</span><br><span class="line">...     x :&#x3D; 11;</span><br><span class="line">... END.</span><br><span class="line">... &quot;&quot;&quot;</span><br><span class="line">&gt;&gt;&gt; lexer &#x3D; Lexer(text)</span><br><span class="line">&gt;&gt;&gt; parser &#x3D; Parser(lexer)</span><br><span class="line">&gt;&gt;&gt; interpreter &#x3D; Interpreter(parser)</span><br><span class="line">&gt;&gt;&gt; interpreter.interpret()</span><br><span class="line">&gt;&gt;&gt; print(interpreter.GLOBAL_SCOPE)</span><br><span class="line">&#123;&#39;a&#39;: 2, &#39;x&#39;: 11, &#39;c&#39;: 27, &#39;b&#39;: 25, &#39;number&#39;: 2&#125;</span><br></pre></td></tr></table></figure><p>And from the command line, using a source file as input to our interpreter:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python spi.py assignments.txt</span><br><span class="line">&#123;&#39;a&#39;: 2, &#39;x&#39;: 11, &#39;c&#39;: 27, &#39;b&#39;: 25, &#39;number&#39;: 2&#125;</span><br></pre></td></tr></table></figure><p>If you haven’t tried it yet, try it now and see for yourself that the interpreter is doing its job properly.</p><h2 id="summary"><a href="#summary" class="headerlink" title="summary"></a><red>summary</red></h2><p>让我们来总结一下，你今天扩展了Pascal解释器的哪些部分：</p><ol><li>添加新的语法规则</li><li>添加新的token，和它对应词法分析器中的方法（也更新了<em>get_next_token</em>）</li><li>在 parser 中为新的语法结构添加新的AST结点</li><li>在（递归下降的）语法分析中 添加相应对应新语法规则的新函数，</li><li>在interpreter中增添了新的visitor函数</li><li>新增 用于存储和查找变量的字典</li></ol><h2 id="HACKS"><a href="#HACKS" class="headerlink" title="HACKS"></a><red>HACKS</red></h2><p>现在要介绍一下“hacks”（不完善的地方），并且随着系列文章的深入，我们还将一步步解决这些内容：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-9/lsbasi_part9_hacks.png" alt="lsbasi_part9_hacks"></p><p>上图中的不完善的地方，也就是这些：</p><ol><li><p><em>program</em> 语法规则目前不完善，在后续文章会扩展；</p></li><li><p>Pascal语言是一个静态类型语言，在使用变量之前必须要先声明；</p></li><li><p>没有类型检测，目前还不是什么大问题。但当有更多类型的时候，就需要类型检测；</p></li><li><p>符号表</p></li><li><p>目前为止，都是用“/”来表示除法。但在Pascal语言中，必须要用关键字“div”来表示整数除法；</p></li><li><p>在Pascal语言中，标识符 和 保留字 是不区分大小写的(case insensitive)。但是在目前的文章中，我们把它设计成了区分大小写。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Let&#39;s Build A Simple Interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Front-matter的规则</title>
      <link href="/archives/138a.html"/>
      <url>/archives/138a.html</url>
      
        <content type="html"><![CDATA[<p>文章写作时，的front matter 的参数</p><a id="more"></a><p>参数描述<code>layout</code>布局<code>title</code>标题<code>date</code>建立日期<code>updated</code>更新日期<code>comments</code>开启文章的评论功能<code>tags</code>标签（不适用于分页）<code>categories</code>分类（不适用于分页）<code>permalink</code>覆盖文章网址</p><p>其中，分类和标签需要区别一下，分类具有顺序性和层次性，也就是说<code>Foo</code>，<code>Bar</code>不等于<code>Bar</code>，<code>Foo</code>；而标签没有顺序和层次。</p><p><strong>注意：每个冒号后面是有一个空格的。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">title: 文章的front-matter规则 <span class="comment">// 你的博客名字    </span></span><br><span class="line">date: <span class="number">2019</span><span class="number">-08</span><span class="number">-10</span> <span class="number">21</span>:<span class="number">44</span>:<span class="number">44</span>  <span class="comment">//文章创建的日期</span></span><br><span class="line">author: longlongqin   <span class="comment">//作者名字</span></span><br><span class="line">img: /medias/banner/<span class="number">6.</span>jpg <span class="comment">//文章的显示的时候的背景</span></span><br><span class="line">coverImg: /medias/banner/<span class="number">6.</span>jpg  </span><br><span class="line">top: <span class="literal">true</span></span><br><span class="line">cover: <span class="literal">true</span></span><br><span class="line">toc: <span class="literal">true</span></span><br><span class="line">password: </span><br><span class="line">mathjax: <span class="literal">true</span></span><br><span class="line">summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</span><br><span class="line">tags:</span><br><span class="line">- Hexo</span><br><span class="line">- Github</span><br><span class="line">- 博客</span><br><span class="line">categories:</span><br><span class="line">- 软件安装与配置</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">配置选项</th><th align="left">默认值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">title</td><td align="left"><code>Markdown</code> 的文件标题</td><td align="left">文章标题，强烈建议填写此选项</td></tr><tr><td align="left">date</td><td align="left">文件创建时的日期时间</td><td align="left">发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td align="left">author</td><td align="left">根 <code>_config.yml</code>中的 <code>author</code></td><td align="left">文章作者</td></tr><tr><td align="left">img</td><td align="left"><code>featureImages</code>中的某个值</td><td align="left">文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td align="left">top</td><td align="left"><code>true</code></td><td align="left">推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td align="left">cover</td><td align="left"><code>false</code></td><td align="left"><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td align="left">coverImg</td><td align="left">无</td><td align="left"><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td align="left">password</td><td align="left">无</td><td align="left">文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td align="left">toc</td><td align="left"><code>true</code></td><td align="left">是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td align="left">mathjax</td><td align="left"><code>false</code></td><td align="left">是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td align="left">summary</td><td align="left">无</td><td align="left">文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td align="left">categories</td><td align="left">无</td><td align="left">文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td align="left">tags</td><td align="left">无</td><td align="left">文章标签，一篇文章可以多个标签</td></tr><tr><td align="left">reprintPolicy</td><td align="left">cc_by</td><td align="left">文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><p><strong>注意</strong>:</p><blockquote><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2" target="_blank" rel="noopener">开源中国在线工具</a>、<a href="http://encode.chahuo.com/" target="_blank" rel="noopener">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx" target="_blank" rel="noopener">站长工具</a>。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> front-matter配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let’s Build A Simple Interpreter-8</title>
      <link href="/archives/ae12.html"/>
      <url>/archives/ae12.html</url>
      
        <content type="html"><![CDATA[<p>今天，将要在前面的基础上，添加<strong>一元操作符unary operators</strong>：unary plus (+) and unary minus (-) operators。</p><a id="more"></a><p><strong>今天将要完成的任务：</strong></p><ul><li>扩展语法，能够处理“+”、“-”一元操作符；</li><li>添加一个新的结点类：<em>UnaryOp</em> AST node class；</li><li>扩展语法分析器parser，生成含有<em>UnaryOp</em> nodes结点的抽象语法树；</li><li>扩展解释器interpreter。并且增添一个新的<em>visit_UnaryOp</em> method函数，它可以解析一元操作符</li></ul><p>现在，开始吧。</p><h1 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h1><h2 id="一元操作符是什么？"><a href="#一元操作符是什么？" class="headerlink" title="一元操作符是什么？"></a>一元操作符是什么？</h2><p><strong>二元操作符：</strong></p><p>之前，我们的计算器都是围绕着这些二元操作符 (+, -, *, /)在工作，这些操作符操作两个操作数（the operators that operate on two operands.）。</p><p><strong>一元操作符<em>unary operator</em> ：</strong></p><p>那么，我们就能知道一元操作符是：一个操作符只操作一个操作数。（A <em>unary operator</em> is an operator that operates on one <em>operand</em> only.）</p><h2 id="一元操作符的规则"><a href="#一元操作符的规则" class="headerlink" title="一元操作符的规则"></a>一元操作符的规则</h2><p>下面是一元操作符“+、-”的规则：</p><ul><li>一元操作符<code>-</code>：它会使它的操作数取反（negation）</li><li>一元操作符<code>+</code>：他对于它的操作数没影响，即，它的操作数不改变什么</li><li>一元操作符比二元操作符（+, -, *, and /）有着更高的优先级（precedence）</li></ul><p>例子：</p><ol><li><p><strong>“+ - 3”</strong></p><p>其中，这第一个位置的“+”表示一元操作符加号操作；第二个位置的“-”表示一元操作符减号操作。所以，“+ - 3”就相当于“+ (- (3))”，即，等于-3。</p><p>【注】：这里的-3平常情况说它是一个负整数（negative integer），但是在这里我们称它是：一个一元操作符“-”，它的操作数是3。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-8/lsbasi_part8_exp1.png" alt="img"></p></li><li><p><strong>“5 - - 2”</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-8/lsbasi_part8_exp2.png" alt="img"></p><p><u>在这个表达式中，第一个“-”表示一个二元操作符：减法。第二个“-”表示一个一元操作符：取反。</u></p><p>比如下面的一些例子，也是这个样子：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-8/lsbasi_part8_exp3.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-8/lsbasi_part8_exp4.png" alt="img"></p></li></ol><h1 id="开始修改"><a href="#开始修改" class="headerlink" title="开始修改"></a>开始修改</h1><h2 id="将一元操作符添加入语法"><a href="#将一元操作符添加入语法" class="headerlink" title="将一元操作符添加入语法"></a>将一元操作符添加入语法</h2><h3 id="修改factor"><a href="#修改factor" class="headerlink" title="修改factor"></a>修改factor</h3><p>因为，一元操作符的优先级高于二元操作符。所以，函数<code>factor</code>需要需改。它之前的规则为：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-8/lsbasi_part8_factor_before.png" alt="更新前"></p><p>更新后的，规则为：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-8/lsbasi_part8_factor_after.png" alt="更新后"></p><blockquote><p>从更新后的factor函数的规则，可知：<strong>它扩展之后能够引用它本身</strong>。</p><p>这样我们就能够写出类似于：- - - + - 3”这样的式子，这是合法的带有很多一元操作符的表达式。</p></blockquote><p>其实，这里修改语法，只用修改<code>factor</code>函数的产生式，其他的<code>expr</code>、<code>term</code>产生式不变：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-8/lsbasi_part8_grammar.png" alt="img"></p><h2 id="扩展抽象语法树的结点类"><a href="#扩展抽象语法树的结点类" class="headerlink" title="扩展抽象语法树的结点类"></a>扩展抽象语法树的结点类</h2><p>下一步就是要添加一个AST node class，来表示一元操作符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnaryOp</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, op, expr)</span>:</span></span><br><span class="line">        self.token = self.op = op</span><br><span class="line">        self.expr = expr</span><br></pre></td></tr></table></figure><p>这个函数有两个参数：op、expr：</p><ul><li>op：代表一元操作符的token（+或-）</li><li>expr：表示一个AST的结点（要与expr函数区分，这两个知识名字一样，但是代表的东西不一样）</li></ul><h2 id="扩展语法分析器parser"><a href="#扩展语法分析器parser" class="headerlink" title="扩展语法分析器parser"></a>扩展语法分析器parser</h2><p>之前我们修改了语法规则，当中的factor函数的产生式也发生了变化，所以现在我们将要修改代码，使其能够处理产生式中的 “(PLUS | MINUS) factor” 子规则：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""factor : (PLUS | MINUS) factor | INTEGER | LPAREN expr RPAREN"""</span></span><br><span class="line">    token = self.current_token</span><br><span class="line">    <span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">        self.eat(PLUS)</span><br><span class="line">        node = unaryop(token, self.factor())</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">        self.eat(MINUS)</span><br><span class="line">        node = unaryop(token, self.facot())</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="keyword">elif</span> token.type == INTEGER:</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        node = NUM(token)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="keyword">elif</span> token.type == LPAREN:</span><br><span class="line">        self.eat(LPAREN)</span><br><span class="line">        node = self.expr()</span><br><span class="line">        self.eat(RPAREN)</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure><h2 id="扩展解释器Interpreter"><a href="#扩展解释器Interpreter" class="headerlink" title="扩展解释器Interpreter"></a>扩展解释器Interpreter</h2><p>现在我们还需要扩展解释器类<em>Interpreter</em> class ，向其中添加<em>visit_UnaryOp</em> 函数，来解释一元操作符结点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit_UnaryOp</span><span class="params">(self, node)</span></span></span><br><span class="line">op = node.op.type #token的类型</span><br><span class="line">    <span class="keyword">if</span> op == PLUS:</span><br><span class="line">        <span class="keyword">return</span> +self.visit(node.expr)</span><br><span class="line">    <span class="keyword">elif</span> op == MINUS:</span><br><span class="line">        <span class="keyword">return</span> -self.visit(node.expr)</span><br></pre></td></tr></table></figure><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>让我们看一个例子，表达式 “5 - - - 2” ，通过我们的解析器来证实这个新的<em>visit_UnaryOp</em>函数确实起作用了。</p><p>下面是如何从Python shell中实现:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> spi <span class="keyword">import</span> BinOp, UnaryOp, Num, MINUS, INTEGER, Token</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>five_tok = Token(INTEGER, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>two_tok = Token(INTEGER, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>minus_tok = Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>expr_node = BinOp(</span><br><span class="line"><span class="meta">... </span>    Num(five_tok),</span><br><span class="line"><span class="meta">... </span>    minus_tok,</span><br><span class="line"><span class="meta">... </span>    UnaryOp(minus_token, UnaryOp(minus_token, Num(two_tok)))</span><br><span class="line"><span class="meta">... </span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> spi <span class="keyword">import</span> Interpreter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inter = Interpreter(<span class="literal">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inter.visit(expr_node)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>上面的AST树看起来是这样的:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-8/lsbasi_part8_ast.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Let&#39;s Build A Simple Interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造凸包——Divide And Conquer</title>
      <link href="/archives/f32f.html"/>
      <url>/archives/f32f.html</url>
      
        <content type="html"><![CDATA[<p>Graham Scan算法说明了凸包构造问题的下界O(nlogn)是可以达到的。其实O(nlogn)的算法远不止这一种，分治法就是一种能达到O(nlogn)复杂度的思想。在此引入运用分治思想的两种算法来构造凸包。</p><a id="more"></a><h1 id="归并排序与分治思想"><a href="#归并排序与分治思想" class="headerlink" title="归并排序与分治思想"></a>归并排序与分治思想</h1><p>引入新算法之前依旧先来回顾一个经典排序算法：归并排序（merge sort）。归并排序的基本流程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315163056136.png" alt="image-20200315163056136"></p><p>算法分为两个阶段：<strong>分（divide）</strong>和<strong>归并（merge）</strong>。</p><ul><li><strong>分</strong>的阶段将待排序列均分到一个个子序列（如图中划分到单个元素）。</li><li><strong>归并</strong>阶段将分好的子序列两两合并成有序序列，重复合并的过程直到整体归为一个序列。</li></ul><p>归并过程共logn步，每步耗费n的时间，总体复杂度为O(nlogn)。</p><p>归并排序的过程就是一个典型的分治（divide-and-conquer）策略。凸包构造问题也可以套用这种策略来分而治之，逐步求解。<u>我们可以将待处理点集S分为同等规模的两个子点集，并分别对其求凸包。</u></p><p>有了两个子解后，问题就变成了如何<strong>适当加一些边</strong>，将两个子凸包merge成整体解。<strong>分治法核心的任务就是如何merge。</strong></p><h1 id="Divide-And-Conquer（1）"><a href="#Divide-And-Conquer（1）" class="headerlink" title="Divide And Conquer（1）"></a>Divide And Conquer（1）</h1><h2 id="预处理为star-shaped-polygon"><a href="#预处理为star-shaped-polygon" class="headerlink" title="预处理为star-shaped polygon"></a>预处理为star-shaped polygon</h2><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315163119718.png" alt="image-20200315163119718"></p><p>分治法解决问题的过程可以概括为：大事化小，小事化了。就是首先将问题划分为易求解的子问题，子问题套用已知方法解答即可。例如子凸包的构造就能用Graham Scan来解决。</p><p>Graham Scan解决问题的前提是：参照基准点，其他点按极角有序排列，也就是构成了一个有序的星形多边形（star-shaped polygon）。<strong>首先要做的就是将两个子凸包预处理成两个star-shaped polygon。</strong></p><blockquote><p><strong>star-shaped polygon星形多边形</strong>是什么呢？</p><p>其实就是在多边形内部存在一个点A，这个点与多边形内任意一点的连线都在多边形内部，就叫做星形多边形，这一个点A就叫做多边形的内核。</p></blockquote><p>由于任何一个凸多边形都是star-shaped polygon，它必然有一个核，其他点按极角有序排列。<u>问题在于如何找到一个公共核</u>，使得两个子凸包同时关于这个核是极角有序排列的。也就是公共核处于两个凸包的交部分，这样是最好处理的情况（如下左图）。不过还有可能有其他情况，不能找到公共核（如下中图），甚至两个凸包根本不相交（如下右图）：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315163145301.png" alt="image-20200315163145301"></p><p>这就要将分治策略分不同情况来实现：</p><h3 id="两个子凸包有公共核："><a href="#两个子凸包有公共核：" class="headerlink" title="两个子凸包有公共核："></a>两个子凸包有公共核：</h3><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315163518484.png" alt="image-20200315163518484"></p><p><u>先找其中一个子凸包的核</u>：我们可以任取该子凸包上的三点构成三角形，求三角形重心作为核。</p><p><u>然后判断这个核是否也在另一个子凸包内部</u>，若判定为真，就是有公共核的最简单情况。判定方法也就是之前提过的<u>in convex polygon test</u>，对凸包每条边做to left test即可，在线性时间内可以判定。</p><p><strong>找到公共核之后，进行凸包形成</strong>：—-用二路归并</p><p>相对于公共核，两个子凸包的各自有序排列，相互交错。要做的就是将二者点序列合并，方法正是经典的<strong>二路归并</strong>，线性时间可以完成。最后进行Graham Scan即可得到大凸包。</p><h3 id="一个子凸包的核落在另一个子凸包外部："><a href="#一个子凸包的核落在另一个子凸包外部：" class="headerlink" title="一个子凸包的核落在另一个子凸包外部："></a>一个子凸包的核落在另一个子凸包外部：</h3><p>存在公共核的情况处理是很简单的，再看第一个子凸包的核落在第二个子凸包外部的情况。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315164325225.png" alt="image-20200315164325225"></p><p>这中情况与<strong>增量构造法</strong>的情况很相似，P1的核x相对于P2就是一个新加入的点。做出两条support line：x→t和x→s，舍弃P2上t→s路径的点即可。这样P2中剩余点与x构成了一个星形多边形，x也成为了P2的核。<strong>这就转化成了第一种有公共核的情况。</strong></p><h1 id="Divide-And-Conquer（2）"><a href="#Divide-And-Conquer（2）" class="headerlink" title="Divide And Conquer（2）"></a>Divide And Conquer（2）</h1><p>上述分治策略的算法过于复杂，所以引入一种更加简明的分治策略。这种分治策略也会为三角剖分等问题提供思路。</p><p>首先规定一种点集划分的策略。假设待合并的两个子凸包是沿着某方向是分离的，<strong>二者不相交</strong>（Divide And Conquer（1）中是有相交的）。例如下图凸包P1和P2就是相互分离的：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315164957102.png" alt="image-20200315164957102"></p><p><strong>这样划分会使得合并更加简明，不必区分多种复杂情况</strong>。</p><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>为了满足这种划分策略，<strong>需要引入一种预处理</strong>，也就是一个x方向的排序过程（X-sorting）。排序后就可取点x坐标的中值，将点集划分为规模相当的左右两个子集。每个凸包都有其<strong>最左点l</strong>和<strong>最右点r</strong>，如上图。</p><h2 id="merge操作"><a href="#merge操作" class="headerlink" title="merge操作"></a>merge操作</h2><p>现在<strong>merge操作</strong>就是将两个左右相离的两个子凸包合并为一个大凸包的过程了。运算的关注的正是两对l和r点。</p><p>先直观感受一下merge操作要添加的新极边：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315165142262.png" alt="image-20200315165142262"></p><p>上下两条紫色边正是要求的新边，又称支撑边（<strong>support line</strong>），<u>并且每次merge<strong>只会</strong>增加<strong>两条</strong>新边</u>。两条边类似两个圆的<strong>公切线（common tangent）</strong>，将二者连接起来。</p><blockquote><p>注意，注意，注意：<strong>眼睛可能会欺骗你</strong></p><p>直观上感觉，两条support line正是两个子凸包的最高点t和最低点b相互连接得到的，这些点只需线性时间就能找到。<u>当真如此的话凸包构造的下界就成了O(n)，显然直觉是错误的。</u>例如下面的两种情况，support line就和b、t两点没有直接关系了：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315165430771.png" alt="image-20200315165430771">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315165443290.png" alt="image-20200315165443290"></p><p>构造support line的过程需要缜密的分析，并非凭直觉能得到的。</p></blockquote><h3 id="缝合（stitch）—构造support-line"><a href="#缝合（stitch）—构造support-line" class="headerlink" title="缝合（stitch）—构造support line"></a>缝合（stitch）—构造support line</h3><p>将两个子凸包连接的过程更像古代妇女用针将两块布缝合在一起（但是这里的两个凸包的间距是不能变的，仅仅是用线将其连接在一起。而且这里连接只需要最后找出来的那两条线，其余剩下的中间“工具线”都要舍去）。</p><p>构造过程首先从<strong>左凸包的r点</strong>和<strong>右凸包的l点</strong>连线开始，以这条线为基础逐步得到support line。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315165636768.png" alt="image-20200315165636768"></p><blockquote><p>注意一个细节问题：</p><p>如何得到各子凸包的l点和r点。每次合并都会产生新的凸包，所以凸包是一个动态的结构。当然可以每次计算出最左点和最右点，只需要线性时间。但是这并不是最优的方式。考虑分治的思想，就整个merge流程来讲，是自底向上将子凸包两两合并的过程。因此只要在最底层上最小的子凸包中记录最左点和最右点，每次merge更新一下这两个变量即可，只需要O(1)的常数时间！这种优化对整体的复杂度上线nlogn虽然没有影响，也能为程序节省一部分的开销。</p></blockquote><h4 id="缝合上半部分"><a href="#缝合上半部分" class="headerlink" title="缝合上半部分"></a>缝合上半部分</h4><blockquote><p>再看如何将最初的r-l线变成support line，在此以<strong>寻找upper support line为例</strong>（上切线，相应的还需要计算下切线）。<strong><u>算法的核心依然是to left test</u></strong>。</p></blockquote><ul><li><strong>首先看<code>l</code>点</strong>，从r-l线出发，可以发现相对于对于r→l时，l的前驱、后继是LR型的。而我们想要的是RR型的。所以必须要找l的前驱。直到在某一个时刻，我们找到了l的一个前驱点满足RR型：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315171448455.png" alt="找到l点的前驱满足当前形势的RR"></p><ul><li><p><strong>再看<code>r</code>点</strong>，同样的，从此时的状态，来观察r的类型：是RL型的。要想成为LL型，r必须要找它的后驱。</p><p>在某一时刻，r找到r的后继（就是该凸包点t）使其满足LL型：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315171826930.png" alt="找到r的后驱满足当前形势的LL"></p></li><li><p><strong>反过来继续看<code>l</code></strong>，此时，<strong>具体的说应该是检测l的前驱点<code>l&#39;</code></strong>，经检测，<code>l&#39;</code>已经不再满足RR型了，编程了LR型，所以还要继续寻找它的前驱点，使其再次满足RR型。</p><p>某一时刻，找到它的前驱（就是该凸包的点t），使其成为RR型。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315171826931.png" alt="image-20200315171826931"></p><ul><li><strong>反过来继续看<code>r</code></strong>，此时，更准确的应该说是在看<code>r&#39;</code>，经检测，该店符合LL型。至此，所谓的<code>r</code>和<code>l</code>都已经符合RR或LL型了。从而已经找到<strong>upper support line</strong>了。结束上半部分。</li></ul></li></ul><blockquote><p>回顾由r-l线逐步推进得到support line的过程，每次操作一个端点，得到是一种“Z”字形（zig-zag）的推进轨迹。操作点的切换由另一点满足要求决定，而算法停止的依据是两个端点同时满足了要求。这种方式类似快速排序构造轴点的过程，左右两轴点交替操作，直到二者都满足要求时算法停止。</p></blockquote><h4 id="缝合下半部分"><a href="#缝合下半部分" class="headerlink" title="缝合下半部分"></a>缝合下半部分</h4><p>缝合下半部分的流程与，上半部分流程一样。</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>分析一下算法时间复杂度。<strong>算法首先要按照x坐标排序，排序复杂度为O(nlogn)。</strong>再看merge过程，无论是左侧子凸包还是右侧子凸包，对于其每个点的操作至多只有以此，也就是每次归并是线性时间。归并共logn次，算法的<strong>总体复杂度就是O(nlogn)</strong>了。</p><h1 id="更多的考虑"><a href="#更多的考虑" class="headerlink" title="更多的考虑"></a>更多的考虑</h1><p>在这些算法讲解中，<strong>通常都是不考虑退化的情况</strong>，如，三点共线……</p><p>最后总结一下第二种分治法的特点。此前<a href="http://blog.csdn.net/houszchina/article/details/79261505" target="_blank" rel="noopener">Jarvis March算法</a>虽然以平方复杂度为上界，但其”输出敏感性“使得实际复杂度为O(hn)，最好情况下仅甚至为线性。例如如下情况：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Divide-And-Conquererer/image-20200315174908920.png" alt="image-20200315174908920"></p><p>Jarvis March算法的复杂度变为了O(4n)，而此时分治法依旧会经历按部就班的X-sorting，一上来就注定了O(nlogn)的复杂度，然后经历同样O(nlogn)的merge过程。也就是说这种分治法在各种情况下的表现都是很均匀的。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造凸包-Graham Scan法</title>
      <link href="/archives/3478.html"/>
      <url>/archives/3478.html</url>
      
        <content type="html"><![CDATA[<h1 id="Graham-Scan算法的流程"><a href="#Graham-Scan算法的流程" class="headerlink" title="Graham Scan算法的流程"></a>Graham Scan算法的流程</h1><p>假设待处理点集S共有n个点。</p><h2 id="1、预处理"><a href="#1、预处理" class="headerlink" title="1、预处理"></a>1、预处理</h2><ol><li><p><strong>预排序(presorting</strong>）</p><p>Graham Scan首先要做的是一个预处理排序操作（<strong>presorting</strong>）。即找到某个基准点，然后将其余所有的点按照相对于基准点的<strong>极坐标</strong>排序。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/20180207204917568.jpg" alt="img"></p><blockquote><p>点的排序可以套用任意排序算法的框架，只是将排序对象由数值变为了平面上的点，而比较器改为<strong>to left test</strong>实现。</p></blockquote><p><strong>如何找出第一个点：点1？</strong></p><blockquote><p>以点1为基准点，其余点按照相当于点1的极角依次排序为2、3、4……理论上讲任何一个点都能当第一个基准点，为了简化算法通常选择<strong>lowest-then-leftmost point（LTL）</strong>作为基准点。</p></blockquote></li><li><p><strong>找出起始边</strong></p><p>对于与基准点1极角最小的点，也就是图中点2（假设没有三点共线的情况）。将点1和点2作为算法的起始点。</p></li><li><p><strong>将起始边 与 剩下的n-2条边分别存储在不同的栈(stack)中：</strong></p><p>算法开始前先将起始点1和2入栈S，其他的n-2个点入栈T，如下图。注意S和T中元素的入栈顺序。至此预处理已经完成。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/image-20200314181609764.png" alt="栈：T和S"></p><blockquote><p>Graham Scan用到的数据结构。整个算法非常简明，核心数据结构只有两个<strong>栈</strong>，分别记作栈<strong>S</strong>和栈<strong>T</strong>。便于理解我们将S和T画成开口相对的形式，如上图。</p></blockquote></li></ol><h2 id="2、scan操作-此处为逆时针扫描"><a href="#2、scan操作-此处为逆时针扫描" class="headerlink" title="2、scan操作(此处为逆时针扫描)"></a>2、scan操作(此处为逆时针扫描)</h2><p>完成预处理之后，就能开始算法的核心：scan操作。scan的过程主要关注三个点：<strong>栈S的栈顶（S[0]）、次栈顶（S[1]）和栈T的栈顶（T[0]）</strong>。也就下图红色标注的三个点：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/20180207210925858.jpg" alt="img"></p><p>对这三个关注的点，进行检测，检测的框架为：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/image-20200314182719216.png" alt="image-20200314182719216"></p><ul><li>可以观察到，<u>每次待处理的S[0]和S[1]构成的边一定是一条极边（如上图点1和点2）</u>，算法<strong>关键步骤</strong><u>就是对边这条极边和T[0]做to left test，判断T[0]位于边S[0]S[1]的左边还是右边。若在左边则继续拓展，若在右边则否定掉此前认定的极边。</u>无论结果如何，每次判定都会将问题规模缩小一个单元，算法结束时T最终肯定为空。T空后，S中存留下的点正是凸包的极点，这些点自底而上正是凸包边界点的逆时针遍历，也得到了整个凸包构造问题的解。</li></ul><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><strong>1、</strong>先来看一个最简单的例子，即点集S中所有的点都在凸包边界上。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/image-20200314183056395.png" alt="image-20200314183056395"></p><ul><li><p>先找到LTL，也就是图中点1。然后基于点1对其余点按极角排序为点2、3、4……<em>（实际上以一个点为中心的有序的点集，构成了所谓的星形多边形（star-shaped polygon），中心点正是星形多边形核（kernel）的一部分。凸多边形必然是星形多边形，反之则不然。）</em>然后找到点1的后继2，点1和点2构成第一条极边。初始化栈S和栈T。</p></li><li><p>现在要关心S[1], S[0]和T[0]，就是点1，2和3。点3位于边12左侧，to left关系为true，S.push ( T.pop() )，向前拓展了一条暂定极边。</p></li><li><p>接下来重复上述过程。考虑点2，3和4。to left关系为true，S.push( T.pop() )……最终栈T空，算法结束，凸包由栈S自底向上得到。S和T的变化过程如下图：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/image-20200314211052355.png" alt="image-20200314211052355"></p><hr><p><strong>2、</strong>上面列举了最简单的情况下Graham Scan的过程，接下来列举一个更有代表性的实例深入算法的细节。输入的点集S，并进行预处理排序，并初始化栈S、T，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/20180207215925185.jpg" alt="20180207215925185"></p><ul><li><p>接下来对点1，2和3进行to left测试，本质上就是判断边2→3（图中黄色边）能否被暂时采纳。测试结果为true，暂时采纳边2→3，<strong>S.push( T.pop() )</strong>。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/image-20200314211330428.png" alt="image-20200314211330428"></p><blockquote><p>注意图中蓝色边表示已经被暂时接纳的边，也就是算法暂时认定的极边。上一次操作将蓝色边推进一个单元</p></blockquote></li><li><p>接下来关注点2，3和4，来判断下一条黄色边3→4能否被接纳。to left测试为true，<strong>S.push( T.pop() )</strong>，接纳边3→4。如下图右侧所示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/image-20200314211603647.png" alt="image-20200314211603647"></p></li><li><p>然后判断点3，4和5。点5在边3→4的右侧，即to left测试为false。<strong>S.pop()</strong>，也就是判断出点4不可能为极点，丢弃4。因此算法回溯到点3，判断点2，3和5的关系。5在2→3的左侧，暂时接纳边3→5，<strong>S.push( T.pop() )。</strong>如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/image-20200314211705197.png" alt="image-20200314211705197"></p><blockquote><p>算法经历了无效操作，进行了回溯，得到了目前来说最优的“极边”。虽然这些”极边“不一定能最终保留，但问题的规模得到了削减。</p></blockquote></li><li><p>下一次scan考察的就是3，5和6了。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/image-20200314211916570.png" alt="image-20200314211916570"></p><blockquote><p>3，5和6的to left测试为false，<strong>S.pop()</strong>，舍弃点5。</p></blockquote></li><li><p>然后考察点2，3和6，to left测试为false，<strong>S.pop()</strong>舍弃点3。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/20180207223417072.jpg" alt="img"></p></li><li><p>……..</p></li><li><p>………</p></li><li><p>直遍历完剩下其他点，凸包就构造完成。</p></li></ul><h1 id="验证算法的正确性"><a href="#验证算法的正确性" class="headerlink" title="验证算法的正确性"></a>验证算法的正确性</h1><h2 id="思路上的正确性"><a href="#思路上的正确性" class="headerlink" title="思路上的正确性"></a>思路上的正确性</h2><p>了解了算法的整体流程之后，我们再来论证一下算法的正确性。证明一个算法正确性的方法有很多，在此选用数学归纳法。数学归纳法的思想可用多米诺骨牌类比，要做的无非是两件事：证明第1张骨牌会倒；证明如果第n张骨牌会倒则第n+1张骨牌也会倒下。</p><p>Graham Scan过程就是一个个引入点的过程。每当我们得到第k个点的时候，算法所得到的就是前k个点对应的“最好的凸包”。因此当k = n时得到的是整体的凸包。</p><ol><li><p>归纳的第一步就是证明k = 3时得到的是当前点集S‘ = {1，2，3}中的极边——也就是证明第1张骨牌会倒。</p><blockquote><p>显然边1→2是S’的一条极边。而根据预处理的方式，3相较于1的极角一定大于2，因此点3一定在边1→2的左侧，因此边2→3会得到保留。对于这三个点来说，任意两条边一定都是极边，2→3也是一条极边。</p></blockquote></li><li><p>然后证明：假设已经处理到第k个点，得到的是前点集S’ = {1，2，3，…，k}中所谓“最好的凸包”。根据算法处理方式，接下来从S’’ = {1，2，3，…，k，k+1}得到的结果是否也是正确的——也就是证明第n张骨牌会倒，则第n+1张骨牌也会倒下。</p><blockquote><p>预处理的方式是对2~n所有点相较于点1按极角排序，因此下一个要处理点k+1一定出现在线1→k的左侧，也就是下图蓝色区域和绿色区域（假设k = 9）：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/20180207231513568.jpg" alt="img"></p><p>而根据目前接纳的最后一条极边( k-1)→k （例如图中8→9）来划分，点k+1可能出现的区域又分为两块，即该极边的左侧（绿色区域）和右侧（蓝色区域）。这也正对应于算法判定的两个分支。</p><ul><li><p>左侧：左侧的情况很简单，点k+1显然会是一个新的极点。Graham Scan要做的正是暂时接纳边k→k+1，拓展了一个新的单位。</p></li><li><p>右侧：再看k+1落在右侧的情况。如下图点10：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/20180207232235024.jpg" alt="img"></p><p>Graham Scan要做的是丢弃点k（图中点9），也就是判定出点k不可能是极点。这样做的原因：是引入点k+1后，点k一定会被包含在三角形(1, k-1, k+1)内部。如图中点9一定包含于三角形(1, 8, 10)内部。正如极点法中排除非极点的做法，点k被排除是正确的做法。接下来点k-1，k-2等（如图中点8，点7等）也可能是非极点，按照算法的流程，它们总会被判定在某个三角形的内部（例如点7在三角形(1, 5, 10)内部）而被排除，直到left test为true，回溯停止。</p><p>换个角度考虑，回溯停止时得到的新边正是增量构造法中每步得到的support line，即切线。例如图中线5→10正是算法当前保留的”凸包“的切线。这也能论证Graham Scan处理方式的正确性。</p></li></ul></blockquote></li></ol><p>至此，算法思路上的正确性已经证明完毕。</p><h2 id="表述方式的正确性"><a href="#表述方式的正确性" class="headerlink" title="表述方式的正确性"></a>表述方式的正确性</h2><p>接下来还要考虑算法的表述方式是否有漏洞：代码中每次to left test之前并没有判断S栈中是否有≥2个元素。这也可以由预处理的方式来论证。点1选取的是LTL，而点2是相对于点1极角最小的点，这样的做法保证了除了点1和点2之外所有的点一定是在边1→2左侧的。因此算法回溯最多到点2，永远不可能把点2丢弃，S中元素任何时候至少有两个。</p><hr><p>Graham Scan算法的正确性论证完毕。</p><h1 id="预处理操作的必要性"><a href="#预处理操作的必要性" class="headerlink" title="预处理操作的必要性"></a>预处理操作的必要性</h1><p>最后来思考一下预处理操作：presorting。仔细回顾上述论证过程会发现，每一步的正确性都是建立在最初的排序上的。那么这个预处理排序真的是必要的吗？可以来举极端的反例，每次选取下一个点都是随机的，例如下图的路径：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/20180207235736089.jpg" alt="img"></p><p>上图中从点1开始出发进行to left测试，可以发现，每次判定结果都为true，最终所有的点都被保留了下了，而显然这并不是一个凸包。因此presorting是整个算法成立的基础。</p><h1 id="分析复杂度"><a href="#分析复杂度" class="headerlink" title="分析复杂度"></a>分析复杂度</h1><p>上面证明了Graham Scan算法的正确性，接下来分析其复杂度是否满足O(nlogn)，实现所谓的最优算法。</p><p>直观上无法断定Graham Scan是一个最优的算法，尤其是以下极端情况令人质疑其效率：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/image-20200314220437069.png" alt="image-20200314220437069"></p><p>Graham Scan算法复杂度由三部分决定：</p><ul><li>persorting，采用一般排序算法，复杂度是O(nlogn)</li><li>逐步迭代，O(n)：算法一步步纳入新点，会迭代n步。</li><li>scan，O(?)</li></ul><p><strong>所以算法的总体复杂度：O(nlogn + n * ?) ，可见scan的复杂度决定了算法总体的复杂度。</strong></p><ul><li>算法一步步纳入新点，会迭代n步。但是在每个点上都有可能做回溯操作，所以scan的复杂度是不确定的。我们来以上图最坏情况为例，到第8个点时判定为false，舍弃点7，回溯。下一步判断也为false，舍弃点6，回溯。如此回溯直到算法开始的点2。这次scan倒退了高达O(n)个点，如果每次scan都是如此那么算法整体复杂度就为：O(nlogn + n * n) = O(n^2)了，那这种算法的意义也就不大了。</li></ul><p>其实上述分析并非错误，只是不够精确。<u>O(n^2)确实是Graham Scan算法的一个<strong>上界</strong></u>，但是这个上界并不是紧的。</p><p><u>问题就出在分析假定了每次都会出现回退高达O(n)个点。</u></p><ul><li><p>下图展示了整个Graham Scan的流程：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/20180208002202338.jpg" alt="img"></p><p>图中黄色边是没有采纳的，就是to left测试判定为false后直接舍去的。紫色边则是曾经被认为是极边而接纳的，后来经过回溯又舍去了。无论是黄边还是紫边，在其上耗费的都是常数时间，关键就在于黄色边和紫色边的数目了。</p><blockquote><p>通过观察可以发现，从图论的角度看，所有的黄色边和紫色边连在一起构成了一张<strong>平面图</strong>，也就是它们互相是不可能内部相交的。平面图的一个重要性质：<strong>平面图中所有边的数目和顶点数目保持同阶</strong></p><p>这个性质来自<strong>欧拉公式</strong>：有n个点的平面图，<u>边</u>的数目上限是3n，也就是<strong>O(3n)</strong>。</p><ul><li>回溯（backtrack）可能会倒退的边数：在0~n之间。【但是注意，不是每次回溯都能回退到n，因为由上面可知，点集边数最多为3n，而这里面的每一个边，会被回退0次（极边），或者1次（非极边）。所以，某条边一旦被回退过，之后就不可能再被回退了】</li></ul><p>根据这个性质，在persorting之后的整个流程中，Graham Scan所能走过的所有边不仅不会到达n^2，而顶多到达和n同阶的一个<strong>线性数目</strong>。因此整个算法的复杂度也就取决于persorting的O(nlogn)了。</p></blockquote></li></ul><h1 id="算法推广"><a href="#算法推广" class="headerlink" title="算法推广"></a>算法推广</h1><p>Graham Scan算法不仅可以用于凸包构造问题，在其他许多场景下中也十分有效。为了推广Graham Scan算法，首先可以对其做简化，以方便利用在其他问题。</p><p>首先再来回顾一下预处理排序，这是算法成立必不可少的一步。排序算法套用成熟的方法即可，利用数学方法计算偏角不仅复杂而且引入了误差，所以要采用to left test。要做的就是两点：</p><ul><li>套用成熟的排序算法，将待排序元素由数值变为点</li><li>将排序算法的比较器改为<strong>to left test</strong>实现</li></ul><p>按照这样的流程就能间接地实现persorting。</p><h2 id="1、原始点集已经有某种次序"><a href="#1、原始点集已经有某种次序" class="headerlink" title="1、原始点集已经有某种次序"></a>1、原始点集已经有某种次序</h2><p>有时候我们并不是从零开始构造凸包，例如得到的待处理点集已经是有某种次序的（比如已经按x坐标大小排序，如下图）。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/20180208004657243.jpg" alt="img"></p><p><u>这种情况也不一定非得进行persorting构造新的次序</u>，通常改变观察的角度，换一种理解方式就能免去预处理而直接进行后面的线性的scan操作了。</p><p><strong>上半部分凸包：</strong></p><p>考虑y轴负方向无穷远一个点，所有的点相对于这个点的极角排序恰好就是各点的x坐标序！也就是将无穷远的点看作起始点①，最右侧点（图中点8）看作点②，进行scan过程直到最左边的点（图中点1）结束，就得到了凸包的上半部分（upper hull），也就是下图的8→7→2→1：</p><p><em>注：对 “考虑y轴负方向无穷远一个点，所有的点相对于这个点的极角排序恰好就是各点的x坐标序！” 这句话的理解：</em></p><ul><li>就像太阳光照在地球上的道理是一样的，太阳离地球足够的远，那么它的光到达地球上的时候，就近似的是<strong>平行</strong>的。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Graham-Scan/20180208005912300.jpg" alt="img"></p><p><strong>下半部分凸包（lower hull）的构造</strong></p><p>也是如此。考虑一个在y轴正方向无穷远的一个点，以此为起点进行scan，最终得到lower hull：1→4→7。最后将两个凸包合二为一即可。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 凸包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lower Bound</title>
      <link href="/archives/ba04.html"/>
      <url>/archives/ba04.html</url>
      
        <content type="html"><![CDATA[<h2 id="Lower-Bound"><a href="#Lower-Bound" class="headerlink" title="Lower Bound"></a>Lower Bound</h2><p>从极点法的O(n^4^)复杂度，到极边法的O(n^3^)，再到增量构造法和Jarvis March的O(n^2^)，我们经历了将特定问题算法不断优化、降低复杂度的过程。那么还有比O(n^2^)更高效的算法吗？凸包构造算法的下界是什么？推广到一般情况，在计算模型固定的情况下特定问题的复杂度下界又是如何确定的？</p><p>在计算模型固定的情况下特定问题的复杂度<strong>下界（lower bound）</strong>是确定的。严谨考虑，在设计算法前应该先确定下界是多少。</p><p>对于某个问题的特定算法，我们可以用时间复杂度来评价算法的好坏。算法能达到的下界也就是所谓问题的难度。当然这种评价通常是比较麻烦的，有时候甚至是不可行的。<u>这就要引入新的的方式来衡量一个算法的好坏。</u></p><h3 id="规约（reduction）"><a href="#规约（reduction）" class="headerlink" title="规约（reduction）"></a>规约（reduction）</h3><p>我们引入<strong>规约（reduction）</strong>的方法来<u>间接</u>衡量一个算法。规约简单来讲就是用一个“参照物”对比待评算法，得到算法的复杂度。规约的一般方法如图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20180206145307478.png" alt="规约（reduction）"></p><blockquote><p>左侧是已知的问题<strong>A</strong>，已经明确它的难度，右侧是待分析问题<strong>B</strong>，复杂度未知。我们在二者之间建立起一种基本<strong>reduction</strong>关系：<strong>linear-time reduction</strong>。</p><p>linear-time reduction具体表述为：</p><ul><li>任何一个A的输入（input of A），都可以在O(n)复杂度转化为一个B的输入（input of B），然后通过B的某种算法（any algorithm）计算出结果（output of B）;</li><li>而对于output of B又都可以在在O(n)复杂度转化为A问题的结果（output of A）。两次转换的复杂度不能超过线性，也就是linear-time（线性时间）。</li></ul></blockquote><p>能够进行上述操作，就称为：<strong>A问题可以规约到B问题（problem A is linear-time reducible to problem B）</strong>。注意表述方式防止搞混A和B的位置。</p><h4 id="曹冲称象"><a href="#曹冲称象" class="headerlink" title="曹冲称象"></a>曹冲称象</h4><p>可以通过<strong>曹冲称象</strong>的故事来帮助理解规约的思想。要解决的问题是：没有秤能直接称量大象重量（问题B的难度无法直接衡量），<u>解决方案是</u>：利用船和石块间接称量。石头块的重量是可以直接称量的（问题A的难度是已知的），利用<u>船和水</u>来转换石头和大象的重量是可操作的（规约的方法是可操作的）。【这里的<u>规约关系(Reduction relationship)</u>是指曹冲成像时的船和水】</p><h4 id="规约记号"><a href="#规约记号" class="headerlink" title="规约记号"></a>规约记号</h4><p>引入规约记号，problem A is linear-time reducible to problem B表示为：<br>$$<br>A≤_NB<br>$$<br>将问题A、B的难度分别表示为|A|，|B|。规约记号的意思相当于<strong>|A|≤|B|</strong>，A的下界必然就是B的下界。</p><p><strong>规约的过程</strong>：</p><ol><li>将A的输入转化为B的输入</li><li>经过B的某种算法获得解后又转化为A的解，也就是这个算法也是解决A问题的算法。</li></ol><p>已知A问题的下界，那么这个算法必然不会低于A的这个下界。</p><h3 id="构造凸包的下界"><a href="#构造凸包的下界" class="headerlink" title="构造凸包的下界"></a>构造凸包的下界</h3><p>按照“曹冲称象”的规约思想，分析问题的难度，最重要的在于找到“石头”，而船就是规约这种方法。以二维凸包（2d-CH）来分析，首先将待解决的问题放到规约记号<u>右边</u>，而左边的“石头”就是<strong>排序算法</strong>。<br>$$<br>Sorting≤_N2D-CH<br>$$<br>排序是纯粹的数值计算问题，而凸包是典型的几何问题，二者是如何联系在一起的呢？前面<a href="http://blog.csdn.net/HouszChina/article/details/79254856" target="_blank" rel="noopener">增量构造法</a>和<a href="http://blog.csdn.net/HouszChina/article/details/79261505" target="_blank" rel="noopener">Jarvis March算法</a>正是分别由两种排序算法来类比引入的，可见排序和凸包之间有深刻的内在联系。二者之间的联系可以通过下图表示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200312231702595.png" alt="image-20200312231702595"></p><p>首先清点要做的任务：</p><ul><li><p>可以在线性时间内，将排序问题的输入转化为凸包问题的输入</p><ul><li>排序问题的输入可以表示为x轴上的一系列的点（图中蓝色点）。然后将这些点转化为凸包问题的输入，就是将这些待排序的数转化为平面上的点。引入辅助线——一条抛物线，例如图中蓝色虚线。接下来要对蓝色点做到抛物线上的映射（O(n)），映射在抛物线上的点用绿色标出。这样就完成了将待排序数字转化为平面上点的操作。接下来就可以用某种算法将绿色点构造为凸包，即图中CH(P)。</li></ul></li><li><p>可以在线性时间内，将凸包问题的结果转化为排序问题的结果</p><ul><li>凸包CH(P)就是问题B的解，如何将B的解转化为A的解？注意最左和最右边两点的连线，即图中1和4的连线4→1。除去这条连线之外，其他首尾相接的连线：1→2，2→3和3→4都是“沿着x方向单调的”，遍历这些首尾相连的边（O(n)）就能得到一系列的数值，并且已经是有序的了。这样就将凸包问题的解——凸包CH(P) 转化为了排序问题的解——有序数值序列。</li></ul></li></ul><p>两次转化说明规约是可行的，因此2d-CH问题的下界可由sorting的下界确定。一般而言，排序问题的难度是确定的：<strong>O(nlogn)</strong>。2d-CH问题的下界也就是：<br>$$<br>O(nlogn)<br>$$<br>更高维的凸包问题下界也是如此。</p><p>增量构造法和Jarvis March的O(n^2^)到O(nlogn)之间的鸿沟能否跨越呢？是否存在O(nlogn)复杂度的凸包构造算法？后续文章会有回答。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 凸包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造凸包-Jarvis March(Gift Wrapping)算法</title>
      <link href="/archives/9c7f.html"/>
      <url>/archives/9c7f.html</url>
      
        <content type="html"><![CDATA[<p>回顾凸包构造算法：极点法、极边法和增量构造法，其复杂度分别为O(n^4^)、O(n^3^)和O(n^2^)，效率经过优化已经大大提高了。接下来引入一种新的算法——Jarvis March，其复杂度也是O(n^2^)，但是相较于增量构造在最好情况下效率是较高的。</p><a id="more"></a><h3 id="实现策略"><a href="#实现策略" class="headerlink" title="实现策略"></a>实现策略</h3><p>先想一下为何<a href="http://blog.csdn.net/houszchina/article/details/79253249" target="_blank" rel="noopener">极边法</a>复杂度高达O(n^3^)。实际上我们要对点集中所有边进行遍历，这需要n^2^复杂度，然后对每个边进行鉴别，又需要n复杂度，因此总体复杂度高达O(n^3^)。那么该如何改进呢？这就可以运用选择排序的思想：将下一个要查找的边缩小到一个小范围，而非遍历所有边。</p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20180205163738819-1584005657109.png" alt="选择排序示意"></p><p>选择排序每次选取出的unsorted最大元素放在sorted 部分的首部，<u>也就意味着整个unsorted部分必然不会超过sorted部分</u>。从算法整体框架考虑，每次我们都是维护一个局部解（也就是sorted部分），然后从尚未处理的部分（也就是unsorted部分）找到一个与当前局部解“紧密相关的元素”（相当于选取的最大元素）。这个思想为解决凸包问题带来了新思路。</p></blockquote><p>对算法的大致过程进行描述(标识为：已找到极边数/所有极边数)：</p><ul><li><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200312175230158.png" alt="在加入[partial convex hull]之前找出下一条极边"></p><p>首先从任何一个极点（后面说明如何找到这个点）开始（图中0/5），然后找到一条以这个极点为端点的极边（1/5）。接着沿着极边另一个端点<strong>（endpoint）</strong>出发，再找出下一条极边（2/5）。如此反复操作，<u>最终会找到一条以最初极点为endpoint的极边，得到一个封闭的环，凸包也构造完成</u>。凸包构造过程类似于选择排序中sorted不断向前扩展一样，不断扩展局部解，最后得到问题最终解。</p></li></ul><table><thead><tr><th>凸包构造的问题由此分解为一个个子问题：<u>如何从endpoint出发找到下一条极边</u>。</th></tr></thead><tbody><tr><td></td></tr></tbody></table><h4 id="用to-left-test找到下一条极边"><a href="#用to-left-test找到下一条极边" class="headerlink" title="用to left test找到下一条极边"></a>用to left test找到下一条极边</h4><p>现分析如何从endpoint找到下一条极边。考虑一下的一般情况：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200312175230158.png" alt="image-20200312175230158"></p><p>我们从极点o开始寻找极边，假设当前找到的极边是ik，接下来要做的工作是找到从k出发的另一条极边ks，即找到极点s。</p><p>显然，s来自于其他那些尚未处理的点中，那么s与其他点相比有什么特征？观察发现，ik作为一条极边，它的右侧肯定都是空的，所有其他点都在ik左侧。画出k与其他候选点的有向直线，例如下图中的ks，kt：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200312175450087.png" alt="image-20200312175450087"></p><p>注意图中红色标出的角度，可以看出ks与ik的夹角比kt小，也就是ks比kt相较于ik偏左的角度更小。实际上ks偏左的角度比其他任何从k出发的边都小，<strong>这就是s点的判定依据</strong>。</p><p><strong>这样就找到了从其余点中选择s点的思路</strong>：任选两个点，从k出发过这两点做有向边，看哪个偏左的角度更小就留下，另一点丢弃。然后再拿一点与留下的点比较，反复这个过程，最终留下的就是要找的s点。</p><table><thead><tr><th>问题至此转化为：<u>如何比较两条有向边（例如ks和kt）相较于另一有向直线（例如ik）谁偏左的角度更小。</u></th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>当然可以通过计算三角函数的方法来比较，这是最直观的数学思维。但是这样计算十分复杂，更重要的是引入了误差。<u>这时候又要使用<strong>to left test</strong>这个基础方法来解决问题了</u></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200312175904984.png" alt="image-20200312175904984"></p><p>具体做法就是以在ks和kt中以任意个为基准（如以ks为基准），对另一点（如t）做to left test。上图点t和有向边ks的to left test结果为true，t在ks左边，因此ks偏左的角度更小，舍弃点t。</p><blockquote><p>类比选择排序来理解:</p><ul><li><u>已得到的极边</u>（从极点o开始到ik的首尾相连的极边）——相当于 sorted部分</li><li><u>其余点</u>——相当于 unsorted部分</li><li><u>找到点s</u>（能构成最小偏角的点）——相当于 从unsorted部分取出极大值</li></ul><p>选择排序中的选择过程需要比较元素大小，就要由一种<strong>比较器</strong>完成，<u>而上述比较偏角的过程也可以抽象为一种比较器的操作</u>。构造凸包的算法框架与选择排序相同，<u>只是比较器替换为to left test而已</u>。</p></blockquote><p><em>此处只是考虑一般情况，一些特殊细节未进行处理。例如在st上有s和s’两点，这两点的取舍问题未考虑。当然为了理解算法整体框架忽略特殊情况是很必要的。</em></p><h4 id="确定第一个极点"><a href="#确定第一个极点" class="headerlink" title="确定第一个极点"></a>确定第一个极点</h4><p><strong>一个细节</strong>：上文一开始提到的算法的最开始的<strong>第一个极点</strong>如何确定？</p><p>任何一个极点都可以使用，我们没必要去计算出哪个点是极点。可以选取y坐标最小的点，也就是最低点，在没有退化的情况下，这个点一定是一个极点。如果情况退化，有多个最低点（如例图中所示），我们就去选x坐标最小的那个点，也就是最左边的点即可。这种方法选出的点称为<strong>lowest-then-leftmost point（LTL）</strong>。<u>注意选取的规则的先后顺序，先选lowest，若点不唯一再选leftmost。</u></p><h3 id="Jarvis-March"><a href="#Jarvis-March" class="headerlink" title="Jarvis March"></a>Jarvis March</h3><p>类比选择排序的过程，我们得到的凸包构造算法就是<strong>Jarvis March算法</strong>，又称<strong><a href="https://en.wikipedia.org/wiki/Gift_wrapping_algorithm" target="_blank" rel="noopener">gift wrapping算法</a></strong>（算法过程如包装礼物一样）。接下来看算法具体实现方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ToLeft</span><span class="params">(Point P, Point q, Point s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> area2 = p.x*q.y - p.y*q.x + q.x*s.y -q.y*s.x + s.x*p.y - s.y*p.x;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> area2 &gt;<span class="number">0</span> ; <span class="comment">//左侧为真</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LTL</span> <span class="params">(Point S[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ltl = <span class="number">0</span>; <span class="comment">//the lowest-then-leftmost point</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;n;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S[k].y &lt; S[ltl].y || (S[k].y==S[ltl].y &amp;&amp; S[k].x&lt;S[ltl].x))</span><br><span class="line">            ltl =k;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> ltl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Javis</span><span class="params">(Point S[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; k++)</span><br><span class="line">    S[k].extreme =FALSE; <span class="comment">//首先将所有点标记为非极点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ltl=LTL(S, n); <span class="comment">//找到LTL</span></span><br><span class="line">    <span class="keyword">int</span> k=ltl;  <span class="comment">//将LTL作为第一个极点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">    S[k].extrem = <span class="literal">true</span>; <span class="keyword">int</span> s =<span class="number">-1</span>; <span class="comment">//s是要找的下一个极点，用t去循环找</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t=<span class="number">0</span>; t&lt;n; t++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(t != k &amp;&amp;t != s &amp;&amp; ( s == <span class="number">-1</span> || !ToLeft(S[K],S[s],S[t]) ) )</span><br><span class="line">                s = t; <span class="comment">//如果t在pq的右侧，则更新s</span></span><br><span class="line">        &#125;</span><br><span class="line">        S[k].succ = s; k = s; <span class="comment">//新的极边pq确定   </span></span><br><span class="line">        k = s; <span class="comment">//更新k的值，变为下一次查找的起点</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(ltl != k) <span class="comment">//如果循环回到了原来的点，则结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h3><ol><li>首先，初始化将所有点都设为：非极点</li><li>然后，开始找到<u>第一个极点</u>（用LTL方法），找到之后赋值给k</li><li>接下来，开始找<u>下一个极点</u>s：<ul><li>主要用<code>ToLeft Test</code>来找出下一个极点</li></ul></li><li>循环第3步骤，直到找到所有极点</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>最后分析Jarvis March算法相较于增量构造法的优势。二者都是O(n^2^)的复杂度，Jarvis March算法的优势在于其的“<strong>输出敏感性（output sensitive）</strong>”。考虑点集S，共有n个点，来构造S上的凸包。</p><p>何为“<u>输出敏感性</u>”？Jarvis March算法每次新加入一条边都会耗费n的复杂度，但是构造过程一共会加入的边数往往比n少。如下图（设n = 7）：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20180206002208800.png" alt="img"></p><p>在非退化为共线的前提下，最好情况为只加入3条边（复杂度为O(3n)），最坏情况为所有点都是极点，加入n-1条边（复杂度为O(n^2^)）。实际情况中最坏情况出现的几率很小，我们引入一个指标h来衡量凸包的极边数（the size of convex hull）：<br>$$<br>h = |CH(S)|<br>$$<br>Jarvis March算法算法的复杂度<strong>更准确的表示为O(nh)。</strong>h又由最终输出结果，即凸包本身来决定，输出结果决定了构造过程的复杂度，这就是所谓的“输出敏感性”。这种类型的算法又被称为output sensitive algorithm。这种特性在其它凸包算法中也会体现。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 凸包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Convex Hull(凸包)</title>
      <link href="/archives/510d.html"/>
      <url>/archives/510d.html</url>
      
        <content type="html"><![CDATA[<p>这山之高，就叫凸碧；山之低洼近水处，就叫作凹晶。这凸、凹二字，历来用的人最少，如今直用做轩馆之名，更觉新鲜，不落窠臼。</p><a id="more"></a><h1 id="欧拉公式"><a href="#欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式</h1><p>简单介绍一下欧拉公式：</p><p>虚数中：i^2^=-1 ; i=√(-1)</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/1573819506389.png" alt="1573819506389"></p><p>其中θ为实数，i表示虚数中的虚数单位 i；</p><p>欧拉恒等式：</p><p>当θ=π时；</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/1573820164006.png" alt="1573820164006"></p><p>几何学中的欧拉公式：</p><p><code>V-E+F=2</code> 【v：几何体的顶点数；E：边数；F：面数】</p><h1 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h1><p><strong>凸包</strong>：比如，我们有很多很多钉子钉在木板上面，然后用一个皮筋将这些钉子包围起来，当我们松手后，皮筋就把这些定在全都包围起来。此时，这个皮筋所形成的凸多边形就叫<strong>凸包</strong>。如下图的蓝色的多边形就是凸包。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200304214005104.png" alt="绿色线圈记为凸包"></p><h2 id="凸性-Convexity"><a href="#凸性-Convexity" class="headerlink" title="凸性(Convexity)"></a>凸性(Convexity)</h2><p>下图中，假设x,y,z是三种颜色，如果仅以x,y就能调出来的颜色，那么如u所示它一定会落在x,y中；若需要x,y,z三种 一起，那么如v所示会落在以x,y,z三点连成的三角形内部。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/v2-386fd3aaf073885dd32ab6241e9a0452_720w.jpg" alt="凸性"></p><h2 id="极点-Extreme-Point"><a href="#极点-Extreme-Point" class="headerlink" title="极点(Extreme Point)"></a>极点(Extreme Point)</h2><p>有一个点集S。如果存在通过点P的直线L，使得点集S中除了点P之外的其他的点都在这个直线的同一侧，则这个点P就是<strong>极点(Extreme Points)</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200304214843584.png" alt="极点"></p><ul><li><p><strong>判断一个点是否为极点</strong>：该点P是否会被包含在其他点中任意三个点形成的三角形中，如果点P不在任何三角形内部，则说明点P是极点。反之，则不是极点。如下图：</p><p>下图中，S就不是极点，因为他在三角形内部。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200304220601816.png" alt="判断极点"></p><h2 id="判断极点的算法"><a href="#判断极点的算法" class="headerlink" title="判断极点的算法"></a>判断极点的算法</h2><h3 id="In-Trangle-Test"><a href="#In-Trangle-Test" class="headerlink" title="In-Trangle Test"></a>In-Trangle Test</h3><p><strong>算法描述伪代码</strong>：其实这个算法就是判断点是否在三角形内部。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200304221051234.png" alt="In-Trangle Test"></p><p><strong>代码实现：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200304221130677.png" alt="算法实现"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extremePoint</span> <span class="params">(<span class="built_in">point</span> S[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>; s&lt;n; s++)</span><br><span class="line">        S[s].extreme = TRUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>; p&lt;n; p++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> q=p+<span class="number">1</span>; q&lt;n; q++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> r=q+<span class="number">1</span>; r&lt;n; r++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>; s&lt;n; s++)</span><br><span class="line">                &#123;</span><br><span class="line"><span class="keyword">if</span>(s==p || s==q || s==r ||!S[s].extreme)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(Intriangle(S[p],S[q],S[r],S[s]))</span><br><span class="line">                        S[s].extreme = FALSE;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可知，该算法的时间复杂度为O(n^4^)，其实挺大的，在后面我们会进一步改善。</p><p>这样基于极点的凸包算法虽然效率不高，但是它会引出一个非常重要的操作我们称之为<strong>To-Left Test</strong><br>在后面我们可以看到这个测试几乎是贯穿于我们计算几何这个课程的始终的。如果说我们刚才所给出的那个算法还有什么需要补充的话其实最重要的也就是那样的一个细节也就是所谓的<strong>In-Triangle test</strong>。</p><h4 id="To-Left-Test"><a href="#To-Left-Test" class="headerlink" title="To-Left Test"></a>To-Left Test</h4><p>我们将刚才这个In-Triangle Test转化为三次To-Left测试也就是说一个点如果确实落在某一个三角形的内部的话那么相对于这个三角形的三条边所做的这个To-Left测试都会统一的返回true或者统一地返回false。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200304223141504.png" alt="To-Left Test"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InTriangle</span><span class="params">(Point p, Point q, Point r, Point s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> pqLeft = ToLeft(p, q, s);</span><br><span class="line">    <span class="keyword">bool</span> qrLeft = ToLeft(q, r, s);</span><br><span class="line">    <span class="keyword">bool</span> rpLeft = ToLeft(r, p, s);</span><br><span class="line">    <span class="keyword">return</span> (pdLeft == qrLeft) &amp;&amp; (qrLeft == rqLeft);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>To-Left测试是相对于另外这两个点所确定的那条<strong>有向</strong>直线而言的，任何一条有向直线不仅会把平面分成两部分，我们还可以知道哪一边是左边，哪一边是右边。To-Left，其实就是说这个点相对于刚才的那条有向线而言到底是位于它的左侧，还是右侧。如果是前者就是true，否则的话就是false。因为三角形有三条边，所以我们要用三次To-Left Test。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200304223826387.png" alt="INT=3*TLT"></p><p><strong>To-Left Test具体实现</strong>：</p><p>这里用到了行列式来求三角形面积（至于原理，这里就不多说了）。下图中的这个行列式实际上算的首先是它的面积的<strong>两倍</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200304224456126.png" alt="To-Left Test"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ToLeft</span><span class="params">(Point p, Point q, Point s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Area2(p, q, s) &gt; <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Area2</span><span class="params">(Point p, Point q, Point s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">        p.x * q.y - p.y * q.x </span><br><span class="line">       +q.x * s.y - q.y * s.x</span><br><span class="line">       +s.x * p.y - s.y *p.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：这里的面积其实是“有向面积”，也就是说这里的面积分正负（相对于这样一个逆时针的<br>一个编号pqs的这样的一个面积 与 s在右侧也就是按照顺时针的pqs所构成的面积虽然有可能大小是一样完全对称但是它们的符号是相反的）。整个这个To-Left的测试的<strong>判断的依据也就在于这个符号</strong>。</p><p>这个行列式取正条件为：当且仅当s位于pq所确定的这条有向直线的左侧。其中转换成代码也是非常简明的，代码如上图所示。</p><p>至此，To-Left Test实现完成。</p><h2 id="极边-Extreme-Edge"><a href="#极边-Extreme-Edge" class="headerlink" title="极边(Extreme Edge)"></a>极边(Extreme Edge)</h2><p><strong>极边</strong>：两个极点连成的边，剩余的所有点均会在该边的一侧。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/v2-534df0cc332ead89da7586c99c22dd5f_720w.jpg" alt="极边"></p><p><strong>判断是否为极边</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200308231616965.png" alt="image-20200308231616965"></p><ul><li><strong>代码实现</strong>：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200308231916308.png" alt="markEE"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">markEE</span><span class="params">(<span class="built_in">point</span> S[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; k++)</span><br><span class="line">        S[k].extreme = FALSE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p=<span class="number">0</span>; p&lt;n; p++) <span class="comment">//test</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> q=p+<span class="number">1</span>; q&lt;n; q++) <span class="comment">//检验每一条边</span></span><br><span class="line">            checkEdge(S,n,p,q) <span class="comment">//有向边pq</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200308231932585.png" alt="checkEdge"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkEdge</span><span class="params">(Point S[], <span class="keyword">int</span> n, <span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> LEmpty =TRUE, REmpty =TRUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n &amp;&amp; (LEmpty || REmpty); k++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k != p &amp;&amp; k != q)</span><br><span class="line">            ToLeft(S[p], S[q], S[k]) ? LEmpty=FALSE : REmpty=FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(LEmpty || REmpty)</span><br><span class="line">        S[p].extreme=S[q].extreme=TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现的步骤：</p><ol><li><p>初始时，先假设所有的点都不是极点。</p></li><li><p>开始遍点集S中的点，它们两两组合成一个线段，然后进行checkEdge(检查这些线段是否是极边)。</p><p>检查的方法<code>checkEdge</code>：</p><p>利用ToLeft测试，每次都将当前的线段与其他点（即，除了这两个点之外的点）进行ToLeft测试<strong>，如果测试结果中：LEmpty、REmpty 其中之一为true，就表明这两个点构成的线段为*极边*，而且同时也检测出这两个点是*极点*。</strong>（其实两个点组成的线段进行<code>checkEdge</code>的结果中的LEmpty、REmpty最多只有一个是true,因为这里不存在一条边的两侧都没有其他点的情况）</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">markEE</span><span class="params">(Point S[], <span class="keyword">int</span> n)</span> <span class="comment">//n&gt;2</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;n; k ++)</span><br><span class="line">        S[k].extreme = False; <span class="comment">//先假设所有的点都不是极点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; n; p ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> q = p + <span class="number">1</span>; q &lt; n; q ++)</span><br><span class="line">            checkEdge(S, n, p, q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkEdge</span><span class="params">(Point S[], <span class="keyword">int</span> n, <span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//LEmpty、REmpty表示改边的左侧、右侧，等于True时表示该侧是没有点的。</span></span><br><span class="line">    <span class="keyword">bool</span> LEmpty = True, REmpty = True;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n &amp;&amp; (LEmpty || REmpty); k ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k != p &amp;&amp; k != q)</span><br><span class="line">        &#123;</span><br><span class="line">            ToLeft(S[p], S[q], S[k]) ? LEmpty = False : REmpty = False;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(LEmpty || REmpty)</span><br><span class="line">        S[p].extreme = S[q].extreme = True;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样可利用此来判断是否是极点（复杂度为O(n^3)）。</p><h1 id="补：根据极角排序"><a href="#补：根据极角排序" class="headerlink" title="补：根据极角排序"></a>补：根据极角排序</h1><p><strong>定义：</strong></p><p>我们平常所使用的坐标系都是直角坐标系，而极角排序是在极坐标系下进行的。<br>这里首先要选取一个点，然后其它点根据与参考点的连线与x轴所成的夹角的大小进行排序的。<br>这里我们可以简单理解为绕着一个点逆时针转圈访问。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/1-1584641857659.png" alt="极角排序"></p><p><strong>代码：</strong></p><p>在讲具体实现方法之前，先给出用到的函数和结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>//存储点</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cross</span><span class="params">(<span class="keyword">double</span> x1,<span class="keyword">double</span> y1,<span class="keyword">double</span> x2,<span class="keyword">double</span> y2)</span>　<span class="comment">//计算叉积</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x1*y2-x2*y1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">compare</span><span class="params">(<span class="built_in">point</span> a,<span class="built_in">point</span> b,<span class="built_in">point</span> c)</span><span class="comment">//计算极角</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cross((b.x-a.x),(b.y-a.y),(c.x-a.x),(c.y-a.y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>利用叉积的正负来排序</p><blockquote><p>　关于叉积：叉积=0是指两向量平行（重合）；叉积&gt;0，则向量a在向量b的顺时针方向（粗略的理解为在a在b的下方）；叉积&lt;0，则向量a在向量b的逆时针方向（粗略的理解为在a在b的上方）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">point</span> a,<span class="built_in">point</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">point</span> c;<span class="comment">//原点</span></span><br><span class="line">    c.x = <span class="number">0</span>;</span><br><span class="line">    c.y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(compare(c,a,b)==<span class="number">0</span>)<span class="comment">//计算叉积，函数在上面有介绍，如果叉积相等，按照X从小到大排序</span></span><br><span class="line">        <span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> compare(c,a,b)&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用 complex 的内建函数，算出极角大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x real()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y imag()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Point&amp; p1, <span class="keyword">const</span> Point&amp; p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg(p1) &lt; arg(p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用 arctan 计算极角大小。注意角的大小范围是(-180°, +180°]。弧度表示。这里用 arctan2 函数应该是为了提高精度。</p><blockquote><p>关于atan2()函数：在C语言的math.h或C++中的cmath中有两个求反正切的函数atan(double x)与atan2(double y,double x) 他们返回的值是弧度要转化为角度再自己处理下。</p><p>前者接受的是一个正切值（直线的斜率）得到夹角，但是由于正切的规律性本可以有两个角度的但它却只返回一个，因为atan的值域是从-90°~90° 也就是它只处理一四象限，所以一般不用它。</p><p><strong>推荐这个</strong>：第二个atan2(double y,double x) 其中y代表已知点的Y坐标，同理x ,返回值是此点与远点连线与x轴正方向的夹角，这样它就可以处理四个象限的任意情况了，它的值域相应的也就是-180~180了</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">const</span> Point&amp; p1, <span class="keyword">const</span> Point&amp; p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">atan2</span>(p1.y, p1.x) &lt; <span class="built_in">atan2</span>(p2.y, p2.x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>先判断象限，再用外积判断顺序，最后根据长度排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Quadrant</span><span class="params">(<span class="built_in">point</span> a)</span>　　<span class="comment">//象限排序，注意包含四个坐标轴</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x&gt;<span class="number">0</span>&amp;&amp;a.y&gt;=<span class="number">0</span>)  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a.x&lt;=<span class="number">0</span>&amp;&amp;a.y&gt;<span class="number">0</span>)  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a.x&lt;<span class="number">0</span>&amp;&amp;a.y&lt;=<span class="number">0</span>)  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(a.x&gt;=<span class="number">0</span>&amp;&amp;a.y&lt;<span class="number">0</span>)  <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp3</span><span class="params">(<span class="built_in">point</span> a,<span class="built_in">point</span> b)</span>  <span class="comment">//先按象限从小到大排序 再按极角从小到大排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Quadrant(a)==Quadrant(b))<span class="comment">//返回值就是象限</span></span><br><span class="line">        <span class="keyword">return</span> cmp1(a,b);</span><br><span class="line">    <span class="keyword">else</span> Quadrant(a)&lt;Quadrant(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="向量的点乘与叉乘的几何意义"><a href="#向量的点乘与叉乘的几何意义" class="headerlink" title="向量的点乘与叉乘的几何意义"></a>向量的点乘与叉乘的几何意义</h2><p>向量的<strong>点乘（内积）</strong>：</p><p>$$<br>\vec{a} \cdot \vec{b}=|\vec{a}| \cdot |\vec{b}|\cdot cos\theta<br>$$<br>点乘的几何意义是可以用来表征或计算两个向量之间的夹角，以及在b向量在a向量方向上的投影</p><p>向量的<strong>叉乘（外积）</strong>：<br>$$<br>\vec{a} \times \vec{b}=|\vec{a}| \cdot |\vec{b}|\cdot sin\theta<br>$$<br>向量积被定义为：</p><ul><li><p>模长：（在这里θ表示两向量之间的夹角(共起点的前提下)（0° ≤ θ ≤ 180°），它位于这两个矢量所定义的平面上。）</p></li><li><p>方向：a向量与b向量的向量积的方向与这两个向量所在平面垂直，且遵守右手定则。（一个简单的确定满足“右手定则”的结果向量的方向的方法是这样的：若坐标系是满足右手定则的，当右手的四指从a以不超过180度的转角转向b时，竖起的大拇指指向是c的方向。<strong>c</strong> = <strong>a</strong> ∧ <strong>b</strong>）</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/afa5c98582b08ef4bac175d7bb5c9bda80adcaab.png@968w_1346h.webp" alt="叉乘"></p><p>特别的，在二维中，两个向量的向量积的模的绝对值等于由这两天向量组成的平行四边形的面积。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/62a0493b8bb7f29f2655190b718be3d029e6750e.png@960w_750h.webp" alt="向量积"></p><p>向量的叉乘，即求同时垂直两个向量的向量，即c垂直于a，同时c垂直于b（a与c的夹角为90°，b与c的夹角为90°）</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><strong>极角排序</strong>：<a href="https://sumygg.com/2013/07/30/Sorting-Points-by-Polar-Angle/" target="_blank" rel="noopener">https://sumygg.com/2013/07/30/Sorting-Points-by-Polar-Angle/</a></p><p><strong>关于极角排序：</strong><a href="https://www.cnblogs.com/aiguona/p/7248311.html" target="_blank" rel="noopener">https://www.cnblogs.com/aiguona/p/7248311.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 凸包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造凸包-增量构造法</title>
      <link href="/archives/7c53.html"/>
      <url>/archives/7c53.html</url>
      
        <content type="html"><![CDATA[<p>在引入新算法之前首先来回顾一下经典的算法思想：减治（decrease and conquer），注意不是分治（divided and conquer），二者<a href="https://www.geeksforgeeks.org/decrease-and-conquer/" target="_blank" rel="noopener">稍有区别</a>。简单来讲就是将问题划分为一个个简单的小问题，减而治之，逐个求解，最终就能得到整个问题的解。</p><p>减治法的经典例子就是插入排序（insertion sort）。插入排序的过程可以归结成下图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200315172527.png" alt="img"></p><p>排序的过程中将序列分为两部分：已排序部分（sorted）和未排序部分（unsorted）。每次排序都是从unsorted中拿出一个元素，通过一次<strong>顺序查找</strong>过程在sorted部分中找到位置并插入其中。</p><p>整个插入排序的过程就是逐个元素的去“蚕食”unsorted部分的过程，连续的进行这个操作就会将整个问题解决。这种将大问题分解成小问题的减治过程，又被看成一种递增的、增量式的策略（incremental strategy）。这种思想为解决凸包问题提供了新的思路：从逐个插入新点的角度构造凸包。</p><p>典型流程如下图（标识为：极点/整体规模）：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200311222412367.png" alt="image-20200311222412367"></p><p>插入新的点可能的情况有：</p><blockquote><ul><li>新点对凸包有“贡献”，例如5/5→6/6，6/6→7/7；</li><li>新点也有可能没有“贡献”，例如7/7→7/8；</li><li>还有可能使原先有“贡献”的点失效，极点数量减少，例如7/8→6/9。<br>那么如何对不同情况进行处理呢？</li></ul></blockquote><h3 id="确定新点与现有凸包的关系-in-convex-polygon-test"><a href="#确定新点与现有凸包的关系-in-convex-polygon-test" class="headerlink" title="确定新点与现有凸包的关系~in-convex-polygon test"></a>确定新点与现有凸包的关系~in-convex-polygon test</h3><p>构造过程的核心算法应该是：<strong>判定待定点是否位于某多边形内部（in-convex-polygon test）</strong>。再看上图流程，实际上每步的核心就是判断点位于多边形内部还是外部，若落在外部，则新插入的点就是下一个极点，否则舍弃。</p><p>考虑基本情况，给定一个点和一个多边形，如何高效判断该点与多边形的位置关系呢？</p><ul><li><p>一种思路是：我们可以先对多边形进行一个“<strong>预处理</strong>”，给每个点按序编号，类比<strong>有序向量二分查找</strong>的思想，来逐步缩小规模。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/v2-3e18e3822557820d852899d5c503f62a_720w.jpg" alt="img"></p><p>首先任选一点为基准点（蓝色点），然后用二分法选取其余点的“中点“（预处理已经为所有点排了序），然后判断基准点到终点的有向直线与待定点的位置关系<strong>（to-left test）</strong>。然后可将搜索范围减半，反复上述过程，直到最后退化为平凡情况：三角形与点的位置关系<strong>（in-triangle test）</strong>。</p></li></ul><p>分析一下算法的整体复杂度：整个算法共log(n)步，每步的to-left test或in-triangle test都为常数成本，则整体复杂度为log(n)。至此，我们似乎得到了一个log(n)的“高效”算法，但是这种方法真的可行吗？</p><blockquote><p>注意，每步都会将原凸包规模减半，也就是说凸包是<strong>动态的</strong>，随时可能变化。这种方法和极点法或极边法中静态查找的情况是完全不同的。</p><p>类比插入排序的过程来解释这个问题。为何插入排序的复杂度是n^2^而非nlog(n)？每次插入时，既然sorted部分已经有序，为何不使用二分查找来取代顺序查找（复杂度由n变为log(n)）？这不得不考虑sorted部分的动态性，每次插入后它的结构都会改变，而二分查找必须在静态结构中实现。当然可以使用std::vector这类支持按秩访问（call by rank）的数据结构，但是插入时维护vector的成本依旧是线性复杂度。因此插入排序的总体复杂度是n^2^。要处理的凸包与插入排序中sorted部分本质是一样的，它们都不是静态不变的结构，而要随着算法执行而不断变化。若要每次在log(n)成本下完成待定点的in-convex-polygon test，必须将凸包存储为类似vector的数据结构，但是每次向这种数据结构插入新点的成本依旧是线性的。因此对凸包进行的所谓“预处理”是没有意义的，这种减治策略算法复杂度最低应该为O(n^2^)。</p></blockquote><p>到现在问题依旧没有解决，究竟如何用这种增量式的策略来构造凸包？其实复杂问题中最朴素、最基本的方法反而是最有效的。</p><p>in-convex-polygon test最基本的方法是什么？就是按一定方向（约定为逆时针）凸包的每条边和待定点做<strong>to-left test</strong>，一旦有一次test为false就能断定点在凸包外面。这实际上就是将in-triangle test推广多边形的情况。因此每次in-convex-polygon test的成本就会变成当前凸包的规模，也就是n。对于每个新点做一次in-convex-polygon test，构造算法的整体复杂度就是O(n^2^)。算法的复杂度从极边法的O(n^3^)又下降了一个数量级。</p><p><strong>其实增量算法的整个思路可以分成两块：</strong></p><ul><li><strong>1、如何判断凸包与新点的位置关系（in-convex-polygon test）</strong></li><li><strong>2、如何向凸包插入新点</strong></li></ul><p>上面的方法已经解决了第一个问题。第二个问题看下面部分：</p><h3 id="如何向凸包插入新点-support-line"><a href="#如何向凸包插入新点-support-line" class="headerlink" title="如何向凸包插入新点~support-line"></a>如何向凸包插入新点~support-line</h3><p>现在来讨论如何向凸包插入新点：</p><p>比如下面这个点，应该如何插入凸包之中呢？</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200311230823679.png" alt="新点准备插入现有凸包"></p><p><strong>插入过程</strong>：将新点x插入原凸包的过程，本质上就是寻找两个连接点s和t，将x和t、s分别连接得到新的凸包。注意t和s两点将整个原凸包边界分为两部分：st和ts两个有向段。构造新凸包就要保留远端st、舍弃近端ts。取代近端ts的两条线就是x和t的连线xt和xs，被称为<strong>切线（tangent）</strong>或者<strong>support line（支撑线）</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/v2-8afbf4ebfa808eec9ffff8c111ae6465_720w.jpg" alt="img"></p><p><strong>那如何查找t、s这两个点呢？</strong></p><blockquote><p>我们在凸包上任取一点v，按<u>逆时针</u>方向v点会有一个直接前驱点和直接后继点。考察有向直线xv与点v直接前驱和直接后继的位置关系（两次to left test），记录为一个<strong>pattern表</strong>。</p><p>结果无非是四种情况：v的直接前驱和直接后继相对于有向直线xv的位置是RL，LR，LL，RR。例如上图黄色点v，是R和L；蓝色点v分别是L和R。实际上凸包边界st上所有点的pattern都为RL，ts上所有点的pattern都为LR。关键点在于：点S的pattern是LL，点t的pattern为RR。</p></blockquote><p>因此对凸包边界每个点做<strong>两次to left test</strong>，判断其pattern就可找出s和t，花费时间成本为常数。</p><h3 id="incremental-construction"><a href="#incremental-construction" class="headerlink" title="incremental construction"></a>incremental construction</h3><p>再来回顾整个凸包构造算法的两大问题：in-convex-polygon test和插入新点。分开考虑只是为了将思路简化，实际上这两个问题可以套用一个算法，同时来解决。</p><p>具体做法就是：对于每个待定点x，<u>不必特意去考虑它与凸包的位置关系</u>，<u>而是遍历凸包上每一个点</u>。</p><blockquote><p>对于凸包<strong>边界</strong>上的每一个点，我们都能通过两次to left test迅速判断出pattern。</p><p>对于x位于凸包<strong>外部</strong>的情况，经过遍历凸包的点，我们很容易就能得到s和t的位置，得到两条support line，从而构造出新的凸包；</p><p>而对于x位于凸包<strong>内部</strong>的情况，凸包边界每个点都不可能出现RR或LL的情况，直接舍弃x即可。</p></blockquote><p>每次遍历凸包边界点的复杂度为O(n)，整个构造过程要增量式的逐点考察，自然得到了一个<strong>O(n^2^)</strong>的incremental construction算法。</p><p>这就是所谓增量构造法来构造凸包的过程。构造过程巧妙的避开了特殊处理诸如5/5→6/6、7/7→7/8、7/8→6/9等复杂情况，采用一致的思路逐个考察“新点”，最终完成凸包的构造。</p><h3 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h3><p>待写……..</p><h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p><strong>其实增量算法的整个思路可以分成两块：</strong></p><ul><li><strong>1、如何判断凸包与新点的位置关系（in-convex-polygon test）</strong></li><li><strong>2、如何向凸包插入新点</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 凸包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let’s Build A Simple Interpreter 7</title>
      <link href="/archives/5a757a52.html"/>
      <url>/archives/5a757a52.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原文链接：<a href="https://ruslanspivak.com/lsbasi-part7/" target="_blank" rel="noopener">https://ruslanspivak.com/lsbasi-part7/</a></p><p>之前的那几小结，我们都是把interpreter的代码和parser的代码混在一起，而且interpreter在parser识别出一个如加减乘除之类 的特定的语言结构(language construct)后，就会立刻对它进行求值。这种 interpreter 被称为 <strong>语法导向解释器</strong>(syntax-directed interpreter)。</p><blockquote><p>他们通常在输 入上做一个 pass 且只适合基础的语言应用。</p></blockquote><p>为了分析更复杂的编程语言 Pascal 的结构， 我们需要建立一个 <strong>中间表示</strong> (intermediate representation, <strong>IR)</strong>。</p><blockquote><p>parser 会 负责构建 IR</p><p>interpreter 会用来解释由 IR 所代表的输入。</p></blockquote><p>事实证明树是一个表示 IR 非常合适的数据结构。关于数的一些术语terminology：</p><ul><li>树是一个包含一个或多个结点组成的层次数据结构。</li><li>树有一个<strong>根结点</strong>，就是顶部结点。</li><li>除根结点外的所有结点有唯一 一个<strong>父结点</strong>。</li><li>下图中结点为*的是一个父结点。结点为 2 和 7 的是它的子结点；子结点从左到右排序。</li><li>没有子结点的结点称为<strong>叶子结点</strong>。</li><li>有一个或多个子结点的非根结点被称为<strong>中间结点</strong>。</li><li>子结点也可以是完全子树。下图中结点＋的左子树（结点为*）就是一个有自己子结点的 完全子树。</li><li>在计算机科学中我们把树倒过来画，根结点在最上边，分枝向下生长。</li></ul><p>下面是表达式 2 * 7 + 3 的带有解释的树形表示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_tree_terminology.png" alt="lsbasi_part7_tree_terminology"></p><p>本系列中我们会用到的 IR 被称为 <strong>抽象语法树</strong> (abstract-syntax tree, AST)。但在深 入了解 AST 之前让我们简单聊聊 <strong>解析树</strong> (parse tree)。</p><blockquote><p>尽管我们不会在解释器和编译 器中用到解析树，但它会通过可视化 parser 执行轨迹的方法，加深你对 parser 如何解释 输入的理解。我们也会将它和 AST 做比较，来表明为什么 AST 比解析树更适合用来做 IR。</p></blockquote><p>那么，什么是解析树呢？</p><ul><li>解析树（有时叫做 <strong>具体语法树<em>concrete syntax tree</em></strong> ）是一个根据我们的语法定义来 表示一门语言的句法结构的树形结构。它基本上展示了你的 parser 如何识别语言结构或者， 换句话说，它展示了你语法的开始符号怎么派生出该编程语言中一个特定的字符串的。</li></ul><p>parser 的调用栈隐式地代表了一个解析树，且当parser 在试图识别一个特定的语言结构时，解析树 就会自动地在内存中构建出来。下面是表达式 2 * 7 + 3 的解析树：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_parsetree_01.png" alt="lsbasi_part7_parsetree_01"></p><blockquote><p>在上面的图片中可以看到：</p><ul><li>解析树记录了 parser 用来识别输入的一系列规则。</li><li>解析树的根结点的标签是语法的开始符号(start symbol)。</li><li>每个中间结点表示一个非终结符(non-terminal)，代表应用了一条语法规则，像我们的情况里的 <code>expr</code>, <code>term</code>和 <code>factor</code>.</li><li>每个叶子结点代表了一个 token.</li></ul></blockquote><blockquote><p>我们不会手动构建解析树且在我们的解释器中用到它，但解析树可以通过可视化 调用过程帮助我们理解 parser 怎么解释输入。</p><p>你可以使用一个名为 <a href="https://github.com/rspivak/lsbasi/blob/master/part7/python/genptdot.py" target="_blank" rel="noopener">genptdot.py</a> 的小应用（我很快写完用来帮助你的），来查看不同的 算术表达式看起来什么样。要使用这个应用你首先需要安装 <a href="http://graphviz.org/" target="_blank" rel="noopener">Graphviz</a>包，然后运行下面的 命令，你可以打开生成的图片文件 parsetree.png 查看你从命令行传入的表达式的解析树：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python genptdot.py <span class="string">"14 + 2 * 3 - 6 / 2"</span> &gt; \</span><br><span class="line">  parsetree.dot &amp;&amp; dot -Tpng -o parsetree.png parsetree.dot</span><br></pre></td></tr></table></figure><p>下面是由表达式 14 + 2 * 3 - 6 / 2 生成的图片 parsetree.png:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_genptdot_01.png" alt="lsbasi_part7_genptdot_01"></p></blockquote><h2 id="parser"><a href="#parser" class="headerlink" title="parser"></a>parser</h2><h3 id="抽象语法树-AST"><a href="#抽象语法树-AST" class="headerlink" title="抽象语法树(AST)"></a>抽象语法树(AST)</h3><p>现在我们来聊聊<strong>抽象语法树(AST)</strong>。它是在余下的文章中会大量用到的中间表示(IR)。它是我们的解释器和未来编译器项目的核心数据结构。</p><p>让我们以把表达式 2 * 7 + 3 的 AST 和解析树放在一起看来开始我们的讨论：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_ast_01.png" alt="lsbasi_part7_ast_01"></p><p>从上面的图片中可以看出，AST抓住了输入的精髓且更小。</p><p><strong>AST 和解析树最主要的区别有</strong>：</p><blockquote><ul><li>AST 使用操作符/操作(operators/operations )作为根结点，操作数(operands)作为它们的子结点。</li><li>不像解析树，AST <strong>不</strong>使用中间结点来表示语法规则。</li><li>AST 并不把真实句法中的所有结节都表示出来（这就是为什么它是抽象的）──例如，没有 规则结点和括号。</li><li>对于相同的语言结构来说，AST 相比于解析树更紧凑。</li></ul></blockquote><p><strong>抽象语法树是什么</strong>？</p><blockquote><p>抽象语法树(AST)是表示一个语言结构的抽象句法结构的树形表示，它的中间结点和根结点代表了一个操作符，子结点代表了该操作符的操作数。</p></blockquote><p>看一下AST与解析树对比，显现他的紧凑性：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_ast_02.png" alt="lsbasi_part7_ast_02"></p><p><strong>如何将操作符的优先级(precedence)编码进 AST 呢？</strong></p><blockquote><p>为了把操作符优先级编码进 AST，即，为了表示“X 在 Y 之前发生”你只需要在树中把 X 放在低于 Y 的位置。你在前面 的图片中已经见过到了。</p><ul><li>【例子】：在下面的图片中，左边是表达式 2 * 7 + 3 的 AST。让我们用括号把 7 + 3 围起来以改变 它的优先级。在右边是修改后的表达式 2 * (7 + 3) 的 AST：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_astprecedence_01.png" alt="lsbasi_part7_astprecedence_01"></p></blockquote><h4 id="代码实现AST"><a href="#代码实现AST" class="headerlink" title="代码实现AST"></a>代码实现AST</h4><p>好了，让我们写些代码来实现不同的 AST 结点类 并修改我们的 parser 来生成包含这些结点的 AST 树：</p><ul><li><p>首先，新建一个基本结点类叫做 AST，其他类会从它继承：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AST</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span> <span class="comment">#pass 不做任何事情，一般用做占位语句。因为如果定义一个空函数程序会报错，当你没有想好函数的内容是可以用 pass 填充，使程序可以正常运行。</span></span><br></pre></td></tr></table></figure></li><li><p>回忆一下 AST 表示了<strong>操作符-操作数</strong>模型。到现在为止，我们有4个操作符和整型操作数。操作符有加、减、乘、除。我们原本可以新建单独的类来表示每个操作符如 AddNode, SubNode, MulNode 和 DivNode，相反我们只会新建一个 BinOp 类来表示所有 4 个<strong>二元操作符*binary operator*</strong> （二元操作符就是作用在两个操作数的操作符）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinOp</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, left, op, right)</span>:</span></span><br><span class="line">    self.left = left</span><br><span class="line">    self.token = self.op = op</span><br><span class="line">    self.right = right</span><br></pre></td></tr></table></figure><ul><li>构造函数的参数是 <code>left</code>, <code>op</code>, 和 <code>right</code>, 其中 <code>left</code> 和 <code>right</code> 分别指向了表示 左操作数和右操作数的结点。 <code>op</code> 保存了指向操作符本身的 token: <code>Token(PLUS, &#39;+&#39;)</code> 表示加操作符， <code>Token(MINUS, &#39;-&#39;)</code> 表示减操作符，等等。</li></ul></li><li><p>为了在 AST 中表示整数，我们定义一个 <code>Num</code> 类，它将保存一个 <code>INTEGER</code> token 和该 token 的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Num</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, token)</span>:</span></span><br><span class="line">    self.token = token</span><br><span class="line">    self.value = token.value</span><br></pre></td></tr></table></figure><ul><li>和你注意到的一样，所有的note保存 token 从而则创建note(all nodes store the token used to create the node)。这主要是为了方便，将来会派上用场。</li></ul></li></ul><p>回忆一下表达式 2 * 7 + 3 的 AST。我们会在代码中手工创建该表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> spi <span class="keyword">import</span> Token, MUL, PLUS, INTEGER, Num, BinOp</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mul_token = Token(MUL, <span class="string">'*'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plus_token = Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mul_node = BinOp(</span><br><span class="line"><span class="meta">... </span>    left=Num(Token(INTEGER, <span class="number">2</span>)),</span><br><span class="line"><span class="meta">... </span>    op=mul_token,</span><br><span class="line"><span class="meta">... </span>    right=Num(Token(INTEGER, <span class="number">7</span>))</span><br><span class="line"><span class="meta">... </span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_node = BinOp(</span><br><span class="line"><span class="meta">... </span>    left=mul_node,</span><br><span class="line"><span class="meta">... </span>    op=plus_token,</span><br><span class="line"><span class="meta">... </span>    right=Num(Token(INTEGER, <span class="number">3</span>))</span><br><span class="line"><span class="meta">... </span>)</span><br></pre></td></tr></table></figure><p>以下是在新定义的结点类下 AST 的样子。下面的图片也遵循了上面手工创建的过程：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_astimpl_01.png" alt="lsbasi_part7_astimpl_01"></p><h3 id="parser-代码"><a href="#parser-代码" class="headerlink" title="parser 代码"></a>parser 代码</h3><p>下面是我们修改过的 parser 代码，在识别输入（算术表达式）时建立和返回一个 AST:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AST</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinOp</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, left, op, right)</span>:</span></span><br><span class="line">    self.left  = left</span><br><span class="line">    self.token = self.op = op</span><br><span class="line">    self.right = right</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Num</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, token)</span>:</span></span><br><span class="line">    self.token = token</span><br><span class="line">    self.value = token.value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lexer)</span>:</span></span><br><span class="line">    self.lexer = lexer</span><br><span class="line">    <span class="comment"># set current token to the first token from the input</span></span><br><span class="line">    self.current_token = self.lexer.get_next_token()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">'Invalid syntax'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">    <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">    <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">    <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">    <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">    <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">        self.current_token = self.lexer.get_next_token()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.error()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""factor : INTEGER | LPAREN expr RPAREN"""</span></span><br><span class="line">    token = self.current_token</span><br><span class="line">    <span class="keyword">if</span> token.type == INTEGER:</span><br><span class="line">        <span class="keyword">return</span> Num(token)</span><br><span class="line">    <span class="keyword">elif</span> token.type == LPAREN:</span><br><span class="line">        self.eat(LPAREN)</span><br><span class="line">        node = self.expr()</span><br><span class="line">        self.eat(RPAREN)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""term : factor ((MUL | DIV) factor)*"""</span></span><br><span class="line">    node = self.factor()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">        token = self.current_token</span><br><span class="line">        <span class="keyword">if</span> token.type == MUL:</span><br><span class="line">        self.eat(MUL)</span><br><span class="line">        <span class="keyword">elif</span> token.type == DIV:</span><br><span class="line">        self.eat(DIV)</span><br><span class="line"></span><br><span class="line">        node = BinOp(left=node, op=token, right=self.factor())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    expr   : term ((PLUS | MINUS) term)*</span></span><br><span class="line"><span class="string">    term   : factor ((MUL | DIV) factor)*</span></span><br><span class="line"><span class="string">    factor : INTEGER | LPAREN expr RPAREN</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    node = self.term()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (PLUS, MINUS):</span><br><span class="line">        token = self.current_token</span><br><span class="line">        <span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">        self.eat(PLUS)</span><br><span class="line">        <span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">        self.eat(MINUS)</span><br><span class="line"></span><br><span class="line">        node = BinOp(left=node, op=token, right=self.term())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.expr()</span><br></pre></td></tr></table></figure><p>让我们看一些算术表达式的 AST 的构建过程。</p><p>如果你看了上面的 parser 代码，可以看到它建立一个 AST 中的结点的时，把变量 node 的当前值做为 BinOp 结点的左子结点，把对 <code>term</code> 或 <code>factor</code> 调用的返回结果做为它 的右子结点，这实际上就是把结点推向左边，下面表达式 1 +2 + 3 + 4 + 5 的树结构就是 这种情况的一个好例子。下面是 parser 如何一步步地构建表达式 1 + 2 + 3 + 4 + 5 的 AST 的图形表示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_astimpl_02.png" alt="lsbasi_part7_astimpl_02"></p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>好了，下面是表达式 2 * 7 + 3 的 AST：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_ast_walking_01.png" alt="lsbasi_part7_ast_walking_01"></p><p><strong>你怎么遍历这个树并恰当地对它所代表的表达式进行求值呢？</strong></p><blockquote><p>你可以使用<strong>后序遍历*postorder traversal*</strong> (深度优先遍历<em>depth-first traversal</em> 的一个特例) 。</p><ul><li>这种方式由根结点开始，递归由左至右访问每个结点的子结点。后序遍历从根结点开始尽可能快地访问离根结点远的结点(The postorder traversal visits nodes as far away from the root as fast as it can)。</li></ul></blockquote><p>下面是后序遍历的伪代码，其中 <code>&lt;&lt; postorder actions &gt;&gt;</code>是一些操作的占位符，如 <code>BinOp</code> 结点的加减乘除操作或 <code>Num</code> 结点返回整数的简单操作：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_ast_visit_postorder.png" alt="lsbasi_part7_ast_visit_postorder"></p><ul><li><p><strong>为什么要使用后续遍历呢？</strong></p><blockquote><p>第一，我们需要对在树中更低的中间结点进行求值， 因为它们代表了优先级更高的操作符，</p><p>第二，我们在对操作数 参与 对应操作符 的运算 之前需要对操作数进行求值。</p></blockquote><p>在下面的图片中，可以看到使用后序遍历时我们会首先对表达式 2*7 进行 求值，而只有在对 14 + 3 求值之后，我们才会得到正确答案 17:</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_ast_walking_02.png" alt="lsbasi_part7_ast_walking_02"></p><p><strong>三种深度优先遍历</strong>：</p><p>为了完整起见，三种深度优先遍历的方式：先序遍历，中序遍历和后序遍历。这 些遍历方式名字的来自于遍历代码中操作的位置：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_ast_visit_generic.png" alt="lsbasi_part7_ast_visit_generic"></p><p>有时你可能需要在所有地方（先序，中序和后序）都执行一些操作。你会在本文的源代码仓 库中找到一些例子。</p><blockquote><ul><li><p>先序遍历<em>preorder traversal</em>,</p><p>在先序遍历中，我们先访问根节点，然后递归使用先序遍历访问左子树，再递归使用先序遍历访问右子树，即：根节点-&gt;左子树-&gt;右子树</p></li><li><p>中序遍历<em>inorder traversal</em>,</p><p>在中序遍历中，我们递归使用中序遍历访问左子树，然后访问根节点，最后再递归使用中序遍历访问右子树，即：<br>左子树-&gt;根节点-&gt;右子树</p></li><li><p>后序遍历 <em>postorder traversal</em>.</p><p>在后序遍历中，我们先递归使用后序遍历访问左子树和右子树，最后访问根节点。 即：<br>左子树-&gt;右子树-&gt;根节点</p></li></ul></blockquote><h2 id="Interpreter"><a href="#Interpreter" class="headerlink" title="Interpreter"></a>Interpreter</h2><p><strong>用代码来遍历和解释由 parser 建立的抽象语法树</strong>：</p><p>好了，让我们写一些代码来遍历和解释由 parser 建立的抽象语法树，好吗？</p><p>下面是实现了<a href="https://en.wikipedia.org/wiki/Visitor_pattern" target="_blank" rel="noopener">访问者模式</a>的源代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeVisitor</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        method_name = <span class="string">'visit_'</span> + type(node).__name__</span><br><span class="line">        visitor = getattr(self, method_name, self.generic_visit)</span><br><span class="line">        <span class="keyword">return</span> visitor(node)</span><br><span class="line"><span class="comment">#generic_visit 是一个备用函数，它会抛出一个异常来表示它遇到了一个实现类中没有相 应 #visit_NodeType 方法的结点。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generic_visit</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'No visit_&#123;&#125; method'</span>.format(type(node).__name__))</span><br></pre></td></tr></table></figure><blockquote><p>NodeVisitor一个结点访问器的基类：它遍历抽象语法树并为找到的每个节点调用一个访问器函数。（这个函数可能会返回一个由visit()方法转发 的值）。This class is meant to be subclassed, with the subclass adding visitor methods.</p><p>成员函数：</p><ul><li>1️⃣ visit(node)：访问一个结点。它默认调用self.visit_classname（其中的classname是结点类的名<br>字，或者如果这个方法不存在时，classname就是 generic_visit() ）的方法。</li><li>2️⃣ generic_visit(node)：这个访问器(visitor)对结点的所有子节点调用visit()。<br>【注意：只有这个访问器调用generic_visit() 或者访问它本身，否则自定义访问器的结点的子节点将不会被访问】</li></ul><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getattr(object, name[, default])</span><br></pre></td></tr></table></figure><p>官方文档中说这个函数作用是返回对象的一个属性，第一个参数是对象实例<code>obj</code>,<code>name</code>是个字符串，是对象的成员函数名字或者成员变量，<code>default</code>当对象没有这个属相的时候就返回默认值，如果没有提供默认值就返回异常。</p><p>如：</p><ol><li>提供不默认写法：</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Test</span>(<span class="title">object</span>):</span></span><br><span class="line">...     <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">...             print <span class="string">'I am a test'</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; test = Test()  <span class="comment"># 实例化一个对象</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; func = getattr(test, <span class="string">'func'</span>) <span class="comment"># 使用getattr函数获取func的值</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; func()</span><br><span class="line">I am a test</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; func = getattr(test, <span class="string">'f'</span>)  <span class="comment"># 使用对象没有的属性，则会出现异常</span></span><br><span class="line">Traceback (most recent call last)<span class="symbol">:</span></span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line"><span class="symbol">AttributeError:</span> <span class="string">'Test'</span> object has no attribute <span class="string">'f'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure><ol><li>提供默认写法</li></ol><p>如果对象没有该属性可以提供一个默认值。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; func = getattr(test, <span class="string">'f'</span>, None)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; print func</span><br><span class="line">None</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="Interpreter-类的源代码"><a href="#Interpreter-类的源代码" class="headerlink" title="Interpreter 类的源代码"></a>Interpreter 类的源代码</h3><p>下面是 Interpreter 类的源代码，它继承自 NodeVisitor 类且实现了形式为 <code>visit_NodeType</code> 的不同方法，其中 <code>NodeType</code> 会被如 <code>BinOp</code>, <code>Num</code> 等类名替换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(NodeVisitor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parser)</span>:</span></span><br><span class="line">    self.parser = parser</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_BinOp</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> node.op.type == PLUS:</span><br><span class="line">        <span class="keyword">return</span> self.visit(node.left) + self.visit(node.right)</span><br><span class="line">    <span class="keyword">elif</span> node.op.type == MINUS:</span><br><span class="line">        <span class="keyword">return</span> self.visit(node.left) - self.visit(node.right)</span><br><span class="line">    <span class="keyword">elif</span> node.op.type == MUL:</span><br><span class="line">        <span class="keyword">return</span> self.visit(node.left) * self.visit(node.right)</span><br><span class="line">    <span class="keyword">elif</span> node.op.type == DIV:</span><br><span class="line">        <span class="keyword">return</span> self.visit(node.left) / self.visit(node.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_Num</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> node.value</span><br></pre></td></tr></table></figure><p>关于以上代码有两点值得在这里提一下：</p><blockquote><p>第一，<u>操作 AST 结点的访问器(也就是对AST数据的操作)</u>的代码 和 AST 结点(即，AST的数据结构)本身 分离（解耦了）。</p><ul><li>可以看到 AST 结点类(BinOp 和 Num)没有提供任何代码来操作存储在这些结点中的数据，该逻辑被封装在了实现 <code>NodeVisitor</code> 的 <code>Interpreter</code> 类中。（也就是对数据的操作在<code>NodeVisitor</code> 的 <code>Interpreter</code> 类中）。</li></ul><p>第二，在NodeVisitor的访问函数中，不像这样使用一个巨大的if语句:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit</span><span class="params">(node)</span>:</span></span><br><span class="line">    node_type = type(node).__name__</span><br><span class="line">    <span class="keyword">if</span> node_type == <span class="string">'BinOp'</span>:</span><br><span class="line">        <span class="keyword">return</span> self.visit_BinOp(node)</span><br><span class="line">    <span class="keyword">elif</span> node_type == <span class="string">'Num'</span>:</span><br><span class="line">        <span class="keyword">return</span> self.visit_Num(node)</span><br><span class="line">    <span class="keyword">elif</span> ...</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"><span class="comment">#####或者##########</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit</span><span class="params">(node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(node, BinOp):</span><br><span class="line">        <span class="keyword">return</span> self.visit_BinOp(node)</span><br><span class="line">    <span class="keyword">elif</span> isinstance(node, Num):</span><br><span class="line">        <span class="keyword">return</span> self.visit_Num(node)</span><br><span class="line">    <span class="keyword">elif</span> ...</span><br></pre></td></tr></table></figure><p>NodeVisitor 的 visit 方法非常通用，能根据传入的结点类型来调度适当的方法。正如前面提到的，为了利用这一点，我们的解释器继承了 NodeVisitor 类并实现了必要的方法。 因此：</p><ul><li>如果传递给 <code>visit</code> 函数的结点是 <code>BinOp</code>，那么<code>visit</code> 函数就会调用 <code>visit_BinOp</code> 方法。</li><li>如果传递给 <code>visit</code>函数的结点是 <code>Num</code>,那么 <code>visit</code> 函数就会调用<code>visit_Num</code> 方 法，等等。</li></ul></blockquote><p>花此时间研究一下这个方法（Python 的标准模块 <a href="https://docs.python.org/2.7/library/ast.html#module-ast" target="_blank" rel="noopener">ast</a> 也使用了相同的机制来遍历结点）， 因为我们将来会用很多新的 <code>visit_NodeType</code> 方法来扩展我们的解释器。</p><p>现在，让我们手工为表达式 2 * 7 + 3 建立一个 AST 并把它传递给解释器，通过对该表达式求值看看运行中的 visit 方法。下面是你从 Python shell 中尝试的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> spi <span class="keyword">import</span> Token, MUL, PLUS, INTEGER, Num, BinOp</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mul_token = Token(MUL, <span class="string">'*'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plus_token = Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mul_node = BinOp(</span><br><span class="line"><span class="meta">... </span>    left=Num(Token(INTEGER, <span class="number">2</span>)),</span><br><span class="line"><span class="meta">... </span>    op=mul_token,</span><br><span class="line"><span class="meta">... </span>    right=Num(Token(INTEGER, <span class="number">7</span>))</span><br><span class="line"><span class="meta">... </span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_node = BinOp(</span><br><span class="line"><span class="meta">... </span>    left=mul_node,</span><br><span class="line"><span class="meta">... </span>    op=plus_token,</span><br><span class="line"><span class="meta">... </span>    right=Num(Token(INTEGER, <span class="number">3</span>))</span><br><span class="line"><span class="meta">... </span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> spi <span class="keyword">import</span> Interpreter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inter = Interpreter(<span class="literal">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inter.visit(add_node)</span><br><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure><p>如你所见，我把表达式树的根结点传递给了 <code>visit</code> 方法，这一行为触发了树的遍历，遍历调用了 <code>Interpreter</code> 类正确的方法(<code>visit_BinOp</code> 和 <code>visit_Num</code>)并生成了结果。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""" SPI - Simple Pascal Interpreter """</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, PLUS, MINUS, MUL, DIV, LPAREN, RPAREN, EOF = (</span><br><span class="line">    <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'MINUS'</span>, <span class="string">'MUL'</span>, <span class="string">'DIV'</span>, <span class="string">'('</span>, <span class="string">')'</span>, <span class="string">'EOF'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        self.type = type</span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""String representation of the class instance.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">            Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">            Token(PLUS, '+')</span></span><br><span class="line"><span class="string">            Token(MUL, '*')</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Token(&#123;type&#125;, &#123;value&#125;)'</span>.format(</span><br><span class="line">            type=self.type,</span><br><span class="line">            value=repr(self.value)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"></span><br><span class="line"><span class="comment">###############################################################################</span></span><br><span class="line"><span class="comment">#                                                                             #</span></span><br><span class="line"><span class="comment">#  LEXER                                                                      #</span></span><br><span class="line"><span class="comment">#                                                                             #</span></span><br><span class="line"><span class="comment">###############################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lexer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="comment"># client string input, e.g. "4 + 2 * 3 - 6 / 2"</span></span><br><span class="line">        self.text = text</span><br><span class="line">        <span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        self.current_char = self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid character'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Advance the `pos` pointer and set the `current_char` variable."""</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt; len(self.text) - <span class="number">1</span>:</span><br><span class="line">            self.current_char = <span class="literal">None</span>  <span class="comment"># Indicates end of input</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_char = self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">            self.advance()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return a (multidigit) integer consumed from the input."""</span></span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">            result += self.current_char</span><br><span class="line">            self.advance()</span><br><span class="line">        <span class="keyword">return</span> int(result)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">        apart into tokens. One token at a time.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">                self.skip_whitespace()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isdigit():</span><br><span class="line">                <span class="keyword">return</span> Token(INTEGER, self.integer())</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'+'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'-'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'*'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MUL, <span class="string">'*'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'/'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(DIV, <span class="string">'/'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'('</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(LPAREN, <span class="string">'('</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">')'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(RPAREN, <span class="string">')'</span>)</span><br><span class="line"></span><br><span class="line">            self.error()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">###############################################################################</span></span><br><span class="line"><span class="comment">#                                                                             #</span></span><br><span class="line"><span class="comment">#  PARSER                                                                     #</span></span><br><span class="line"><span class="comment">#                                                                             #</span></span><br><span class="line"><span class="comment">###############################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AST</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span>   <span class="comment"># 表示定义留空</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinOp</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, left, op, right)</span>:</span></span><br><span class="line">        self.left = left</span><br><span class="line">        self.token = self.op = op</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Num</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, token)</span>:</span></span><br><span class="line">        self.token = token</span><br><span class="line">        self.value = token.value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lexer)</span>:</span></span><br><span class="line">        self.lexer = lexer</span><br><span class="line">        <span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">        self.current_token = self.lexer.get_next_token()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid syntax'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">        <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">        <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">        <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.lexer.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""factor : INTEGER | LPAREN expr RPAREN"""</span></span><br><span class="line">        token = self.current_token</span><br><span class="line">        <span class="keyword">if</span> token.type == INTEGER:</span><br><span class="line">            self.eat(INTEGER)</span><br><span class="line">            <span class="keyword">return</span> Num(token)</span><br><span class="line">        <span class="keyword">elif</span> token.type == LPAREN:</span><br><span class="line">            self.eat(LPAREN)</span><br><span class="line">            node = self.expr()</span><br><span class="line">            self.eat(RPAREN)</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""term : factor ((MUL | DIV) factor)*"""</span></span><br><span class="line">        node = self.factor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == MUL:</span><br><span class="line">                self.eat(MUL)</span><br><span class="line">            <span class="keyword">elif</span> token.type == DIV:</span><br><span class="line">                self.eat(DIV)</span><br><span class="line"></span><br><span class="line">            node = BinOp(left=node, op=token, right=self.factor())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        expr   : term ((PLUS | MINUS) term)*</span></span><br><span class="line"><span class="string">        term   : factor ((MUL | DIV) factor)*</span></span><br><span class="line"><span class="string">        factor : INTEGER | LPAREN expr RPAREN</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        node = self.term()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (PLUS, MINUS):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">                self.eat(PLUS)</span><br><span class="line">            <span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">                self.eat(MINUS)</span><br><span class="line"></span><br><span class="line">            node = BinOp(left=node, op=token, right=self.term())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.expr()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">###############################################################################</span></span><br><span class="line"><span class="comment">#                                                                             #</span></span><br><span class="line"><span class="comment">#  INTERPRETER                                                                #</span></span><br><span class="line"><span class="comment">#                                                                             #</span></span><br><span class="line"><span class="comment">###############################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeVisitor</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        method_name = <span class="string">'visit_'</span> + type(node).__name__</span><br><span class="line">        visitor = getattr(self, method_name, self.generic_visit)</span><br><span class="line">        <span class="keyword">return</span> visitor(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generic_visit</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'No visit_&#123;&#125; method'</span>.format(type(node).__name__))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(NodeVisitor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parser)</span>:</span></span><br><span class="line">        self.parser = parser</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_BinOp</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node.op.type == PLUS:</span><br><span class="line">            <span class="keyword">return</span> self.visit(node.left) + self.visit(node.right)</span><br><span class="line">        <span class="keyword">elif</span> node.op.type == MINUS:</span><br><span class="line">            <span class="keyword">return</span> self.visit(node.left) - self.visit(node.right)</span><br><span class="line">        <span class="keyword">elif</span> node.op.type == MUL:</span><br><span class="line">            <span class="keyword">return</span> self.visit(node.left) * self.visit(node.right)</span><br><span class="line">        <span class="keyword">elif</span> node.op.type == DIV:</span><br><span class="line">            <span class="keyword">return</span> self.visit(node.left) / self.visit(node.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_Num</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">interpret</span><span class="params">(self)</span>:</span></span><br><span class="line">        tree = self.parser.parse()</span><br><span class="line">        <span class="keyword">return</span> self.visit(tree)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                text = raw_input(<span class="string">'spi&gt; '</span>)</span><br><span class="line">            <span class="keyword">except</span> NameError:  <span class="comment"># Python3</span></span><br><span class="line">                text = input(<span class="string">'spi&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        lexer = Lexer(text)</span><br><span class="line">        parser = Parser(lexer)</span><br><span class="line">        interpreter = Interpreter(parser)</span><br><span class="line">        result = interpreter.interpret()</span><br><span class="line">        print(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>将以上代码保存到名为 <code>spi.py</code> 的文件中，或者直接从 <a href="https://github.com/rspivak/lsbasi/blob/master/part7/python/spi.py" target="_blank" rel="noopener">GitHub</a> 下载。自己试一试，确认 你的新的基于树的解释器可以正确地对算术表达式进行求值。</p><p>下面是某次运行过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python spi.py</span><br><span class="line">spi&gt; <span class="number">7</span> + <span class="number">3</span> * (<span class="number">10</span> / (<span class="number">12</span> / (<span class="number">3</span> + <span class="number">1</span>) - <span class="number">1</span>))</span><br><span class="line"><span class="number">22</span></span><br><span class="line">spi&gt; <span class="number">7</span> + <span class="number">3</span> * (<span class="number">10</span> / (<span class="number">12</span> / (<span class="number">3</span> + <span class="number">1</span>) - <span class="number">1</span>)) / (<span class="number">2</span> + <span class="number">3</span>) - <span class="number">5</span> - <span class="number">3</span> + (<span class="number">8</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line">spi&gt; <span class="number">7</span> + (((<span class="number">3</span> + <span class="number">2</span>)))</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天你学习了关于解析树和 AST，如何构建 AST 以及遍历表示输入的 AST 并解释执行。你还修改了 parser 和 interpreter 并将这两部分解开了。现在 lexer, parser 和 interpreter 之间的接口看起来像这样：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LSBASI-7/lsbasi_part7_pipeline.png" alt="lsbasi_part7_pipeline"></p><p>你可以把它读作“parser 从 lexer 中 得到 token 然后返回生成的 AST 给 Interpreter 进行遍历并解释执行所给输入”。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>这就是今天的所有内容，但在总结之前我还想简单地聊一聊递归下降 (recursive-descent) parser，即是仅仅给出它的定义。</p><blockquote><p>定义就是：一个 <strong>递归下降parser</strong> 就 是一个自顶向下的 parser，它使用一组递归过程来处理输入。自顶向下反映了 parser 从 构建解析树的顶部结点开始逐渐构建更低的结点这一事实。</p></blockquote><h2 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h2><p>本节与part6相比主要添加了AST：</p><ol><li><code>Lexer</code>与part6中的是一样的，还是将输入的text分析转换为token。(这也是词法分析器的功能)</li><li><code>Parser</code>相比part6，<ul><li>它添加了构造AST的内容：添加了三个类：<ul><li><code>AST()</code>：是一个基类</li><li><code>BinOp(AST)</code>：继承于<code>AST()</code>，主要功能是实现<strong>二元操作符<em>binary operator</em></strong> 。（这里只有四种：加、减、乘、除法）</li><li><code>Num(AST)</code>：继承于<code>AST()</code>，它主要是表示AST中的整数integer token（它将保存一个 <code>INTEGER</code> token 和该 token 的值）</li></ul></li><li>第二个变化就是实现语法解析的这三个函数<code>term</code>、<code>factor</code>、<code>expr</code>中的返回的不在是result变量了，而是返回一个结点node。</li></ul></li><li><code>Interpreter</code>：通过词法分析、语法分析之后，开始解释语法分析之后的算式，计算出它的结果，用<code>Interpreter</code>来解释：<ul><li>增添了<strong>访问者模式</strong>：将 对数据的操作(对数据的操作在interpreter中完成：访问、解释) 和 数据结构(数据结构 在parser中的三个类中构建) 进行分离（解耦合）。使得操作集合可相对自由地演化。<ul><li>这里通过创建 <code>NodeVisitor()</code>类 实现访问者模式。实现了通过什么方式去<strong>访问</strong>生成的AST</li><li>又通过<code>Interpreter</code>（继承于 <code>NodeVisitor()</code>类）来实现<strong>解释</strong>生成的AST</li></ul></li></ul></li></ol><p>最后，再次提醒一下：之前的那几小结，我们都是把interpreter的代码和parser的代码混在一起，但这一小节我们把interpreter的代码和parser的代码<strong>分开了</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Let&#39;s Build A Simple Interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let’s Build A Simple Interpreter 6</title>
      <link href="/archives/167c.html"/>
      <url>/archives/167c.html</url>
      
        <content type="html"><![CDATA[<p>新增了<strong>括号运算(parenthesized expressions)</strong></p><a id="more"></a><p>原文链接：<a href="https://ruslanspivak.com/lsbasi-part6/" target="_blank" rel="noopener">https://ruslanspivak.com/lsbasi-part6/</a></p><p>本文在前面的基础上，新增了<strong>括号运算(parenthesized expressions)</strong>，如： 7 + 3 * (10 / (12 / (3 + 1) - 1))</p><p>所以需要在part5中的语法基础上，进行修改，修改后的语法如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part6_grammar.png" alt="lsbasi_part6_grammar"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part5_grammar.png" alt="lsbasi_part5_grammar"></p><p>从上面的图可以看出来,在part6中，<code>expr</code>和<code>term</code>和part5中一样，<u>唯一变的是<code>factor</code>的<strong>产生式 (production)</strong>。</u></p><blockquote><p>它新添加了两个 terminal ：</p><ul><li>LPAREN：表示一个左括号 left parenthesis ‘( ‘</li><li>RPAREN：表示一个右括号 right parenthesis ‘)’</li></ul><p>还新添加了一个非终端符：<code>expr</code></p><ul><li><code>expr</code>添加在两个括号之间</li></ul></blockquote><p>下面是<code>factor</code>的语法图：（这里用到了<u>递归</u>）</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part6_factor_diagram.png" alt="lsbasi_part6_factor_diagram"></p><p>然后，再放一下没有改变的（与part5相同）<code>expr</code>、<code>term</code>的语法图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part6_expr_term_diagram.png" alt="img"></p><p>现在看一下算式：2 * (7 + 3) 的分解过程吧：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part6_decomposition.png" alt="img"></p><p>现在把语法转换成代码。</p><p>下面这两条是代码中主要改变的部分：</p><blockquote><ol><li><code>Lexer</code>被修改，使其在原来的基础上可以返回另外两个token：左括号LPAREN 、右括号RPAREN</li><li><code>Interpreter</code>类的<code>factor</code>被修改，修改之后不仅可以解析整数integer，还可以解析括号表达式(parenthesized expressions)</li></ol></blockquote><p>下面就是本小节的代码部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, PLUS, MINUS, MUL, DIV, LPAREN, RPAREN, EOF = (</span><br><span class="line">    <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'MINUS'</span>, <span class="string">'MUL'</span>, <span class="string">'DIV'</span>, <span class="string">'('</span>, <span class="string">')'</span>, <span class="string">'EOF'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        self.type = type</span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""String representation of the class instance.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">            Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">            Token(PLUS, '+')</span></span><br><span class="line"><span class="string">            Token(MUL, '*')</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Token(&#123;type&#125;, &#123;value&#125;)'</span>.format(</span><br><span class="line">            type=self.type,</span><br><span class="line">            value=repr(self.value)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lexer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="comment"># client string input, e.g. "4 + 2 * 3 - 6 / 2"</span></span><br><span class="line">        self.text = text</span><br><span class="line">        <span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        self.current_char = self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid character'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Advance the `pos` pointer and set the `current_char` variable."""</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt; len(self.text) - <span class="number">1</span>:</span><br><span class="line">            self.current_char = <span class="literal">None</span>  <span class="comment"># Indicates end of input</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_char = self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">            self.advance()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return a (multidigit) integer consumed from the input."""</span></span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">            result += self.current_char</span><br><span class="line">            self.advance()</span><br><span class="line">        <span class="keyword">return</span> int(result)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">        apart into tokens. One token at a time.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">                self.skip_whitespace()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isdigit():</span><br><span class="line">                <span class="keyword">return</span> Token(INTEGER, self.integer())</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'+'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'-'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'*'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MUL, <span class="string">'*'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'/'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(DIV, <span class="string">'/'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'('</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(LPAREN, <span class="string">'('</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">')'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(RPAREN, <span class="string">')'</span>)</span><br><span class="line"></span><br><span class="line">            self.error()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lexer)</span>:</span></span><br><span class="line">        self.lexer = lexer</span><br><span class="line">        <span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">        self.current_token = self.lexer.get_next_token()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid syntax'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">        <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">        <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">        <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.lexer.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""factor : INTEGER | LPAREN expr RPAREN"""</span></span><br><span class="line">        token = self.current_token</span><br><span class="line">        <span class="keyword">if</span> token.type == INTEGER:</span><br><span class="line">            self.eat(INTEGER)</span><br><span class="line">            <span class="keyword">return</span> token.value</span><br><span class="line">        <span class="keyword">elif</span> token.type == LPAREN:</span><br><span class="line">            self.eat(LPAREN)</span><br><span class="line">            result = self.expr()</span><br><span class="line">            self.eat(RPAREN)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""term : factor ((MUL | DIV) factor)*"""</span></span><br><span class="line">        result = self.factor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == MUL:</span><br><span class="line">                self.eat(MUL)</span><br><span class="line">                result = result * self.factor()</span><br><span class="line">            <span class="keyword">elif</span> token.type == DIV:</span><br><span class="line">                self.eat(DIV)</span><br><span class="line">                result = result / self.factor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Arithmetic expression parser / interpreter.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        calc&gt; 7 + 3 * (10 / (12 / (3 + 1) - 1))</span></span><br><span class="line"><span class="string">        22</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        expr   : term ((PLUS | MINUS) term)*</span></span><br><span class="line"><span class="string">        term   : factor ((MUL | DIV) factor)*</span></span><br><span class="line"><span class="string">        factor : INTEGER | LPAREN expr RPAREN</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = self.term()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (PLUS, MINUS):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">                self.eat(PLUS)</span><br><span class="line">                result = result + self.term()</span><br><span class="line">            <span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">                self.eat(MINUS)</span><br><span class="line">                result = result - self.term()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># To run under Python3 replace 'raw_input' call</span></span><br><span class="line">            <span class="comment"># with 'input'</span></span><br><span class="line">            text = raw_input(<span class="string">'calc&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        lexer = Lexer(text)</span><br><span class="line">        interpreter = Interpreter(lexer)</span><br><span class="line">        result = interpreter.expr()</span><br><span class="line">        print(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Let&#39;s Build A Simple Interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let’s Build A Simple Interpreter 5</title>
      <link href="/archives/173c.html"/>
      <url>/archives/173c.html</url>
      
        <content type="html"><![CDATA[<p>本文为这一系列的part5，第五小节。这次将写一个可移植性加减乘除混合运算的解释器。</p><a id="more"></a><p>原文链接：<a href="https://ruslanspivak.com/lsbasi-part5/" target="_blank" rel="noopener">https://ruslanspivak.com/lsbasi-part5/</a></p><p>本文为这一系列的part5，第五小节。这次将写一个可移植性加减乘除混合运算的解释器。</p><p>在开始写代码之前，我们需要知道一些，比如：<strong>结合律</strong>、操作符(operator)的<strong>优先级(precedence)</strong></p><h2 id="结合律-associativity"><a href="#结合律-associativity" class="headerlink" title="结合律(associativity)"></a>结合律(associativity)</h2><p>比如，7+3+1等同于(7+3)+1 ，7 - 3 - 1 等同于 (7 - 3) - 1。这没有什么奇怪的。但是再比如： 7 - 3 - 1 与 7 - (3 - 1) 的结果就不一样了。</p><p>其实：加、减、乘、除 这些操作符(operator)是<strong>左结合(left-associative)</strong>。</p><ul><li>比如， 7 + 3 + 1 中的 <strong>操作数(operand)</strong> 3，它的左右都是 加号 ，但是这个操作数3是与它左边的加号“+”结合的， 所以加法是左结合。</li><li>那加减乘除混合时，如 7 + 5 * 2 是否还是遵循左结合律呢？很显然，不遵循，因为 (7 + 5) * 2 不等于 7 + 5 * 2 。</li></ul><p>由此可知：</p><p>​ <u>加法</u>和<u>减法</u>是一类，所以它们在一起组成的运算是左结合；<u>乘法</u>和<u>除法</u>是一类，所以他们在一起组成的运算是左结合。（即，左结合律只适用于同一类的操作符(operator)）</p><h2 id="优先级-precedence"><a href="#优先级-precedence" class="headerlink" title="优先级(precedence)"></a>优先级(precedence)</h2><p>那我们如何规定这种加减乘除（这两类操作符(operator)）同时出现时的运算规则呢？（实际上我们都知道，但是这里是为实现代码来做出一种运算规则）</p><p>在 7 + 5 * 2中，如果<u>操作符“<em>”</em></u>能先比<u>操作符“+”</u>到他的<u>操作数5</u>，就说，操作符“”有<strong>更高的优先级(higher precedence)</strong>。</p><p>在实际中我们也在用，也知道。乘除的优先级要高于加减法。</p><p>好了，现在我们开始用表格来表示操作符的结合律与优先级：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part5_precedence.png" alt="随着箭头方向优先级升高"></p><p>由上表可知：+ and - 是优先级相同，都是左结合；* and / 优先级相同，也都是左结合；</p><p>我们还可以根据上面的优先级表格来制定一个语法规则：</p><ol><li>优先级相同的每一级都定义一个非终端符(non-terminal)。其中每个<strong>产生式(production)</strong>的body中应该包含:算数运算符(arithmetic operators) &amp; 非终端符(这里的非终端又参与构成下一较高的优先级的规则(产生式)的一部分)</li><li>创建一个表示 基本表达式的非终端符<code>factor</code>，本文中指integer。一般的规则是：如果你有N个优先级，那么你就需要N+1个非终端符（一类是每一层优先级的一个非终端符，一类是表示基本表达式单元）</li></ol><h2 id="构建语法-grammars"><a href="#构建语法-grammars" class="headerlink" title="构建语法(grammars)"></a>构建语法(grammars)</h2><p>现在根据上面的规则来构建语法：</p><p>由规则1，我们将定义两个非终结符(non-terminal)，一个是leve1的non-terminal叫做<code>expr</code>，另一个是level2的non-terminal叫做term。然后根据规则2，我们需要定义一个叫做<code>factor</code>的non-terminal来作为一个基本的表达式单元，integers。</p><p>这个语法的<strong>开始符号（<em>start symbol</em> ）</strong>叫做<code>expr</code>。它的产生式(production)的body含有：</p><ul><li><p>1️⃣表示level2的操作符(在这指的是+ and - )，</p></li><li><p>2️⃣和一个非终端符<code>term</code>(这个term是下一层优先级（更高的）level1 的一个产生式)</p></li></ul><blockquote><p><strong>开始符号（S）</strong>：最大的语法单位 或 最重要的语法单位。（如上面的那个英文句子中的，最大的语法单位是：句子。）</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part5_cfg_expr.png" alt="start symbol（开始符）:expr"></p><p>非终端符<code>term</code>的production(产生式)的body包含:</p><ul><li><p>1️⃣表示level1的操作符(在这指的是 * and /)。</p></li><li><p>2️⃣还有一个非终端符<code>factor</code>来表示基本的表达式单元，integers</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part5_cfg_term.png" alt="term"></p></li></ul><p>非终端符<code>factor</code>包含：</p><ul><li><p>1️⃣一个integer</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part5_cfg_factor.png" alt="factor"></p></li></ul><p>上面的三幅图是语法、语法图的一部分，这在之前的文章中也出现过。但现在需要将上面的三幅图结合在一起来考虑结合律和优先级（ associativity and precedence ）</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part5_grammar.png" alt="img"></p><p>下面是本文的语法对应的语法图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LSBASI-5/20200318213222.png" alt="grammar"></p><p>上面语法图的每一个小方框都是其他语法图的：函数调用（“method call”）。</p><blockquote><p>如果你以表达式 7 + 5 * 2 为例并从顶 层图 <code>expr</code> 开始逐步分解到最底层的图 <code>factor</code>, 你应该可以看到位于中间的图的高优 先级操作符*和/会比上面的图的操作符+和-先执行。</p></blockquote><p>为了解释清楚运算符的优先级，让我们看看使用上面语法和句法图来分解相同算术表达式 7 + 5 * 2 的过程。这只是另一种展示高优先级运算符 先于 低优先级运算符执行这个事实的 方式。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part5_exprdecomp.png" alt="img"></p><h3 id="语法转换成代码"><a href="#语法转换成代码" class="headerlink" title="语法转换成代码"></a>语法转换成代码</h3><p>让我们使用<a href="http://ruslanspivak.com/lsbasi-part4/" target="_blank" rel="noopener">part 4</a>中的准则把该语法转化成代码，看看它怎么工作，先看一张上面放过的语法图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part5_grammar-1583931621458.png" alt="语法图"></p><p>下面是能处理可以包含任意数量加减乘除操作符的算术表达式的计算器的完整代码。</p><blockquote><p>相比于<a href="http://ruslanspivak.com/lsbasi-part4/" target="_blank" rel="noopener">part 4</a>代码的主要变化有：</p><ul><li><code>Lexer</code> 类现在可以把+,-,*和/都 token 化了（没什么新方法，我们只是把前面文章中 的代码合并到一个类中来支持所有这些 token）</li><li>回想语法中的每条规则（产生式）R都要变成一个同名的方法，且对该规则的引用都要变 成一个方法调用 <code>R()</code> 这一点。现在 <code>Interpreter</code> 类有了三个方法来对应语法中的非 终结符： <code>expr</code>, <code>term</code>, <code>factor</code>.</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, PLUS, MINUS, MUL, DIV, EOF = (</span><br><span class="line">    <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'MINUS'</span>, <span class="string">'MUL'</span>, <span class="string">'DIV'</span>, <span class="string">'EOF'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        <span class="comment"># token type: INTEGER, PLUS, MINUS, MUL, DIV, or EOF</span></span><br><span class="line">        self.type = type</span><br><span class="line">        <span class="comment"># token value: non-negative integer value, '+', '-', '*', '/', or None</span></span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""String representation of the class instance.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">            Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">            Token(PLUS, '+')</span></span><br><span class="line"><span class="string">            Token(MUL, '*')</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Token(&#123;type&#125;, &#123;value&#125;)'</span>.format(</span><br><span class="line">            type=self.type,</span><br><span class="line">            value=repr(self.value)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lexer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="comment"># client string input, e.g. "3 * 5", "12 / 3 * 4", etc</span></span><br><span class="line">        self.text = text</span><br><span class="line">        <span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        self.current_char = self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid character'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Advance the `pos` pointer and set the `current_char` variable."""</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt; len(self.text) - <span class="number">1</span>:</span><br><span class="line">            self.current_char = <span class="literal">None</span>  <span class="comment"># Indicates end of input</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_char = self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">            self.advance()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return a (multidigit) integer consumed from the input."""</span></span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">            result += self.current_char</span><br><span class="line">            self.advance()</span><br><span class="line">        <span class="keyword">return</span> int(result)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">        apart into tokens. One token at a time.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">                self.skip_whitespace()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isdigit():</span><br><span class="line">                <span class="keyword">return</span> Token(INTEGER, self.integer())</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'+'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'-'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'*'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MUL, <span class="string">'*'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'/'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(DIV, <span class="string">'/'</span>)</span><br><span class="line"></span><br><span class="line">            self.error()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lexer)</span>:</span></span><br><span class="line">        self.lexer = lexer</span><br><span class="line">        <span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">        self.current_token = self.lexer.get_next_token()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid syntax'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">        <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">        <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">        <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.lexer.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""factor : INTEGER"""</span></span><br><span class="line">        token = self.current_token</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        <span class="keyword">return</span> token.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""term : factor ((MUL | DIV) factor)*"""</span></span><br><span class="line">        result = self.factor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == MUL:</span><br><span class="line">                self.eat(MUL)</span><br><span class="line">                result = result * self.factor()</span><br><span class="line">            <span class="keyword">elif</span> token.type == DIV:</span><br><span class="line">                self.eat(DIV)</span><br><span class="line">                result = result / self.factor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Arithmetic expression parser / interpreter.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        calc&gt;  14 + 2 * 3 - 6 / 2</span></span><br><span class="line"><span class="string">        17</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        expr   : term ((PLUS | MINUS) term)*</span></span><br><span class="line"><span class="string">        term   : factor ((MUL | DIV) factor)*</span></span><br><span class="line"><span class="string">        factor : INTEGER</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = self.term()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (PLUS, MINUS):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">                self.eat(PLUS)</span><br><span class="line">                result = result + self.term()</span><br><span class="line">            <span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">                self.eat(MINUS)</span><br><span class="line">                result = result - self.term()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># To run under Python3 replace 'raw_input' call</span></span><br><span class="line">            <span class="comment"># with 'input'</span></span><br><span class="line">            text = raw_input(<span class="string">'calc&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        lexer = Lexer(text)</span><br><span class="line">        interpreter = Interpreter(lexer)</span><br><span class="line">        result = interpreter.expr()</span><br><span class="line">        print(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>将以上代码保存到名为 <code>calc5.py</code> 中，或者直接从 <a href="https://github.com/rspivak/lsbasi/blob/master/part5/calc5.py" target="_blank" rel="noopener">GitHub</a> 上下载。和以往一样，自己尝 试一下，确认解释器可以对包含不同优先级操作符的算术表达式进行求值。</p><h2 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h2><p>代码中有三个类(class)，他们中的函数及作用：</p><ol><li><p><code>Token</code>：</p><ul><li><p><code>__init__</code>：初始化实例</p></li><li><p><code>__str__</code>：字符串形式</p></li><li><p><code>__repr__</code>：字符串形式</p><blockquote><p>在Python中，所有以“_<em>”双下划线包起来的方法，都统称为“Magic Method”（魔术方法）,例如类的初始化方法 __init_</em></p><table><thead><tr><th><strong><strong>repr</strong>(self)</strong></th><th>定义当被 repr() 调用时的行为</th></tr></thead><tbody><tr><td><strong><strong>str</strong>(self)</strong></td><td>定义当被 str() 调用时的行为</td></tr></tbody></table></blockquote></li></ul></li><li><p><code>Lexer</code>用于词法分析：</p><ul><li><code>__init__</code>：初始化实例</li><li><code>error</code>：错误提示</li><li><code>advance</code>：使pos前进一个位置</li><li><code>skip_whitespace</code>：略过空格</li><li><code>integer</code>：识别整数（可以识别多位数）</li><li><code>get_next_token</code>：获得一个token（其实我觉得叫做：<code>get_token_and_to_next</code>更合适）</li></ul></li><li><p><code>Interpreter</code>用于语法分析：</p><ul><li><code>__init__</code>：初始化实例</li><li><code>error</code>：错误提示</li><li><code>eat</code>：负责检测当前的token.type与传入的token_type是否相同。若相同，则将当前的token“吃了”，然后把当前token的下一个token分配给current_token。</li><li>下面就是语法分析的核心了，由上面的分析直到，它由：<code>expr</code>、<code>term</code>、<code>factor</code>构成。</li></ul></li></ol><p>梳理完毕。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Let&#39;s Build A Simple Interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let’s Build A Simple Interpreter 4</title>
      <link href="/archives/3b16.html"/>
      <url>/archives/3b16.html</url>
      
        <content type="html"><![CDATA[<p>原文链接：<a href="https://ruslanspivak.com/lsbasi-part4/" target="_blank" rel="noopener">https://ruslanspivak.com/lsbasi-part4/</a></p><p>在前面的文章中你学会了怎样识别和解释包含任意数量的加减操作的算术表达式，例如“7 - 3 + 2 - 1”。还学会了句法图以及它们如何被用来表示一门编程语言的语法。</p><p>今天你将会学习解析(parse)和解释(interpret)包含任意乘除操作的算术表达式，例如“7 * 4 / 2 * 3”。在这篇文章中使用的是整数除法，所以对于表达式“9 / 4”来说，结果是一个 整数：2。</p><p>我今天会讲很多另一个表示编程语言句法的广泛使用的表示法，叫 <strong>上下文无关语法</strong> (context-free grammars, 简记为 grammars)或 <strong>BNF</strong> (Backus-Naur Form)。为了这篇文章的目的，我不会使用纯 <a href="https://en.wikipedia.org/wiki/Backus–Naur_Form" target="_blank" rel="noopener">BNF</a> 记法，而更像是一个修改过的 <a href="https://en.wikipedia.org/wiki/Extended_Backus–Naur_Form" target="_blank" rel="noopener">EBNF</a> 记法。</p><blockquote><p><strong>文法(语法)</strong>：描述语言的语法结构的形式规则。</p><p><strong>上下文无关语法</strong>就是说这个文法中所有的产生式左边只有一个非终结符，比如：</p><p>S -&gt; aSb</p><p>S -&gt; ab<br>这个文法有两个产生式，每个产生式左边只有一个非终结符S，这就是上下文无关文法，因为你只要找到符合产生式右边的串，就可以把它归约为对应的非终结符。</p><p>比如：</p><p>aSb -&gt; aaSbb</p><p>S -&gt; ab<br>这就是上下文相关文法，因为它的第一个产生式左边有不止一个符号，所以你在匹配这个产生式中的S的时候必需确保这个S有正确的“上下文”，也就是左边的a和右边的b，所以叫上下文相关文法。</p><p>作者：徐辰<br>链接：<a href="https://www.zhihu.com/question/21833944/answer/40689967" target="_blank" rel="noopener">https://www.zhihu.com/question/21833944/answer/40689967</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><p>以下是一些使用语法的原因：</p><ol><li>语法使用了一种简明的方式来描述一门编程语言的句法。不像语法图，语法非常紧凑。 在以后的文章中，你会看到我越来越多地使用语法。</li><li>语法可以做为文档保存。</li><li>即使对从头开始写解析器(parser)来说，语法也是一个好的入手点。很多时候通过遵循 一套简单的规则你就可以把语法转化成代码。</li><li>有一套工具，叫解析器生成器(parser generator)，可以把语法做为输入并自动根据它为你生成一个解析器。我会以后在这个系列中谈到这些工具。</li></ol><h2 id="语法机制"><a href="#语法机制" class="headerlink" title="语法机制"></a>语法机制</h2><p>现在，我们来聊聊语法的机制方面：</p><p>下面的语法描述了算术表达式，像“7 * 4 / 2 * 3”这样的（这只是该语法可以生成的许多表达式<strong>之一</strong>）：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200310202232.png" alt="BNF-1"></p><p>语法是由一系列规则组成的，也被称为<strong>产生式(production)</strong>。我们的语法中有两条规则(产生式)：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200310202500.png" alt=""></p><ul><li><p>1、一条规则由：<u>一个非终结符</u>(叫做 <strong>head</strong>或生成式的<strong>左</strong>边) <strong>+</strong> <u>一个分号</u>（:）<strong>+</strong> <u>一系列终结符 和/或 非终结符</u>(叫做 <strong>body</strong> 或 <strong>右边</strong>)：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200310204653.png" alt=""></p></li><li><p>2、在上面展示的语法中，像 MUL, DIV, 或 INTEGER 这样的 token 被称为 <strong>终结符(terminals)</strong>, <code>expr</code> <code>factor</code> 这样的变量被称为 <strong>非终结符(not-terminals)</strong>.</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200310204953.png" alt=""></p></li></ul><p>第一条规则左边的非终结符被叫做 <strong>开始符号(start symbol)</strong>. 在我们的语法中，开始符号是 <em>expr</em>:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200310205155.png" alt=""></p><p>你可以这么理解 <code>expr</code> 这条规则：“expr 是一个 factor 后面可选地跟一个乘或除运算符再跟 另一个 factor，后面也相应可选地跟一个乘或除运算符再跟另一个 factor，如此重复”。</p><p>factor 是什么？对于本文来说 factor 就是一个整数。</p><h3 id="语法中的符号"><a href="#语法中的符号" class="headerlink" title="语法中的符号"></a>语法中的符号</h3><p>让我们快速地过一遍语法中的符号及它们的意义。</p><ul><li><p><code>|</code>多选一。竖线表示“或”。所以 <code>(MUL | DIV)</code> 表示 MUL 或 DIV</p></li><li><p><code>(...)</code>被括号包围表示把终结符 和/或 非终结符组成一组，就像 <code>(MUL | DIV)</code></p></li><li><p><code>(...)*</code>分组中的内容被匹配 0 或 多次。</p></li></ul><p>语法通过解释可以组成什么样的句子来定义一门语言。通过语法派生出算术表达式的方式为：首先从开始符号 <code>expr</code> 开始，然后反复地使用所包含的非终结符的规则替换该非终结符， 直到生成一个<u>只包含终结符的</u>句子。语法能组成的句子构成了一门语言。</p><p>下面举例说明：</p><ul><li><p>例1，下面是语法如何派生出表达式 <code>3</code>:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200310210521.png" alt=""></p></li><li><p>例2，下面是语法如何派生出表达式 <code>3 * 7</code>:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200310210557.png" alt=""></p></li><li><p>例3，下面是语法如何派生出表达式 <code>3 * 7 / 2</code>:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part4_derive3.png" alt="img"></p></li></ul><h2 id="将语法变成代码"><a href="#将语法变成代码" class="headerlink" title="将语法变成代码"></a>将语法变成代码</h2><p>下面是一些我们在把语法转化成源代码时会用到的==四个准则==。按照这些准则，你真的就可以把语法翻译成一个可工作的 parser:</p><ol><li>对于语法中定义的每个规则 R，将它做成一个有相同名字的方法，对该规则的引用就变成了一个方法调用：R()。该方法的方法体遵循该规则的步骤，过程中使用相同的准则。</li><li>多选一 <code>(a1|a2|aN)</code> 变成 <strong>if-elif-else</strong> 语句</li><li>可选组 <code>(...)*</code> 变成一个可以执行 0 或多次的 <strong>while</strong> 循环（can loop over zero or more times）</li><li>每个 Token 记为 T 变成一个 <code>eat</code> 方法调用: <code>eat(T)</code>. <code>eat</code> 方法的工作是 当它匹配到当前的<code>向前看</code> (lookahead) token 就消耗掉它，然后从 lexer 中得到一个新 token 并将它赋值给内部变量 <code>current_token</code>.</li></ol><p>这些准则看上去像这样：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200310211240.png" alt=""></p><p>让我们继续并遵循上述准则把我们的语法转化为代码。</p><p>我们的语法中有两条规则： <code>expr</code> 和 <code>factor</code>. 我们从 <code>factor</code> 规则（生成式）开始。 根据准则，需要新建一个名为 factor 的方法（准则1)，它调用了一次 <code>eat</code> 方法来消耗INTEGER token （准则4)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span>   <span class="comment">#factor就是指的integer型数值</span></span><br><span class="line">    self.eat(INTEGER)</span><br></pre></td></tr></table></figure><p><code>expr</code> 规则变成了 <code>expr</code> 方法（还是准则1）。规则体(body)开始的 <code>factor</code> 引用 变成了对 <code>factor()</code> 方法的调用。可行组 <code>(...)*</code> 变成了一个 <code>while</code> 循环，多选一 <code>(MUL|DIV)</code> 变成了一个 <code>if-elif-else</code> 语句。把这些片段合并在一起就得到了下面的<code>expr</code> 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.factor() <span class="comment">#语法准则中的第一个factor</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">        token = self.current_token</span><br><span class="line">        <span class="keyword">if</span> token.type == MUL:</span><br><span class="line">            self.eat(MUL)</span><br><span class="line">            self.factor()</span><br><span class="line">        <span class="keyword">elif</span> token.type == DIV:</span><br><span class="line">            self.eat(DIV)</span><br><span class="line">            self.factor()</span><br></pre></td></tr></table></figure><p>原作者将本文的代码放在了文件 <code>parser.py</code> 中，它包含了 lexer 和 parser 但没有interpreter。你可以直接从 <a href="https://github.com/rspivak/lsbasi/blob/master/part4/parser.py" target="_blank" rel="noopener">GitHub</a>下载并尝试一下。它包含有一个 interpreter 提示符，你可以输入表达式来查看它是否合法，即查看根据语法建立的 parser 是否可以识别出表达式。</p><p>下面是在我笔记本上的一次尝试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ python parser.py</span><br><span class="line">calc&gt; <span class="number">3</span></span><br><span class="line">calc&gt; <span class="number">3</span> * <span class="number">7</span></span><br><span class="line">calc&gt; <span class="number">3</span> * <span class="number">7</span> / <span class="number">2</span></span><br><span class="line">calc&gt; <span class="number">3</span> *</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"parser.py"</span>, line <span class="number">155</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    main()</span><br><span class="line">  File <span class="string">"parser.py"</span>, line <span class="number">151</span>, <span class="keyword">in</span> main</span><br><span class="line">    parser.parse()</span><br><span class="line">  File <span class="string">"parser.py"</span>, line <span class="number">136</span>, <span class="keyword">in</span> parse</span><br><span class="line">    self.expr()</span><br><span class="line">  File <span class="string">"parser.py"</span>, line <span class="number">130</span>, <span class="keyword">in</span> expr</span><br><span class="line">    self.factor()</span><br><span class="line">  File <span class="string">"parser.py"</span>, line <span class="number">114</span>, <span class="keyword">in</span> factor</span><br><span class="line">    self.eat(INTEGER)</span><br><span class="line">  File <span class="string">"parser.py"</span>, line <span class="number">107</span>, <span class="keyword">in</span> eat</span><br><span class="line">    self.error()</span><br><span class="line">  File <span class="string">"parser.py"</span>, line <span class="number">97</span>, <span class="keyword">in</span> error</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">'Invalid syntax'</span>)</span><br><span class="line">Exception: Invalid syntax</span><br></pre></td></tr></table></figure><p>这里再次提起语法图。这是相同的 <code>expr</code> 规则（也叫，产生式(production)）对应的句法图：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200310212342.png" alt="expr"></p><p>下面是原作者的关于本文的源码。下面是可以处理包含任意数量整数 乘除（整数除法）操作的合法的算术表达式的计算器代码。这里把词法分析器重构 到了一个单独的类 <code>Lexer</code> 中，并让 <code>Interpreter</code> 类使用 <code>Lexer</code> 实例做为参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, MUL, DIV, EOF = <span class="string">'INTEGER'</span>, <span class="string">'MUL'</span>, <span class="string">'DIV'</span>, <span class="string">'EOF'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        <span class="comment"># token type: INTEGER, MUL, DIV, or EOF</span></span><br><span class="line">        self.type = type</span><br><span class="line">        <span class="comment"># token value: non-negative integer value, '*', '/', or None</span></span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""String representation of the class instance.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">            Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">            Token(MUL, '*')</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Token(&#123;type&#125;, &#123;value&#125;)'</span>.format(</span><br><span class="line">            type=self.type,</span><br><span class="line">            value=repr(self.value)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"></span><br><span class="line"><span class="comment">#词法分析</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lexer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="comment"># client string input, e.g. "3 * 5", "12 / 3 * 4", etc</span></span><br><span class="line">        self.text = text</span><br><span class="line">        <span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        self.current_char = self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid character'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Advance the `pos` pointer and set the `current_char` variable."""</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt; len(self.text) - <span class="number">1</span>:</span><br><span class="line">            self.current_char = <span class="literal">None</span>  <span class="comment"># Indicates end of input</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_char = self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">            self.advance()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return a (multidigit) integer consumed from the input."""</span></span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">            result += self.current_char</span><br><span class="line">            self.advance()</span><br><span class="line">        <span class="keyword">return</span> int(result)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#不如叫做：get_token_and_next</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">        apart into tokens. One token at a time.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">                self.skip_whitespace()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isdigit():</span><br><span class="line">                <span class="keyword">return</span> Token(INTEGER, self.integer())</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'*'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MUL, <span class="string">'*'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'/'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(DIV, <span class="string">'/'</span>)</span><br><span class="line"></span><br><span class="line">            self.error()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lexer)</span>:</span></span><br><span class="line">        self.lexer = lexer</span><br><span class="line">        <span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">        self.current_token = self.lexer.get_next_token()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid syntax'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">        <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">        <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">        <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.lexer.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return an INTEGER token value.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        factor : INTEGER</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        token = self.current_token</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        <span class="keyword">return</span> token.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Arithmetic expression parser / interpreter.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        expr   : factor ((MUL | DIV) factor)*</span></span><br><span class="line"><span class="string">        factor : INTEGER</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = self.factor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == MUL:</span><br><span class="line">                self.eat(MUL)</span><br><span class="line">                result = result * self.factor()</span><br><span class="line">            <span class="keyword">elif</span> token.type == DIV:</span><br><span class="line">                self.eat(DIV)</span><br><span class="line">                result = result / self.factor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># To run under Python3 replace 'raw_input' call</span></span><br><span class="line">            <span class="comment"># with 'input'</span></span><br><span class="line">            text = raw_input(<span class="string">'calc&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        lexer = Lexer(text)</span><br><span class="line">        interpreter = Interpreter(lexer)</span><br><span class="line">        result = interpreter.expr()</span><br><span class="line">        print(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>将以上代码保存到名为 <code>calc4.py</code> 中，或者直接从 <a href="https://github.com/rspivak/lsbasi/blob/master/part4/calc4.py" target="_blank" rel="noopener">GitHub</a> 上下载。和以往一样，自己尝 试一下，确认它能工作。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Let&#39;s Build A Simple Interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let’s Build A Simple Interpreter 3</title>
      <link href="/archives/f957.html"/>
      <url>/archives/f957.html</url>
      
        <content type="html"><![CDATA[<p>原文链接：<a href="https://ruslanspivak.com/lsbasi-part3/" target="_blank" rel="noopener">https://ruslanspivak.com/lsbasi-part3/</a></p><p>目前为止，你已经学习了如何解释整数相加或相减的算术表达式如“7+3”或“12-9”。今天我 会聊一聊怎样解析（识别）并解释包含多位整数的加减法的算术表达式，如“7 - 3 + 2 - 1”。</p><h2 id="语法图"><a href="#语法图" class="headerlink" title="语法图"></a>语法图</h2><p>本文中的算术表达式可以用如下的语法图(syntax diagram)表示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part3_syntax_diagram-1583822487945.png" alt="语法图"></p><blockquote><p><strong>语法图(syntax diagram)</strong>：就是程序语言句法规则的图形表示。基本上，语法图从视觉上向你展示了在你的程序语言中哪些语句是允许的哪些是不允许的。</p></blockquote><p>句法图很容易阅读：只需跟随箭头所指示的路径即可。一些路径表示选择，一些路径表示循环。</p><p>你可以这样阅读上面的句法图：一个 term 后面可以跟一个加号或减号，后面又跟另一个 term， 相应地它后面又可以跟一个加号或减号，后面又跟另一个 term，如此循环。你已经读懂了 这幅图片，真的。<u>你可能会疑惑什么是“term”。在这篇文章中“term”就是一个整数。</u></p><h3 id="语法图的用途"><a href="#语法图的用途" class="headerlink" title="语法图的用途"></a>语法图的用途</h3><p>本文中的语法图主要有两个用途：</p><ul><li>从图形上表示一个编程语言的标准（语法）。</li><li>用来帮助你编写parser(语法分析器)，你可以通过下面简单的规则将图映射到代码。</li></ul><h2 id="语法分析器"><a href="#语法分析器" class="headerlink" title="语法分析器"></a>语法分析器</h2><p>你已经学过了从 token 流中识别组合的过程叫 <strong>parsing</strong>. 且解释器或编译器中执行这部分任务的叫 <strong>parser</strong>. parsing也被称为 <strong>语法分析</strong> (syntax analysis)，parser也相应地被称为<strong>语法分析器</strong>(syntax analyzer)，你应该也猜到这点了。</p><p>根据上面的句法图，下面所有的算术表达式都是合法的：</p><ul><li>3</li><li>3 + 4</li><li>7 - 3 + 2 - 1</li></ul><p>因为在不同的程序语言中算术表达式的句法规则都相似，我们可以使用 Python shell 来 “测试”我们的句法图。启动 Python shell 自己试一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> + <span class="number">4</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">7</span> - <span class="number">3</span> + <span class="number">2</span> - <span class="number">1</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>一切正常。</p><p>但表达式“3+”就不是合法的算术表达式，因为根据句法图加号后面必须跟一个 term（整数）， 否则就是句法错误。两次启动 Python shell 自己查看结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> +</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    <span class="number">3</span> +</span><br><span class="line">      ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><p>使用 Python shell 来做测试是挺不错的，不过我们还是把上面的句法图映射到代码，用我 们自己的解释器来测试，是吧？</p><p>从前面的文章（<a href="http://ruslanspivak.com/lsbasi-part1/" target="_blank" rel="noopener">第一部分</a>和<a href="http://ruslanspivak.com/lsbasi-part2/" target="_blank" rel="noopener">第二部分</a>）你知道了 parser 和 interpreter 都在 <code>expr</code> 方 法中。再重复一下，parser只是识别出结构并保证它符合某些规范，interpreter在parser成功识别后对表达式进行求值。</p><p>下面的代码片段展示了与句语法图相对应的 parser 的代码。语法图中的矩形盒子变成了解析一个整数的 <code>term</code> 方法， <code>expr</code> 方法则只是跟随了语法图的指示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span>    </span><br><span class="line">    self.eat(INTEGER)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span>    </span><br><span class="line"><span class="comment"># set current token to the first token taken from the input  </span></span><br><span class="line">self.current_token = self.get_next_token()    </span><br><span class="line">        </span><br><span class="line">self.term()    </span><br><span class="line"><span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (PLUS, MINUS):</span><br><span class="line">token = self.current_token</span><br><span class="line">        <span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">self.eat(PLUS)</span><br><span class="line">self.term()</span><br><span class="line"><span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">self.eat(MINUS)</span><br><span class="line">self.term()</span><br></pre></td></tr></table></figure><p>可以看到 <code>expr</code> 方法首先调用了 <code>term</code> 方法。然后是一个可能执行 0 或多次的循环。 在循环中，parser 根据 token （是加号还是减号）来做选择。</p><p><strong>Parser 本身并不解释任何事</strong>：如果识别到一个表达式它就沉默，否则就抛出一个句法错误。 让我们修改 <code>expr</code> 方法来添加 interpreter 代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Return an INTEGER token value"""</span></span><br><span class="line">    token = self.current_token</span><br><span class="line">    self.eat(INTEGER)</span><br><span class="line">    <span class="keyword">return</span> token.value</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Parser / Interpreter"""</span></span><br><span class="line">    <span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">    self.current_token = self.get_next_token()</span><br><span class="line"></span><br><span class="line">    result = self.term()</span><br><span class="line">    <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (PLUS, MINUS):</span><br><span class="line">token = self.current_token</span><br><span class="line"><span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">    self.eat(PLUS)</span><br><span class="line">    result = result += self.term()</span><br><span class="line"><span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">    self.eat(MINUS)</span><br><span class="line">    result = result - self.term()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>因为 interpreter 需要对表达式进行求值，所以 <code>term</code> 方法被修改为返回一个整数值， <code>expr</code> 方法被修改为在适当的地方执行加减法并返回解释的结果。</p><p>让我们继续前进，来看一下现在解释器的完整代码怎么样？</p><p>下面是你新版计算器的源代码，它可以处理包含任意多个整数的加减操作的合法算术表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Token的类型：'INTEGER', 'PLUS', 'MINUS', 'EOF'</span></span><br><span class="line"><span class="comment"># Token的值(value)：整数，'+', '-', or None</span></span><br><span class="line">INTEGER, PLUS, MINUS, EOF = <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'MINUS'</span>, <span class="string">'EOF'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义Token类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        self.type = type</span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Token( &#123;type&#125;, &#123;value&#125; ) '</span> .format(</span><br><span class="line">            type = self.type ,</span><br><span class="line">            value = repr(self.value) <span class="comment">#repr与下面的__repr__不一样，下面的是重构的。</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        self.currrent_token = <span class="literal">None</span> <span class="comment">#此时还没有token实例所以是None</span></span><br><span class="line">        self.current_char =self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="comment">##########################################################</span></span><br><span class="line">    <span class="comment">#                       Lexer code                       #</span></span><br><span class="line">    <span class="comment">##########################################################</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid syntax'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt; len(self.text) <span class="number">-1</span> :</span><br><span class="line">            self.current_char =<span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_char = self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">            self.advance()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span></span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">            result += self.current_char</span><br><span class="line">            self.advance()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> int(result)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#词法分析(分析之后形成一个个的token)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">                self.skip_whitespace()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment">#识别整数</span></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isdigit():</span><br><span class="line">                <span class="keyword">return</span> Token(INTEGER, self.integer() )</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 识别是否为+ - 运算符号</span></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'+'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'-'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line"></span><br><span class="line">            self.error()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    <span class="comment">##########################################################</span></span><br><span class="line">    <span class="comment">#               Parser / Interpreter code                #</span></span><br><span class="line">    <span class="comment">##########################################################</span></span><br><span class="line">    <span class="comment">#比较当前的token的类型与传来的类型是否相同</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.currrent_token.type == token_type:</span><br><span class="line">            self.currrent_token = self.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#返回一个整型的token的value</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">        token = self.currrent_token</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        <span class="keyword">return</span> token.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.currrent_token = self.get_next_token()</span><br><span class="line"></span><br><span class="line">        result = self.term()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.currrent_token.type <span class="keyword">in</span> (PLUS , MINUS):</span><br><span class="line">            <span class="comment">#循环是为了算不止一次的加or减法，从而达到混合运算的目的</span></span><br><span class="line">            token = self.currrent_token</span><br><span class="line">            <span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">                self.eat(PLUS)</span><br><span class="line">                result = result + self.term()</span><br><span class="line">            <span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">                self.eat(MINUS)</span><br><span class="line">                result = result - self.term()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># To run under Python3 replace 'raw_input' call</span></span><br><span class="line">            <span class="comment"># with 'input'</span></span><br><span class="line">            text = input(<span class="string">'calc&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        interpreter = Interpreter(text)</span><br><span class="line">        result = interpreter.expr()</span><br><span class="line">        print(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>将以上代码保存到名为 <code>calc3.py</code> 中，或者直接从 <a href="https://github.com/rspivak/lsbasi/blob/master/part3/calc3.py" target="_blank" rel="noopener">GitHub</a> 上下载。试一试。亲眼看一下 它可以处理之前展示给你的句法图中包含的算术表达式规则。</p><h2 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h2><ol><li>输入字符串表达式（如“2+8-6+1”)，存入变量text中</li><li>将text进行词法分析，执行此功能的是<code>get_next_token()</code>函数，词法分析会生成一个个的token</li><li>然后对词法分析之后的token按照规定的语法，进行语法分析，相应函数为<code>expr()</code></li><li>最后输出结果</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Let&#39;s Build A Simple Interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3、布尔逻辑和逻辑门</title>
      <link href="/archives/87ef.html"/>
      <url>/archives/87ef.html</url>
      
        <content type="html"><![CDATA[<p>计算机最早的是机电设备，一般使用十进制计数，比如用齿轮数来代表十进制。但是其实只用开/关两种状态已经足够表示信息了，将其称为<strong>二进制（Binary）</strong>。</p><a id="more"></a><p>在计算机中，当电流流过时，为闭合状态，表示true（1），当没有电流流过时，为断开状态，表示false（0）。但是其实晶体管可以不只是开/关状态，还可以让不同大小的电流通过，一些早期电子计算机，通过对不同电流大小进行划分，可以使用三进制、五进制等等。但问题是，状态越多就越难区分信号，如果存在电噪音，可能就会使状态十分混乱。所以为了让信号更加清晰，可以只使用“开”和“关”两种状态。</p><p>另一个使用二进制的原因是，有一整个数学分支专门处理“真”和“假”，它已解决了所有法则和运算，即<strong>布尔代数（Boolean Algebra）</strong>。</p><h1 id="布尔代数（Boolean-Algebra）与逻辑门"><a href="#布尔代数（Boolean-Algebra）与逻辑门" class="headerlink" title="布尔代数（Boolean Algebra）与逻辑门"></a>布尔代数（Boolean Algebra）与逻辑门</h1><p>在布尔代数中，变量的值是true和false，能够对其进行逻辑操作。布尔代数中有三个<strong>基本操作：</strong>NOT、AND和OR。</p><h2 id="NOT-GATE"><a href="#NOT-GATE" class="headerlink" title="NOT GATE"></a>NOT GATE</h2><p><strong>NOT</strong>：把输出端（就像水龙头左边部分送水，它送电）接在上面的电极，如果打开输出，电流就可以流过，然后“接地”，输出就没有电流，所以输出是off。当输入关闭时，电流没法接地，就流过了输出，所以输出是on。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310011249234.png" alt="NOT GATE"></p><p>就像是水龙头一样：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310014800881.png" alt="水龙头关着"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310015120188.png" alt="水龙头开着"></p><p>​</p><p>​ <strong>NOT操作：</strong>把布尔值进行翻转，所以NOT操作的真值表为</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310011832488.png" alt="NOT 真值表"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310020424245.png" alt="NOT GATE的表示图"></p><h2 id="AND-GATE"><a href="#AND-GATE" class="headerlink" title="AND GATE"></a>AND GATE</h2><p><strong>AND</strong>：为了实现“AND 门”，我们需要2个晶体管连接在一起，这样有2个输入和1个输出。如果只打开A，不打开B，电流无法留到output，所以输出是false；如果只打开B，不打开A，也一样，电流无法留到output；只有当A、B都打开了，output才有电流。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310012335375.png" alt="image-20200310012335375"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310020520507.png" alt="AND GATE表示图"></p><h2 id="OR-GATE"><a href="#OR-GATE" class="headerlink" title="OR GATE"></a>OR GATE</h2><p><strong>OR</strong>：实现OR 门除了晶体管还需要额外的线将两个晶体管(transistor)并联起来，即得到OR GATE</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/v2-fda2d5cd50eb2f760f0a2ac72eb5efe5_720w.jpg" alt="OR GATE"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310020006112.png" alt="image-20200310020006112"></p><p>左侧电极为电源，下方两个电极分别表示两个输入，右侧电极为输出。只要任意一个输入开启，就能使得电源和输出电极接通，使得输出开启；当两个输入都关闭时，就使得电源和输出电极保持断开状态，使得输出保持关闭。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310020600225.png" alt="OR GATE表示图"></p><p>由此通过上方的三个组件（NOT门、AND门和OR门）可以构建出更加复杂的组件。另一个常见的布尔操作叫做<strong>异或操作</strong>。</p><h2 id="XOR-异或"><a href="#XOR-异或" class="headerlink" title="XOR(异或)"></a>XOR(异或)</h2><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310020826408.png" alt="XOR"></p><p>我们有两个输入，A和B，还有一个输出。先放一个OR门。因为OR和XOR的逻辑表很像，只有一个不同点就是：当两个输入都为true时，XOR输出false，而OR输出true。通过对AND操作真值表取反，再和OR操作真值表进行对比，可以发现，第二三行都为true，而第一四行结果不同，因此只要在这两个结果后面加个AND就能得到XOR的真值表。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>操作真值表：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310021526100.png" alt="XOR操作真值表"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310021854665.png" alt="NOT操作真值表"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/v2-eb0326d9127258653005333d2d1c59a6_720w.jpg" alt="AND操作真值表"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/v2-088dbb26ce45d8e512140426f6e3bb62_720w.jpg" alt="OR操作真值表"></p><p>对应的罗基本表示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200310022102365.png" alt="逻辑门的表示图"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学速成课 </tag>
            
            <tag> 布尔逻辑和逻辑门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let’s Build A Simple Interpreter 2</title>
      <link href="/archives/d57d.html"/>
      <url>/archives/d57d.html</url>
      
        <content type="html"><![CDATA[<p>If you learn only methods, you’ll be tied to your methods. But if you learn<br>principles, you can devise your own methods.</p><a id="more"></a><p>原文地址：<a href="https://ruslanspivak.com/lsbasi-part2/" target="_blank" rel="noopener">https://ruslanspivak.com/lsbasi-part2/</a></p><p>这是第二个版本V2.0，第二个版本较第一个版V1.0，它可以做到：</p><ol><li>处理输入字符串中任何位置的空白符</li><li>处理输入中的多位数</li><li>两个整数相减（版本V1.0中只有加法）</li></ol><p>下面先给出V2.0的新版计算器的源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, PLUS, MINUS, EOF = <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'MINUS'</span>, <span class="string">'EOF'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line"><span class="comment"># token type: 'INTEGER', 'PLUS', 'MINUS', or 'EOF'</span></span><br><span class="line">self.type  = type</span><br><span class="line"><span class="comment"># token value: non-negative integer value, '+', '-', or None</span></span><br><span class="line">self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""String representation of class instance</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Examples:</span></span><br><span class="line"><span class="string">    Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">    Token(PLUS, '+')</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">f'Token(<span class="subst">&#123;self.type&#125;</span>, <span class="subst">&#123;self.value&#125;</span>)'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">return</span> self.__str__()</span><br><span class="line"><span class="comment">##__repr__() 与 __str__() 的主要区别在于，前者在交互式步骤中显示结果，后者在 print 函数中显示结果。</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line"><span class="comment"># client string input, e.g. "3 + 5", "12 - 5", etc</span></span><br><span class="line">self.text = text</span><br><span class="line"><span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">self.pos  = <span class="number">0</span></span><br><span class="line"><span class="comment"># current token instance</span></span><br><span class="line">self.current_token = <span class="literal">None</span></span><br><span class="line">self.current_char  = self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">raise</span> Exception(<span class="string">'Error parsing input'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">########新增#######</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""Advance the 'pos' pointer and set the 'current_char' variable."""</span></span><br><span class="line">self.pos += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> self.pos &gt;= len(self.text):</span><br><span class="line">    self.current_char = <span class="literal">None</span>  <span class="comment"># Indicates end of input</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    self.current_char = self.text[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">    self.advance()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""Return a (multidigit) integer consumed from the input."""</span></span><br><span class="line">result = <span class="string">''</span></span><br><span class="line"><span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">    result += self.current_char</span><br><span class="line">    self.advance()</span><br><span class="line"><span class="keyword">return</span> int(result)</span><br><span class="line">  <span class="comment">##新增 完毕#####</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">apart into tokens.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">self.skip_whitespace()</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> self.current_char.isdigit():</span><br><span class="line"><span class="keyword">return</span> Token(INTEGER, self.integer())</span><br><span class="line">    <span class="keyword">if</span> self.current_char == <span class="string">'+'</span>:</span><br><span class="line">self.advance()</span><br><span class="line"><span class="keyword">return</span> Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line">    <span class="keyword">if</span> self.current_char == <span class="string">'-'</span>:</span><br><span class="line">self.advance()</span><br><span class="line"><span class="keyword">return</span> Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line"></span><br><span class="line">    self.error()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line"><span class="comment"># compare the current token type with the passed token</span></span><br><span class="line"><span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line"><span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line"><span class="comment"># otherwise raise an exception.</span></span><br><span class="line"><span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">    self.current_token = self.get_next_token()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    self.error()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""Parser / Interpreter</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">expr -&gt; INTEGER PLUS INTEGER</span></span><br><span class="line"><span class="string">expr -&gt; INTEGER MINUS INTEGER</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># set current token to the first token from the input</span></span><br><span class="line">self.current_token = self.get_next_token()</span><br><span class="line"></span><br><span class="line"><span class="comment"># we expect the current token to be an integer</span></span><br><span class="line">left = self.current_token</span><br><span class="line">self.eat(INTEGER)</span><br><span class="line"></span><br><span class="line"><span class="comment"># we expect the current token to be either a '+' or '-'</span></span><br><span class="line">op = self.current_token</span><br><span class="line"><span class="keyword">if</span> op.type == PLUS:</span><br><span class="line">    self.eat(PLUS)</span><br><span class="line"><span class="keyword">elif</span> op.type == MINUS:</span><br><span class="line">    self.eat(MINUS)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    self.error()</span><br><span class="line"></span><br><span class="line"><span class="comment"># we expect the current token to be an integer</span></span><br><span class="line">right = self.current_token</span><br><span class="line">self.eat(INTEGER)</span><br><span class="line"><span class="comment"># after the above call the self.current_token is set to</span></span><br><span class="line"><span class="comment"># EOF token</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># at this point either the INTEGER PLUS INTEGER or</span></span><br><span class="line"><span class="comment"># the INTEGER MINUS INTEGER sequence of tokens</span></span><br><span class="line"><span class="comment"># has been successfully found and the method can just</span></span><br><span class="line"><span class="comment"># return the result of adding or subtracting two integers,</span></span><br><span class="line"><span class="comment"># thus effectively interpreting client input</span></span><br><span class="line"><span class="keyword">if</span> op.type == PLUS:</span><br><span class="line">    result = left.value + right.value</span><br><span class="line"><span class="keyword">elif</span> op.type == MINUS:</span><br><span class="line">    result = left.value - right.value</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    self.error()</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># To run under Python3 replace 'raw_input' call with 'input'</span></span><br><span class="line">    text = input(<span class="string">'calc&gt; '</span>)</span><br><span class="line"><span class="keyword">except</span> EOFError:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">interpreter = Interpreter(text)</span><br><span class="line">result      = interpreter.expr()</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>把以上代码保存到名为 <code>calc2.py</code> 中，或者直接从 <a href="https://github.com/rspivak/lsbasi/blob/master/part2/calc2.py" target="_blank" rel="noopener">GitHub</a> 上下载。试一试。亲眼看一下 它可以按预期运行：它可以处理输入中的任何位置的空白符；它接受多位整数，除了整数相 加还可以处理整数相减。</p><p>下面可以再笔记本上次尝试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python calc2.py</span><br><span class="line">calc&gt; <span class="number">27</span> + <span class="number">3</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line">calc&gt; <span class="number">27</span> - <span class="number">7</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line">calc&gt;</span><br></pre></td></tr></table></figure><p>与<a href="http://ruslanspivak.com/lsbasi-part1/" target="_blank" rel="noopener">第一部分</a>相比代码的主要变化有：</p><ol><li><code>get_next_token</code> 方法做了一点重构。增加指针 <code>pos</code> 的逻辑被重构到了方法 <code>advance</code> 中。</li><li>增加了两个方法： <code>skip_whitespace</code> 用来忽略空白符， <code>integer</code> 用来处理输入中的多位整数。</li><li><code>expr</code> 方法在修改后，除了可以识别 INTEGER -&gt; PLUS -&gt; INTEGER 这个组合(phrase) 之外，还可以识别INTEGER -&gt; MINUS -&gt; INTEGER。而且在成功识别相应的组合后，也可以进行相应的加减操作。</li></ol><p>在<a href="http://ruslanspivak.com/lsbasi-part1/" target="_blank" rel="noopener">第一部分</a>你尝到了两个重要的概念，即 <strong>token</strong> 和 <strong>词法分析器</strong> 。今天我想聊一聊 <strong>lexeme</strong> 、 <strong>parsing</strong> 和 <strong>parser</strong> 。</p><p>你已经知道 token 了。但为了叙述方便，需要介绍一下 lexeme。什么是 lexeme？ lexeme 是组成 token 的一个字符序列。在下面的图片中是一些 token 和 lexeme 的例子， 希望它能把两者之间的关系表达清楚：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part2_lexemes.png" alt="img"></p><p>现在还记得 <code>expr</code> 方法吗？我以前说过这是真正解释算术表达式的地方。但在解释一个表达式之前，你需要知道它是哪种组合，比如相加或相减。这是 <code>expr</code> 方法本质上做的事： 它从 <code>get_next_token</code> 方法得到的 token 流中找到结构，然后解释它识别出的组合，产 生算术表达式的结果。</p><p>又到了做练习的时间了。</p><ol><li>扩展计算器以处理两个整数相乘</li><li>扩展计算器以处理两个整数相除</li><li>修改代码以使它可以解释包含任意个数字的加减操作，如“9 - 5 + 3 + 11”</li></ol><p>本节检测：</p><ol><li>什么是 lexeme？</li><li>在 token 流中找到结构的过程叫什么？或者这么问，在 token 流中识别出特定组合的过程叫什么？</li><li>解释器（编译器）做 parsing 工作的部分叫什么？</li></ol><hr><p><strong>梳理</strong>：</p><ol><li>首先输入一个表达式，如“3+9”，送给解释器<strong><code>Interpreter</code></strong></li><li>开始对这个表达式拆分成一个个的token，这一步叫做词法分析，由<strong>词法分析器</strong>(lexical analyzer)来完成。在本文中，函数<strong><code>get_next_token</code></strong>就相当于词法分析器。<ul><li>词法分析器<code>get_next_token</code>处理完之后的是一个个的<code>token(type , value)</code></li></ul></li><li>然后开始进行语法分析（由于本文中只实现了加法、减法），所以这里的语法分析就是分析：加、减法的表达式。执行这个步骤的是<strong><code>expr</code></strong>函数，其中<code>expr</code> 方法使用了辅助方法<strong><code>eat</code></strong>来验证传给token的类型与当前类型是否相匹配。与现有语法规则（即，加法规则和减法规则）不匹配，<code>eat</code>就会抛出异常。</li><li>语法分析完成之后，就直接得出算式的结果。（这也很符合解释器的特性嘛：边解释边执行，不会生成目标代码）</li></ol><p>其他的函数：</p><p><code>Interpreter</code></p><ul><li><code>error(self)</code>：当有错误的时候，就调用它</li><li><code>advance(self)</code>：增加指针pos的作用，即，将指向下一个token</li><li><code>skip_whitespace(self)</code>：跳过空格，V2.0新增加的功能</li><li><code>integer(self)</code>：为了可以算多位数的加减法。<ul><li>这里要注意：如3和233是两个整数类型的token，但是值得注意的是这篇文章中的token是按照输入的一串字符串（如“3+155”）每一个都当成一个token。也就是说本来155是一个token，但是从细节上看，在代码实现中155是被当成了三次“token”然后经过<code>integer</code>函数才形成了最终形体155这个token。</li></ul></li></ul><hr><p>在本系列的下一篇文章中你会扩展你的计算器来处理更复杂的算术表达式。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Let’s Build A Simple Interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let’s Build A Simple Interpreter 1</title>
      <link href="/archives/427485bf.html"/>
      <url>/archives/427485bf.html</url>
      
        <content type="html"><![CDATA[<hr><hr><p>为什么要你学解释器和编译器？这里有三条理由。</p><a id="more"></a><ol><li>要写一个解释器或编译器，你必须同时用到很多技术。编写一个解释器或编译器会帮助 你提高这些技能并且成为一个更好的软件开发者。而且，你将学到的这些技能在开发任 何软件时都有可能用到，而不仅仅是解释器或编译器。</li><li>你确实想要知道计算机如何工作。一般解释器和编译器看上去都像魔法一样。但你不应 该对这些魔法感到舒服。你想要揭开解释器和编译器的神秘面纱，理解它们如何工作并 控制所有一切。</li><li>你想要创造自己的编程语言或者领域特定语言。如果是这样，你就需要为这个语言创建 一个解释器或编译器。最近，创建新语言再度兴起。你几乎每天都可以看到一门新语言 的诞生：Elixir, Go, Rust 等。</li></ol><p>原文链接：<a href="https://ruslanspivak.com/lsbasi-part1/" target="_blank" rel="noopener">https://ruslanspivak.com/lsbasi-part1/</a></p><p>好了，但什么是<strong>解释器</strong>和<strong>编译器</strong>呢？</p><h1 id="解释器与编译器"><a href="#解释器与编译器" class="headerlink" title="解释器与编译器"></a>解释器与编译器</h1><p>解释器与编译器都是“高级语言与机器之间的翻译官”。都是将代码翻译成机器可以执行的二进制机器码，只不过在运行原理和翻译过程不同。</p><p>那它们的区别在于：</p><ul><li>编译器：先整体编译完，然后<strong>一次性</strong>执行。比如：C语言代码被编译成二进制代码（exe程序），在windows平台上执行。</li><li>解释器：解释一句后就提交计算机执行一句，即边解释边执行。比如php，postscritp，javascript就是典型的解释性语言。</li></ul><blockquote><p>用一个通俗的例子来讲：我们去饭馆吃饭，点了八菜一汤。<strong>编译器</strong>的方式就是厨师把所有的菜给你全做好了，一起给你端上来，至于你在哪吃，怎么吃，随便。<strong>解释器</strong>的方式就是厨师做好一个菜给你上一个菜，你就吃这个菜，而且必须在饭店里吃。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200309170643.png" alt="解释器与编译器的区别"></p><p>编译器与解释器的工作流程的差别：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20160918194226830.jpg" alt="编译器与解释器的工作流程的差别"></p><p>编译器与解释器的各自的特点：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/20200309171531.png" alt="各自特点"></p><h1 id="构造解释器V1-0"><a href="#构造解释器V1-0" class="headerlink" title="构造解释器V1.0"></a>构造解释器V1.0</h1><p>该系列文章的作者使用 Python 编写Pascal语言的解释器。</p><p>第一版V1.0，构造的计算器有诸多限制。如：</p><ul><li>只输入一位的数字</li><li>现阶段仅支持加法操作</li><li>输入中不允许有空白符</li></ul><p>这些约束使得构建一个计算器很简单，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Token types：</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, PLUS, EOF = <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'EOF'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line"><span class="comment"># token type: INTEGER, PLUS, or EOF</span></span><br><span class="line">self.type  = type</span><br><span class="line"><span class="comment"># token value: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, '+', or None</span></span><br><span class="line">self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""String representation of the class instance.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Examples:</span></span><br><span class="line"><span class="string">    Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">    Token(PLUS, '+')</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">'Token(&#123;type&#125;, &#123;value&#125;)'</span>.format(</span><br><span class="line">    type=self.type,</span><br><span class="line">    value=repr(self.value)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">return</span> self.__str__()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line"><span class="comment"># client string input, e.g. "3+5"</span></span><br><span class="line">self.text = text</span><br><span class="line"><span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">self.pos  = <span class="number">0</span></span><br><span class="line"><span class="comment"># current token instance</span></span><br><span class="line">self.current_token = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">raise</span> Exception(<span class="string">'Error parsing input'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">apart into tokens. One token at a time.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">text = self.text</span><br><span class="line"></span><br><span class="line"><span class="comment"># is self.pos index past the end of the self.text ?</span></span><br><span class="line"><span class="comment"># if so, then return EOF token because there no more</span></span><br><span class="line"><span class="comment"># input left to convert into tokens</span></span><br><span class="line"><span class="keyword">if</span> self.pos &gt; len(text) - <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get a character at the position self.pos and decide</span></span><br><span class="line"><span class="comment"># what token to create based on the single character</span></span><br><span class="line">current_char = text[self.pos]</span><br><span class="line"></span><br><span class="line"><span class="comment"># if the character is a digit then convert it to</span></span><br><span class="line"><span class="comment"># integer, create an INTEGER token, increment self.pos</span></span><br><span class="line"><span class="comment"># index to point to the next character after the digit,</span></span><br><span class="line"><span class="comment"># and return the INTEGER token</span></span><br><span class="line"><span class="keyword">if</span> current_char.isdigit():</span><br><span class="line">    token     = Token(INTEGER, int(current_char))</span><br><span class="line">    self.pos += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> token</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> current_char == <span class="string">'+'</span>:</span><br><span class="line">    token     = Token(PLUS, current_char)</span><br><span class="line">    self.pos += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> token</span><br><span class="line"></span><br><span class="line">self.error()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line"><span class="comment"># compare the current token type with the passed token</span></span><br><span class="line"><span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line"><span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line"><span class="comment"># otherwise raise an exception.</span></span><br><span class="line"><span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">    self.current_token = self.get_next_token()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    self.error()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""expr -&gt; INTEGER PLUS INTEGER"""</span></span><br><span class="line"><span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">self.current_token = self.get_next_token()</span><br><span class="line"></span><br><span class="line"><span class="comment"># we expect the current token to be a single-digit integer</span></span><br><span class="line">left = self.current_token</span><br><span class="line">self.eat(INTEGER)</span><br><span class="line"></span><br><span class="line"><span class="comment"># we expect the current token to be a '+' token</span></span><br><span class="line">op = self.current_token</span><br><span class="line">self.eat(PLUS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># we expect the current token to be a single-digit integer</span></span><br><span class="line">right = self.current_token</span><br><span class="line">self.eat(INTEGER)</span><br><span class="line"><span class="comment"># after the above call the self.current_token is set to</span></span><br><span class="line"><span class="comment"># EOF token</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># at this point INTEGER PLUS INTEGER sequence of tokens</span></span><br><span class="line"><span class="comment"># has been successfully found and the method can just</span></span><br><span class="line"><span class="comment"># return the result of adding two integers, thus</span></span><br><span class="line"><span class="comment"># effectively interpreting client input</span></span><br><span class="line">result = left.value + right.value</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># To run under Python3 replace 'raw_input' call with 'input'</span></span><br><span class="line">    text = input(<span class="string">'calc&gt; '</span>)</span><br><span class="line"><span class="keyword">except</span> EOFError:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">interpreter = Interpreter(text)</span><br><span class="line">result = interpreter.expr()</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>把以上代码保存到名为 <code>calc1.py</code> 中，或者直接从 <a href="https://github.com/rspivak/lsbasi/blob/master/part1/calc1.py" target="_blank" rel="noopener">GitHub</a> 上下载。在你开始仔细研究代 码之前，在命令行上运行这个计算器并看它实现运行。把玩一下！下面是在我笔记本上的一 次尝试（如果你想在 Python3 下运行，就需要把 <code>raw_input</code> 替换为 input）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ python calc1.py</span><br><span class="line">calc&gt; 3+4</span><br><span class="line">7</span><br><span class="line">calc&gt; 3+5</span><br><span class="line">8</span><br><span class="line">calc&gt; 3+9</span><br><span class="line">12</span><br><span class="line">calc&gt;</span><br></pre></td></tr></table></figure><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>假设我们在命令行输入一个表达式“3+5”。你的解释器得到一个字符串 “3+5”。为了使解释器真正理解如何处理这个字符串，需要先把输入的 “3+5” 拆分成被叫做 <strong>token</strong> 的部件。</p><blockquote><p><strong>词法分析</strong>：（<strong>lexical analysis</strong>，简称<strong>lexer</strong>，亦称<strong>scanner</strong> 或 <strong>tokenizer</strong>）</p><p>​ 词法分析也称为 <strong>分词</strong> ，此阶段编译器从左向右扫描源文件，将其字符流分割成一个个的 <strong>词</strong> （ <strong>token</strong> 、 <strong>记号</strong> ，后文中将称为 <strong>token</strong> ）。</p><p><strong>Token</strong>：</p><p>​ 所谓 <strong>token</strong> ，就是源文件中不可再进一步分割的一串字符，类似于英语中单词，或汉语中的词。</p></blockquote><p>这里的 <strong>token</strong> 就是一个有类型的值的对象（即，token还存着值的类型）。例如对于字符串“3”来说，token 类型为 <code>INTEGER</code> ， 相应的值是整数 3 。</p><p>解释器<code>Interpreter</code>要做的第一步就是读取输入的字符串并把他转化成 token <strong>流</strong>。解释器中做这个工作的部分被称为 <strong>词法分析器</strong>(lexical analyzer)，简称 <strong>lexer</strong> 。也可以称它为： <strong>scanner</strong> 或 <strong>tokenizer</strong> 。他们的含义是一样的：表示解释器或编译器中将输入的字符串转化为 token 流的部分。</p><p>那是如何转化为token流呢？</p><ul><li>解释器 <code>Interpreter</code>中的 <code>get_next_token</code> 方法就是你的词法分析器。你每次调用它，就会从输入到解释器的字符流中得到下一个 token。让我们仔细看一下这个方法，看看它是怎么把字符转化 为 token 的。输入被存放在变量 <code>text</code> 中，它保存了输入的字符串， <code>pos</code> 是指向该字符串的一个索引（把字符串看作是一个字符数组）。 <code>pos</code> 的初值被设为 0, 指向字符‘3’。 该方法首先检查该字符是不是数字，若是数字，就递增 <code>pos</code> 并返回一个类型为 <code>INTEGER</code> 值 为整数 3 的 token：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part1_lexer1-1583746666076.png" alt="img"></p><p>现在 <code>pos</code> 指向了 <code>text</code> 中的字符‘+’，下次你调用这个方法时，它会先测试 <code>pos</code> 位 置的字符是否是数字，然后再测试它是否是加号，此时它是加号。这样该方法就递增 <code>pos</code> 并返回一个类型为 <code>PLUS</code> 值为‘+’的 token：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part1_lexer2.png" alt="img"></p><p>现在 <code>pos</code> 指向了字符‘5’。当你再次调用 <code>get_next_token</code> 时，它会检查 <code>pos</code> 位置 是否是一个数字，此时是的，因此它递增 <code>pos</code> 并返回一个类型为 <code>INTEGER</code> 值为‘5’的 token：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part1_lexer3.png" alt="img"></p><p>现在索引 <code>pos</code> 越过了字符串“3+5”的末尾，接下来每次调用 <code>get_next_token</code> 方法都会 返回 <code>EOF</code> token：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_part1_lexer4.png" alt="img"></p><p>自己动手试试看看你的计算器的 lexer 组件怎么工作的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> calc1 <span class="keyword">import</span> Interpreter</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>interpreter = Interpreter(<span class="string">'3+5'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>interpreter.get_next_token()</span><br><span class="line">Token(INTEGER, <span class="number">3</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>interpreter.get_next_token()</span><br><span class="line">Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>interpreter.get_next_token()</span><br><span class="line">Token(INTEGER, <span class="number">5</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>interpreter.get_next_token()</span><br><span class="line">Token(EOF, <span class="literal">None</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>此时你的解释器已经可以从输入的字符流中获得 token 流了，解释器需要对它做点什么： 它需要从使用 lexer <code>get_next_token</code> 得到的字符流中找到结构。你的解释器期望从 流中找到如下的结构： INTEGER -&gt; PLUS -&gt; INTEGER. 即，它试着找到这样一个 token 序 列：整数后跟一个加号再跟一个整数。</p><p>负责查找和解释这个结构的方法是 <code>expr</code>. 这个方法验证一个 token 序列是否遵从期望的 token 序列，即 INTEGER -&gt; PLUS -&gt; INTEGER. 当确定遵从这个结构后，它就把 PLUS 左 边和右边 token 的值相加来生成结果，从而成功地解释了你传给解释器的算术表达式。</p><p><code>expr</code> 方法使用了辅助方法 <code>eat</code> 来验证传给 <code>eat</code> 的 token 类型与当前的 token 类 型相匹配。在匹配到传入的 token 类型后， <code>eat</code> 方法会取得下一个 token 并把它赋值 给变量 <code>current_token</code>, 这样实际上是“吃掉”了当前匹配的 token 并把想象中的 token 流中的指针向前移动了。如果 token 流中的结构不遵从期望的 INTEGER PLUS INTEGER 序 列， <code>eat</code> 方法就会抛出一个异常。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>回顾一下你的解释器为了对一个算术表达式求值都做了什么：</p><ol><li>解释器接<code>Interpreter</code>收一个输入字符串，假设为“3+5”</li><li>解释器调用了 <code>expr</code> 方法来从词法解析器 <code>get_next_token</code> 返回的 token 流中寻找一个结构。这个结构就是一个 <em>INTEGER PLUS INTEGER</em> 的形式。当确认了这个结构以后，它就使用把两个 INTEGER token 相加的方式来解释这个输入，因为此时解释器已经清楚 地知道它要做的就是把 3 和 5 两个整数相加。</li></ol><p>祝贺你。你刚刚学会了怎么构造你的第一个解释器！</p><p>现在是时候做此练习了。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/lsbasi_exercises2.png" alt="img"></p><p>你不会觉得你刚刚读了这篇文章就足够了，是吧？好了，自己动手做下面的练习：</p><ol><li>修改代码使得允许输入多位整数，例如“12+3”</li><li>增加一个跳过空白符的方法，使你的计算器可以处理包含空白符的输入如 “ 12 + 3”</li><li>修改代码使得它可以处理‘-’而非‘+’的情况</li></ol><p>检查你的理解。</p><ol><li>什么是解释器？</li><li>什么是编译器？</li><li>解释器和编译器的区别是什么？</li><li>什么是 token？</li><li>将输入拆分成 token 的过程叫什么？</li><li>解释器中做词法分析的部分叫什么？</li><li>解释器或编译器的这个部分还有什么其他常见的名字？</li></ol><p>相关文章链接：</p><p>编译器与解释器：<a href="https://www.liujiangblog.com/course/python/9" target="_blank" rel="noopener">https://www.liujiangblog.com/course/python/9</a></p><p>Let’s Build A Simple Interpreter. Part 1：<a href="https://feng-qi.github.io/2018/01/23/lets-build-a-simple-interpreter-part-01/" target="_blank" rel="noopener">https://feng-qi.github.io/2018/01/23/lets-build-a-simple-interpreter-part-01/</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Let’s Build A Simple Interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2、电子计算机</title>
      <link href="/archives/d84f.html"/>
      <url>/archives/d84f.html</url>
      
        <content type="html"><![CDATA[<p>这个系列的课程还是值得大家去看一看的。这个系列的视频叫《计算机科学速成课》。虽然叫速成课，我们也要做到心中有数，它肯定不是让你看了这些内容你就什么都知道了。这是科普性的视频。这个视频都是被翻译好的，再次感谢这些翻译者。</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>视频在B站上都有全集的，传送门：<a href="https://www.bilibili.com/video/av21376839" target="_blank" rel="noopener">https://www.bilibili.com/video/av21376839</a></p><p>在GitHub上的地址：<a href="https://github.com/1c7/crash-course-computer-science-chinese" target="_blank" rel="noopener">https://github.com/1c7/crash-course-computer-science-chinese</a></p><p>这门课总共有40节，每节课的标题为：</p><ol><li>计算机早期历史</li><li>电子计算</li><li>布尔逻辑与逻辑电路</li><li>二进制</li><li>算术逻辑单元</li><li>寄存器 &amp; 内存</li><li>中央处理器</li><li>指令和程序</li><li>高级 CPU 设计</li><li>编程史话</li><li>编程语言</li><li>编程原理：语句和函数</li><li>算法初步</li><li>数据结构</li><li>阿兰·图灵</li><li>软件工程</li><li>集成电路、摩尔定律</li><li>操作系统</li><li>内存 &amp; 储存介质</li><li>文件系统</li><li>压缩</li><li>命令行界面</li><li>屏幕 &amp; 2D 图形显示</li><li>冷战和消费主义</li><li>个人计算机革命</li><li>图形用户界面</li><li>3D 图形</li><li>计算机网络</li><li>互联网</li><li>万维网</li><li>网络安全</li><li>黑客与攻击</li><li>加密</li><li>机器学习与人工智能</li><li>计算机视觉</li><li>自然语言处理</li><li>机器人</li><li>计算机中的心理学</li><li>教育型科技</li><li>奇点，天网，计算机的未来</li></ol><h1 id="计算机早期历史"><a href="#计算机早期历史" class="headerlink" title="计算机早期历史"></a>计算机早期历史</h1><p>这一张图大致说明了计算机早期发展的历史。图片来源：请查看图片本身链接。</p><p>后面的课会较详细的讲解。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/5c2dbf8e0001443913279329.png" alt="计算机历史"></p><h1 id="电子计算机"><a href="#电子计算机" class="headerlink" title="电子计算机"></a>电子计算机</h1><h2 id="继电器"><a href="#继电器" class="headerlink" title="继电器"></a>继电器</h2><p>在1937年最大的机电计算机之一是哈佛的马克一号(Harvard Mark Ⅰ)，是IBM在1944年给二战的同盟国建造的。该机器的大脑(CPU的基础器件)是“<strong>继电器</strong>”。</p><ul><li><strong>继电器</strong>：是用电控制的机械开关，继电器里有根“控制线路”控制着电路的开关，“控制线路”连着一个线圈，当线圈通电时，会产生感应磁场，由此由此能够吸引上方的金属臂，从而闭合电路，得到高电平。它的<strong>性能：</strong>1940年一个好的继电器1秒能翻转50次。哈佛马克一号1秒能做3次加减法运算，一次乘法需要6秒，除法需要15秒，三角函数需要一分钟以上。它的<strong>缺点：</strong>控制开关的金属臂是“有质量的”，因此无法快速开关。并且金属臂的反复移动就会存在磨损（任何会动的机械都会随时间磨损），哈佛马克一号平均每天需要更换一个故障继电器。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200308033154957.png" alt="继电器"></p><h2 id="真空管"><a href="#真空管" class="headerlink" title="真空管"></a>真空管</h2><p>在1904年，英国物理学家John Ambrose Fleming开发了新的电子组件——<strong>热电子管（Thermionic valve）</strong>。</p><ul><li><strong>热电子管</strong>：把两个电极装在一个气密的真空玻璃灯泡中。其中一个点击A可以加热，从而发射电子，称为<strong>热电子发射（Thermionic emission）</strong>；另一个电极B会吸引电子，来形成电流。但只有当电极B带正电时才能吸引电子，否则当电极B带负电荷或者中性电荷时，电子就无法跨越真空区。</li></ul><p>美国发明家Lee de Forest在此基础上加入了第三个控制电极。通过向控制电极施加正电荷，就能吸引电子，从而闭合电路；而通过施加负电荷，就能闭合电路。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/v2-94062a34bd644ef937224efaa2ebdf6c_720w.png" alt="img"></p><p><strong>特点：</strong></p><p><em>每秒可开闭数千次。</em></p><p><em>和继电器相同的是，可以通过一个控制线路来控制断开或闭合电路，并且真空管内没有会动的组件，因此存在更少的磨损。</em></p><p><em>比较脆弱，会像灯泡一样烧坏，并且体积比较大。</em></p><p><strong>真空管的出现，标志着计算机从机电转向电子</strong>，电子数值积分计算机ENIAC，在1946年于宾夕法尼亚大学设计制造，这是世上第一个真正的通用可编程电子计算机，每秒可执行5000次十位加减法。但是由于存在大量的真空管，因此ENIAC运行半天左右就会出现一次故障。</p><h2 id="晶体管"><a href="#晶体管" class="headerlink" title="晶体管"></a>晶体管</h2><p><strong>晶体管：</strong>类似于继电器和真空管，晶体管也是一个用于控制电路闭合断开的开关。晶体管有两个电极，这两个电极之间通过半导体材料隔开。控制线连接到一个“门”电极，通过改“门”的电荷，我们可以控制半导体的导电性，由此来控制电流是否流动。当控制线路通电时，两个电极接通，否则两个电极断开。</p><p><strong>特点：</strong></p><p><em>每秒可开关10000次。</em></p><p><em>相比玻璃制成的真空管，晶体管是固体的，并且体积远小于继电器和真空管。</em></p><p>第一个消费者可购买的，完全由晶体管构成的计算机是1957年发布的IBM 608，它有3000个晶体管，每秒执行4500次加减法，或80次左右的乘除法。</p><p>如今，计算机里的晶体管小于50nm，并且每秒可切换上百万次，工作几十年。很多晶体管和半导体开发在圣克拉拉谷，位于旧金山和圣河西之间，由于制造半导体最常见的材料是硅，由此这个地方被称为“硅谷”。并且William Shockley搬过去创建了肖克利半导体，里面的员工后来成立了仙童半导体，而这里面的员工后来创立了英特尔。</p><hr><p>所以，计算机的大脑基础单元的发展路径，可概括为：<strong>继电器-&gt;电子管-&gt;晶体管</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《计算机科学速成课》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo之 Yilia主题配置</title>
      <link href="/archives/460671de.html"/>
      <url>/archives/460671de.html</url>
      
        <content type="html"><![CDATA[<p>Yilia主题配置</p><a id="more"></a><h2 id="在左侧显示总文章数"><a href="#在左侧显示总文章数" class="headerlink" title="在左侧显示总文章数"></a>在左侧显示总文章数</h2><p>将themes\yilia\layout_partial\left-col.ejs文件的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;nav <span class="class"><span class="keyword">class</span></span>=<span class="string">"header-menu"</span>&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">    &lt;% <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> theme.menu)&#123; %&gt;</span><br><span class="line">        &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%- url_for(theme.menu[i]) %&gt;"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">i</span> %&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;%&#125;%&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/u</span>l&gt;</span><br><span class="line">&lt;<span class="regexp">/nav&gt;</span></span><br></pre></td></tr></table></figure><p>后面加上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;nav&gt;</span><br><span class="line">    总文章数 &lt;%=site.posts.length%&gt;</span><br><span class="line">&lt;<span class="regexp">/nav&gt;</span></span><br></pre></td></tr></table></figure><h2 id="字数、阅读时长添加"><a href="#字数、阅读时长添加" class="headerlink" title="字数、阅读时长添加"></a>字数、阅读时长添加</h2><p>首先安装 <a href="https://github.com/willin/hexo-wordcount" target="_blank" rel="noopener">hexo-wordcount</a></p><p>使用如下命令安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-wordcount  <span class="comment">#如果安装了cnpm，可换为cnpm安装</span></span><br></pre></td></tr></table></figure><blockquote><p>Node 版本7.6.0之前,请安装 2.x 版本 (Node.js v7.6.0 and previous)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copynpm install hexo-wordcount@2 --save</span><br></pre></td></tr></table></figure><p>然后在 <code>themes\yilia\layout\_partial\left-col.ejs</code>中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copy&lt;nav&gt;</span><br><span class="line">    总字数 &lt;span class&#x3D;&quot;post-count&quot;&gt;&lt;%&#x3D; totalcount(site, &#39;0,0.0a&#39;) %&gt;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;nav&gt;</span><br></pre></td></tr></table></figure><p>添加位置在如下代码的下面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copy&lt;nav&gt;</span><br><span class="line">    总文章数 &lt;%&#x3D;site.posts.length%&gt;</span><br><span class="line">&lt;&#x2F;nav&gt;</span><br></pre></td></tr></table></figure><p>编辑 <code>themes\yilia\layout\_partial\article.ejs</code></p><p>在header下面加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div align&#x3D;&quot;left&quot; class&#x3D;&quot;post-count&quot;&gt;   &lt;!--其中align可以在：right、center、left--&gt;</span><br><span class="line">    字数：&lt;%&#x3D; wordcount(post.content) %&gt;字 | 预计阅读时长：&lt;%&#x3D; min2read(post.content) %&gt;分钟</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>即可显示单篇字数和预计阅读时长。</p><h2 id="置顶文章"><a href="#置顶文章" class="headerlink" title="置顶文章"></a>置顶文章</h2><p><strong>安装插件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure><p><strong>配置置顶标准</strong></p><p>打开：/themes/*/layout（/_macro）/post.ejs 直接在最前面加入以下代码即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (page.top) &#123; %&gt;</span><br><span class="line">  &lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">"fa fa-thumb-tack"</span>&gt;&lt;<span class="regexp">/i&gt;</span></span><br><span class="line"><span class="regexp">  &lt;font color=7D26CD&gt;置顶&lt;/</span>font&gt;</span><br><span class="line">  &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"post-meta-divider"</span>&gt;|&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;% &#125; %&gt;</span></span><br></pre></td></tr></table></figure><p><strong>配置文章</strong></p><p>然后在需要置顶的文章的Front-matter中加上top选项即可 top后面的数字越大，优先级越高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 2019</span><br><span class="line">date: 2019-02-14 16:10:03</span><br><span class="line">top: 5</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h2 id="增加不蒜子统计"><a href="#增加不蒜子统计" class="headerlink" title="增加不蒜子统计"></a>增加不蒜子统计</h2><p>利用这个统计，可以知道你博客的访问量。</p><p><strong>安装不蒜子脚本</strong>：</p><p>在themes\yilia\layout\ _partial\after-footer.ejs最后添加：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="单篇文章点击量："><a href="#单篇文章点击量：" class="headerlink" title="单篇文章点击量："></a>单篇文章点击量：</h3><p>在themes/yilia/layout/_partial/article.ejs中 在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%- partial(&#39;post&#x2F;title&#39;, &#123;class_name: &#39;article-title&#39;&#125;) %&gt;</span><br></pre></td></tr></table></figure><p>后面插入如下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--显示阅读次数--&gt;</span><br><span class="line">&lt;% <span class="keyword">if</span> (!index &amp;&amp; post.comments)&#123; %&gt;</span><br><span class="line">  &lt;br/&gt;</span><br><span class="line">  &lt;a <span class="class"><span class="keyword">class</span></span>=<span class="string">"cloud-tie-join-count"</span> href=<span class="string">"javascript:void(0);"</span> style=<span class="string">"color:gray;font-size:14px;"</span>&gt;</span><br><span class="line">  &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"icon-sort"</span>&gt;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;span id="busuanzi_container_page_pv" style="color:#ef7522;font-size:14px;"&gt;</span></span><br><span class="line"><span class="regexp">            阅读数: &lt;span id="busuanzi_value_page_pv"&gt;&lt;/</span>span&gt;次 &amp;nbsp;&amp;nbsp;</span><br><span class="line">  &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>a&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line">&lt;!--显示阅读次数完毕--&gt;</span><br></pre></td></tr></table></figure><h2 id="增加版权声明"><a href="#增加版权声明" class="headerlink" title="增加版权声明"></a>增加版权声明</h2><p><strong>配置yilia</strong>：</p><p>在themes/yilia/layout/_partial/article.ejs中，标注的位置添加代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"article-entry"</span> itemprop=<span class="string">"articleBody"</span>&gt;</span><br><span class="line">  &lt;% <span class="keyword">if</span> (post.excerpt &amp;&amp; index)&#123; %&gt;</span><br><span class="line">    &lt;%- post.excerpt %&gt;</span><br><span class="line">    &lt;% <span class="keyword">if</span> (theme.excerpt_link) &#123; %&gt;</span><br><span class="line">      &lt;a <span class="class"><span class="keyword">class</span></span>=<span class="string">"article-more-a"</span> href=<span class="string">"&lt;%- url_for(post.path) %&gt;#more"</span>&gt;&lt;%= theme.excerpt_link %&gt; &gt;&gt;&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">    &lt;% &#125; %&gt;</span></span><br><span class="line"><span class="regexp">  &lt;% &#125; else &#123; %&gt;</span></span><br><span class="line"><span class="regexp">    &lt;%- post.content %&gt;</span></span><br><span class="line"><span class="regexp">  &lt;% &#125; %&gt;</span></span><br><span class="line"><span class="regexp">  &lt;-- 在此处添加代码--&gt; &lt;-- 在此处添加代码--&gt; &lt;-- 在此处添加代码--&gt; &lt;-- 在此处添加代码--&gt;</span></span><br><span class="line"><span class="regexp">  &lt;% if ((theme.reward_type === 2 || (theme.reward_type === 1 &amp;&amp; post.reward)) &amp;&amp; !index)&#123; %&gt;</span></span><br><span class="line"><span class="regexp">  &lt;div class="page-reward"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;a href="javascript:;" class="page-reward-btn tooltip-top"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="tooltip tooltip-east"&gt;</span></span><br></pre></td></tr></table></figure><p>在目录：themes/yilia/source-src/css中创建新文件：declare.scss，并添加如下CSS代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.declare &#123;</span><br><span class="line">    background-color: #eaeaea;</span><br><span class="line">    margin-top: <span class="number">2</span>em;</span><br><span class="line">    border-left: 3px solid #ff1700;</span><br><span class="line">    padding: <span class="number">.5</span>em <span class="number">1</span>em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，为themes/yilia/source-src/css/main.scss，添加如下代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">"./declare"</span>;</span><br></pre></td></tr></table></figure><p><strong>配置显示</strong>：</p><p>现在该让其显示出来，在themes/yilia/_config.yml，中加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#版权基础设定：0-关闭声明； 1-文章对应的md文件里有declare: true属性，才有版权声明； 2-所有文章均有版权声明</span><br><span class="line">#当前应用的版权协议地址。</span><br><span class="line">#版权协议的名称</span><br><span class="line">#版权协议的Logo</span><br><span class="line"></span><br><span class="line">declare_type: 1</span><br><span class="line">licensee_url: https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by-nc-sa&#x2F;4.0&#x2F;</span><br><span class="line">licensee_name: &#39;知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议&#39;</span><br><span class="line">licensee_img: https:&#x2F;&#x2F;i.creativecommons.org&#x2F;l&#x2F;by-nc-sa&#x2F;4.0&#x2F;88x31.png</span><br></pre></td></tr></table></figure><p>然后在需要进行版权声明的文章的md文件头部，设置属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare:true</span><br></pre></td></tr></table></figure><p>即可。</p><h2 id="在主页时文章显示摘要"><a href="#在主页时文章显示摘要" class="headerlink" title="在主页时文章显示摘要"></a>在主页时文章显示摘要</h2><p>在你 MD 格式文章正文插入 <code>&lt;!-- more --&gt;</code> 即可，只会显示它之前的，此后的就不显示，点击文章标题，，或者点击下面的<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200302193556416.png" alt="image-20200302193556416">按钮，即可进入全文。</p><p>如：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200302180731556.png" alt="image-20200302180731556"></p><h2 id="文章显示目录"><a href="#文章显示目录" class="headerlink" title="文章显示目录"></a>文章显示目录</h2><p>增加文章目录 TOC ( table of content )，方便阅读文章，在 <code>themes/yilia/_config.yml</code> 中进行配置 <code>toc: 2</code> 即可，它会将你 Markdown 语法的标题，生成目录，目录查看在右下角。</p><h2 id="头像设置"><a href="#头像设置" class="headerlink" title="头像设置"></a>头像设置</h2><p><strong>设置存放位置</strong>：</p><p>头像/图标图片的存放位置是<code>/themes/yilia/source/</code>下任意位置，可以自己新建一个文件夹存放，我存放在<code>assets</code>文件夹下。（我之前放在img中，但是不知道为什么，它就显示不出来）</p><p><strong>配置修改</strong>：</p><p>配置文件为<code>/themes/yilia/_config.yml</code>。设置头像为配置文件中<code>avatar</code>一项，设置图标为配置文件中<code>favicon</code>一项，设置路径的根目录为<code>/themes/yilia/source/</code>。例如，我的头像存放的地址是<code>/themes/yilia/source/assets/me.png</code>，设置则为<code>avatar: /assets/me.png</code>。（图标同理）</p><h2 id="提交网页"><a href="#提交网页" class="headerlink" title="提交网页"></a>提交网页</h2><h3 id="sitemap方式提交网页"><a href="#sitemap方式提交网页" class="headerlink" title="sitemap方式提交网页"></a>sitemap方式提交网页</h3><p>在 Hexo 根目录打开命令行工具，执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;your_hexo_path&#125;&#x2F;public</span><br></pre></td></tr></table></figure><p>文件夹，可以看到文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sitemap.xml</span><br></pre></td></tr></table></figure><p>sitemap 的初衷是给搜索引擎看的，为了提高搜索引擎对自己站点的收录效果，我们最好手动到 google 和百度等搜索引擎提交 sitemap.xml。</p><p>baidu提交网址：<a href="https://ziyuan.baidu.com/?castk=LTE%3D" target="_blank" rel="noopener">https://ziyuan.baidu.com/?castk=LTE%3D</a></p><h3 id="百度自动推送方式提交网页"><a href="#百度自动推送方式提交网页" class="headerlink" title="百度自动推送方式提交网页"></a>百度自动推送方式提交网页</h3><p>在本机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;博客根目录&gt;&#x2F;themes&#x2F;yilia&#x2F;layout&#x2F;_partial</span><br></pre></td></tr></table></figure><p>目录下打开article.ejs文件，定位到如下这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">        var sUrl &#x3D; url.replace(&#x2F;index\.html$&#x2F;, &#39;&#39;);</span><br><span class="line">        sUrl &#x3D; &#x2F;^(http:|https:)\&#x2F;\&#x2F;&#x2F;.test(sUrl) ? sUrl : &#39;https:&#39; + sUrl;</span><br><span class="line">      %&gt;</span><br></pre></td></tr></table></figure><p>在它前面加上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!- 百度自动推送方式提交 --&gt;</span><br><span class="line">&lt;% if (1)&#123; %&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">  (function()&#123;</span><br><span class="line">      var bp &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">      var curProtocol &#x3D; window.location.protocol.split(&#39;:&#39;)[0];</span><br><span class="line">      if (curProtocol &#x3D;&#x3D;&#x3D; &#39;https&#39;) &#123;</span><br><span class="line">          bp.src &#x3D; &#39;https:&#x2F;&#x2F;zz.bdstatic.com&#x2F;linksubmit&#x2F;push.js&#39;;</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">          bp.src &#x3D; &#39;http:&#x2F;&#x2F;push.zhanzhang.baidu.com&#x2F;push.js&#39;;</span><br><span class="line">      &#125;</span><br><span class="line">      var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0];</span><br><span class="line">      s.parentNode.insertBefore(bp, s);</span><br><span class="line">  &#125;)();</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line">&lt;!- 百度自动推送方式提交结束 --&gt;</span><br></pre></td></tr></table></figure><p>即完成了新增博客文章页面（不包括其他页面）的自动推送方式提交。</p><h2 id="链接提交"><a href="#链接提交" class="headerlink" title="链接提交"></a>链接提交</h2><p>百度站长平台的链接提交方式分为自动提交和手动提交两种，此处只讲自动提交，手动提交按照要求操作即可。</p><h3 id="主动推送"><a href="#主动推送" class="headerlink" title="主动推送"></a>主动推送</h3><h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><p>主动推送最为快速的提交方式，是被百度收录最快的推送方式。主动推送可以通过安装插件实现：</p><p><strong>首先安装插件：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-baidu-url-submit --save</span><br></pre></td></tr></table></figure><p>修改站点根目录下的配置文件_config.yml，添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">baidu_url_submit:</span><br><span class="line">  count: 20 ## 提交最新的20个链接</span><br><span class="line">  host: www.dongshuyan.com ## 百度站长平台中注册的域名</span><br><span class="line">  token:  ## 16位准入秘钥</span><br><span class="line">  path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里</span><br></pre></td></tr></table></figure><p><strong>准入秘钥获取</strong>:</p><p>在如下图的网址中：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/e8d810a8-af7b-40ce-8a7d-1db0e61a8a14-3316715.jpg" alt="img"></p><p>下拉，找到这里：<br><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/a94c8872-d402-4ce3-afc2-ea2705e95aeb-3316715.jpg" alt="img"><br>点击进去就是准入秘钥。</p><p><strong>检查</strong>:</p><p>其次，记得查看根目录下的_config.yml文件中url的值， 必须包含是百度站长平台注册的域名， 比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;</span><br><span class="line">url: http:&#x2F;&#x2F;dongshuyan.com</span><br><span class="line">root: &#x2F;</span><br><span class="line">permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure><p><strong>最后，加入新的deployer</strong></p><p>最后，加入新的deployer:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- type: git ## 这是我原来的deployer</span><br><span class="line">  repo:</span><br><span class="line">  branch:</span><br><span class="line">- type: baidu_url_submitter ## 添加这里内容即可</span><br></pre></td></tr></table></figure><p>这里的”-“,必不可少！ 否则报错。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>其主动推送的实现原理如下：<br>新链接的产生， hexo generate 会产生一个文本文件，里面包含最新的链接<br>新链接的提交， hexo deploy 会从上述文件中读取链接，提交至百度搜索引擎</p><h3 id="自动推送"><a href="#自动推送" class="headerlink" title="自动推送"></a>自动推送</h3><p>装自动推送JS代码的网页，在页面被访问时，页面URL将立即被推送给百度。</p><p>修改主题目录下的layout/post.ejs文件，末尾添加自动推送代码，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">(function()&#123;</span><br><span class="line">    var bp &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">    var curProtocol &#x3D; window.location.protocol.split(&#39;:&#39;)[0];</span><br><span class="line">    if (curProtocol &#x3D;&#x3D;&#x3D; &#39;https&#39;) &#123;</span><br><span class="line">        bp.src &#x3D; &#39;https:&#x2F;&#x2F;zz.bdstatic.com&#x2F;linksubmit&#x2F;push.js&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        bp.src &#x3D; &#39;http:&#x2F;&#x2F;push.zhanzhang.baidu.com&#x2F;push.js&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0];</span><br><span class="line">    s.parentNode.insertBefore(bp, s);</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>出处：(<a href="http://dongshuyan.com/2019/05/24/hexo博客注意事项/#14-Hexo添加百度统计" target="_blank" rel="noopener">http://dongshuyan.com/2019/05/24/hexo博客注意事项/#14-Hexo添加百度统计</a>)</p><h2 id="添加百度统计和谷歌统计代码"><a href="#添加百度统计和谷歌统计代码" class="headerlink" title="添加百度统计和谷歌统计代码"></a>添加百度统计和谷歌统计代码</h2><h3 id="百度统计"><a href="#百度统计" class="headerlink" title="百度统计"></a>百度统计</h3><p>首先打开<a href="https://ziyuan.baidu.com/site/index" target="_blank" rel="noopener">百度站长平台</a>，注册账户。</p><p>然后登陆 百度统计》管理》新增站点。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://gitee.com/longlongqin/hexo_blog_map_bed/raw/master/img/image-20200303193303556.png" alt="image-20200303193303556"></p><p>然后复制生成的代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> _hmt = _hmt || [];</span></span><br><span class="line"><span class="actionscript">(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> hm = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span></span><br><span class="line"><span class="actionscript">  hm.src = <span class="string">"https://hm.baidu.com/hm.js?这里是你的专属字符串"</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> s = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"script"</span>)[<span class="number">0</span>]; </span></span><br><span class="line">  s.parentNode.insertBefore(hm, s);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这一段代码，最重要的就是你那段专属的字符串。</p><p><strong>开始配置：</strong></p><p>首先，打开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">themes&#x2F;yilia&#x2F;_config.yml</span><br></pre></td></tr></table></figure><p>里面</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">baidu_analytics:</span> <span class="string">''</span></span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">baidu_analytics:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>然后，打开：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">themes/yilia/layout/_partial/baidu-analytics.ejs</span><br></pre></td></tr></table></figure><p>你会看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (theme.baidu_analytics)&#123; %&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var _hmt &#x3D; _hmt || [];</span><br><span class="line">(function() &#123;</span><br><span class="line">var hm &#x3D; document.createElement(&quot;script&quot;);</span><br><span class="line">hm.src &#x3D; &quot;https:&#x2F;&#x2F;hm.baidu.com&#x2F;hm.js?&lt;%&#x3D; theme.baidu_analytics %&gt;&quot;;</span><br><span class="line">var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0]; </span><br><span class="line">s.parentNode.insertBefore(hm, s);</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>这里，我们直接用你的<code>专属字符串</code>去替换<code>&lt;%= theme.baidu_analytics %&gt;</code>就行了。替换后为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (theme.baidu_analytics)&#123; %&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var _hmt &#x3D; _hmt || [];</span><br><span class="line">(function() &#123;</span><br><span class="line">var hm &#x3D; document.createElement(&quot;script&quot;);</span><br><span class="line">hm.src &#x3D; &quot;https:&#x2F;&#x2F;hm.baidu.com&#x2F;hm.js?你的专属字符串&quot;;</span><br><span class="line">var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0]; </span><br><span class="line">s.parentNode.insertBefore(hm, s);</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><h3 id="谷歌统计"><a href="#谷歌统计" class="headerlink" title="谷歌统计"></a>谷歌统计</h3><p>参考：<a href="http://yansheng836.coding.me/article/eda67a25.html" target="_blank" rel="noopener">http://yansheng836.coding.me/article/eda67a25.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Yilia主题配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo之Matery主题配置</title>
      <link href="/archives/514b.html"/>
      <url>/archives/514b.html</url>
      
        <content type="html"><![CDATA[<p>最近的三天一直在折腾hexo框架的博客，先是使用yilia主题，但是用来一天觉得我不适合这个主题，随即看到了matery主题。</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E4%B9%8BMatery%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/qqpyimg1583400714.jpg" alt="img"></p><p>今天又折腾了白天一天时间，我这个是直接克隆的<a href="https://sunhwee.com/about" target="_blank" rel="noopener">hongweiの博客</a>，这是一个大佬呀，还要多多向他学习。</p><p>然后，只把一些简单的配置弄好了。现在梳理一下：</p><p><strong>已完成的配置：</strong></p><ul><li><input checked disabled type="checkbox"><p>404页面</p></li><li><input checked disabled type="checkbox"><p>简历</p></li><li><input checked disabled type="checkbox"><p>建站时间</p></li><li><input checked disabled type="checkbox"><p>设置个人域名（已购买域名，单还需要审核，明天再去弄。）</p></li><li><input checked disabled type="checkbox"><p>不蒜子设置</p></li></ul><ul><li><input checked disabled type="checkbox"> 添加评论插件</li><li><input checked disabled type="checkbox"> 网站SEO优化</li><li><input disabled type="checkbox"> 百度收录站点 1.验证网站所有权</li><li><input disabled type="checkbox"> 谷歌收录站点</li><li><input checked disabled type="checkbox"> 优化你的URL</li><li><input disabled type="checkbox"> 添加代码块复制功能</li><li><input disabled type="checkbox"> 添加文章更新时间功能</li></ul><p><strong>非必要配置（已经取消）：</strong></p><ul><li><input checked disabled type="checkbox"><p>添加网易云音乐BGM</p></li><li><input checked disabled type="checkbox"><p>添加鼠标点击烟花爆炸效果</p></li><li><input checked disabled type="checkbox"><p>添加页面樱花飘落效果</p></li><li><input checked disabled type="checkbox"><p>添加鼠标点击文字特效</p></li><li><input checked disabled type="checkbox"><p>添加页面雪花飘落动效</p></li><li><input checked disabled type="checkbox"><p>优化网站加载速度</p></li><li><input checked disabled type="checkbox"><p>数学公式渲染和代码高亮</p></li><li><input disabled type="checkbox"><p>其他搜索引擎收录你的站点</p></li><li><input disabled type="checkbox"><p>添加动漫人物</p></li><li><input disabled type="checkbox"><p>增加emoji支持</p></li><li><input disabled type="checkbox"><p>添加博客动态标签</p></li><li><input disabled type="checkbox"><p>添加博客天气插件</p></li><li><input checked disabled type="checkbox"><p>GitHub&amp;coding pages双部署</p></li><li><input checked disabled type="checkbox"><p>修复Valine评论的头像不显示问题</p></li></ul><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h2><p>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 <a href="https://github.com/ele828/hexo-prism-plugin" target="_blank" rel="noopener">hexo-prism-plugin</a> 的 Hexo 插件来做代码高亮，安装命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -S hexo-prism-plugin</span><br></pre></td></tr></table></figure><p>然后，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并新增 <code>prism</code> 插件相关的配置，主要配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">prism_plugin:</span></span><br><span class="line">  <span class="attr">mode:</span> <span class="string">'preprocess'</span>    <span class="comment"># realtime/preprocess</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">'tomorrow'</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">false</span>    <span class="comment"># default false</span></span><br><span class="line">  <span class="attr">custom_css:</span></span><br></pre></td></tr></table></figure><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><h2 id="1、Cannot-set-property-39-lastIndex-39-of-undefined"><a href="#1、Cannot-set-property-39-lastIndex-39-of-undefined" class="headerlink" title="1、Cannot set property &#39;lastIndex&#39; of undefined"></a>1、<code>Cannot set property &#39;lastIndex&#39; of undefined</code></h2><p>运行<code>hexo g</code>出现Cannot set property ‘lastIndex’ of undefined</p><p>解决方法：修改配置文件的 _config.yml，注意不是主题里面的配置文件，把 <code>auto_detect</code> 设置为<code>false</code> 即可。</p><h2 id="2、代码显示异常"><a href="#2、代码显示异常" class="headerlink" title="2、代码显示异常"></a>2、代码显示异常</h2><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E4%B9%8BMatery%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/image-20200307011749942.png" alt="image-20200307011749942"></p><p>解决方法：</p><ul><li>首先，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>。</li></ul><p>然后<code>hexo clean</code>&amp; <code>hexo g</code>&amp; <code>hexo s</code></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E4%B9%8BMatery%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/image-20200307012129958.png" alt="image-20200307012129958"></p><p>好了。</p><p><strong>注</strong>：作者给的解决方案比我这个要多一步，我在这里贴出来，供大家参考。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E4%B9%8BMatery%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/image-20200307012313539.png" alt="image-20200307012313539"></p><h2 id="3、目录定位内容有偏差"><a href="#3、目录定位内容有偏差" class="headerlink" title="3、目录定位内容有偏差"></a>3、目录定位内容有偏差</h2><p>我反复的去测试，后来发现，可能有两个原因会导致这个问题的出现：</p><ol><li><p>网页没有刷新完全的时候，点击目录他有可能不会跳转。</p><p><strong>解决方法</strong>：</p><ul><li>法一：等待网页刷新完全。</li><li>法二：手动的去停止网页的刷新（这个来的比较快一点，哈哈）</li></ul></li><li><p>你的文章的标题格式有问题，比如，我用Typora软件来写文章，这个软件就是所写即所得。但是这样你就不容易发现格式细节处的错误。</p><p><u>错误示范</u>：</p><p>我先写了一个一级标题，<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E4%B9%8BMatery%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/image-20200308024217913.png" alt="image-20200308024217913"></p><p>然后，我又点击引用，就变成这样了：<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E4%B9%8BMatery%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/image-20200308024438170.png" alt="image-20200308024438170">这种写法在Typora中，是不会认为它是一级标题的。</p><p>我们打开源码查看他的格式：<code>&gt; # 配置</code>。他的格式是这样的。就是这里<u>出错了</u>，在matery主题中这样写它仍然会识别成标题，然后就导致从这个标题开始后面的标题，在你点击这些标题的时候，它会定位错误。</p><p><strong>解决方法</strong>：我们一定要遵循Markdown格式的语法，一定要，一定要。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matery主题配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tsinghua_Online_Judge_练习</title>
      <link href="/archives/d4fa.html"/>
      <url>/archives/d4fa.html</url>
      
        <content type="html"><![CDATA[<h2 id="CG2017-PA1-1-Convex-Hull-凸包"><a href="#CG2017-PA1-1-Convex-Hull-凸包" class="headerlink" title="CG2017 PA1-1 Convex Hull (凸包)"></a>CG2017 PA1-1 Convex Hull (凸包)</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><hr><p>Description (描述)</p><p>After learning Chapter 1, you must have mastered the convex hull very well. Yes, convex hull is at the kernel of computational geometry and serves as a fundamental geometric structure. That’s why you are asked to implement such an algorithm as your first programming assignments.</p><p>Specifically, given a set of points in the plane, please construct the convex hull and output an encoded description of all the extreme points.</p><p>经过了第一章的学习，想必你对于凸包的认识已经非常深刻。是的，凸包是计算几何的核心问题，也是一种基础性的几何结构。因此你的第一项编程任务，就是来实现这样的一个算法。</p><p>具体地，对于平面上的任意一组点，请构造出对应的凸包，并在经过编码转换之后输出所有极点的信息。</p><p>Input (输入)</p><p>The first line is an integer <strong>n &gt; 0</strong>, i.e., the total number of input points.</p><p>The k-th of the following <strong>n</strong> lines gives the k-th point:</p><p>pk = (xk, yk), k = 1, 2, …, n</p><p>Both xk and yk here are integers and they are delimited by a space.</p><p>第一行是一个正整数首行为一个正整数<strong>n &gt; 0</strong>，即输入点的总数。</p><p>随后<strong>n</strong>行中的第k行给出第k个点：</p><p>pk = (xk, yk), k = 1, 2, …, n</p><p>这里，xk与yk均为整数，且二者之间以空格分隔。</p><p>Output (输出)</p><p>Let <strong>{ s1, s2, …, sh }</strong> be the indices of all the extreme points, <strong>h ≤ n</strong>. Output the following integer as your solution:</p><p>( s1 * s2 * s3 * … * sh * h ) mod (n + 1)</p><p>若 <strong>{ s1, s2, …, sh }</strong> 为所有极点的编号, <strong>h ≤ n</strong>，则作为你的解答，请输出以下整数：</p><p>( s1 * s2 * s3 * … * sh * h ) mod (n + 1)</p><p>Sample Input (输入样例)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line"></span><br><span class="line">10</span><br><span class="line">7 9</span><br><span class="line">-8 -1</span><br><span class="line">-3 -1</span><br><span class="line">1 4</span><br><span class="line">-3 9</span><br><span class="line">6 -4</span><br><span class="line">7 5</span><br><span class="line">6 6</span><br><span class="line">-6 10</span><br><span class="line">0 8</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://dsa.cs.tsinghua.edu.cn/oj/attachment/9f51/9f516d08f38b1bbde0ab6aec6bfccb92211dc802.png" alt="img"></p><p>Sample Output (输出样例)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"></span><br><span class="line">7   &#x2F;&#x2F; ( 9 x 2 x 6 x 7 x 1 x 5 ) % (10 + 1)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://dsa.cs.tsinghua.edu.cn/oj/attachment/cb9d/cb9dbfbef90751cc0bc372041f543118dc6c9f1a.png" alt="img"></p><p>Limitation (限制)</p><ul><li><p>3 ≤ <strong>n</strong> ≤ 10^5</p></li><li><p>Each coordinate of the points is an integer from (-10^5, 10^5). There are no duplicated points. Each point is selected uniformly randomly in (-10^5, 10^5) x (-10^5, 10^5).</p></li><li><p>All points on extreme edges are regarded as extreme points and hence should be included in your solution.</p></li><li><p>Time Limit: 2 sec</p></li><li><p>Space Limit: 512 MB</p></li><li><p>3 ≤ <strong>n</strong> ≤ 10^5</p></li><li><p>所有点的坐标均为范围(-10^5, 10^5)内的整数，且没有重合点。每个点在(-10^5, 10^5) x (-10^5, 10^5)范围内均匀随机选取</p></li><li><p>极边上的所有点均被视作极点，故在输出时亦不得遗漏</p></li><li><p>时间限制：2 sec</p></li><li><p>空间限制：512 MB</p></li></ul><p>Hint (提示)</p><p>Use the CH algorithms presented in the lectures.</p><p>课程中讲解过的凸包算法</p><h3 id="解答：Graham-Scan算法"><a href="#解答：Graham-Scan算法" class="headerlink" title="解答：Graham Scan算法"></a><a href="https://renjikai.com/cg2017-pa1-1-convex-hull/" target="_blank" rel="noopener">解答：Graham Scan算法</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x, y, id;</span><br><span class="line">    <span class="built_in">point</span>() :x(<span class="number">0</span>), y(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">point</span>(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y) :x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> ==(<span class="keyword">const</span> <span class="built_in">point</span>&amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x == p.x &amp;&amp; y == p.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;PP; <span class="comment">//PP: Polar Point</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">point</span>&gt; points;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">area2</span><span class="params">(<span class="built_in">point</span> p, <span class="built_in">point</span> q, <span class="built_in">point</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    |p.x p.y 1|</span></span><br><span class="line"><span class="comment">    |q.x q.y 1| == 2*DirectedTriangleArea(p,q,s)</span></span><br><span class="line"><span class="comment">    |s.x s.y 1|</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> p.x * q.y - s.x * q.y</span><br><span class="line">        + q.x * s.y - q.x * p.y</span><br><span class="line">        + s.x * p.y - p.x * s.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">toLeftTest</span><span class="params">(<span class="built_in">point</span> p, <span class="built_in">point</span> q, <span class="built_in">point</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//When return value large than 0, S is on the left side of ray PQ</span></span><br><span class="line">    <span class="keyword">return</span> area2(p, q, s) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">toLeftTest2</span><span class="params">(<span class="built_in">point</span> p, <span class="built_in">point</span> q, <span class="built_in">point</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//When return value large than 0, S is on the left side of ray PQ</span></span><br><span class="line">    <span class="keyword">return</span> area2(p, q, s) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">point</span>&amp; p1, <span class="keyword">const</span> <span class="built_in">point</span>&amp; p2)</span> </span>&#123; <span class="comment">// Sort according to polar angle</span></span><br><span class="line">    <span class="keyword">return</span> PP == p1 || !(PP == p2) &amp;&amp; toLeftTest(PP, p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">point</span> <span class="title">LTL</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">point</span>&gt;&amp; points)</span> </span>&#123; <span class="comment">//Lowest then leftmost</span></span><br><span class="line">    <span class="built_in">point</span> ltl = points[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (points[i].y &lt; ltl.y || points[i].y == ltl.y &amp;&amp; points[i].x &lt; ltl.x)</span><br><span class="line">            ltl = points[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ltl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">point</span>&gt; <span class="title">grahamScan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PP = LTL(points);</span><br><span class="line">    sort(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">point</span>&gt; S, T;</span><br><span class="line">    S.push_back(points[<span class="number">0</span>]); S.push_back(points[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = points.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; <span class="number">1</span>; i--)T.push_back(points[i]);</span><br><span class="line">    <span class="keyword">while</span> (!T.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (toLeftTest2(S[S.<span class="built_in">size</span>() - <span class="number">2</span>], S[S.<span class="built_in">size</span>() - <span class="number">1</span>], T[T.<span class="built_in">size</span>() - <span class="number">1</span>])) &#123;</span><br><span class="line">            S.push_back(T[T.<span class="built_in">size</span>() - <span class="number">1</span>]);</span><br><span class="line">            T.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> S.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">point</span> tmp;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tmp.x &gt;&gt; tmp.y;</span><br><span class="line">        tmp.id = i;</span><br><span class="line">        points.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">point</span>&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (points.<span class="built_in">size</span>() &gt; <span class="number">2</span>)result = grahamScan();</span><br><span class="line">    <span class="keyword">else</span> result = points;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; result[i].id &lt;&lt; endl;//debug</span></span><br><span class="line">        res = ((res % (n + <span class="number">1</span>)) * (result[i].id % (n + <span class="number">1</span>))) % (n + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    res = ((res % (n + <span class="number">1</span>)) * (result.<span class="built_in">size</span>() % (n + <span class="number">1</span>))) % (n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分数：92.5<br>使用Graham Scan算法。凸包板子题。</p>]]></content>
      
      
      <categories>
          
          <category> OJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>32、黑客&amp;攻击</title>
      <link href="/archives/622.html"/>
      <url>/archives/622.html</url>
      
        <content type="html"><![CDATA[<p>黑客入侵最常见的方式不是通过技术，而是欺骗别人，这个称为<strong>社会工程学（Social Engineering）</strong>，通过欺骗别人来让人泄露秘密，或让人配置电脑系统来变得易于攻击。最常见的攻击是<strong>网络钓鱼（Phishing）</strong>，其次还有<strong>假托（Pretexting）</strong>，攻击者给某个公司打电话，假装是IT部门的人，攻击者的第一通电话一般会叫人转接，这样另一个接的时候，电话看起来就像内部的，然后让别人把电脑配置得易于入侵，或者让他们泄露机密信息，比如密码或网络配置。</p><a id="more"></a><p>邮件里带<strong>木马（trojan horse）</strong>也是常见手段，木马通常会伪装成无害的东西，比如照片或发票，但实际上是恶意软件，有的会偷数据，有的会加密文件。</p><p>如果攻击者无法用木马或电话欺骗，攻击者只能被迫使用其他手段，方法之一就是暴力破解，尝试所有可能的密码，直到进入系统，大多数现代系统会加长等待时间来抵御这种攻击，每次失败就加长等待时间，甚至超过一定次数后，完全封锁。现在出现了一种攻破方法称为<strong>NAND镜像</strong>，如果能物理接触到电脑，可以往内存上接几根线，复制整个内存，然后暴力尝试密码，直到设备让你等待。这时只要把复制的内容覆盖掉内存，本质上重置了内存，就不用等待，可以继续尝试密码。</p><p>如果无法物理接触到设备，就需要远程攻击，比如通过互联网，这一般需要攻击者利用系统漏洞，来获得某些能力或访问权限，称为<strong>漏洞利用（Exploit）</strong>。一种常见的漏洞利用叫<strong>缓冲区溢出（Buffer Overflow）</strong>，这里的缓冲区是指预留的一块内存空间，比如我们在系统登录界面输入用户名和密码，而系统是用缓冲区来存储输入值的，假设缓冲区大小为10，并且缓冲区前后肯定还有其他数据，当用户输入用户名和密码时，这些值就会被复制到缓冲区中来进行验证，而该方法会溢出缓冲区，比如输入超过10个字符的密码，会覆盖掉相邻的数据，有时会让程序或系统崩溃，因为重要值被垃圾数据覆盖掉了。这里只是让系统崩溃，但是攻击者可以输入有意义的新值到程序的内存中，比如把<code>is_admin</code>标志位的值改为true，有了任意修改内存的能力，黑客就可以绕过登录这类东西，甚至使用那个程序劫持整个系统。</p><p>有许多方法阻止缓冲区溢出，最简单的方法就是复制到内存之前先检查长度，称为<strong>边界检查（Bounds checking</strong>），许多现代编程语言都自带边界检查，程序也会随机存放变量在内存中的位置，这样黑客就不知道应该覆盖内存的哪部分，使得更容易让程序崩溃，而不是获得访问权限。程序也可以在缓冲区后，预留一些不用的空间，然后跟踪里面的值，看是否发生变化，来判断是否有攻击，这些不用的内存空间称为<strong>金丝雀（Canaries）</strong>。</p><p>另一种经典手段是<strong>代码注入（Code Injection）</strong>，最常用于攻击用数据库的网站。假设网页上有登录提示，当用户点击“登录”，输入文本就会发送服务器，服务器就会运行代码，检查用户名是否存在，如果存在就看密码是否匹配。为此服务器会执行一段sql查询代码，比如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">password</span> <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> username=<span class="string">'___'</span>;</span><br></pre></td></tr></table></figure><p>这里语句就是要从<code>users</code>表中查找<code>username</code>为<code>___</code>的密码<code>password</code>。 这里的<code>___</code>就是用户输入的用户名。由此攻击者就能把sql命令输入到用户名中，比如<code>whatever&#39;;DROP TABLE users;&#39;</code>，这时上面的查询语句就会变成</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">password</span> <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> username=<span class="string">'whatever'</span>;<span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">users</span>;';</span><br></pre></td></tr></table></figure><p>如果服务器存在用户名<code>wharever</code>，数据库就会返回密码， 当然我们无法得知密码是什么，所以服务器会拒绝我们；如果不存在用户名<code>wharever</code>，服务器会返回空密码或者直接错误，服务器也会拒绝我们。 但是我们关心的是后面的代码<code>DROP TABLE users;</code><strong>这个是我们注入的命令</strong>，这个命令是删掉users这张表。如今几乎所有服务器都会防御这种手段。</p><p>程序员需要认识到从外界输入的信息都是危险的，必须要好好检查，很多用户名和密码表单，不会让你直接输入特殊符号，比如分号或括号，来作为第一道防御。好的服务器也会清理输入，比如修改或删除特殊字符，然后才放到数据库查询语句中。</p><p>当软件制造者不知道的新漏洞被发现时，称为<strong>0day漏洞（Zero Day Vulnerability）</strong>，黑客就会抢在白帽程序员做出补丁之前尽可能利用漏洞。</p><p>如果有足够多的电脑有漏洞，让恶意程序可以自动地在电脑之间互相传播，称为<strong>蠕虫（Worm）</strong>。如果黑客拿下大量电脑，这些电脑可以组成<strong>僵尸网络（Botnet）</strong>，可以用于很多目的，比如发大量垃圾邮件等，用别人电脑的计算能力来挖比特币，或发起DDOS来攻击服务器。DDOS就是僵尸网络里的所有电脑发一大堆垃圾信息到服务器上，造成服务器的阻塞。</p><center>完~~~</center>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《计算机科学速成课》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 博客框架搭建</title>
      <link href="/archives/7f7e.html"/>
      <url>/archives/7f7e.html</url>
      
        <content type="html"><![CDATA[<center>搭建这个博客起因是2020年的二月末的某一天晚上，无聊逛B站，然后就看到了一个博客搭建教程，随机就有了这一系列的文章了。</center><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我的是在windows操作系统上面，在其他的系统上面大同小异。也参考了很多文章及视频教程。主要参考的是：</p><p><a href="https://www.codesheep.cn" target="_blank" rel="noopener"><strong>程序羊</strong></a>的视频：<a href="https://www.bilibili.com/video/av44544186?from=search&amp;seid=12981624311298276946" target="_blank" rel="noopener">https://www.bilibili.com/video/av44544186?from=search&amp;seid=12981624311298276946</a></p><p>文章：</p><ul><li><p><a href="https://ouwen666.gitee.io/2020/01/29/Hexo+Gitee搭建个人博客" target="_blank" rel="noopener">https://ouwen666.gitee.io/2020/01/29/Hexo+Gitee搭建个人博客</a></p><p>作者部署的是gitee</p></li><li><p><a href="https://godweiyang.com/2018/04/13/hexo-blog/#toc-heading-6" target="_blank" rel="noopener">https://godweiyang.com/2018/04/13/hexo-blog/#toc-heading-6</a></p><p>含有个性化配置</p></li></ul><p><strong>注</strong>：文中的指令都是在<code>cmd</code>（Windows中的命令提示符）中完成的。如果在这之前电脑上就已经安装了<code>Git bash</code>，那么也可以在<code>Git bash</code>中运行指令。</p><h2 id="下面会用得到的命令"><a href="#下面会用得到的命令" class="headerlink" title="下面会用得到的命令"></a>下面会用得到的命令</h2><ul><li><p><code>npm install</code>=<code>npm i</code>。在git clone项目的时候，项目文件中并没有 node_modules文件夹，项目的依赖文件可能很大。直接执行，npm会根据package.json配置文件中的依赖配置下载安装。</p></li><li><p><code>-global</code>=<code>-g</code>，全局安装，安装后的包位于系统预设目录下</p></li><li><p><code>--save</code>=<code>-S</code>，安装的包将写入package.json里面的dependencies，dependencies：生产环境需要依赖的库</p></li></ul><h1 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h1><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>博客框架<code>Hexo</code>是基于<code>Node.js</code>制作的静态博客，我们待会要用到Node.js里面的<a href="https://www.npmjs.cn/" target="_blank" rel="noopener">npm</a>(node package manager)包管理器来安装插件。</p><p>可以点击<a href="https://nodejs.org/en/" target="_blank" rel="noopener">这里</a>进入其官网。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200301192702158.png" alt="image-20200301192702158"></p><p>进入之后，按照操作系统进行下载安装。如上图是Windows系统64位的版本，上面官方推荐下载的版本。</p><p>安装选项就按默认的，一直点击<code>Next</code>。</p><p>然后，检验是否安装成功：用<code>Win+R</code>命令打开命令提示符，输入<code>node -v</code> 和<code>npm -v</code> ，出现版本号，则说明安装成功。</p><h3 id="添加cnpm"><a href="#添加cnpm" class="headerlink" title="添加cnpm"></a>添加cnpm</h3><p><strong>注</strong>：因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，如果npm的服务器在中国就好了，所以我们乐于分享的淘宝团队干了这事。来自官网：“这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。”</p><p>所以我们可以利用<code>npm</code>安装<code>cnpm</code>，再<code>cmd</code>中输入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install cnpm -g –registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>再输入：<code>cnpm -v</code>来检验是否安装成功。</p><p>此时，假设我们<code>Node.js</code>安装成功。</p><h2 id="安装Hexo框架"><a href="#安装Hexo框架" class="headerlink" title="安装Hexo框架"></a>安装Hexo框架</h2><p>我们要利用<code>Hexo</code>框架模型来搭建我们的博客。点击<a href="https://hexo.io/" target="_blank" rel="noopener">这里</a>可以进入其官网。下载该框架也仍然是在<code>cmd</code>（Windows中的“命令提示符”）中输入指令完成的。</p><ol><li><p>在上一步我们安装了<code>cnpm</code>，现在我们要用它来安装<code>hexo</code>，用<code>cnpm</code>安装的速度更快一些，也可以用<code>npm</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>检验是否安装成功，当运行之后出现版本号则安装成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><p>现在，我们的<code>Hexo</code>框架已经安装成功了。</p></li></ol><h3 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h3><p>想要看到博客运行起来，我们现在还需要对<code>Hexo</code>框架进行初始化。</p><p>在你的电脑上找一个合适的位置，创建一个文件夹，名字可以随便取，可以用Blog等等的名字，随个人喜好取名。为了便于演示，假设你取的名字叫做：<code>blog</code></p><p>注意，初始化是在我们创建的这个<code>blog</code>文件夹中初始化的，所以，我们的命令提示符（cmd）左边的路径要在这个<code>blog</code>文件夹中。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200301215807657.png" alt="image-20200301215807657"></p><center>进入刚刚创建的文件夹中</center>然后，在输入指令 ：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>初始化完成后，我们的<code>blog</code>文件夹中，就会生成这些文件：</p><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li>_config.yml: 博客的配置文件</li></ul><p>在安装一些必要的包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>初始化完成，在打开<code>hexo</code>服务器：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><p>我们，打开浏览器，输入：localhost:4000，就可以看到你的博客的雏形已经好了。</p><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>加入你觉得这个主题你不喜欢，想要找一个其他的主题，你可以进入Hexo的官网的<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题</a>板块，来选择你喜欢的主题：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200301221159332.png" alt="image-20200301221159332"></p><p>假如，你想更换为<code>3-hexo</code>，那就点击它，会跳转到该主题的创作者的GitHub上：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200301221422653.png" alt="image-20200301221422653"></p><p>安装<code>3-hexo</code>主题，其中命令的<code>themes/3-hexo</code>指的是该主题的安装位置：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/yelog/hexo-theme-3-hexo.git themes/3-hexo</span><br></pre></td></tr></table></figure><p>安装完之后，我们需要运行：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean          # 清除所有记录 </span><br><span class="line">$ hexo generate       # 生成静态网页 简写：hexo g</span><br><span class="line">$ hexo server         # 启动服务 简写：hexo s</span><br></pre></td></tr></table></figure><p>然后，我们就能在本地localhost:4000中，查看修改好的主题了。</p><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>如果你不想只在本地上查看你的博客，也想有自己的博客网址链接，那我们可以下载Git，把博客内容部署到<code>GitHub</code>或者<code>gitee</code>上面。我们这里以GitHub为例。</p><p>Git的官网点击<a href="https://git-scm.com/" target="_blank" rel="noopener">这里</a>。然后按照你的电脑的操作系统下载相应的版本。安装选项还是全部默认，只不过最后一步添加路径时选择<code>Use Git from the Windows Command Prompt</code>，这样我们就可以直接在命令提示符里打开git了。</p><p>安装完成后在命令提示符中输入<code>git --version</code>验证是否安装成功。</p><h3 id="GitHub账号"><a href="#GitHub账号" class="headerlink" title="GitHub账号"></a>GitHub账号</h3><p>如果你没有GitHub账号，我们现在去创建一个吧。点击<a href="https://github.com/" target="_blank" rel="noopener">这里</a>创建。创建完成之后，我们新建一个github仓库：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200301223129140.png" alt="image-20200301223129140"></p><p>注意你的仓库名字不要随便起，待会我们要用到。加入你GitHub名字叫“AAA”，那么仓库个名字就一定是：<code>AAA.github.io</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200301223729456.png" alt="image-20200301223729456"></p><h1 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h1><h2 id="将博客部署在github中"><a href="#将博客部署在github中" class="headerlink" title="将博客部署在github中"></a>将博客部署在github中</h2><p>目前，还不能部署到GitHub上。还需要下载<code>hexo-deployer-git</code>插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install hexo-deployer-git --save  <span class="comment">#通过cpnm安装git插件</span></span><br></pre></td></tr></table></figure><p>如果，你是刚刚才下载的Git，则还需要设置你的姓名和邮箱：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"Firstname Lastname"</span> // 名字使用英文输入</span><br><span class="line">git config --global user.email <span class="string">"your_email@example.com"</span></span><br></pre></td></tr></table></figure><p>还有你的SSH Key，创建公开密钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><p>​ 把生成的密钥添加到GitHub中去：</p><ol><li>找到生成的密钥：如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，我的在：<code>C:\Users\xxxx\.ssh</code>（xxxx是我的一个目录）。里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是<strong>私钥</strong>，不能泄露出去，<code>id_rsa.pub</code>是<strong>公钥</strong>，可以放心地告诉任何人。</li><li>在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个SSH，名字随便，把公钥复制进去。</li></ol><p>到这里，我们的git与远程的GitHub已经建立起关系了。</p><p>我们还需要把<code>blog</code>文件夹中的设置文件，即：<code>_config.yml</code>，将最后一行进行修改,：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: https://github.com/longlongqin/longlongqin.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>​ repository修改为你自己的github项目地址，在实际操作过程中，repository: <a href="mailto:git@github.com">git@github.com</a>:longlongqin/longlongqin.github.io.git,也是可以的。</p><p>修改之后，我们才能部署到GitHub上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deployer</span><br><span class="line"><span class="comment">## 初次使用这个命令，需要输入github的用户名username和密码password</span></span><br></pre></td></tr></table></figure><p>​ 这里，就是利用刚下载的插件：<code>hexo-deployer-git</code></p><p>现在我们可以访问我们在github服务器上的博客网址，网址就是我们刚刚创建仓库的名字，比如我的仓库名是：<code>longlongqin.github.io</code>，我们复制粘贴它到浏览器，然后你就可以看到你的博客内容了。😊</p><h2 id="Git提交到多个仓库"><a href="#Git提交到多个仓库" class="headerlink" title="Git提交到多个仓库"></a>Git提交到多个仓库</h2><p><a href="https://yuxiang.ren/2017/08/25/hexo博客自动部署到多台服务器/" target="_blank" rel="noopener">https://yuxiang.ren/2017/08/25/hexo%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%88%B0%E5%A4%9A%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/</a></p><h2 id="部署在gitee"><a href="#部署在gitee" class="headerlink" title="部署在gitee"></a>部署在gitee</h2><h3 id="部署在gitee上的坑"><a href="#部署在gitee上的坑" class="headerlink" title="部署在gitee上的坑"></a>部署在gitee上的坑</h3><p>在gitee上面，和在GitHub上面部署差不多，但是有些地方我们还是要注意的。</p><h4 id="仓库命名问题"><a href="#仓库命名问题" class="headerlink" title="仓库命名问题"></a>仓库命名问题</h4><p>在创建gitee仓库时，最好也是将仓库名字命名为你的账号的用户名，比如我的：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200302144640624.png" alt="image-20200302144640624"></p><p>​ 当然，你也可以命名为其他名字，但是换成其他名字之后，可能会带来一系列其他的问题，比如图片无法显示。其实我之前命名成其他名字，就出现了很大的问题：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200302015639908.png" alt="image-20200302015639908"></p><p>这种情况是因为，他找不到资源，加载错误：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200302015741200.png" alt="image-20200302015741200"></p><p>熬了一个晚上，终于发现了。在官方文档中有：</p><blockquote><p><strong>网站在子目录的情况</strong></p></blockquote><p>如果你的网站在一个子目录（例如<a href="https://link.jianshu.com/?t=http://example.org/blog" target="_blank" rel="noopener">http://example.org/blog</a>） 设置<code>url</code>为<code>http://example.org/blog</code>并且设置<code>root</code>为<code>/blog/</code></p><p>说来也奇怪，在GitHub上面，和本地运行的时候都是好好的。就是在gitee上面出错了。o(︶︿︶)o 唉</p><p>解决它的办法就是：</p><p>​ 将root添加上缺少的那一级目录，即可</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://yoursite.com/child</span></span><br><span class="line"></span><br><span class="line"><span class="attr">root:</span> <span class="string">/blog/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:post_title/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line"></span><br><span class="line"> <span class="attr">trailing_index:</span> <span class="literal">false</span>   <span class="comment"># Set to false to remove trailing 'index.html' from permalinks</span></span><br><span class="line"></span><br><span class="line"> <span class="attr">trailing_html:</span> <span class="literal">true</span>     <span class="comment"># Set to false to remove trailing '.html' from permalinks</span></span><br></pre></td></tr></table></figure><p>这一篇帖子里面也有人遇到了同样的问题，最后也是通过root的修改解决的。：<a href="https://gitee.com/oschina/git-osc/issues/IFVWV?from=project-issue" target="_blank" rel="noopener">https://gitee.com/oschina/git-osc/issues/IFVWV?from=project-issue</a></p><h4 id="gitee-pages刷新"><a href="#gitee-pages刷新" class="headerlink" title="gitee pages刷新"></a>gitee pages刷新</h4><p>除了仓库名字需要注意，我们还需要注意，gitee个人版似乎不能自动刷新，所以你<strong>每次</strong><code>hexo d</code>之后，需要手动的刷新<code>gitee pages</code>，才能显示你新提交的内容。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200302145524039.png" alt="image-20200302145524039"></p><h1 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h1><h2 id="编辑器推荐"><a href="#编辑器推荐" class="headerlink" title="编辑器推荐"></a>编辑器推荐</h2><p>推荐使用<code>Typora</code>这款软件，点击<a href="https://www.typora.io/" target="_blank" rel="noopener">这里</a>进入官网，他可以写Markdown格式的内容，这个软件的方便之处在于直接将markdown语法呈现出其效果，并且已经集成了很多方便的功能，你无需记住插入代码的语法格式，无需记住插入图片的语法格式，这使得我可以专心写博客而无法关心学习markdown语法。有很多md编辑器，他们分成两个界面，一个界面是md源代码，另外一个界面实时更新显示其效果，而Typora是浑然一体的，真正所见即所得，就跟在使用word一样方便。</p><p>不仅如此，它还可以导出PDF、Word、HTML、图片等格式。</p><p>待续……</p><h2 id="图片问题"><a href="#图片问题" class="headerlink" title="图片问题"></a>图片问题</h2><p><a href="http://etrd.org/2017/01/23/hexo中完美插入本地图片/" target="_blank" rel="noopener">http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/</a></p><h1 id="Hexo的操作指令"><a href="#Hexo的操作指令" class="headerlink" title="Hexo的操作指令"></a>Hexo的操作指令</h1><p>我们刚开始，对于<code>Hexo</code>的指令不太熟悉，我们可以在他的官网上去查找相应的操作指令。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200301222120697.png" alt="image-20200301222120697"></p><h2 id="文章的front-matter"><a href="#文章的front-matter" class="headerlink" title="文章的front-matter"></a><a href="https://hexo.io/zh-cn/docs/front-matter" target="_blank" rel="noopener">文章的front-matter</a></h2><h3 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code>的值。</p><table><thead><tr><th align="left">配置选项</th><th align="left">默认值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">title</td><td align="left"><code>Markdown</code> 的文档标题</td><td align="left">文章标题，强烈建议填写此选项</td></tr><tr><td align="left">date</td><td align="left">文档创建时的日期时间</td><td align="left">发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td align="left">author</td><td align="left">根 <code>_config.yml</code>中的 <code>author</code></td><td align="left">文章作者</td></tr><tr><td align="left">img</td><td align="left"><code>featureImages</code>中的某个值</td><td align="left">文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td align="left">top</td><td align="left"><code>true</code></td><td align="left">（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页</td></tr><tr><td align="left">password</td><td align="left">无</td><td align="left">文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td align="left">toc</td><td align="left"><code>true</code></td><td align="left">是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td align="left">mathjax</td><td align="left"><code>false</code></td><td align="left">是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文档中也需要开启才行</td></tr><tr><td align="left">summary</td><td align="left">无</td><td align="left">文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则进程会自动截取文章的部分内容作为摘要</td></tr><tr><td align="left">categories</td><td align="left">无</td><td align="left">文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td align="left">tags</td><td align="left">无</td><td align="left">文章标签，一篇文章可以多个标签</td></tr></tbody></table><p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量，举例来说：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hello</span> <span class="string">World</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2013</span><span class="string">/7/13</span> <span class="number">20</span><span class="string">:46:25</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h3 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a>分类和标签</h3><p>只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而标签没有顺序和层次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">- Diary</span><br><span class="line">tags:</span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br></pre></td></tr></table></figure><blockquote><p><strong>分类方法的分歧</strong></p><p>如果您有过使用 WordPress 的经验，就很容易误解 Hexo 的分类方式。WordPress 支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是 Hexo 不支持指定多个同级分类。下面的指定方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - Diary</span><br><span class="line">  - Life</span><br></pre></td></tr></table></figure><p>会使分类<code>Life</code>成为<code>Diary</code>的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。</p><p>如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">- [Diary, PlayStation]</span><br><span class="line">- [Diary, Games]</span><br><span class="line">- [Life]</span><br></pre></td></tr></table></figure><p>此时这篇文章同时包括三个分类： <code>PlayStation</code> 和 <code>Games</code> 分别都是父分类 <code>Diary</code> 的子分类，同时 <code>Life</code> 是一个没有子分类的分类。</p></blockquote><h3 id="JSON-Front-matter"><a href="#JSON-Front-matter" class="headerlink" title="JSON Front-matter"></a>JSON Front-matter</h3><p>除了 YAML 外，你也可以使用 JSON 来编写 Front-matter，只要将 <code>---</code> 代换成 <code>;;;</code> 即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;title&quot;: &quot;Hello World&quot;,</span><br><span class="line">&quot;date&quot;: &quot;2013&#x2F;7&#x2F;13 20:46:25&quot;</span><br><span class="line">;;;</span><br></pre></td></tr></table></figure><h1 id="配置过程遇到的问题"><a href="#配置过程遇到的问题" class="headerlink" title="配置过程遇到的问题"></a>配置过程遇到的问题</h1><h2 id="Hexo博客中文章图片不显示的坑"><a href="#Hexo博客中文章图片不显示的坑" class="headerlink" title="Hexo博客中文章图片不显示的坑"></a>Hexo博客中文章图片不显示的坑</h2><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/qqpyimg1583424159.gif" alt="img"></p><p>这个是真的坑，搞了好久，终于看到一篇博文，才解决了这个问题。放一下这篇文章的<a href="https://myfavs.win/2019/08/08/%E8%AE%B0%E5%BD%95-Hexo-%E5%9B%BE%E7%89%87%E7%9A%84%E5%9D%91/" target="_blank" rel="noopener">传送门</a>。</p><h2 id="在coding中SSL证书申请失败的坑"><a href="#在coding中SSL证书申请失败的坑" class="headerlink" title="在coding中SSL证书申请失败的坑"></a>在coding中SSL证书申请失败的坑</h2><p>在搭建到coding中步骤其实和在github中比较相似，就是给仓库命名原则的时候需要注意，尽量让仓库名字与你的用户名相同，即和在github中命名规则相似。</p><p>如果你之前都很顺利，那么在SSL证书申请时，需要注意了：你会遇到证书申请一直失败的情况。这是为什么呢？是这样的：</p><ul><li><p>第一次尝试，查资料说是如果之前你已经在github oages上部署了，你自己买的域名也已经解析过了。此时直接在coding pages中申请ssl的话，会失败。</p><p>解决的办法就是：先把用于解析github pages的那两条暂停了，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200306234025834.png" alt="image-20200306234025834"></p></li><li><p>然后，我再试试，还是申请失败。出现类似于下面的错误：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200306234233629.png" alt="image-20200306234233629"></p></li><li><p>继续去查。嗯，找到了，申请失败是因为我的域名在国外无法解析，这是我的DNS设置导致的。</p><p>解决办法：在解析的时候，需要将<strong>线路类型</strong>改成<strong>默认</strong>。去试一试，等待一小会</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20200306234452437.png" alt="image-20200306234452437"></p><p>哇，终于申请成功了。</p><p>#Hexo博客备份</p><p>有时候我们外出，自己的电脑没有带，这时候想写博客怎么办。这也是有办法的，就是我们要先备份我们的博客。这里我们可以备份到github或者gitee.</p><p>拿github举例：</p><ul><li><p>首先，我们先要在GitHub上面建立一个仓库，仓库名字自取，仓库是public还是private，按照自己的心情来就好了。</p></li><li><p>然后，我们要在本地关联远程仓库：</p><p>我们进入你的本地博客所在的目录，比如我的在<code>D:\Blog</code>，然后，打开你的Git bash，按顺序输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init    <span class="comment">#初始化本地仓库</span></span><br><span class="line">git remote add origin &lt;你的远程仓库的SSH或HTTPS链接&gt;  <span class="comment">#关联远程仓库（ssh的链接比较快一点）</span></span><br></pre></td></tr></table></figure><p>关联完成，然后我们还需要，将本地的推送到远端，同样，按顺序输入一下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .  <span class="comment">#这个‘.’表示将整个文件夹都一起添加到暂存区（不然还要一个个输入文件名）</span></span><br><span class="line">git commit -m <span class="string">"输入你这次提交的说明"</span> </span><br><span class="line">git push origin master  <span class="comment">#推送到远程仓库</span></span><br></pre></td></tr></table></figure><p>好了，记得按时将本地的备份到远程仓库。</p></li></ul><p>至此，本地备份已经完成。如果你想同时备份到gitee和github上面，你可以参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/1163625339727712" target="_blank" rel="noopener">这里</a>。</p><h1 id="在另外一台电脑上写博客"><a href="#在另外一台电脑上写博客" class="headerlink" title="在另外一台电脑上写博客"></a>在另外一台电脑上写博客</h1><p>前提是我们把博客备份在github、gitee等上面。</p><p>然后在新电脑上面：</p><ol><li>安装 Git、nodejs</li><li>把你远程的博客备份，clone下来到一个指定的位置（位置自己定）</li><li>在本地的博客仓库运行：<code>npm install</code>，来 安装依赖包</li></ol><p>好了，你可开始写博客了。</p><h1 id="优化技巧"><a href="#优化技巧" class="headerlink" title="优化技巧"></a>优化技巧</h1><h2 id="优化文章URL"><a href="#优化文章URL" class="headerlink" title="优化文章URL"></a>优化文章URL</h2><p><code>seo</code>搜索引擎优化认为，网站的最佳结构是<strong>用户从首页点击三次就可以到达任何一个页面</strong>，但是我们使用<code>hexo</code>编译的站点打开文章的<code>url</code>是：<code>sitename/year/mounth/day/title</code>四层的结构，这样的<code>url</code>结构很不利于<code>seo</code>，爬虫就会经常爬不到我们的文章，于是，我们需要优化一下网站文章<code>url</code></p><p>方案一：</p><p>我们可以将<code>url</code>直接改成<code>sitename/title</code>的形式，并且<code>title</code>最好是用英文，在根目录的配置文件下修改<code>permalink</code>如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://sunhwee.com</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:title.html</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br></pre></td></tr></table></figure><p>方案二：</p><p>使用插件优化<code>url</code></p><p>插件<code>hexo-abbrlink</code>实现了这个功能，它将原来的<code>URL</code>地址重新进行了进制转换和再编码。</p><p>安装<code>hexo-abbrlink</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>配置博客根目录下的_config.yml文件。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># permalink: :title/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">archives/:abbrlink.html</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>  <span class="comment"># 算法：crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>    <span class="comment"># 进制：dec(default) and hex</span></span><br></pre></td></tr></table></figure><p>运行<code>hexo clean</code>和<code>hexo g</code>命令来重新生成文件看看，可以清楚的看到，<code>URL</code>结构成功变为了3层。</p><p>来源: 洪卫の博客<br>作者: 洪卫<br>文章链接: <a href="https://sunhwee.com/posts/6e8839eb.html#toc-heading-59" target="_blank" rel="noopener">https://sunhwee.com/posts/6e8839eb.html#toc-heading-59</a><br>本文章著作权归作者所有，任何形式的转载都请注明出处。</p><h1 id="其他参考文章"><a href="#其他参考文章" class="headerlink" title="其他参考文章"></a>其他参考文章</h1><p>列表：<br><a href="http://dongshuyan.com/2019/05/24/hexo博客注意事项/#14-Hexo添加百度统计" target="_blank" rel="noopener">http://dongshuyan.com/2019/05/24/hexo%E5%8D%9A%E5%AE%A2%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/#14-Hexo添加百度统计</a></p><p><a href="https://www.dazhuanlan.com/2019/10/16/5da6352aa2a2e/" target="_blank" rel="noopener">网络编程系列 Hexo + Github搭建个人博客 · 花田半亩</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo主题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
