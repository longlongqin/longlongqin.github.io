<!DOCTYPE html><html><head hexo-theme="https://volantis.js.org/#2.1.4"><meta charset="utf-8"><meta name="robots" content="index,follow"><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><title>龙龙‘S BLOG</title><link rel="alternate" href="/atom.xml" title="龙龙‘S BLOG"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css"><link rel="shortcut icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1.4.3/css/style.css"><script>function setLoadingBarProgress(e){document.getElementById("loading-bar").style.width=e+"%"}</script></head><body><script type="text/javascript" src="/js/love.js"></script><script type="text/javascript" src="/js/ergao.js"></script><div class="cover-wrapper"><cover class="cover full"><div class="cover-body"><div class="a"><p class="title white">龙龙'S BLOG</p><p class="subtitle white">你做三四月的事，在八九月自有答案。</p></div><div class="b"><div class="m_search"><form name="searchform" class="form u-search-form"><input type="text" class="input u-search-input" placeholder="search for anything"> <i class="icon fas fa-search fa-fw"></i></form></div><div class="menu navigation"><ul class="h-list"><li><a class="nav home white" href="/easysearch/" id="easysearch"><i class="fa fa-search fa-fw"></i>&nbsp;easy搜索</a></li><li><a class="nav home white" href="/" id="home"><i class="fas fa-rss fa-fw"></i>&nbsp;博文</a></li><li><a class="nav home white" href="https://devdocs.io" target="_blank" rel="noopener" id="https:devdocs.io"><i class="fas fa-code-branch fa-fw"></i>&nbsp;API文档浏览器</a></li><li><a class="nav home white" href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="E5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-book fa-fw"></i>&nbsp;学习笔记</a></li><li><a class="nav home white" href="https://longlongqin.github.io/archives/eaabd222.html" rel="nofollow" id="https:longlongqin.github.ioarchiveseaabd222.html"><i class="fa fa-bookmark fa-fw"></i>&nbsp;云书签</a></li><li><a class="nav home white" href="https://www.yuque.com/longlongqin/gis/hdwn9y" target="_blank" rel="nofollow noopener" id="https:www.yuque.comlonglongqingishdwn9y"><i class="fa fa-bookmark fa-fw"></i>&nbsp;GIS</a></li></ul></div></div></div><div class="scroll-down"><i class="fa fa-chevron-down scroll-down-effects"></i></div></cover><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><header class="l_header shadow blur"><div class="wrapper"><div class="nav-sub container--flex"><a class="logo flat-box"></a><ul class="switcher h-list"><li><a class="s-comment flat-btn fas fa-comments fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-toc flat-btn fas fa-list fa-fw" target="_self" href="javascript:void(0)"></a></li></ul></div><div class="nav-main container container--flex"><a class="logo flat-box" target="_self" href="/"><i class="fas fa-home"></i> 龙龙</a><div class="menu navigation"><ul class="h-list"><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list-alt fa-fw fa-fw"></i> 索引</a><ul class="submenu"><li><a class="flat-box" href="/categories/" id="categories"><i class="fas fa-folder-open fa-fw fa-fw"></i> 分类</a><ul class="submenu"><li><a class="flat-box" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="categoriesE5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-fire fa-fw"></i> 学习笔记</a></li><li><a class="flat-box" href="/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" id="categoriesE5AE9EE794A8E68A80E5B7A7"><i class="fas fa-fire fa-fw"></i> 实用技巧</a></li></ul></li><li><a class="flat-box" href="/tags/" id="tags"><i class="fas fa-tags fa-fw fa-fw"></i> 标签</a></li><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list fa-fw fa-fw"></i> 时间轴</a></li></ul></li><li><a class="flat-box" href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="E5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-book fa-fw"></i> 学习笔记</a></li><li><a class="flat-box"><i class="fas fa-wrench fa-fw"></i> 工具</a><ul class="submenu"><li><a class="flat-box" href="https://www.thinkcmf.com/font/search/index.html" target="_blank" rel="noopener" id="https:www.thinkcmf.comfontsearchindex.html"><i class="fas fa-font fa-fw"></i> Font Awesome图标</a></li><li><a class="flat-box" href="https://www.sojson.com/image/change.html" target="_blank" rel="noopener" id="https:www.sojson.comimagechange.html"><i class="fa fa-crop fa-fw"></i> 在线图片尺寸修改</a></li><li><a class="flat-box" href="http://dir.scmor.com/" target="_blank" rel="noopener" id="http:dir.scmor.com"><i class="fa fa-search fa-fw"></i> Google学术&搜索镜像</a></li><li><a class="flat-box" href="https://emojixd.com/" target="_blank" rel="noopener" id="https:emojixd.com"><i class="fa fa-smile-o fa-fw"></i> Emoji表情符号辞典📓</a></li></ul></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw fa-fw"></i> 关于</a><ul class="submenu"><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-user-circle fa-fw fa-fw"></i> 关于我</a></li><hr><li><a class="flat-box" href="/friends/" id="friends"><i class="fas fa-link fa-fw"></i> 友人帐</a></li><li><a class="flat-box" href="/comment/" id="comment"><i class="fas fa-comment fa-fw"></i> 留言板</a></li><hr><li><a class="flat-box" href="https://github.com/longlongqin" target="_blank" rel="noopener" id="https:github.comlonglongqin"><i class="fab fa-github fa-fw fa-fw"></i> 我的Github</a></li><li><a class="flat-box" href="https://longlongqin.gitee.io" target="_blank" rel="noopener" id="https:longlongqin.gitee.io"><i class="fa fa-chevron-circle-right fa-fw"></i> matery主题博客</a></li></ul></li><li><a class="flat-box" href="https://volantis.js.org/tag-plugins/" target="_blank" rel="noopener" id="https:volantis.js.orgtag-plugins"><i class="fa fa-bookmark fa-fw"></i> Volantis主题文档</a></li><li><a class="flat-box" href="/easysearch/" id="easysearch"><i class="fa fa-search fa-fw"></i> easy搜索</a></li></ul></div><div class="m_search"><form name="searchform" class="form u-search-form"><i class="icon fas fa-search fa-fw"></i> <input type="text" class="input u-search-input" placeholder="search for everything"></form></div><ul class="switcher h-list"><li><a class="s-search flat-btn fas fa-search fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-menu flat-btn fas fa-bars fa-fw" target="_self" href="javascript:void(0)"></a></li></ul></div></div></header><ul class="menu-phone navigation white-box"><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list-alt fa-fw fa-fw"></i> 索引</a></li><li><a class="flat-box" href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="E5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-book fa-fw"></i> 学习笔记</a></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw fa-fw"></i> 关于</a></li></ul><script>setLoadingBarProgress(40)</script></div><div class="l_body"><div class="body-wrapper"><div class="l_main"><section class="post-list"><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/448ac7f1.html">hexo中插入pdf</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://www.longlongqin.github.io" target="_blank" rel="nofollow noopener"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongqin</p></a></div><div class="new-meta-item category"><a href="/categories/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" rel="nofollow"><i class="fas fa-folder-open" aria-hidden="true"></i><p>hexo博客搭建</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年3月21日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：580字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：2分钟</p></a></div><div class="new-meta-item top-post"><a class="notlink"><i class="fas fa-angle-double-up" aria-hidden="true"></i><p>置顶</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>法1：安装hexo-pdf插件</p><p>法2：利用html语法：可以轻松设定尺寸</p><div class="button readmore"><a href="/archives/448ac7f1.html">Read More <i class="fas fa-chevron-right"></i></a></div></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/7f7e.html">Hexo 博客框架搭建</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item category"><a href="/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" rel="nofollow"><i class="fas fa-folder-open" aria-hidden="true"></i><p>博客搭建</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年3月1日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：4.7k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：17分钟</p></a></div><div class="new-meta-item top-post"><a class="notlink"><i class="fas fa-angle-double-up" aria-hidden="true"></i><p>置顶</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><center>搭建这个博客起因是2020年的二月末的某一天晚上，无聊逛B站，然后就看到了一个博客搭建教程，随机就有了这一系列的文章了。</center><div class="button readmore"><a href="/archives/7f7e.html">Read More <i class="fas fa-chevron-right"></i></a></div></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/18085cf9.html">GIT 学习</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item category"><a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git/" rel="nofollow"><i class="fas fa-folder-open" aria-hidden="true"></i><p>学习笔记&nbsp;/&nbsp;Git</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年4月5日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：3.9k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：15分钟</p></a></div><div class="new-meta-item top-post"><a class="notlink"><i class="fas fa-angle-double-up" aria-hidden="true"></i><p>置顶</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><center><p center large><red></red>Git学习笔记</p></center><div class="button readmore"><a href="/archives/18085cf9.html">Read More <i class="fas fa-chevron-right"></i></a></div></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/50be15c2.html">C&C++/调试c++程序</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年6月1日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：9.6k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：36分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><h1 id="语法和语义错误"><a href="#语法和语义错误" class="headerlink" title="语法和语义错误"></a>语法和语义错误</h1><p>原文：<a href="https://www.learncpp.com/cpp-tutorial/syntax-and-semantic-errors/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/syntax-and-semantic-errors/</a></p><hr><p>软件错误非常普遍。制作它们很容易，但要找到它们却很难。在本章中，我们将探索与在我们的c++程序中发现和清除bug相关的主题，包括学习如何使用集成调试器(IDE的一部分)。</p><p>当根据c++语言的语法编写无效的语句时，会发生<strong>语法错误</strong>。这包括错误，如缺少分号，使用未声明的变量，不匹配的括号或大括号等。例如，下面的程序包含相当多的语法错误:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt; <span class="string">"Hi there"</span>; &lt;&lt; x; <span class="comment">// invalid operator (&lt;), extraneous semicolon, undeclared variable (x)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> <span class="comment">// missing semicolon at end of statement</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>幸运的是，编译器通常会捕获语法错误并生成警告或错误，因此您可以轻松地识别和修复问题。然后只需重新编译，直到消除所有错误。</p><p>一旦你的程序正确编译，让它实际产生你想要的结果可能会很棘手。当语句在语法上有效，但没有按照程序员的意图执行时，就会发生<strong>语义错误</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" / "</span> &lt;&lt; b &lt;&lt; <span class="string">" = "</span> &lt;&lt; a / b; <span class="comment">// 除0没有定义</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现代编译器已经能够更好地检测某些类型的常见语义错误(例如使用未初始化的变量)。然而，在大多数情况下，编译器将无法捕获大多数这类问题，因为编译器的设计目的是加强语法，而不是意图。</p><p>在上面的例子中，错误是很容易发现的。但是在大多数重要的程序中，通过肉眼观察代码不容易发现语义错误。这就是调试技术可以派上用场的地方。</p><h1 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h1><p>原文：<a href="https://www.learncpp.com/cpp-tutorial/the-debugging-process/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/the-debugging-process/</a></p><p>假设您编写了一个程序，但是它不能正确地工作——代码编译得很好，但是当您运行它时，您将得到一个不正确的结果。你一定在什么地方犯了语义错误。你怎么找到它的?如果您一直遵循最佳实践，编写一些代码，然后对其进行测试，那么您可能已经很清楚错误在哪里了。或者你可能完全没有线索。</p><h2 id="调试的一般方法"><a href="#调试的一般方法" class="headerlink" title="调试的一般方法"></a>调试的一般方法</h2><p>一旦发现问题，调试问题通常包括五个步骤:</p><ol><li>找出问题的根本原因(通常是不能工作的代码行)</li><li>确保您理解问题发生的原因</li><li>决定如何解决这个问题</li><li>修复导致问题的问题</li><li>重新测试以确保问题已经解决，没有出现新的问题</li></ol><p>练习：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Adds two numbers</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y; <span class="comment">// function is supposed to add, but it doesn't</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// should produce 8, but produces 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码有一点很好: 错误非常明显，因为错误的答案通过第11行打印到屏幕上。这为我们的调查提供了一个起点。</p><p><strong>Find the root cause:</strong> On line 11, we can see that we’re passing in literals for arguments (5 and 3), so there is no room for error there. Since the inputs to function <em>add</em> are correct, but the output isn’t, it’s pretty apparent that function <em>add</em> must be producing the wrong value. The only statement in function <em>add</em> is the return statement, which must be the culprit. We’ve found the problem line. Now that we know where to focus our attention, noticing that we’re subtracting instead of adding is something you’re likely to find via inspection.</p><p><strong>Understand the problem:</strong> In this case, it’s obvious why the wrong value is being generated – we’re using the wrong operator.</p><p><strong>Determine a fix:</strong> We’ll simply change <em>operator-</em> to <em>operator+</em>.</p><p><strong>Repair the issue:</strong> This is actually changing <em>operator-</em> to <em>operator+</em> and ensuring the program recompiles.</p><p><strong>Retest:</strong> After implementing the change, rerunning the program will indicate that our program now produces the correct value of 8. For this simple program, that’s all the testing that’s needed.</p><p>This example is trivial, but illustrates the basic process you’ll go through when diagnosing any program.</p><h1 id="调试策略"><a href="#调试策略" class="headerlink" title="调试策略"></a>调试策略</h1><p>原文：<a href="https://www.learncpp.com/cpp-tutorial/a-strategy-for-debugging/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/a-strategy-for-debugging/</a></p><hr><p>在调试程序时，在大多数情况下，您的大部分时间都将花在寻找错误的实际位置上。一旦发现了问题，剩下的步骤 (修复问题并验证问题是否已修复) 相比之下通常是微不足道的。</p><h2 id="通过代码检查发现问题"><a href="#通过代码检查发现问题" class="headerlink" title="通过代码检查发现问题"></a>通过代码检查发现问题</h2><p>假设你注意到一个问题，你想要找出这个问题的原因。在许多情况下(<strong>特别是在较小的程序中</strong>)，我们可以很快确定问题所在。</p><p>然而，随着程序变得越来越复杂，通过代码检查发现问题也变得越来越复杂。</p><ul><li>首先，有更多的代码需要查看。在一个有数千行代码的程序中，查看每一行代码都要花费很长的时间(更不用说它是非常无聊的)。</li><li>其次，代码本身往往更复杂，出错的地方也更多。</li><li>第三，代码的行为可能不会给您提供很多关于哪里出了问题的线索。如果你写了一个程序来输出股票推荐，但实际上它什么也没输出，你可能就不知道从哪里开始寻找问题了。</li><li>最后，错误可能是由于错误的假设造成的。几乎不可能从视觉上发现由错误假设引起的错误，因为在检查代码时，您可能会做出相同的错误假设，而不会注意到错误。</li></ul><p>因此，如果我们有一个问题，我们不能通过代码检查发现，我们如何找到它?</p><h2 id="通过运行程序发现问题"><a href="#通过运行程序发现问题" class="headerlink" title="通过运行程序发现问题"></a>通过运行程序发现问题</h2><p>幸运的是，如果我们不能通过代码检查发现问题，那么我们可以采用另一种方法:<strong>我们可以观察程序运行时的行为，并尝试从中诊断问题。</strong>这种方法可以概括为:</p><ol><li>找出重现问题的方法</li><li>运行程序并收集信息以缩小问题所在</li><li>重复前面的步骤，直到找到问题为止</li></ol><p>在本章的其余部分，我们将讨论促进这种方法的技术。</p><h3 id="重现问题"><a href="#重现问题" class="headerlink" title="重现问题"></a>重现问题</h3><p>发现问题的第一步也是最重要的一步是能够重现问题。原因很简单: 除非你能观察到问题的发生，否则很难发现问题。</p><h3 id="关注问题"><a href="#关注问题" class="headerlink" title="关注问题"></a>关注问题</h3><p>一旦我们可以合理地重现问题，下一步就是找出问题在代码的什么地方。根据问题的性质，这可能是容易的，也可能是困难的。</p><h1 id="基本的调试策略"><a href="#基本的调试策略" class="headerlink" title="基本的调试策略"></a>基本的调试策略</h1><h2 id="调试策略-1-注释掉代码"><a href="#调试策略-1-注释掉代码" class="headerlink" title="调试策略#1:注释掉代码"></a>调试策略#1:注释掉代码</h2><p>如果程序显示出错误行为，减少必须搜索的代码量的一种方法是注释一些代码，看看问题是否仍然存在。如果问题仍然存在，注释掉的代码不负责。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    getNames(); <span class="comment">// ask user to enter a bunch of names</span></span><br><span class="line">    doMaintenance(); <span class="comment">// do some random stuff</span></span><br><span class="line">    sortNames(); <span class="comment">// sort them in alphabetical order</span></span><br><span class="line">    printNames(); <span class="comment">// print the sorted list of names</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们假设这个程序应该按字母顺序打印用户输入的名称，但是它按相反的字母顺序打印它们。问题在哪里?</p><p>它可以是上面的代码中的任何一个。但是我们可能怀疑<code>doMaintenance();</code>与这个问题没有任何关系，所以让我们注释掉它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    getNames(); <span class="comment">// ask user to enter a bunch of names</span></span><br><span class="line"><span class="comment">//    doMaintenance(); // do some random stuff</span></span><br><span class="line">    sortNames(); <span class="comment">// sort them in alphabetical order</span></span><br><span class="line">    printNames(); <span class="comment">// print the sorted list of names</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果问题消失了，那么问题一定是由<code>doMaintenance</code>引起的，我们应该把注意力集中在维护上。</p><p>但是，如果问题仍然存在(这种可能性更大)，那么我们就知道<code>doMaintenance</code>并不是错误，我们可以将该函数排除在外。这并不能帮助我们理解实际的问题是在对<code>doMaintenance</code>的调用之前还是之后，但是它减少了我们随后要检查的代码量。</p><p>不要忘记您注释掉了哪些函数，以便稍后取消注释!</p><h2 id="调试策略-2-验证代码流"><a href="#调试策略-2-验证代码流" class="headerlink" title="调试策略#2:验证代码流"></a>调试策略#2:验证代码流</h2><p>在更复杂的程序中常见的另一个问题是，程序调用一个函数的次数太多或太少(包括完全不调用)。</p><p>在这种情况下，将语句放在函数的顶部以打印函数名是很有帮助的。这样，当程序运行时，您就可以看到调用了哪些函数。</p><blockquote><p>当打印用于调试的信息时，使用<strong><code>std::cerr</code></strong>而不是std::cout。</p><ul><li>这样做的一个原因是std::cout可能会被缓冲，这意味着在您请求std::cout输出信息和它实际执行输出信息之间可能会有一个停顿。如果您使用std::cout输出，然后您的程序立即崩溃，那么std::cout可能还没有实际输出。这可能会误导你问题在哪里。</li><li>另一方面，std::cerr是无缓冲的，这意味着您发送给它的任何内容都会立即输出。这有助于确保所有调试输出尽快出现(以牺牲某些性能为代价，我们通常在调试时并不关心这些性能)。</li></ul></blockquote><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; getValue;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然我们希望这个程序打印值4，但它实际上会在不同的机器上打印不同的值。在作者的机器上，它打印:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00101424</span><br></pre></td></tr></table></figure><p>让我们在这些函数中添加一些调试语句:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"getValue() called\n"</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main() called\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; getValue;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>在添加临时调试语句时，最好不要缩进它们。这使得以后更容易找到它们并移除。</strong></p></blockquote><p>现在，当这些函数执行时，它们将输出它们的名称，表明它们被调用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main() called</span><br><span class="line">00101424</span><br></pre></td></tr></table></figure><p>现在我们可以看到函数getValue从未被调用。调用函数的代码一定有问题。让我们仔细看看这句话:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; getValue;</span><br></pre></td></tr></table></figure><p>看，我们忘了函数调用的括号了。应该是:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"getValue() called\n"</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main() called\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; getValue(); <span class="comment">// added parenthesis here</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将生成正确的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main() called</span><br><span class="line">getValue() called</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>我们可以删除临时调试语句。</strong></p><h2 id="调试策略-3-打印值"><a href="#调试策略-3-打印值" class="headerlink" title="调试策略#3:打印值"></a>调试策略#3:打印值</h2><p>对于某些类型的错误，程序可能正在计算或传递错误的值。</p><p>我们还可以输出变量(包括参数)或表达式的值，以确保它们是正确的。</p><p>考虑下面的程序，它本应该添加两个数字，但却不能正确工作:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printResult</span><span class="params">(<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The answer is: "</span> &lt;&lt; z &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getUserInput</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line">	<span class="keyword">int</span> x&#123;&#125;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x&#123; getUserInput() &#125;;</span><br><span class="line">	<span class="keyword">int</span> y&#123; getUserInput() &#125;;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" + "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">int</span> z&#123; add(x, <span class="number">5</span>) &#125;;</span><br><span class="line">	printResult(z);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是这个程序的一些输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Enter a number: 4</span><br><span class="line">Enter a number: 3</span><br><span class="line">4 + 3</span><br><span class="line">The answer is: 9</span><br></pre></td></tr></table></figure><p>这是不正确的。看到错误了吗?即使在这个简短的程序中，也很难发现它。让我们添加一些代码来调试我们的值:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printResult</span><span class="params">(<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The answer is: "</span> &lt;&lt; z &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getUserInput</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line">	<span class="keyword">int</span> x&#123;&#125;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x&#123; getUserInput() &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main::x = "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	<span class="keyword">int</span> y&#123; getUserInput() &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main::y = "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" + "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">int</span> z&#123; add(x, <span class="number">5</span>) &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main::z = "</span> &lt;&lt; z &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	printResult(z);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是上面的输出:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Enter a number: <span class="number">4</span></span><br><span class="line">main::x = <span class="number">4</span></span><br><span class="line">Enter a number: <span class="number">3</span></span><br><span class="line">main::y = <span class="number">3</span></span><br><span class="line"><span class="number">4</span> + <span class="number">3</span></span><br><span class="line">main::z = <span class="number">9</span></span><br><span class="line">The answer is: <span class="number">9</span></span><br></pre></td></tr></table></figure><p>变量x和y得到了正确的值，但变量z没有。问题必须在这两点之间，这使得函数<code>add()</code>成为一个关键问题。</p><p>让我们修改函数<code>add</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"add() called (x="</span> &lt;&lt; x &lt;&lt;<span class="string">", y="</span> &lt;&lt; y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//⭐</span></span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printResult</span><span class="params">(<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The answer is: "</span> &lt;&lt; z &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getUserInput</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line">	<span class="keyword">int</span> x&#123;&#125;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x&#123; getUserInput() &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main::x = "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	<span class="keyword">int</span> y&#123; getUserInput() &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main::y = "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" + "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">int</span> z&#123; add(x, <span class="number">5</span>) &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main::z = "</span> &lt;&lt; z &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	printResult(z);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Now we’ll <span class="built_in">get</span> the output:</span><br><span class="line"></span><br><span class="line">Enter a number: <span class="number">4</span></span><br><span class="line">main::x = <span class="number">4</span></span><br><span class="line">Enter a number: <span class="number">3</span></span><br><span class="line">main::y = <span class="number">3</span></span><br><span class="line">add() called (x=<span class="number">4</span>, y=<span class="number">5</span>)</span><br><span class="line">main::z = <span class="number">9</span></span><br><span class="line">The answer is: <span class="number">9</span></span><br></pre></td></tr></table></figure><p>变量y的值是3，但是我们的函数add却得到了参数y的值5，我们一定是传递了错误的参数。果然:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> z&#123; add(x, <span class="number">5</span>) &#125;;</span><br></pre></td></tr></table></figure><p>在这里。我们传递的是文字5，而不是变量y的值作为参数。这是一个简单的修复，然后我们可以<strong>删除调试语句</strong>。</p><h3 id="为什么使用-打印语句-进行调试不是很好"><a href="#为什么使用-打印语句-进行调试不是很好" class="headerlink" title="为什么使用 打印语句 进行调试不是很好"></a>为什么使用 打印语句 进行调试不是很好</h3><p>虽然将调试语句添加到用于诊断的程序中是一种常见的基本技术，也是一种功能性技术(特别是当调试器由于某种原因不可用时)，但它并不是很好，原因如下:</p><ol><li>调试语句使代码混乱。</li><li>调试语句会使程序的输出变得混乱。</li><li>在使用完调试语句之后，必须删除它们，这使得它们不可重用。</li><li>调试语句需要修改代码来添加和删除，这可能会引入新的错误。</li></ol><p>我们可以做得更好。我们将在以后的课程中探索如何做到这一点。</p><h1 id="更多的调试策略"><a href="#更多的调试策略" class="headerlink" title="更多的调试策略"></a>更多的调试策略</h1><h2 id="对调试代码进行条件化"><a href="#对调试代码进行条件化" class="headerlink" title="对调试代码进行条件化"></a>对调试代码进行条件化</h2><p>考虑以下包含一些调试语句的程序:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getUserInput</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"getUserInput() called\n"</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line">	<span class="keyword">int</span> x&#123;&#125;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main() called\n"</span>;</span><br><span class="line">    <span class="keyword">int</span> x&#123; getUserInput() &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"You entered: "</span> &lt;&lt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当您完成调试语句时，您将需要删除它们，或者注释掉它们。然后，如果您稍后还想要它们，就必须将它们添加回去，或者取消注释。</p><p>一种更容易在程序中禁用和启用调试的方法是使用<strong>预处理器指令使调试语句有条件</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENABLE_DEBUG <span class="comment">// 注释出以禁用调试</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getUserInput</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENABLE_DEBUG  <span class="comment">//⭐</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"getUserInput() called\n"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">//⭐</span></span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line">	<span class="keyword">int</span> x&#123;&#125;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENABLE_DEBUG  <span class="comment">//⭐</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main() called\n"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">//⭐</span></span></span><br><span class="line">    <span class="keyword">int</span> x&#123; getUserInput() &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"You entered: "</span> &lt;&lt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们可以通过 注释/取消注释 #define ENABLE_DEBUG 来启用调试。这允许我们重用以前添加的调试语句，然后在使用它们时禁用它们，而不必从代码中实际删除它们。</p><p>如果这是一个<strong>多文件程序，那么#define ENABLE_DEBUG将位于一个头文件中</strong>，该头文件包含在所有代码文件中，因此我们可以在单个位置 注释/取消注 释#define，并让它传播到所有代码文件。</p><p>这解决了必须删除调试语句的问题和这样做的风险：</p><ul><li>但代价是代码更加混乱。</li><li>这种方法的另一个缺点是，如果您输入错误(例如拼错“DEBUG”)或忘记将头文件包含到代码文件中，那么可能无法启用该文件的部分或全部调试。</li></ul><h2 id="使用一个日志记录器"><a href="#使用一个日志记录器" class="headerlink" title="使用一个日志记录器"></a>使用一个日志记录器</h2><p>通过预处理程序进行条件化调试的另一种方法 是将调试信息发送到<strong>日志文件</strong>。</p><blockquote><p><strong>日志文件</strong>是一个记录软件中发生的事件的文件(通常存储在磁盘上)。</p><p>将信息写入日志文件的过程称为<strong>日志记录</strong>。</p></blockquote><p>大多数应用程序和操作系统编写的日志文件可用于帮助诊断发生的问题。</p><p>日志文件有一些优点：</p><ul><li><p>因为写入日志文件的信息与程序的输出是分开的，所以可以避免将正常输出和调试输出混合在一起所造成的混乱。</p></li><li><p>日志文件也可以很容易地发送给其他人进行诊断——因此，如果使用您的软件的人遇到问题，您可以让他们将日志文件发送给您，这可能会帮助您了解问题所在。</p></li></ul><p>虽然可以编写自己的代码来创建日志文件并向它们发送输出，<strong>但是最好使用现有的第三方日志工具之一</strong>。你用哪一个取决于你。</p><p>为了便于说明，我们将展示使用<a href="https://github.com/SergiusTheBest/plog" target="_blank" rel="noopener">plog</a>日志记录器输出到日志记录器的内容。</p><blockquote><p>Plog是作为一组头文件实现的，因此很容易在任何需要的地方包含它，而且它是轻量级的，易于使用。</p></blockquote><h3 id="如何使用plog日志记录器"><a href="#如何使用plog日志记录器" class="headerlink" title="如何使用plog日志记录器"></a>如何使用plog日志记录器</h3><p>If you want to compile the above example yourself, or use plog in your own projects, you can follow these instructions to install it:</p><p>First, get the latest plog release:</p><ul><li>Visit the <a href="https://github.com/SergiusTheBest/plog" target="_blank" rel="noopener">plog</a> repo.</li><li>Click the “releases” tab (it’s in the same row as “commits”, “branches”, “packages”, etc…)</li><li>Under the release tagged as “latest release” on the left, click the link “Source code (zip)” to download the latest release.</li></ul><p>Next, unzip the entire archive to `` on your hard drive.</p><p>Finally, for each project, set the <code>\plog-\include\</code> directory as an <code>include directory</code> inside your IDE. There are instructions on how to do this for Visual Studio here: <a href="https://www.learncpp.com/cpp-tutorial/a2-using-libraries-with-visual-studio-2005-express/" target="_blank" rel="noopener">A.2 – Using libraries with Visual Studio</a> and Code::Blocks here: <a href="https://www.learncpp.com/cpp-tutorial/a3-using-libraries-with-codeblocks/" target="_blank" rel="noopener">A.3 – Using libraries with Code::Blocks</a>.</p><h1 id="使用集成调试器-单步调试"><a href="#使用集成调试器-单步调试" class="headerlink" title="使用集成调试器: 单步调试"></a>使用集成调试器: 单步调试</h1><p>原文：<a href="https://www.learncpp.com/cpp-tutorial/using-an-integrated-debugger-stepping/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/using-an-integrated-debugger-stepping/</a></p><hr><p>当您运行程序时，执行从主函数的顶部开始，然后一个语句接着一个语句地执行，直到程序结束。</p><p>在任何时候当你的程序运行时,程序跟踪很多事情：你使用的变量的值，调用了哪些函数(当这些函数返回,程序将知道回到)，以及程序内的当前执行点(所以它知道这语句执行下一个)。所有这些被跟踪的信息都称为您的<strong>程序状态</strong>(或者简称为<strong>状态</strong>)。</p><p>在以前的课程中，我们探讨了各种修改代码以帮助调试的方法，包括打印诊断信息或使用日志记录器。这些是在程序<strong>运行时</strong>检查程序状态的简单方法。</p><p>尽管这些方法如果使用得当是有效的，但是它们仍然有缺点:</p><ul><li>它们需要修改代码，这需要时间，并且可能会引入新的错误，而且它们会使代码变得混乱，使现有的代码更难理解。</li></ul><p>到目前为止，我们所展示的技术背后有一个未阐明的假设:一旦我们运行代码，它就会运行到完成(只有在接受输入时才会暂停)，而我们没有机会在任何我们想要的地方干预和检查程序的结果。</p><p>但是，如果我们能够去掉这个假设呢?幸运的是,我们可以。大多数现代IDE都带有一个集成的工具，称为<strong>调试器</strong>，它的设计目的就是实现这一点。</p><h2 id="调试器"><a href="#调试器" class="headerlink" title="调试器"></a>调试器</h2><p><strong>调试器</strong>是一种计算机程序，它允许程序员控制程序的执行方式，并在程序运行时检查程序状态。例如，程序员可以使用调试器逐行执行程序，同时检查变量的值。通过比较变量的实际值和预期值，或者观察代码的执行路径，调试器可以极大地帮助跟踪语义(逻辑)错误。</p><p>调试器背后的强大功能有两方面：</p><ul><li>精确控制程序执行的能力；</li><li>以及 查看(和修改，如果需要)程序状态的能力。</li></ul><p>早期的调试器(如<a href="http://en.wikipedia.org/wiki/Gdb" target="_blank" rel="noopener">gdb</a>)是具有命令行接口的独立程序，程序员必须在命令行中输入晦涩难懂的命令才能工作。</p><p>后来的调试器(例如Borland的 <a href="http://en.wikipedia.org/wiki/Turbo_Debugger" target="_blank" rel="noopener">turbo debugger</a>的早期版本)仍然是独立的，但是有了自己的“图形化”前端，使得使用它们更加容易。</p><p>现在，大多数现代ide都有<strong>集成的调试器</strong>——也就是说，调试器使用与代码编辑器相同的接口，因此可以使用编写代码时使用的环境进行调试(而不必切换程序)。</p><p>几乎所有现代调试器都包含相同的基本特性标准集——然而，在如何安排菜单来访问这些功能方面几乎没有一致性，键盘快捷键的一致性就更少了。</p><p>本章的其余部分将用于学习如何使用调试器。</p><blockquote><p><strong>不要忽视学习使用调试器。随着程序变得越来越复杂，与查找和修复问题所节省的时间相比，学习如何有效地使用集成调试器所花费的时间就显得微不足道了。</strong></p></blockquote><h3 id="Step-into"><a href="#Step-into" class="headerlink" title="Step into"></a>Step into</h3><blockquote><p>In Visual Studio, the <em>step into</em> command can be accessed via <em>Debug menu &gt; Step Into</em>, or by pressing the F11 shortcut key.</p></blockquote><p>step into命令在程序的正常执行路径中执行下一个语句，然后暂停程序的执行，以便我们可以使用调试器检查程序的状态。</p><blockquote><p>如果正在执行的语句包含一个函数调用，单步执行会导致程序跳转到正在调用的函数的顶部，并在那里暂停。</p></blockquote><p>当你的程序不运行，你执行第一个调试命令，你可能会看到相当多的事情发生:</p><ul><li>如果需要，程序将重新编译。</li><li>程序将开始运行。因为我们的应用程序是一个控制台程序，所以应该打开控制台输出窗口。它将是空的，因为我们还没有输出任何东西。</li><li>您的IDE可能会打开一些诊断窗口，这些窗口的名称可能是“诊断工具”、“调用堆栈”和“监视”。稍后我们将介绍其中的一些内容—现在您可以忽略它们。</li></ul><h3 id="Step-over"><a href="#Step-over" class="headerlink" title="Step over"></a>Step over</h3><blockquote><p>In Visual Studio, the <em>step over</em> command can be accessed via <em>Debug menu &gt; Step Over</em>, or by pressing the F10 shortcut key.</p></blockquote><p>与step into类似，step over命令在程序的正常执行路径中执行下一条语句。但是，step into将输入函数调用并逐行执行它们，而<strong>step over将执行整个函数而不停止并在函数执行后将控制权返回给您。</strong></p><h3 id="Step-out"><a href="#Step-out" class="headerlink" title="Step out"></a>Step out</h3><blockquote><p>In Visual Studio, the <em>step out</em> command can be accessed via <em>Debug menu &gt; Step Out</em>, or by pressing the Shift-F11 快捷键组合.</p></blockquote><p>与其他两个单步执行命令不同，<strong>Step out</strong>不只是执行下一行代码。相反，<strong>它执行当前正在执行的函数中的所有剩余代码，然后在函数返回时将控制权返回给您。</strong></p><h3 id="Step-back"><a href="#Step-back" class="headerlink" title="Step back"></a>Step back</h3><p>一些调试器(如Visual Studio Enterprise Edition和GDB 7.0)引入了单步调试功能，通常称为<strong>单步后退</strong>或<strong>反向调试</strong>（<em>step back</em> or <em>reverse debugging</em>）。</p><p><strong>Step back</strong>的目的是回退最后一步，这样您就可以将程序返回到先前的状态。如果您执行的操作超过了一步，或者您想重新检查刚刚执行的语句，那么这将非常有用。由于其复杂性，这种功能还没有标准化，并且会因调试器的不同而有所不同。截止到编写本文时(2019年1月)，Visual Studio Community edition和最新版本的Code::Blocks都不支持这种功能。希望在未来的某个时候，它会慢慢渗透到这些产品中，并被更广泛的使用。</p><h1 id="使用集成调试器-运行和断点"><a href="#使用集成调试器-运行和断点" class="headerlink" title="使用集成调试器: 运行和断点"></a>使用集成调试器: 运行和断点</h1><h2 id="运行到光标处"><a href="#运行到光标处" class="headerlink" title="运行到光标处"></a>运行到光标处</h2><p>第一个有用的命令通常称为<strong>Run to cursor（运行到光标处）</strong>。这个<strong>Run to cursor</strong>命令执行程序，直到执行到光标所选择的语句为止。然后，它将控制权返回给您，以便您可以从该点开始调试。</p><p>这是一种高效的方式，可以在代码中的特定点开始调试，或者如果已经在调试，则可以直接移动到需要进一步检查的位置。</p><blockquote><p><strong>For Visual Studio users</strong></p><p>在Visual Studio中，右击代码中的语句并从上下文菜单中选择run to cursor，或者按下ctrl-F10组合键，就可以访问run to cursor命令。</p></blockquote><h2 id="Continue"><a href="#Continue" class="headerlink" title="Continue"></a>Continue</h2><p>在调试会话进行到一半时，您可能希望从那时开始运行程序。最简单的方法是使用<strong>continue命令</strong>。</p><p><strong>continue 调试命令</strong>只是继续按正常方式运行程序，直到程序终止，或者直到有东西触发控件再次返回给您(例如断点，我们将在本课后面介绍)。</p><blockquote><p><strong>For Visual Studio users</strong></p><p>在Visual Studio中，可以通过Debug <em>menu</em>&gt; <em>continue</em> 或 按F5快捷键在调试程序时访问continue命令。</p></blockquote><h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><p>continue命令有一个名为start的孪生兄弟。start命令执行与continue相同的操作，<strong>只是从程序的开头开始。它只能在不在调试会话中调用。</strong></p><blockquote><p>在Visual Studio中，<strong>可以在不调试程序的情况下</strong>通过 Debug <em>menu</em> &gt; start debugging 或按下F5快捷键来访问start命令。</p></blockquote><h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><p>本节要讨论的最后一个主题是断点。<strong>断点</strong>是一种特殊的标记，它告诉调试器在调试模式下运行时，在断点处停止程序的执行。</p><blockquote><p><strong>For Visual Studio users</strong></p><p>在Visual Studio中,可以通过设置或删除断点 <em>Debug menu &gt; Toggle Breakpoint</em>, 或右键单击一个语句, 从上下文菜单中选择Toggle breakpoint或按 F9快捷键,或通过点击左边的行号(浅灰色区域)。</p></blockquote><h2 id="设置下一条语句"><a href="#设置下一条语句" class="headerlink" title="设置下一条语句"></a>设置下一条语句</h2><p>还有一个调试命令使用得非常不常见，但至少值得了解，即使您不经常使用它。</p><p><strong>设置下一条语句</strong> 命令允许我们将执行点更改为其他一些语句(有时也称为<strong>跳转</strong>)。这可以用来向前跳转执行点，跳过一些本来要执行的代码，或者向后跳转，让已经执行的代码重新运行。</p><blockquote><p><strong>For Visual Studio users</strong></p><p>在Visual Studio中，您可以通过右键单击一个语句并从上下文菜单中选择<em>Set next statement</em>，或者按下Ctrl-Shift-F10快捷组合键来跳过执行点。此选项与上下文相关，<strong>仅在已经调试程序时才会出现。</strong></p></blockquote><p>注意：</p><p><em>set next statement</em> 命令将更改执行点，但不会更改程序状态。您的变量将保留它们在跳转之前的任何值。因此，与其他情况相比，跳转可能会导致程序产生不同的值、结果或行为。明智地使用此功能(特别是向后跳转)。</p><p>不应该使用<em>set next statement</em> 将执行点更改为其他函数。这将导致未定义的行为，并可能导致崩溃。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>现在，您了解了使用集成调试器监视和控制程序执行方式的主要方法。虽然这些命令对于诊断代码流问题非常有用(例如，确定是否调用某些函数)，但是它们只是集成调试器给表带来的好处的一部分。</p><p>在下一课中，我们将开始探索检查程序状态的其他方法，您将需要这些命令作为先决条件。我们走吧!</p><h1 id="使用集成调试器-监视变量"><a href="#使用集成调试器-监视变量" class="headerlink" title="使用集成调试器: 监视变量"></a>使用集成调试器: 监视变量</h1><h2 id="监视变量"><a href="#监视变量" class="headerlink" title="监视变量"></a>监视变量</h2><p><strong>监视变量是在程序以调试模式执行时检查变量值的过程</strong>。大多数调试器都提供了几种方法来实现这一点。</p><ul><li><p><strong>检查简单变量(如x) 值的最简单方法是将鼠标悬停在变量x上</strong>。一些现代调试器支持这种检查简单变量的方法，这是最直接的方法。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-Watch2-min.png" alt="img"></p><blockquote><p>注意，您可以将鼠标悬停在任何变量x上，而不仅仅是当前行上的变量x。例如，如果我们将鼠标悬停在第12行x上，我们将看到相同的值:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-Watch3-min.png" alt="img"></p></blockquote></li><li><p>如果你在使用Visual Studio，你也可以使用<strong>QuickWatch</strong>。用鼠标高亮显示变量名x，然后从右键菜单中选择“QuickWatch”。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-QuickWatch1-min.png" alt="img"></p><p>这将打开一个包含变量当前值的子窗口:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-QuickWatch2-min.png" alt="img"></p><p>如果你打开了QuickWatch，请关闭它</p></li></ul><h2 id="监视窗口"><a href="#监视窗口" class="headerlink" title="监视窗口"></a>监视窗口</h2><p>如果你想知道一个变量的值在一个特定的时间点 ，使用<strong>鼠标悬停</strong>或<strong>QuickWatch</strong>方法检查变量很好。但是，它并不特别适合在运行代码时监视变量更改的值，因为您必须不断地 重新悬停/重新选择变量。</p><p>为了解决这个问题，所有现代集成调试器都提供了另一个特性，称为<strong>监视窗口</strong>。</p><p><strong>监视窗口</strong>是一个窗口，您可以在其中添加您想要持续检查的变量，并且当您单步执行程序时，这些变量将被更新。</p><p>当您进入调试模式时，监视窗口可能已经在您的屏幕上了，但是如果不是这样，您可以通过IDE的窗口命令(通常在视图或调试菜单中可以找到这些命令)打开它。</p><blockquote><p><strong>For Visual Studio users</strong></p><p>在Visual Studio中，<em>Debug menu &gt; Windows &gt; Watch &gt; Watch 1</em>. 中可以找到监视菜单。请注意，<strong>要启用此选项，必须处于调试模式，因此请先进入程序。</strong></p><p>此窗口出现的位置(停靠左、右或底部)可能不同。您可以通过将Watch 1选项卡拖动到应用程序窗口的另一侧来更改其停靠位置。</p></blockquote><p>超出作用域的变量(例如，函数中已经返回给调用者的局部变量)将留在您的监视窗口中，但通常要么被标记为“不可用”，要么显示最后一个已知值，但显示为灰色。如果变量返回到作用域(例如再次调用函数)，它的值将再次显示。因此，即使变量不在监视范围内，也可以将它们留在监视窗口中。</p><h2 id="监视窗口可以计算表达式"><a href="#监视窗口可以计算表达式" class="headerlink" title="监视窗口可以计算表达式"></a>监视窗口可以计算表达式</h2><p><strong>监视窗口</strong>还允许计算简单表达式。</p><h2 id="局部监视"><a href="#局部监视" class="headerlink" title="局部监视"></a>局部监视</h2><p>因为在调试时检查函数内部局部变量的值是很常见的，所以许多调试器会提供某种方式来快速监视 作用域中所有局部变量的值。</p><blockquote><p><strong>For Visual Studio users</strong></p><p>在Visual Studio中，可以在<strong>局部变量窗口</strong>中看到所有局部变量的值，可以在<em>Debug menu &gt; Windows &gt; Locals</em> 中找到。请注意，<strong>您必须处于调试会话中才能激活此窗口。</strong></p></blockquote><h1 id="使用集成调试器-调用栈"><a href="#使用集成调试器-调用栈" class="headerlink" title="使用集成调试器: 调用栈"></a>使用集成调试器: 调用栈</h1><p>现代调试器还包含一个调试信息窗口，它在调试程序时非常有用，即<strong>调用堆栈窗口</strong>。</p><p>当您的程序调用一个函数时，您已经知道它标记了当前位置，进行了函数调用，然后返回。它怎么知道回到哪里去? <strong>答案是它在调用堆栈中保持跟踪</strong>。</p><p>调用堆栈是所有已被调用以到达当前执行点的活动函数的列表。调用堆栈包括每个被调用函数的条目，以及函数返回时将返回到哪一行代码。</p><p>每当调用一个新函数时，该函数都会被添加到调用堆栈的顶部。当 当前函数返回给调用方时，它将从调用堆栈的顶部移除，而控制将返回给它下面的函数。</p><p><strong>“调用堆栈”窗口</strong>是一个显示当前调用堆栈的调试器窗口。如果没有看到“调用堆栈”窗口，则需要告诉IDE显示它。</p><blockquote><p><strong>For Visual Studio users</strong></p><p>在Visual Studio中，可以通过 <em>Debug menu &gt; Windows &gt; Call Stack</em>。请注意，<strong>您必须处于调试会话中才能激活此窗口。</strong></p></blockquote><hr><p>祝贺您，现在您已经了解了使用集成调试器的基本知识!通过使用单步执行、断点、监视和调用堆栈窗口，您现在已经具备了调试几乎所有问题的基础知识。</p><p>像许多事情一样，要想熟练使用调试器，需要一些实践和反复试验。但是，我们再次重申，花在学习如何有效使用集成调试器上的时间将比花在调试程序上的时间节省许多倍!</p><h1 id="在问题变成问题之前找到问题"><a href="#在问题变成问题之前找到问题" class="headerlink" title="在问题变成问题之前找到问题"></a>在问题变成问题之前找到问题</h1><p>当您犯语义错误时，当您运行程序时，这个错误可能不会立即被发现。一个问题可能潜伏在你的代码中很长一段时间都没有被发现，直到新引入的代码或改变的环境导致它作为程序故障出现。</p><p>在找到错误之前，错误在代码库中停留的时间越长，就越有可能难以找到它，本来很容易修复的错误会变成一场耗费时间和精力的调试冒险。</p><p>我们能做些什么呢?</p><h2 id="不要犯错误"><a href="#不要犯错误" class="headerlink" title="不要犯错误"></a>不要犯错误</h2><p>最好的办法是一开始就不要犯错误。这里有一个不完整的清单，可以帮助避免犯错误:</p><ul><li>遵循最佳实践</li><li>累了就别编程</li><li>了解一门语言中常见的陷阱(我们警告过你不要做的所有事情)</li><li>保持程序简单</li><li>不要让函数太长</li><li>尽可能使用标准库而不是编写自己的代码。</li><li>使用注释</li></ul><h2 id="重构功能"><a href="#重构功能" class="headerlink" title="重构功能"></a>重构功能</h2><p>当您向程序添加新功能(“行为更改”)时，您会发现一些函数的长度在增加。随着函数变长，它们变得更加复杂和难以理解。</p><p>解决这个问题的一种方法是将一个长函数分解成多个短函数。在不改变代码行为(通常是为了使其更易于维护)的情况下对代码进行结构更改的过程称为<strong>重构</strong>。</p><blockquote><p>那么对于一个函数，多长才算长呢?</p><p>一个占据一个垂直屏幕的函数通常被认为太长——如果必须滚动才能阅读整个函数，那么函数的可理解性就会显著下降。但是越短越好——函数小于10行就很好。小于5行的函数甚至更好。</p></blockquote><h2 id="介绍防御性编程"><a href="#介绍防御性编程" class="headerlink" title="介绍防御性编程"></a>介绍防御性编程</h2><p>错误不仅可能是您自己造成的(例如，不正确的逻辑)，还可能发生在您的用户以您没有预料到的方式使用应用程序时。</p><blockquote><p>例如，如果您要求用户输入一个整数，而用户输入的却是字母，那么在这种情况下，您的程序是如何运行的呢?除非您预料到了这一点，并为本例添加了一些错误处理，否则情况可能不太好。</p></blockquote><p><strong>防御性编程</strong>是一种实践，程序员试图预测软件可能被最终用户或使用代码的其他开发人员(包括程序员自己)滥用的所有方式。这些误用通常可以被发现，然后减轻(例如，要求输入错误输入的用户重试)。</p><p>我们将在以后的课程中探索与错误处理相关的主题。</p><h2 id="快速找到错误"><a href="#快速找到错误" class="headerlink" title="快速找到错误"></a>快速找到错误</h2><p>由于在大型程序中不出错是很困难的，所以下一个最好的方法就是快速捕获您确实犯的错误。</p><p><strong>最好的方法是每次编写一点程序，然后测试代码并确保它能正常工作。</strong></p><p>然而，还有一些其他的技术我们也可以使用。</p><h3 id="测试功能介绍"><a href="#测试功能介绍" class="headerlink" title="测试功能介绍"></a>测试功能介绍</h3><p>帮助发现程序问题的一种常见方法是<strong>编写测试函数来“练习”所编写的代码</strong>。这里有一个原始的尝试，更多的是为了说明的目的比任何东西:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testadd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"This function should print: 2 0 0 -2\n"</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">1</span>, <span class="number">1</span>) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">-1</span>, <span class="number">1</span>) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">1</span>, <span class="number">-1</span>) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">-1</span>, <span class="number">-1</span>) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	testadd();</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>testadd()函数通过使用不同的值调用add()函数来测试它。如果所有的值都符合我们的期望，那么我们就可以合理地确信函数是有效的。更好的是，我们可以保留这个函数，并在每次更改函数add时运行它，以确保我们没有意外地破坏它。</p><p>这是<strong>单元测试</strong>的基本形式，<strong>单元测试是一种软件测试方法，通过测试小单元的源代码来确定它们是否正确。</strong></p><p>与日志记录框架一样，可以使用许多第三方单元测试框架。也可以自己编写，不过我们需要更多的语言特性来处理主题。我们将在以后的课程中对此进行讨论。</p><h3 id="约束条件介绍"><a href="#约束条件介绍" class="headerlink" title="约束条件介绍"></a>约束条件介绍</h3><p>基于约束的技术包括添加一些额外的代码(如果需要，可以在非调试版本中编译)，以检查是否违反了一些假设或期望。</p><p>例如，如果我们编写一个函数来计算一个数字的阶乘，这个函数需要一个非负参数，那么该函数可以进行检查，以确保调用者在继续之前传入了一个非负的数字。如果调用方传入一个负数，那么函数可能会立即出错，而不是生成一些不确定的结果，从而帮助确保立即捕获问题。</p><p><strong>一种常见的方法是通过assert和static_assert</strong>，我们在<strong><a href="https://www.learncpp.com/cpp-tutorial/7-12a-assert-and-static_assert/" target="_blank" rel="noopener">7.12a – Assert and static_assert</a>.</strong>中介绍了这两个方法。</p></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/d30baea4.html">C&C++/静态与动态链接库</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月31日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：1.8k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：6分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/a1-static-and-dynamic-libraries/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/a1-static-and-dynamic-libraries/</a></p><hr><p><strong>库(library)</strong>是一个代码包，可以被许多程序重用。通常，一个c++库分为两部分:</p><ul><li>一个<strong>头文件</strong>，定义库向使用它的程序公开(提供)的功能。</li><li>预编译的<strong>二进制文件</strong>，包含预编译成机器语言的功能的实现。</li></ul><p><strong>一些库可能被分成多个文件和/或具有多个头文件。</strong></p><p><strong>预编译库</strong>有几个原因：</p><ul><li>首先，由于库很少更改，它们不需要经常重新编译。每次编写使用它们的程序时都重新编译库是浪费时间。</li><li>其次，因为预编译对象是机器语言的，所以它阻止人们访问或更改源代码，这对于企业或不希望出于知识产权原因而提供源代码的人来说非常重要。</li></ul><p>有两种类型的库:</p><ul><li><strong>静态库</strong></li><li><strong>动态库</strong></li></ul><h1 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h1><p><strong>静态库(也称为归档库(archive))</strong>由一些<strong>例程(routines)</strong>组成，这些例程被编译并直接链接到程序中。当您编译一个使用静态库的程序时，<u>程序所使用的静态库的所有功能都将成为可执行文件的一部分。</u></p><blockquote><p>在Windows中，静态库通常有一个<strong><code>.lib</code>扩展名</strong>；</p><p>而在linux上，静态库通常有一个<strong><code>.a</code>(存档)扩展名</strong>。</p></blockquote><p>静态库的一个<strong>优点</strong>是，您只需要分发可执行文件就可以让用户运行您的程序。</p><p>因为静态库成为程序的一部分，这就确保了程序总是使用正确版本的库；此外，因为静态库成为程序的一部分，所以可以像使用为自己的程序编写的功能一样使用它们。</p><p><strong>不利</strong>的一面是，由于库的副本成为使用它的每个可执行文件的一部分，这会导致大量的空间浪费。静态库也不能轻松升级——要更新库，需要替换整个可执行文件。</p><h1 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h1><p><strong>动态库(也称为共享库)</strong>由在<strong><u>运行时</u></strong>加载到应用程序中的例程组成。当您编译使用动态库的程序时，该库不会成为可执行文件的一部分——它仍然是一个单独的单元。</p><blockquote><p>在Windows上，动态库通常有一个<strong><code>.dll</code>(动态链接库)扩展名</strong>；</p><p>而在Linux上，动态库通常有一个<strong><code>.so</code>(共享对象)扩展名</strong>。</p></blockquote><p>动态库的一个<strong>优点</strong>是许多程序可以共享一个副本，这节省了空间。也许一个更大的优点是：动态库可以升级到一个新的版本，而不需要替换使用它的所有可执行文件。</p><p><strong>缺点</strong>：</p><p>因为动态库没有链接到程序中，所以使用动态库的程序<u>必须显式地加载动态库并与之交互</u>。这种机制可能会让人感到困惑，并使与动态库的交互变得非常棘手。</p><p><u>为了使动态库更易于使用，可以使用<strong>导入库( import library )</strong></u>。</p><p><strong>导入库</strong>是一个自动加载和使用动态库过程的库。</p><blockquote><p>在Windows上，这通常是通过一个与动态库(.dll)同名 的 <strong>小型静态库(.lib)</strong> 来完成的。静态库在<strong>编译时</strong>链接到程序中，然后动态库的功能 就可以 <u>像静态库一样</u> 有效地使用。</p><p>在Linux上，<strong>共享对象(.so)文件</strong>同时充当 动态库 和 导入库 。大多数链接器 可以在创建动态库时 为 动态库构建导入库。</p></blockquote><h1 id="安装和使用库"><a href="#安装和使用库" class="headerlink" title="安装和使用库"></a>安装和使用库</h1><p>现在您已经了解了不同种类的库，让我们讨论一下如何在程序中实际使用库。在c++中安装一个库通常需要4个步骤:</p><ul><li><ol><li><strong>获取库</strong>。</li></ol><blockquote><p>最好的选择是为您的操作系统下载一个预编译包(如果存在的话)，这样您就不必自己编译库了。</p><p>如果您的操作系统没有提供这样的包，那么您必须下载一个<u>只包含源代码的包</u>并自己编译它(这超出了本课的范围)。</p></blockquote><p>在Windows上，库通常以<code>.zip</code>文件的形式发布。</p><p>在Linux上，库通常以包的形式发布(例如<code>. rpm</code>)。</p><p>您的包管理器可能有一些比较流行的库(例如 SDL)。已经列出了，以便于安装，所以先检查一下。</p></li><li><ol start="2"><li><strong>安装库</strong>。</li></ol><p>在Linux上，这通常涉及调用包管理器并让它完成所有工作。</p><p>在Windows上，这通常涉及到将库解压缩到您选择的目录。</p><blockquote><p>我们建议将所有库保存在一个位置，以便于访问。例如，<strong>使用一个名为C:\Libs的目录，并将每个库放在它自己的子目录中。</strong></p></blockquote></li><li><ol start="3"><li><strong>确保编译器知道在哪里查找库的头文件</strong>。</li></ol><p>在Windows上，通常这是安装库文件到的目录的include子目录(例如。如果您将您的库安装到C:\libs\SDL-1.2.11，头文件可能在C:\libs\SDL-1.2.11\include中)。</p><p>在Linux上，头文件通常安装在/usr/include中，它应该已经是包含文件搜索路径的一部分。但是，如果文件安装在其他地方，则必须告诉编译器在哪里找到它们。</p></li><li><ol start="4"><li><strong>告诉链接器在哪里查找库文件</strong>。与步骤3一样，这通常涉及将目录添加到链接器查找库的位置列表中。</li></ol><p>在Windows上，这通常是安装库文件的目录的<code>/lib</code>子目录。</p><p>在Linux上，库通常安装在<code>/usr/lib</code>上，它应该已经是库搜索路径的一部分。</p></li></ul><p>一旦库被安装，IDE知道到哪里去找它，通常需要为每个想要使用库的项目执行以下3个步骤:</p><ul><li><ol start="5"><li><strong>如果使用静态库或导入库，请告诉链接器要链接哪个库文件</strong>。</li></ol></li><li><ol start="6"><li><p><strong>在程序中#include 库的头文件</strong>。</p><p>这将告诉编译器库所提供的所有功能，以便您的程序能够正确地编译。</p></li></ol></li><li><ol start="7"><li><strong>如果使用动态库，请确保程序知道在哪里可以找到它们</strong>。</li></ol><p>在Linux下，库通常安装在/usr/lib中，它位于LD_LIBRARY_PATH环境变量中的路径之后的默认搜索路径中。</p><p>在Windows上，默认的搜索路径包括：程序运行的目录、通过调用SetDllDirectory()设置的目录、Windows、System和System32目录以及path环境变量中的目录。</p><blockquote><p>使用.dll的最简单方法是将.dll复制到可执行文件的位置。由于您通常会将.dll与可执行文件一起发布，因此无论如何将它们放在一起都是有意义的。</p></blockquote></li></ul><p>步骤3-5涉及到配置IDE——</p><ul><li><p>幸运的是，几乎所有ide在执行这些操作时都以相同的方式工作。</p></li><li><p>不幸的是，因为每个IDE都有不同的接口，所以这个过程中最困难的部分就是找到执行这些步骤的正确位置。</p></li></ul></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/60adc21f.html">C&C++/文件的随机IO</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月28日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：754字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：3分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/187-random-file-io/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/187-random-file-io/</a></p><hr><h1 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h1><p>类中的每个文件流类都包含一个<strong>文件指针</strong>，用于跟踪当前的读/写位置文件。</p><p>当从文件中读取或写入文件时，读取/写入发生在文件指针的当前位置。</p><blockquote><p>默认情况，<strong>当打开文件进行读写操作时，文件指针被设置为文件的开头</strong>。</p><p>但是，<strong>如果以追加模式打开文件</strong>，文件指针就会移动到文件的<strong>末尾</strong>，这样写入操作就不会覆盖文件的任何当前内容。</p></blockquote><h1 id="使用seekg-和seekp-随机访问文件"><a href="#使用seekg-和seekp-随机访问文件" class="headerlink" title="使用seekg()和seekp()随机访问文件"></a>使用seekg()和seekp()随机访问文件</h1><p>之前，我们访问的文件都是按顺序访问的。——也就是说，我们之前是按顺序读取或写入文件内容。</p><p>但是，也可以进行<strong>随机文件访问</strong>。——即，跳过文件中的各个点，来读其内容。</p><blockquote><p>当您的文件中充满了记录，并且您希望检索特定的记录时，这将非常有用。</p></blockquote><p>随机访问文件 是通过<code>seekg()</code>函数(用于input) 和 <code>seekp()</code>函数(用于output) 来操作文件指针。</p><blockquote><p>其中：“g”表示：get ；“p”表示：put。</p></blockquote><p>对于某些类型的流、seekg()(更改读位置) 和 seekp()(更改写位置) 独立操作。</p><p><strong>但是对于，文件流：读和写位置总是相同的，所以可以使用seekg和seekp互换。</strong></p><p><code>seekg()</code>和<code>seekp()</code>函数接受两个参数。</p><ul><li>第一个参数：是决定文件指针的偏移量。</li><li>第二个参数：是一个Ios标志，它指定偏移量参数应该从哪里偏移。</li></ul><table><thead><tr><th>Ios seek flag</th><th>Meaning</th></tr></thead><tbody><tr><td>beg</td><td>the offset is relative to the begining of the file(default)</td></tr><tr><td>cur</td><td>the offset is relative to the current location of the file pointer</td></tr><tr><td>end</td><td>the offset is relative to the end of the file</td></tr></tbody></table><p><strong>正偏移</strong>量意味着将文件指针移动到文件末尾，而<strong>负偏移</strong>意味着将文件指针移动指向文件开头。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inf.seekg(<span class="number">14</span>, ios::cur); <span class="comment">// move forward 14 bytes</span></span><br><span class="line">inf.seekg(<span class="number">-18</span>, ios::cur); <span class="comment">// move backwards 18 bytes</span></span><br><span class="line">inf.seekg(<span class="number">22</span>, ios::beg); <span class="comment">// move to 22nd byte in file</span></span><br><span class="line">inf.seekg(<span class="number">24</span>); <span class="comment">// move to 24th byte in file</span></span><br><span class="line">inf.seekg(<span class="number">-28</span>, ios::<span class="built_in">end</span>); <span class="comment">// move to the 28th byte before end of the file</span></span><br></pre></td></tr></table></figure><p>移动到文件的开头或结尾很容易:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inf.seekg(<span class="number">0</span>, ios::beg); <span class="comment">// move to beginning of file</span></span><br><span class="line">inf.seekg(<span class="number">0</span>, ios::<span class="built_in">end</span>); <span class="comment">// move to end of file</span></span><br></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>让我们使用<code>seekg()</code>和我们在上一课中创建的输入文件来做一个示例。这个输入文件看起来像这样:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">This is <span class="built_in">line</span> <span class="number">1</span></span><br><span class="line">This is <span class="built_in">line</span> <span class="number">2</span></span><br><span class="line">This is <span class="built_in">line</span> <span class="number">3</span></span><br><span class="line">This is <span class="built_in">line</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>下面是代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="function">ifstream <span class="title">inf</span><span class="params">(<span class="string">"Sample.dat"</span>)</span></span>;</span><br><span class="line">    <span class="comment">// If we couldn't open the input file stream for reading</span></span><br><span class="line">    <span class="keyword">if</span> (!inf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Print an error and exit</span></span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Uh oh, Sample.dat could not be opened for reading!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> strData;</span><br><span class="line">    inf.seekg(<span class="number">5</span>); <span class="comment">// move to 5th character</span></span><br><span class="line">    <span class="comment">// Get the rest of the line and print it</span></span><br><span class="line">    getline(inf, strData);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; strData &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    inf.seekg(<span class="number">8</span>, ios::cur); <span class="comment">// move 8 more bytes into file</span></span><br><span class="line">    <span class="comment">// Get rest of the line and print it</span></span><br><span class="line">    getline(inf, strData);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; strData &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    inf.seekg(<span class="number">-15</span>, ios::<span class="built_in">end</span>); <span class="comment">// move 15 bytes before end of file</span></span><br><span class="line">    <span class="comment">// Get rest of the line and print it</span></span><br><span class="line">    getline(inf, strData);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; strData &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/2926b12b.html">C&C++/文件的基本IO</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月28日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：1.9k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：8分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/186-basic-file-io/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/186-basic-file-io/</a></p><hr><p>c++中的文件I/O的工作方式与普通I/O非常相似(只是增加了一些细微的复杂性)。</p><p>在c++中有3个基本的文件I/O类:（<strong>头文件<code>fstream</code>中</strong>）</p><ul><li><code>ifstream</code> (derived from istream),</li><li><code>ofstream</code> (derived from ostream),</li><li><code>fstream</code> (derived from iostream).</li></ul><p>这些类分别执行文件 <strong>输入</strong>、<strong>输出</strong>和 <strong>输入/输出</strong>。</p><p>与cout、cin、cerr和clog流不同，<strong>文件流必须由程序员显式地设置。</strong></p><p>然而，这非常简单:</p><ul><li>要打开文件进行读取 和/或 写入，只需实例化适当文件I/O类的一个对象，以文件的名称作为参数。然后使用插入(&lt;&lt;)或提取(&gt;&gt;)操作符来写入或读取文件中的数据。</li><li>一旦你完成，有几种方法来<strong>关闭</strong>一个文件:<ul><li>显式调用close()函数，</li><li>或者只需让文件I/O变量超出范围 (文件I/O类析构函数将为您关闭文件)。</li></ul></li></ul><h1 id="文件输出"><a href="#文件输出" class="headerlink" title="文件输出"></a>文件输出</h1><p>要在下面的示例中执行文件输出，我们将使用<strong>ofstream类</strong>。这是非常直接的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ofstream用于编写文件</span></span><br><span class="line">	<span class="comment">//我们将创建一个名为Sample.dat的文件</span></span><br><span class="line">    <span class="built_in">std</span>::ofstream outf&#123; <span class="string">"Sample.dat"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 如果我们不能打开输出文件流进行写入</span></span><br><span class="line">    <span class="keyword">if</span> (!outf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 打印错误并退出</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Uh oh, Sample.dat could not be opened for writing!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 我们将在这个文件中写入两行</span></span><br><span class="line">    outf &lt;&lt; <span class="string">"This is line 1"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    outf &lt;&lt; <span class="string">"This is line 2"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 当outf超出范围时，ofstream析构函数将关闭文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果查看项目目录，应该会看到一个名为Sample.dat的文件。如果您使用文本编辑器打开它，您将看到它确实包含我们写入文件的两行。</p><blockquote><p>注意，也可以使用put()函数将<strong>单个</strong>字符写入文件。</p></blockquote><h1 id="文件输入"><a href="#文件输入" class="headerlink" title="文件输入"></a>文件输入</h1><p>现在，我们将获取我们在上一个示例中编写的文件，并将其从磁盘读入。</p><p>注意，如果我们到达了文件的末尾(EOF)， ifstream将返回0。我们将使用这个事实来决定需要读多少。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ifstream用于读取文件</span></span><br><span class="line">	<span class="comment">// 我们将从一个名为Sample.dat的文件中进行读取</span></span><br><span class="line">    <span class="built_in">std</span>::ifstream inf&#123; <span class="string">"Sample.dat"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// If we couldn't open the output file stream for reading</span></span><br><span class="line">    <span class="keyword">if</span> (!inf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Print an error and exit</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Uh oh, Sample.dat could not be opened for reading!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 还有很多东西要读</span></span><br><span class="line">    <span class="keyword">while</span> (inf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将文件中的内容读入一个字符串并打印出来</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> strInput;</span><br><span class="line">        inf &gt;&gt; strInput;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; strInput &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// When inf goes out of scope, the ifstream</span></span><br><span class="line">    <span class="comment">// destructor will close the file</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">This</span><br><span class="line">is</span><br><span class="line"><span class="built_in">line</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">This</span><br><span class="line">is</span><br><span class="line"><span class="built_in">line</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>嗯，那不是我们想要的。请记住，<strong>提取操作符会在空格处中断</strong>。为了整行读取，<strong>我们必须使用getline()函数。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ifstream is used for reading files</span></span><br><span class="line">    <span class="comment">// We'll read from a file called Sample.dat</span></span><br><span class="line">    <span class="built_in">std</span>::ifstream inf&#123; <span class="string">"Sample.dat"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// If we couldn't open the input file stream for reading</span></span><br><span class="line">    <span class="keyword">if</span> (!inf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Print an error and exit</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Uh oh, Sample.dat could not be opened for reading!\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// While there's still stuff left to read</span></span><br><span class="line">    <span class="keyword">while</span> (inf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// read stuff from the file into a string and print it</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> strInput;</span><br><span class="line">        <span class="built_in">std</span>::getline(inf, strInput); <span class="comment">//⭐⭐⭐</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; strInput &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// When inf goes out of scope, the ifstream</span></span><br><span class="line">    <span class="comment">// destructor will close the file</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">This is <span class="built_in">line</span> <span class="number">1</span></span><br><span class="line">This is <span class="built_in">line</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h1 id="缓冲输出"><a href="#缓冲输出" class="headerlink" title="缓冲输出"></a>缓冲输出</h1><p><strong>c++的输出可以被缓冲。</strong></p><blockquote><p>这意味着输出到文件流的任何内容都可能<strong>不会立即写入磁盘</strong>。相反，几个输出操作可以成批处理并一起处理。</p></blockquote><p>这主要是出于性能原因。</p><h2 id="刷新缓冲区"><a href="#刷新缓冲区" class="headerlink" title="刷新缓冲区"></a>刷新缓冲区</h2><p>当将缓冲区写入磁盘时，这称为<strong>刷新缓冲区</strong>。</p><h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p><u>使缓冲区被刷新的一种方法是<strong>关闭文件</strong></u>——缓冲区的内容将被刷新到磁盘，然后文件将被关闭。</p><p>缓冲通常不是问题，但在某些情况下，它会给粗心大意的人带来麻烦。</p><ul><li><p>这种情况下的罪魁祸首是<strong>当缓冲区中有数据时，程序立即 终止</strong>(通过崩溃或调用exit())。<u>在这些情况下，文件流类的析构函数不会被执行，这意味着文件永远不会被关闭，这意味着缓冲区永远不会被刷新。</u></p><p><strong>在这种情况下，缓冲区中的数据不写入磁盘，而是永远丢失</strong>。<u>这就是为什么在调用exit()之前显式地关闭所有打开的文件总是一个好主意。</u></p></li></ul><h3 id="手动刷新"><a href="#手动刷新" class="headerlink" title="手动刷新"></a>手动刷新</h3><ul><li><p><strong>可以使用<code>ostream::flush()</code>函数手动刷新缓冲区</strong>，</p></li><li><p><strong>或者将<code>std::flush</code>发送到输出流</strong>。</p></li></ul><p>这两种方法都有助于确保缓冲区的内容被立即写入磁盘，以防程序崩溃。</p><p><strong>有趣的是<code>std::endl</code>; 也刷新输出流。</strong></p><ul><li>因此，过度使用std::endl(导致不必要的缓冲区刷新) 会在执行开销很大的缓冲I/O(例如写入文件)时对性能造成影响。</li></ul><p>出于这个原因，关心性能的<strong>程序员通常会使用’ \n ‘而不是std::endl来将换行符插入到输出流中</strong>，以避免不必要的缓冲区刷新。</p><h1 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h1><p>如果我们试图<strong>写入</strong>一个已经存在的文件，会发生什么? 再次运行输出示例 表明，每次运行程序时，原始文件都被完全覆盖。</p><p><strong>如果我们想要在文件的末尾追加更多的数据</strong>，该怎么办?</p><ul><li><p>结果是，<strong>文件流构造函数接受一个可选的第二个参数，该参数允许您指定有关文件应该如何打开的信息。</strong></p></li><li><p>这个参数称为<strong>mode</strong>，它接受的有效标志（<strong>位于Ios类中</strong>）。</p></li></ul><table><thead><tr><th align="left">Ios file mode</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">app</td><td align="left">Opens the file in append mode</td></tr><tr><td align="left">ate</td><td align="left">Seeks to the end of the file before reading/writing</td></tr><tr><td align="left">binary</td><td align="left">Opens the file in binary mode (instead of text mode)</td></tr><tr><td align="left">in</td><td align="left">Opens the file in read mode (default for ifstream)</td></tr><tr><td align="left">out</td><td align="left">Opens the file in write mode (default for ofstream)</td></tr><tr><td align="left">trunc</td><td align="left">Erases the file if it already exists</td></tr></tbody></table><p><strong>可以通过位操作(使用<code>|</code>操作符)指定多个标志。</strong></p><p>在文件模式下，</p><ul><li>Ifstream默认为<code>std::ios::in</code>；</li><li>Ofstream默认为<code>std::ios::out</code>文件模式。</li><li>fstream 默认为<code>std::ios::in | std::ios::out</code>文件模式，这意味着你可以在默认情况下读和写。</li></ul><p>让我们编写一个程序，在前面创建的Sample.dat文件中追加两行代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 我们会传递ios:app标志告诉ofstream去追加</span></span><br><span class="line">	<span class="comment">// 而不是重写文件。我们不需要通过std::ios::out</span></span><br><span class="line">	<span class="comment">// 因为ofstream默认std::ios::out</span></span><br><span class="line">    <span class="built_in">std</span>::ofstream outf&#123; <span class="string">"Sample.dat"</span>, <span class="built_in">std</span>::ios::app &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// If we couldn't open the output file stream for writing</span></span><br><span class="line">    <span class="keyword">if</span> (!outf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Print an error and exit</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Uh oh, Sample.dat could not be opened for writing!\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    outf &lt;&lt; <span class="string">"This is line 3"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    outf &lt;&lt; <span class="string">"This is line 4"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// When outf goes out of scope, the ofstream</span></span><br><span class="line">    <span class="comment">// destructor will close the file</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">This is line 1</span><br><span class="line">This is line 2</span><br><span class="line">This is line 3</span><br><span class="line">This is line 4</span><br></pre></td></tr></table></figure><h1 id="使用open-显式打开文件"><a href="#使用open-显式打开文件" class="headerlink" title="使用open()显式打开文件"></a>使用open()显式打开文件</h1><p>就像可以使用<strong>close()显式地关闭文件流</strong>一样，也可以使用<strong>open()显式地打开文件流</strong>。</p><ul><li>open()的工作原理与文件流构造函数类似——<strong>它接受一个文件名和一个可选的文件模式。</strong></li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::ofstream outf&#123; <span class="string">"Sample.dat"</span> &#125;;</span><br><span class="line">outf &lt;&lt; <span class="string">"This is line 1"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">outf &lt;&lt; <span class="string">"This is line 2"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">outf.<span class="built_in">close</span>(); <span class="comment">// 显式关闭文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 追加一行</span></span><br><span class="line">outf.<span class="built_in">open</span>(<span class="string">"Sample.dat"</span>, <span class="built_in">std</span>::ios::app);</span><br><span class="line">outf &lt;&lt; <span class="string">"This is line 3\n"</span>;</span><br><span class="line">outf.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><p>其他参考文章：</p><p><a href="https://www.runoob.com/cplusplus/cpp-files-streams.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/cpp-files-streams.html</a></p></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/ba87b609.html">C&C++/流状态和输入验证</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月27日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：1.3k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：5分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/185-stream-states-and-input-validation/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/185-stream-states-and-input-validation/</a></p><hr><h1 id="流状态"><a href="#流状态" class="headerlink" title="流状态"></a>流状态</h1><p><strong><code>ios_base</code></strong>类包含几个状态标志，用来指示使用流时可能发生的各种情况:</p><table><thead><tr><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">goodbit</td><td align="left">Everything is okay</td></tr><tr><td align="left">badbit</td><td align="left">Some kind of fatal error occurred (e.g. the program tried to read past the end of a file)</td></tr><tr><td align="left">eofbit</td><td align="left">The stream has reached the end of a file</td></tr><tr><td align="left">failbit</td><td align="left">A non-fatal error occurred (eg. the user entered letters when the program was expecting an integer)</td></tr></tbody></table><p>虽然这些标志存在于<code>ios_base</code>中，因为<code>ios</code>是从<code>ios_base</code>派生而来的，而且<code>ios</code>比<code>ios_base</code>需要更少的输入，但它们通常是通过<code>ios</code>访问的(例如<code>std::ios::failbit</code>)。</p><p><strong><code>ios</code></strong>还提供了一些成员功能，以便方便地访问这些国家:</p><table><thead><tr><th align="left">Member function</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">good()</td><td align="left">Returns true if the goodbit is set (the stream is ok)</td></tr><tr><td align="left">bad()</td><td align="left">Returns true if the badbit is set (a fatal error occurred)</td></tr><tr><td align="left">eof()</td><td align="left">Returns true if the eofbit is set (the stream is at the end of a file)</td></tr><tr><td align="left">fail()</td><td align="left">Returns true if the failbit is set (a non-fatal error occurred)</td></tr><tr><td align="left">clear()</td><td align="left">Clears all flags and restores the stream to the goodbit state</td></tr><tr><td align="left">clear(state)</td><td align="left">Clears all flags and sets the state flag passed in</td></tr><tr><td align="left">rdstate()</td><td align="left">Returns the currently set flags</td></tr><tr><td align="left">setstate(state)</td><td align="left">Sets the state flag passed in</td></tr></tbody></table><p>最常处理的位是故障位 (failbit)，它是在用户输入无效输入时设置的。例如，考虑以下程序:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter your age: "</span>;</span><br><span class="line"><span class="keyword">int</span> nAge;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; nAge;</span><br></pre></td></tr></table></figure><p>注意，这个程序期望用户输入一个整数。但是，如果用户输入非数字数据，如“Alex”，cin将无法提取任何数据进行计数，并设置成故障位。</p><p>如果出现错误，并且将流设置为<code>goodbit</code>以外的任何内容。则将忽略该流上的进一步流操作。这个条件可以通过调用<code>clear()</code>函数来清除。</p><h1 id="输入验证"><a href="#输入验证" class="headerlink" title="输入验证"></a>输入验证</h1><p><strong>输入验证</strong>是检查用户输入是否满足某些条件的过程。输入验证通常可以分为两种类型: <strong>字符串</strong>和<strong>数字</strong>。</p><ul><li><p>对于<strong>字符串验证</strong>，我们接受所有用户输入作为一个字符串，然后根据其格式是否正确接受或拒绝该字符串。</p><p>在大多数语言中(特别是像Perl和PHP这样的脚本语言)，这是通过正则表达式完成的。但是，c++没有内置的正则表达式支持。</p><p>因此，这通常是通过检查字符串的每个字符来完成的，以确保它满足一些条件。</p></li><li><p>对于<strong>数字验证</strong>，我们通常关心的是确保用户输入的数字在一个特定的范围内(例如，在0到20之间)。但是，与字符串验证不同，用户可以输入完全不是数字的内容——我们也需要处理这些情况。</p></li></ul><p>为了帮助我们，c++提供了许多有用的函数，我们可以使用这些函数来确定特定字符是数字还是字母。<strong><code>cctype</code>头文件</strong>中有以下函数:</p><table><thead><tr><th align="left">Function</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">isalnum(int)</td><td align="left">Returns non-zero if the parameter is a letter or a digit</td></tr><tr><td align="left">isalpha(int)</td><td align="left">Returns non-zero if the parameter is a letter</td></tr><tr><td align="left">iscntrl(int)</td><td align="left">Returns non-zero if the parameter is a control character</td></tr><tr><td align="left">isdigit(int)</td><td align="left">Returns non-zero if the parameter is a digit</td></tr><tr><td align="left">isgraph(int)</td><td align="left">Returns non-zero if the parameter is printable character that is not whitespace</td></tr><tr><td align="left">isprint(int)</td><td align="left">Returns non-zero if the parameter is printable character (including whitespace)</td></tr><tr><td align="left">ispunct(int)</td><td align="left">Returns non-zero if the parameter is neither alphanumeric nor whitespace</td></tr><tr><td align="left">isspace(int)</td><td align="left">Returns non-zero if the parameter is whitespace</td></tr><tr><td align="left">isxdigit(int)</td><td align="left">Returns non-zero if the parameter is a hexadecimal digit (0-9, a-f, A-F)</td></tr></tbody></table><h2 id="字符串验证"><a href="#字符串验证" class="headerlink" title="字符串验证"></a>字符串验证</h2><p>让我们做一个简单的字符串验证，要求用户输入他们的名字。我们的验证标准是用户只输入字母字符或空格。如果遇到其他情况，输入将被拒绝。</p><blockquote><p><strong>当涉及到可变长度输入时</strong>，验证字符串的最佳方法(除了使用正则表达式库之外)是遍历字符串的每个字符，并确保它满足验证标准。这就是我们要做的。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Get user's name</span></span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter your name: "</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> strName;</span><br><span class="line">		<span class="built_in">std</span>::getline(<span class="built_in">cin</span>, strName); <span class="comment">// get the entire line, including spaces</span></span><br><span class="line"> </span><br><span class="line">		<span class="keyword">bool</span> bRejected&#123; <span class="literal">false</span> &#125;; <span class="comment">// has strName been rejected?</span></span><br><span class="line"> </span><br><span class="line">								<span class="comment">// Step through each character in the string until we either hit</span></span><br><span class="line">								<span class="comment">// the end of the string, or we rejected a character</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> nIndex&#123; <span class="number">0</span> &#125;; nIndex &lt; strName.length() &amp;&amp; !bRejected; ++nIndex)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// If the current character is an alpha character, that's fine</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">isalpha</span>(strName[nIndex]))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line">			<span class="comment">// If it's a space, that's fine too</span></span><br><span class="line">			<span class="keyword">if</span> (strName[nIndex] == <span class="string">' '</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line">			<span class="comment">// Otherwise we're rejecting this input</span></span><br><span class="line">			bRejected = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">// If the input has been accepted, exit the while loop</span></span><br><span class="line">		<span class="comment">// otherwise we're going to loop again</span></span><br><span class="line">		<span class="keyword">if</span> (!bRejected)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数值验证"><a href="#数值验证" class="headerlink" title="数值验证"></a>数值验证</h2><p>在处理数字输入时，最明显的方法是使用<strong>提取操作符</strong>将输入提取为数字类型。通过检查<strong>故障位</strong>，我们可以判断用户是否输入了数字。</p><p>让我们试试这个方法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nAge;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter your age: "</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; nAge;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">cin</span>.fail()) <span class="comment">// no extraction took place</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">clear</span>(); <span class="comment">// reset the state bits back to goodbit so we can use ignore()</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="number">32767</span>, <span class="string">'\n'</span>); <span class="comment">// clear out the bad input from the stream</span></span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// try again</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (nAge &lt;= <span class="number">0</span>) <span class="comment">// make sure nAge is positive</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"You entered: "</span> &lt;&lt; nAge &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用户输入一个数字，<code>cin.fail()</code>将为false，我们将按break语句，退出循环。如果用户输入以字母开头的输入，<code>cin.fail()</code>将为真，我们将进入条件句。</p><p>更多详细的讲解，请看<a href="https://www.learncpp.com/cpp-tutorial/185-stream-states-and-input-validation/" target="_blank" rel="noopener">原文</a>。这里先不写，说不定以后会补上<code>~~~~</code></p></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/4be6fd59.html">C&C++/字符串的流(stream)类</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月27日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：861字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：3分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/184-stream-classes-for-strings/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/184-stream-classes-for-strings/</a></p><hr><p>到目前为止，您看到的所有I/O示例都是写给cout或从cin读取的。</p><p>然而，还有另一组类叫做<strong>字符串的流类</strong>，它允许您使用熟悉的 插入(&lt;&lt;) 和 提取(&gt;&gt;)操作符来处理字符串。</p><p>与istream和ostream一样，字符串流提供了一个保存数据的缓冲区。但是，与cin和cout不同，这些流没有连接到I/O通道(例如键盘、监视器等)。<strong>字符串流的主要用途之一是缓冲输出以便以后显示，或者逐行处理输入。</strong></p><p>字符串有六个流类，：在<strong>头文件<code>sstream</code></strong>中。</p><ul><li><p>用于读取和写入正常字符宽度的字符串。</p><ul><li>istringstream(继承自istream)，</li><li>ostringstream(继承自ostream)，</li><li>stringstream(继承自iostream)</li></ul></li><li><p>用于读取和写入宽字符串。</p><ul><li>wistringstream</li><li>wostringstream</li><li>wstringstream</li></ul></li></ul><p>有两种方法可以将数据<strong>导入</strong>stringstream：</p><ol><li>使用插入(&lt;&lt;)操作符:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> os;</span><br><span class="line">os &lt;&lt; <span class="string">"en garde!"</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// insert "en garde!" into the stringstream</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用str(string)函数设置缓冲区的值:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> os;</span><br><span class="line">os.str(<span class="string">"en garde!"</span>); <span class="comment">// set the stringstream buffer to "en garde!"</span></span><br></pre></td></tr></table></figure><p>从stringstream中<strong>获取</strong>数据有两种类似的方法:</p><ol><li>使用str()函数检索缓冲区的结果:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> os;</span><br><span class="line">os &lt;&lt; <span class="string">"12345 67.89"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; os.str();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">12345</span> <span class="number">67.89</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用<strong>提取(&gt;&gt;)</strong>操作符:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> os;</span><br><span class="line">os &lt;&lt; <span class="string">"12345 67.89"</span>; <span class="comment">// insert a string of numbers into the stream</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> strValue;</span><br><span class="line">os &gt;&gt; strValue;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> strValue2;</span><br><span class="line">os &gt;&gt; strValue2;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// print the numbers separated by a dash</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; strValue &lt;&lt; <span class="string">" - "</span> &lt;&lt; strValue2 &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p>注意，<strong>&gt;&gt;操作符</strong>遍历字符串——每次连续使用&gt;&gt;都会返回流中的下一个可提取值。</p><p>另一方面，<strong>str()返回流的整个值</strong>，即使已经在流上使用了&gt;&gt;。</p><h1 id="字符串和数字之间的转换"><a href="#字符串和数字之间的转换" class="headerlink" title="字符串和数字之间的转换"></a>字符串和数字之间的转换</h1><p>因为插入和提取操作符知道如何处理所有基本数据类型，<strong>所以我们可以使用它们将字符串转换为数字，反之亦然。</strong></p><p>首先，让我们看看如何<strong>将数字转换成字符串</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> os;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> nValue&#123; <span class="number">12345</span> &#125;;</span><br><span class="line"><span class="keyword">double</span> dValue&#123; <span class="number">67.89</span> &#125;;</span><br><span class="line">os &lt;&lt; nValue &lt;&lt; <span class="string">' '</span> &lt;&lt; dValue;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> strValue1, strValue2;</span><br><span class="line">os &gt;&gt; strValue1 &gt;&gt; strValue2;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; strValue1 &lt;&lt; <span class="string">' '</span> &lt;&lt; strValue2 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">12345</span> <span class="number">67.89</span></span><br></pre></td></tr></table></figure><p>现在让我们把<strong>一个 数字 字符串 转换成一个数字</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> os;</span><br><span class="line">os &lt;&lt; <span class="string">"12345 67.89"</span>; <span class="comment">// insert a string of numbers into the stream</span></span><br><span class="line"><span class="keyword">int</span> nValue;</span><br><span class="line"><span class="keyword">double</span> dValue;</span><br><span class="line"> </span><br><span class="line">os &gt;&gt; nValue &gt;&gt; dValue;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; nValue &lt;&lt; <span class="string">' '</span> &lt;&lt; dValue &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">12345</span> <span class="number">67.89</span></span><br></pre></td></tr></table></figure><h1 id="清除stringstream以便重用"><a href="#清除stringstream以便重用" class="headerlink" title="清除stringstream以便重用"></a>清除stringstream以便重用</h1><p>有几种方法可以清空stringstream的缓冲区。</p><ol><li><p>使用str()与一个空白c风格的字符串 将它设置为空字符串:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> os;</span><br><span class="line">os &lt;&lt; <span class="string">"Hello "</span>;</span><br><span class="line"> </span><br><span class="line">os.str(<span class="string">""</span>); <span class="comment">// erase the buffer</span></span><br><span class="line"> </span><br><span class="line">os &lt;&lt; <span class="string">"World!"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; os.str();</span><br></pre></td></tr></table></figure></li><li><p>使用str()和一个空的std::string对象 将它设置为空字符串:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> os;</span><br><span class="line">os &lt;&lt; <span class="string">"Hello "</span>;</span><br><span class="line"> </span><br><span class="line">os.str(<span class="built_in">std</span>::<span class="built_in">string</span>&#123;&#125;); <span class="comment">// erase the buffer</span></span><br><span class="line"> </span><br><span class="line">os &lt;&lt; <span class="string">"World!"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; os.str();</span><br></pre></td></tr></table></figure><p>这两个程序产生以下相同的结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">World!</span><br></pre></td></tr></table></figure></li></ol><p><strong>当清除一个stringstream时，调用clear()函数通常也是一个好主意:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> os;</span><br><span class="line">os &lt;&lt; <span class="string">"Hello "</span>;</span><br><span class="line"> </span><br><span class="line">os.str(<span class="string">""</span>); <span class="comment">// erase the buffer</span></span><br><span class="line">os.<span class="built_in">clear</span>(); <span class="comment">// reset error flags</span></span><br><span class="line"> </span><br><span class="line">os &lt;&lt; <span class="string">"World!"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; os.str();</span><br></pre></td></tr></table></figure><p>clear()函数 重置可能已经设置的任何错误标志，并将流返回到ok状态。在下一课中，我们将更多地讨论流状态和错误标志。</p></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/927246b0.html">C&C++/ostream与ios 输出</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月27日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：2.9k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：14分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/183-output-with-ostream-and-ios/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/183-output-with-ostream-and-ios/</a></p><hr><p>在本节中，我们将研究iostream输出类(ostream)的各个方面。</p><p>注意:</p><p><strong>本课中的所有I/O功能都位于std名称空间中</strong>。<strong>这意味着所有I/O对象和函数要么必须以“std::”为前缀，要么必须使用“using namespace std;”语句。</strong></p><h1 id="插入操作符-lt-lt"><a href="#插入操作符-lt-lt" class="headerlink" title="插入操作符(&lt;&lt;)"></a>插入操作符(&lt;&lt;)</h1><p>插入操作符(&lt;&lt;)<strong>用于将信息放入输出流。</strong></p><p>c++为所有内置数据类型预定义了插入操作，您已经了解了如何为您自己的类[重载插入操作符](<a href="http://www.learncpp.com/cpp-tutorial/93-overloading-the-io-operators/" target="_blank" rel="noopener">overload the insertion operator</a>)。</p><p>在关于<a href="https://www.learncpp.com/cpp-tutorial/183-output-with-ostream-and-ios/" target="_blank" rel="noopener">Input and output (I/O) streams</a>的课程中，您看到istream和ostream都来自于一个名为ios的类。ios(和ios_base)的任务之一是控制输出的格式化选项。</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>有两种方法来改变格式选项:</p><ul><li><p><strong>标志(flag)</strong>——可以将标志看作可以打开和关闭的布尔变量。</p></li><li><p><strong>控制器(manipulator)</strong>——控制器 是放置在流中的对象，它影响输入和输出的方式。</p></li></ul><h2 id="标志-flag"><a href="#标志-flag" class="headerlink" title="标志(flag)"></a>标志(flag)</h2><p>要<strong>打开标志</strong>，请使用<strong>setf()</strong>函数，并将适当的标志作为参数。</p><p>例如，在默认情况下，c++不会在正数前面打印+符号。但是，通过使用std::ios::showpos标志，我们可以改变这个行为:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::showpos); <span class="comment">// turn on the std::ios::showpos flag</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这将产生以下输出:*/</span></span><br><span class="line">+<span class="number">27</span></span><br></pre></td></tr></table></figure><p>可以使用<strong>OR(|)操作符</strong>同时打开多个ios标志:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::showpos | <span class="built_in">std</span>::ios::uppercase); <span class="comment">// turn on the std::ios::showpos and std::ios::uppercase flag</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p>要<strong>关闭标志</strong>，请使用<strong>unsetf()</strong>函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::showpos); <span class="comment">// turn on the std::ios::showpos flag</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.unsetf(<span class="built_in">std</span>::ios::showpos); <span class="comment">// turn off the std::ios::showpos flag</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">28</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这将产生以下输出:*/</span></span><br><span class="line">+<span class="number">27</span></span><br><span class="line"><span class="number">28</span></span><br></pre></td></tr></table></figure><p>在使用setf()时，还有一个需要注意的问题。</p><ul><li>许多标志属于组，称为<strong>格式组(format group)</strong>。格式组是一组执行类似 (有时互斥) 格式选项的标志。</li></ul><p>例如，名为“basefield”的格式组包含标志“oct”、“dec”和“hex”，它们控制整数值的基数。默认情况下，设置“dec”标志。因此，如果我们这样做:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::hex); <span class="comment">// try to turn on hex output</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*我们得到如下输出:*/</span></span><br><span class="line"><span class="number">27</span></span><br></pre></td></tr></table></figure><p>它没有工作! <strong>原因是setf()只打开标志</strong>——因此，当我们打开std::hex时，std::ios::dec仍然是打开的，而std::ios::dec显然是优先的。有两种方法可以解决这个问题。</p><ul><li><p>首先，我们<strong>可以关闭std::ios::dec</strong>，这样就只设置了std::ios::hex:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.unsetf(<span class="built_in">std</span>::ios::dec); <span class="comment">// turn off decimal output</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::hex); <span class="comment">// turn on hexadecimal output</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">1b</span></span><br></pre></td></tr></table></figure></li><li><p>第二种方法是使用另一种形式的setf()，它有两个参数:</p><ul><li>第一个参数是要设置的标志，</li><li>第二个是它所属的格式化组。</li></ul><p>当使用这种形式的setf()时，属于这个组的所有标志都是关闭的，只有传入的标志是打开的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Turn on std::ios::hex as the only std::ios::basefield flag</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::hex, <span class="built_in">std</span>::ios::basefield);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">1b</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="控制器-manipulator"><a href="#控制器-manipulator" class="headerlink" title="控制器(manipulator)"></a>控制器(manipulator)</h2><p>使用setf()和unsetf()可能会有些笨拙，因此c++提供了第二种方法来更改格式化选项: <strong>控制器(manipulator)</strong>。</p><p>控制器的优点是他们足够聪明，<strong>能够打开和关闭适当的标志</strong>。</p><p>这里有一个例子，使用一些控制器来改变基地:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print 27 in hex</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">28</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// we're still in hex</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::dec &lt;&lt; <span class="number">29</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// back to decimal</span></span><br></pre></td></tr></table></figure><p>这个程序产生的输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1b</span><br><span class="line">1c</span><br><span class="line">29</span><br></pre></td></tr></table></figure><p><strong>通常，使用 控制器 比 设置和取消标志 要容易得多。</strong>许多选项可以通过标志和操作器(例如更改基数)来使用，但是，其他选项只能通过标志或操作器来使用，因此了解如何使用这两个选项非常重要。</p><h2 id="有用的格式器"><a href="#有用的格式器" class="headerlink" title="有用的格式器"></a>有用的格式器</h2><p>下面是一些更有用的标志、控制器和 成员函数 的列表。</p><ul><li><p><strong>标记</strong>位于<strong>std::ios</strong>类中</p></li><li><p><strong>控制器</strong>位于<strong>std名称空间</strong>中，</p></li><li><p><strong>成员函数</strong>位于<strong>std::ostream类</strong>中。</p></li></ul><table><thead><tr><th align="left">Group</th><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"></td><td align="left">std::ios::boolalpha</td><td align="left">If set, booleans print “true” or “false”. If not set, booleans print 0 or 1</td></tr></tbody></table><table><thead><tr><th align="left">Manipulator</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">std::boolalpha</td><td align="left">Booleans print “true” or “false”</td></tr><tr><td align="left">std::noboolalpha</td><td align="left">Booleans print 0 or 1 (default)</td></tr></tbody></table><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="literal">false</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::boolalpha);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="literal">false</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::noboolalpha &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="literal">false</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="literal">false</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="literal">true</span> <span class="literal">false</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="literal">true</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><hr><table><thead><tr><th align="left">Group</th><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"></td><td align="left">std::ios::showpos</td><td align="left">If set, prefix positive numbers with a +</td></tr></tbody></table><table><thead><tr><th align="left">Manipulator</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">std::showpos</td><td align="left">Prefixes positive numbers with a +</td></tr><tr><td align="left">std::noshowpos</td><td align="left">Doesn’t prefix positive numbers with a +</td></tr></tbody></table><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">5</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::showpos);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">5</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::noshowpos &lt;&lt; <span class="number">5</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::showpos &lt;&lt; <span class="number">5</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">+<span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">+<span class="number">5</span></span><br></pre></td></tr></table></figure><hr><table><thead><tr><th align="left">Group</th><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"></td><td align="left">std::ios::uppercase</td><td align="left">If set, uses upper case letters</td></tr></tbody></table><table><thead><tr><th align="left">Manipulator</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">std::uppercase</td><td align="left">Uses upper case letters</td></tr><tr><td align="left">std::nouppercase</td><td align="left">Uses lower case letters</td></tr></tbody></table><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">12345678.9</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::uppercase);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">12345678.9</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::nouppercase &lt;&lt; <span class="number">12345678.9</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::uppercase &lt;&lt; <span class="number">12345678.9</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">1.23457e+007</span></span><br><span class="line"><span class="number">1.23457E+007</span></span><br><span class="line"><span class="number">1.23457e+007</span></span><br><span class="line"><span class="number">1.23457E+007</span></span><br></pre></td></tr></table></figure><hr><table><thead><tr><th align="left">Group</th><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">std::ios::basefield</td><td align="left">std::ios::dec</td><td align="left">Prints values in decimal (default)</td></tr><tr><td align="left">std::ios::basefield</td><td align="left">std::ios::hex</td><td align="left">Prints values in hexadecimal</td></tr><tr><td align="left">std::ios::basefield</td><td align="left">std::ios::oct</td><td align="left">Prints values in octal</td></tr><tr><td align="left">std::ios::basefield</td><td align="left">(none)</td><td align="left">Prints values according to leading characters of value</td></tr></tbody></table><table><thead><tr><th align="left">Manipulator</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">std::dec</td><td align="left">Prints values in decimal</td></tr><tr><td align="left">std::hex</td><td align="left">Prints values in hexadecimal</td></tr><tr><td align="left">std::oct</td><td align="left">Prints values in octal</td></tr></tbody></table><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::dec, <span class="built_in">std</span>::ios::basefield);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::oct, <span class="built_in">std</span>::ios::basefield);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::hex, <span class="built_in">std</span>::ios::basefield);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::dec &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::oct &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; <span class="number">27</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">33</span></span><br><span class="line"><span class="number">1b</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">33</span></span><br><span class="line"><span class="number">1b</span></span><br></pre></td></tr></table></figure><p>现在，您应该能够通过标记和控制器查看设置格式之间的关系。在以后的示例中，我们将使用控制器，除非它们不可用。</p><h1 id="精度、符号和小数点"><a href="#精度、符号和小数点" class="headerlink" title="精度、符号和小数点"></a>精度、符号和小数点</h1><p>通过使用操作器(或标志)，可以更改显示浮点数的精度和格式。有几种格式化选项以某种复杂的方式组合在一起，因此我们将仔细研究这个问题。</p><table><thead><tr><th align="left">Group</th><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">std::ios::floatfield</td><td align="left">std::ios::fixed</td><td align="left">Uses decimal notation for floating-point numbers</td></tr><tr><td align="left">std::ios::floatfield</td><td align="left">std::ios::scientific</td><td align="left">Uses scientific notation for floating-point numbers</td></tr><tr><td align="left">std::ios::floatfield</td><td align="left">(none)</td><td align="left">Uses fixed for numbers with few digits, scientific otherwise</td></tr><tr><td align="left">std::ios::floatfield</td><td align="left">std::ios::showpoint</td><td align="left">Always show a decimal point and trailing 0’s for floating-point values</td></tr></tbody></table><table><thead><tr><th align="left">Manipulator</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">std::fixed</td><td align="left">Use decimal notation for values</td></tr><tr><td align="left">std::scientific</td><td align="left">Use scientific notation for values</td></tr><tr><td align="left">std::showpoint</td><td align="left">Show a decimal point and trailing 0’s for floating-point values</td></tr><tr><td align="left">std::noshowpoint</td><td align="left">Don’t show a decimal point and trailing 0’s for floating-point values</td></tr><tr><td align="left">std::setprecision(int)</td><td align="left">Sets the precision of floating-point numbers (defined in iomanip.h)</td></tr></tbody></table><table><thead><tr><th align="left">Member function</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">std::precision()</td><td align="left">Returns the current precision of floating-point numbers</td></tr><tr><td align="left">std::precision(int)</td><td align="left">Sets the precision of floating-point numbers and returns old precision</td></tr></tbody></table><ul><li><strong>如果使用固定记数法或科学记数法</strong>，则精度决定了在分数中显示多少位小数。注意，如果精度小于有效数字的数目，则该数字将四舍五入。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::fixed &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">3</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">4</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">5</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">6</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">7</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::scientific &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">3</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">4</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">5</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">6</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">7</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">123.456</span><br><span class="line">123.4560</span><br><span class="line">123.45600</span><br><span class="line">123.456000</span><br><span class="line">123.4560000</span><br><span class="line"></span><br><span class="line">1.235e+002</span><br><span class="line">1.2346e+002</span><br><span class="line">1.23456e+002</span><br><span class="line">1.234560e+002</span><br><span class="line">1.2345600e+002</span><br></pre></td></tr></table></figure><ul><li><strong>如果既不使用固定数字，也不使用科学数字，则精度决定应显示多少位有效数字。</strong>同样，如果精度小于有效数字的数目，则该数字将四舍五入。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">3</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">4</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">5</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">6</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">7</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">123</span><br><span class="line">123.5</span><br><span class="line">123.46</span><br><span class="line">123.456</span><br><span class="line">123.456</span><br></pre></td></tr></table></figure><ul><li><strong>使用showpoint控制器器或标记，您可以让流 写入小数点和尾随零</strong>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::showpoint &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">3</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">4</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">5</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">6</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">7</span>) &lt;&lt; <span class="number">123.456</span> &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123.</span></span><br><span class="line"><span class="number">123.5</span></span><br><span class="line"><span class="number">123.46</span></span><br><span class="line"><span class="number">123.456</span></span><br><span class="line"><span class="number">123.4560</span></span><br></pre></td></tr></table></figure><p>下面是一些例子的总结表:</p><table><thead><tr><th align="left">Option</th><th align="left">Precision</th><th align="left">12345.0</th><th align="left">0.12345</th></tr></thead><tbody><tr><td align="left">Normal</td><td align="left">3</td><td align="left">1.23e+004</td><td align="left">0.123</td></tr><tr><td align="left">4</td><td align="left">1.235e+004</td><td align="left">0.1235</td><td align="left"></td></tr><tr><td align="left">5</td><td align="left">12345</td><td align="left">0.12345</td><td align="left"></td></tr><tr><td align="left">6</td><td align="left">12345</td><td align="left">0.12345</td><td align="left"></td></tr><tr><td align="left">Showpoint</td><td align="left">3</td><td align="left">1.23e+004</td><td align="left">0.123</td></tr><tr><td align="left">4</td><td align="left">1.235e+004</td><td align="left">0.1235</td><td align="left"></td></tr><tr><td align="left">5</td><td align="left">12345.</td><td align="left">0.12345</td><td align="left"></td></tr><tr><td align="left">6</td><td align="left">12345.0</td><td align="left">0.123450</td><td align="left"></td></tr><tr><td align="left">Fixed</td><td align="left">3</td><td align="left">12345.000</td><td align="left">0.123</td></tr><tr><td align="left">4</td><td align="left">12345.0000</td><td align="left">0.1235</td><td align="left"></td></tr><tr><td align="left">5</td><td align="left">12345.00000</td><td align="left">0.12345</td><td align="left"></td></tr><tr><td align="left">6</td><td align="left">12345.000000</td><td align="left">0.123450</td><td align="left"></td></tr><tr><td align="left">Scientific</td><td align="left">3</td><td align="left">1.235e+004</td><td align="left">1.235e-001</td></tr><tr><td align="left">4</td><td align="left">1.2345e+004</td><td align="left">1.2345e-001</td><td align="left"></td></tr><tr><td align="left">5</td><td align="left">1.23450e+004</td><td align="left">1.23450e-001</td><td align="left"></td></tr><tr><td align="left">6</td><td align="left">1.234500e+004</td><td align="left">1.234500e-001</td><td align="left"></td></tr></tbody></table><h1 id="宽度、填充字符和对齐"><a href="#宽度、填充字符和对齐" class="headerlink" title="宽度、填充字符和对齐"></a>宽度、填充字符和对齐</h1><p>通常，当您打印数字时，数字的打印与周围的空间无关。然而，向左或向右打印数字是可能的。</p><ul><li><strong>为了做到这一点，我们必须首先定义一个字段宽度，它定义了一个值将具有的输出空间的数量。</strong><ul><li>如果实际打印的数字小于字段宽度，它将被左对齐或右对齐(如指定)。</li><li>如果实际数字大于字段宽度，则<u>不会截断它</u>——它将溢出字段。</li></ul></li></ul><table><thead><tr><th align="left">Group</th><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">std::ios::adjustfield</td><td align="left">std::ios::internal</td><td align="left">Left-justifies the sign of the number, and right-justifies the value</td></tr><tr><td align="left">std::ios::adjustfield</td><td align="left">std::ios::left</td><td align="left">Left-justifies the sign and value</td></tr><tr><td align="left">std::ios::adjustfield</td><td align="left">std::ios::right</td><td align="left">Right-justifies the sign and value (default)</td></tr></tbody></table><table><thead><tr><th align="left">Manipulator</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">std::internal</td><td align="left">Left-justifies the sign of the number, and right-justifies the value</td></tr><tr><td align="left">std::left</td><td align="left">Left-justifies the sign and value</td></tr><tr><td align="left">std::right</td><td align="left">Right-justifies the sign and value</td></tr><tr><td align="left">std::setfill(char)</td><td align="left">Sets the parameter as the fill character (defined in iomanip.h)</td></tr><tr><td align="left">std::setw(int)</td><td align="left">Sets the field width for input and output to the parameter (defined in iomanip.h)</td></tr></tbody></table><table><thead><tr><th align="left">Member function</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">std::fill()</td><td align="left">Returns the current fill character</td></tr><tr><td align="left">std::fill(char)</td><td align="left">Sets the fill character and returns the old fill character</td></tr><tr><td align="left">std::width()</td><td align="left">Returns the current field width</td></tr><tr><td align="left">std::width(int)</td><td align="left">Sets the current field width and returns old field width</td></tr></tbody></table><p>为了使用任何这些格式化器，我们首先必须设置字段宽度。</p><blockquote><p>这可以通过<strong>width(int)</strong>成员函数或<strong>setw()</strong>机械手来完成。<strong>注意，右对齐是默认的。</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">-12345</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print default value with no field width</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">10</span>) &lt;&lt; <span class="number">-12345</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print default with field width</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">10</span>) &lt;&lt; left &lt;&lt; <span class="number">-12345</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print left justified</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">10</span>) &lt;&lt; right &lt;&lt; <span class="number">-12345</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print right justified</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">10</span>) &lt;&lt; internal &lt;&lt; <span class="number">-12345</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print internally justified</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">-12345</span></span><br><span class="line">    <span class="number">-12345</span></span><br><span class="line"><span class="number">-12345</span></span><br><span class="line">    <span class="number">-12345</span></span><br><span class="line">-    <span class="number">12345</span></span><br></pre></td></tr></table></figure><p><strong>需要注意的一点是，setw()和width()只影响下一个输出语句</strong>。它们不像其他一些标志/操纵器那样持久。</p><p>现在，让我们设置一个填充字符，并做同样的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.<span class="built_in">fill</span>(<span class="string">'*'</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">-12345</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print default value with no field width</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">10</span>) &lt;&lt; <span class="number">-12345</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print default with field width</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">10</span>) &lt;&lt; left &lt;&lt; <span class="number">-12345</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print left justified</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">10</span>) &lt;&lt; right &lt;&lt; <span class="number">-12345</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print right justified</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">10</span>) &lt;&lt; internal &lt;&lt; <span class="number">-12345</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print internally justified</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">-12345</span></span><br><span class="line">****<span class="number">-12345</span></span><br><span class="line"><span class="number">-12345</span>****</span><br><span class="line">****<span class="number">-12345</span></span><br><span class="line">-****<span class="number">12345</span></span><br></pre></td></tr></table></figure><p>请注意，字段中的所有空格都已用填充字符填充。</p><p>ostream类和iostream库包含其他可能有用的输出函数、标志和操作符，这取决于您需要做什么。与istream类一样，这些主题实际上更适合于关注标准库的教程或书籍(例如Nicolai M. Josuttis的优秀书籍《c++标准模板库》)。</p></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/dac06bda.html">C&C++/istream输入</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月27日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：1.3k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：5分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/182-input-with-istream/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/182-input-with-istream/</a></p><hr><p>iostream库相当复杂——因此我们无法在本教程中完整地介绍它。但是，我们将向您展示最常用的功能。在本节中，我们将研究input类(istream)的各个方面。</p><h1 id="提取操作符-gt-gt"><a href="#提取操作符-gt-gt" class="headerlink" title="提取操作符(&gt;&gt;)"></a>提取操作符(&gt;&gt;)</h1><p>正如在许多课程中看到的，我们可以使用<strong>提取操作符(&gt;&gt;)</strong>从输入流中读取信息。</p><p><strong>c++为所有内置数据类型提供了预定义的提取操作</strong>，您已经了解了如何<a href="https://www.google.com/search?q=overload+the+extraction+operator&oq=overload+the+extraction+operator+&aqs=chrome..69i57&sourceid=chrome&ie=UTF-8" target="_blank" rel="noopener">重载自己类的提取操作符</a>。</p><p>读取字符串时，提取操作符的一个常见问题是如何防止输入溢出缓冲区。给出以下例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; buf;</span><br></pre></td></tr></table></figure><p>如果用户输入18个字符会发生什么?缓冲区溢出，就会发生不好的事情。一般来说，对用户将输入多少字符做任何假设都不是一个好主意。</p><p>处理这个问题的一种方法是使用<strong>控制符</strong>。<strong>控制符</strong>是一个对象，当使用提取(&gt;&gt;)或插入(&lt;&lt;)操作符时，用于修改流。</p><blockquote><p>您已经广泛使用过的一个控制符是“endl”，它既打印换行字符，又刷新任何缓冲输出。</p></blockquote><p><strong>c++提供了一个名为setw的机械手(在iomanip.h头文件中)，</strong>它可以用来限制从流中读取的字符的数量。</p><blockquote><p>要使用setw()，只需提供作为参数读取的最大字符数，并将其插入到您的输入语句中，</p></blockquote><p>如下所示:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; <span class="built_in">std</span>::setw(<span class="number">10</span>) &gt;&gt; buf;</span><br></pre></td></tr></table></figure><p>这个程序现在将只从流中读取前9个字符(为终止符留出空间)。任何剩余的字符都将留在流中，直到下一次提取。</p><h1 id="提取和空白"><a href="#提取和空白" class="headerlink" title="提取和空白"></a>提取和空白</h1><p>到目前为止，我们没有提到的一件事是<strong>提取操作符处理“格式化”的数据</strong>——也就是说，它跳过空白(空格、制表符和换行符)。</p><p>看看下面的程序:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; ch)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ch;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当用户输入以下内容时:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello my name is Alex</span><br></pre></td></tr></table></figure><p>提取操作符跳过空格和换行符。因此，输出为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HellomynameisAlex</span><br></pre></td></tr></table></figure><p><strong>通常，您希望获得用户输入，但不放弃空格。为此，istream类提供了许多可用于此目的的函数。</strong></p><h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><ul><li><p><strong><code>get()</code></strong>——最有用的函数之一是get()函数，它只从输入流中获取一个字符。下面是上面使用get()的同一个程序:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>(ch))</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ch;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*现在当我们使用输入:*/</span></span><br><span class="line">Hello my name is Alex</span><br><span class="line"><span class="comment">/*它的结果是*/</span></span><br><span class="line">Hello my name is Alex</span><br></pre></td></tr></table></figure><p><strong>std::get()也有一个字符串版本，需要读取最多的字符:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> strBuf[<span class="number">11</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>(strBuf, <span class="number">11</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; strBuf &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*现在当我们使用输入:*/</span></span><br><span class="line">Hello my name is Alex</span><br><span class="line"><span class="comment">/*它的结果是*/</span></span><br><span class="line">Hello my n</span><br></pre></td></tr></table></figure><blockquote><p>注意，我们只读取了前10个字符(必须留下一个字符作为终止符)。其余字符留在输入流中。</p></blockquote></li></ul><p>关于<strong>get()</strong>需要注意的一件重要事情是，它<strong>不读取换行字符</strong>! 这可能会导致一些意想不到的结果:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> strBuf[<span class="number">11</span>];</span><br><span class="line">    <span class="comment">// Read up to 10 characters</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>(strBuf, <span class="number">11</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; strBuf &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Read up to 10 more characters</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>(strBuf, <span class="number">11</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; strBuf &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用户输入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello!</span><br></pre></td></tr></table></figure><p>程序将打印:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello!</span><br></pre></td></tr></table></figure><p>然后终止! 为什么不要求增加10个字符呢? 答案是，因为第一个get()读到换行，然后停止。第二个get()看到cin流中仍然有输入，并试图读取它。但第一个字符是换行符，所以它立即停止。</p><h2 id="getline"><a href="#getline" class="headerlink" title="getline()"></a>getline()</h2><p>因此，还有另一个名为getline()的函数，它的工作方式与get()完全相同，<strong>但它会读取换行符</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> strBuf[<span class="number">11</span>];</span><br><span class="line">    <span class="comment">// Read up to 10 characters</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.getline(strBuf, <span class="number">11</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; strBuf &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Read up to 10 more characters</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.getline(strBuf, <span class="number">11</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; strBuf &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码将按照您的期望执行，即使用户输入一个带有换行符的字符串。</p><p><strong>如果需要知道getline()的最后一次调用提取了多少字符，</strong> 使用<strong><code>gcount ()</code></strong> :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> strBuf[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.getline(strBuf, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; strBuf &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">cin</span>.gcount() &lt;&lt; <span class="string">" characters were read"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一些更有用的istream函数"><a href="#一些更有用的istream函数" class="headerlink" title="一些更有用的istream函数"></a>一些更有用的istream函数</h1><p>这里有一些更有用的输入函数，你可能想利用:</p><ul><li><p><strong><code>ignore()</code>：</strong>丢弃流中的第一个字符**。</p></li><li><p><strong><code>ignore(int nCount)</code></strong>：丢弃第一个nCount字符。</p></li><li><p><strong><code>peek()</code></strong>：允许您从流中读取字符，而无需从流中删除字符。</p></li><li><p><strong><code>unget()</code></strong>：将最后读取的字符返回到流中，以便下一个调用可以再次读取它。</p></li><li><p><strong><code>putback(char ch)</code></strong>：允许您将选择的字符放回流中，以便下一次调用读取。</p></li></ul><p>istream包含了许多其他的函数和上面提到的函数的变体，它们可能是有用的，这取决于你需要做什么。但是，这些主题更适合于关注标准库的教程或书籍（如 <a href="https://www.amazon.com/Standard-Library-Tutorial-Reference-2nd/dp/0321623215" target="_blank" rel="noopener">“The C++ Standard Library”</a> by Nicolai M. Josuttis）</p></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/57266241.html">C&C++/输入输出(IO)流</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月27日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：1.1k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：3分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/181-input-and-output-io-streams/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/181-input-and-output-io-streams/</a></p><hr><p>输入和输出功能不是作为核心c++语言的一部分定义的，而是通过c++标准库提供的 (因此驻留在<strong>std名称空间</strong>中)。</p><p>在以前的课程中，您包括了iostream库头，并使用cin和cout对象来执行简单的I/O。在这节课中，我们将更详细地了解iostream库。</p><h1 id="iostream库"><a href="#iostream库" class="headerlink" title="iostream库"></a><code>iostream</code>库</h1><p>当您包含iostream报头时，您可以访问 负责提供I/O功能的整个类层次结构 (包括一个实际名为iostream的类)。非文件 I/O类的类层次结构如下:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="http://www.learncpp.com/images/CppTutorial/Section13/iostream.gif" alt="img"></p><p>关于这个层次结构，您可能注意到的第一件事是它使用了多重继承(我们告诉您尽可能避免的事情)。但是，为了避免任何典型的多重继承问题，已经设计并广泛测试了iostream库，所以您可以自由地使用它。</p><h2 id="流-Streams"><a href="#流-Streams" class="headerlink" title="流(Streams)"></a>流(Streams)</h2><p>你可能注意到的第二件事是，<strong>“流”</strong>这个词使用得非常频繁。在最基本的方面，c++中的I/O是用流实现的。<strong>抽象地说，流就是可以按顺序访问的字节序列。随着时间的推移，流可能产生或消耗无限数量的数据。</strong></p><p>通常我们处理两种不同类型的流：</p><ul><li><p><strong>输入流</strong>用于保存来自数据生成器 (如键盘、文件或网络)的输入。</p><blockquote><p>例如，当程序当前不期望任何输入时，用户可以按键盘上的一个键。而不是忽略用户的按键，数据被放入一个输入流，在那里它将等待，直到程序为它准备好。</p></blockquote></li><li><p>相反，<strong>输出流</strong>用于保存特定数据使用者 (如监视器、文件或打印机)的输出。</p><blockquote><p>当向输出设备写入数据时，设备可能还没有准备好接受该数据——例如，当程序将数据写入其输出流时，打印机可能仍然处于预热状态。这些数据将保存在输出流中，直到打印机开始使用它。</p></blockquote></li></ul><p>一些设备，如文件和网络，可以同时作为输入源和输出源。</p><p><strong>流的好处是程序员只需要学习如何与流交互，就可以将数据读写到许多不同的设备上</strong>。流如何与它们所连接的实际设备进行接口的详细信息由环境或操作系统决定。</p><h1 id="在c-中的输入-输出"><a href="#在c-中的输入-输出" class="headerlink" title="在c++中的输入/输出"></a>在c++中的输入/输出</h1><p>虽然<strong>ios类</strong>通常派生自ios_base类，但ios 通常是您将直接使用的最基本的类。ios类定义了一些输入流和输出流共有的东西。我们将在以后的课程中讨论这些内容。</p><p><strong>istream类</strong>是<strong>处理输入流</strong>时使用的主要类。<strong>对于输入流，提取操作符(&gt;&gt;) 用于从流中删除值。</strong> 这是有意义的:</p><ul><li>当用户在键盘上按下一个键时，键代码就被放置在输入流中。然后，程序从流中提取值，以便使用它。</li></ul><p><strong>ostream类</strong>是<strong>处理输出流</strong>时使用的主要类。<strong>对于输出流，使用插入操作符(&lt;&lt;)将值放入流中</strong>。这也是有意义的:</p><ul><li>您将您的值插入到流中，数据使用者(例如。监控)使用。</li></ul><p><strong>iostream类可以处理输入和输出，允许双向I/O。</strong></p><p>最后，有一堆类以“_withassign”结束。这些 流类 派生自istream、ostream和iostream (分别)，并定义了赋值运算符，允许您将一个流分配给另一个流。在大多数情况下，您不会直接处理这些类。</p><h1 id="c-中的标准流"><a href="#c-中的标准流" class="headerlink" title="c++中的标准流"></a>c++中的标准流</h1><p><strong>标准流是由环境提供给计算机程序的预先连接的流。</strong></p><p>c++附带了四个预定义的标准流对象，它们已经为您的使用进行了设置。</p><ul><li><code>cin</code>——与标准输入(通常是键盘)绑定的 istream_withassign类</li><li><code>cout</code>——与标准输出(通常是监视器)绑定的ostream_withassign类</li><li><code>cerr</code>—— 一个与标准<u>错误</u>(通常是监视器)绑定的ostream_withassign类，提供 未缓冲 的<strong>输出</strong></li><li><code>clog</code>—— 一个与标准错误(通常是监视器)绑定的ostream_withassign类，提供缓冲 <strong>输出</strong></li></ul><p><strong>非缓冲输出通常是立即处理的，而缓冲输出通常是作为一个块存储和写入的</strong>。因为clog不是经常使用，所以它常常从标准流列表中被省略。</p></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/e56a544e.html">C&C++/std：：string的插入</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月26日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：265字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：1分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/17-7-stdstring-inserting/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/17-7-stdstring-inserting/</a></p><hr><p>可以通过<strong>insert()</strong>函数将字符插入到现有的字符串中。</p><p><strong><code>string&amp; string::insert (size_type index, const string&amp; str)</code></strong></p><p><strong><code>string&amp; string::insert (size_type index, const char* str)</code></strong></p><ul><li>这两个函数都将str的字符插入到索引处的字符串中</li><li>两个函数都返回*this，因此它们可以被“链接”。</li><li>如果索引无效，两个函数都会抛出out_of_range</li><li>如果结果超过最大字符数，这两个函数都会抛出一个length_error异常。</li><li>在c风格的字符串版本中，str不能为空。</li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sString</span><span class="params">(<span class="string">"aaaa"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">sString.insert(<span class="number">2</span>, <span class="built_in">string</span>(<span class="string">"bbbb"</span>));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">sString.insert(<span class="number">4</span>, <span class="string">"cccc"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aaaa</span><br><span class="line">aabbbbaa</span><br><span class="line">aabbccccbbaa</span><br></pre></td></tr></table></figure><p>下面，将只给出函数的声明，具体解释，请看原文对应内容：</p><p><strong><code>string&amp; string::insert (size_type index, const string&amp; str, size_type startindex, size_type num)</code></strong></p><p><strong><code>string&amp; string::insert(size_type index, const char* str, size_type len)</code></strong></p><p><strong><code>string&amp; string::insert(size_type index, size_type num, char c)</code></strong></p><p><strong><code>void insert(iterator it, size_type num, char c)</code></strong></p><p><strong><code>iterator string::insert(iterator it, char c)</code></strong></p><p><strong><code>void string::insert(iterator it, InputIterator begin, InputIterator end)</code></strong></p></div></section></article></div></section><br><div class="prev-next"><p class="current">1 / 15</p><a class="next" rel="next" href="/page/2/"><section class="post next white-box shadow">&nbsp;下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i></section></a></div></div><aside class="l_side"><section class="widget blogger shadow desktop"><div class="content"><div class="avatar"><img class="avatar" src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"></div><div class="text"><p><span id="jinrishici-sentence">龙龙‘S BLOG</span></p><script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script></div><div class="social-wrapper"><a href="/atom.xml" class="social fas fa-rss flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="mailto:1198216723@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://github.com/longlongqin" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://music.163.com/#/user/home?id=285545421" class="social fas fa-headphones-alt flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a></div></div></section><section class="widget grid shadow desktop mobile"><header><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i><span class="name">站内导航</span></header><div class="content"><div class="grid navigation"><a class="flat-box" title="/" href="/" id="home"><i class="fas fa-clock fa-fw" aria-hidden="true"></i> 近期文章 </a><a class="flat-box" title="/archives/" href="/archives/" rel="nofollow" id="archives"><i class="fas fa-archive fa-fw" aria-hidden="true"></i> 文章归档 </a><a class="flat-box" title="/friends/" href="/friends/" rel="nofollow" id="friends"><i class="fas fa-link fa-fw" aria-hidden="true"></i> 友人帐 </a><a class="flat-box" title="/about/" href="/about/" rel="nofollow" id="about"><i class="fas fa-info-circle fa-fw" aria-hidden="true"></i> 关于小站</a></div></div></section><section class="widget category shadow desktop"><header><a href="/blog/categories/"><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i><span class="name">文章分类</span></a></header><div class="content"><ul class="entry navigation"><li><a class="flat-box" title="/categories/OJ/" href="/categories/OJ/" id="categoriesOJ"><div class="name">OJ</div><div class="badge">(1)</div></a></li><li><a class="flat-box" title="/categories/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" href="/categories/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" id="categorieshexoE58D9AE5AEA2E690ADE5BBBA"><div class="name">hexo博客搭建</div><div class="badge">(1)</div></a></li><li><a class="flat-box" title="/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" href="/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" id="categoriesE58D9AE5AEA2E690ADE5BBBA"><div class="name">博客搭建</div><div class="badge">(4)</div></a></li><li><a class="flat-box" title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="categoriesE5ADA6E4B9A0E7AC94E8AEB0"><div class="name">学习笔记</div><div class="badge">(48)</div></a></li><li><a class="flat-box child" title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/" id="categoriesE5ADA6E4B9A0E7AC94E8AEB0C-C"><div class="name">C/C++</div><div class="badge">(25)</div></a></li><li><a class="flat-box child" title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git/" id="categoriesE5ADA6E4B9A0E7AC94E8AEB0Git"><div class="name">Git</div><div class="badge">(1)</div></a></li><li><a class="flat-box" title="/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" href="/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" id="categoriesE5AE9EE794A8E68A80E5B7A7"><div class="name">实用技巧</div><div class="badge">(1)</div></a></li><li><a class="flat-box" title="/categories/%E9%85%8D%E7%BD%AE/" href="/categories/%E9%85%8D%E7%BD%AE/" id="categoriesE9858DE7BDAE"><div class="name">配置</div><div class="badge">(1)</div></a></li></ul></div></section><section class="widget tagcloud shadow desktop"><header><a href="/blog/tags/"><i class="fas fa-tags fa-fw" aria-hidden="true"></i><span class="name">热门标签</span></a></header><div class="content"><a href="/tags/C/" style="font-size:16px;color:#8b8b8b">C++</a> <a href="/tags/C-C/" style="font-size:24px;color:#555">C/C++</a> <a href="/tags/Git/" style="font-size:14px;color:#999">Git</a> <a href="/tags/Hexo%E4%B8%BB%E9%A2%98/" style="font-size:14px;color:#999">Hexo主题</a> <a href="/tags/Let-s-Build-A-Simple-Interpreter/" style="font-size:22px;color:#636363">Let's Build A Simple Interpreter</a> <a href="/tags/Let%E2%80%99s-Build-A-Simple-Interpreter/" style="font-size:18px;color:#7e7e7e">Let’s Build A Simple Interpreter</a> <a href="/tags/OJ/" style="font-size:14px;color:#999">OJ</a> <a href="/tags/Yilia%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/" style="font-size:14px;color:#999">Yilia主题配置</a> <a href="/tags/forme/" style="font-size:14px;color:#999">forme</a> <a href="/tags/front-matter%E9%85%8D%E7%BD%AE/" style="font-size:14px;color:#999">front-matter配置</a> <a href="/tags/github/" style="font-size:14px;color:#999">github</a> <a href="/tags/hexo%E6%98%BE%E7%A4%BApdf/" style="font-size:14px;color:#999">hexo显示pdf</a> <a href="/tags/matery%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/" style="font-size:14px;color:#999">matery主题配置</a> <a href="/tags/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE%E3%80%8B/" style="font-size:18px;color:#7e7e7e">《计算机科学速成课》</a> <a href="/tags/%E5%87%B8%E5%8C%85/" style="font-size:20px;color:#707070">凸包</a> <a href="/tags/%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91%E5%92%8C%E9%80%BB%E8%BE%91%E9%97%A8/" style="font-size:14px;color:#999">布尔逻辑和逻辑门</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" style="font-size:14px;color:#999">计算几何</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE/" style="font-size:14px;color:#999">计算机科学速成课</a> <a href="/tags/%E9%85%8D%E7%BD%AE/" style="font-size:14px;color:#999">配置</a></div></section></aside><footer class="clearfix white"><br><br><div class="aplayer-container"><meting-js theme="#1BCDFC" autoplay volume="0.6" loop order="list" fixed="false" list-max-height="340px" server="netease" type="song" id="186453" list-folded="true"></meting-js></div><br><div class="social-wrapper"><a href="/atom.xml" class="social fas fa-rss flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="mailto:1198216723@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://github.com/longlongqin" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://music.163.com/#/user/home?id=285545421" class="social fas fa-headphones-alt flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a></div><red>&copy; 2020-2020 longlongqin 😊| powered by HEXO | theme volantis</red><br><yellow><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("03/01/2020 18:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="小站已运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒 "}setInterval("createtime()",250)</script></yellow><br><green><i class="fas fa-chart-area"></i> <span class="post-count">字数统计：307.9k</span></green>|<script type="text/javascript" src="https://v1.cnzz.com/z_stat.php?id=1278663994&web_id=1278663994"></script><br><cyan>博客内容遵循</cyan><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank"><cyan>署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</cyan></a></footer><script>setLoadingBarProgress(80)</script><script>setLoadingBarProgress(60)</script></div><a class="s-top fas fa-arrow-up fa-fw" href="javascript:void(0)"></a></div><script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script><script>var SEARCH_SERVICE="hexo",ROOT="/";ROOT.endsWith("/")||(ROOT+="/")</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script><script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script><script type="text/javascript">$(function(){Waves.attach(".flat-btn",["waves-button"]),Waves.attach(".float-btn",["waves-button","waves-float"]),Waves.attach(".float-btn-light",["waves-button","waves-float","waves-light"]),Waves.attach(".flat-box",["waves-block"]),Waves.attach(".float-box",["waves-block","waves-float"]),Waves.attach(".waves-image"),Waves.init()})</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script><script type="text/javascript">$(function(){var n=["https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/background/4.jpg"];!function(n){for(var o=n.length;o--;){var r=Math.floor(Math.random()*o),t=n[r];n[r]=n[o],n[o]=t}}(n),$(".cover").backstretch(n,{duration:"20000",fade:"1500"})})</script><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js" async></script><script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js" async></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1.4/js/app.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1/js/search.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script><script>!function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copyed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-clipboard-check');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPYED';
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-exclamation-triangle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
      });
    }
    initCopyCode();
  }(window, document);</script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>let LAZY_LOAD_IMAGE = "[object Object]";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });</script><script>setLoadingBarProgress(100)</script><script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)t=c[r],0<=(n=t.getBoundingClientRect()).bottom&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this);</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script></body></html>