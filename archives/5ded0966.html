<!DOCTYPE html><html><head hexo-theme="https://volantis.js.org/#2.1.4"><meta charset="utf-8"><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><title>C&amp;C++/匿名函数 - 龙龙‘S BLOG</title><link rel="alternate" href="/atom.xml" title="龙龙‘S BLOG"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css"><link rel="shortcut icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1.4.3/css/style.css"><script>function setLoadingBarProgress(e){document.getElementById("loading-bar").style.width=e+"%"}</script></head><body><script type="text/javascript" src="/js/love.js"></script><script type="text/javascript" src="/js/ergao.js"></script><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><header class="l_header shadow blur"><div class="wrapper"><div class="nav-sub container--flex"><a class="logo flat-box"></a><ul class="switcher h-list"><li><a class="s-comment flat-btn fas fa-comments fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-toc flat-btn fas fa-list fa-fw" target="_self" href="javascript:void(0)"></a></li></ul></div><div class="nav-main container container--flex"><a class="logo flat-box" target="_self" href="/"><i class="fas fa-home"></i> 龙龙</a><div class="menu navigation"><ul class="h-list"><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list-alt fa-fw fa-fw"></i> 索引</a><ul class="submenu"><li><a class="flat-box" href="/categories/" id="categories"><i class="fas fa-folder-open fa-fw fa-fw"></i> 分类</a><ul class="submenu"><li><a class="flat-box" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="categoriesE5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-fire fa-fw"></i> 学习笔记</a></li><li><a class="flat-box" href="/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" id="categoriesE5AE9EE794A8E68A80E5B7A7"><i class="fas fa-fire fa-fw"></i> 实用技巧</a></li></ul></li><li><a class="flat-box" href="/tags/" id="tags"><i class="fas fa-tags fa-fw fa-fw"></i> 标签</a></li><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list fa-fw fa-fw"></i> 时间轴</a></li></ul></li><li><a class="flat-box" href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="E5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-book fa-fw"></i> 学习笔记</a></li><li><a class="flat-box"><i class="fas fa-wrench fa-fw"></i> 工具</a><ul class="submenu"><li><a class="flat-box" href="https://www.thinkcmf.com/font/search/index.html" target="_blank" rel="noopener" id="https:www.thinkcmf.comfontsearchindex.html"><i class="fas fa-font fa-fw"></i> Font Awesome图标</a></li><li><a class="flat-box" href="https://www.sojson.com/image/change.html" target="_blank" rel="noopener" id="https:www.sojson.comimagechange.html"><i class="fa fa-crop fa-fw"></i> 在线图片尺寸修改</a></li><li><a class="flat-box" href="http://dir.scmor.com/" target="_blank" rel="noopener" id="http:dir.scmor.com"><i class="fa fa-search fa-fw"></i> Google学术&搜索镜像</a></li><li><a class="flat-box" href="https://emojixd.com/" target="_blank" rel="noopener" id="https:emojixd.com"><i class="fa fa-smile-o fa-fw"></i> Emoji表情符号辞典📓</a></li></ul></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw fa-fw"></i> 关于</a><ul class="submenu"><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-user-circle fa-fw fa-fw"></i> 关于我</a></li><hr><li><a class="flat-box" href="/friends/" id="friends"><i class="fas fa-link fa-fw"></i> 友人帐</a></li><li><a class="flat-box" href="/comment/" id="comment"><i class="fas fa-comment fa-fw"></i> 留言板</a></li><hr><li><a class="flat-box" href="https://github.com/longlongqin" target="_blank" rel="noopener" id="https:github.comlonglongqin"><i class="fab fa-github fa-fw fa-fw"></i> 我的Github</a></li><li><a class="flat-box" href="https://longlongqin.gitee.io" target="_blank" rel="noopener" id="https:longlongqin.gitee.io"><i class="fa fa-chevron-circle-right fa-fw"></i> matery主题博客</a></li></ul></li><li><a class="flat-box" href="https://volantis.js.org/tag-plugins/" target="_blank" rel="noopener" id="https:volantis.js.orgtag-plugins"><i class="fa fa-bookmark fa-fw"></i> Volantis主题文档</a></li><li><a class="flat-box" href="/easysearch/" id="easysearch"><i class="fa fa-search fa-fw"></i> easy搜索</a></li></ul></div><div class="m_search"><form name="searchform" class="form u-search-form"><i class="icon fas fa-search fa-fw"></i> <input type="text" class="input u-search-input" placeholder="search for everything"></form></div><ul class="switcher h-list"><li><a class="s-search flat-btn fas fa-search fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-menu flat-btn fas fa-bars fa-fw" target="_self" href="javascript:void(0)"></a></li></ul></div></div></header><ul class="menu-phone navigation white-box"><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list-alt fa-fw fa-fw"></i> 索引</a></li><li><a class="flat-box" href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="E5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-book fa-fw"></i> 学习笔记</a></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw fa-fw"></i> 关于</a></li></ul><script>setLoadingBarProgress(40)</script><div class="l_body nocover"><div class="body-wrapper"><div class="l_main"><article id="post" class="post white-box shadow article-type-post" itemscope itemprop="blogPost"><section class="meta"><div class="meta" id="header-meta"><h1 class="title"><a href="/archives/5ded0966.html">C&C++/匿名函数</a></h1><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月7日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：6k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：25分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/introduction-to-lambdas-anonymous-functions/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/introduction-to-lambdas-anonymous-functions/</a></p><p><strong>匿名函数：lambdas（anonymous functions）</strong></p><hr><p>考虑一下我们在之前课程中介绍的这段代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">containsNut</span><span class="params">(<span class="built_in">std</span>::string_view str)</span> <span class="comment">// static 是指在这个上下文中的内部链接</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// std::string_view::find returns std::string_view::npos if it doesn't find</span></span><br><span class="line">  <span class="comment">// the substring. Otherwise it returns the index where the substring occurs</span></span><br><span class="line">  <span class="comment">// in str.</span></span><br><span class="line">  <span class="keyword">return</span> (str.<span class="built_in">find</span>(<span class="string">"nut"</span>) != <span class="built_in">std</span>::string_view::npos);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::string_view, 4&gt; arr&#123; <span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"walnut"</span>, <span class="string">"lemon"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// std::find_if takes a pointer to a function</span></span><br><span class="line">  <span class="keyword">auto</span> found&#123; <span class="built_in">std</span>::find_if(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), containsNut) &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (found == arr.<span class="built_in">end</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"No nuts\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Found "</span> &lt;&lt; *found &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Found walnut</span><br></pre></td></tr></table></figure><p>其实这个可以被改进：</p><p>这里问题的根源是<code>std::find_if</code>要求我们给它传递一个函数指针。</p><h1 id="函数不能嵌套"><a href="#函数不能嵌套" class="headerlink" title="函数不能嵌套"></a>函数不能嵌套</h1><p>因此，我们必须定义一个<strong>只会使用一次的函数</strong>，它必须有一个名称，并且必须放在全局范围内(<strong>因为函数不能嵌套</strong>!)这个函数也很短，从一行代码就比从名称和注释更容易看出它的功能。</p><h1 id="使用匿名函数"><a href="#使用匿名函数" class="headerlink" title="使用匿名函数"></a>使用匿名函数</h1><p><strong>匿名函数表达式 (也称为lambda 或 closure ) 允许我们在另一个函数中定义匿名函数。</strong> <strong>嵌套</strong>很重要，因为它允许我们避免命名空间命名污染，并尽可能在使用它的地方定义函数(提供额外的上下文)。</p><p>lambdas的语法是c++中比较奇怪的东西之一，需要一点时间来适应<strong>。Lambdas的形式是</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[ captureClause ] ( parameters ) -&gt; returnType</span><br><span class="line">&#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不需要"captureClause"句和"parameters"，则它们都可以为空。</span></span><br><span class="line"><span class="comment">//"return type"是可选的。如果省略它，将使用auto(即，使用类型推断来确定返回类型)。</span></span><br><span class="line"><span class="comment">//虽然我们前面已经注意到，应该避免对函数返回类型进行类型推断，但是在这个上下文中，使用这种类型推断是可以的(因为这些函数通常都是非常琐碎的)。</span></span><br></pre></td></tr></table></figure><p>还要注意，<strong>lambdas没有名称</strong>，所以我们不需要提供名称。</p><p>这意味着一个普通的lambda定义是这样的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  []() &#123;&#125;; <span class="comment">// defines a lambda with no captures, no parameters, and no return type</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>重新写上面的那段代码（使用匿名函数）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::string_view, 4&gt; arr&#123; <span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"walnut"</span>, <span class="string">"lemon"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Define the function right where we use it.</span></span><br><span class="line">  <span class="keyword">auto</span> found&#123; <span class="built_in">std</span>::find_if(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(),</span><br><span class="line">                           [](<span class="built_in">std</span>::string_view str) <span class="comment">// here's our lambda, no capture clause⭐</span></span><br><span class="line">                           &#123;</span><br><span class="line">                             <span class="keyword">return</span> (str.<span class="built_in">find</span>(<span class="string">"nut"</span>) != <span class="built_in">std</span>::string_view::npos);</span><br><span class="line">                           &#125;) &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (found == arr.<span class="built_in">end</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"No nuts\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Found "</span> &lt;&lt; *found &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就像函数指针的情况，并产生一个相同的结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Found walnut</span><br></pre></td></tr></table></figure><hr><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>注意我们的 匿名函数 与我们的 <code>containsNut</code>函数 是多么的相似：</p><p>它们都具有相同的参数和函数体。lambda没有captureClause（捕获子句）(我们将在下一课中解释捕获子句是什么)，因为它不需要捕获子句。我们在lambda中省略了末尾的返回类型(为了简洁)，但是因为是操作符 != 返回一个bool，我们的lambda也将返回一个bool。</p><h1 id="匿名函数的类型"><a href="#匿名函数的类型" class="headerlink" title="匿名函数的类型"></a>匿名函数的类型</h1><p>在上面的例子中，我们在需要的地方定义了一个lambda。这种对lambda的使用有时被称为<strong>函数文字（function literal）</strong>。</p><p>但是上面的例子中的匿名函数的可读性很差。</p><p>就像我们可以用一个文字值(或函数指针)初始化一个变量以供以后使用一样，<strong>我们也可以用一个lambda定义初始化一个lambda变量，然后再使用它。</strong></p><p>比如：（在下面的代码段中，我们使用<code>std::all_of</code>来检查数组中的所有元素是否为偶数:）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们必须读lambda来理解发生了什么。(Bad)</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::all_of (<span class="built_in">array</span>.<span class="built_in">begin</span>(), <span class="built_in">array</span>.<span class="built_in">end</span>(), [] (<span class="keyword">int</span> i) &#123;<span class="keyword">return</span> ((i%<span class="number">2</span>) == <span class="number">0</span>);&#125;);</span><br></pre></td></tr></table></figure><p>我们可以改善可读性的这个如下:[推荐⭐]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相反，我们可以将lambda存储在指定的变量中，并将其传递给函数。</span></span><br><span class="line"><span class="keyword">auto</span> isEven&#123;</span><br><span class="line">    [] (<span class="keyword">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ((i%<span class="number">2</span>) == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::ll_of(<span class="built_in">array</span>.<span class="built_in">begin</span>(), <span class="built_in">array</span>.<span class="built_in">end</span>(), isEven);</span><br><span class="line"><span class="comment">//注意最后一行读起来有多好:“返回数组中的所有元素是否为偶数”</span></span><br></pre></td></tr></table></figure><h2 id="匿名函数的类型到底是什么？"><a href="#匿名函数的类型到底是什么？" class="headerlink" title="匿名函数的类型到底是什么？"></a>匿名函数的类型到底是什么？</h2><p>但是上面的匿名函数<code>isEven</code>到底是什么呢？</p><p>答：</p><p>事实证明，<strong>lambdas没有一个我们可以明确使用的类型。当我们写一个lambda时，编译器会生成一个唯一的类型，但是不暴露给我们。</strong></p><hr><p><strong>虽然我们不知道lambda的类型，但是有几种方法可以存储用于post-definition（后定义？？？）的lambda</strong>。<u>如果lambda有一个空的捕获子句</u>，我们可以使用下面三种方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//⭐1：一个常规的函数指针。只对 空捕获句子(capture clause) 有效。</span></span><br><span class="line">    <span class="keyword">double</span> (*addNumbers1) (doubel, <span class="keyword">double</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        [] (<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (a+b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    addNumbers1(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//⭐2： Using std::function。也可适用于匿名函数的capture clause非空的情况(下一课会讲)。</span></span><br><span class="line">    <span class="built_in">std</span>::function addNumbers2 <span class="comment">//注意：在C++17之前，应该这样写：std::function&lt;double(double, double)&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        [] (<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="keyword">return</span> (a+b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    addNumbers2(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//⭐3：使用auto。存储lambda的实际类型。</span></span><br><span class="line">    <span class="keyword">auto</span> addNumbers3</span><br><span class="line">    &#123;</span><br><span class="line">        [] (<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (a+b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    addNumbers3(<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用lambda实际类型的惟一方法是使用auto</strong>。<strong>auto还具有</strong><u>与std::function 相比</u><strong>没有开销的优点。</strong></p><h2 id="适用std-function而不适用auto的情况"><a href="#适用std-function而不适用auto的情况" class="headerlink" title="适用std::function而不适用auto的情况"></a>适用<code>std::function</code>而不适用<code>auto</code>的情况</h2><p>不幸的是，我们不能总是使用auto。</p><p><strong>在实际的lambda未知的情况下</strong>(例如，因为我们将lambda作为参数传递给一个函数，调用者决定将传递什么lambda)，我们不能使用auto。在这种情况下，应该使用std::function。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#incldue <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们不知道fn会是什么。std::function与常规函数和lambdas一起工作。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">repeat</span><span class="params">(<span class="keyword">int</span> repetitions, <span class="keyword">const</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt;&amp; fn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i&#123; <span class="number">0</span> &#125;; i &lt; repetitions; ++i )</span><br><span class="line">        fn(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    repeat(<span class="number">3</span>, [] (<span class="keyword">int</span> i) &#123;<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">'\n'</span>;&#125; );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><hr><h1 id="匿名函数其实不是真正的函数"><a href="#匿名函数其实不是真正的函数" class="headerlink" title="匿名函数其实不是真正的函数"></a>匿名函数其实不是真正的函数</h1><p>实际上，<strong>lambdas不是函数</strong></p><blockquote><p><strong>(这也是它们为什么在“函数不能嵌套”的规定下，可以使用的原因)。</strong></p></blockquote><p>它们是一种特殊的物体，叫做<strong>函子(functor)</strong>。<strong>函子是包含重载运算符() 的对象，使其可以像函数一样调用。</strong></p><hr><h1 id="泛型的匿名函数（generic-lambdas）"><a href="#泛型的匿名函数（generic-lambdas）" class="headerlink" title="泛型的匿名函数（generic lambdas）"></a>泛型的匿名函数（generic lambdas）</h1><p>在大多数情况下，lambda参数的工作原理与常规函数参数相同。</p><p>一个值得注意的例外是，因为c++ 14允许我们使用auto作为参数（注意:在c++ 20中，常规函数也可以使用auto作为参数）。</p><p><strong>当一个lambda有一个或多个<u>auto参数</u>时，编译器将从对lambda的调用中推断出需要哪些参数类型。</strong></p><hr><p>因为具有一个或多个auto参数的lambdas可以处理各种类型的数据，所以它们被称为<strong>generic lambdas</strong>。</p><p>看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">array</span> months&#123; <span class="comment">//C++17之前，使用：std::array&lt;const char*, 12&gt;</span></span><br><span class="line">	<span class="string">"January"</span>,</span><br><span class="line">	<span class="string">"February"</span>,</span><br><span class="line">	<span class="string">"March"</span>,</span><br><span class="line">	<span class="string">"April"</span>,</span><br><span class="line">	<span class="string">"May"</span>,</span><br><span class="line">	<span class="string">"June"</span>,</span><br><span class="line">	<span class="string">"July"</span>,</span><br><span class="line">	<span class="string">"August"</span>,</span><br><span class="line">	<span class="string">"September"</span>,</span><br><span class="line">	<span class="string">"October"</span>,</span><br><span class="line">	<span class="string">"November"</span>,</span><br><span class="line">	<span class="string">"December"</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//搜索以相同字母开头的连续两个月。</span></span><br><span class="line">	<span class="keyword">auto</span> samelatter&#123; <span class="built_in">std</span>::adjacent_find(months.<span class="built_in">begin</span>(), months.<span class="built_in">end</span>(),</span><br><span class="line">		[](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b)</span><br><span class="line">		&#123;<span class="keyword">return</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>]); &#125;</span><br><span class="line">		) &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确保找到两个月的时间。</span></span><br><span class="line">	<span class="keyword">if</span> (samelatter != months.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//std::next返回sameLetter之后的下一个迭代器</span></span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;*samelatter &lt;&lt; <span class="string">" and "</span> &lt;&lt;*<span class="built_in">std</span>::next(samelatter)</span><br><span class="line">			&lt;&lt; <span class="string">" start with the same letter\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">June <span class="keyword">and</span> July start with the same letter</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们使用auto类型的参数通过 const引用 来捕获字符串。</p><blockquote><p>因为<strong>所有的字符串类型都允许通过 操作符[] 访问它们各自的字符</strong>，所以我们不需要关心用户是否传入了<u>std::string</u>、<u>c风格的字符串</u>或<u>其他内容</u>。这允许我们写一个可以接受任何这些的lambda，意味着如果我们在几个月后改变类型，我们就不必重写lambda了。</p></blockquote><p>然而，有些情况auto，不是最好的选择：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span> months&#123; <span class="comment">// pre-C++17 use std::array&lt;const char*, 12&gt;</span></span><br><span class="line">    <span class="string">"January"</span>,</span><br><span class="line">    <span class="string">"February"</span>,</span><br><span class="line">    <span class="string">"March"</span>,</span><br><span class="line">    <span class="string">"April"</span>,</span><br><span class="line">    <span class="string">"May"</span>,</span><br><span class="line">    <span class="string">"June"</span>,</span><br><span class="line">    <span class="string">"July"</span>,</span><br><span class="line">    <span class="string">"August"</span>,</span><br><span class="line">    <span class="string">"September"</span>,</span><br><span class="line">    <span class="string">"October"</span>,</span><br><span class="line">    <span class="string">"November"</span>,</span><br><span class="line">    <span class="string">"December"</span></span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Count how many months consist of 5 letters</span></span><br><span class="line">  <span class="keyword">auto</span> fiveLetterMonths&#123; <span class="built_in">std</span>::count_if(months.<span class="built_in">begin</span>(), months.<span class="built_in">end</span>(),</span><br><span class="line">                                       [](<span class="built_in">std</span>::string_view str) &#123; <span class="comment">//⭐</span></span><br><span class="line">                                         <span class="keyword">return</span> (str.length() == <span class="number">5</span>);</span><br><span class="line">                                       &#125;) &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"There are "</span> &lt;&lt; fiveLetterMonths &lt;&lt; <span class="string">" months with 5 letters\n"</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">There are <span class="number">2</span> months with <span class="number">5</span> letters</span><br></pre></td></tr></table></figure><p>在本例中，使用auto将会推断出const char<em>的类型。*</em>c风格的字符串不容易使用(除了使用运算符[])**。</p><p>在本例中，<strong>我们倾向于显式地将参数定义为std::string_view</strong>，这使我们能够更轻松地处理底层数据(例如，我们可以询问string视图的长度，即使用户传入的是c风格的数组)。</p><h2 id="泛型lambda和静态变量"><a href="#泛型lambda和静态变量" class="headerlink" title="泛型lambda和静态变量"></a>泛型lambda和静态变量</h2><p><strong>需要注意的一件事是，一个独一无二的匿名函数将会(被)auto解析为不同的类型。</strong></p><p>下面的例子展示了一个泛型lambda如何变成两个不同的lambda:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//打印一个值并计算 @print被调用的次数。</span></span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">print</span></span><br><span class="line">    &#123;</span><br><span class="line">        [] (<span class="keyword">auto</span> value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">int</span> callcount &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; callcount++&lt;&lt; <span class="string">": "</span> &lt;&lt; value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"hello"</span>); <span class="comment">// 0: hello</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"world"</span>); <span class="comment">// 1: world</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>); <span class="comment">// 0: 1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>); <span class="comment">// 1: 2</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span> (<span class="string">"ding dong"</span>); <span class="comment">// 2: ding dong</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">0</span>: hello</span><br><span class="line"><span class="number">1</span>: world</span><br><span class="line"><span class="number">0</span>: <span class="number">1</span></span><br><span class="line"><span class="number">1</span>: <span class="number">2</span></span><br><span class="line"><span class="number">2</span>: ding dong</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们定义了一个lambda，然后使用两个不同的参数 (一个字符串文字参数 和 一个整数参数)来调用它。这将生成lambda的两个不同版本 (一个带有字符串文字参数，另一个带有整数参数)。</p><blockquote><p>大多数时候，这是无关紧要的。但是，请注意，<strong>如果泛型lambda使用静态持续时间变量，那么这些变量不会在生成的lambda之间共享。</strong></p></blockquote><p>我们可以在上面的示例中看到这一点，其中每个类型(字符串和整数)都有自己的惟一计数!</p><p>虽然我们只写了一次lambda，但是生成了两个lambda，每个lambda都有自己的callCount版本。<u>为了在两个生成的lambda之间共享一个计数器，我们必须在lambda之外定义一个变量</u>。现在，这意味着即使在函数外部也要定义变量。在上面的例子中，这意味着添加一个全局变量。在下一课中讨论lambda捕获之后，我们将能够避免全局变量。</p><h1 id="返回类型推导和跟踪返回类型"><a href="#返回类型推导和跟踪返回类型" class="headerlink" title="返回类型推导和跟踪返回类型"></a>返回类型推导和跟踪返回类型</h1><p>如果使用返回类型推断，则lambda的返回类型是从lambda内部的<code>return</code>语句中推导出来的。如果使用返回类型推断，lambda中的所有返回语句必须返回相同的类型(否则编译器将不知道选择哪一个)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> divide&#123; [](<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">bool</span> bInteger) &#123; <span class="comment">// 注意:没有指定的返回类型</span></span><br><span class="line">    <span class="keyword">if</span> (bInteger)</span><br><span class="line">      <span class="keyword">return</span> x / y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(x) / y; <span class="comment">// 错误:返回类型与以前的返回类型不匹配</span></span><br><span class="line">  &#125; &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; divide(<span class="number">3</span>, <span class="number">2</span>, <span class="literal">true</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; divide(<span class="number">3</span>, <span class="number">2</span>, <span class="literal">false</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将产生一个编译错误：</p><p>因为第一个返回语句(int)的返回类型 与 第二个返回语句(double)的返回类型不匹配。</p><p>如何解决呢？</p><p>在我们返回不同类型的情况下，我们有两个选项:</p><ol><li><strong>显式强制转换以使所有返回类型匹配；</strong></li><li><strong>显式地为lambda指定返回类型，并让编译器进行隐式转换。【推荐⭐】</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//注意：显式指定此值将返回一个double</span></span><br><span class="line">    <span class="keyword">auto</span> divide &#123;</span><br><span class="line">        [] (<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">bool</span> bInteger) -&gt;<span class="keyword">double</span> <span class="comment">//⭐</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (bInteger)</span><br><span class="line">                <span class="keyword">return</span> x/y; <span class="comment">// 将做一个隐式转换为double</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(x) / y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; divide(<span class="number">3</span>, <span class="number">2</span>, <span class="literal">true</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; divide(<span class="number">3</span>, <span class="number">2</span>, <span class="literal">false</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就像上面一样，如果您决定更改返回类型，<strong>您(通常)只需要更改lambda的返回类型，而不需要触及lambda主体。</strong></p><h1 id="——————————"><a href="#——————————" class="headerlink" title="——————————"></a>——————————</h1><h1 id="Lambda-captures"><a href="#Lambda-captures" class="headerlink" title="Lambda captures"></a>Lambda captures</h1><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/lambda-captures/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/lambda-captures/</a></p><hr><h2 id="Capture-clauses-and-capture-by-value"><a href="#Capture-clauses-and-capture-by-value" class="headerlink" title="Capture clauses and capture by value"></a>Capture clauses and capture by value</h2><p>现在，让我们修改nut示例，让用户选择要搜索的子字符串。这并不像你想象的那么直观。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::string_view, 4&gt; arr&#123; <span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"walnut"</span>, <span class="string">"lemon"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 询问用户要搜索什么。</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"search for: "</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> search&#123;&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; search;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">auto</span> found&#123; <span class="built_in">std</span>::find_if(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [](<span class="built_in">std</span>::string_view str) &#123;</span><br><span class="line">    <span class="comment">// 搜索@search而不是“nut”。</span></span><br><span class="line">    <span class="keyword">return</span> (str.<span class="built_in">find</span>(search) != <span class="built_in">std</span>::string_view::npos); <span class="comment">// 错误:search 在此范围内不可访问</span></span><br><span class="line">  &#125;) &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (found == arr.<span class="built_in">end</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Not found\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Found "</span> &lt;&lt; *found &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码无法编译。</p><p>与嵌套块不同的是，外层块中定义的任何标识符都可以在嵌套块的范围内访问，<strong>而</strong>lambdas只能访问特定类型的标识符:</p><ul><li>全局标识符、</li><li>编译时已知的实体</li><li>具有静态存储持续时间的实体。</li></ul><p>search不满足这些要求，所以lambda看不到它<strong>。这就是capture clause的作用。</strong></p><h2 id="capture-clause"><a href="#capture-clause" class="headerlink" title="capture clause"></a>capture clause</h2><p><strong>capture clause(捕获子句)</strong> 用于(间接地)为lambda提供对周围范围中可用变量（这些变量是它通常无法访问的）的访问，</p><p><strong>我们所需要做的就是在lambda中列出我们想要访问的实体，作为捕获子句的一部分</strong>。在这种情况下，我们想给我们的lambda访问变量search的值，所以我们把它添加到捕获子句:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">26</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">28</span></span><br><span class="line"><span class="number">29</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="number">31</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::string_view, 4&gt; arr&#123; <span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"walnut"</span>, <span class="string">"lemon"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"search for: "</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> search&#123;&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; search;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Capture @search                                vvvvvv⭐</span></span><br><span class="line">  <span class="keyword">auto</span> found&#123; <span class="built_in">std</span>::find_if(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [search](<span class="built_in">std</span>::string_view str) &#123;</span><br><span class="line">    <span class="keyword">return</span> (str.<span class="built_in">find</span>(search) != <span class="built_in">std</span>::string_view::npos);</span><br><span class="line">  &#125;) &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (found == arr.<span class="built_in">end</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Not found\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Found "</span> &lt;&lt; *found &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">search <span class="keyword">for</span>: nana</span><br><span class="line">Found banana</span><br></pre></td></tr></table></figure><h2 id="那么捕捉到底是如何工作的呢"><a href="#那么捕捉到底是如何工作的呢" class="headerlink" title="那么捕捉到底是如何工作的呢?"></a>那么捕捉到底是如何工作的呢?</h2><p>虽然上面例子中的lambda看起来像是直接访问main的搜索变量的值，但实际情况并非如此。<strong>Lambdas的外观和功能可能与嵌套块类似，但它们的工作方式略有不同(</strong>这一点很重要)。</p><p><strong>当执行lambda定义时，对于lambda捕获的每个变量，在lambda中创建该变量的克隆(具有相同的名称)。此时，这些克隆的变量是从同名的外部作用域变量初始化的。</strong></p><p>因此，在上面的例子中，当创建lambda对象时，lambda获得它自己的克隆变量<code>search</code>。这个克隆的<code>search</code>与main的<code>search</code>有相同的值，所以它的行为就像我们访问main的<code>search</code>，但我们没有。</p><blockquote><p>虽然这些克隆的变量具有相同的名称，<strong>但它们不一定具有与原始变量相同的类型</strong>。</p></blockquote><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>虽然lambdas看起来像函数，但它们实际上是可以像函数一样调用的对象(这些被称为<strong>functor</strong>——我们将在以后的课程中讨论如何从头创建自己的functor)。</p><p>当<strong>编译器</strong>遇到一个lambda定义时，它会为该lambda创建一个自定义对象定义。每个捕获的变量都成为该对象的数据成员。</p><p>在<strong>运行时</strong>，当遇到lambda定义时，将<u>实例化lambda对象</u>，并在此时初始化lambda的成员。</p><h2 id="捕获默认的const值"><a href="#捕获默认的const值" class="headerlink" title="捕获默认的const值"></a>捕获默认的const值</h2><p>默认情况下，变量由const值捕获。</p><p><strong>这意味着在创建lambda时，lambda捕获外部作用域变量的常量副本，也就是说不允许lambda修改它们。</strong></p><p>在下面的示例中，我们捕获变量ammo并尝试递减它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ammo&#123;<span class="number">10</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义一个lambda并将其存储在一个名为“shoot”的变量中。</span></span><br><span class="line">    <span class="keyword">auto</span> shoot&#123;</span><br><span class="line">        [ammo]() &#123;</span><br><span class="line">            <span class="comment">//✖，缴获的ammo为const copy。</span></span><br><span class="line">            --ammo;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Pew! "</span> &lt;&lt; ammo &lt;&lt; <span class="string">" shot(s) left.\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用lambda</span></span><br><span class="line">    shoot();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ammo &lt;&lt; <span class="string">" shot(s) left\n"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，当我们捕获ammo时，在lambda中创建了一个具有相同名称和值的新const变量。我们不能修改它，因为它是const，这会导致编译错误。</p><h2 id="捕获可变-mutable-的值"><a href="#捕获可变-mutable-的值" class="headerlink" title="捕获可变(mutable)的值"></a>捕获可变(mutable)的值</h2><p>为了允许对值捕获的变量进行修改，我们可以将lambda<strong>标记为<code>mutable</code>。</strong></p><blockquote><p><strong>关键字<code>mutable</code>会除去 从值捕获的所有变量 的<code>const</code>限定。</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ammo&#123; <span class="number">10</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">auto</span> shoot&#123;</span><br><span class="line">      <span class="comment">//在参数列表之后添加了mutable。</span></span><br><span class="line">      [ammo]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">          <span class="comment">//我们现在可以修改ammo了</span></span><br><span class="line">          --ammo;</span><br><span class="line">           <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Pew! "</span> &lt;&lt; ammo &lt;&lt; <span class="string">" shot(s) left.\n"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  shoot();</span><br><span class="line">  shoot();</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ammo &lt;&lt; <span class="string">" shot(s) left\n"</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Pew! <span class="number">9</span> shot(s) left.</span><br><span class="line">Pew! <span class="number">8</span> shot(s) left.</span><br><span class="line"><span class="number">10</span> shot(s) left  <span class="comment">//真正的ammo的值是没有变的。</span></span><br></pre></td></tr></table></figure><p>虽然现在可以编译，但是还是有逻辑上面的错误，什么错误呢？</p><p>就是：当我们呢调用匿名函数(<code>shoot()</code>)，这个匿名函数捕获一个<code>ammo</code>的副本。当匿名函数对<code>ammo</code>进行递减（由10到9到8），<strong>它递减的是<code>ammo</code>的副本，而不是真正的<code>ammo</code></strong>（如何修改本真的ammo呢？就是利用“引用”来捕获）</p><p>注意：<code>ammo</code>的值在对lambda的调用中保持不变!</p><h2 id="通过“引用”-捕获"><a href="#通过“引用”-捕获" class="headerlink" title="通过“引用” 捕获"></a>通过“引用” 捕获</h2><p>就像函数可以改变通过引用传递的参数的值一样，我们也可以通过<strong>引用</strong>捕获变量<strong>来允许lambda改变参数的值。</strong>(所以，<strong>使用引用捕获，将不再需要<code>mutable</code></strong>)</p><p>为了通过引用捕获变量，我们在捕获的变量名之前加上一个<strong>&amp;</strong>符号。</p><p>与被值捕获的变量不同，<strong>被引用捕获的变量是非const的</strong>，除非它们捕获的变量是const。</p><blockquote><p><strong>当您通常希望通过引用将参数传递给函数时(例如，对于非基本类型)，应该首选通过引用捕获而不是通过值捕获。</strong></p></blockquote><hr><p>这是上面的代码，修改为通过引用来捕获ammo:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ammo</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> shoot&#123;</span><br><span class="line">        <span class="comment">////我们不再需要mutable</span></span><br><span class="line">        [&amp;ammo]() &#123; <span class="comment">// &amp;ammo是指通过引用来捕获ammo</span></span><br><span class="line">            <span class="comment">//这里改变ammo会影响 main's 中的ammo</span></span><br><span class="line">            --ammo;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Pew! "</span> &lt;&lt; ammo &lt;&lt; <span class="string">" shot(s) left.\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  	shoot();</span><br><span class="line"> </span><br><span class="line"> 	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ammo &lt;&lt; <span class="string">" shot(s) left\n"</span>;</span><br><span class="line"> </span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line">Pew! <span class="number">9</span> shot(s) left.</span><br><span class="line"><span class="number">9</span> shot(s) left</span><br></pre></td></tr></table></figure><h2 id="捕获多个变量"><a href="#捕获多个变量" class="headerlink" title="捕获多个变量"></a>捕获多个变量</h2><p>可以通过用<strong>逗号分隔</strong>多个变量来捕获它们。这可以包括由<strong>值</strong>或<strong>引用</strong>捕获的变量组合:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> health&#123; <span class="number">33</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> armor&#123; <span class="number">100</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;CEnemy&gt; enemies&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过值 捕获 health、armor；通过引用捕获enemies</span></span><br><span class="line">[health, armor, &amp;enemies]()&#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="默认捕获"><a href="#默认捕获" class="headerlink" title="默认捕获"></a>默认捕获</h2><p>显式地列出想要捕获的变量可能会很麻烦。如果您修改您的lambda，您可能会忘记添加或删除捕获的变量。</p><p><strong>幸运的是，我们可以利用编译器的帮助来自动生成需要捕获的变量列表</strong>。</p><hr><p><strong>默认捕获</strong>(也称<strong>capture-default</strong>) 捕获lambda中提到的所有变量。<strong>如果使用默认捕获，则不捕获lambda中未提到的变量。</strong></p><ul><li><p>若要按<strong>值</strong>捕获所有使用的变量，请使用<strong>=</strong>的捕获值。</p></li><li><p>若要通过<strong>引用</strong>捕获所有使用的变量，请使用<strong>&amp;</strong>的捕获值。</p></li></ul><p>看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span> areas&#123; <span class="number">100</span>, <span class="number">25</span>, <span class="number">121</span>, <span class="number">40</span>, <span class="number">56</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span>&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter width and height: "</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; <span class="built_in">width</span> &gt;&gt; <span class="built_in">height</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">auto</span> found&#123; <span class="built_in">std</span>::find_if(areas.<span class="built_in">begin</span>(), areas.<span class="built_in">end</span>(),</span><br><span class="line">                           [=](<span class="keyword">int</span> knownArea) &#123; <span class="comment">// will default capture width and height by value</span></span><br><span class="line">                             <span class="keyword">return</span> (<span class="built_in">width</span> * <span class="built_in">height</span> == knownArea); <span class="comment">// because they're mentioned here</span></span><br><span class="line">                           &#125;) &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (found == areas.<span class="built_in">end</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I don't know this area :(\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Area found :)\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认捕获可以与普通捕获混合使用。我们可以通过值捕获一些变量，通过引用捕获另一些变量，但是每个变量只能捕获一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> health&#123; <span class="number">33</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> armor&#123; <span class="number">100</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;CEnemy&gt; enemies&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据值 捕获health和armor，根据引用捕获enemies。</span></span><br><span class="line">[health, armor, &amp;enemies]()&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过引用来捕获enemie，通过值来捕获其他的一切。</span></span><br><span class="line">[=, &amp;enemies]()&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过引用来捕获其他的一切，通过值来捕获armor。</span></span><br><span class="line">[&amp;, armor]()&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*下面是一些非法的*/</span></span><br><span class="line"><span class="comment">//1.我们已经说过，我们想通过引用来捕获所有信息。✖</span></span><br><span class="line">[&amp;, &amp;armor]()&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.我们已经说过，我们希望通过值来捕获一切。✖</span></span><br><span class="line">[=, armor]()&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.armor出现两次。✖</span></span><br><span class="line">[armor, &amp;health, &amp;armor]() &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.默认捕获必须是捕获组中的第一个元素。✖</span></span><br><span class="line">[armor, &amp;]()&#123;&#125;; -----应该是--》[ &amp;, armor]()&#123;&#125;;</span><br></pre></td></tr></table></figure><h1 id="在lambda-capture中定义新变量"><a href="#在lambda-capture中定义新变量" class="headerlink" title="在lambda-capture中定义新变量"></a>在lambda-capture中定义新变量</h1><p>有时，我们希望通过轻微的修改来捕获一个变量，或者声明一个只在lambda作用域内可见的新变量。</p><p>我们可以通过<strong>在lambda-capture中定义一个变量<u>而不指定它的类型</u>来做到这一点。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span> areas&#123; <span class="number">100</span>, <span class="number">25</span>, <span class="number">121</span>, <span class="number">40</span>, <span class="number">56</span> &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span>&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter width and height: "</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; <span class="built_in">width</span> &gt;&gt; <span class="built_in">height</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 我们存储areas，但用户输入宽度和高度。</span></span><br><span class="line">  <span class="comment">// 我们需要先计算出面积，然后才能搜索它。</span></span><br><span class="line">  <span class="keyword">auto</span> found&#123; <span class="built_in">std</span>::find_if(areas.<span class="built_in">begin</span>(), areas.<span class="built_in">end</span>(),</span><br><span class="line">                           <span class="comment">// 声明一个仅对lambda可见的新变量(userarea)</span></span><br><span class="line">                           <span class="comment">// userarea的类型被自动推断为int</span></span><br><span class="line">                           [userArea&#123; <span class="built_in">width</span> * <span class="built_in">height</span> &#125;](<span class="keyword">int</span> knownArea) &#123;</span><br><span class="line">                             <span class="keyword">return</span> (userArea == knownArea);</span><br><span class="line">                           &#125;) &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (found == areas.<span class="built_in">end</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I don't know this area :(\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Area found :)\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当定义了lambda时，<code>userArea</code>只计算一次。计算的区域存储在lambda对象中，对于每个调用都是相同的。如果lambda是可变的，并且修改了在捕获中定义的变量，则原始值将被覆盖。</p><h2 id="空悬的捕获变量"><a href="#空悬的捕获变量" class="headerlink" title="空悬的捕获变量"></a>空悬的捕获变量</h2><p>变量在定义lambda的地方被捕获。如果被引用捕获的变量在lambda之前被销毁，lambda将保留一个悬空引用。</p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个lambda</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">makeWalrus</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 通过引用捕获name并返回lambda。</span></span><br><span class="line">    <span class="keyword">return</span> [&amp;]()&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">"I am a walrus, my name is "</span>&lt;&lt;name &lt;&lt;<span class="string">'\n'</span>; <span class="comment">//未定义行为</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个新的walrus，它的名字叫做Roofus.</span></span><br><span class="line">    <span class="comment">// sayName是makeWalrus返回的lambda。</span></span><br><span class="line">    <span class="keyword">auto</span> sayName &#123;makeWalrus(<span class="string">"Roofus"</span>)&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用makeWalrus返回的 lambda函数。</span></span><br><span class="line">    sayName();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对<code>makeWalrus</code>的调用将从字符串文本“Roofus”创建一个临时<code>std::string</code>。在<code>makeWalrus</code> 中的lambda 通过引用捕获了这个临时字符串。当返回<code>makeWalrus</code>时，临时字符串被销毁，但是lambda依然在引用它。然后当我们调用<code>sayName</code>，就会访问到这个空悬的引用，于是就造成了未定义行为。</p><blockquote><p>注意，<strong>如果按值将<code>name</code>传递给<code>makeWalrus</code>，也会发生这种情况。</strong></p></blockquote><hr><p>warning:</p><p><strong>通过引用捕获变量时要格外小心，特别是使用默认的引用捕获时。捕获的变量必须比lambda存在的时间长。</strong></p><hr><p>未完待续~~：<strong>Unintended copies of mutable lambdas</strong></p><blockquote><p>目前，本节剩下部分先不看。2020-05-07 22:26:38</p></blockquote><br><section class="widget copyright desktop mobile"><div class="content"><blockquote><p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p><p>本文永久链接是：<a href="https://longlongqin.github.io/archives/5ded0966.html">https://longlongqin.github.io/archives/5ded0966.html</a></p></blockquote></div></section><section class="widget qrcode desktop mobile"><div class="content article-entry"><fancybox><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/reward/AliPayOR.jpg" height="64px"></fancybox><fancybox><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/reward/WeChatPayOR.png" height="64px"></fancybox></div></section></div><section class="meta" id="footer-meta"><div class="new-meta-box"><div class="new-meta-item date" itemprop="dateUpdated" datetime="2020-12-31T13:11:48+08:00"><a class="notlink"><i class="fas fa-save" aria-hidden="true"></i><p>更新于：2020年12月31日</p></a></div><div class="new-meta-item share -mob-share-list"><div class="-mob-share-list share-body"><a class="-mob-share-qq" rel="external nofollow noopener noreferrer noopener" href="http://connect.qq.com/widget/shareqq/index.html?url=https://longlongqin.github.io/archives/5ded0966.html&title=C&C++/匿名函数 - 龙龙‘S BLOG&summary=" target="_blank"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qq.png"> </a><a class="-mob-share-qzone" rel="external nofollow noopener noreferrer noopener" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://longlongqin.github.io/archives/5ded0966.html&title=C&C++/匿名函数 - 龙龙‘S BLOG&summary=" target="_blank"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qzone.png"> </a><a class="-mob-share-weibo" rel="external nofollow noopener noreferrer noopener" href="http://service.weibo.com/share/share.php?url=https://longlongqin.github.io/archives/5ded0966.html&title=C&C++/匿名函数 - 龙龙‘S BLOG&summary=" target="_blank"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/weibo.png"></a></div></div></div></section><div class="prev-next"><a class="prev" href="/archives/1459e5c7.html"><p class="title"><i class="fas fa-chevron-left" aria-hidden="true"></i>C&C++/访问函数及封装</p><p class="content">为什么要将成员变量设为私有?在前一课中，我们提到类成员变量通常是私有的。学习面向对象编程的开发人员通常很难理解为什么要这样做。为了回答这个问题，让我们从一个类比开始。在现代生活中，我们可以使用许...</p></a><a class="next" href="/archives/5844b406.html"><p class="title">C&C++/省略号(以及为啥避免使用他)<i class="fas fa-chevron-right" aria-hidden="true"></i></p><p class="content">原文：https://www.learncpp.com/cpp-tutorial/714-ellipsis-and-why-to-avoid-them/在我们目前看到的所有函数中，必须提前知道函...</p></a></div></section></article><article class="post white-box comments shadow"><section class="article typo"><p ct><i class="fas fa-comments"></i> 评论</p><section id="comments"><div id="valine_container" class="valine_thread"><i class="fas fa-spinner fa-spin fa-fw"></i></div></section></section></article><script>window.subData={title:"C&C++/匿名函数",tools:!0}</script></div><aside class="l_side"><section class="widget toc-wrapper shadow desktop mobile"><header><i class="fas fa-list fa-fw" aria-hidden="true"></i><span class="name">本文目录</span></header><div class="content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#函数不能嵌套"><span class="toc-text">函数不能嵌套</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用匿名函数"><span class="toc-text">使用匿名函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#注意："><span class="toc-text">注意：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#匿名函数的类型"><span class="toc-text">匿名函数的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#匿名函数的类型到底是什么？"><span class="toc-text">匿名函数的类型到底是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#适用std-function而不适用auto的情况"><span class="toc-text">适用std::function而不适用auto的情况</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#匿名函数其实不是真正的函数"><span class="toc-text">匿名函数其实不是真正的函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#泛型的匿名函数（generic-lambdas）"><span class="toc-text">泛型的匿名函数（generic lambdas）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#泛型lambda和静态变量"><span class="toc-text">泛型lambda和静态变量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#返回类型推导和跟踪返回类型"><span class="toc-text">返回类型推导和跟踪返回类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#——————————"><span class="toc-text">——————————</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lambda-captures"><span class="toc-text">Lambda captures</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Capture-clauses-and-capture-by-value"><span class="toc-text">Capture clauses and capture by value</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#capture-clause"><span class="toc-text">capture clause</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#那么捕捉到底是如何工作的呢"><span class="toc-text">那么捕捉到底是如何工作的呢?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#注意"><span class="toc-text">注意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#捕获默认的const值"><span class="toc-text">捕获默认的const值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#捕获可变-mutable-的值"><span class="toc-text">捕获可变(mutable)的值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通过“引用”-捕获"><span class="toc-text">通过“引用” 捕获</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#捕获多个变量"><span class="toc-text">捕获多个变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#默认捕获"><span class="toc-text">默认捕获</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#在lambda-capture中定义新变量"><span class="toc-text">在lambda-capture中定义新变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#空悬的捕获变量"><span class="toc-text">空悬的捕获变量</span></a></li></ol></li></ol></div></section></aside><footer class="clearfix white"><br><br><div class="aplayer-container"><meting-js theme="#1BCDFC" autoplay volume="0.6" loop order="list" fixed="false" list-max-height="340px" server="netease" type="song" id="186453" list-folded="true"></meting-js></div><br><div class="social-wrapper"><a href="/atom.xml" class="social fas fa-rss flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="mailto:1198216723@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://github.com/longlongqin" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://music.163.com/#/user/home?id=285545421" class="social fas fa-headphones-alt flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a></div><red>&copy; 2020-2021 longlongqin 😊| powered by HEXO | theme volantis</red><br><yellow><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("03/01/2020 18:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="小站已运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒 "}setInterval("createtime()",250)</script></yellow><br><green><i class="fas fa-chart-area"></i> <span class="post-count">字数统计：307.9k</span></green>|<script type="text/javascript" src="https://v1.cnzz.com/z_stat.php?id=1278663994&web_id=1278663994"></script><br><cyan>博客内容遵循</cyan><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank"><cyan>署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</cyan></a></footer><script>setLoadingBarProgress(80)</script><script>setLoadingBarProgress(60)</script></div><a class="s-top fas fa-arrow-up fa-fw" href="javascript:void(0)"></a></div><script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script><script>var SEARCH_SERVICE="hexo",ROOT="/";ROOT.endsWith("/")||(ROOT+="/")</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script><script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script><script type="text/javascript">$(function(){Waves.attach(".flat-btn",["waves-button"]),Waves.attach(".float-btn",["waves-button","waves-float"]),Waves.attach(".float-btn-light",["waves-button","waves-float","waves-light"]),Waves.attach(".flat-box",["waves-block"]),Waves.attach(".float-box",["waves-block","waves-float"]),Waves.attach(".waves-image"),Waves.init()})</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script><script type="text/javascript">$(function(){var n=["https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/background/4.jpg"];!function(n){for(var o=n.length;o--;){var r=Math.floor(Math.random()*o),t=n[r];n[r]=n[o],n[o]=t}}(n),$(".cover").backstretch(n,{duration:"20000",fade:"1500"})})</script><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js" async></script><script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js" async></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.0/js/valine.js"></script><script>var GUEST_INFO=["nick","mail","link"],guest_info="nick,mail,link".split(",").filter(function(i){return-1<GUEST_INFO.indexOf(i)}),notify=!1,verify=!1,valine=new Valine;valine.init({el:"#valine_container",notify:notify,verify:verify,guest_info:guest_info,appId:"TYFUId8Xuddv6nUYuVUHJbac-gzGzoHsz",appKey:"bCYkC8WKY7n8VjI7K2g8MMJ3",placeholder:"快来评论吧~",pageSize:"10",avatar:"mp",lang:"zh-cn",visitor:"false",highlight:"true"})</script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1.4/js/app.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1/js/search.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script><script>!function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copyed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-clipboard-check');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPYED';
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-exclamation-triangle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
      });
    }
    initCopyCode();
  }(window, document);</script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>let LAZY_LOAD_IMAGE = "[object Object]";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });</script><script>setLoadingBarProgress(100)</script><script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)t=c[r],0<=(n=t.getBoundingClientRect()).bottom&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this);</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script></body></html>