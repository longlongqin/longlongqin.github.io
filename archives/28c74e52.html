<!DOCTYPE html><html><head hexo-theme="https://volantis.js.org/#2.1.4"><meta charset="utf-8"><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><title>LearnCpp chapter2 - 龙龙‘S BLOG</title><meta name="keywords" content="C++"><meta name="description" content="LearnCpp-chapter2https://www.learncpp.com"><link rel="alternate" href="/atom.xml" title="龙龙‘S BLOG"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css"><link rel="shortcut icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1.4.3/css/style.css"><script>function setLoadingBarProgress(e){document.getElementById("loading-bar").style.width=e+"%"}</script></head><body><script type="text/javascript" src="/js/love.js"></script><script type="text/javascript" src="/js/ergao.js"></script><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><header class="l_header shadow blur"><div class="wrapper"><div class="nav-sub container--flex"><a class="logo flat-box"></a><ul class="switcher h-list"><li><a class="s-comment flat-btn fas fa-comments fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-toc flat-btn fas fa-list fa-fw" target="_self" href="javascript:void(0)"></a></li></ul></div><div class="nav-main container container--flex"><a class="logo flat-box" target="_self" href="/"><i class="fas fa-home"></i> 龙龙</a><div class="menu navigation"><ul class="h-list"><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list-alt fa-fw fa-fw"></i> 索引</a><ul class="submenu"><li><a class="flat-box" href="/categories/" id="categories"><i class="fas fa-folder-open fa-fw fa-fw"></i> 分类</a><ul class="submenu"><li><a class="flat-box" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="categoriesE5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-fire fa-fw"></i> 学习笔记</a></li><li><a class="flat-box" href="/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" id="categoriesE5AE9EE794A8E68A80E5B7A7"><i class="fas fa-fire fa-fw"></i> 实用技巧</a></li></ul></li><li><a class="flat-box" href="/tags/" id="tags"><i class="fas fa-tags fa-fw fa-fw"></i> 标签</a></li><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list fa-fw fa-fw"></i> 时间轴</a></li></ul></li><li><a class="flat-box" href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="E5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-book fa-fw"></i> 学习笔记</a></li><li><a class="flat-box"><i class="fas fa-wrench fa-fw"></i> 工具</a><ul class="submenu"><li><a class="flat-box" href="https://www.thinkcmf.com/font/search/index.html" target="_blank" rel="noopener" id="https:www.thinkcmf.comfontsearchindex.html"><i class="fas fa-font fa-fw"></i> Font Awesome图标</a></li><li><a class="flat-box" href="https://www.sojson.com/image/change.html" target="_blank" rel="noopener" id="https:www.sojson.comimagechange.html"><i class="fa fa-crop fa-fw"></i> 在线图片尺寸修改</a></li><li><a class="flat-box" href="http://dir.scmor.com/" target="_blank" rel="noopener" id="http:dir.scmor.com"><i class="fa fa-search fa-fw"></i> Google学术&搜索镜像</a></li></ul></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw fa-fw"></i> 关于</a><ul class="submenu"><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-user-circle fa-fw fa-fw"></i> 关于我</a></li><hr><li><a class="flat-box" href="/friends/" id="friends"><i class="fas fa-link fa-fw"></i> 友人帐</a></li><li><a class="flat-box" href="/comment/" id="comment"><i class="fas fa-comment fa-fw"></i> 留言板</a></li><hr><li><a class="flat-box" href="https://github.com/longlongqin" target="_blank" rel="noopener" id="https:github.comlonglongqin"><i class="fab fa-github fa-fw fa-fw"></i> 我的Github</a></li><li><a class="flat-box" href="https://longlongqin.gitee.io" target="_blank" rel="noopener" id="https:longlongqin.gitee.io"><i class="fa fa-chevron-circle-right fa-fw"></i> matery主题博客</a></li></ul></li><li><a class="flat-box" href="https://volantis.js.org/tag-plugins/" target="_blank" rel="noopener" id="https:volantis.js.orgtag-plugins"><i class="fa fa-bookmark fa-fw"></i> Volantis主题文档</a></li><li><a class="flat-box" href="/easysearch/" id="easysearch"><i class="fa fa-search fa-fw"></i> easy搜索</a></li></ul></div><div class="m_search"><form name="searchform" class="form u-search-form"><i class="icon fas fa-search fa-fw"></i> <input type="text" class="input u-search-input" placeholder="search for everything"></form></div><ul class="switcher h-list"><li><a class="s-search flat-btn fas fa-search fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-menu flat-btn fas fa-bars fa-fw" target="_self" href="javascript:void(0)"></a></li></ul></div></div></header><ul class="menu-phone navigation white-box"><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list-alt fa-fw fa-fw"></i> 索引</a></li><li><a class="flat-box" href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="E5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-book fa-fw"></i> 学习笔记</a></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw fa-fw"></i> 关于</a></li></ul><script>setLoadingBarProgress(40)</script><div class="l_body nocover"><div class="body-wrapper"><div class="l_main"><article id="post" class="post white-box shadow article-type-post" itemscope itemprop="blogPost"><section class="meta"><div class="meta" id="header-meta"><h1 class="title"><a href="/archives/28c74e52.html">LearnCpp chapter2</a></h1><div class="new-meta-box"><div class="new-meta-item author"><a href="https://www.longlongqin.top" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongqin</p></a></div><div class="new-meta-item category"><a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="nofollow"><i class="fas fa-folder-open" aria-hidden="true"></i><p>学习笔记</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年3月26日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：8.5k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：35分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><center><p center large><red>LearnCpp-chapter2</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h2 id="2-1-函数"><a href="#2-1-函数" class="headerlink" title="2.1 函数"></a>2.1 函数</h2><p>当你读一本书的时候，突然有人给你打电话。然后你就用“书签”夹在当前阅读位置，去接电话。等你电话接完，再回到你放书签的那个地方继续读书。</p><p><strong>函数调用(function call)</strong>是一个表达式。它告诉CPU中断当前函数并在这里“放一个书签”，然后执行另一个函数(就是函数调用中提及的那个函数)。当调用结束后，CPU就返回到“书签”的位置，然后再继续执行。</p><blockquote><p><strong>caller</strong>：发起函数调用的函数叫做caller；</p><p><strong>callee(called function)</strong>：被调用的函数叫做callee(called function)。</p></blockquote><p><strong>int main()的返回值</strong>：</p><p>在int main()函数最后，会有返回值，这个值是返回到操作系统的，为了让操作系统知道这个程序执行成功与否。main函数的返回值，有一个特定名字叫做：<strong><u>status code （状态码）</u></strong></p><blockquote><p>一般 <code>return 0;</code> 表示程序执行成功。</p><p>返回非零值，表示程序执行错误。</p></blockquote><p>【<strong>Note</strong>】：<strong>C++规定，main函数必须是int型的。即： int main()</strong></p><h2 id="2-3-函数的形参与实参"><a href="#2-3-函数的形参与实参" class="headerlink" title="2.3 函数的形参与实参"></a>2.3 函数的形参与实参</h2><ul><li><p><strong>形参(parameter)</strong>：是指函数定义中参数；(形参初始化是通过调用者传来的值(即，实参)来初始化的 )</p><p><strong>实参(argument)</strong>：函数调用时的实际参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printValues</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">//函数定义时的参数x,y，即这里的x,y是形参</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printValues(<span class="number">6</span>, <span class="number">7</span>); <span class="comment">//调用函数。即，6和7是实参</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>实参与形参如何一起工作？</strong></p><p>当调用一个函数时，函数所有的parameters都被创建为变量，并且每个arguments的值都被复制到匹配的parameters中。这个过程称为<strong>pass by value(按值传递)</strong>。</p></li><li><p><strong>关于函数参数求值顺序的警告</strong></p><p>在C++中，没有规定实参匹配的顺序（顺序：从左→右，还是从右→左），因为匹配顺序不重要。</p><p>但是，如果实参是函数调用，那就需要注意了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someFunction(a(), b()); <span class="comment">// a() or b() may be called first</span></span><br></pre></td></tr></table></figure><ul><li>是从右→左，还是从右→左：<strong>取决于a()和b()的功能</strong>。</li></ul><p>如果你想要规定谁先的话，你可以显示的规定匹配顺序，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> avar&#123; a() &#125;; <span class="comment">// a() will always be called first</span></span><br><span class="line"><span class="keyword">int</span> bvar&#123; b() &#125;; <span class="comment">// b() will always be called second</span></span><br><span class="line"> </span><br><span class="line">someFunction(avar, bvar); <span class="comment">// it doesn't matter whether avar or bvar are copied first because they are just values</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="2-4-局部范围"><a href="#2-4-局部范围" class="headerlink" title="2.4 局部范围"></a>2.4 局部范围</h2><ul><li><strong>局部变量Local variables</strong>：函数的形参，和它内部定义的变量 属于“局部变量”。如：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// function parameters x and y are local variables</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> z&#123; x + y &#125;; <span class="comment">// z is a local variable too</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>局部变量生命周期</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// x and y are created and enter scope here</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// x and y are visible/usable within this function only</span></span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125; <span class="comment">// y and x go out of scope and are destroyed here</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a&#123; <span class="number">5</span> &#125;; <span class="comment">// a is created, initialized, and enters scope here</span></span><br><span class="line">    <span class="keyword">int</span> b&#123; <span class="number">6</span> &#125;; <span class="comment">// b is created, initialized, and enters scope here</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// a and b are usable within this function only</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(a, b) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// calls function add() with x=5 and y=6</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// b and a go out of scope and are destroyed here</span></span><br></pre></td></tr></table></figure><blockquote><p>执行过程：</p><ol><li><p>程序开始执行于main()函数；</p></li><li><p>main()函数的变量a被创建并赋值为5；（初始化）★</p></li><li><p>main()函数的变量b被创建并赋值为6；（初始化）★</p></li><li><p>函数add()被调用，并传入实参5，6；</p></li><li><p>add()函数的变量x被创建，并初值为5;（初始化）★</p></li><li><p>add()函数的变量y被创建，并初值为6;（初始化）★</p></li><li><p>操作符“+”计算表达式”x+y”，产生值11；</p></li><li><p>add函数将值11复制回调用者main()函数；</p></li><li><p>add函数的x、y被摧毁；★</p></li><li><p>main()函数在控制台上打印出11；</p></li><li><p>main()函数返回0到操作系统；</p></li><li><p>main()函数的a、b被摧毁。★</p></li></ol></blockquote><p>由此可知，<strong>局部变量的生命周期</strong>：是从他开始<u>被创建</u>（如上述的第2步，变量a被创建）一直到执行完这个它所在的函数（如上述的第9步）被摧毁。</p><p><strong>【Note】</strong>：变量的创建和摧毁发生在程序的<strong>运行期间（runtime）</strong>。所以生命周期是一个runtime属性。</p></li><li><p><strong>局部范围</strong></p><p><strong>标识符的范围</strong>决定了在源代码中标识符可以被访问的位置。范围是一个<strong>编译期间(compile-time)</strong>的属性。（当使用的标识符不在范围内时，编译器会报错）</p><p><strong>局部变量的范围</strong>：开始于它的<u>定义</u>，结束于<u>定义它们的花括号集合的末尾</u>。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// x is not in scope anywhere in this function</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello!\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// x can not be used here because it's not in scope yet</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> x&#123; <span class="number">0</span> &#125;; <span class="comment">// x enters scope here and can now be used</span></span><br><span class="line"> </span><br><span class="line">    doSomething();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// x goes out of scope here and can no longer be used</span></span><br></pre></td></tr></table></figure><h2 id="2-5-为什么要用函数"><a href="#2-5-为什么要用函数" class="headerlink" title="2.5 为什么要用函数"></a>2.5 为什么要用函数</h2></li></ul><p><strong>使用函数的优势</strong>：</p><ul><li><strong>有组织性Organization</strong>：随着程序越来越复杂，若将全部的代码都写在main()函数中，势必会增加复杂性。一个函数就像一个小型程序。将它与main函数分开写，我们就不必去考其余代码。</li><li><strong>可重用性Reusability</strong>：一个函数可以被调用无数次。就可以避免这种情况：如果写在main函数中，要调用n次这个功能，就要重新写这个功能n次。</li><li><strong>便于测试Testing</strong>：因为函数减少了代码冗余，所以首先要测试的代码就更少了。另外，因为函数是自包含的，所以一旦我们测试了一个函数以确保它可以工作，我们就不需要再次测试它，除非我们修改它。这减少了我们必须一次测试的代码量，使得查找bug(或者在第一时间避免bug)变得更加容易。</li><li><strong>可扩展性Extensibility</strong>：</li><li><strong>抽象化Abstraction</strong>：在每次用这个函数时，我们只需要知道它的名字。输入和输出。不必知道它是如何工作的。</li></ul><p><strong>如何高效的使用函数？</strong></p><ul><li>在一个程序中<u>出现多次的语句</u>通常应该构成一个函数。例如，如果我们以相同的方式多次读取来自用户的输入，那么这就是一个很好的函数候选。如果我们以相同的方式输出多次，这也是一个很好的候选函数。</li><li>一个函数通常应该执行一个(且仅一个)任务。</li><li>当一个函数变得太长、太复杂或难以理解时，可以将其分解为多个子函数。这就是所谓的<strong>重构refactoring</strong>。</li></ul><h2 id="2-6-空白与基本格式"><a href="#2-6-空白与基本格式" class="headerlink" title="2.6 空白与基本格式"></a>2.6 空白与基本格式</h2><h3 id="空白"><a href="#空白" class="headerlink" title="空白"></a>空白</h3><p><strong>空白Whitespace</strong>：是一个术语，指的是用于格式化目的的字符。在c++中，这主要指<strong>空格</strong>、<strong>制表符(tab)</strong>和<strong>换行</strong>。c++编译器通常会忽略空白，只有少数例外(在处理文本时)。因此，<strong>我们说c++是一种与空白无关的语言。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*下面这三个都是一样的作用*/</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>               &lt;&lt;            <span class="string">"Hello world!"</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; 		<span class="string">"Hello world!"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span></span><br><span class="line">	&lt;&lt; <span class="string">"Hello world!"</span>;</span><br></pre></td></tr></table></figure><p>【注意】</p><ul><li>在<strong>文本</strong>中，不允许换行：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这种是不被允许的</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello</span></span><br><span class="line"><span class="string">    world!"</span> ;</span><br></pre></td></tr></table></figure><ul><li><p>但是这种情况是可以的：文本只是被空白(空格、制表符(tab)、换行)分离，他将会被连接：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的hello与world都是被双引号包含起来的</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello "</span></span><br><span class="line">     <span class="string">"world!"</span>; <span class="comment">// prints "Hello world!"</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h3><ol><li><p><strong>缩进(indentation)</strong>可以用：<strong>空格spaces</strong>或者<strong>tabs（制符表）</strong>。</p><blockquote><p>如果用制符表，建议将其调整为4个空格的缩进，3个也可以。</p></blockquote></li><li><p><strong>大花括号（brace）</strong>：</p><ul><li><p>Google中的C++风格：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>另一种风格：这一种不容易出错，更容易找出花括号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在大花括号中的每条语句，应该从其所在花括号算起隔开一个tab的距离，开始写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!\n"</span>;       <span class="comment">// tabbed in one tab (4 spaces)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Nice to meet you.\n"</span>;  <span class="comment">// tabbed in one tab (4 spaces)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>每一行的字符不要过长，一般不超过80个字符</p></li><li><p>如果一行别操作符(如，&lt;&lt; 、+)分割(split)。这个操作符应该被卸载下一行的开头：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">3</span> + <span class="number">4</span></span><br><span class="line">    + <span class="number">5</span> + <span class="number">6</span></span><br><span class="line">    * <span class="number">7</span> * <span class="number">8</span>;</span><br></pre></td></tr></table></figure></li><li><p>通过对齐值或注释或在代码块之间添加间距，使用空白使代码更易于阅读。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不易读</span></span><br><span class="line">cost = <span class="number">57</span>;</span><br><span class="line">pricePerItem = <span class="number">24</span>;</span><br><span class="line">value = <span class="number">5</span>;</span><br><span class="line">numberOfItems = <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//易读</span></span><br><span class="line">cost          = <span class="number">57</span>;</span><br><span class="line">pricePerItem  = <span class="number">24</span>;</span><br><span class="line">value         = <span class="number">5</span>;</span><br><span class="line">numberOfItems = <span class="number">17</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不易读</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!\n"</span>; <span class="comment">// cout lives in the iostream library</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"It is very nice to meet you!\n"</span>; <span class="comment">// these comments make the code hard to read</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Yeah!\n"</span>; <span class="comment">// especially when lines are different lengths</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//易读</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!\n"</span>;                  <span class="comment">// cout lives in the iostream library</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"It is very nice to meet you!\n"</span>;  <span class="comment">// these comments are easier to read</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Yeah!\n"</span>;                         <span class="comment">// especially when all lined up</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不易读</span></span><br><span class="line"><span class="comment">// cout lives in the iostream library</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!\n"</span>;</span><br><span class="line"><span class="comment">// these comments make the code hard to read</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"It is very nice to meet you!\n"</span>;</span><br><span class="line"><span class="comment">// especially when all bunched together</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Yeah!\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//易读</span></span><br><span class="line"><span class="comment">// cout lives in the iostream library</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!\n"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// these comments are easier to read</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"It is very nice to meet you!\n"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// when separated by whitespace</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Yeah!\n"</span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-7-提前声明与定义"><a href="#2-7-提前声明与定义" class="headerlink" title="2.7 提前声明与定义"></a>2.7 提前声明与定义</h2><p>一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of 3 and 4 is: "</span> &lt;&lt; add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在vs 2013中运行，会出现：</p><p><code>add.cpp(5) : error C3861: &#39;add&#39;: identifier not found</code></p><p><strong>原因：</strong>因为编译器是按照顺序进行编译的。当编译器在main函数的第5行中调用add函数，他不知道add是什么。因为目前为止还没有定义add函数（因为add函数的定义在第9行）</p><hr><p><strong>如何解决呢？</strong></p><ol><li><p>法一：<strong>调整代码顺序</strong>：让被调用的函数在调用者之前【在复杂程序中，不实用】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of 3 and 4 is: "</span> &lt;&lt; add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>如果在一个复杂的程序中，会调用很多函数，还有嵌套型的调用。如果去一个个个去找出调用顺序，然后去调整代码。这样是很乏味低效的。</strong></p></blockquote></li><li><p>法二<strong>[推荐]</strong>：<strong>提前声明forward declaration</strong>：在使用函数之前，先声明它。（然后就不用关注代码实现的顺序了）</p><blockquote><p>提前向声明<strong>允许我们在实际定义标识符之前告诉编译器标识符的存在。</strong></p></blockquote><p>为了编写一个函数的提前向声明，我们使用一个称为<strong>函数原型(function prototype)</strong>的声明语句。函数原型包括：函数的 返回<strong>类型</strong>、<strong>名字</strong>、<strong>形参</strong>，以<strong>分号(semicolon)</strong>结束。但是不包含函数<strong>主体(function body)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="comment">// forward declaration of add() (using a function prototype)</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of 3 and 4 is: "</span> &lt;&lt; add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// this works because we forward declared add() above</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// even though the body of add() isn't defined until here</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="忘记定义函数主题"><a href="#忘记定义函数主题" class="headerlink" title="忘记定义函数主题"></a>忘记定义函数主题</h3><ol><li><p>如果<strong>声明</strong>了函数，但<strong>没定义</strong>函数，而且这个函数<strong>没有被调用</strong>，那么这个程序<strong>可以被编译&amp;运行</strong>；</p></li><li><p>如果<strong>声明</strong>了函数，但<strong>没定义</strong>函数，而且而且这个函数<strong>有被调用</strong>，那么这个程序<strong>可以被编译</strong>，但<strong>链接会出错</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="comment">// forward declaration of add() using function prototype</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of 3 and 4 is: "</span> &lt;&lt; add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// note: No definition for function add</span></span><br></pre></td></tr></table></figure><p>上面程序在visual studio 中，会出现：编译成功，链接失败</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Compiling...</span><br><span class="line">add.cpp</span><br><span class="line">Linking...</span><br><span class="line">add.obj : error LNK2001: unresolved external symbol &quot;int __cdecl add(int,int)&quot; (?add@@YAHHH@Z)</span><br><span class="line">add.exe : fatal error LNK1120: 1 unresolved externals</span><br></pre></td></tr></table></figure></li></ol><h3 id="声明-VS-定义"><a href="#声明-VS-定义" class="headerlink" title="声明 VS. 定义"></a>声明 VS. 定义</h3><ul><li><p><strong>定义(define)</strong>：实现(函数或类型）或者是 实例化(对于变量）标识符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// implements function add()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> z&#123; x + y &#125;; <span class="comment">// instantiates variable z</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于<strong>链接器(linker)</strong>来说<strong>定义（define）</strong>是必要的的。</p></blockquote></li></ul><h4 id="单定义规则"><a href="#单定义规则" class="headerlink" title="单定义规则"></a>单定义规则</h4><p><strong>单定义规则（one definition rule）</strong>简称：<strong>ODR</strong>：在C++中非常有名的规则，主要分三部分：</p><ol><li><p>在给定的文件中（这里翻译不准确），每个函数、对象、类型、模板<u>只能有一次定义</u>。</p></li><li><p>在整个程序中，一个对象或者函数只能被定义一次；</p></li><li><p>类型、模板、内置函数、变量 被允许在不同的文件中有相同的定义。</p><hr></li></ol><p><strong>违背第1条，将会使编译器发出重新定义错误；</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// violation part1 of ODR, we've already defined function add</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> x; <span class="comment">// violation of ODR, we've already defined x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在visual studio中，会出现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">project3.cpp(9): error C2084: function &#39;int add(int,int)&#39; already has a body</span><br><span class="line">project3.cpp(3): note: see previous definition of &#39;add&#39;</span><br><span class="line">project3.cpp(16): error C2086: &#39;int x&#39;: redefinition</span><br><span class="line">project3.cpp(15): note: see declaration of &#39;x&#39;</span><br></pre></td></tr></table></figure></li></ul><p><strong>违背第2条，将会使连接器发出重新定义的错误；</strong></p><p><strong>违背第3条，将会产生未定义的行为。</strong></p><hr><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p><strong>声明(declaration)</strong>：是一个语句。它告诉编译器这里存在一个标识符和它的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="comment">// tells the compiler about a function named "add" that takes two int parameters and returns an int.  No body!</span></span><br><span class="line"><span class="keyword">int</span> x; <span class="comment">// tells the compiler about an integer variable named x</span></span><br></pre></td></tr></table></figure><blockquote><p>对<strong>编译器(complier)</strong>而言<strong>声明(declaeation)</strong>是必要的。</p></blockquote><p>在C++中，所有的<strong>定义</strong>也用作<strong>声明</strong>。上述例子中的<code>int x</code>是 定义，也是声明。</p><p>多数情况下，<strong>定义</strong>符合我们的目的，因为定义能同时满足“编译器”和“链接器”的要求。</p><hr><p><red>【所有的<strong>定义</strong>都是<strong>声明</strong>，但所有的<strong>声明</strong>并不一定是<strong>定义</strong>。这些不是定义的声明有一个名字：<u><strong>纯声明(pure declarations)</strong></u>】</red></p><ul><li>一个典型的例子就是：<u>函数原型(function prototype)</u>，它满足编译器的要求，但不满足链接器的要求。</li><li>其他类型的纯声明包含：提前声明变量 和 类型声明。</li></ul><p><strong>单定义规则不适用于纯声明。</strong>所以，你可以对一些标识符声明n多次都可以（虽然声明n次，会有很多次是冗余的）</p><hr><p>小结：</p><p>在很多编程语言中，“声明”就是指“纯声明”；“定义”就是指“定义也可以用于声明”。所以，<code>int x;</code>是一个定义（虽然他既是定义，也是声明）</p><h2 id="2-9-命名冲突-amp-命名空间"><a href="#2-9-命名冲突-amp-命名空间" class="headerlink" title="2.9 命名冲突&amp;命名空间"></a>2.9 命名冲突&amp;命名空间</h2><h3 id="命名冲突"><a href="#命名冲突" class="headerlink" title="命名冲突"></a>命名冲突</h3><p><strong>命名冲突：naming collision</strong> (or <strong>naming conflict</strong>).</p><blockquote><p>将两个同名的标识符放在同一个程序中，编译器或者链接器无法区分它们时，就会报错。这种情况就是：<strong>命名冲突</strong></p></blockquote><p>例如：</p><blockquote><p>a.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFcn</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>main.cpp</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFcn</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> * x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当编译器编译这个程序时，它将会<strong>单独的</strong>编译<em>a.cpp</em>和<em>main.cpp</em>，每个cpp文件都编译成功。但是，当链接时，链接器将会链接<em>a.cpp</em>和<em>main.cpp</em>中所有的定义到一起，此时就发现函数<em>myFun</em>命名冲突了。【注意，虽然函数<em>myFun</em>没有被调用，但在链接时还是会出错】</p><p>命名冲突一般出现在以下两种情况：</p><ol><li>一个函数(或全局变量)的两个(或多个)定义被引入到不同的文件中，这些文件被编译到同一个程序中。这将导致一个<strong>链接器错误</strong>，如上所示。</li><li>一个函数(或全局变量)的两个(或多个)定义被引入到同一个文件中(通常通过#include)。这将导致<strong>编译器错误</strong>。</li></ol><p>对于<strong>局部变量</strong>，C++提供一种局部范围的机制，它使定义在函数内部的局部变量不会冲突。但这种机制对于函数的名字无效。</p><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p><strong>命名空间：namespace</strong></p><p><strong>命名空间：</strong>之所以出来这样一个东西，是因为人类可用的单词数太少，并且不同的人写的程序不可能所有的变量都没有重名现象，对于库来说，这个问题尤其严重，如果两个人写的库文件中出现同名的变量或函数(不可避免)，使用起来就有问题了。为了解决这个问题，引入了名字空间这个概念，通过使用 namespace xxx；你所使用的库函数或变量就是在该名字空间中定义的，这样一来就不会引起不必要的冲突了。</p><blockquote><p>注意，在同一命名空间中，所有的名字必须是独一无二的。</p></blockquote><h4 id="全局命名空间"><a href="#全局命名空间" class="headerlink" title="全局命名空间"></a>全局命名空间</h4><p>在C++中，任何没有定义在 类、函数、或 命名空间 的名字，都被默认的归为“<strong>全局命名空间(global namespace)</strong>”，有时也叫“<strong>全局范围(global scope)</strong>”</p><h4 id="std-命名空间"><a href="#std-命名空间" class="headerlink" title="std 命名空间"></a>std 命名空间</h4><p>在最初设计c++时，c++标准库中的所有标识符(包括std::cin和std::cout)都可以在没有std::前缀的情况下使用(它们是全局命名空间的一部分)。</p><p>但是，这意味着标准库中的任何标识符都可能与你自己定义的标识符的名字(也在全局名称空间中定义)发生冲突。</p><p>为了避免这种冲突，C++将所有标准库中的所有函数都移入一个叫做<strong>“std(是standard的简称)”的命名空间</strong>，即：<strong>std namespace</strong></p><blockquote><p>所以，你看到的<em>std::cout</em>，这并不是它的名字，它实际上只是<em>cout</em>，<em>std</em>只是命名空间的名字，而<em>cout</em>是std namespace中的一部分。</p></blockquote><p><strong>【注】：如果你使用一个命名空间中的标识符，你必须告诉编译器，这个标识符是在这个命名空间内。</strong></p><hr><ol><li><p><strong>显示的命名空间限定符 std::</strong></p><p>最直接的方法是：告诉编译器我们使用<em>cout</em>是来自 <em>std</em>这个namespace(命名空间)的。可以使用前缀 “std::” 来完成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!"</span>; <span class="comment">// when we say cout, we mean the cout defined in the std namespace</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>‘::’</strong> 是一个操作符，叫做<strong>“作用域解析符(scope resolution operator)”</strong>。</p><p>在它左边的标识符表示：所在命名空间的名称；在它右边的标识符表示：这个命名空间的一个 标识符。</p><p>【注】如果“::”的左边没有东西，则默认为它在<strong>全局命名空间( global namespace )</strong>中。</p></blockquote><p>std::cout就表示<em>cout</em>是在 std namsoace 中。</p></li></ol><ol start="2"><li><p><strong>using namespace std</strong></p><p>另一种方法是：用<strong>使用指令(using directive)**</strong><code>using namespace std</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">// this is a using directive telling the compiler to check the std namespace when resolving identifiers with no prefix</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!"</span>; <span class="comment">// cout has no prefix, so the compiler will check to see if cout is defined locally or in namespace std</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>using directive</strong>：告诉编译器 当试图解析一个没有使用<u>命名空间前缀(namespace prefix)</u>的标识符时，检查一个指定的命名空间。</p></blockquote><p><strong>【不推荐此方法】</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // imports the declaration of std::cout</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">// makes std::cout accessible as "cout"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cout</span><span class="params">()</span> <span class="comment">// declares our own "cout" function</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, world!"</span>; <span class="comment">// Compile error!  Which cout do we want here?  The one in the std namespace or the one we defined above?</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况，将不会被编译。因为编译器不知道我们到底想用我们自己定义的cout函数，还是想用 std命名空间 中的cout函数。</p><p>并且，虽然标识符名称现在可能不冲突，但在将来的语言修订中，它可能与添加到std名称空间的新标识符发生冲突。</p></li></ol><h2 id="2-10-预处理器"><a href="#2-10-预处理器" class="headerlink" title="2.10 预处理器"></a>2.10 预处理器</h2><p>在编译之前，代码要经过一个阶段，叫做“<strong>翻译(translation)</strong>”。在翻译阶段会发生许多事情，以使您的代码准备好被编译(如果您感兴趣，可以在<a href="https://en.cppreference.com/w/cpp/language/translation_phases" target="_blank" rel="noopener">这里</a>找到翻译阶段的列表)。应用翻译的代码文件称为<strong>翻译单元(translation unit)</strong>。</p><p>最值得注意的是：翻译阶段包含<strong>预处理器(preprocessor)</strong>。最好将预处理器看作是一个单独的程序，它处理每个代码文件中的文本部分。</p><p>当预处理器运行时，它从头到尾的扫描源码文件，寻找预处理程序指令。</p><blockquote><p><strong>预处理指令(preprocessor directives)，也称作directives</strong>：<u>是以“#”符号开始，以换行符结束的指令(不是分号，即不要加分号)</u>。</p></blockquote><ul><li><strong>“使用指令(using directives)”</strong>不是预处理指令，所以不会被预处理器处理。所以当提起“directive”，通常指的是“preprocessor directive”</li></ul><h4 id="include"><a href="#include" class="headerlink" title="include"></a>include</h4><p>当你<em>#include*一个文件，预处理器将会把</em>#include*指令 替换为 include file的内容。（include file 的内容将会被预处理，然后被编译）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, world!"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当预处理器运行时，预处理器将会把<code>#include &lt;iostream&gt;</code>替换为 名为“iostream”的文件。</p></blockquote><h4 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h4><p><strong>宏定义：Macro defines</strong></p><p><em>#include</em> 指令可以用来创建<strong>宏</strong>。在C++中，<strong>宏</strong>是定义如何将 ‘输入文本’ 转换为 ‘替换输出文本’。</p><p>宏有两种基本类型：1️⃣<strong>对象式宏</strong>(<em>object-like macros</em>)。2️⃣<strong>函数式宏</strong>( <em>function-like macros</em>)</p><ol><li><p>函数式宏</p><p>函数式宏的作用类似于函数，并具有类似的用途。</p></li><li><p>对象式宏</p><p>可以被定义成以下两种形式：</p><ul><li><p>#define identifier</p></li><li><p>#define identifier substitution_text</p><blockquote><p>此处，identifier：宏名【一般是大写字母，用下划线表示空格】；substitution_text：替换文本(替换输出文本)</p></blockquote></li></ul><p>1.带有输出文本(substitution_text)：当预处理器处理此条指令时，宏名 将会被替换为‘输出文本’。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_NAME <span class="meta-string">"Alex"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"My name is: "</span> &lt;&lt; MY_NAME;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预处理程序将上述转换为以下内容:</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"My name is: "</span> &lt;&lt; <span class="string">"Alex"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.不带输出文本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USE_YEN</span></span><br></pre></td></tr></table></figure><p>如你所想，这条宏指令工作方式：标识符的任何进一步出现都将被删除，并将被nothing替换!</p></li></ol><h4 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h4><p><strong>条件编译：conditional compilation</strong></p><p>使用<strong>条件编译的预处理指令</strong>可以设置在什么条件下编译，什么条件下不编译。比较常见的条件编译指令有以下三个：<em>#ifdef*、</em>#ifndef<em>、</em>#endif*</p><ul><li><p><strong><em>#ifdef</em></strong> 预处理指令允许预处理器检查这个标识符(identifier)是否已经被 #define(定义了)。如果被定义，那么在<em>#ifdef*和</em>#endif*之间的代码将会被编译；如果没被定义，这些代码将会被忽略。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_JOE</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PRINT_JOE</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Joe\n"</span>; <span class="comment">// if PRINT_JOE is defined, compile this code</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PRINT_BOB</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Bob\n"</span>; <span class="comment">// if PRINT_BOB is defined, compile this code</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><em>ifndef</em></strong>指令和<em>ifdef*指令的作用是相反的。即，如果这个标识符没有被 #define，那么在</em>#ifndef<em>和</em>#endif*之间的代码才会被编译</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PRINT_BOB</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Bob\n"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是“Bob”,因为PRINT_BOB没有被 #define，所有才会执行。</p></li><li><p><strong><em>#if 0</em></strong> ：条件编译的另一个常见用法是使用<em>#if 0</em>来排除正在编译的代码块(就像它在一个注释块中一样):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Joe\n"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0 <span class="comment">// Don't compile anything starting here</span></span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Bob\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Steve\n"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// until this point</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>【注】<strong>对象式宏</strong>不会影响<strong>预处理器的其他指令</strong></p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO 9 <span class="comment">// Here's a macro substitution</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> FOO <span class="comment">// This FOO does not get replaced because it’s part of another preprocessor directive</span></span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; FOO; <span class="comment">// This FOO gets replaced with 9 because it's part of the normal code</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="宏定义的范围"><a href="#宏定义的范围" class="headerlink" title="宏定义的范围"></a>宏定义的范围</h4><p>指令在编译之前，从上到下逐个文件地解析。</p><ol><li><strong>同一文件中</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_NAME <span class="meta-string">"Alex"</span></span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"My name is: "</span> &lt;&lt; MY_NAME;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然，上面的代码表面上看起来：<em>#define MY_NAME “Alex”</em>是定义在函数<em>foo</em>内部的。<strong>但是预处理器将不会注意，因为它不懂C++中的概念，例如函数。所以，这个程序的执行流程与#define MY_NAME “Alex”在函数foo之前或之后定义的行为相同。</strong>但是，一般情况下，我们习惯于将 <code>#define identifiers</code>这种宏定义放在函数的外面。</p><ol start="2"><li><strong>同一项目的不同文件中</strong></li></ol><p>预处理程序完成后，将丢弃该文件中定义的所有标识符。这意味着指令仅从<strong>定义点</strong>到<strong>定义它们的文件末尾</strong>有效。<u>在一个代码文件中定义的指令不会影响同一项目中的其他代码文件。</u></p><p>example：</p><p><code>function.cpp:</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PRINT</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Printing!"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PRINT</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Not printing!"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>; <span class="comment">// forward declaration for function doSomething()</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    doSomething();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行的结果是：Not printing!</p><p><strong>因为文件之间的宏定义互不影响。</strong></p><h2 id="2-11-头文件"><a href="#2-11-头文件" class="headerlink" title="2.11 头文件"></a>2.11 头文件</h2><p><strong>头文件：Header files</strong></p><p>当程序变得越来越大了，对每个函数都进行提前声明是很乏味无趣的。如果能够将所有的 提前声明 放在一个地方，然后在需要时导入它们，这不是很好吗?</p><blockquote><p><strong>code files</strong>：<strong>源文件(后缀 .cpp)</strong>；<strong>header files</strong>：<strong>头文件(后缀 .h 或 .hpp)</strong></p></blockquote><p>头文件的主要用途就是：将 声明 引入 源文件 中。</p><h4 id="使用标准库头文件"><a href="#使用标准库头文件" class="headerlink" title="使用标准库头文件"></a>使用标准库头文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, world!"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序使用<em>std::cout</em>。但是这个程序没有提供关于<em>std::cout</em>的声明或者定义，那编译器是如何知道<em>std::cout</em>是什么呢？</p><p>答：因为<em>std::cout<em>在头文件“iostream” 中 已经提前声明过了。当我们<code>#include &lt;iostream&gt;</code>时，我们就请求预处理器将头文件“iostream”中的所有内容(当然也包含</em>std::cout</em>)都复制过来。</p><blockquote><p><strong>注意：</strong><red>当<code>#include xxx</code>时，xxx头文件的所有内容都被引入到当前文件中。</red></p></blockquote><p><strong>头文件通常只包含：函数和对象的声明，不包含它们的定义</strong>。</p><blockquote><p>如 <em>std::cout</em>在头文件“iostream”中<u>声明</u>， 但 <u>定义</u>为c++标准库的一部分，在链接器阶段自动链接到程序中。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LearnCpp-chapter2/IncludeLibrary.png" alt="IncludeLibrary"></p></blockquote><h4 id="创建自己的头文件"><a href="#创建自己的头文件" class="headerlink" title="创建自己的头文件"></a>创建自己的头文件</h4><p>步骤：</p><ol><li><strong>头文件保护符(header guaed)</strong></li><li>然后添加头文件(后缀 .h)进行声明；相应的也要添加源文件(后缀 .cpp)进行定义。【注意头文件、源文件的名字要一样】</li></ol><p>创建完之后：</p><p><code>add.h</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1) We really should have a header guard here, but will omit it for simplicity (we'll cover header guards in the next lesson)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2) This is the content of the .h file, which is where the declarations go</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="comment">// function prototype for add.h -- don't forget the semicolon!</span></span><br></pre></td></tr></table></figure><p><code>add.cpp</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"add.h"</span> <span class="comment">// Insert contents of add.h at this point.  Note use of double quotes here.【不是标准库的头文件，一般用双引号""】</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of 3 and 4 is "</span> &lt;&lt; add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序的编译、链接过程：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="LearnCpp-chapter2/IncludeHeader.png" alt="IncludeHeader"></p><h4 id="头文件的-lt-gt-amp-””"><a href="#头文件的-lt-gt-amp-””" class="headerlink" title="头文件的&lt;&gt;&amp;””"></a>头文件的&lt;&gt;&amp;””</h4><p><strong>尖括号</strong>：<strong>Angled brackets</strong> ，即<strong>&lt;&gt;</strong>。尖括号用来告诉预处理程序我们包含了编译器包含的头文件，所以它应该在<u>系统目录中查找那个头文件</u>。</p><p><strong>双引号</strong>：<strong>double-quotes</strong>，即<strong>“”</strong>。双引号告诉预处理器这是一个用户定义的头文件，所以它应该在当前目录中寻找这个头文件。如果没找到，它会检查其他的包含路径(已指定为compiler/IDE设置的一部分的路径)。如果还是失败的话，它将去系统目录中寻找这个头文件。</p><h4 id="“iostream”没-h-后缀？"><a href="#“iostream”没-h-后缀？" class="headerlink" title="“iostream”没 .h 后缀？"></a>“iostream”没 .h 后缀？</h4><ol><li><p>好奇，为什么“iostream”(或者其他标准库头文件)没有后缀 .h？</p><p>答：因为<em>iostream.h</em>是另一个头文件</p></li><li><p><em>iostream.h</em>与<em>iostream</em>：</p><p>在C++最开始创建的时候，所有标准库都是有 .h 后缀的。但是，后来ANSI委员会修改C++，将所有的标准库放在 <em>std 命名空间</em> 中，进而避免与用户自定义的标识符 冲突。</p><p>但是为题来了，将这些标准库移入<em>std 命名空间</em> 后，以前的程序将无法运行。为了解决这个问题，一个新的头文件：<em>iostream</em>出现，这个新头文件包含了 <em>iostream.h</em>的所有内容。然后，旧的程序依然可以用<code>#include &lt;iostream.h&gt;</code>，新程序就用<code>#include &lt;iostream&gt;</code></p></li></ol><h4 id="头文件路径建议"><a href="#头文件路径建议" class="headerlink" title="头文件路径建议"></a>头文件路径建议</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/myHeader.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../moreHeaders/myOtherHeader.h"</span></span></span><br></pre></td></tr></table></figure><p>这种设置成路径形式的头文件，假设现在路径没问题。但是很有可能在某一天，你的文件位置就不小心的被移动了，这时候就用不了了。</p><p>【建议】将你平常会用到的很多不同的文件放在比较固定的地方，然后在你的 compiler/IDE 这个固定地方的位置。这样当它在当前目录中找不到它们时，它就会去你设置的固定位置找。这通常可以通过在IDE项目设置中设置包含路径或搜索目录来实现。</p><blockquote><p>visual studio设置方法：</p><p>在“解决方案”中，点击project的“属性”，然后看到“VC++目录”中的“包含目录(include directories)”，在这里面添加你要使用的头文件的目录。</p></blockquote><p>这种方法的优点是，如果要更改目录结构，只需更改单个编译器或IDE设置，而不必更改每个代码文件。</p><h2 id="2-12-头文件保护符"><a href="#2-12-头文件保护符" class="headerlink" title="2.12 头文件保护符"></a>2.12 头文件保护符</h2><p><strong>头文件保护符：header guards</strong></p><h3 id="重复定义"><a href="#重复定义" class="headerlink" title="重复定义"></a>重复定义</h3><p><strong>duplicate definition：重复定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变量重定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x; <span class="comment">// this is a definition for variable x</span></span><br><span class="line">    <span class="keyword">int</span> x; <span class="comment">// compile error: duplicate definition</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数重定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> <span class="comment">// this is a definition for function foo</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> <span class="comment">// compile error: duplicate definition</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; foo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种比较容易修复。</p><hr><p>但是在头文件中，很容易出现一个头文件中的定义被include不止一次。这通常发生在 一个头文件 又#include 其他头文件：</p><p><code>square.h</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在头文件中，不建议出现 定义；但是这里为了方便举例</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSquareSides</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>geometry.h</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"square.h"</span></span></span><br></pre></td></tr></table></figure><p><code>main.cpp</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"square.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"geometry.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个程序。首先，在<code>main.cpp</code>中<em>#include square.h</em> ，它(<em>square.h</em>)将<code>getSquareSides</code>函数的定义复制到main.cpp中。然后，<code>main.cpp</code>又<em>#include geometry.h</em> ，它(<em>geometry.h</em>)又包含了<em>square.h</em>，所以也会将<em>square.h</em>中的内容(包括<code>getSquareSides</code>函数)复制到<em>geometry.h</em>，进而也就被复制到<em>main.cpp</em>中。</p><p>所以，当解析完所有的<em>#include</em>之后，main.cpp就变成这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSquareSides</span><span class="params">()</span>  <span class="comment">// from square.h</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSquareSides</span><span class="params">()</span> <span class="comment">// from geometry.h (via square.h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，就会出现重复定义，编译也会出错。每个单独的文件没问题，但是因为main.cpp最终#include了两次square.h的内容，所以我们遇到了问题。如何解决呢？？？答：使用<strong>header guard</strong></p><h3 id="头文件保护符"><a href="#头文件保护符" class="headerlink" title="头文件保护符"></a>头文件保护符</h3><p><strong>头文件保护符(header guard)</strong>是<strong>条件编译(conditional compilation)</strong>的指令，它的形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SOME_UNIQUE_NAME_HERE <span class="comment">//SOME_UNIQUE_NAME_HERE：你可以用任何名字代替它</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOME_UNIQUE_NAME_HERE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里是写关于 声明 的代码</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>当这个头文件被<em>#included</em>时，预处理器检查<code>SOME_UNIQUE_NAME_HERE</code>是否被定义过。</p><ul><li>如果这是我们第一次包含这个头文件，<code>SOME_UNIQUE_NAME_HERE</code>还没有被创建。然后就会定义<code>SOME_UNIQUE_NAME_HERE</code>，而且会包含文件的内容。</li><li>如果这个头文件之前已经被包含到这个文件中，那么<code>SOME_UNIQUE_NAME_HERE</code>是已经被定义过的，而且其内容也以经被包含在这个文件中。所以这个头文件的内容将会被忽略（由于<strong><code>#ifndef</code></strong>）。</li></ul><hr><p><strong>每一个头文件都应该要有头文件保护符</strong>。</p><hr><p><strong>好的头文件保护符命名规则</strong>：</p><p><code>&lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H</code>或者<code>&lt;FILE&gt;_&lt;LARGE RANDOM NUMBER&gt;_H</code>或者<code>&lt;FILE&gt;_&lt;CREATION DATE&gt;_H</code></p><hr><p>请注意，头文件保护的目标是防止<strong>源文件</strong>多次接收到被保护的<strong>头文件</strong>。根据设计，头文件保护<strong>不</strong>会阻止将给定的头文件(一次)包含到单独的源码文件中。这也会导致意想不到的问题：</p><p><code>square.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SQUARE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE_H</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSquareSides</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSquarePerimeter</span><span class="params">(<span class="keyword">int</span> sideLength)</span></span>; <span class="comment">// forward declaration for getSquarePerimeter</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>square.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"square.h"</span>  <span class="comment">// square.h is included once here</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSquarePerimeter</span><span class="params">(<span class="keyword">int</span> sideLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sideLength * getSquareSides();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"square.h"</span> <span class="comment">// square.h is also included once here</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a square has "</span> &lt;&lt; getSquareSides() &lt;&lt; <span class="string">" sides\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a square of length 5 has perimeter length "</span> &lt;&lt; getSquarePerimeter(<span class="number">5</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，square.h包含在main.cpp和square.cpp中。这意味着square.h的内容将被包含一次到square.cpp中，一次到main.cpp中。</p><blockquote><p>细节：</p><p>当<code>square.h</code>被包含在<code>square.cpp</code>中时，在<code>square.cpp</code>结束之前，<code>SQUARE_H</code>都一直被定义。（这阻止了<code>square.h</code>被多次包含于<code>square.cpp</code>。也真是头文件保护符起作用的）。然而，一旦<code>square.cpp</code>结束后，<code>SQUARE_H</code>将不再被定义。这就意味着当预处理器运行<code>main.cpp</code>时，<code>SQUARE_H</code>在<code>main.cpp</code>中最初是没有定义的。</p><p>结果就是，<code>square.cpp</code>和<code>main.cpp</code>都复制了<em>getSquareSides</em>的定义。这个程序将<strong>可以被编译</strong>，但是会<strong>链接出错</strong>（链接器会抱怨为什么会有不止一个的<em>getSquareSides</em>的定义）</p></blockquote><p><strong>最好的解决办法就是：将函数的<u>定义</u>放在源文件中(即 .cpp文件中)，头文件中只含有<u>声明</u>。</strong></p><h3 id="pragma-once"><a href="#pragma-once" class="headerlink" title="#pragma once"></a>#pragma once</h3><p><code>#program once</code>的作用和头文件标识符相同，但是它更加短。</p><blockquote><p>但是，<code>#program once</code>不是C++官方原生的一部分，所以<strong>不是所有的编译器都支持它</strong>。</p></blockquote><br><section class="widget copyright desktop mobile"><div class="content"><blockquote><p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p><p>本文永久链接是：<a href="https://www.longlongqin.top/archives/28c74e52.html">https://www.longlongqin.top/archives/28c74e52.html</a></p></blockquote></div></section><section class="widget qrcode desktop mobile"><div class="content article-entry"><fancybox><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/reward/AliPayOR.jpg" height="64px"></fancybox><fancybox><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/reward/WeChatPayOR.png" height="64px"></fancybox></div></section></div><section class="meta" id="footer-meta"><div class="new-meta-box"><div class="new-meta-item date" itemprop="dateUpdated" datetime="2020-03-28T22:31:11+08:00"><a class="notlink"><i class="fas fa-save" aria-hidden="true"></i><p>更新于：2020年3月28日</p></a></div><div class="new-meta-item meta-tags"><a class="tag" href="/tags/C/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i><p>C++</p></a></div><div class="new-meta-item share -mob-share-list"><div class="-mob-share-list share-body"><a class="-mob-share-qq" rel="external nofollow noopener noreferrer noopener" href="http://connect.qq.com/widget/shareqq/index.html?url=https://www.longlongqin.top/archives/28c74e52.html&title=LearnCpp chapter2 - 龙龙‘S BLOG&summary=LearnCpp-chapter2https://www.learncpp.com" target="_blank"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qq.png"> </a><a class="-mob-share-qzone" rel="external nofollow noopener noreferrer noopener" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://www.longlongqin.top/archives/28c74e52.html&title=LearnCpp chapter2 - 龙龙‘S BLOG&summary=LearnCpp-chapter2https://www.learncpp.com" target="_blank"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qzone.png"> </a><a class="-mob-share-weibo" rel="external nofollow noopener noreferrer noopener" href="http://service.weibo.com/share/share.php?url=https://www.longlongqin.top/archives/28c74e52.html&title=LearnCpp chapter2 - 龙龙‘S BLOG&summary=LearnCpp-chapter2https://www.learncpp.com" target="_blank"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/weibo.png"></a></div></div></div></section><div class="prev-next"><a class="prev" href="/archives/c1a4eb67.html"><p class="title"><i class="fas fa-chevron-left" aria-hidden="true"></i>LearnCpp chapter4</p><p class="content">LearnCpp-chapter4https://www.learncpp.com4.1 基本的数据类型内存最小的单位是一个二进制数(binary digit)，即位(bit)。它可以存储一个0...</p></a><a class="next" href="/archives/2f66ae56.html"><p class="title">Let’s Build A Simple Interpreter-10<i class="fas fa-chevron-right" aria-hidden="true"></i></p><p class="content">今天的改进内容：如何进行语法Fenix和解释Pascal的程序头部；如何进行语法分析Pascal的变量声明；将更新解释器，用DIV关键字来表示整数的出发、用品”/“来表示浮点数的除法；添加Pas...</p></a></div></section></article><article class="post white-box comments shadow"><section class="article typo"><p ct><i class="fas fa-comments"></i> 评论</p><section id="comments"><div id="valine_container" class="valine_thread"><i class="fas fa-spinner fa-spin fa-fw"></i></div></section></section></article><script>window.subData={title:"LearnCpp chapter2",tools:!0}</script></div><aside class="l_side"><section class="widget toc-wrapper shadow desktop mobile"><header><i class="fas fa-list fa-fw" aria-hidden="true"></i><span class="name">本文目录</span></header><div class="content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-函数"><span class="toc-text">2.1 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-函数的形参与实参"><span class="toc-text">2.3 函数的形参与实参</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-局部范围"><span class="toc-text">2.4 局部范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-为什么要用函数"><span class="toc-text">2.5 为什么要用函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-空白与基本格式"><span class="toc-text">2.6 空白与基本格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#空白"><span class="toc-text">空白</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本格式"><span class="toc-text">基本格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-提前声明与定义"><span class="toc-text">2.7 提前声明与定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#忘记定义函数主题"><span class="toc-text">忘记定义函数主题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#声明-VS-定义"><span class="toc-text">声明 VS. 定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#单定义规则"><span class="toc-text">单定义规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#声明"><span class="toc-text">声明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-命名冲突-amp-命名空间"><span class="toc-text">2.9 命名冲突&amp;命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#命名冲突"><span class="toc-text">命名冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命名空间"><span class="toc-text">命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#全局命名空间"><span class="toc-text">全局命名空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#std-命名空间"><span class="toc-text">std 命名空间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10-预处理器"><span class="toc-text">2.10 预处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#include"><span class="toc-text">include</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#宏定义"><span class="toc-text">宏定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#条件编译"><span class="toc-text">条件编译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#宏定义的范围"><span class="toc-text">宏定义的范围</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#2-11-头文件"><span class="toc-text">2.11 头文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用标准库头文件"><span class="toc-text">使用标准库头文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建自己的头文件"><span class="toc-text">创建自己的头文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#头文件的-lt-gt-amp-””"><span class="toc-text">头文件的&lt;&gt;&amp;””</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#“iostream”没-h-后缀？"><span class="toc-text">“iostream”没 .h 后缀？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#头文件路径建议"><span class="toc-text">头文件路径建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-12-头文件保护符"><span class="toc-text">2.12 头文件保护符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#重复定义"><span class="toc-text">重复定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#头文件保护符"><span class="toc-text">头文件保护符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pragma-once"><span class="toc-text">#pragma once</span></a></li></ol></li></div></section></aside><footer class="clearfix white"><br><br><div class="aplayer-container"><meting-js theme="#1BCDFC" autoplay volume="0.6" loop order="list" fixed="false" list-max-height="340px" server="netease" type="song" id="186453" list-folded="true"></meting-js></div><br><div class="social-wrapper"><a href="/atom.xml" class="social fas fa-rss flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="mailto:1198216723@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://github.com/longlongqin" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://music.163.com/#/user/home?id=285545421" class="social fas fa-headphones-alt flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a></div><red>&copy; 2020-2020 longlongqin 😊| powered by HEXO | theme volantis</red><br><yellow><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("03/01/2020 18:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="小站已运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒 "}setInterval("createtime()",250)</script></yellow><br><green><i class="fas fa-chart-area"></i> <span class="post-count">字数统计：101.6k</span></green>|<script type="text/javascript" src="https://v1.cnzz.com/z_stat.php?id=1278663994&web_id=1278663994"></script><br><cyan>博客内容遵循</cyan><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank"><cyan>署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</cyan></a></footer><script>setLoadingBarProgress(80)</script><script>setLoadingBarProgress(60)</script></div><a class="s-top fas fa-arrow-up fa-fw" href="javascript:void(0)"></a></div><script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script><script>var SEARCH_SERVICE="hexo",ROOT="/";ROOT.endsWith("/")||(ROOT+="/")</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script><script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script><script type="text/javascript">$(function(){Waves.attach(".flat-btn",["waves-button"]),Waves.attach(".float-btn",["waves-button","waves-float"]),Waves.attach(".float-btn-light",["waves-button","waves-float","waves-light"]),Waves.attach(".flat-box",["waves-block"]),Waves.attach(".float-box",["waves-block","waves-float"]),Waves.attach(".waves-image"),Waves.init()})</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script><script type="text/javascript">$(function(){var n=["https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/background/4.jpg"];!function(n){for(var o=n.length;o--;){var r=Math.floor(Math.random()*o),t=n[r];n[r]=n[o],n[o]=t}}(n),$(".cover").backstretch(n,{duration:"20000",fade:"1500"})})</script><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js" async></script><script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js" async></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.0/js/valine.js"></script><script>var GUEST_INFO=["nick","mail","link"],guest_info="nick,mail,link".split(",").filter(function(i){return-1<GUEST_INFO.indexOf(i)}),notify=!1,verify=!1,valine=new Valine;valine.init({el:"#valine_container",notify:notify,verify:verify,guest_info:guest_info,appId:"TYFUId8Xuddv6nUYuVUHJbac-gzGzoHsz",appKey:"bCYkC8WKY7n8VjI7K2g8MMJ3",placeholder:"快来评论吧~",pageSize:"10",avatar:"mp",lang:"zh-cn",visitor:"false",highlight:"true"})</script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1.4/js/app.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1/js/search.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script><script>!function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copyed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-clipboard-check');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPYED';
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-exclamation-triangle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
      });
    }
    initCopyCode();
  }(window, document);</script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>let LAZY_LOAD_IMAGE = "[object Object]";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });</script><script>setLoadingBarProgress(100)</script><script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)t=c[r],0<=(n=t.getBoundingClientRect()).bottom&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this);</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script></body></html>