<!DOCTYPE html><html><head hexo-theme="https://volantis.js.org/#2.1.4"><meta charset="utf-8"><meta name="robots" content="noindex,follow"><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><title>归档：2020/6 - 龙龙‘S BLOG</title><link rel="alternate" href="/atom.xml" title="龙龙‘S BLOG"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css"><link rel="shortcut icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1.4.3/css/style.css"><script>function setLoadingBarProgress(e){document.getElementById("loading-bar").style.width=e+"%"}</script></head><body><script type="text/javascript" src="/js/love.js"></script><script type="text/javascript" src="/js/ergao.js"></script><div class="cover-wrapper"><cover class="cover half"><div class="cover-body"><div class="a"><p class="title white">龙龙'S BLOG</p><p class="subtitle white">你做三四月的事，在八九月自有答案。</p></div><div class="b"><div class="m_search"><form name="searchform" class="form u-search-form"><input type="text" class="input u-search-input" placeholder="search for anything"> <i class="icon fas fa-search fa-fw"></i></form></div><div class="menu navigation"><ul class="h-list"><li><a class="nav home white" href="/easysearch/" id="easysearch"><i class="fa fa-search fa-fw"></i>&nbsp;easy搜索</a></li><li><a class="nav home white" href="/" id="home"><i class="fas fa-rss fa-fw"></i>&nbsp;博文</a></li><li><a class="nav home white" href="https://devdocs.io" target="_blank" rel="noopener" id="https:devdocs.io"><i class="fas fa-code-branch fa-fw"></i>&nbsp;API文档浏览器</a></li><li><a class="nav home white" href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="E5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-book fa-fw"></i>&nbsp;学习笔记</a></li><li><a class="nav home white" href="https://longlongqin.github.io/archives/eaabd222.html" rel="nofollow" id="https:longlongqin.github.ioarchiveseaabd222.html"><i class="fa fa-bookmark fa-fw"></i>&nbsp;云书签</a></li><li><a class="nav home white" href="https://www.yuque.com/longlongqin/gis/hdwn9y" target="_blank" rel="nofollow noopener" id="https:www.yuque.comlonglongqingishdwn9y"><i class="fa fa-bookmark fa-fw"></i>&nbsp;GIS</a></li></ul></div></div></div></cover><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><header class="l_header shadow blur"><div class="wrapper"><div class="nav-sub container--flex"><a class="logo flat-box"></a><ul class="switcher h-list"><li><a class="s-comment flat-btn fas fa-comments fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-toc flat-btn fas fa-list fa-fw" target="_self" href="javascript:void(0)"></a></li></ul></div><div class="nav-main container container--flex"><a class="logo flat-box" target="_self" href="/"><i class="fas fa-home"></i> 龙龙</a><div class="menu navigation"><ul class="h-list"><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list-alt fa-fw fa-fw"></i> 索引</a><ul class="submenu"><li><a class="flat-box" href="/categories/" id="categories"><i class="fas fa-folder-open fa-fw fa-fw"></i> 分类</a><ul class="submenu"><li><a class="flat-box" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="categoriesE5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-fire fa-fw"></i> 学习笔记</a></li><li><a class="flat-box" href="/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" id="categoriesE5AE9EE794A8E68A80E5B7A7"><i class="fas fa-fire fa-fw"></i> 实用技巧</a></li></ul></li><li><a class="flat-box" href="/tags/" id="tags"><i class="fas fa-tags fa-fw fa-fw"></i> 标签</a></li><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list fa-fw fa-fw"></i> 时间轴</a></li></ul></li><li><a class="flat-box" href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="E5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-book fa-fw"></i> 学习笔记</a></li><li><a class="flat-box"><i class="fas fa-wrench fa-fw"></i> 工具</a><ul class="submenu"><li><a class="flat-box" href="https://www.thinkcmf.com/font/search/index.html" target="_blank" rel="noopener" id="https:www.thinkcmf.comfontsearchindex.html"><i class="fas fa-font fa-fw"></i> Font Awesome图标</a></li><li><a class="flat-box" href="https://www.sojson.com/image/change.html" target="_blank" rel="noopener" id="https:www.sojson.comimagechange.html"><i class="fa fa-crop fa-fw"></i> 在线图片尺寸修改</a></li><li><a class="flat-box" href="http://dir.scmor.com/" target="_blank" rel="noopener" id="http:dir.scmor.com"><i class="fa fa-search fa-fw"></i> Google学术&搜索镜像</a></li><li><a class="flat-box" href="https://emojixd.com/" target="_blank" rel="noopener" id="https:emojixd.com"><i class="fa fa-smile-o fa-fw"></i> Emoji表情符号辞典📓</a></li></ul></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw fa-fw"></i> 关于</a><ul class="submenu"><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-user-circle fa-fw fa-fw"></i> 关于我</a></li><hr><li><a class="flat-box" href="/friends/" id="friends"><i class="fas fa-link fa-fw"></i> 友人帐</a></li><li><a class="flat-box" href="/comment/" id="comment"><i class="fas fa-comment fa-fw"></i> 留言板</a></li><hr><li><a class="flat-box" href="https://github.com/longlongqin" target="_blank" rel="noopener" id="https:github.comlonglongqin"><i class="fab fa-github fa-fw fa-fw"></i> 我的Github</a></li><li><a class="flat-box" href="https://longlongqin.gitee.io" target="_blank" rel="noopener" id="https:longlongqin.gitee.io"><i class="fa fa-chevron-circle-right fa-fw"></i> matery主题博客</a></li></ul></li><li><a class="flat-box" href="https://volantis.js.org/tag-plugins/" target="_blank" rel="noopener" id="https:volantis.js.orgtag-plugins"><i class="fa fa-bookmark fa-fw"></i> Volantis主题文档</a></li><li><a class="flat-box" href="/easysearch/" id="easysearch"><i class="fa fa-search fa-fw"></i> easy搜索</a></li></ul></div><div class="m_search"><form name="searchform" class="form u-search-form"><i class="icon fas fa-search fa-fw"></i> <input type="text" class="input u-search-input" placeholder="search for everything"></form></div><ul class="switcher h-list"><li><a class="s-search flat-btn fas fa-search fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-menu flat-btn fas fa-bars fa-fw" target="_self" href="javascript:void(0)"></a></li></ul></div></div></header><ul class="menu-phone navigation white-box"><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list-alt fa-fw fa-fw"></i> 索引</a></li><li><a class="flat-box" href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="E5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-book fa-fw"></i> 学习笔记</a></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw fa-fw"></i> 关于</a></li></ul><script>setLoadingBarProgress(40)</script></div><div class="l_body"><div class="body-wrapper"><div class="l_main"><section class="post-list"><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/50be15c2.html">C&C++/调试c++程序</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年6月1日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：9.6k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：36分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><h1 id="语法和语义错误"><a href="#语法和语义错误" class="headerlink" title="语法和语义错误"></a>语法和语义错误</h1><p>原文：<a href="https://www.learncpp.com/cpp-tutorial/syntax-and-semantic-errors/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/syntax-and-semantic-errors/</a></p><hr><p>软件错误非常普遍。制作它们很容易，但要找到它们却很难。在本章中，我们将探索与在我们的c++程序中发现和清除bug相关的主题，包括学习如何使用集成调试器(IDE的一部分)。</p><p>当根据c++语言的语法编写无效的语句时，会发生<strong>语法错误</strong>。这包括错误，如缺少分号，使用未声明的变量，不匹配的括号或大括号等。例如，下面的程序包含相当多的语法错误:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt; <span class="string">"Hi there"</span>; &lt;&lt; x; <span class="comment">// invalid operator (&lt;), extraneous semicolon, undeclared variable (x)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> <span class="comment">// missing semicolon at end of statement</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>幸运的是，编译器通常会捕获语法错误并生成警告或错误，因此您可以轻松地识别和修复问题。然后只需重新编译，直到消除所有错误。</p><p>一旦你的程序正确编译，让它实际产生你想要的结果可能会很棘手。当语句在语法上有效，但没有按照程序员的意图执行时，就会发生<strong>语义错误</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" / "</span> &lt;&lt; b &lt;&lt; <span class="string">" = "</span> &lt;&lt; a / b; <span class="comment">// 除0没有定义</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现代编译器已经能够更好地检测某些类型的常见语义错误(例如使用未初始化的变量)。然而，在大多数情况下，编译器将无法捕获大多数这类问题，因为编译器的设计目的是加强语法，而不是意图。</p><p>在上面的例子中，错误是很容易发现的。但是在大多数重要的程序中，通过肉眼观察代码不容易发现语义错误。这就是调试技术可以派上用场的地方。</p><h1 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h1><p>原文：<a href="https://www.learncpp.com/cpp-tutorial/the-debugging-process/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/the-debugging-process/</a></p><p>假设您编写了一个程序，但是它不能正确地工作——代码编译得很好，但是当您运行它时，您将得到一个不正确的结果。你一定在什么地方犯了语义错误。你怎么找到它的?如果您一直遵循最佳实践，编写一些代码，然后对其进行测试，那么您可能已经很清楚错误在哪里了。或者你可能完全没有线索。</p><h2 id="调试的一般方法"><a href="#调试的一般方法" class="headerlink" title="调试的一般方法"></a>调试的一般方法</h2><p>一旦发现问题，调试问题通常包括五个步骤:</p><ol><li>找出问题的根本原因(通常是不能工作的代码行)</li><li>确保您理解问题发生的原因</li><li>决定如何解决这个问题</li><li>修复导致问题的问题</li><li>重新测试以确保问题已经解决，没有出现新的问题</li></ol><p>练习：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Adds two numbers</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y; <span class="comment">// function is supposed to add, but it doesn't</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// should produce 8, but produces 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码有一点很好: 错误非常明显，因为错误的答案通过第11行打印到屏幕上。这为我们的调查提供了一个起点。</p><p><strong>Find the root cause:</strong> On line 11, we can see that we’re passing in literals for arguments (5 and 3), so there is no room for error there. Since the inputs to function <em>add</em> are correct, but the output isn’t, it’s pretty apparent that function <em>add</em> must be producing the wrong value. The only statement in function <em>add</em> is the return statement, which must be the culprit. We’ve found the problem line. Now that we know where to focus our attention, noticing that we’re subtracting instead of adding is something you’re likely to find via inspection.</p><p><strong>Understand the problem:</strong> In this case, it’s obvious why the wrong value is being generated – we’re using the wrong operator.</p><p><strong>Determine a fix:</strong> We’ll simply change <em>operator-</em> to <em>operator+</em>.</p><p><strong>Repair the issue:</strong> This is actually changing <em>operator-</em> to <em>operator+</em> and ensuring the program recompiles.</p><p><strong>Retest:</strong> After implementing the change, rerunning the program will indicate that our program now produces the correct value of 8. For this simple program, that’s all the testing that’s needed.</p><p>This example is trivial, but illustrates the basic process you’ll go through when diagnosing any program.</p><h1 id="调试策略"><a href="#调试策略" class="headerlink" title="调试策略"></a>调试策略</h1><p>原文：<a href="https://www.learncpp.com/cpp-tutorial/a-strategy-for-debugging/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/a-strategy-for-debugging/</a></p><hr><p>在调试程序时，在大多数情况下，您的大部分时间都将花在寻找错误的实际位置上。一旦发现了问题，剩下的步骤 (修复问题并验证问题是否已修复) 相比之下通常是微不足道的。</p><h2 id="通过代码检查发现问题"><a href="#通过代码检查发现问题" class="headerlink" title="通过代码检查发现问题"></a>通过代码检查发现问题</h2><p>假设你注意到一个问题，你想要找出这个问题的原因。在许多情况下(<strong>特别是在较小的程序中</strong>)，我们可以很快确定问题所在。</p><p>然而，随着程序变得越来越复杂，通过代码检查发现问题也变得越来越复杂。</p><ul><li>首先，有更多的代码需要查看。在一个有数千行代码的程序中，查看每一行代码都要花费很长的时间(更不用说它是非常无聊的)。</li><li>其次，代码本身往往更复杂，出错的地方也更多。</li><li>第三，代码的行为可能不会给您提供很多关于哪里出了问题的线索。如果你写了一个程序来输出股票推荐，但实际上它什么也没输出，你可能就不知道从哪里开始寻找问题了。</li><li>最后，错误可能是由于错误的假设造成的。几乎不可能从视觉上发现由错误假设引起的错误，因为在检查代码时，您可能会做出相同的错误假设，而不会注意到错误。</li></ul><p>因此，如果我们有一个问题，我们不能通过代码检查发现，我们如何找到它?</p><h2 id="通过运行程序发现问题"><a href="#通过运行程序发现问题" class="headerlink" title="通过运行程序发现问题"></a>通过运行程序发现问题</h2><p>幸运的是，如果我们不能通过代码检查发现问题，那么我们可以采用另一种方法:<strong>我们可以观察程序运行时的行为，并尝试从中诊断问题。</strong>这种方法可以概括为:</p><ol><li>找出重现问题的方法</li><li>运行程序并收集信息以缩小问题所在</li><li>重复前面的步骤，直到找到问题为止</li></ol><p>在本章的其余部分，我们将讨论促进这种方法的技术。</p><h3 id="重现问题"><a href="#重现问题" class="headerlink" title="重现问题"></a>重现问题</h3><p>发现问题的第一步也是最重要的一步是能够重现问题。原因很简单: 除非你能观察到问题的发生，否则很难发现问题。</p><h3 id="关注问题"><a href="#关注问题" class="headerlink" title="关注问题"></a>关注问题</h3><p>一旦我们可以合理地重现问题，下一步就是找出问题在代码的什么地方。根据问题的性质，这可能是容易的，也可能是困难的。</p><h1 id="基本的调试策略"><a href="#基本的调试策略" class="headerlink" title="基本的调试策略"></a>基本的调试策略</h1><h2 id="调试策略-1-注释掉代码"><a href="#调试策略-1-注释掉代码" class="headerlink" title="调试策略#1:注释掉代码"></a>调试策略#1:注释掉代码</h2><p>如果程序显示出错误行为，减少必须搜索的代码量的一种方法是注释一些代码，看看问题是否仍然存在。如果问题仍然存在，注释掉的代码不负责。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    getNames(); <span class="comment">// ask user to enter a bunch of names</span></span><br><span class="line">    doMaintenance(); <span class="comment">// do some random stuff</span></span><br><span class="line">    sortNames(); <span class="comment">// sort them in alphabetical order</span></span><br><span class="line">    printNames(); <span class="comment">// print the sorted list of names</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们假设这个程序应该按字母顺序打印用户输入的名称，但是它按相反的字母顺序打印它们。问题在哪里?</p><p>它可以是上面的代码中的任何一个。但是我们可能怀疑<code>doMaintenance();</code>与这个问题没有任何关系，所以让我们注释掉它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    getNames(); <span class="comment">// ask user to enter a bunch of names</span></span><br><span class="line"><span class="comment">//    doMaintenance(); // do some random stuff</span></span><br><span class="line">    sortNames(); <span class="comment">// sort them in alphabetical order</span></span><br><span class="line">    printNames(); <span class="comment">// print the sorted list of names</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果问题消失了，那么问题一定是由<code>doMaintenance</code>引起的，我们应该把注意力集中在维护上。</p><p>但是，如果问题仍然存在(这种可能性更大)，那么我们就知道<code>doMaintenance</code>并不是错误，我们可以将该函数排除在外。这并不能帮助我们理解实际的问题是在对<code>doMaintenance</code>的调用之前还是之后，但是它减少了我们随后要检查的代码量。</p><p>不要忘记您注释掉了哪些函数，以便稍后取消注释!</p><h2 id="调试策略-2-验证代码流"><a href="#调试策略-2-验证代码流" class="headerlink" title="调试策略#2:验证代码流"></a>调试策略#2:验证代码流</h2><p>在更复杂的程序中常见的另一个问题是，程序调用一个函数的次数太多或太少(包括完全不调用)。</p><p>在这种情况下，将语句放在函数的顶部以打印函数名是很有帮助的。这样，当程序运行时，您就可以看到调用了哪些函数。</p><blockquote><p>当打印用于调试的信息时，使用<strong><code>std::cerr</code></strong>而不是std::cout。</p><ul><li>这样做的一个原因是std::cout可能会被缓冲，这意味着在您请求std::cout输出信息和它实际执行输出信息之间可能会有一个停顿。如果您使用std::cout输出，然后您的程序立即崩溃，那么std::cout可能还没有实际输出。这可能会误导你问题在哪里。</li><li>另一方面，std::cerr是无缓冲的，这意味着您发送给它的任何内容都会立即输出。这有助于确保所有调试输出尽快出现(以牺牲某些性能为代价，我们通常在调试时并不关心这些性能)。</li></ul></blockquote><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; getValue;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然我们希望这个程序打印值4，但它实际上会在不同的机器上打印不同的值。在作者的机器上，它打印:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00101424</span><br></pre></td></tr></table></figure><p>让我们在这些函数中添加一些调试语句:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"getValue() called\n"</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main() called\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; getValue;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>在添加临时调试语句时，最好不要缩进它们。这使得以后更容易找到它们并移除。</strong></p></blockquote><p>现在，当这些函数执行时，它们将输出它们的名称，表明它们被调用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main() called</span><br><span class="line">00101424</span><br></pre></td></tr></table></figure><p>现在我们可以看到函数getValue从未被调用。调用函数的代码一定有问题。让我们仔细看看这句话:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; getValue;</span><br></pre></td></tr></table></figure><p>看，我们忘了函数调用的括号了。应该是:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"getValue() called\n"</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main() called\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; getValue(); <span class="comment">// added parenthesis here</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将生成正确的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main() called</span><br><span class="line">getValue() called</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>我们可以删除临时调试语句。</strong></p><h2 id="调试策略-3-打印值"><a href="#调试策略-3-打印值" class="headerlink" title="调试策略#3:打印值"></a>调试策略#3:打印值</h2><p>对于某些类型的错误，程序可能正在计算或传递错误的值。</p><p>我们还可以输出变量(包括参数)或表达式的值，以确保它们是正确的。</p><p>考虑下面的程序，它本应该添加两个数字，但却不能正确工作:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printResult</span><span class="params">(<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The answer is: "</span> &lt;&lt; z &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getUserInput</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line">	<span class="keyword">int</span> x&#123;&#125;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x&#123; getUserInput() &#125;;</span><br><span class="line">	<span class="keyword">int</span> y&#123; getUserInput() &#125;;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" + "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">int</span> z&#123; add(x, <span class="number">5</span>) &#125;;</span><br><span class="line">	printResult(z);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是这个程序的一些输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Enter a number: 4</span><br><span class="line">Enter a number: 3</span><br><span class="line">4 + 3</span><br><span class="line">The answer is: 9</span><br></pre></td></tr></table></figure><p>这是不正确的。看到错误了吗?即使在这个简短的程序中，也很难发现它。让我们添加一些代码来调试我们的值:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printResult</span><span class="params">(<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The answer is: "</span> &lt;&lt; z &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getUserInput</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line">	<span class="keyword">int</span> x&#123;&#125;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x&#123; getUserInput() &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main::x = "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	<span class="keyword">int</span> y&#123; getUserInput() &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main::y = "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" + "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">int</span> z&#123; add(x, <span class="number">5</span>) &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main::z = "</span> &lt;&lt; z &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	printResult(z);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是上面的输出:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Enter a number: <span class="number">4</span></span><br><span class="line">main::x = <span class="number">4</span></span><br><span class="line">Enter a number: <span class="number">3</span></span><br><span class="line">main::y = <span class="number">3</span></span><br><span class="line"><span class="number">4</span> + <span class="number">3</span></span><br><span class="line">main::z = <span class="number">9</span></span><br><span class="line">The answer is: <span class="number">9</span></span><br></pre></td></tr></table></figure><p>变量x和y得到了正确的值，但变量z没有。问题必须在这两点之间，这使得函数<code>add()</code>成为一个关键问题。</p><p>让我们修改函数<code>add</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"add() called (x="</span> &lt;&lt; x &lt;&lt;<span class="string">", y="</span> &lt;&lt; y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//⭐</span></span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printResult</span><span class="params">(<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The answer is: "</span> &lt;&lt; z &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getUserInput</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line">	<span class="keyword">int</span> x&#123;&#125;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x&#123; getUserInput() &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main::x = "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	<span class="keyword">int</span> y&#123; getUserInput() &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main::y = "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" + "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">int</span> z&#123; add(x, <span class="number">5</span>) &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main::z = "</span> &lt;&lt; z &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	printResult(z);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Now we’ll <span class="built_in">get</span> the output:</span><br><span class="line"></span><br><span class="line">Enter a number: <span class="number">4</span></span><br><span class="line">main::x = <span class="number">4</span></span><br><span class="line">Enter a number: <span class="number">3</span></span><br><span class="line">main::y = <span class="number">3</span></span><br><span class="line">add() called (x=<span class="number">4</span>, y=<span class="number">5</span>)</span><br><span class="line">main::z = <span class="number">9</span></span><br><span class="line">The answer is: <span class="number">9</span></span><br></pre></td></tr></table></figure><p>变量y的值是3，但是我们的函数add却得到了参数y的值5，我们一定是传递了错误的参数。果然:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> z&#123; add(x, <span class="number">5</span>) &#125;;</span><br></pre></td></tr></table></figure><p>在这里。我们传递的是文字5，而不是变量y的值作为参数。这是一个简单的修复，然后我们可以<strong>删除调试语句</strong>。</p><h3 id="为什么使用-打印语句-进行调试不是很好"><a href="#为什么使用-打印语句-进行调试不是很好" class="headerlink" title="为什么使用 打印语句 进行调试不是很好"></a>为什么使用 打印语句 进行调试不是很好</h3><p>虽然将调试语句添加到用于诊断的程序中是一种常见的基本技术，也是一种功能性技术(特别是当调试器由于某种原因不可用时)，但它并不是很好，原因如下:</p><ol><li>调试语句使代码混乱。</li><li>调试语句会使程序的输出变得混乱。</li><li>在使用完调试语句之后，必须删除它们，这使得它们不可重用。</li><li>调试语句需要修改代码来添加和删除，这可能会引入新的错误。</li></ol><p>我们可以做得更好。我们将在以后的课程中探索如何做到这一点。</p><h1 id="更多的调试策略"><a href="#更多的调试策略" class="headerlink" title="更多的调试策略"></a>更多的调试策略</h1><h2 id="对调试代码进行条件化"><a href="#对调试代码进行条件化" class="headerlink" title="对调试代码进行条件化"></a>对调试代码进行条件化</h2><p>考虑以下包含一些调试语句的程序:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getUserInput</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"getUserInput() called\n"</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line">	<span class="keyword">int</span> x&#123;&#125;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main() called\n"</span>;</span><br><span class="line">    <span class="keyword">int</span> x&#123; getUserInput() &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"You entered: "</span> &lt;&lt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当您完成调试语句时，您将需要删除它们，或者注释掉它们。然后，如果您稍后还想要它们，就必须将它们添加回去，或者取消注释。</p><p>一种更容易在程序中禁用和启用调试的方法是使用<strong>预处理器指令使调试语句有条件</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENABLE_DEBUG <span class="comment">// 注释出以禁用调试</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getUserInput</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENABLE_DEBUG  <span class="comment">//⭐</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"getUserInput() called\n"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">//⭐</span></span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line">	<span class="keyword">int</span> x&#123;&#125;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENABLE_DEBUG  <span class="comment">//⭐</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"main() called\n"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">//⭐</span></span></span><br><span class="line">    <span class="keyword">int</span> x&#123; getUserInput() &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"You entered: "</span> &lt;&lt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们可以通过 注释/取消注释 #define ENABLE_DEBUG 来启用调试。这允许我们重用以前添加的调试语句，然后在使用它们时禁用它们，而不必从代码中实际删除它们。</p><p>如果这是一个<strong>多文件程序，那么#define ENABLE_DEBUG将位于一个头文件中</strong>，该头文件包含在所有代码文件中，因此我们可以在单个位置 注释/取消注 释#define，并让它传播到所有代码文件。</p><p>这解决了必须删除调试语句的问题和这样做的风险：</p><ul><li>但代价是代码更加混乱。</li><li>这种方法的另一个缺点是，如果您输入错误(例如拼错“DEBUG”)或忘记将头文件包含到代码文件中，那么可能无法启用该文件的部分或全部调试。</li></ul><h2 id="使用一个日志记录器"><a href="#使用一个日志记录器" class="headerlink" title="使用一个日志记录器"></a>使用一个日志记录器</h2><p>通过预处理程序进行条件化调试的另一种方法 是将调试信息发送到<strong>日志文件</strong>。</p><blockquote><p><strong>日志文件</strong>是一个记录软件中发生的事件的文件(通常存储在磁盘上)。</p><p>将信息写入日志文件的过程称为<strong>日志记录</strong>。</p></blockquote><p>大多数应用程序和操作系统编写的日志文件可用于帮助诊断发生的问题。</p><p>日志文件有一些优点：</p><ul><li><p>因为写入日志文件的信息与程序的输出是分开的，所以可以避免将正常输出和调试输出混合在一起所造成的混乱。</p></li><li><p>日志文件也可以很容易地发送给其他人进行诊断——因此，如果使用您的软件的人遇到问题，您可以让他们将日志文件发送给您，这可能会帮助您了解问题所在。</p></li></ul><p>虽然可以编写自己的代码来创建日志文件并向它们发送输出，<strong>但是最好使用现有的第三方日志工具之一</strong>。你用哪一个取决于你。</p><p>为了便于说明，我们将展示使用<a href="https://github.com/SergiusTheBest/plog" target="_blank" rel="noopener">plog</a>日志记录器输出到日志记录器的内容。</p><blockquote><p>Plog是作为一组头文件实现的，因此很容易在任何需要的地方包含它，而且它是轻量级的，易于使用。</p></blockquote><h3 id="如何使用plog日志记录器"><a href="#如何使用plog日志记录器" class="headerlink" title="如何使用plog日志记录器"></a>如何使用plog日志记录器</h3><p>If you want to compile the above example yourself, or use plog in your own projects, you can follow these instructions to install it:</p><p>First, get the latest plog release:</p><ul><li>Visit the <a href="https://github.com/SergiusTheBest/plog" target="_blank" rel="noopener">plog</a> repo.</li><li>Click the “releases” tab (it’s in the same row as “commits”, “branches”, “packages”, etc…)</li><li>Under the release tagged as “latest release” on the left, click the link “Source code (zip)” to download the latest release.</li></ul><p>Next, unzip the entire archive to `` on your hard drive.</p><p>Finally, for each project, set the <code>\plog-\include\</code> directory as an <code>include directory</code> inside your IDE. There are instructions on how to do this for Visual Studio here: <a href="https://www.learncpp.com/cpp-tutorial/a2-using-libraries-with-visual-studio-2005-express/" target="_blank" rel="noopener">A.2 – Using libraries with Visual Studio</a> and Code::Blocks here: <a href="https://www.learncpp.com/cpp-tutorial/a3-using-libraries-with-codeblocks/" target="_blank" rel="noopener">A.3 – Using libraries with Code::Blocks</a>.</p><h1 id="使用集成调试器-单步调试"><a href="#使用集成调试器-单步调试" class="headerlink" title="使用集成调试器: 单步调试"></a>使用集成调试器: 单步调试</h1><p>原文：<a href="https://www.learncpp.com/cpp-tutorial/using-an-integrated-debugger-stepping/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/using-an-integrated-debugger-stepping/</a></p><hr><p>当您运行程序时，执行从主函数的顶部开始，然后一个语句接着一个语句地执行，直到程序结束。</p><p>在任何时候当你的程序运行时,程序跟踪很多事情：你使用的变量的值，调用了哪些函数(当这些函数返回,程序将知道回到)，以及程序内的当前执行点(所以它知道这语句执行下一个)。所有这些被跟踪的信息都称为您的<strong>程序状态</strong>(或者简称为<strong>状态</strong>)。</p><p>在以前的课程中，我们探讨了各种修改代码以帮助调试的方法，包括打印诊断信息或使用日志记录器。这些是在程序<strong>运行时</strong>检查程序状态的简单方法。</p><p>尽管这些方法如果使用得当是有效的，但是它们仍然有缺点:</p><ul><li>它们需要修改代码，这需要时间，并且可能会引入新的错误，而且它们会使代码变得混乱，使现有的代码更难理解。</li></ul><p>到目前为止，我们所展示的技术背后有一个未阐明的假设:一旦我们运行代码，它就会运行到完成(只有在接受输入时才会暂停)，而我们没有机会在任何我们想要的地方干预和检查程序的结果。</p><p>但是，如果我们能够去掉这个假设呢?幸运的是,我们可以。大多数现代IDE都带有一个集成的工具，称为<strong>调试器</strong>，它的设计目的就是实现这一点。</p><h2 id="调试器"><a href="#调试器" class="headerlink" title="调试器"></a>调试器</h2><p><strong>调试器</strong>是一种计算机程序，它允许程序员控制程序的执行方式，并在程序运行时检查程序状态。例如，程序员可以使用调试器逐行执行程序，同时检查变量的值。通过比较变量的实际值和预期值，或者观察代码的执行路径，调试器可以极大地帮助跟踪语义(逻辑)错误。</p><p>调试器背后的强大功能有两方面：</p><ul><li>精确控制程序执行的能力；</li><li>以及 查看(和修改，如果需要)程序状态的能力。</li></ul><p>早期的调试器(如<a href="http://en.wikipedia.org/wiki/Gdb" target="_blank" rel="noopener">gdb</a>)是具有命令行接口的独立程序，程序员必须在命令行中输入晦涩难懂的命令才能工作。</p><p>后来的调试器(例如Borland的 <a href="http://en.wikipedia.org/wiki/Turbo_Debugger" target="_blank" rel="noopener">turbo debugger</a>的早期版本)仍然是独立的，但是有了自己的“图形化”前端，使得使用它们更加容易。</p><p>现在，大多数现代ide都有<strong>集成的调试器</strong>——也就是说，调试器使用与代码编辑器相同的接口，因此可以使用编写代码时使用的环境进行调试(而不必切换程序)。</p><p>几乎所有现代调试器都包含相同的基本特性标准集——然而，在如何安排菜单来访问这些功能方面几乎没有一致性，键盘快捷键的一致性就更少了。</p><p>本章的其余部分将用于学习如何使用调试器。</p><blockquote><p><strong>不要忽视学习使用调试器。随着程序变得越来越复杂，与查找和修复问题所节省的时间相比，学习如何有效地使用集成调试器所花费的时间就显得微不足道了。</strong></p></blockquote><h3 id="Step-into"><a href="#Step-into" class="headerlink" title="Step into"></a>Step into</h3><blockquote><p>In Visual Studio, the <em>step into</em> command can be accessed via <em>Debug menu &gt; Step Into</em>, or by pressing the F11 shortcut key.</p></blockquote><p>step into命令在程序的正常执行路径中执行下一个语句，然后暂停程序的执行，以便我们可以使用调试器检查程序的状态。</p><blockquote><p>如果正在执行的语句包含一个函数调用，单步执行会导致程序跳转到正在调用的函数的顶部，并在那里暂停。</p></blockquote><p>当你的程序不运行，你执行第一个调试命令，你可能会看到相当多的事情发生:</p><ul><li>如果需要，程序将重新编译。</li><li>程序将开始运行。因为我们的应用程序是一个控制台程序，所以应该打开控制台输出窗口。它将是空的，因为我们还没有输出任何东西。</li><li>您的IDE可能会打开一些诊断窗口，这些窗口的名称可能是“诊断工具”、“调用堆栈”和“监视”。稍后我们将介绍其中的一些内容—现在您可以忽略它们。</li></ul><h3 id="Step-over"><a href="#Step-over" class="headerlink" title="Step over"></a>Step over</h3><blockquote><p>In Visual Studio, the <em>step over</em> command can be accessed via <em>Debug menu &gt; Step Over</em>, or by pressing the F10 shortcut key.</p></blockquote><p>与step into类似，step over命令在程序的正常执行路径中执行下一条语句。但是，step into将输入函数调用并逐行执行它们，而<strong>step over将执行整个函数而不停止并在函数执行后将控制权返回给您。</strong></p><h3 id="Step-out"><a href="#Step-out" class="headerlink" title="Step out"></a>Step out</h3><blockquote><p>In Visual Studio, the <em>step out</em> command can be accessed via <em>Debug menu &gt; Step Out</em>, or by pressing the Shift-F11 快捷键组合.</p></blockquote><p>与其他两个单步执行命令不同，<strong>Step out</strong>不只是执行下一行代码。相反，<strong>它执行当前正在执行的函数中的所有剩余代码，然后在函数返回时将控制权返回给您。</strong></p><h3 id="Step-back"><a href="#Step-back" class="headerlink" title="Step back"></a>Step back</h3><p>一些调试器(如Visual Studio Enterprise Edition和GDB 7.0)引入了单步调试功能，通常称为<strong>单步后退</strong>或<strong>反向调试</strong>（<em>step back</em> or <em>reverse debugging</em>）。</p><p><strong>Step back</strong>的目的是回退最后一步，这样您就可以将程序返回到先前的状态。如果您执行的操作超过了一步，或者您想重新检查刚刚执行的语句，那么这将非常有用。由于其复杂性，这种功能还没有标准化，并且会因调试器的不同而有所不同。截止到编写本文时(2019年1月)，Visual Studio Community edition和最新版本的Code::Blocks都不支持这种功能。希望在未来的某个时候，它会慢慢渗透到这些产品中，并被更广泛的使用。</p><h1 id="使用集成调试器-运行和断点"><a href="#使用集成调试器-运行和断点" class="headerlink" title="使用集成调试器: 运行和断点"></a>使用集成调试器: 运行和断点</h1><h2 id="运行到光标处"><a href="#运行到光标处" class="headerlink" title="运行到光标处"></a>运行到光标处</h2><p>第一个有用的命令通常称为<strong>Run to cursor（运行到光标处）</strong>。这个<strong>Run to cursor</strong>命令执行程序，直到执行到光标所选择的语句为止。然后，它将控制权返回给您，以便您可以从该点开始调试。</p><p>这是一种高效的方式，可以在代码中的特定点开始调试，或者如果已经在调试，则可以直接移动到需要进一步检查的位置。</p><blockquote><p><strong>For Visual Studio users</strong></p><p>在Visual Studio中，右击代码中的语句并从上下文菜单中选择run to cursor，或者按下ctrl-F10组合键，就可以访问run to cursor命令。</p></blockquote><h2 id="Continue"><a href="#Continue" class="headerlink" title="Continue"></a>Continue</h2><p>在调试会话进行到一半时，您可能希望从那时开始运行程序。最简单的方法是使用<strong>continue命令</strong>。</p><p><strong>continue 调试命令</strong>只是继续按正常方式运行程序，直到程序终止，或者直到有东西触发控件再次返回给您(例如断点，我们将在本课后面介绍)。</p><blockquote><p><strong>For Visual Studio users</strong></p><p>在Visual Studio中，可以通过Debug <em>menu</em>&gt; <em>continue</em> 或 按F5快捷键在调试程序时访问continue命令。</p></blockquote><h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><p>continue命令有一个名为start的孪生兄弟。start命令执行与continue相同的操作，<strong>只是从程序的开头开始。它只能在不在调试会话中调用。</strong></p><blockquote><p>在Visual Studio中，<strong>可以在不调试程序的情况下</strong>通过 Debug <em>menu</em> &gt; start debugging 或按下F5快捷键来访问start命令。</p></blockquote><h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><p>本节要讨论的最后一个主题是断点。<strong>断点</strong>是一种特殊的标记，它告诉调试器在调试模式下运行时，在断点处停止程序的执行。</p><blockquote><p><strong>For Visual Studio users</strong></p><p>在Visual Studio中,可以通过设置或删除断点 <em>Debug menu &gt; Toggle Breakpoint</em>, 或右键单击一个语句, 从上下文菜单中选择Toggle breakpoint或按 F9快捷键,或通过点击左边的行号(浅灰色区域)。</p></blockquote><h2 id="设置下一条语句"><a href="#设置下一条语句" class="headerlink" title="设置下一条语句"></a>设置下一条语句</h2><p>还有一个调试命令使用得非常不常见，但至少值得了解，即使您不经常使用它。</p><p><strong>设置下一条语句</strong> 命令允许我们将执行点更改为其他一些语句(有时也称为<strong>跳转</strong>)。这可以用来向前跳转执行点，跳过一些本来要执行的代码，或者向后跳转，让已经执行的代码重新运行。</p><blockquote><p><strong>For Visual Studio users</strong></p><p>在Visual Studio中，您可以通过右键单击一个语句并从上下文菜单中选择<em>Set next statement</em>，或者按下Ctrl-Shift-F10快捷组合键来跳过执行点。此选项与上下文相关，<strong>仅在已经调试程序时才会出现。</strong></p></blockquote><p>注意：</p><p><em>set next statement</em> 命令将更改执行点，但不会更改程序状态。您的变量将保留它们在跳转之前的任何值。因此，与其他情况相比，跳转可能会导致程序产生不同的值、结果或行为。明智地使用此功能(特别是向后跳转)。</p><p>不应该使用<em>set next statement</em> 将执行点更改为其他函数。这将导致未定义的行为，并可能导致崩溃。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>现在，您了解了使用集成调试器监视和控制程序执行方式的主要方法。虽然这些命令对于诊断代码流问题非常有用(例如，确定是否调用某些函数)，但是它们只是集成调试器给表带来的好处的一部分。</p><p>在下一课中，我们将开始探索检查程序状态的其他方法，您将需要这些命令作为先决条件。我们走吧!</p><h1 id="使用集成调试器-监视变量"><a href="#使用集成调试器-监视变量" class="headerlink" title="使用集成调试器: 监视变量"></a>使用集成调试器: 监视变量</h1><h2 id="监视变量"><a href="#监视变量" class="headerlink" title="监视变量"></a>监视变量</h2><p><strong>监视变量是在程序以调试模式执行时检查变量值的过程</strong>。大多数调试器都提供了几种方法来实现这一点。</p><ul><li><p><strong>检查简单变量(如x) 值的最简单方法是将鼠标悬停在变量x上</strong>。一些现代调试器支持这种检查简单变量的方法，这是最直接的方法。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-Watch2-min.png" alt="img"></p><blockquote><p>注意，您可以将鼠标悬停在任何变量x上，而不仅仅是当前行上的变量x。例如，如果我们将鼠标悬停在第12行x上，我们将看到相同的值:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-Watch3-min.png" alt="img"></p></blockquote></li><li><p>如果你在使用Visual Studio，你也可以使用<strong>QuickWatch</strong>。用鼠标高亮显示变量名x，然后从右键菜单中选择“QuickWatch”。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-QuickWatch1-min.png" alt="img"></p><p>这将打开一个包含变量当前值的子窗口:</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-QuickWatch2-min.png" alt="img"></p><p>如果你打开了QuickWatch，请关闭它</p></li></ul><h2 id="监视窗口"><a href="#监视窗口" class="headerlink" title="监视窗口"></a>监视窗口</h2><p>如果你想知道一个变量的值在一个特定的时间点 ，使用<strong>鼠标悬停</strong>或<strong>QuickWatch</strong>方法检查变量很好。但是，它并不特别适合在运行代码时监视变量更改的值，因为您必须不断地 重新悬停/重新选择变量。</p><p>为了解决这个问题，所有现代集成调试器都提供了另一个特性，称为<strong>监视窗口</strong>。</p><p><strong>监视窗口</strong>是一个窗口，您可以在其中添加您想要持续检查的变量，并且当您单步执行程序时，这些变量将被更新。</p><p>当您进入调试模式时，监视窗口可能已经在您的屏幕上了，但是如果不是这样，您可以通过IDE的窗口命令(通常在视图或调试菜单中可以找到这些命令)打开它。</p><blockquote><p><strong>For Visual Studio users</strong></p><p>在Visual Studio中，<em>Debug menu &gt; Windows &gt; Watch &gt; Watch 1</em>. 中可以找到监视菜单。请注意，<strong>要启用此选项，必须处于调试模式，因此请先进入程序。</strong></p><p>此窗口出现的位置(停靠左、右或底部)可能不同。您可以通过将Watch 1选项卡拖动到应用程序窗口的另一侧来更改其停靠位置。</p></blockquote><p>超出作用域的变量(例如，函数中已经返回给调用者的局部变量)将留在您的监视窗口中，但通常要么被标记为“不可用”，要么显示最后一个已知值，但显示为灰色。如果变量返回到作用域(例如再次调用函数)，它的值将再次显示。因此，即使变量不在监视范围内，也可以将它们留在监视窗口中。</p><h2 id="监视窗口可以计算表达式"><a href="#监视窗口可以计算表达式" class="headerlink" title="监视窗口可以计算表达式"></a>监视窗口可以计算表达式</h2><p><strong>监视窗口</strong>还允许计算简单表达式。</p><h2 id="局部监视"><a href="#局部监视" class="headerlink" title="局部监视"></a>局部监视</h2><p>因为在调试时检查函数内部局部变量的值是很常见的，所以许多调试器会提供某种方式来快速监视 作用域中所有局部变量的值。</p><blockquote><p><strong>For Visual Studio users</strong></p><p>在Visual Studio中，可以在<strong>局部变量窗口</strong>中看到所有局部变量的值，可以在<em>Debug menu &gt; Windows &gt; Locals</em> 中找到。请注意，<strong>您必须处于调试会话中才能激活此窗口。</strong></p></blockquote><h1 id="使用集成调试器-调用栈"><a href="#使用集成调试器-调用栈" class="headerlink" title="使用集成调试器: 调用栈"></a>使用集成调试器: 调用栈</h1><p>现代调试器还包含一个调试信息窗口，它在调试程序时非常有用，即<strong>调用堆栈窗口</strong>。</p><p>当您的程序调用一个函数时，您已经知道它标记了当前位置，进行了函数调用，然后返回。它怎么知道回到哪里去? <strong>答案是它在调用堆栈中保持跟踪</strong>。</p><p>调用堆栈是所有已被调用以到达当前执行点的活动函数的列表。调用堆栈包括每个被调用函数的条目，以及函数返回时将返回到哪一行代码。</p><p>每当调用一个新函数时，该函数都会被添加到调用堆栈的顶部。当 当前函数返回给调用方时，它将从调用堆栈的顶部移除，而控制将返回给它下面的函数。</p><p><strong>“调用堆栈”窗口</strong>是一个显示当前调用堆栈的调试器窗口。如果没有看到“调用堆栈”窗口，则需要告诉IDE显示它。</p><blockquote><p><strong>For Visual Studio users</strong></p><p>在Visual Studio中，可以通过 <em>Debug menu &gt; Windows &gt; Call Stack</em>。请注意，<strong>您必须处于调试会话中才能激活此窗口。</strong></p></blockquote><hr><p>祝贺您，现在您已经了解了使用集成调试器的基本知识!通过使用单步执行、断点、监视和调用堆栈窗口，您现在已经具备了调试几乎所有问题的基础知识。</p><p>像许多事情一样，要想熟练使用调试器，需要一些实践和反复试验。但是，我们再次重申，花在学习如何有效使用集成调试器上的时间将比花在调试程序上的时间节省许多倍!</p><h1 id="在问题变成问题之前找到问题"><a href="#在问题变成问题之前找到问题" class="headerlink" title="在问题变成问题之前找到问题"></a>在问题变成问题之前找到问题</h1><p>当您犯语义错误时，当您运行程序时，这个错误可能不会立即被发现。一个问题可能潜伏在你的代码中很长一段时间都没有被发现，直到新引入的代码或改变的环境导致它作为程序故障出现。</p><p>在找到错误之前，错误在代码库中停留的时间越长，就越有可能难以找到它，本来很容易修复的错误会变成一场耗费时间和精力的调试冒险。</p><p>我们能做些什么呢?</p><h2 id="不要犯错误"><a href="#不要犯错误" class="headerlink" title="不要犯错误"></a>不要犯错误</h2><p>最好的办法是一开始就不要犯错误。这里有一个不完整的清单，可以帮助避免犯错误:</p><ul><li>遵循最佳实践</li><li>累了就别编程</li><li>了解一门语言中常见的陷阱(我们警告过你不要做的所有事情)</li><li>保持程序简单</li><li>不要让函数太长</li><li>尽可能使用标准库而不是编写自己的代码。</li><li>使用注释</li></ul><h2 id="重构功能"><a href="#重构功能" class="headerlink" title="重构功能"></a>重构功能</h2><p>当您向程序添加新功能(“行为更改”)时，您会发现一些函数的长度在增加。随着函数变长，它们变得更加复杂和难以理解。</p><p>解决这个问题的一种方法是将一个长函数分解成多个短函数。在不改变代码行为(通常是为了使其更易于维护)的情况下对代码进行结构更改的过程称为<strong>重构</strong>。</p><blockquote><p>那么对于一个函数，多长才算长呢?</p><p>一个占据一个垂直屏幕的函数通常被认为太长——如果必须滚动才能阅读整个函数，那么函数的可理解性就会显著下降。但是越短越好——函数小于10行就很好。小于5行的函数甚至更好。</p></blockquote><h2 id="介绍防御性编程"><a href="#介绍防御性编程" class="headerlink" title="介绍防御性编程"></a>介绍防御性编程</h2><p>错误不仅可能是您自己造成的(例如，不正确的逻辑)，还可能发生在您的用户以您没有预料到的方式使用应用程序时。</p><blockquote><p>例如，如果您要求用户输入一个整数，而用户输入的却是字母，那么在这种情况下，您的程序是如何运行的呢?除非您预料到了这一点，并为本例添加了一些错误处理，否则情况可能不太好。</p></blockquote><p><strong>防御性编程</strong>是一种实践，程序员试图预测软件可能被最终用户或使用代码的其他开发人员(包括程序员自己)滥用的所有方式。这些误用通常可以被发现，然后减轻(例如，要求输入错误输入的用户重试)。</p><p>我们将在以后的课程中探索与错误处理相关的主题。</p><h2 id="快速找到错误"><a href="#快速找到错误" class="headerlink" title="快速找到错误"></a>快速找到错误</h2><p>由于在大型程序中不出错是很困难的，所以下一个最好的方法就是快速捕获您确实犯的错误。</p><p><strong>最好的方法是每次编写一点程序，然后测试代码并确保它能正常工作。</strong></p><p>然而，还有一些其他的技术我们也可以使用。</p><h3 id="测试功能介绍"><a href="#测试功能介绍" class="headerlink" title="测试功能介绍"></a>测试功能介绍</h3><p>帮助发现程序问题的一种常见方法是<strong>编写测试函数来“练习”所编写的代码</strong>。这里有一个原始的尝试，更多的是为了说明的目的比任何东西:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testadd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"This function should print: 2 0 0 -2\n"</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">1</span>, <span class="number">1</span>) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">-1</span>, <span class="number">1</span>) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">1</span>, <span class="number">-1</span>) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">-1</span>, <span class="number">-1</span>) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	testadd();</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>testadd()函数通过使用不同的值调用add()函数来测试它。如果所有的值都符合我们的期望，那么我们就可以合理地确信函数是有效的。更好的是，我们可以保留这个函数，并在每次更改函数add时运行它，以确保我们没有意外地破坏它。</p><p>这是<strong>单元测试</strong>的基本形式，<strong>单元测试是一种软件测试方法，通过测试小单元的源代码来确定它们是否正确。</strong></p><p>与日志记录框架一样，可以使用许多第三方单元测试框架。也可以自己编写，不过我们需要更多的语言特性来处理主题。我们将在以后的课程中对此进行讨论。</p><h3 id="约束条件介绍"><a href="#约束条件介绍" class="headerlink" title="约束条件介绍"></a>约束条件介绍</h3><p>基于约束的技术包括添加一些额外的代码(如果需要，可以在非调试版本中编译)，以检查是否违反了一些假设或期望。</p><p>例如，如果我们编写一个函数来计算一个数字的阶乘，这个函数需要一个非负参数，那么该函数可以进行检查，以确保调用者在继续之前传入了一个非负的数字。如果调用方传入一个负数，那么函数可能会立即出错，而不是生成一些不确定的结果，从而帮助确保立即捕获问题。</p><p><strong>一种常见的方法是通过assert和static_assert</strong>，我们在<strong><a href="https://www.learncpp.com/cpp-tutorial/7-12a-assert-and-static_assert/" target="_blank" rel="noopener">7.12a – Assert and static_assert</a>.</strong>中介绍了这两个方法。</p></div></section></article></div></section></div><aside class="l_side"><section class="widget blogger shadow desktop"><div class="content"><div class="avatar"><img class="avatar" src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"></div><div class="text"><p><span id="jinrishici-sentence">龙龙‘S BLOG</span></p><script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script></div><div class="social-wrapper"><a href="/atom.xml" class="social fas fa-rss flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="mailto:1198216723@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://github.com/longlongqin" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://music.163.com/#/user/home?id=285545421" class="social fas fa-headphones-alt flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a></div></div></section><section class="widget grid shadow desktop mobile"><header><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i><span class="name">站内导航</span></header><div class="content"><div class="grid navigation"><a class="flat-box" title="/" href="/" id="home"><i class="fas fa-clock fa-fw" aria-hidden="true"></i> 近期文章 </a><a class="flat-box" title="/archives/" href="/archives/" rel="nofollow" id="archives"><i class="fas fa-archive fa-fw" aria-hidden="true"></i> 文章归档 </a><a class="flat-box" title="/friends/" href="/friends/" rel="nofollow" id="friends"><i class="fas fa-link fa-fw" aria-hidden="true"></i> 友人帐 </a><a class="flat-box" title="/about/" href="/about/" rel="nofollow" id="about"><i class="fas fa-info-circle fa-fw" aria-hidden="true"></i> 关于小站</a></div></div></section><section class="widget category shadow desktop"><header><a href="/blog/categories/"><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i><span class="name">文章分类</span></a></header><div class="content"><ul class="entry navigation"><li><a class="flat-box" title="/categories/OJ/" href="/categories/OJ/" id="categoriesOJ"><div class="name">OJ</div><div class="badge">(1)</div></a></li><li><a class="flat-box" title="/categories/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" href="/categories/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" id="categorieshexoE58D9AE5AEA2E690ADE5BBBA"><div class="name">hexo博客搭建</div><div class="badge">(1)</div></a></li><li><a class="flat-box" title="/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" href="/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" id="categoriesE58D9AE5AEA2E690ADE5BBBA"><div class="name">博客搭建</div><div class="badge">(4)</div></a></li><li><a class="flat-box" title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="categoriesE5ADA6E4B9A0E7AC94E8AEB0"><div class="name">学习笔记</div><div class="badge">(48)</div></a></li><li><a class="flat-box child" title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/" id="categoriesE5ADA6E4B9A0E7AC94E8AEB0C-C"><div class="name">C/C++</div><div class="badge">(25)</div></a></li><li><a class="flat-box child" title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git/" id="categoriesE5ADA6E4B9A0E7AC94E8AEB0Git"><div class="name">Git</div><div class="badge">(1)</div></a></li><li><a class="flat-box" title="/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" href="/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" id="categoriesE5AE9EE794A8E68A80E5B7A7"><div class="name">实用技巧</div><div class="badge">(1)</div></a></li><li><a class="flat-box" title="/categories/%E9%85%8D%E7%BD%AE/" href="/categories/%E9%85%8D%E7%BD%AE/" id="categoriesE9858DE7BDAE"><div class="name">配置</div><div class="badge">(1)</div></a></li></ul></div></section><section class="widget tagcloud shadow desktop"><header><a href="/blog/tags/"><i class="fas fa-tags fa-fw" aria-hidden="true"></i><span class="name">热门标签</span></a></header><div class="content"><a href="/tags/C/" style="font-size:16px;color:#8b8b8b">C++</a> <a href="/tags/C-C/" style="font-size:24px;color:#555">C/C++</a> <a href="/tags/Git/" style="font-size:14px;color:#999">Git</a> <a href="/tags/Hexo%E4%B8%BB%E9%A2%98/" style="font-size:14px;color:#999">Hexo主题</a> <a href="/tags/Let-s-Build-A-Simple-Interpreter/" style="font-size:22px;color:#636363">Let's Build A Simple Interpreter</a> <a href="/tags/Let%E2%80%99s-Build-A-Simple-Interpreter/" style="font-size:18px;color:#7e7e7e">Let’s Build A Simple Interpreter</a> <a href="/tags/OJ/" style="font-size:14px;color:#999">OJ</a> <a href="/tags/Yilia%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/" style="font-size:14px;color:#999">Yilia主题配置</a> <a href="/tags/forme/" style="font-size:14px;color:#999">forme</a> <a href="/tags/front-matter%E9%85%8D%E7%BD%AE/" style="font-size:14px;color:#999">front-matter配置</a> <a href="/tags/github/" style="font-size:14px;color:#999">github</a> <a href="/tags/hexo%E6%98%BE%E7%A4%BApdf/" style="font-size:14px;color:#999">hexo显示pdf</a> <a href="/tags/matery%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/" style="font-size:14px;color:#999">matery主题配置</a> <a href="/tags/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE%E3%80%8B/" style="font-size:18px;color:#7e7e7e">《计算机科学速成课》</a> <a href="/tags/%E5%87%B8%E5%8C%85/" style="font-size:20px;color:#707070">凸包</a> <a href="/tags/%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91%E5%92%8C%E9%80%BB%E8%BE%91%E9%97%A8/" style="font-size:14px;color:#999">布尔逻辑和逻辑门</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" style="font-size:14px;color:#999">计算几何</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE/" style="font-size:14px;color:#999">计算机科学速成课</a> <a href="/tags/%E9%85%8D%E7%BD%AE/" style="font-size:14px;color:#999">配置</a></div></section></aside><footer class="clearfix white"><br><br><div class="aplayer-container"><meting-js theme="#1BCDFC" autoplay volume="0.6" loop order="list" fixed="false" list-max-height="340px" server="netease" type="song" id="186453" list-folded="true"></meting-js></div><br><div class="social-wrapper"><a href="/atom.xml" class="social fas fa-rss flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="mailto:1198216723@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://github.com/longlongqin" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://music.163.com/#/user/home?id=285545421" class="social fas fa-headphones-alt flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a></div><red>&copy; 2020-2021 longlongqin 😊| powered by HEXO | theme volantis</red><br><yellow><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("03/01/2020 18:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="小站已运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒 "}setInterval("createtime()",250)</script></yellow><br><green><i class="fas fa-chart-area"></i> <span class="post-count">字数统计：307.9k</span></green>|<script type="text/javascript" src="https://v1.cnzz.com/z_stat.php?id=1278663994&web_id=1278663994"></script><br><cyan>博客内容遵循</cyan><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank"><cyan>署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</cyan></a></footer><script>setLoadingBarProgress(80)</script><script>setLoadingBarProgress(60)</script></div><a class="s-top fas fa-arrow-up fa-fw" href="javascript:void(0)"></a></div><script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script><script>var SEARCH_SERVICE="hexo",ROOT="/";ROOT.endsWith("/")||(ROOT+="/")</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script><script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script><script type="text/javascript">$(function(){Waves.attach(".flat-btn",["waves-button"]),Waves.attach(".float-btn",["waves-button","waves-float"]),Waves.attach(".float-btn-light",["waves-button","waves-float","waves-light"]),Waves.attach(".flat-box",["waves-block"]),Waves.attach(".float-box",["waves-block","waves-float"]),Waves.attach(".waves-image"),Waves.init()})</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script><script type="text/javascript">$(function(){var n=["https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/background/4.jpg"];!function(n){for(var o=n.length;o--;){var r=Math.floor(Math.random()*o),t=n[r];n[r]=n[o],n[o]=t}}(n),$(".cover").backstretch(n,{duration:"20000",fade:"1500"})})</script><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js" async></script><script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js" async></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1.4/js/app.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1/js/search.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script><script>!function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copyed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-clipboard-check');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPYED';
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-exclamation-triangle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
      });
    }
    initCopyCode();
  }(window, document);</script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>let LAZY_LOAD_IMAGE = "[object Object]";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });</script><script>setLoadingBarProgress(100)</script><script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)t=c[r],0<=(n=t.getBoundingClientRect()).bottom&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this);</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script></body></html>