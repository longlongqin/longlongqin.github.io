<!DOCTYPE html><html><head hexo-theme="https://volantis.js.org/#2.1.4"><meta charset="utf-8"><meta name="robots" content="noindex,follow"><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><title>归档：2020 - 龙龙‘S BLOG</title><link rel="alternate" href="/atom.xml" title="龙龙‘S BLOG"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css"><link rel="shortcut icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1.4.3/css/style.css"><script>function setLoadingBarProgress(e){document.getElementById("loading-bar").style.width=e+"%"}</script></head><body><script type="text/javascript" src="/js/love.js"></script><script type="text/javascript" src="/js/ergao.js"></script><div class="cover-wrapper"><cover class="cover half"><div class="cover-body"><div class="a"><p class="title white">龙龙'S BLOG</p><p class="subtitle white">你做三四月的事，在八九月自有答案。</p></div><div class="b"><div class="m_search"><form name="searchform" class="form u-search-form"><input type="text" class="input u-search-input" placeholder="search for anything"> <i class="icon fas fa-search fa-fw"></i></form></div><div class="menu navigation"><ul class="h-list"><li><a class="nav home white" href="/easysearch/" id="easysearch"><i class="fa fa-search fa-fw"></i>&nbsp;easy搜索</a></li><li><a class="nav home white" href="/" id="home"><i class="fas fa-rss fa-fw"></i>&nbsp;博文</a></li><li><a class="nav home white" href="https://devdocs.io" target="_blank" rel="noopener" id="https:devdocs.io"><i class="fas fa-code-branch fa-fw"></i>&nbsp;API文档浏览器</a></li><li><a class="nav home white" href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="E5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-book fa-fw"></i>&nbsp;学习笔记</a></li><li><a class="nav home white" href="https://longlongqin.github.io/archives/eaabd222.html" rel="nofollow" id="https:longlongqin.github.ioarchiveseaabd222.html"><i class="fa fa-bookmark fa-fw"></i>&nbsp;云书签</a></li><li><a class="nav home white" href="https://www.yuque.com/longlongqin/gis/hdwn9y" target="_blank" rel="nofollow noopener" id="https:www.yuque.comlonglongqingishdwn9y"><i class="fa fa-bookmark fa-fw"></i>&nbsp;GIS</a></li></ul></div></div></div></cover><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><header class="l_header shadow blur"><div class="wrapper"><div class="nav-sub container--flex"><a class="logo flat-box"></a><ul class="switcher h-list"><li><a class="s-comment flat-btn fas fa-comments fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-toc flat-btn fas fa-list fa-fw" target="_self" href="javascript:void(0)"></a></li></ul></div><div class="nav-main container container--flex"><a class="logo flat-box" target="_self" href="/"><i class="fas fa-home"></i> 龙龙</a><div class="menu navigation"><ul class="h-list"><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list-alt fa-fw fa-fw"></i> 索引</a><ul class="submenu"><li><a class="flat-box" href="/categories/" id="categories"><i class="fas fa-folder-open fa-fw fa-fw"></i> 分类</a><ul class="submenu"><li><a class="flat-box" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="categoriesE5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-fire fa-fw"></i> 学习笔记</a></li><li><a class="flat-box" href="/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" id="categoriesE5AE9EE794A8E68A80E5B7A7"><i class="fas fa-fire fa-fw"></i> 实用技巧</a></li></ul></li><li><a class="flat-box" href="/tags/" id="tags"><i class="fas fa-tags fa-fw fa-fw"></i> 标签</a></li><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list fa-fw fa-fw"></i> 时间轴</a></li></ul></li><li><a class="flat-box" href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="E5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-book fa-fw"></i> 学习笔记</a></li><li><a class="flat-box"><i class="fas fa-wrench fa-fw"></i> 工具</a><ul class="submenu"><li><a class="flat-box" href="https://www.thinkcmf.com/font/search/index.html" target="_blank" rel="noopener" id="https:www.thinkcmf.comfontsearchindex.html"><i class="fas fa-font fa-fw"></i> Font Awesome图标</a></li><li><a class="flat-box" href="https://www.sojson.com/image/change.html" target="_blank" rel="noopener" id="https:www.sojson.comimagechange.html"><i class="fa fa-crop fa-fw"></i> 在线图片尺寸修改</a></li><li><a class="flat-box" href="http://dir.scmor.com/" target="_blank" rel="noopener" id="http:dir.scmor.com"><i class="fa fa-search fa-fw"></i> Google学术&搜索镜像</a></li><li><a class="flat-box" href="https://emojixd.com/" target="_blank" rel="noopener" id="https:emojixd.com"><i class="fa fa-smile-o fa-fw"></i> Emoji表情符号辞典📓</a></li></ul></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw fa-fw"></i> 关于</a><ul class="submenu"><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-user-circle fa-fw fa-fw"></i> 关于我</a></li><hr><li><a class="flat-box" href="/friends/" id="friends"><i class="fas fa-link fa-fw"></i> 友人帐</a></li><li><a class="flat-box" href="/comment/" id="comment"><i class="fas fa-comment fa-fw"></i> 留言板</a></li><hr><li><a class="flat-box" href="https://github.com/longlongqin" target="_blank" rel="noopener" id="https:github.comlonglongqin"><i class="fab fa-github fa-fw fa-fw"></i> 我的Github</a></li><li><a class="flat-box" href="https://longlongqin.gitee.io" target="_blank" rel="noopener" id="https:longlongqin.gitee.io"><i class="fa fa-chevron-circle-right fa-fw"></i> matery主题博客</a></li></ul></li><li><a class="flat-box" href="https://volantis.js.org/tag-plugins/" target="_blank" rel="noopener" id="https:volantis.js.orgtag-plugins"><i class="fa fa-bookmark fa-fw"></i> Volantis主题文档</a></li><li><a class="flat-box" href="/easysearch/" id="easysearch"><i class="fa fa-search fa-fw"></i> easy搜索</a></li></ul></div><div class="m_search"><form name="searchform" class="form u-search-form"><i class="icon fas fa-search fa-fw"></i> <input type="text" class="input u-search-input" placeholder="search for everything"></form></div><ul class="switcher h-list"><li><a class="s-search flat-btn fas fa-search fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-menu flat-btn fas fa-bars fa-fw" target="_self" href="javascript:void(0)"></a></li></ul></div></div></header><ul class="menu-phone navigation white-box"><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list-alt fa-fw fa-fw"></i> 索引</a></li><li><a class="flat-box" href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="E5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-book fa-fw"></i> 学习笔记</a></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw fa-fw"></i> 关于</a></li></ul><script>setLoadingBarProgress(40)</script></div><div class="l_body"><div class="body-wrapper"><div class="l_main"><section class="post-list"><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/54babab5.html">C&C++/std：：string的末尾追加字符串</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月26日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：443字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：1分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/17-6-stdstring-appending/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/17-6-stdstring-appending/</a></p><hr><p>使用<strong>运算符+=</strong>、<strong>append()</strong>或<strong>push_back()</strong>函数可以很容易地将字符串追加到现有字符串的末尾。</p><p><strong><code>string&amp; string::operator+= (const string&amp; str)</code></strong></p><p><strong><code>string&amp; string::append (const string&amp; str)</code></strong></p><ul><li>这两个函数都将str的字符追加到字符串中。</li></ul><ul><li>两个函数都返回*this，因此它们可以被“链接”。</li><li>如果结果超过最大字符数，这两个函数都会抛出一个length_error异常。</li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sString</span><span class="params">(<span class="string">"one"</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">sString += <span class="built_in">string</span>(<span class="string">" two"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sThree</span><span class="params">(<span class="string">" three"</span>)</span></span>;</span><br><span class="line">sString.append(sThree);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one two three</span><br></pre></td></tr></table></figure><p>还有一种<strong>append()</strong>方法可以附加子字符串:</p><p><strong><code>string&amp; string::append (const string&amp; str, size_type index, size_type num)</code></strong></p><ul><li>这个函数将从str开始的num字符追加到字符串。</li><li>返回*this，这样它可以被“链接”。</li><li>如果索引超出范围，则抛出out_of_range</li><li>如果结果超过最大字符数，则抛出length_error异常。</li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sString</span><span class="params">(<span class="string">"one "</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> <span class="title">sTemp</span><span class="params">(<span class="string">"twothreefour"</span>)</span></span>;</span><br><span class="line">sString.append(sTemp, <span class="number">3</span>, <span class="number">5</span>); <span class="comment">// append substring of sTemp starting at index 3 of length 5</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one three</span><br></pre></td></tr></table></figure><p>运算符+=和append()也有<strong>处理c风格字符串</strong>的版本:</p><p><strong><code>string&amp; string::operator+= (const char* str)</code></strong></p><p><strong><code>string&amp; string::append (const char* str)</code></strong></p><ul><li><p>这两个函数都将str的字符追加到字符串中。</p></li><li><p>两个函数都返回*this，因此它们可以被“链接”。</p></li><li><p>如果结果超过最大字符数，这两个函数都会抛出一个length_error异常。</p></li><li><p>str不应该为空。</p></li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sString</span><span class="params">(<span class="string">"one"</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">sString += <span class="string">" two"</span>;</span><br><span class="line">sString.append(<span class="string">" three"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one two three</span><br></pre></td></tr></table></figure><p>下面还有很多，将只给出其声明，具体解释，请看原教程对应内容：</p><p><strong><code>string&amp; string::append (const char* str, size_type len)</code></strong></p><p><strong><code>string&amp; string::operator+= (char c)</code></strong></p><p><strong><code>void string::push_back (char c)</code></strong></p><p><strong><code>string&amp; string::append (size_type num, char c)</code></strong></p><p><strong><code>string&amp; string::append (InputIterator start, InputIterator end)</code></strong></p></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/6b2ecf81.html">C&C++/std：：string的赋值 与 交换</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月26日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：628字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：2分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/17-5-stdstring-assignment-and-swapping/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/17-5-stdstring-assignment-and-swapping/</a></p><hr><h1 id="字符串赋值"><a href="#字符串赋值" class="headerlink" title="字符串赋值"></a>字符串赋值</h1><p><strong>给字符串赋值的最简单方法是使用重载的运算符=函数</strong>。<strong>还有一个assign()成员函数</strong>，它复制了某些功能。</p><p><strong><code>string&amp; string::operator= (const string&amp; str)</code></strong></p><p><strong><code>string&amp; string::assign (const string&amp; str)</code></strong></p><p><strong><code>string&amp; string::operator= (const char* str)</code></strong></p><p><strong><code>string&amp; string::assign (const char* str)</code></strong></p><p><strong><code>string&amp; string::operator= (char c)</code></strong></p><ul><li>这些函数将各种类型的值赋给字符串。</li><li>这些函数返回*this，因此它们可以被“链接”。</li><li>注意，<strong>不存在接受单个字符</strong>的<strong>assign()</strong>函数。</li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> sString;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Assign a string value</span></span><br><span class="line">sString = <span class="built_in">string</span>(<span class="string">"One"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> <span class="title">sTwo</span><span class="params">(<span class="string">"Two"</span>)</span></span>;</span><br><span class="line">sString.assign(sTwo);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Assign a C-style string</span></span><br><span class="line">sString = <span class="string">"Three"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">sString.assign(<span class="string">"Four"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Assign a char</span></span><br><span class="line">sString = <span class="string">'5'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Chain assignment</span></span><br><span class="line"><span class="built_in">string</span> sOther;</span><br><span class="line">sString = sOther = <span class="string">"Six"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString &lt;&lt; <span class="string">" "</span> &lt;&lt; sOther &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">One</span><br><span class="line">Two</span><br><span class="line">Three</span><br><span class="line">Four</span><br><span class="line"><span class="number">5</span></span><br><span class="line">Six Six</span><br></pre></td></tr></table></figure><h2 id="assign-成员函数也有其他一些版本"><a href="#assign-成员函数也有其他一些版本" class="headerlink" title="assign()成员函数也有其他一些版本"></a>assign()成员函数也有其他一些版本</h2><p><strong><code>string&amp; string::assign (const string&amp; str, size_type index, size_type len)</code></strong></p><ul><li><p>赋值一个str的子字符串，从index开始，长度为len</p></li><li><p>如果索引超出范围，则抛出out_of_range异常</p></li><li><p>返回*this，这样它可以被“链接”。</p></li></ul><p>如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> <span class="title">sSource</span><span class="params">(<span class="string">"abcdefg"</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span> sDest;</span><br><span class="line"> </span><br><span class="line">sDest.assign(sSource, <span class="number">2</span>, <span class="number">4</span>); <span class="comment">// assign a substring of source from index 2 of length 4</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sDest &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cdef</span><br></pre></td></tr></table></figure><p><strong><code>string&amp; string::assign (const char\* chars, size_type len)</code></strong></p><ul><li><p>从c风格的数组字符中分配len字符</p></li><li><p>如果结果超过最大字符数，则抛出length_error异常</p></li><li><p>返回*this，这样它可以被“链接”。</p></li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> sDest;</span><br><span class="line"> </span><br><span class="line">sDest.assign(<span class="string">"abcdefg"</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sDest &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcd</span><br></pre></td></tr></table></figure><p><strong>这个函数有潜在的危险，不建议使用它。</strong></p><p><strong><code>string&amp; string::assign (size_type len, char c)</code></strong></p><ul><li>使用len个字符c 来赋值</li><li>如果结果超过最大字符数，则抛出length_error异常</li><li>返回*this，这样它可以被“链接”。</li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> sDest;</span><br><span class="line"> </span><br><span class="line">sDest.assign(<span class="number">4</span>, <span class="string">'g'</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sDest &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gggg</span><br></pre></td></tr></table></figure><h1 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h1><p>如果有两个字符串，并且希望交换它们的值，那么可以使用两个名为<strong>swap()</strong>的函数。</p><p><strong><code>void string::swap (string &amp;str)</code></strong></p><p><strong><code>void swap (string &amp;str1, string &amp;str2)</code></strong></p><ul><li><p>两个函数交换两个字符串的值。<strong>成员函数</strong>交换<em>this和str，*</em>全局函数**交换str1和str2。</p></li><li><p>这些函数是有效的，应该用来代替赋值来执行字符串交换。</p></li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sStr1</span><span class="params">(<span class="string">"red"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sStr2</span><span class="params">(<span class="string">"blue"</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sStr1 &lt;&lt; <span class="string">" "</span> &lt;&lt; sStr2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">swap(sStr1, sStr2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sStr1 &lt;&lt; <span class="string">" "</span> &lt;&lt; sStr2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">sStr1.swap(sStr2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sStr1 &lt;&lt; <span class="string">" "</span> &lt;&lt; sStr2 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">red blue</span><br><span class="line">blue red</span><br><span class="line">red blue</span><br></pre></td></tr></table></figure></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/a3edb06.html">C&C++/std：：string的字符访问 及 转换为C风格数组</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月26日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：798字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：3分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/17-4-stdstring-character-access-and-conversion-to-c-style-arrays/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/17-4-stdstring-character-access-and-conversion-to-c-style-arrays/</a></p><hr><h1 id="访问字符"><a href="#访问字符" class="headerlink" title="访问字符"></a>访问字符</h1><h2 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符[]"></a>重载运算符[]</h2><p>有两种几乎相同的方法来访问字符串中的字符。更容易使用和更快的版本是<strong>重载运算符[]</strong>:</p><p><strong><code>char&amp; string::operator[] (size_type nIndex)</code></strong></p><p><strong><code>const char&amp; string::operator[] (size_type nIndex) const</code></strong></p><ul><li><p>这两个函数都返回带有索引nIndex的字符</p></li><li><p>传递无效索引将导致未定义的行为</p></li><li><p>使用length()作为索引仅对const字符串有效，并返回由字符串的默认构造函数生成的值。不建议您这样做。</p></li><li><p>因为char&amp;是返回类型，所以可以使用它编辑数组中的字符</p></li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sSource&#123; <span class="string">"abcdefg"</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sSource[<span class="number">5</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">sSource[<span class="number">5</span>] = <span class="string">'X'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sSource &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f</span><br><span class="line">abcdeXg</span><br></pre></td></tr></table></figure><h2 id="非操作符版本"><a href="#非操作符版本" class="headerlink" title="非操作符版本"></a>非操作符版本</h2><p>还有一个非操作符版本。<strong>这个版本比较慢</strong>，因为它使用异常来检查nIndex是否有效。</p><p><strong>如果你不确定nIndex是否有效，你应该使用这个版本来访问数组</strong>:</p><p><strong><code>char&amp; string::at (size_type nIndex)</code></strong></p><p><strong><code>const char&amp; string::at (size_type nIndex) const</code></strong></p><ul><li><p>这两个函数都返回带有索引nIndex的字符</p></li><li><p>传递无效索引将导致out_of_range异常</p></li><li><p>因为char&amp;是返回类型，所以可以使用它编辑数组中的字符</p></li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sSource&#123; <span class="string">"abcdefg"</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sSource.at(<span class="number">5</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">sSource.at(<span class="number">5</span>) = <span class="string">'X'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sSource &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><h1 id="转换为c风格的数组"><a href="#转换为c风格的数组" class="headerlink" title="转换为c风格的数组"></a>转换为c风格的数组</h1><p>许多函数(包括所有C函数)都希望将字符串格式化为C风格的字符串，而不是std::string。由于这个原因，std::string提供了3种不同的方法来将std::string转换成c风格的字符串。</p><ul><li><p><strong><code>const char* string::c_str () const</code></strong> ⭐【推荐】</p><ul><li>以const c风格的字符串返回字符串的内容</li><li>将追加一个空终止符</li><li>c风格的字符串属于std::string，不应该被删除</li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sSource&#123; <span class="string">"abcdefg"</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">strlen</span>(sSource.c_str());</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong><code>const char* string::data () const</code></strong></p><ul><li>以const c风格的字符串返回字符串的内容</li><li>将追加一个空终止符。这个函数执行的操作与c_str()相同</li><li>c风格的字符串属于std::string，不应该被删除</li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sSource&#123; <span class="string">"abcdefg"</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *szString&#123; <span class="string">"abcdefg"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个c样式字符串的前n个字符，如果它们相等，则返回0</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">memcmp</span>(sSource.data(), szString, sSource.length()) == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The strings are equal"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The strings are not equal"</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The strings are equal</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong><code>size_type string::copy(char *szBuf, size_type nLength) const</code></strong></p></li><li><p><strong><code>size_type string::copy(char *szBuf, size_type nLength, size_type nIndex) const</code></strong></p><ul><li>这两种风格都将字符串的最多nLength字符复制到szBuf，从字符nIndex开始</li><li>返回复制的字符数</li><li><strong>没</strong>有空值被追加。由调用者负责确保szBuf被初始化为NULL或使用返回的长度终止字符串</li><li>调用者负责不溢出szBuf</li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sSource&#123; <span class="string">"sphinx of black quartz, judge my vow"</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span> szBuf[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> nLength&#123; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(sSource.copy(szBuf, <span class="number">5</span>, <span class="number">10</span>)) &#125;;</span><br><span class="line">szBuf[nLength] = <span class="string">'\0'</span>;  <span class="comment">// 确保终止缓冲区中的字符串</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; szBuf &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">black</span><br></pre></td></tr></table></figure></li></ul><p><strong>除非您需要充分利用效率，否则c_str()是这三个函数中最简单、最安全的一个。</strong></p></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/cc14dac2.html">C&C++/std：：string长度和容量</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月26日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：1.3k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：5分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/17-3-stdstring-length-and-capacity/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/17-3-stdstring-length-and-capacity/</a></p><hr><p>一旦创建了字符串，了解它们的长度通常是很有用的。这就是长度和容量操作发挥作用的地方。</p><p>我们还将讨论将std::string转换回c风格字符串的各种方法，这样您就可以将它们用于需要char*类型的字符串的函数。</p><h1 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h1><p>字符串的长度非常简单——<strong>它是字符串中的字符数</strong>。确定字符串长度有两个相同的函数:</p><ul><li><p><strong><code>size_type string::length() const</code></strong></p></li><li><p><strong><code>size_type string::size() const</code></strong></p></li></ul><p>这两个函数都返回字符串中的当前字符数(<strong>不包括null终止符</strong>)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sSource</span><span class="params">(<span class="string">"012345678"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sSource.length() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="确定字符串是否有字符"><a href="#确定字符串是否有字符" class="headerlink" title="确定字符串是否有字符"></a>确定字符串是否有字符</h2><p>虽然可以使用length()来确定一个字符串是否有字符，<strong>但是使用empty()函数更有效</strong>:</p><p><strong><code>bool string::empty() const</code></strong></p><ul><li>如果字符串没有字符，则返回true，否则返回false。</li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sString1</span><span class="params">(<span class="string">"Not Empty"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (sString1.empty() ? <span class="string">"true"</span> : <span class="string">"false"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">string</span> sString2; <span class="comment">// empty</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (sString2.empty() ? <span class="string">"true"</span> : <span class="string">"false"</span>)  &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h1 id="字符串可容纳最大的容量"><a href="#字符串可容纳最大的容量" class="headerlink" title="字符串可容纳最大的容量"></a>字符串可容纳最大的容量</h1><p>还有一个与大小相关的函数，您可能永远不会用到，但是为了完整起见，我们将在这里包括它:</p><p><strong><code>size_type string::max_size() cons</code>t</strong></p><ul><li><p><strong>返回字符串允许的最大字符数</strong>。</p></li><li><p>这个值会随着操作系统和系统架构的不同而变化。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sString</span><span class="params">(<span class="string">"MyString"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sString.max_size() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;教程中的结果</span><br><span class="line">4294967294</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在我自己电脑中的结果</span><br><span class="line">2147483647</span><br></pre></td></tr></table></figure><h1 id="字符串的容量-capacity"><a href="#字符串的容量-capacity" class="headerlink" title="字符串的容量( capacity)"></a>字符串的容量( capacity)</h1><p>字符串的容量<strong>反映了字符串为保存其内容而分配的内存大小。</strong></p><ul><li>此值以字符串字符为度量，不包括NULL终止符。（例如，一个容量为8的字符串可以容纳8个字符。）</li></ul><p><strong><code>size_type string::capacity() const</code></strong></p><ul><li>返回一个字符串在不重新分配的情况下可以容纳的字符数。</li></ul><p>如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sString</span><span class="params">(<span class="string">"01234567"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Length: "</span> &lt;&lt; sString.length() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Capacity: "</span> &lt;&lt; sString.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Length: 8</span><br><span class="line">Capacity: 15</span><br></pre></td></tr></table></figure><p>注意，容量大于字符串的长度!虽然我们的字符串长度为8，但实际上该字符串分配了足够15个字符的内存!为什么要这样做?</p><h2 id="字符串容量-capacity-大于等于-字符串长度"><a href="#字符串容量-capacity-大于等于-字符串长度" class="headerlink" title="字符串容量( capacity) 大于等于 字符串长度"></a>字符串容量( capacity) 大于等于 字符串长度</h2><p>注意，容量大于字符串的长度!虽然我们的字符串长度为8，但实际上该字符串分配了足够15个字符的内存!为什么要这样做?</p><ul><li>如果用户想在一个字符串中放入比该字符串所能容纳的更多的字符，则必须将该字符串重新分配到更大的容量中。例如，如果一个字符串的长度和容量都为8，那么向该字符串添加任何字符都将强制重新分配。通过使容量大于实际的字符串，<strong>这就为用户提供了一些缓冲空间，以便在需要进行重新分配之前扩展字符串。</strong></li></ul><p>事实证明，重新分配有以下几个不利原因：</p><ul><li><p>首先，<strong>重新分配字符串相对比较昂贵。</strong></p><ul><li><p>首先，必须分配新内存。</p></li><li><p>然后必须将字符串中的每个字符复制到新内存中。如果字符串很大，这可能需要很长时间。</p></li><li><p>最后，旧的内存空间必须释放。如果您正在进行许多重新分配，这个过程会显著降低程序的运行速度。</p></li></ul></li><li><p>其次，每当重新分配一个字符串时，该字符串的内容就会<strong>更改为一个新的内存地址</strong>。<strong>这意味着对字符串的所有引用、指针和迭代器都是无效的!</strong></p></li></ul><h2 id="设置字符串的容量的下限"><a href="#设置字符串的容量的下限" class="headerlink" title="设置字符串的容量的下限"></a>设置字符串的容量的下限</h2><p><strong><code>void string::reserve(size_type unSize)</code></strong></p><p><strong><code>void string::reserve()</code></strong></p><ul><li>第一个函数特点是<strong>将字符串的容量<u>至少</u>设置为unSize(可以更大</strong>)。<u>注意，这可能需要重新分配。</u></li><li>当调用第一个函数时，<strong>但大小小于当前容量，则函数将尝试收缩容量以匹配长度</strong>。这是一个非绑定请求。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sString</span><span class="params">(<span class="string">"01234567"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Length: "</span> &lt;&lt; sString.length() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Capacity: "</span> &lt;&lt; sString.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">sString.reserve(<span class="number">200</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Length: "</span> &lt;&lt; sString.length() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Capacity: "</span> &lt;&lt; sString.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">sString.reserve();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Length: "</span> &lt;&lt; sString.length() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Capacity: "</span> &lt;&lt; sString.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Length: <span class="number">8</span></span><br><span class="line">Capacity: <span class="number">15</span></span><br><span class="line">Length: <span class="number">8</span></span><br><span class="line">Capacity: <span class="number">207</span></span><br><span class="line">Length: <span class="number">8</span></span><br><span class="line">Capacity: <span class="number">207</span></span><br></pre></td></tr></table></figure><p>这个例子展示了两件有趣的事情。</p><ul><li>首先，虽然我们要求200的容量，但实际上我们得到了207的容量。容量总是保证至少与您的请求一样大，但也可能更大。</li><li>然后，我们请求更改容量以适应字符串<strong>。这个请求被忽略了，因为容量没有改变。</strong></li></ul><h2 id="向字符串添加一个字符"><a href="#向字符串添加一个字符" class="headerlink" title="向字符串添加一个字符"></a>向字符串添加一个字符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sString</span><span class="params">(<span class="string">"0123456789abcde"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Length: "</span> &lt;&lt; sString.length() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Capacity: "</span> &lt;&lt; sString.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Now add a new character</span></span><br><span class="line">sString += <span class="string">"f"</span>; ⭐⭐⭐</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Length: "</span> &lt;&lt; sString.length() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Capacity: "</span> &lt;&lt; sString.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Length: 15</span><br><span class="line">Capacity: 15</span><br><span class="line">Length: 16</span><br><span class="line">Capacity: 31</span><br></pre></td></tr></table></figure></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/550c4d87.html">C&C++/std：：string构造和销毁</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月26日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：1.4k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：5分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/17-2-stdstring-construction-and-destruction/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/17-2-stdstring-construction-and-destruction/</a></p><hr><p>在这节课中，我们将学习如何构造std::string的对象，以及如何从数字创建字符串，反之亦然。</p><h1 id="String-的构造"><a href="#String-的构造" class="headerlink" title="String 的构造"></a><strong>String</strong> 的构造</h1><p>string类有许多构造函数，可用于创建字符串。我们将在这里逐一介绍。</p><p>注意：<code>string::size_type</code>解析为<code>size_t</code>，它与<code>sizeof</code>操作符返回的无符号整数类型 相同。它的实际大小因环境而异。出于本教程的目的，将它想象成一个无符号整型。</p><h2 id="string-string"><a href="#string-string" class="headerlink" title="string::string()"></a>string::string()</h2><p>这是<strong>默认的构造函数</strong>。它创建一个<strong>空字符串</strong>。</p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sSource;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sSource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"> 	<span class="comment">//什么都没有，因为这是空字符串</span></span><br></pre></td></tr></table></figure><h2 id="string-string-const-string-amp-strString"><a href="#string-string-const-string-amp-strString" class="headerlink" title="string::string(const string&amp; strString)"></a>string::string(const string&amp; strString)</h2><p>这是<strong>复制构造函数</strong>。这个构造函数<strong>创建一个新的字符串作为strString的副本</strong>。</p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sSource&#123; <span class="string">"my string"</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sOutput&#123; sSource &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sOutput;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my string</span><br></pre></td></tr></table></figure><h2 id="string-string-const-string-amp-strString-size-type-unIndex-size-type-unLength"><a href="#string-string-const-string-amp-strString-size-type-unIndex-size-type-unLength" class="headerlink" title="string::string(const string&amp; strString, size_type unIndex, size_type unLength)"></a>string::string(const string&amp; strString, size_type unIndex, size_type unLength)</h2><p><strong><code>string::string(const string&amp; strString, size_type unIndex)</code></strong></p><p><strong><code>string::string(const string&amp; strString, size_type unIndex, size_type unLength)</code></strong></p><ul><li><p>此构造函数创建一个新字符串，该字符串从索引 unIndex开始，最多包含来自strString的 unLength长度字符。</p><blockquote><p>如果遇到NULL，即使没有达到unLength，字符串复制也将结束。</p></blockquote></li><li><p><u>如果不提供unLength</u>，则使用从unIndex开始的所有字符。</p></li><li><p>如果unIndex大于字符串的大小，则会抛出out_of_range异常。</p></li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sSource&#123; <span class="string">"my string"</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sOutput&#123; sSource, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sOutput&lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">sOutput2</span><span class="params">(sSource, <span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sOutput2 &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string</span><br><span class="line">stri</span><br></pre></td></tr></table></figure><h2 id="string-string-const-char-szCString"><a href="#string-string-const-char-szCString" class="headerlink" title="string::string(const char *szCString)"></a>string::string(const char *szCString)</h2><ul><li><p>这个构造函数从c风格的字符串szCString创建一个新字符串，直到但不包括NULL终止符。</p></li><li><p>如果结果大小超过最大字符串长度，将抛出length_error异常。</p></li><li><p><strong>警告:szCString不能为空。</strong></p></li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *szSource&#123; <span class="string">"my string"</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sOutput&#123; szSource &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sOutput &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my string</span><br></pre></td></tr></table></figure><h2 id="string-string-const-char-szCString-size-type-unLength"><a href="#string-string-const-char-szCString-size-type-unLength" class="headerlink" title="string::string(const char *szCString, size_type unLength)"></a>string::string(const char *szCString, size_type unLength)</h2><ul><li><p>这个构造函数从c样式的字符串szCString的 第一个字符开始 到 第 unLength个字符(包含它) 结束 创建一个新字符串。</p></li><li><p>如果结果大小超过最大字符串长度，将抛出length_error异常。</p></li><li><p>警告：<strong>仅对于此函数</strong>，在szCString中null不被视为字符串结束字符! 这意味着如果字符串的长度太大，是可以读取字符串的末尾的字符的。 注意不要溢出你的字符串缓冲区!</p></li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *szSource&#123; <span class="string">"my string"</span> &#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">sOutput</span><span class="params">(szSource, <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sOutput &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my s</span><br></pre></td></tr></table></figure><h2 id="string-string-size-type-nNum-char-chChar"><a href="#string-string-size-type-nNum-char-chChar" class="headerlink" title="string::string(size_type nNum, char chChar)"></a>string::string(size_type nNum, char chChar)</h2><ul><li><p>这个构造函数创建一个由nNum个 chChar字符 初始化的新字符串。</p></li><li><p>如果结果大小超过最大字符串长度，将抛出length_error异常。</p></li></ul><p>如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">sOutput</span><span class="params">(<span class="number">4</span>, <span class="string">'Q'</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sOutput &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QQQQ</span><br></pre></td></tr></table></figure><h2 id="template-string-string-InputIterator-itBeg-InputIterator-itEnd"><a href="#template-string-string-InputIterator-itBeg-InputIterator-itEnd" class="headerlink" title="template string::string(InputIterator itBeg, InputIterator itEnd)"></a>template string::string(InputIterator itBeg, InputIterator itEnd)</h2><ul><li><p>这个构造函数创建由一个范围为 [itBeg, itEnd]字符 初始化的新字符串。</p></li><li><p>如果结果大小超过最大字符串长度，将抛出length_error异常。</p></li></ul><p>这个没有示例代码。它很模糊，你可能永远不会用到它。</p><h1 id="string-的销毁"><a href="#string-的销毁" class="headerlink" title="string 的销毁"></a>string 的销毁</h1><p><strong><code>string::~string()</code></strong></p><p>字符串的销毁：</p><ul><li>这是破坏者。它销毁字符串并释放内存。</li></ul><p>这里也没有示例代码，因为析构函数不是显式调用的。</p><h1 id="由数字构造字符串"><a href="#由数字构造字符串" class="headerlink" title="由数字构造字符串"></a>由数字构造字符串</h1><p>在std::string类中一个值得注意的遗漏是<strong>缺乏从数字创建字符串的能力</strong>。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sFour&#123; <span class="number">4</span> &#125;;</span><br></pre></td></tr></table></figure><p>产生以下错误:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:vcprojectstest2test2test.cpp(10) : error C2664: &#39;std::basic_string&lt;_Elem,_Traits,_Ax&gt;::basic_string(std::basic_string&lt;_Elem,_Traits,_Ax&gt;::_Has_debug_it)&#39; : cannot convert parameter 1 from &#39;int&#39; to &#39;std::basic_string&lt;_Elem,_Traits,_Ax&gt;::_Has_debug_it&#39;</span><br></pre></td></tr></table></figure><p>还记得我说过字符串类会产生可怕的错误吗? 这里的相关信息是:</p><p><code>不能将参数1从&#39;int&#39;转换为&#39;std::basic_string</code></p><p>换句话说，它试图将int转换成字符串，但是失败了。</p><p><strong>将数字转换为字符串的最简单方法是使用std::ostringstream类。</strong></p><p>std::ostringstream（头文件<code>&lt;sstream&gt;</code>中）已经设置为接受来自各种来源的输入，包括字符、数字、字符串等…….。它同样能够<strong>输出字符串（可以通过提取操作符&gt;&gt;，也可以通过str()函数）</strong>。</p><blockquote><p>有关std::ostringstream的更多信息，请看<a href="https://www.learncpp.com/cpp-tutorial/184-stream-classes-for-strings/" target="_blank" rel="noopener">18.4 – Stream classes for strings</a>.</p></blockquote><p>这里有一个简单的解决方案来创建<code>std::string</code>从各种类型的输入:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">ToString</span><span class="params">(T tX)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">ostringstream</span> oStream;</span><br><span class="line">    oStream &lt;&lt; tX;</span><br><span class="line">    <span class="keyword">return</span> oStream.str();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> sFour&#123; ToString(<span class="number">4</span>) &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> sSixPointSeven&#123; ToString(<span class="number">6.7</span>) &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> sA&#123; ToString(<span class="string">'A'</span>) &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sFour &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sSixPointSeven &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sA &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">6.7</span><br><span class="line">A</span><br></pre></td></tr></table></figure><p>请注意，此解决方案省略了任何错误检查。将tX插入oStream可能会失败。一个适当的响应是在转换失败时抛出异常。</p><h1 id="将字符串转换为数字"><a href="#将字符串转换为数字" class="headerlink" title="将字符串转换为数字"></a>将字符串转换为数字</h1><p>类似于上面的解决方案:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">FromString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; sString, T &amp;tX)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">istringstream</span> <span class="title">iStream</span><span class="params">(sString)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> !(iStream &gt;&gt; tX).fail(); <span class="comment">// extract value into tX, return success or not</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> dX;</span><br><span class="line">    <span class="keyword">if</span> (FromString(<span class="string">"3.4"</span>, dX))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dX &lt;&lt; <span class="string">'\n'</span>; </span><br><span class="line">    <span class="keyword">if</span> (FromString(<span class="string">"ABC"</span>, dX))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dX &lt;&lt; <span class="string">'\n'</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.4</span><br></pre></td></tr></table></figure><p>注意，第二次转换失败并返回false。</p></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/67452a19.html">C&C++/std：：string and std：：wstring</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月26日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：1.6k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：6分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/17-1-stdstring-and-stdwstring/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/17-1-stdstring-and-stdwstring/</a></p><hr><p>标准库包含许多有用的类——但最有用的可能是<strong>std::string</strong>。</p><p>std::string(和std::wstring)是一个字符串类，它提供了许多操作来分配、比较和修改字符串。在本章中，我们将深入研究这些字符串类。</p><blockquote><p>注意:</p><p><strong>C-style字符串将被称为“C-style string”</strong>，<strong>而std::string(和std::wstring)将被简单地称为“string”。</strong></p></blockquote><h1 id="字符串类-字符串类的动机-的动机"><a href="#字符串类-字符串类的动机-的动机" class="headerlink" title="字符串类(字符串类的动机)的动机"></a>字符串类(字符串类的动机)的动机</h1><h2 id="C风格字符串的缺点"><a href="#C风格字符串的缺点" class="headerlink" title="C风格字符串的缺点"></a>C风格字符串的缺点</h2><p>在 <a href="http://www.learncpp.com/cpp-tutorial/66-c-style-strings/" target="_blank" rel="noopener">C-style strings</a>中，我们介绍了<strong>c风格</strong>的字符串，它使用字符<strong>数组</strong>来存储字符串。</p><p>如果您尝试过使用c风格的字符串做任何事情，那么您会很快得出这样的结论:</p><ul><li>使用c风格的字符串很麻烦，很容易出错，而且很难调试。</li></ul><p>c风格的字符串有很多<strong>缺点</strong>，主要是围绕这样一个事实:</p><ul><li><p><strong>您必须自己完成所有的内存管理</strong>。</p><blockquote><p>例如，如果您想要分配字符串“hello!进入一个缓冲区，你必须先动态分配一个缓冲区的正确长度:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *strHello = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">7</span>];</span><br><span class="line"><span class="comment">//不要忘记说明null终止符的额外字符!</span></span><br></pre></td></tr></table></figure><p>然后你必须实际 复制值:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(strHello, <span class="string">"hello!"</span>);</span><br><span class="line"> &gt;<span class="comment">//希望你使你的缓冲区足够大，所以没有缓冲区溢出!</span></span><br></pre></td></tr></table></figure><p>当然，因为字符串是动态分配的，你必须记住，当你处理完它时，要正确地释放它:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span>[] strHello;</span><br><span class="line">  &gt;<span class="comment">//不要忘记使用数组删除代替普通的删除!</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>此外，C提供的用于处理数字的许多直观操作符(如赋值和比较)根本不适用于C风格的字符串。</strong>有时这些方法看似有效，但实际上产生了不正确的结果。例如：</p><ul><li>使用==比较两个c风格的字符串实际上会进行指针比较，而不是字符串比较。</li><li>使用operator=将一个c风格的字符串赋值给另一个c风格的字符串，乍一看似乎可行，但实际上是在做指针复制(浅复制)，这通常不是您想要的。</li></ul><p>这类事情会导致程序崩溃，很难找到和调试!</p></li></ul><ul><li>最后，处理c风格的字符串需要记住许多关于什么是安全/不安全的挑剔规则，记住一堆具有有趣名称的函数，如strcat()和strcmp()，而不是使用直观的操作符，并执行大量手工内存管理。</li></ul><p>幸运的是，c++和标准库提供了更好的处理字符串的方法: <strong>std::string和std::wstring类。</strong></p><p>通过使用c++概念，例如构造函数、析构函数和操作符重载，std::string允许您以一种直观和安全的方式创建和操作字符串! <u>不再需要内存管理，不再需要奇怪的函数名，灾难发生的可能性也大大降低。</u></p><h2 id="std-string概述"><a href="#std-string概述" class="headerlink" title="std::string概述"></a>std::string概述</h2><p>位于 <strong>头文件<code>&lt;string&gt;</code>中</strong></p><p>实际上在字符串头中有3个不同的字符串类。</p><ul><li><p>第<strong>一</strong>个模板基类名为basic_string&lt;&gt;:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">charT</span>, <span class="title">class</span> <span class="title">traits</span> = <span class="title">char_traits</span>&lt;charT&gt;, <span class="title">class</span> <span class="title">Allocator</span> = <span class="title">allocator</span>&lt;charT&gt; &gt;</span></span><br><span class="line"><span class="class">        <span class="title">class</span> <span class="title">basic_string</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您不会直接使用这个类，所以暂时不要担心什么trait或 Allocator。在几乎所有可能的情况下，默认值就足够了。</p></li></ul><ul><li><p>标准库提供了<strong>两</strong>种basic_string&lt;&gt;:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> basic_string&lt;<span class="keyword">char</span>&gt; <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">typedef</span> basic_string&lt;<span class="keyword">wchar_t</span>&gt; <span class="built_in">wstring</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是您将实际使用的两个类。</p><ul><li><p>std::string用于 标准ascii和utf-8字 符串。</p></li><li><p>std::wstring用于 宽字符/unicode (utf-16) 字符串。</p><blockquote><p>没有用于utf-32字符串的内置类(尽管如果需要的话，您应该能够从basic_string&lt;&gt;扩展自己的类)。</p></blockquote></li></ul></li></ul><p>尽管您将直接使用std::string和std::wstring，但所有字符串功能都是在basic_string&lt;&gt;类中实现的。通过模板化，String和wstring能够直接访问该功能。因此，本文提供的所有函数都可以用于string和wstring。</p><p>这里是string类中所有函数的列表。这些函数中的大多数具有多种风格，可以处理不同类型的输入，我们将在接下来的课程中更深入地介绍这些内容。</p><table><thead><tr><th align="left">Function</th><th align="left">Effect</th></tr></thead><tbody><tr><td align="left"><strong>Creation and destruction</strong></td><td align="left"></td></tr><tr><td align="left"><a href="http://www.learncpp.com/cpp-tutorial/17-2-ststring-construction-and-destruction/" target="_blank" rel="noopener">(constructor)</a> <a href="http://www.learncpp.com/cpp-tutorial/17-2-ststring-construction-and-destruction/" target="_blank" rel="noopener">(destructor)</a></td><td align="left">Create or copy a string Destroy a string</td></tr><tr><td align="left"><strong>Size and capacity</strong></td><td align="left"></td></tr><tr><td align="left"><a href="http://www.learncpp.com/cpp-tutorial/17-3-stdstring-length-and-capacity/" target="_blank" rel="noopener">capacity()</a> <a href="http://www.learncpp.com/cpp-tutorial/17-3-stdstring-length-and-capacity/" target="_blank" rel="noopener">empty()</a> <a href="http://www.learncpp.com/cpp-tutorial/17-3-stdstring-length-and-capacity/" target="_blank" rel="noopener">length(), size()</a> <a href="http://www.learncpp.com/cpp-tutorial/17-3-stdstring-length-and-capacity/" target="_blank" rel="noopener">max_size()</a> <a href="http://www.learncpp.com/cpp-tutorial/17-3-stdstring-length-and-capacity/" target="_blank" rel="noopener">reserve()</a></td><td align="left">Returns the number of characters that can be held without reallocation Returns a boolean indicating whether the string is empty Returns the number of characters in string Returns the maximum string size that can be allocated Expand or shrink the capacity of the string</td></tr><tr><td align="left"><strong>Element access</strong></td><td align="left"></td></tr><tr><td align="left"><a href="http://www.learncpp.com/cpp-tutorial/17-4-stdstring-character-access-and-conversion-to-c-style-arrays/" target="_blank" rel="noopener">[], at()</a></td><td align="left">Accesses the character at a particular index</td></tr><tr><td align="left"><strong>Modification</strong></td><td align="left"></td></tr><tr><td align="left"><a href="http://www.learncpp.com/cpp-programming/17-5-stdstring-assignment-and-swapping/" target="_blank" rel="noopener">=, assign()</a> <a href="http://www.learncpp.com/uncategorized/17-6-stdstring-appending/" target="_blank" rel="noopener">+=, append(), push_back()</a> <a href="http://www.learncpp.com/cpp-tutorial/17-7-stdstring-inserting/" target="_blank" rel="noopener">insert()</a> clear() erase() replace() resize() <a href="http://www.learncpp.com/cpp-programming/17-5-stdstring-assignment-and-swapping/" target="_blank" rel="noopener">swap()</a></td><td align="left">Assigns a new value to the string Concatenates characters to end of the string Inserts characters at an arbitrary index in string Delete all characters in the string Erase characters at an arbitrary index in string Replace characters at an arbitrary index with other characters Expand or shrink the string (truncates or adds characters at end of string) Swaps the value of two strings</td></tr><tr><td align="left"><strong>Input and Output</strong></td><td align="left"></td></tr><tr><td align="left">&gt;&gt;, getline() &lt;&lt; <a href="http://www.learncpp.com/cpp-tutorial/17-4-stdstring-character-access-and-conversion-to-c-style-arrays/" target="_blank" rel="noopener">c_str()</a> <a href="http://www.learncpp.com/cpp-tutorial/17-4-stdstring-character-access-and-conversion-to-c-style-arrays/" target="_blank" rel="noopener">copy()</a> <a href="http://www.learncpp.com/cpp-tutorial/17-4-stdstring-character-access-and-conversion-to-c-style-arrays/" target="_blank" rel="noopener">data()</a></td><td align="left">Reads values from the input stream into the string Writes string value to the output stream Returns the contents of the string as a NULL-terminated C-style string Copies contents (not NULL-terminated) to a character array Returns the contents of the string as a non-NULL-terminated character array</td></tr><tr><td align="left"><strong>String comparison</strong></td><td align="left"></td></tr><tr><td align="left">==, != &lt;, &lt;=, &gt; &gt;= compare()</td><td align="left">Compares whether two strings are equal/unequal (returns bool) Compares whether two strings are less than / greater than each other (returns bool) Compares whether two strings are equal/unequal (returns -1, 0, or 1)</td></tr><tr><td align="left"><strong>Substrings and concatenation</strong></td><td align="left"></td></tr><tr><td align="left">+ substr()</td><td align="left">Concatenates two strings Returns a substring</td></tr><tr><td align="left"><strong>Searching</strong></td><td align="left"></td></tr><tr><td align="left">find() find_first_of() find_first_not_of() find_last_of() find_last_not_of() rfind()</td><td align="left">Find index of first character/substring Find index of first character from a set of characters Find index of first character not from a set of characters Find index of last character from a set of characters Find index of last character not from a set of characters Find index of last character/substring</td></tr><tr><td align="left"><strong>Iterator and allocator support</strong></td><td align="left"></td></tr><tr><td align="left">begin(), end() get_allocator() rbegin(), rend()</td><td align="left">Forward-direction iterator support for beginning/end of string Returns the allocator Reverse-direction iterator support for beginning/end of string</td></tr></tbody></table><p>虽然标准的库字符串类提供了很多功能，但有几个明显的遗漏:</p><ul><li>正则表达式</li><li>用于从数字创建字符串的构造函数</li><li>大写/大写/小写函数</li><li>不区分大小写的比较</li><li>标记化/将字符串拆分为数组</li><li>获取字符串的左或右部分的简单函数</li><li>空白修剪</li><li>格式化一个字符串 sprintf 样式</li><li>由utf-8转换为utf-16或反之亦然</li></ul><p>对于大多数情况，您必须编写自己的函数，<strong>或者将字符串转换为C样式的字符串(使用c_str())，并使用提供此功能的C函数。</strong></p></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/38f02bc7.html">C&C++/algorithm</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月26日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：407字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：1分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/16-4-stl-algorithms-overview/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/16-4-stl-algorithms-overview/</a></p><hr><p><strong>头文件：<code>algorithm</code></strong></p><p>除了容器类和迭代器之外，STL还提供了一些用于处理容器类元素的通用<strong>算法</strong>。它们允许您执行诸如搜索、排序、插入、重新排序、删除和复制容器类的元素等操作。</p><p>注意，<strong>算法是作为使用迭代器操作的函数来实现的</strong>。这意味着每个算法只需要实现一次，它通常会自动为所有提供一组迭代器的容器(包括您的自定义容器类)工作。</p><p>虽然这是非常强大的，可以导致编写复杂代码的能力非常快，它也有一些缺点：</p><ul><li><strong>某些算法和容器类型的组合可能不起作用，可能导致无限循环，或者可能起作用，但性能非常差。因此，使用这些在你的风险。</strong></li></ul><p>STL提供了相当多的算法，在这里，我们只讨论一些更常见、更容易使用的方法。其余的(和完整的细节)将保存在关于STL算法的一章中。</p><h1 id="min-element-与-max-element"><a href="#min-element-与-max-element" class="headerlink" title="min_element 与 max_element"></a>min_element 与 max_element</h1><p><code>std::min_element</code>和<code>std::max_element</code>算法查找容器类中的最小和最大元素。</p><p><code>std::iota</code>生成一系列连续的值。在头文件：<code>&lt;numeric&gt;</code>中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // ⭐std::min_element and std::max_element</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt; // std::iota</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">li</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 用从0开始的数字 填充li。</span></span><br><span class="line">    <span class="built_in">std</span>::iota(li.<span class="built_in">begin</span>(), li.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *<span class="built_in">std</span>::min_element(li.<span class="built_in">begin</span>(), li.<span class="built_in">end</span>()) &lt;&lt; <span class="string">' '</span></span><br><span class="line">              &lt;&lt; *<span class="built_in">std</span>::max_element(li.<span class="built_in">begin</span>(), li.<span class="built_in">end</span>()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果：*/</span></span><br><span class="line"><span class="number">0</span> <span class="number">5</span></span><br></pre></td></tr></table></figure></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/34a9aaba.html">C&C++/STL迭代器</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月26日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：1.1k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：4分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/16-3-stl-iterators-overview/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/16-3-stl-iterators-overview/</a></p><hr><p><strong>Iterator(迭代器)</strong>是一个<strong>对象</strong>，<strong>它可以遍历(迭代)一个容器类，而用户不需要知道容器是如何实现的。</strong></p><blockquote><p>对于许多类(特别是列表和关联类)，迭代器是访问这些类元素的主要方式。</p></blockquote><ul><li><p>操作符<code>*</code>：\对迭代器的解引用将返回迭代器当前指向的元素。</p></li><li><p>操作符<code>++</code>：将迭代器移动到容器中的下一个元素。（大多数迭代器还提供运算符——移动到前面的元素。）</p></li><li><p>操作符<code>==</code>与<code>!=</code>：确定两个迭代器是否指向同一个元素的基本比较操作符。</p><blockquote><p>要比较两个迭代器所指向的值，首先取消对迭代器的引用，然后使用比较操作符。</p></blockquote></li><li><p>操作符<code>=</code>：将迭代器分配到一个<strong>新位置</strong>(通常是容器元素的开始或结束位置)。</p><blockquote><p>要分配迭代器所指向的元素的值，首先对迭代器解引用，然后使用赋值操作符(<code>=</code>)。</p></blockquote></li></ul><p>每个容器包含四个基本的成员函数，用于<strong>操作符<code>=</code></strong>:</p><ul><li><strong><code>begin()</code></strong>：返回一个迭代器，<strong>表示容器中元素的开头</strong>。</li><li><strong><code>end()</code></strong>：返回一个迭代器，<strong>该迭代器表示元素的末尾</strong>。</li><li><strong><code>cbegin()</code></strong>：返回一个const(只读)迭代器，表示容器中元素的开头。</li><li><strong><code>cend()</code></strong>：返回一个const(只读)迭代器，表示元素的末尾。</li></ul><p>最后，所有容器都提供(至少)两种迭代器:</p><ul><li><strong><code>container::iterator</code></strong>：提供了一个读/写迭代器</li><li><strong><code>container::const_iterator</code></strong>：提供了一个只读迭代器</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>遍历一个 <strong>vector</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vect;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count &lt; <span class="number">6</span>; ++count)</span><br><span class="line">        vect.push_back(count);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it; <span class="comment">// declare a read-only iterator</span></span><br><span class="line">    it = vect.cbegin(); <span class="comment">// assign it to the start of the vector</span></span><br><span class="line">    <span class="keyword">while</span> (it != vect.cend()) <span class="comment">// while it hasn't reach the end</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>; <span class="comment">// print the value of the element it points to</span></span><br><span class="line">        ++it; <span class="comment">// and iterate to the next element</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历<strong>list(列表)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; li;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count &lt; <span class="number">6</span>; ++count)</span><br><span class="line">        li.push_back(count);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it; <span class="comment">// declare an iterator</span></span><br><span class="line">    it = li.cbegin(); <span class="comment">// assign it to the start of the list</span></span><br><span class="line">    <span class="keyword">while</span> (it != li.cend()) <span class="comment">// while it hasn't reach the end</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>; <span class="comment">// print the value of the element it points to</span></span><br><span class="line">        ++it; <span class="comment">// and iterate to the next element</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，代码几乎与向量的情况相同，尽管向量和列表的内部实现几乎完全不同!</p><p>遍历一个<strong>set(集合)</strong></p><p>在下面的例子中，我们将从6个数字创建一个集合，并使用迭代器来打印集合中的值:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; myset;</span><br><span class="line">    myset.insert(<span class="number">7</span>);</span><br><span class="line">    myset.insert(<span class="number">2</span>);</span><br><span class="line">    myset.insert(<span class="number">-6</span>);</span><br><span class="line">    myset.insert(<span class="number">8</span>);</span><br><span class="line">    myset.insert(<span class="number">1</span>);</span><br><span class="line">    myset.insert(<span class="number">-4</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it; <span class="comment">// declare an iterator</span></span><br><span class="line">    it = myset.cbegin(); <span class="comment">// assign it to the start of the set</span></span><br><span class="line">    <span class="keyword">while</span> (it != myset.cend()) <span class="comment">// while it hasn't reach the end</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>; <span class="comment">// print the value of the element it points to</span></span><br><span class="line">        ++it; <span class="comment">// and iterate to the next element</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，尽管填充集合的方式与填充 vector 和 list的方式不同，但是用于迭代集合元素的代码在本质上是相同的。</p><p>遍历<strong>map(映射)</strong></p><p>这个有点复杂。Maps and multimaps 取元素对(定义为std::pair)。我们使用<strong><code>make_pair()</code>辅助函数</strong>来轻松地创建对。*<em>std::pair *</em>允许通过第一个和第二个成员访问pair的元素。</p><p>在我们的map中，我们使用first作为键，second作为值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; mymap;</span><br><span class="line">	mymap.insert(<span class="built_in">std</span>::make_pair(<span class="number">4</span>, <span class="string">"apple"</span>));</span><br><span class="line">	mymap.insert(<span class="built_in">std</span>::make_pair(<span class="number">2</span>, <span class="string">"orange"</span>));</span><br><span class="line">	mymap.insert(<span class="built_in">std</span>::make_pair(<span class="number">1</span>, <span class="string">"banana"</span>));</span><br><span class="line">	mymap.insert(<span class="built_in">std</span>::make_pair(<span class="number">3</span>, <span class="string">"grapes"</span>));</span><br><span class="line">	mymap.insert(<span class="built_in">std</span>::make_pair(<span class="number">6</span>, <span class="string">"mango"</span>));</span><br><span class="line">	mymap.insert(<span class="built_in">std</span>::make_pair(<span class="number">5</span>, <span class="string">"peach"</span>));</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">auto</span> it&#123; mymap.cbegin() &#125;; <span class="comment">// declare a const iterator and assign to start of vector</span></span><br><span class="line">	<span class="keyword">while</span> (it != mymap.cend()) <span class="comment">// while it hasn't reach the end</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">"="</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">" "</span>; <span class="comment">// print the value of the element it points to</span></span><br><span class="line">		++it; <span class="comment">// and iterate to the next element</span></span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，迭代器很容易遍历容器的每个元素。您根本不需要关心map如何存储数据!</p></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/ef749515.html">C&C++/容器类STL</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月26日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：1.2k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：4分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/16-2-stl-containers-overview/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/16-2-stl-containers-overview/</a></p><hr><p>到目前为止，<strong>STL库最常用的功能是STL容器类</strong>。如果您需要快速复习一下容器类，请查看<a href="https://www.learncpp.com/cpp-tutorial/106-container-classes/" target="_blank" rel="noopener">10.6 – Container classes</a>。</p><p>STL包含许多不同的容器类，可以在不同的情况下使用。一般来说，容器类分为三个基本类别:</p><ul><li>序列容器</li><li>关联容器</li><li>容器适配器</li></ul><h1 id="序列容器"><a href="#序列容器" class="headerlink" title="序列容器"></a>序列容器</h1><p><strong>序列容器是维护容器中元素顺序的容器类</strong>。序列容器的一个定义特性是，<u>您可以根据位置选择元素的插入位置</u>。</p><p>序列容器最常见的例子是<strong>数组</strong>：如果您将四个元素插入到一个数组中，那么这些元素将按照您插入它们的确切顺序排列。</p><p>在c++ 11中，STL包含6个序列容器:</p><ul><li><p>std::vector</p><blockquote><p>在头文件：<code>vector</code>中</p></blockquote></li><li><p>std::deque</p><blockquote><p>在头文件：<code>deque</code>中</p></blockquote></li><li><p>std::array</p></li><li><p>std::list</p></li><li><p>std::forward_list</p></li><li><p>std::basic_string</p></li></ul><h2 id="std-vector"><a href="#std-vector" class="headerlink" title="std::vector"></a>std::vector</h2><p>如果你学过物理，你可能会认为<strong>矢量</strong>是同时具有大小和方向的实体。但是，STL中名为<strong>vector的类</strong>是一个动态数组，能够根据需要增长以包含它的元素。</p><p>vector类允许通过操作符[]<strong>随机访问</strong>它的元素，并且插入和删除vector中<strong>末尾</strong>的元素通常是很快的。</p><p>下面的程序将6个数字插入到一个向量中，并使用重载的[]运算符访问它们以打印它们。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vect;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count &lt; <span class="number">6</span>; ++count)</span><br><span class="line">        vect.push_back(<span class="number">10</span> - count); <span class="comment">// insert at end of array</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index=<span class="number">0</span>; index &lt; vect.<span class="built_in">size</span>(); ++index)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; vect[index] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">10</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="std-deque"><a href="#std-deque" class="headerlink" title="std::deque"></a>std::deque</h2><p><strong>deque类</strong>(发音为“deck”)是一个双端队列类，<strong>实现为一个可以从两端增长的动态数组。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; deq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count &lt; <span class="number">3</span>; ++count)</span><br><span class="line">    &#123;</span><br><span class="line">        deq.push_back(count); <span class="comment">// insert at end of array</span></span><br><span class="line">        deq.push_front(<span class="number">10</span> - count); <span class="comment">// insert at front of array</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index=<span class="number">0</span>; index &lt; deq.<span class="built_in">size</span>(); ++index)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; deq[index] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果*/</span></span><br><span class="line"><span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="std-list"><a href="#std-list" class="headerlink" title="std::list"></a>std::list</h2><p>std::list是一种特殊类型的序列容器，称为<strong>双链表</strong>，其中容器中的每个元素都包含指向列表中的下一个和前一个元素的指针。</p><p>std::list只提供对列表的<strong>开始和结束的访问</strong>。<strong>不提供随机访问</strong>。</p><blockquote><p>如果您想要在中间找到一个值，您必须从一端开始并“遍历列表”，直到找到您想要找到的元素。</p><p>通常使用迭代器遍历列表。</p></blockquote><p>列表的优点是<strong>，如果您已经知道要将元素插入到列表的何处，那么将元素插入到列表中会非常快</strong>。</p><h2 id="特殊的：string"><a href="#特殊的：string" class="headerlink" title="特殊的：string"></a>特殊的：string</h2><p>尽管STL string(和wstring)类通常不作为一种序列容器类型包含在内，但它们实际上是，因为它们可以被认为是一个带有char(或wchar)类型数据元素的向量。</p><h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><p>关联容器是在将输入插入容器时<strong>自动对其输入排序的容器</strong>。默认情况下，<strong>关联容器使用操作符&lt;比较元素。</strong></p><ul><li><p><strong>set</strong>是一个容器，<u>它存储惟一的元素，不允许有重复的元素</u>。<strong>元素根据它们的值排序。</strong></p></li><li><p><strong>multiset</strong>是一个允许重复元素的集合。</p></li><li><p><strong>map</strong>(也称为关联数组)是一个集合，<strong>其中每个元素都是一对，称为键/值对</strong>。该键用于对数据进行排序和索引，并且必须是唯一的。值是实际的数据。</p></li><li><p><strong>multimap</strong>(也称为<strong>字典</strong>) 是允许重复键的映射。所有键按升序排列，你可以通过键查找值。</p><blockquote><p>现实生活中的字典是多种多样的:</p><p><strong>键</strong>是单词，而<strong>值</strong>是单词的含义。有些单词可以有多种含义，这就是为什么字典是多用途地图而不是地图的原因。</p></blockquote></li></ul><h1 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h1><p>容器适配器是适应特定用途的特殊<strong>预定义容器</strong>。关于容器适配器的有趣之处在于，您可以选择希望它们使用的序列容器。</p><ul><li><p><strong>stack(栈)</strong>是一个容器，元素在<strong>后进先出</strong>上下文中操作。</p><blockquote><p><strong>栈默认使用deque作为它们的默认序列容器</strong>(这看起来很奇怪，因为vector似乎更适合)，但可以使用vector或 list。</p></blockquote></li><li><p><strong>queue(队列)</strong>是一个容器，元素在FIFO(<strong>先入先出</strong>)上下文中操作，<u>元素被插入(推入)到容器的后面，然后从前面删除(弹出)</u>。</p><blockquote><p><strong>队列默认使用deque，但也可以使用list。</strong></p></blockquote></li><li><p>*<em>priority queue(优先队列) *</em> 是一种保持元素排序的队列(通过操作符&lt;)。<u>推入元素时，元素在队列中排序</u>。从前端删除一个元素将 返回 优先队列中优先级最高的项。</p></li></ul></div></section></article></div><div class="post-wrapper"><article class="post white-box shadow reveal"><section class="meta"><div class="meta" id="header-meta"><h2 class="title"><a href="/archives/b054a192.html">C&C++/标准库</a></h2><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月26日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：410字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：1分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/16-1-the-standard-template-library-stl/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/16-1-the-standard-template-library-stl/</a></p><hr><p>恭喜你! 您已经完成了教程的主要部分!</p><p>前面的课程中，我们介绍了许多c++语言的主要特性(包括c++ 11/14/17语言扩展中的一些特性)。</p><p>因此，显而易见的问题是，“下一步是什么?”你可能注意到的一件事是，很多程序都在反复使用相同的概念:循环、字符串、数组、排序等等…… 您可能还注意到，使用容器的非类版本和通用算法编写程序很容易出错。好消息是，c++附带了一个充满了可重用类的库，您可以在其中构建程序。这个库称为<strong>c++标准库</strong>。</p><p><strong>The Standard Library</strong></p><p>标准库包含一组提供模板容器、算法和迭代器的类。如果您需要一个公共类或算法，标准库中很可能就有。这样做的好处是，您可以利用这些类，而不需要自己编写和调试这些类，而且标准库很好地提供了这些类的相当有效的版本。缺点是标准库很复杂，而且可能有点吓人，因为所有东西都是模板化的。</p><p>幸运的是，您可以将标准库分成小块，只使用需要的部分，而忽略其他部分，直到您准备好处理它。</p><p>在接下来的几节课中，我们将从高层次上了解标准库提供的容器、算法和迭代器的类型。在以后的课程中，我们将深入探讨一些特定的类。</p></div></section></article></div></section><br><div class="prev-next"><a class="prev" rel="prev" href="/archives/2020/"><section class="post prev white-box shadow"><i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页&nbsp;</section></a><p class="current">2 / 15</p><a class="next" rel="next" href="/archives/2020/page/3/"><section class="post next white-box shadow">&nbsp;下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i></section></a></div></div><aside class="l_side"><section class="widget blogger shadow desktop"><div class="content"><div class="avatar"><img class="avatar" src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"></div><div class="text"><p><span id="jinrishici-sentence">龙龙‘S BLOG</span></p><script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script></div><div class="social-wrapper"><a href="/atom.xml" class="social fas fa-rss flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="mailto:1198216723@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://github.com/longlongqin" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://music.163.com/#/user/home?id=285545421" class="social fas fa-headphones-alt flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a></div></div></section><section class="widget grid shadow desktop mobile"><header><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i><span class="name">站内导航</span></header><div class="content"><div class="grid navigation"><a class="flat-box" title="/" href="/" id="home"><i class="fas fa-clock fa-fw" aria-hidden="true"></i> 近期文章 </a><a class="flat-box" title="/archives/" href="/archives/" rel="nofollow" id="archives"><i class="fas fa-archive fa-fw" aria-hidden="true"></i> 文章归档 </a><a class="flat-box" title="/friends/" href="/friends/" rel="nofollow" id="friends"><i class="fas fa-link fa-fw" aria-hidden="true"></i> 友人帐 </a><a class="flat-box" title="/about/" href="/about/" rel="nofollow" id="about"><i class="fas fa-info-circle fa-fw" aria-hidden="true"></i> 关于小站</a></div></div></section><section class="widget category shadow desktop"><header><a href="/blog/categories/"><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i><span class="name">文章分类</span></a></header><div class="content"><ul class="entry navigation"><li><a class="flat-box" title="/categories/OJ/" href="/categories/OJ/" id="categoriesOJ"><div class="name">OJ</div><div class="badge">(1)</div></a></li><li><a class="flat-box" title="/categories/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" href="/categories/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" id="categorieshexoE58D9AE5AEA2E690ADE5BBBA"><div class="name">hexo博客搭建</div><div class="badge">(1)</div></a></li><li><a class="flat-box" title="/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" href="/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" id="categoriesE58D9AE5AEA2E690ADE5BBBA"><div class="name">博客搭建</div><div class="badge">(4)</div></a></li><li><a class="flat-box" title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="categoriesE5ADA6E4B9A0E7AC94E8AEB0"><div class="name">学习笔记</div><div class="badge">(48)</div></a></li><li><a class="flat-box child" title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/" id="categoriesE5ADA6E4B9A0E7AC94E8AEB0C-C"><div class="name">C/C++</div><div class="badge">(25)</div></a></li><li><a class="flat-box child" title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git/" id="categoriesE5ADA6E4B9A0E7AC94E8AEB0Git"><div class="name">Git</div><div class="badge">(1)</div></a></li><li><a class="flat-box" title="/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" href="/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" id="categoriesE5AE9EE794A8E68A80E5B7A7"><div class="name">实用技巧</div><div class="badge">(1)</div></a></li><li><a class="flat-box" title="/categories/%E9%85%8D%E7%BD%AE/" href="/categories/%E9%85%8D%E7%BD%AE/" id="categoriesE9858DE7BDAE"><div class="name">配置</div><div class="badge">(1)</div></a></li></ul></div></section><section class="widget tagcloud shadow desktop"><header><a href="/blog/tags/"><i class="fas fa-tags fa-fw" aria-hidden="true"></i><span class="name">热门标签</span></a></header><div class="content"><a href="/tags/C/" style="font-size:16px;color:#8b8b8b">C++</a> <a href="/tags/C-C/" style="font-size:24px;color:#555">C/C++</a> <a href="/tags/Git/" style="font-size:14px;color:#999">Git</a> <a href="/tags/Hexo%E4%B8%BB%E9%A2%98/" style="font-size:14px;color:#999">Hexo主题</a> <a href="/tags/Let-s-Build-A-Simple-Interpreter/" style="font-size:22px;color:#636363">Let's Build A Simple Interpreter</a> <a href="/tags/Let%E2%80%99s-Build-A-Simple-Interpreter/" style="font-size:18px;color:#7e7e7e">Let’s Build A Simple Interpreter</a> <a href="/tags/OJ/" style="font-size:14px;color:#999">OJ</a> <a href="/tags/Yilia%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/" style="font-size:14px;color:#999">Yilia主题配置</a> <a href="/tags/forme/" style="font-size:14px;color:#999">forme</a> <a href="/tags/front-matter%E9%85%8D%E7%BD%AE/" style="font-size:14px;color:#999">front-matter配置</a> <a href="/tags/github/" style="font-size:14px;color:#999">github</a> <a href="/tags/hexo%E6%98%BE%E7%A4%BApdf/" style="font-size:14px;color:#999">hexo显示pdf</a> <a href="/tags/matery%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/" style="font-size:14px;color:#999">matery主题配置</a> <a href="/tags/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE%E3%80%8B/" style="font-size:18px;color:#7e7e7e">《计算机科学速成课》</a> <a href="/tags/%E5%87%B8%E5%8C%85/" style="font-size:20px;color:#707070">凸包</a> <a href="/tags/%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91%E5%92%8C%E9%80%BB%E8%BE%91%E9%97%A8/" style="font-size:14px;color:#999">布尔逻辑和逻辑门</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" style="font-size:14px;color:#999">计算几何</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE/" style="font-size:14px;color:#999">计算机科学速成课</a> <a href="/tags/%E9%85%8D%E7%BD%AE/" style="font-size:14px;color:#999">配置</a></div></section></aside><footer class="clearfix white"><br><br><div class="aplayer-container"><meting-js theme="#1BCDFC" autoplay volume="0.6" loop order="list" fixed="false" list-max-height="340px" server="netease" type="song" id="186453" list-folded="true"></meting-js></div><br><div class="social-wrapper"><a href="/atom.xml" class="social fas fa-rss flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="mailto:1198216723@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://github.com/longlongqin" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://music.163.com/#/user/home?id=285545421" class="social fas fa-headphones-alt flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a></div><red>&copy; 2020-2021 longlongqin 😊| powered by HEXO | theme volantis</red><br><yellow><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("03/01/2020 18:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="小站已运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒 "}setInterval("createtime()",250)</script></yellow><br><green><i class="fas fa-chart-area"></i> <span class="post-count">字数统计：307.9k</span></green>|<script type="text/javascript" src="https://v1.cnzz.com/z_stat.php?id=1278663994&web_id=1278663994"></script><br><cyan>博客内容遵循</cyan><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank"><cyan>署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</cyan></a></footer><script>setLoadingBarProgress(80)</script><script>setLoadingBarProgress(60)</script></div><a class="s-top fas fa-arrow-up fa-fw" href="javascript:void(0)"></a></div><script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script><script>var SEARCH_SERVICE="hexo",ROOT="/";ROOT.endsWith("/")||(ROOT+="/")</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script><script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script><script type="text/javascript">$(function(){Waves.attach(".flat-btn",["waves-button"]),Waves.attach(".float-btn",["waves-button","waves-float"]),Waves.attach(".float-btn-light",["waves-button","waves-float","waves-light"]),Waves.attach(".flat-box",["waves-block"]),Waves.attach(".float-box",["waves-block","waves-float"]),Waves.attach(".waves-image"),Waves.init()})</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script><script type="text/javascript">$(function(){var n=["https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/background/4.jpg"];!function(n){for(var o=n.length;o--;){var r=Math.floor(Math.random()*o),t=n[r];n[r]=n[o],n[o]=t}}(n),$(".cover").backstretch(n,{duration:"20000",fade:"1500"})})</script><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js" async></script><script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js" async></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1.4/js/app.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1/js/search.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script><script>!function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copyed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-clipboard-check');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPYED';
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-exclamation-triangle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
      });
    }
    initCopyCode();
  }(window, document);</script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>let LAZY_LOAD_IMAGE = "[object Object]";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });</script><script>setLoadingBarProgress(100)</script><script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)t=c[r],0<=(n=t.getBoundingClientRect()).bottom&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this);</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script></body></html>