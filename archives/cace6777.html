<!DOCTYPE html><html><head hexo-theme="https://volantis.js.org/#2.1.4"><meta charset="utf-8"><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><title>C&amp;C++/智能指针与移动语义 - 龙龙‘S BLOG</title><link rel="alternate" href="/atom.xml" title="龙龙‘S BLOG"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css"><link rel="shortcut icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1.4.3/css/style.css"><script>function setLoadingBarProgress(e){document.getElementById("loading-bar").style.width=e+"%"}</script></head><body><script type="text/javascript" src="/js/love.js"></script><script type="text/javascript" src="/js/ergao.js"></script><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><header class="l_header shadow blur"><div class="wrapper"><div class="nav-sub container--flex"><a class="logo flat-box"></a><ul class="switcher h-list"><li><a class="s-comment flat-btn fas fa-comments fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-toc flat-btn fas fa-list fa-fw" target="_self" href="javascript:void(0)"></a></li></ul></div><div class="nav-main container container--flex"><a class="logo flat-box" target="_self" href="/"><i class="fas fa-home"></i> 龙龙</a><div class="menu navigation"><ul class="h-list"><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list-alt fa-fw fa-fw"></i> 索引</a><ul class="submenu"><li><a class="flat-box" href="/categories/" id="categories"><i class="fas fa-folder-open fa-fw fa-fw"></i> 分类</a><ul class="submenu"><li><a class="flat-box" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="categoriesE5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-fire fa-fw"></i> 学习笔记</a></li><li><a class="flat-box" href="/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" id="categoriesE5AE9EE794A8E68A80E5B7A7"><i class="fas fa-fire fa-fw"></i> 实用技巧</a></li></ul></li><li><a class="flat-box" href="/tags/" id="tags"><i class="fas fa-tags fa-fw fa-fw"></i> 标签</a></li><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list fa-fw fa-fw"></i> 时间轴</a></li></ul></li><li><a class="flat-box" href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="E5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-book fa-fw"></i> 学习笔记</a></li><li><a class="flat-box"><i class="fas fa-wrench fa-fw"></i> 工具</a><ul class="submenu"><li><a class="flat-box" href="https://www.thinkcmf.com/font/search/index.html" target="_blank" rel="noopener" id="https:www.thinkcmf.comfontsearchindex.html"><i class="fas fa-font fa-fw"></i> Font Awesome图标</a></li><li><a class="flat-box" href="https://www.sojson.com/image/change.html" target="_blank" rel="noopener" id="https:www.sojson.comimagechange.html"><i class="fa fa-crop fa-fw"></i> 在线图片尺寸修改</a></li><li><a class="flat-box" href="http://dir.scmor.com/" target="_blank" rel="noopener" id="http:dir.scmor.com"><i class="fa fa-search fa-fw"></i> Google学术&搜索镜像</a></li><li><a class="flat-box" href="https://emojixd.com/" target="_blank" rel="noopener" id="https:emojixd.com"><i class="fa fa-smile-o fa-fw"></i> Emoji表情符号辞典📓</a></li></ul></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw fa-fw"></i> 关于</a><ul class="submenu"><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-user-circle fa-fw fa-fw"></i> 关于我</a></li><hr><li><a class="flat-box" href="/friends/" id="friends"><i class="fas fa-link fa-fw"></i> 友人帐</a></li><li><a class="flat-box" href="/comment/" id="comment"><i class="fas fa-comment fa-fw"></i> 留言板</a></li><hr><li><a class="flat-box" href="https://github.com/longlongqin" target="_blank" rel="noopener" id="https:github.comlonglongqin"><i class="fab fa-github fa-fw fa-fw"></i> 我的Github</a></li><li><a class="flat-box" href="https://longlongqin.gitee.io" target="_blank" rel="noopener" id="https:longlongqin.gitee.io"><i class="fa fa-chevron-circle-right fa-fw"></i> matery主题博客</a></li></ul></li><li><a class="flat-box" href="https://volantis.js.org/tag-plugins/" target="_blank" rel="noopener" id="https:volantis.js.orgtag-plugins"><i class="fa fa-bookmark fa-fw"></i> Volantis主题文档</a></li><li><a class="flat-box" href="/easysearch/" id="easysearch"><i class="fa fa-search fa-fw"></i> easy搜索</a></li></ul></div><div class="m_search"><form name="searchform" class="form u-search-form"><i class="icon fas fa-search fa-fw"></i> <input type="text" class="input u-search-input" placeholder="search for everything"></form></div><ul class="switcher h-list"><li><a class="s-search flat-btn fas fa-search fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-menu flat-btn fas fa-bars fa-fw" target="_self" href="javascript:void(0)"></a></li></ul></div></div></header><ul class="menu-phone navigation white-box"><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list-alt fa-fw fa-fw"></i> 索引</a></li><li><a class="flat-box" href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="E5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-book fa-fw"></i> 学习笔记</a></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw fa-fw"></i> 关于</a></li></ul><script>setLoadingBarProgress(40)</script><div class="l_body nocover"><div class="body-wrapper"><div class="l_main"><article id="post" class="post white-box shadow article-type-post" itemscope itemprop="blogPost"><section class="meta"><div class="meta" id="header-meta"><h1 class="title"><a href="/archives/cace6777.html">C&C++/智能指针与移动语义</a></h1><div class="new-meta-box"><div class="new-meta-item author"><a href="https://longlongqin.github.io" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年5月21日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：2.9k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：11分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>原文：</p><p><a href="https://www.learncpp.com/cpp-tutorial/15-1-intro-to-smart-pointers-move-semantics/" target="_blank" rel="noopener">https://www.learncpp.com/cpp-tutorial/15-1-intro-to-smart-pointers-move-semantics/</a></p><hr><p>考虑一个函数，我们动态分配一个值:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Resource *ptr = <span class="keyword">new</span> Resource; <span class="comment">// Resource是一个结构体或者类</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管上面的代码看起来相当简单，但是很容易忘记释放ptr。<strong>即使您记得在函数结束时删除ptr，如果函数提前退出，也有许多方法可以不删除ptr</strong>。</p><ul><li><p>通过提前返回:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Resource *ptr = <span class="keyword">new</span> Resource;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter an integer: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 函数提前返回，ptr不会被删除!</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// do stuff with ptr here</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过抛出异常:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Resource *ptr = <span class="keyword">new</span> Resource;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter an integer: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">0</span>; <span class="comment">// 函数提前返回，ptr不会被删除!</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// do stuff with ptr here</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在上述两个程序中，执行早期的return或throw语句，导致函数终止而不删除变量ptr。因此，为变量ptr分配的内存现在会泄漏(并且在每次调用此函数并提前返回时将再次泄漏)。</p><p>本质上<strong>，这类问题的发生是因为指针变量本身没有内在的机制来清除。</strong></p><h1 id="智能指针类的拯救"><a href="#智能指针类的拯救" class="headerlink" title="智能指针类的拯救?"></a>智能指针类的拯救?</h1><p><strong>类最好的一点是，它们包含析构函数，当类的对象超出作用域时，析构函数会自动执行。</strong></p><p>因此，如果在构造函数中分配(或获取)内存，可以在析构函数中释放内存，并确保在销毁类对象时释放内存(不管它是否超出作用域、是否被显式删除等等)。</p><p>这是我们在 <a href="https://www.learncpp.com/cpp-tutorial/8-7-destructors/" target="_blank" rel="noopener">8.7 – Destructors</a>中讨论的RAII编程范例的核心。</p><p>那么我们可以使用一个类来帮助我们管理和清理指针吗?我们可以!</p><p>考虑这样一个类，它的唯一工作就是持有并“拥有”传递给它的指针，然后在类对象超出作用域时释放该指针。<strong>只要该类的对象仅作为局部变量创建，我们就可以保证该类将适当地超出作用域(不管我们的函数何时或如何终止)，并且所拥有的指针将被销毁。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Auto_ptr1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	T* m_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// Pass in a pointer to "own" via the constructor</span></span><br><span class="line">	Auto_ptr1(T* ptr=<span class="literal">nullptr</span>)</span><br><span class="line">		:m_ptr(ptr)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// The destructor will make sure it gets deallocated</span></span><br><span class="line">	~Auto_ptr1()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> m_ptr;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Overload dereference and operator-&gt; so we can use Auto_ptr1 like m_ptr.</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *m_ptr; &#125;</span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_ptr; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// A sample class to prove the above works</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">    ~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;<span class="function">Auto_ptr1&lt;Resource&gt; <span class="title">res</span><span class="params">(<span class="keyword">new</span> Resource)</span></span>; &#125; <span class="comment">// 注意这里的内存分配</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// ... 但不需要显式删除</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 还要注意，角括号中的资源不需要 * 符号，因为它是由模板提供的</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// res超出了这里的范围，并破坏了为我们分配的资源</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Resource acquired</span><br><span class="line">Resource destroyed</span><br></pre></td></tr></table></figure><p>考虑一下这个程序和类是如何工作的。</p><ul><li><p>首先，我们动态创建一个 Resource，并将其作为参数传递给模板化的Auto_ptr1类。从这一点开始，我们的Auto_ptr1变量res拥有这个Resource对象。（Auto_ptr1与m_ptr有一个复合关系。）</p></li><li><p>因为res被声明为一个局部变量，并且具有块作用域，所以当块结束时，它将超出作用域，并被销毁(不用担心忘记释放它)。</p></li><li><p>因为它是一个类，当它被销毁时，Auto_ptr1析构函数将被调用。这个析构函数将确保它所持有的资源指针被删除!</p></li><li><p>只要Auto_ptr1被定义为一个局部变量(具有自动持续时间，因此类名的“Auto”部分)，无论函数如何终止(即使它提前终止)，资源都将保证在声明它的块的末尾被销毁。</p></li></ul><p>这样的<strong>类</strong>称为<strong>智能指针</strong>。</p><p><strong>智能指针</strong>是一个复合类，用于管理动态分配的内存，并确保在智能指针对象超出作用域时删除内存。(与此相关的是，内置指针有时被称为<strong>“哑指针”</strong>，因为它们自己不能清理)。</p><p>现在让我们回到上面的someFunction()例子，并展示一个智能指针类如何解决我们的挑战:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Auto_ptr1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	T* m_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// Pass in a pointer to "own" via the constructor</span></span><br><span class="line">	Auto_ptr1(T* ptr=<span class="literal">nullptr</span>)</span><br><span class="line">		:m_ptr(ptr)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// The destructor will make sure it gets deallocated</span></span><br><span class="line">	~Auto_ptr1()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> m_ptr;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Overload dereference and operator-&gt; so we can use Auto_ptr1 like m_ptr.</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *m_ptr; &#125;</span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_ptr; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// A sample class to prove the above works</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">    ~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hi!\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Auto_ptr1&lt;Resource&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> Resource)</span></span>; <span class="comment">// ptr now owns the Resource</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter an integer: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// the function returns early</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// do stuff with ptr here</span></span><br><span class="line">    ptr-&gt;sayHi();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    someFunction();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用户输入一个非零整数，上面的程序将打印:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Resource acquired</span><br><span class="line">Enter an integer: 1</span><br><span class="line">Hi</span><br><span class="line">Resource destroyed</span><br></pre></td></tr></table></figure><p>如果用户输入0，以上程序将提前终止，打印:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Resource acquired</span><br><span class="line">Enter an integer: <span class="number">0</span></span><br><span class="line">Resource destroyed</span><br></pre></td></tr></table></figure><p>注意，即使在用户输入0并且函数提前终止的情况下，资源仍然被正确释放。</p><p><strong>因为ptr变量是一个局部变量，所以当函数终止时ptr将被销毁(不管它如何终止)。因为Auto_ptr1析构函数将清理资源，所以我们确信资源将被正确清理。</strong></p><h2 id="一个关键的缺陷"><a href="#一个关键的缺陷" class="headerlink" title="一个关键的缺陷"></a>一个关键的缺陷</h2><p>Auto_ptr1类有一个严重的缺陷，隐藏在一些自动生成的代码后面。在进一步阅读之前，看看您是否能够识别它是什么。我们会等待……</p><p>Rather than tell you, we’ll show you. Consider the following program:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Same as above</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Auto_ptr1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	T* m_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Auto_ptr1(T* ptr=<span class="literal">nullptr</span>)</span><br><span class="line">		:m_ptr(ptr)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	~Auto_ptr1()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> m_ptr;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *m_ptr; &#125;</span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_ptr; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">	~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Auto_ptr1&lt;Resource&gt; <span class="title">res1</span><span class="params">(<span class="keyword">new</span> Resource)</span></span>;</span><br><span class="line">	<span class="function">Auto_ptr1&lt;Resource&gt; <span class="title">res2</span><span class="params">(res1)</span></span>; <span class="comment">// 或者，不初始化res2，然后赋值res2 = res1;</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序打印:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Resource acquired</span><br><span class="line">Resource destroyed</span><br><span class="line">Resource destroyed</span><br></pre></td></tr></table></figure><p>您的程序很可能(但不一定)会在此时崩溃。现在看到问题了吗?</p><ul><li><strong>因为我们没有提供复制构造函数或赋值运算符，c++为我们提供了一个。</strong><u>它提供的函数只做浅拷贝</u>。因此，当我们用res1初始化res2时，Auto_ptr1变量都指向相同的资源。当res2超出范围时，它会删除资源，留下一个悬空指针给res1。当res1删除它的(已删除的)资源时，崩溃!</li></ul><h2 id="使用移动语句-Move-semantics-解决"><a href="#使用移动语句-Move-semantics-解决" class="headerlink" title="使用移动语句(Move semantics)解决"></a>使用移动语句(Move semantics)解决</h2><p><strong>如果不让我们的复制构造函数和赋值操作符复制指针(“复制语义”)，<u>而是将指针的所有权从源对象转移/移动到目标对象会怎么样</u>?</strong> 这是move语义背后的核心思想。</p><blockquote><p><strong>移动语义</strong> <strong>意味着该类将转移对象的所有权，而不是复制。</strong></p></blockquote><p>让我们更新我们的Auto_ptr1类，以展示如何做到这一点:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Auto_ptr2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	T* m_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Auto_ptr2(T* ptr=<span class="literal">nullptr</span>)</span><br><span class="line">		:m_ptr(ptr)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	~Auto_ptr2()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> m_ptr;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 由移动语义 实现的复制构造函数</span></span><br><span class="line">	Auto_ptr2(Auto_ptr2&amp; a) <span class="comment">// note: not const</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_ptr = a.m_ptr; <span class="comment">// 将哑指针从源对象转移到本地对象</span></span><br><span class="line">		a.m_ptr = <span class="literal">nullptr</span>; <span class="comment">// 确保该指针不再拥有源对象</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 实现移动语义的赋值运算符</span></span><br><span class="line">	Auto_ptr2&amp; <span class="keyword">operator</span>=(Auto_ptr2&amp; a) <span class="comment">// note: not const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (&amp;a == <span class="keyword">this</span>)</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">delete</span> m_ptr; <span class="comment">// 确保我们首先释放目标已经持有的指针</span></span><br><span class="line">		m_ptr = a.m_ptr; <span class="comment">// 然后将哑指针从源对象转移到本地对象</span></span><br><span class="line">		a.m_ptr = <span class="literal">nullptr</span>; <span class="comment">// 确保该指针不再拥有源对象</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *m_ptr; &#125;</span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_ptr; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isNull</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_ptr == <span class="literal">nullptr</span>;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource acquired\n"</span>; &#125;</span><br><span class="line">	~Resource() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource destroyed\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Auto_ptr2&lt;Resource&gt; <span class="title">res1</span><span class="params">(<span class="keyword">new</span> Resource)</span></span>;</span><br><span class="line">	Auto_ptr2&lt;Resource&gt; res2; <span class="comment">// Start as nullptr</span></span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"res1 is "</span> &lt;&lt; (res1.isNull() ? <span class="string">"null\n"</span> : <span class="string">"not null\n"</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"res2 is "</span> &lt;&lt; (res2.isNull() ? <span class="string">"null\n"</span> : <span class="string">"not null\n"</span>);</span><br><span class="line"> </span><br><span class="line">	res2 = res1; <span class="comment">// res2 assumes ownership, res1 is set to null</span></span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Ownership transferred\n"</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"res1 is "</span> &lt;&lt; (res1.isNull() ? <span class="string">"null\n"</span> : <span class="string">"not null\n"</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"res2 is "</span> &lt;&lt; (res2.isNull() ? <span class="string">"null\n"</span> : <span class="string">"not null\n"</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Resource acquired</span><br><span class="line">res1 is not null</span><br><span class="line">res2 is null</span><br><span class="line">Ownership transferred</span><br><span class="line">res1 is null</span><br><span class="line">res2 is not null</span><br><span class="line">Resource destroyed</span><br></pre></td></tr></table></figure><p><strong>注意，我们的重载操作符<code>=</code>将m_ptr的所有权从res1赋予给了res2!</strong> <strong>因此，我们不会得到指针的副本，所有东西都会被清理干净。</strong></p><h1 id="（智能指针的）std-auto-ptr及为什么要避免使用它"><a href="#（智能指针的）std-auto-ptr及为什么要避免使用它" class="headerlink" title="（智能指针的）std::auto_ptr及为什么要避免使用它"></a>（智能指针的）<code>std::auto_ptr</code>及为什么要避免使用它</h1><p>现在是讨论<code>std::auto_ptr</code>的合适时机。</p><p><strong><code>std::auto_ptr</code>是在c++ 98中引入的，它是c++对标准化智能指针的第一次尝试。<code>std::auto_ptr</code>选择 像Auto_ptr2类 一样实现move语义。</strong></p><p><u>但是，<code>std::auto_ptr</code>(以及我们的Auto_ptr2类)有很多问题，使得使用它很危险。</u></p><ul><li><p>首先，由于<code>std::auto_ptr</code>通过<strong>复制构造函数</strong>和<strong>赋值操作符(=)</strong>实现了<strong>移动语义</strong>，因此<u>按值</u>向函数传递<code>std::auto_ptr</code>将导致您的资源被移动到函数参数处 (并在函数参数超出作用域时在函数末尾销毁)。然后，当您从调用方访问auto_ptr参数时(没有意识到它已被传输和删除)，您突然取消了对空指针的引用。崩溃!</p></li><li><p>其次，<code>std::auto_ptr</code>总是使用非数组delete删除其内容。这意味着auto_ptr不能正确地处理动态分配的数组，<u>因为它使用了错误的重新分配类型</u>。更糟糕的是，它不能阻止您向它传递一个动态数组，然后它会错误地管理这个数组，从而导致内存泄漏。</p></li><li><p>最后，auto_ptr不能很好地处理标准库中的许多其他类，包括大多数容器和算法。<strong>这是因为这些标准库类假设当它们复制一个项时，它实际上是复制 而不是移动。</strong></p></li></ul><p>由于上述缺点，<strong><code>std::auto_ptr</code>在c++ 11中已经被弃用</strong>，不应该使用。事实上，<strong><code>std::auto_ptr</code>将作为c++ 17的一部分从标准库中完全删除!</strong></p><p>规则:<code>std::auto_ptr</code>是不推荐的，不应该使用。<strong>(推荐使用<code>std::unique_ptr</code>或<code>std::shared_ptr</code>)..</strong></p><h1 id="Moving-forward"><a href="#Moving-forward" class="headerlink" title="Moving forward"></a>Moving forward</h1><p>auto_ptr的设计的核心问题是，<strong>在c++ 11之前，c++语言根本没有机制来区分“复制语义”和“移动语义”。</strong>覆盖复制语义 来实现移动语义 会导致奇怪的边缘情况和意外的错误。例如，您可以编写res1 = res2，却不知道res2是否会被更改!</p><p>因此，<strong>在c++ 11中，“移动”的概念被正式定义，“移动语义”被添加到语言中，以正确区分复制和移动。</strong>既然我们已经为移动语义的用处做好了准备，我们将在本章的其余部分探索移动语义的主题。我们还将使用移动语义修复Auto_ptr2类。</p><p>在c++ 11中，<code>std::auto_ptr</code>已经被一堆其他类型的 “移动感知”智能指针 所取代：</p><ul><li><code>std::unique_ptr</code>,</li><li><code>std::weak_ptr</code>，</li><li>以及<code>std::shared_ptr</code>。</li></ul><br><section class="widget copyright desktop mobile"><div class="content"><blockquote><p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p><p>本文永久链接是：<a href="https://longlongqin.github.io/archives/cace6777.html">https://longlongqin.github.io/archives/cace6777.html</a></p></blockquote></div></section><section class="widget qrcode desktop mobile"><div class="content article-entry"><fancybox><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/reward/AliPayOR.jpg" height="64px"></fancybox><fancybox><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/reward/WeChatPayOR.png" height="64px"></fancybox></div></section></div><section class="meta" id="footer-meta"><div class="new-meta-box"><div class="new-meta-item date" itemprop="dateUpdated" datetime="2020-12-31T13:11:48+08:00"><a class="notlink"><i class="fas fa-save" aria-hidden="true"></i><p>更新于：2020年12月31日</p></a></div><div class="new-meta-item share -mob-share-list"><div class="-mob-share-list share-body"><a class="-mob-share-qq" rel="external nofollow noopener noreferrer noopener" href="http://connect.qq.com/widget/shareqq/index.html?url=https://longlongqin.github.io/archives/cace6777.html&title=C&C++/智能指针与移动语义 - 龙龙‘S BLOG&summary=" target="_blank"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qq.png"> </a><a class="-mob-share-qzone" rel="external nofollow noopener noreferrer noopener" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://longlongqin.github.io/archives/cace6777.html&title=C&C++/智能指针与移动语义 - 龙龙‘S BLOG&summary=" target="_blank"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qzone.png"> </a><a class="-mob-share-weibo" rel="external nofollow noopener noreferrer noopener" href="http://service.weibo.com/share/share.php?url=https://longlongqin.github.io/archives/cace6777.html&title=C&C++/智能指针与移动语义 - 龙龙‘S BLOG&summary=" target="_blank"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/weibo.png"></a></div></div></div></section><div class="prev-next"><a class="prev" href="/archives/145edd42.html"><p class="title"><i class="fas fa-chevron-left" aria-hidden="true"></i>C&C++/右值引用</p><p class="content">原文：https://www.learncpp.com/cpp-tutorial/15-2-rvalue-references/回到第一章，我们提到了左值和右值，然后告诉你们不要太担心它们。在c...</p></a><a class="next" href="/archives/263cd357.html"><p class="title">C&C++/异常的缺点和危险<i class="fas fa-chevron-right" aria-hidden="true"></i></p><p class="content">原文：https://www.learncpp.com/cpp-tutorial/148-exception-dangers-and-downsides/与几乎所有有利因素一样，例外也有一些潜在...</p></a></div></section></article><article class="post white-box comments shadow"><section class="article typo"><p ct><i class="fas fa-comments"></i> 评论</p><section id="comments"><div id="valine_container" class="valine_thread"><i class="fas fa-spinner fa-spin fa-fw"></i></div></section></section></article><script>window.subData={title:"C&C++/智能指针与移动语义",tools:!0}</script></div><aside class="l_side"><section class="widget toc-wrapper shadow desktop mobile"><header><i class="fas fa-list fa-fw" aria-hidden="true"></i><span class="name">本文目录</span></header><div class="content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#智能指针类的拯救"><span class="toc-text">智能指针类的拯救?</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一个关键的缺陷"><span class="toc-text">一个关键的缺陷</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用移动语句-Move-semantics-解决"><span class="toc-text">使用移动语句(Move semantics)解决</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#（智能指针的）std-auto-ptr及为什么要避免使用它"><span class="toc-text">（智能指针的）std::auto_ptr及为什么要避免使用它</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Moving-forward"><span class="toc-text">Moving forward</span></a></li></ol></div></section></aside><footer class="clearfix white"><br><br><div class="aplayer-container"><meting-js theme="#1BCDFC" autoplay volume="0.6" loop order="list" fixed="false" list-max-height="340px" server="netease" type="song" id="186453" list-folded="true"></meting-js></div><br><div class="social-wrapper"><a href="/atom.xml" class="social fas fa-rss flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="mailto:1198216723@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://github.com/longlongqin" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://music.163.com/#/user/home?id=285545421" class="social fas fa-headphones-alt flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a></div><red>&copy; 2020-2021 longlongqin 😊| powered by HEXO | theme volantis</red><br><yellow><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("03/01/2020 18:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="小站已运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒 "}setInterval("createtime()",250)</script></yellow><br><green><i class="fas fa-chart-area"></i> <span class="post-count">字数统计：307.9k</span></green>|<script type="text/javascript" src="https://v1.cnzz.com/z_stat.php?id=1278663994&web_id=1278663994"></script><br><cyan>博客内容遵循</cyan><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank"><cyan>署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</cyan></a></footer><script>setLoadingBarProgress(80)</script><script>setLoadingBarProgress(60)</script></div><a class="s-top fas fa-arrow-up fa-fw" href="javascript:void(0)"></a></div><script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script><script>var SEARCH_SERVICE="hexo",ROOT="/";ROOT.endsWith("/")||(ROOT+="/")</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script><script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script><script type="text/javascript">$(function(){Waves.attach(".flat-btn",["waves-button"]),Waves.attach(".float-btn",["waves-button","waves-float"]),Waves.attach(".float-btn-light",["waves-button","waves-float","waves-light"]),Waves.attach(".flat-box",["waves-block"]),Waves.attach(".float-box",["waves-block","waves-float"]),Waves.attach(".waves-image"),Waves.init()})</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script><script type="text/javascript">$(function(){var n=["https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/background/4.jpg"];!function(n){for(var o=n.length;o--;){var r=Math.floor(Math.random()*o),t=n[r];n[r]=n[o],n[o]=t}}(n),$(".cover").backstretch(n,{duration:"20000",fade:"1500"})})</script><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js" async></script><script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js" async></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.0/js/valine.js"></script><script>var GUEST_INFO=["nick","mail","link"],guest_info="nick,mail,link".split(",").filter(function(i){return-1<GUEST_INFO.indexOf(i)}),notify=!1,verify=!1,valine=new Valine;valine.init({el:"#valine_container",notify:notify,verify:verify,guest_info:guest_info,appId:"TYFUId8Xuddv6nUYuVUHJbac-gzGzoHsz",appKey:"bCYkC8WKY7n8VjI7K2g8MMJ3",placeholder:"快来评论吧~",pageSize:"10",avatar:"mp",lang:"zh-cn",visitor:"false",highlight:"true"})</script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1.4/js/app.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1/js/search.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script><script>!function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copyed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-clipboard-check');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPYED';
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-exclamation-triangle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
      });
    }
    initCopyCode();
  }(window, document);</script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>let LAZY_LOAD_IMAGE = "[object Object]";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });</script><script>setLoadingBarProgress(100)</script><script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)t=c[r],0<=(n=t.getBoundingClientRect()).bottom&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this);</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script></body></html>