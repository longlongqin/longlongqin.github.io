<!DOCTYPE html><html><head hexo-theme="https://volantis.js.org/#2.1.4"><meta charset="utf-8"><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><title>LearnCpp chapter5 - 龙龙‘S BLOG</title><meta name="keywords" content="C/C++"><meta name="description" content="LearnCpp chapter5https://www.learncpp.com"><link rel="alternate" href="/atom.xml" title="龙龙‘S BLOG"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css"><link rel="shortcut icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1.4.3/css/style.css"><script>function setLoadingBarProgress(e){document.getElementById("loading-bar").style.width=e+"%"}</script></head><body><script type="text/javascript" src="/js/love.js"></script><script type="text/javascript" src="/js/ergao.js"></script><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><header class="l_header shadow blur"><div class="wrapper"><div class="nav-sub container--flex"><a class="logo flat-box"></a><ul class="switcher h-list"><li><a class="s-comment flat-btn fas fa-comments fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-toc flat-btn fas fa-list fa-fw" target="_self" href="javascript:void(0)"></a></li></ul></div><div class="nav-main container container--flex"><a class="logo flat-box" target="_self" href="/"><i class="fas fa-home"></i> 龙龙</a><div class="menu navigation"><ul class="h-list"><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list-alt fa-fw fa-fw"></i> 索引</a><ul class="submenu"><li><a class="flat-box" href="/categories/" id="categories"><i class="fas fa-folder-open fa-fw fa-fw"></i> 分类</a><ul class="submenu"><li><a class="flat-box" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="categoriesE5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-fire fa-fw"></i> 学习笔记</a></li><li><a class="flat-box" href="/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" id="categoriesE5AE9EE794A8E68A80E5B7A7"><i class="fas fa-fire fa-fw"></i> 实用技巧</a></li></ul></li><li><a class="flat-box" href="/tags/" id="tags"><i class="fas fa-tags fa-fw fa-fw"></i> 标签</a></li><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list fa-fw fa-fw"></i> 时间轴</a></li></ul></li><li><a class="flat-box" href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="E5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-book fa-fw"></i> 学习笔记</a></li><li><a class="flat-box"><i class="fas fa-wrench fa-fw"></i> 工具</a><ul class="submenu"><li><a class="flat-box" href="https://www.thinkcmf.com/font/search/index.html" target="_blank" rel="noopener" id="https:www.thinkcmf.comfontsearchindex.html"><i class="fas fa-font fa-fw"></i> Font Awesome图标</a></li><li><a class="flat-box" href="https://www.sojson.com/image/change.html" target="_blank" rel="noopener" id="https:www.sojson.comimagechange.html"><i class="fa fa-crop fa-fw"></i> 在线图片尺寸修改</a></li><li><a class="flat-box" href="http://dir.scmor.com/" target="_blank" rel="noopener" id="http:dir.scmor.com"><i class="fa fa-search fa-fw"></i> Google学术&搜索镜像</a></li></ul></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw fa-fw"></i> 关于</a><ul class="submenu"><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-user-circle fa-fw fa-fw"></i> 关于我</a></li><hr><li><a class="flat-box" href="/friends/" id="friends"><i class="fas fa-link fa-fw"></i> 友人帐</a></li><li><a class="flat-box" href="/comment/" id="comment"><i class="fas fa-comment fa-fw"></i> 留言板</a></li><hr><li><a class="flat-box" href="https://github.com/longlongqin" target="_blank" rel="noopener" id="https:github.comlonglongqin"><i class="fab fa-github fa-fw fa-fw"></i> 我的Github</a></li><li><a class="flat-box" href="https://longlongqin.gitee.io" target="_blank" rel="noopener" id="https:longlongqin.gitee.io"><i class="fa fa-chevron-circle-right fa-fw"></i> matery主题博客</a></li></ul></li><li><a class="flat-box" href="https://volantis.js.org/tag-plugins/" target="_blank" rel="noopener" id="https:volantis.js.orgtag-plugins"><i class="fa fa-bookmark fa-fw"></i> Volantis主题文档</a></li><li><a class="flat-box" href="/easysearch/" id="easysearch"><i class="fa fa-search fa-fw"></i> easy搜索</a></li></ul></div><div class="m_search"><form name="searchform" class="form u-search-form"><i class="icon fas fa-search fa-fw"></i> <input type="text" class="input u-search-input" placeholder="search for everything"></form></div><ul class="switcher h-list"><li><a class="s-search flat-btn fas fa-search fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-menu flat-btn fas fa-bars fa-fw" target="_self" href="javascript:void(0)"></a></li></ul></div></div></header><ul class="menu-phone navigation white-box"><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list-alt fa-fw fa-fw"></i> 索引</a></li><li><a class="flat-box" href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="E5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-book fa-fw"></i> 学习笔记</a></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw fa-fw"></i> 关于</a></li></ul><script>setLoadingBarProgress(40)</script><div class="l_body nocover"><div class="body-wrapper"><div class="l_main"><article id="post" class="post white-box shadow article-type-post" itemscope itemprop="blogPost"><section class="meta"><div class="meta" id="header-meta"><h1 class="title"><a href="/archives/b6a3dbf1.html">LearnCpp chapter5</a></h1><div class="new-meta-box"><div class="new-meta-item author"><a href="https://www.longlongqin.top" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongqin</p></a></div><div class="new-meta-item category"><a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/" rel="nofollow"><i class="fas fa-folder-open" aria-hidden="true"></i><p>学习笔记&nbsp;/&nbsp;C/C++</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年3月30日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：3.5k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：15分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><center><p center large><red>LearnCpp chapter5</red></p></center><center><red>https://www.learncpp.com</red></center><a id="more"></a><h2 id="5-1-操作符优先级-amp-结合律"><a href="#5-1-操作符优先级-amp-结合律" class="headerlink" title="5.1 操作符优先级 &amp; 结合律"></a>5.1 操作符优先级 &amp; 结合律</h2><center>Operator precedence and associativity</center><p>下面是<strong>操作符的优先级 及 结合律</strong></p><blockquote><p>【note】</p><ol><li>下面表格的操作符优先级：<strong>level 1是最高优先级；level 17 优先级最低</strong></li><li>结合律：<ul><li><strong>L-&gt;R</strong>：即，从左向右结合</li><li><strong>R-&gt;L</strong> ：即。从右向左结合</li></ul></li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter5/image-20200403103620634.png" alt="1~8 level"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter5/image-20200403103654067.png" alt="9~17 level"></p><hr><p>注意一个<strong>连等号到表达式</strong>：</p><p><strong><code>x=y=z;</code>由上表可知，该表达式其实是这样的：<code>x=(y=z);</code></strong></p><hr><h2 id="5-2-算数运算符"><a href="#5-2-算数运算符" class="headerlink" title="5.2 算数运算符"></a>5.2 算数运算符</h2><center>Arithmetic operators</center><ul><li><p><strong>一元操作符(<em>Unary arithmetic operators</em></strong>)：<strong><code>+</code>、<code>-</code>：</strong></p><blockquote><p><strong>unary minus</strong>：返回 操作数乘以-1 之后的值。</p><p><strong>unary plus</strong>：返回 操作数本身。</p><p>这两个操作符都应该放在操作数的前面(e.g. -x , 而不是 - x)</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter5/image-20200403130245848.png" alt="一元操作符 + -"></p><p>eg: <code>x=5 - -3;</code>.第一个减号表示二元操作符，减法；第二个减号表示一元操作符。</p></li></ul><hr><ul><li><p><strong>二元运算符：<em>Binary arithmetic operators</em></strong></p><p>二元操作符有左、右 两个<strong>操作数(operand)</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter5/image-20200403130913816.png" alt="二元操作符"></p></li></ul><hr><ul><li><p><strong>整数与浮点数 的除法</strong></p><ol><li><p>左右两个操作数<strong>至少有一个是 浮点型值</strong>，它们的运算结果依然是一个浮点型的值。</p><blockquote><p>For example, <code>7.0 / 4 = 1.75</code>, <code>7 / 4.0 = 1.75</code>、<code>7.0 / 4.0 = 1.75</code></p></blockquote></li><li><p>做有<strong>两个操作数均为 整型值</strong>，它的运算结果依然是 整型值。</p><blockquote><p>For example, <code>7 / 4 = 1</code></p></blockquote></li></ol></li></ul><hr><ul><li><p><strong>用<code>static_cast&lt;&gt;</code>对整数进行浮点除法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123;<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> y&#123;<span class="number">4</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"int/int="</span>&lt;&lt;x/y&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"double / int = "</span>&lt;&lt;<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(x)/y&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"int / double = "</span>&lt;&lt;x/ <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(y)&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"double / double = "</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(x) / <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(y)&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****结果*****/</span></span><br><span class="line"><span class="keyword">int</span> / <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">double</span> / <span class="keyword">int</span> = <span class="number">1.75</span></span><br><span class="line"><span class="keyword">int</span> / <span class="keyword">double</span> = <span class="number">1.75</span></span><br><span class="line"><span class="keyword">double</span> / <span class="keyword">double</span> = <span class="number">1.75</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>除以<code>0</code></strong></p><p>如果除以0(或者 0.0)将会使程序崩溃。因为这个结果在数学中是没有定义的。</p></li></ul><hr><ul><li><p><strong>赋值操作符</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter5/image-20200403133616428.png" alt="赋值操作符"></p></li></ul><hr><h2 id="5-3-取模-amp-幂运算"><a href="#5-3-取模-amp-幂运算" class="headerlink" title="5.3 取模 &amp; 幂运算"></a>5.3 取模 &amp; 幂运算</h2><ul><li><p><strong>取模操作符：The modulus operator</strong></p><p><strong><em>取模操作符*，又称 *取余操作符</em></strong>。</p><blockquote><p>【note】：<u><strong>取余运算结果的符号，只和第一个操作数相一致。</strong></u></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123; <span class="number">6</span> &#125;, y&#123; <span class="number">-4</span> &#125;; <span class="comment">//第一个操作数符号为 正</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x%y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> z&#123; <span class="number">-6</span> &#125;, w&#123; <span class="number">4</span> &#125;; <span class="comment">//第一个操作数符号为 负</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; z%w ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="built_in">std</span>::numeric_limits &lt;<span class="built_in">std</span>::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span> );</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/post_image/LearnCpp-chapter5/image-20200403134914381.png" alt="取余结果的符号与“被除数”的符号相同"></p></blockquote></li></ul><hr><ul><li><p><strong>幂运算符<code>^</code></strong></p><p>您将注意到<code>^</code>运算符(在数学中通常用于表示求幂)是c++中的位<strong>XOR操作</strong>。在C++中不包含“幂运算操作符”。如果要用，就需要加上<strong>头文件<code>cmath</code></strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">double</span> x&#123; <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">3.0</span>, <span class="number">4.0</span>)&#125;; <span class="comment">//3 to the 4th power(3的4次方)</span></span><br></pre></td></tr></table></figure><blockquote><p>【Note】注意，<strong>pow()函数的参数(和返回值)是double类型的</strong>。所以，就算传入的是整数类型的，它的计算还是会有误差的(因为浮点数计算本身就会有误差)</p></blockquote><hr><p>所以，如果你想对整数进行幂运算，可以自己设计函数，使其结果比较精确：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt; //for std::int_fast64_t</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//note: exp(幂数) 不能是负数[因为用的是while循环]</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="keyword">int_fast64_t</span> <span class="title">powint</span> <span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> <span class="built_in">exp</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">int_fast64_t</span> result &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">exp</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">exp</span> &amp; <span class="number">1</span>)</span><br><span class="line">            result *= base;</span><br><span class="line">        <span class="built_in">exp</span> &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        base *= base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;powint(<span class="number">7</span>,<span class="number">12</span>); <span class="comment">//7的12次幂</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="5-4-递增-递减操作符"><a href="#5-4-递增-递减操作符" class="headerlink" title="5.4 递增/递减操作符"></a>5.4 递增/递减操作符</h2><table><thead><tr><th align="left">Operator</th><th align="left">Symbol</th><th align="left">Form</th><th align="left">Operation</th></tr></thead><tbody><tr><td align="left">Prefix increment (pre-increment)</td><td align="left">++</td><td align="left">++x</td><td align="left">Increment x, then return x</td></tr><tr><td align="left">Prefix decrement (pre-decrement)</td><td align="left">––</td><td align="left">––x</td><td align="left">Decrement x, then return x</td></tr><tr><td align="left">Postfix increment (post-increment)</td><td align="left">++</td><td align="left">x++</td><td align="left">Copy x, then increment x, then return the copy</td></tr><tr><td align="left">Postfix decrement (post-decrement)</td><td align="left">––</td><td align="left">x––</td><td align="left">Copy x, then decrement x, then return the copy</td></tr></tbody></table><hr><ul><li><p><strong>副作用：side effects</strong></p><center>c++不定义函数参数或操作符操作数的求值顺序。</center><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> x+y;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123;<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> valude = add(x, ++x); <span class="comment">//结果是5+6,还是6+6?</span></span><br><span class="line">    <span class="comment">//这取决于编译器计算函数参数的顺序</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;value; <span class="comment">// value could be 11 or 12, depending on how the above line evaluates!</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>【副作用】：<strong>c++没有定义函数参数求值的顺序。</strong></p><p>这种就会产生不确定性，因为还要<strong>取决于编译器对函数的参数计算的顺序</strong>。所以，不同的编译器可能会产生不同的结果。</p><p>所以，结果可能为：11 或者 12</p></blockquote></li></ul><hr><h2 id="5-5-逗号“-”-amp-条件-运算符"><a href="#5-5-逗号“-”-amp-条件-运算符" class="headerlink" title="5.5 逗号“,” &amp; 条件 运算符"></a>5.5 逗号“<code>,</code>” &amp; 条件 运算符</h2><h3 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h3><center>逗号操作符适用于for循环，其他情况不推荐用</center><table><thead><tr><th align="left">Operator</th><th align="left">Symbol</th><th align="left">Form</th><th align="left">Operation</th></tr></thead><tbody><tr><td align="left">Comma</td><td align="left">,</td><td align="left">x, y</td><td align="left">Evaluate x then y, returns value of y</td></tr></tbody></table><p><strong>comma operator (,)</strong>：允许您在允许单个表达式的情况下计算多个表达式的值。<strong>逗号运算符对左操作数求值，然后对右操作数求值，<u>然后返回右操作数的结果</u></strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> y&#123;<span class="number">2</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; (++x, ++y); <span class="comment">//先计算左操作符，在计算右操作符，但是返回右操作符的结果</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******结果**********/</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><hr><ul><li><p><strong>逗号操作符是所有操作符中最低的</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">z = (a,b); <span class="comment">//计算(a,b)，然后将返回的结果赋值给z</span></span><br><span class="line">z = a , b; <span class="comment">//由于“=”操作符优先于“,”操作符，所以，先计算“z=a”;然后在计算b，计算完之后，b没用就被抛弃了</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>逗号用作分隔符时，它此时代表的不是操作符</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// Comma used to separate parameters in function definition</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    add(x, y); <span class="comment">// Comma used to separate arguments in function call</span></span><br><span class="line">    int z(3), w(5); // Comma used to separate multiple variables being defined on the same line (don't do this)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h3><p>条件操作符是一个 <strong>三元操作符</strong></p><table><thead><tr><th align="left">Operator</th><th align="left">Symbol</th><th align="left">Form</th><th align="left">Operation</th></tr></thead><tbody><tr><td align="left">Conditional</td><td align="left">? :</td><td align="left">c ? x : y</td><td align="left">If c is nonzero (true) then evaluate x, otherwise evaluate y</td></tr></tbody></table><p>形式：<code>(condition) ? expression1 : expression2;</code></p><blockquote><p>当<code>condition</code>的结果是正确的(或者非零数字)，就执行<code>expression1</code>，否则，执行<code>expression2</code></p></blockquote><hr><ul><li><p><strong>由于条件操作符优先级较低，有时需要括号</strong></p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (x&gt;y) ? x : y;</span><br><span class="line"><span class="comment">//由于“&lt;&lt;”的优先级高于“条件操作符”,所以，等同于以下形式：</span></span><br><span class="line">(<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (x&gt;y)) ? x : y;</span><br><span class="line"><span class="comment">//想要按照我们设计的正确执行，则需要适当加上括号</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;((x&gt;y) ? x : y);</span><br></pre></td></tr></table></figure></li></ul><hr><p>【注意】与在函数内部定义的变量在函数结束时死亡非常相似，在if或else语句中定义的变量在if或else语句结束时死亡。因此，在我们试图打印它时，类大小已经被破坏了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> inBigClassroom &#123; <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (inBigClassroom)</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> classSize &#123; <span class="number">30</span> &#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> classSize &#123; <span class="number">20</span> &#125;;</span><br><span class="line">    <span class="comment">//此时，if/else已经执行结束，所以，其内部定义的变量classSize也已经被销毁</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The class size is: "</span> &lt;&lt; classSize; <span class="comment">//因为classSize被销毁，所以会编译出错</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li><p><strong>条件编译的两个表达式的类型</strong></p><p>条件编译的两个表达式，<strong>要么具有相同的类型</strong>；<strong>要么第二个表达式的类型可以转化为第一个表达式的类型</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (x != <span class="number">5</span> ? x : <span class="string">"x is 5"</span>); <span class="comment">// won't compile</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为，表达式1：x 是integer 类型；表达式2："x is 5"是string类型。所以表达式2要转换为表达式1的类型，但是转换失败。所以编译就不成功</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="5-6-关系运算符-amp-浮点数的比较"><a href="#5-6-关系运算符-amp-浮点数的比较" class="headerlink" title="5.6 关系运算符 &amp; 浮点数的比较"></a>5.6 关系运算符 &amp; 浮点数的比较</h2><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><table><thead><tr><th align="left">Operator</th><th align="left">Symbol</th><th align="left">Form</th><th align="left">Operation</th></tr></thead><tbody><tr><td align="left">Greater than</td><td align="left">&gt;</td><td align="left">x &gt; y</td><td align="left">true if x is greater than y, false otherwise</td></tr><tr><td align="left">Less than</td><td align="left">&lt;</td><td align="left">x &lt; y</td><td align="left">true if x is less than y, false otherwise</td></tr><tr><td align="left">Greater than or equals</td><td align="left">&gt;=</td><td align="left">x &gt;= y</td><td align="left">true if x is greater than or equal to y, false otherwise</td></tr><tr><td align="left">Less than or equals</td><td align="left">&lt;=</td><td align="left">x &lt;= y</td><td align="left">true if x is less than or equal to y, false otherwise</td></tr><tr><td align="left">Equality</td><td align="left">==</td><td align="left">x == y</td><td align="left">true if x equals y, false otherwise</td></tr><tr><td align="left">Inequality</td><td align="left">!=</td><td align="left">x != y</td><td align="left">true if x does not equal y, false otherwise</td></tr></tbody></table><blockquote><p>这些操作符的值分别为布尔值true(1)和false(0)。</p></blockquote><hr><h3 id="浮点数的比较"><a href="#浮点数的比较" class="headerlink" title="浮点数的比较"></a>浮点数的比较</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d1&#123; <span class="number">100.0</span> - <span class="number">99.99</span> &#125;; <span class="comment">// should equal 0.01 ?</span></span><br><span class="line">    <span class="keyword">double</span> d2&#123; <span class="number">10.0</span> - <span class="number">9.99</span> &#125;; <span class="comment">// should equal 0.01 ?</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (d1 == d2)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"d1 == d2"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (d1 &gt; d2)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"d1 &gt; d2"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (d1 &lt; d2)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"d1 &lt; d2"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****结果*****/</span></span><br><span class="line">d1 &gt; d2</span><br></pre></td></tr></table></figure><p>我们可以看到，在我们的调试模式下，d1 = 0.0100000000000005116 而 d2 = 0.0099999999999997868.</p><blockquote><p>【Note】：在两个浮点数非常接近时，如果使用<code>==</code>和<code>!=</code>对浮点数之间比较，结果会不太准确。</p></blockquote><hr><ul><li><p><strong>使用<code>epsilon</code>准确比较浮点数</strong></p><p>我们可以使用<code>epsilon</code>来相对准确的比较两个 足够接近的 浮点型数值。</p><blockquote><p><code>epsilon</code>：通常被定义为一个小的正数(如，0.00000001，即1e-8)</p></blockquote><p>现在，我们来比较两个”close enough”的浮点数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; //for std::abs()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//epsilon is an absolute value</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isAlmostEqual</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> epsilon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//if the distance between a and b is less than epsilon, then a and b are "close enough"</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">abs</span>(a-b) &lt;= epsilon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这个函数可以工作，但它不是很好。0.00001的epsilon值对于1.0左右的输入是合适的，对于0.0000001左右的输入是太大了，对于10,000这样的输入是太小了。这意味着每次我们调用这个函数时，我们必须选择一个适合我们输入的。如果我们知道我们要根据输入的比例来缩放，我们也可以修改函数来做到这一点。</p><p><strong>改进1：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; //std::abs</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; //std::max</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//return true if the difference between a and b is within epsilon</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">approximatelyEqual</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b, <span class="keyword">double</span> epsilon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(a-b) &lt;= ( <span class="built_in">std</span>::<span class="built_in">max</span>( <span class="built_in">std</span>::<span class="built_in">abs</span>(a),<span class="built_in">std</span>::<span class="built_in">abs</span>(b) ) * epsilon ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这种情况下，<code>epsilon</code>不再是一个绝对值，<strong>现在是相对于a或b大小的量级</strong>。</p></blockquote><p><strong>再改进2【推荐】</strong>：</p><p><strong>当浮点数足够接近于0时</strong>，上面的方法还是不太行的。</p><blockquote><p>改进方法就是：<strong>同时使用相对值和绝对值</strong>：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return true if the difference between a and b is less than absEpsilon, or within relEpsilon percent of the larger of a and b</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">approximatelyEqualAbsRel</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> absEpsilon, <span class="keyword">double</span> relEpsilon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Check if the numbers are really close -- needed when comparing numbers near zero.</span></span><br><span class="line">    <span class="keyword">double</span> diff&#123; <span class="built_in">std</span>::<span class="built_in">abs</span>(a - b) &#125;;</span><br><span class="line">    <span class="keyword">if</span> (diff &lt;= absEpsilon)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Otherwise fall back to Knuth's algorithm(相对值方法，即“改进1”的方法)</span></span><br><span class="line">    <span class="keyword">return</span> (diff &lt;= (<span class="built_in">std</span>::<span class="built_in">max</span>(<span class="built_in">std</span>::<span class="built_in">abs</span>(a), <span class="built_in">std</span>::<span class="built_in">abs</span>(b)) * relEpsilon));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这个算法中，我们首先检查a和b在绝对值上是否接近，这处理了a和b都接近于零的情况。<strong>absEpsilon参数应该设置为非常小的值(例如1e-12)</strong>。如果失败了，我们就回到Knuth的算法，即，使用相对的epsilon。</p></blockquote></li></ul><p>完整的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; //std::max</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;     //std::abs</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果a和b之间的差值在a和b之间较大值的百分之几内，则返回true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">approximatelyEqual</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b,<span class="keyword">double</span> epsilon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(a-b) &lt;= (<span class="built_in">std</span>::<span class="built_in">max</span>(<span class="built_in">std</span>::<span class="built_in">abs</span>(a), <span class="built_in">std</span>::<span class="built_in">abs</span>(b)) * epsilon ));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//针对于接近于0 的浮点数的比较</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">approximatelyEqualAbsRel</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b,<span class="keyword">double</span> absEpsilon, <span class="keyword">double</span> relEspilon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//check if the numbers are really close -- need when comparing numbers near zero.</span></span><br><span class="line">    <span class="keyword">double</span> diff &#123;<span class="built_in">std</span>::<span class="built_in">abs</span>(a-b)&#125;;</span><br><span class="line">    <span class="keyword">if</span> (diff &lt;= absEpsilon)</span><br><span class="line">        <span class="keyword">return</span> ture;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//otherwise fall back to 相对值法</span></span><br><span class="line">    <span class="keyword">return</span> (diff &lt;= (<span class="built_in">std</span>::<span class="built_in">max</span>(<span class="built_in">std</span>::<span class="built_in">abs</span>(a), <span class="built_in">std</span>::<span class="built_in">abs</span>(b)) * relEspilon));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//a is really close to 1.0, but has rounding errors</span></span><br><span class="line">    <span class="keyword">double</span> a&#123;<span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; approximatelyEqual(a, <span class="number">1.0</span>, <span class="number">1e-8</span>);<span class="comment">//compare "almost 1.0" to 1.0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; approximatelyEqual(a<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">1e-8</span>); <span class="comment">//compare "almost 0.0" to 0.0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; approximatelyEqualAbsRel(a<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">1e-12</span>, <span class="number">1e-8</span>) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// compare "almost 0.0" to 0.0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********结果*********/</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>可以看出，<strong>在对于接近于0的浮点数，与 0.0比较时。<code>approximatelyEqualAbsRel</code>要更加准确。</strong></p></blockquote><p><strong>使用<code>approximatelyEqualAbsRel</code>方法，就可以解决大多数情况</strong>。它也涵盖了<code>approximatelyEqual</code>函数的功能。</p><hr><h2 id="5-7-逻辑操作符"><a href="#5-7-逻辑操作符" class="headerlink" title="5.7 逻辑操作符"></a>5.7 逻辑操作符</h2><table><thead><tr><th align="left">Operator</th><th align="left">Symbol</th><th align="left">Form</th><th align="left">Operation</th></tr></thead><tbody><tr><td align="left">Logical NOT</td><td align="left">!</td><td align="left">!x</td><td align="left">true if x is false, or false if x is true</td></tr><tr><td align="left">Logical AND</td><td align="left">&amp;&amp;</td><td align="left">x &amp;&amp; y</td><td align="left">true if both x and y are true, false otherwise</td></tr><tr><td align="left">Logical OR</td><td align="left">||</td><td align="left">x || y</td><td align="left">true if either x or y are true, false otherwise</td></tr></tbody></table><hr><ul><li><p><strong>NOT：！</strong></p><p>需要注意的是，<strong>NOT 操作符的优先级很高，在level 3</strong>。所以，你很有可能会犯这种错误：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123;<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> y&#123;<span class="number">7</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!x&gt;y) <span class="comment">//正确写法：if (!(x&gt;y))</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x is not greater than y\n"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x is equal to or greater than y\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********结果************/</span></span><br><span class="line">x is equal to <span class="keyword">or</span> greater than y</span><br></pre></td></tr></table></figure><p>可以看出，结果不正确。在这里就是因为，<code>if(!x&gt;y)</code>中，由于<code>!</code>优先级高于<code>&gt;</code>。所以，先计算“!x”，其实，就相当于：<code>if ( (!x) &gt; y )</code></p></li></ul><hr><ul><li><p><strong>AND： &amp;&amp;</strong></p><ul><li><p>如果逻辑操作符<code>&amp;&amp;</code>要返回“true”，那么所有的操作数都必须是‘true’；</p></li><li><p>但如果<code>&amp;&amp;</code>返回是“false”，只要有一个操作数是‘false’即可。</p><blockquote><p>特殊的，如果第一个操作数是‘false’的话，就不会再继续看后面操作符是‘false’还是‘true’，即图签终止了。这种情况叫做：“<strong>short circuit evaluation</strong>”</p></blockquote></li></ul><p>相似的，逻辑操作符 或<code>||</code>，如果要返回“true”的话，也是只要有一个操作数是‘true’即可。</p></li></ul><hr><blockquote><p><strong>逻辑操作符<code>&amp;&amp;</code>的优先级高于<code>||</code></strong>，所以，在使用如：<code>value1 || value2 &amp;&amp; value3</code>时，要更加小心，<strong>使用括号才会更加安全</strong>。</p></blockquote><hr><ul><li><p><strong>德摩根定律：De Morgan’s law</strong></p><p>德摩根定律告诉我们，可以这样使用逻辑操作符<code>!</code>：</p><p><code>!(x &amp;&amp; y)</code> 等同于 <code>!x || !y</code></p><p><code>!(x || y)</code>等同于 <code>!x &amp;&amp; !y</code></p><blockquote><p>换句话说，当您分发逻辑NOT时，您还需要转换为逻辑AND逻辑OR，反之亦然!</p></blockquote></li></ul><hr><ul><li><p><strong>逻辑操作符，异或<code>XOR</code></strong></p><table><thead><tr><th align="left">Left operand</th><th align="left">Right operand</th><th align="left">Result</th></tr></thead><tbody><tr><td align="left">false</td><td align="left">false</td><td align="left">false</td></tr><tr><td align="left">false</td><td align="left">true</td><td align="left">true</td></tr><tr><td align="left">true</td><td align="left">false</td><td align="left">true</td></tr><tr><td align="left">true</td><td align="left">true</td><td align="left">false</td></tr></tbody></table></li></ul><blockquote><p>即，<strong>真假 为 真</strong>，<strong>其他结果都是 假</strong></p></blockquote><p>C++没有提供专门提供 异或操作符，但是我们可以使用：</p><ol><li><p><strong>当操作数是布尔型</strong>的，即true，false，而不是integer，可以使用<code>!=</code>来实现异或：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a != b) <span class="comment">//a XOR b ,假定a、b是booleans</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="comment">//多个操作数</span></span><br><span class="line"><span class="keyword">if</span> (a != b != c != d)  <span class="comment">// a XOR b XOR c XOR d, assuming a, b, c, and d are Booleans</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li><li><p><strong>当操作数不是布尔型</strong>时，<strong>使用<code>static_cast</code>转化为bool</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(a) != <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(b) != <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(c)) <span class="comment">// a XOR b XOR c XOR d, for any type that can be converted to bool</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li></ol><br><section class="widget copyright desktop mobile"><div class="content"><blockquote><p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p><p>本文永久链接是：<a href="https://www.longlongqin.top/archives/b6a3dbf1.html">https://www.longlongqin.top/archives/b6a3dbf1.html</a></p></blockquote></div></section><section class="widget qrcode desktop mobile"><div class="content article-entry"><fancybox><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/reward/AliPayOR.jpg" height="64px"></fancybox><fancybox><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/reward/WeChatPayOR.png" height="64px"></fancybox></div></section></div><section class="meta" id="footer-meta"><div class="new-meta-box"><div class="new-meta-item date" itemprop="dateUpdated" datetime="2020-04-03T21:57:08+08:00"><a class="notlink"><i class="fas fa-save" aria-hidden="true"></i><p>更新于：2020年4月3日</p></a></div><div class="new-meta-item meta-tags"><a class="tag" href="/tags/C-C/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i><p>C/C++</p></a></div><div class="new-meta-item share -mob-share-list"><div class="-mob-share-list share-body"><a class="-mob-share-qq" rel="external nofollow noopener noreferrer noopener" href="http://connect.qq.com/widget/shareqq/index.html?url=https://www.longlongqin.top/archives/b6a3dbf1.html&title=LearnCpp chapter5 - 龙龙‘S BLOG&summary=LearnCpp chapter5https://www.learncpp.com" target="_blank"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qq.png"> </a><a class="-mob-share-qzone" rel="external nofollow noopener noreferrer noopener" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://www.longlongqin.top/archives/b6a3dbf1.html&title=LearnCpp chapter5 - 龙龙‘S BLOG&summary=LearnCpp chapter5https://www.learncpp.com" target="_blank"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qzone.png"> </a><a class="-mob-share-weibo" rel="external nofollow noopener noreferrer noopener" href="http://service.weibo.com/share/share.php?url=https://www.longlongqin.top/archives/b6a3dbf1.html&title=LearnCpp chapter5 - 龙龙‘S BLOG&summary=LearnCpp chapter5https://www.learncpp.com" target="_blank"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/weibo.png"></a></div></div></div></section><div class="prev-next"><a class="prev" href="/archives/c1a4eb67.html"><p class="title"><i class="fas fa-chevron-left" aria-hidden="true"></i>LearnCpp chapter4</p><p class="content">LearnCpp chapter4https://www.learncpp.com4.1 基本的数据类型内存最小的单位是一个二进制数(binary digit)，即位(bit)。它可以存储一个0...</p></a><a class="next" href="/archives/28c74e52.html"><p class="title">LearnCpp chapter2<i class="fas fa-chevron-right" aria-hidden="true"></i></p><p class="content">LearnCpp chapter2https://www.learncpp.com2.1 函数当你读一本书的时候，突然有人给你打电话。然后你就用“书签”夹在当前阅读位置，去接电话。等你电话接完，...</p></a></div></section></article><article class="post white-box comments shadow"><section class="article typo"><p ct><i class="fas fa-comments"></i> 评论</p><section id="comments"><div id="valine_container" class="valine_thread"><i class="fas fa-spinner fa-spin fa-fw"></i></div></section></section></article><script>window.subData={title:"LearnCpp chapter5",tools:!0}</script></div><aside class="l_side"><section class="widget toc-wrapper shadow desktop mobile"><header><i class="fas fa-list fa-fw" aria-hidden="true"></i><span class="name">本文目录</span></header><div class="content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-操作符优先级-amp-结合律"><span class="toc-text">5.1 操作符优先级 &amp; 结合律</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-算数运算符"><span class="toc-text">5.2 算数运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-取模-amp-幂运算"><span class="toc-text">5.3 取模 &amp; 幂运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-递增-递减操作符"><span class="toc-text">5.4 递增&#x2F;递减操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-逗号“-”-amp-条件-运算符"><span class="toc-text">5.5 逗号“,” &amp; 条件 运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#逗号操作符"><span class="toc-text">逗号操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条件操作符"><span class="toc-text">条件操作符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-关系运算符-amp-浮点数的比较"><span class="toc-text">5.6 关系运算符 &amp; 浮点数的比较</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#关系运算符"><span class="toc-text">关系运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#浮点数的比较"><span class="toc-text">浮点数的比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-逻辑操作符"><span class="toc-text">5.7 逻辑操作符</span></a></li></ol></div></section></aside><footer class="clearfix white"><br><br><div class="aplayer-container"><meting-js theme="#1BCDFC" autoplay volume="0.6" loop order="list" fixed="false" list-max-height="340px" server="netease" type="song" id="186453" list-folded="true"></meting-js></div><br><div class="social-wrapper"><a href="/atom.xml" class="social fas fa-rss flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="mailto:1198216723@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://github.com/longlongqin" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://music.163.com/#/user/home?id=285545421" class="social fas fa-headphones-alt flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a></div><red>&copy; 2020-2020 longlongqin 😊| powered by HEXO | theme volantis</red><br><yellow><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("03/01/2020 18:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="小站已运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒 "}setInterval("createtime()",250)</script></yellow><br><green><i class="fas fa-chart-area"></i> <span class="post-count">字数统计：110.4k</span></green>|<script type="text/javascript" src="https://v1.cnzz.com/z_stat.php?id=1278663994&web_id=1278663994"></script><br><cyan>博客内容遵循</cyan><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank"><cyan>署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</cyan></a></footer><script>setLoadingBarProgress(80)</script><script>setLoadingBarProgress(60)</script></div><a class="s-top fas fa-arrow-up fa-fw" href="javascript:void(0)"></a></div><script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script><script>var SEARCH_SERVICE="hexo",ROOT="/";ROOT.endsWith("/")||(ROOT+="/")</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script><script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script><script type="text/javascript">$(function(){Waves.attach(".flat-btn",["waves-button"]),Waves.attach(".float-btn",["waves-button","waves-float"]),Waves.attach(".float-btn-light",["waves-button","waves-float","waves-light"]),Waves.attach(".flat-box",["waves-block"]),Waves.attach(".float-box",["waves-block","waves-float"]),Waves.attach(".waves-image"),Waves.init()})</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script><script type="text/javascript">$(function(){var n=["https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/background/4.jpg"];!function(n){for(var o=n.length;o--;){var r=Math.floor(Math.random()*o),t=n[r];n[r]=n[o],n[o]=t}}(n),$(".cover").backstretch(n,{duration:"20000",fade:"1500"})})</script><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js" async></script><script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js" async></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.0/js/valine.js"></script><script>var GUEST_INFO=["nick","mail","link"],guest_info="nick,mail,link".split(",").filter(function(i){return-1<GUEST_INFO.indexOf(i)}),notify=!1,verify=!1,valine=new Valine;valine.init({el:"#valine_container",notify:notify,verify:verify,guest_info:guest_info,appId:"TYFUId8Xuddv6nUYuVUHJbac-gzGzoHsz",appKey:"bCYkC8WKY7n8VjI7K2g8MMJ3",placeholder:"快来评论吧~",pageSize:"10",avatar:"mp",lang:"zh-cn",visitor:"false",highlight:"true"})</script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1.4/js/app.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1/js/search.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script><script>!function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copyed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-clipboard-check');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPYED';
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-exclamation-triangle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
      });
    }
    initCopyCode();
  }(window, document);</script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>let LAZY_LOAD_IMAGE = "[object Object]";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });</script><script>setLoadingBarProgress(100)</script><script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)t=c[r],0<=(n=t.getBoundingClientRect()).bottom&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this);</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script></body></html>