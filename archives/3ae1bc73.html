<!DOCTYPE html><html><head hexo-theme="https://volantis.js.org/#2.1.4"><meta charset="utf-8"><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><title>计算机科学速成课(总) - 龙龙‘S BLOG</title><meta name="keywords" content="《计算机科学速成课》"><meta name="description" content="计算机科学速成课"><link rel="alternate" href="/atom.xml" title="龙龙‘S BLOG"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css"><link rel="shortcut icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1.4.3/css/style.css"><script>function setLoadingBarProgress(e){document.getElementById("loading-bar").style.width=e+"%"}</script></head><body><script type="text/javascript" src="/js/love.js"></script><script type="text/javascript" src="/js/ergao.js"></script><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><header class="l_header shadow blur"><div class="wrapper"><div class="nav-sub container--flex"><a class="logo flat-box"></a><ul class="switcher h-list"><li><a class="s-comment flat-btn fas fa-comments fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-toc flat-btn fas fa-list fa-fw" target="_self" href="javascript:void(0)"></a></li></ul></div><div class="nav-main container container--flex"><a class="logo flat-box" target="_self" href="/"><i class="fas fa-home"></i> 龙龙</a><div class="menu navigation"><ul class="h-list"><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list-alt fa-fw fa-fw"></i> 索引</a><ul class="submenu"><li><a class="flat-box" href="/categories/" id="categories"><i class="fas fa-folder-open fa-fw fa-fw"></i> 分类</a><ul class="submenu"><li><a class="flat-box" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="categoriesE5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-fire fa-fw"></i> 学习笔记</a></li><li><a class="flat-box" href="/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" id="categoriesE5AE9EE794A8E68A80E5B7A7"><i class="fas fa-fire fa-fw"></i> 实用技巧</a></li></ul></li><li><a class="flat-box" href="/tags/" id="tags"><i class="fas fa-tags fa-fw fa-fw"></i> 标签</a></li><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list fa-fw fa-fw"></i> 时间轴</a></li></ul></li><li><a class="flat-box" href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="E5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-book fa-fw"></i> 学习笔记</a></li><li><a class="flat-box"><i class="fas fa-wrench fa-fw"></i> 工具</a><ul class="submenu"><li><a class="flat-box" href="https://www.thinkcmf.com/font/search/index.html" target="_blank" rel="noopener" id="https:www.thinkcmf.comfontsearchindex.html"><i class="fas fa-font fa-fw"></i> Font Awesome图标</a></li><li><a class="flat-box" href="https://www.sojson.com/image/change.html" target="_blank" rel="noopener" id="https:www.sojson.comimagechange.html"><i class="fa fa-crop fa-fw"></i> 在线图片尺寸修改</a></li><li><a class="flat-box" href="http://dir.scmor.com/" target="_blank" rel="noopener" id="http:dir.scmor.com"><i class="fa fa-search fa-fw"></i> Google学术&搜索镜像</a></li><li><a class="flat-box" href="https://emojixd.com/" target="_blank" rel="noopener" id="https:emojixd.com"><i class="fa fa-smile-o fa-fw"></i> Emoji表情符号辞典📓</a></li></ul></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw fa-fw"></i> 关于</a><ul class="submenu"><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-user-circle fa-fw fa-fw"></i> 关于我</a></li><hr><li><a class="flat-box" href="/friends/" id="friends"><i class="fas fa-link fa-fw"></i> 友人帐</a></li><li><a class="flat-box" href="/comment/" id="comment"><i class="fas fa-comment fa-fw"></i> 留言板</a></li><hr><li><a class="flat-box" href="https://github.com/longlongqin" target="_blank" rel="noopener" id="https:github.comlonglongqin"><i class="fab fa-github fa-fw fa-fw"></i> 我的Github</a></li><li><a class="flat-box" href="https://longlongqin.gitee.io" target="_blank" rel="noopener" id="https:longlongqin.gitee.io"><i class="fa fa-chevron-circle-right fa-fw"></i> matery主题博客</a></li></ul></li><li><a class="flat-box" href="https://volantis.js.org/tag-plugins/" target="_blank" rel="noopener" id="https:volantis.js.orgtag-plugins"><i class="fa fa-bookmark fa-fw"></i> Volantis主题文档</a></li><li><a class="flat-box" href="/easysearch/" id="easysearch"><i class="fa fa-search fa-fw"></i> easy搜索</a></li></ul></div><div class="m_search"><form name="searchform" class="form u-search-form"><i class="icon fas fa-search fa-fw"></i> <input type="text" class="input u-search-input" placeholder="search for everything"></form></div><ul class="switcher h-list"><li><a class="s-search flat-btn fas fa-search fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-menu flat-btn fas fa-bars fa-fw" target="_self" href="javascript:void(0)"></a></li></ul></div></div></header><ul class="menu-phone navigation white-box"><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-list-alt fa-fw fa-fw"></i> 索引</a></li><li><a class="flat-box" href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="E5ADA6E4B9A0E7AC94E8AEB0"><i class="fas fa-book fa-fw"></i> 学习笔记</a></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw fa-fw"></i> 关于</a></li></ul><script>setLoadingBarProgress(40)</script><div class="l_body nocover"><div class="body-wrapper"><div class="l_main"><article id="post" class="post white-box shadow article-type-post" itemscope itemprop="blogPost"><section class="meta"><div class="meta" id="header-meta"><h1 class="title"><a href="/archives/3ae1bc73.html">计算机科学速成课(总)</a></h1><div class="new-meta-box"><div class="new-meta-item author"><a href="https://www.longlongqin.top" rel="nofollow"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/photo.jpg"><p>longlongin</p></a></div><div class="new-meta-item category"><a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="nofollow"><i class="fas fa-folder-open" aria-hidden="true"></i><p>学习笔记</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-edit" aria-hidden="true"></i><p>发布于：2020年4月1日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard" aria-hidden="true"></i><p>字数：26.7k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half" aria-hidden="true"></i><p>时长：93分钟</p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><center><red>计算机科学速成课</red></center><a id="more"></a><h1 id="参考文章-："><a href="#参考文章-：" class="headerlink" title="###参考文章###："></a>###参考文章###：</h1><p>*<em>计算机科学速成课 *</em>：</p><p>笔记：<a href="https://www.cnblogs.com/livil/p/10155073.html" target="_blank" rel="noopener">https://www.cnblogs.com/livil/p/10155073.html</a> 和<a href="https://zhuanlan.zhihu.com/p/103505933" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/103505933</a> 或 <a href="https://www.imooc.com/article/271502" target="_blank" rel="noopener">https://www.imooc.com/article/271502</a></p><p>字幕：<a href="https://github.com/1c7/Crash-Course-Computer-Science-Chinese/blob/master/(字幕)全40集中英字幕文本" target="_blank" rel="noopener">https://github.com/1c7/Crash-Course-Computer-Science-Chinese/blob/master/(字幕)全40集中英字幕文本</a></p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/5c2dbf8e0001443913279329.jpg" alt="5c2dbf8e0001443913279329" style="zoom:150%"><h1 id="2、电子计算机"><a href="#2、电子计算机" class="headerlink" title="2、电子计算机"></a>2、电子计算机</h1><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/1528749-20181221121908992-643367848.png" alt="img" style="zoom:200%"><h1 id="3、布尔逻辑和逻辑门"><a href="#3、布尔逻辑和逻辑门" class="headerlink" title="3、布尔逻辑和逻辑门"></a>3、布尔逻辑和逻辑门</h1><p>计算机最早是机电设备，一般用十进制计数。也有一些是三进制、五进制的。【也就是x进制表示有x种状态。】</p><p>二进制中的 1或0 叫做：位（bit）；1字节（byte）=8位(bits)</p><h1 id="5、算数逻辑单元（ALU）"><a href="#5、算数逻辑单元（ALU）" class="headerlink" title="5、算数逻辑单元（ALU）"></a>5、算数逻辑单元（ALU）</h1><p>：是计算机的数学大脑，是计算机里负责运算的组件。</p><blockquote><p>ALU有2个单元：1个<strong>算数单元</strong>和1个<strong>逻辑单元</strong>。</p><p>算数单元：负责计算机里的所有数字操作。如加减法。</p></blockquote><h2 id="1）算数单元"><a href="#1）算数单元" class="headerlink" title="1）算数单元"></a>1）算数单元</h2><h3 id="半加器-A-half-adder"><a href="#半加器-A-half-adder" class="headerlink" title="(半加器)A half adder:"></a>(半加器)A half adder:</h3><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200220151049446.png" alt="image-20200220151049446" style="zoom:150%"><p>半加器如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200211204327584.png" alt="image-20200211204327584"></p><p>将其抽象化，把“把假期”封装成一个单独组件：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200211204510442.png" alt="image-20200211204510442"></p><h3 id="全加器（Full-Adder）"><a href="#全加器（Full-Adder）" class="headerlink" title="全加器（Full Adder）:"></a>全加器（Full Adder）:</h3><p>如果想要处理多位二进制数加法时，就需要<strong>全加器（Full Adder）</strong>，因为半加器计算完当前位的结果后，会输出进位，意味着计算下一位的结果时，要将两个输入以及前一位的进位相加。我们可以得到<strong>全加器</strong>的真值表：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-f41514f0f20020dd462462f3d58bbcc4_r.jpg" alt="preview"></p><center>全加器真值表</center>![image-20200211205005097](https://longlongqin.gitee.io/image_save/images/assets/image-20200211205005097.png)<p>我们这里可以使用半加器来实现全加器。我们可以将一个半加器结果当做是INPUT A 和INPUT B相加后的结果，然后将SUM当做是新的INPUT A，而PRE CARRY当做是新的INPUT B输入到新的半加器中，可以发现其SUM结果和全加器SUM结果相同。而全加器的CARRY只要对这两个半加器的CARRY进行OR运算就可以了。（<strong>注意：</strong>这两个半加器不会同时出现进位）</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-cd2bf02b43475d66ab37e88a47df4eb2_hd.jpg" alt="img"></p><p>同样我们也可以对全加器进行抽象，得到一个包含三个输入和两个输出的独立部件。</p><p>由此我们可以进行两个8位数字相加，表示为A和B:</p><ol><li>对A和B的第一位进行相加时，由于不存在进位，所以值使用一个半加器就能实现，这个半加器的SUM就为该位的结果，CARRY就为进位。</li><li>后续的7位二进制相加，由于每一个都涉及了上一位的进位，所以后续需要7个全加器，并且每个全加器的CARRY要连接到下一个全加器的输入，而每个全加器的SUM就为该位的结果。</li><li>最后一个全加器有CARRY的输出，如果该CARRY为1，就表示相加结果太大了，超出了8位，所以出现了<strong>溢出（overflow）</strong>【<strong>溢出：</strong>一般来说 “溢出” 的意思是, 两个数字的和太大了，超过了用来表示的位数，这会导致错误和不可预期的结果。】。</li></ol><p>由此，我们就构建出了一个<strong>8位加法器（8-bit adder）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-232e40f98a8adcf998b256bfe5c52bae_hd.jpg" alt="img"></p><p>通过连接1个半加器和n-1个全加器，就能构建n位加法器。通过叠加更多的加法器，能够避免溢出的出现，但是会出现更多的逻辑门，而且每次进位都要一些时间，而计算是串行的，所以消耗的时间也越长，到如今的每秒几十亿次运算时就会造成影响，所以现代计算机用的加法电路有所不同，称为<strong>超前进位加法器（Carry-Look-Ahead Adder）。</strong></p><p><strong>ALU通常支持以下操作：</strong>加法、带进位的加法、减法、带借位的减法、取反、增1、减1、数字无改变通过。这些操作也是由逻辑门构成的。<strong>注意：</strong>简单的ALU并==不==支持乘法，而是把乘法用多次加法来实现，而更好的处理器有专门做乘法的算数单元。</p><h2 id="2）逻辑单元"><a href="#2）逻辑单元" class="headerlink" title="2）逻辑单元"></a>2）逻辑单元</h2><p><strong>逻辑单元：</strong>执行逻辑操作，比如AND、OR和NOT操作，也能做简单的数值测试，比如数字是不是负数。</p><p>对整个8位ALU进行抽象，用一个特殊的V形符号进行表示。其中有两个<strong>8位输入</strong>，并且有一个4位<strong>操作码（Operation Code）</strong>来告诉ALU对输入执行什么操作，比如1000表示加法命令，1100表示减法命令，然后有一个<strong>8位输出</strong>。同时ALU会输出一系列1位<strong>标志（FLAG）</strong>，来表示特定状态，比如我们可以计算A-B，然后通过ZERO来判断结果是否为零来判断A与B是否相等，通过NEGATIVE来判断A是否小于B；然后OVERFLOW连接到加法器的进位，来判断是否出现溢出。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-324be370be80687e69aeb12d8173dccd_hd.jpg" alt="img"></p><hr><h1 id="6、寄存器-amp-内存"><a href="#6、寄存器-amp-内存" class="headerlink" title="6、寄存器&amp;内存"></a>6、寄存器&amp;内存</h1><p>上节中介绍的ALU进行计算后得到的结果需要对其进行存储，可能还要进行多个连续操作，这就需要用到计算机内存了。计算机使用的是<strong>随机存取存储器（Random Access Memory, RAM）</strong>，其只能在<u>有电</u>的情况下存储东西。另一种存储称为<strong>持久存储（Persistent Memory）</strong>，电源关闭时数据也不会丢失，它用来存其他东西。</p><blockquote><p>随机存取存储器(RAM)：只能在有电的时候存储东西。【 <strong>内存</strong>的一个重要特性：可以随时访问任何位置。所以叫“<strong>随机存取存储器(RAM)</strong>”】</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213205406365.png" alt="image-20200213205406365"></p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212233032303.png" alt="image-20200212233032303">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212233049692.png" alt="image-20200212233049692">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212233107576.png" alt="image-20200212233107576"></p></blockquote><p>放入数据的动作叫“<strong>写入</strong>”，拿出数据的动作叫“<strong>读取</strong>”。</p><p>这一节中首先构建能够存储1位的存储器，然后对其扩展来得到内存模块。</p><p>之前构建的都是单向电路，我们同样可以构建回向电路，把输出连回输入。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-81c6dd82241ba3a7de60809922f4e8f7_hd.jpg" alt="img"></p><blockquote><p>1、当将OR门构建成回向电路时，可以分析其电路特性：</p><ul><li>A和B初始为0时，输出结果为0</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://pic1.zhimg.com/80/v2-3dd54ae2c78016bfd6eba69be1f34e98_hd.jpg" alt="img"></p><center>存储0的电路</center>- 将A修改为1时，输出结果为1，此时B的输入就变为了1。随后输出始终保持为1，不论A如何变化。<p>所以这个电路能够永久记录1，并且无法将1变回0。</p><p>2、同理可以分析下AND门构建成回向电路时的特点</p><ul><li><p>A和B初始化为1，则输出结果为1</p></li><li><p>将A修改为0时，输出结果为0，此时B的输入就变成了0。随后输入始终保持为0，无论A如何变化。</p></li></ul><p>所以这个电路能够永久记录0，并且无法将0变回1。</p></blockquote><p>所以我们就得到了能够存储1和0的电路，为了得到有用的Memory，需要将两个电路结合起来，可以得到<strong>AND-OR锁存器（AND-OR Latch）</strong>，上方的是SET输入，下方的是RESET输入，当SET=1、RESET=0，就能将输出设置为1，当RESET=1，就能将输出设置为0，当SET=0、RESET=0，则输出最后放入的内容。由此能够存储1位的信息（该信息存储在OR门上方的输入电极中）！</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200220160959766.png" alt="image-20200220160959766"></p><p>这叫”锁存”, 因为它”锁定”了一个值，放入数据的动作叫 “写入” ，拿出数据的动作叫 “读取”。</p><p>对其进行SET和RESET进行合并，并添加其他门控单元，可以得到一个<strong>门锁（GATE LATCH）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212230438229.png" alt="image-20200212230438229"></p><center>门锁</center>其中DATE INPUT表示数据输入，WRITE ENABLE表示允许写入线，用来控制是否保存当前输入的数据。对这个电路进行分析。<p>可以将门锁进行<u>抽象</u>，得到一个能够存储<strong>一个bit</strong>的部件。当允许写入线为0时，输出保持不变，当允许写入线为1时，输出就是数据输入，并且能够将数据输入进行存储。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212230837936.png" alt="image-20200212230837936"></p><center>门锁的抽象</center>如果我们并排8个锁存器，就能存储8位信息。一组这样的锁存器称为**寄存器（Register）**，寄存器能够存一个数字，这个数字的位数称为寄存器的**位宽（Width）**。<p>写入寄存器之前，要先启动里面所有的锁存器，可以将所有锁存器的允许写入线都连接在一起，把它设为1，然后用8条数据线发送数据，然后将允许写入线设回0，就能将8位数据存储在寄存器中。</p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212231015481.png" alt="image-20200212231015481"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212231043071.png" alt="image-20200212231043071"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212231125590.png" alt="image-20200212231125590"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212231159981.png" alt="image-20200212231159981"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212231218808.png" alt="image-20200212231218808">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200212231232434.png" alt="image-20200212231232434"></p></blockquote><h2 id="寄存器："><a href="#寄存器：" class="headerlink" title="寄存器："></a>寄存器：</h2><p>上面是只能存储1bit的“<strong>锁存器</strong>”，如果我们并排放8个锁存器，就可以存8位(bits)信息。</p><p>一组这样的锁存器叫做“<strong>寄存器</strong>”。</p><p>1、<strong>位宽</strong></p><p>寄存器能存一个数字，这个数字有多少位，叫做“<strong>位宽</strong>”。</p><p>$早期电脑用8位寄存器，然后是16位、32位。如今都有64位宽的寄存器。$</p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213201814518.png" alt="image-20200213201814518">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213201940951.png" alt="image-20200213201940951">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213202116937.png" alt="image-20200213202116937">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213202136340.png" alt="image-20200213202136340"></p><p>所以，如64位的寄存器只需要129条线就可以了。【64条是“数据输入线”、“64条数据输出线”、“一条启用写入线”】。</p><p>如果要存256位，就需要513条线。减少线数的方法就是：<strong>矩阵</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213202534237.png" alt="image-20200213202534237">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213202641868.png" alt="image-20200213202641868"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213202711027.png" alt="image-20200213202711027"></p><p>所以，对于一个256位的存储：只需要35条。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213202942105.png" alt="image-20200213202942105">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213203005839.png" alt="image-20200213203005839"></p><p>如果想要访问特定的锁存器（即寻找其地址），（由于行数和列数均只有16，所以均可以用4个二进制位来表示。）就有行号和列号来对应。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213203515940.png" alt="image-20200213203515940">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213203551017.png" alt="image-20200213203551017">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213203634252.png" alt="image-20200213203634252">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213203648070.png" alt="image-20200213203648070"></p><blockquote><p><strong>多路复用器</strong>：有不同大小。通常包含一定数目的数据输入，有一个单独的输出。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213203948627.png" alt="image-20200213203948627"></p></blockquote><p>把256位内存当成一个整体，抽象化一下：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204207689.png" alt="image-20200213204207689">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204308742.png" alt="image-20200213204308742">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204324322.png" alt="image-20200213204324322"></p><p>一个256位内存也不能做什么大事，所以继续扩大：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204433307.png" alt="image-20200213204433307">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204508271.png" alt="image-20200213204508271">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204556045.png" alt="image-20200213204556045">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204731314.png" alt="image-20200213204731314">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204837880.png" alt="image-20200213204837880"></p><p>再次，看成一个整体：</p><p>下图中：我们有256个地址，每个地址能读或写一个8位(bit)的值。<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213204931499.png" alt="image-20200213204931499">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213205132085.png" alt="image-20200213205132085">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213205150693.png" alt="image-20200213205150693">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213205208450.png" alt="image-20200213205208450">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213205234980.png" alt="image-20200213205234980">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200213205253990.png" alt="image-20200213205253990"></p></blockquote><p>这一节用锁存器做了一块<strong>静态随机存取存储器（Static Random-Access Memory，SRAM）</strong>，还有很多其他类型的RAM，比如DRAM、闪存和NVRAM，它们的功能和SRAM相似，但是使用不同的电路存放单个位。但是根本上，这些技术都是矩阵层层嵌套来存储大量信息。</p><h1 id="7、中央处理器-CPU"><a href="#7、中央处理器-CPU" class="headerlink" title="7、中央处理器(CPU)"></a>7、中央处理器(CPU)</h1><p>CPU负责执行程序，程序由一个个操作组成，这些操作叫“指令(instruction)”。</p><p>如果是<strong>数学指令</strong>，比如加减，CPU会让ALU进行数学运算。如果是<strong>内存指令</strong>，CPU会和内存通信，然后读写值。</p><h1 id="9、高级CPU设计"><a href="#9、高级CPU设计" class="headerlink" title="9、高级CPU设计"></a>9、高级CPU设计</h1><p>RAM是CPU之外的独立组件，意味着数据要用线来传递，这个线叫做“<strong>总线（BUS）</strong>”。</p><p>$总线可能只有几厘米，虽然电信号传输速度接近光速，但是CPU每秒可以处理上亿条指令，很小的延迟也会造成问题。$</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214194800104.png" alt="image-20200214194800104">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214195130456.png" alt="image-20200214195130456"></p><h2 id="提升性能方法一：缓存"><a href="#提升性能方法一：缓存" class="headerlink" title="提升性能方法一：缓存"></a>提升性能方法一：缓存</h2><p>一条“从内存读数据”的指令可能需要多个时钟周期，而此时CPU空等数据。解决延迟的方法之一是给CPU加一点RAM,叫：“<strong>缓存(Cache)</strong>”。因为处理器的空间不大，所以缓存一般只有KB或MB，而RAM都是GB起步。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214195534052.png" alt="image-20200214195534052"></p><p>缓存提高了速度：当CPU从RAM拿数据时，RAM不用传一个，可以传一批。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214195800275.png" alt="image-20200214195800275"></p><p>虽然花的时间多一点，但数据可以存在缓存。这很实用，因为数据常常是一个个按顺序处理。比如：算餐厅的当日收入时，先取RAM地址为100 的交易额，RAM与其只给一个值，不如直接给一批值，把地址为100~200的数据都复制到缓存中。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214200104046.png" alt="image-20200214200104046"></p><p>当处理器要下一个交易额（地址为101的）时，缓存就会告诉处理器：“我已经有这个数据了，现在就给你”。就不用再去RAM取数据了。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214200354398.png" alt="image-20200214200354398">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214200419065.png" alt="image-20200214200419065"></p><p>当想要的数据已经在缓存中时，这种状态叫“<strong>缓存命中</strong>（Cache Hit）”；如果不在，则叫“<strong>缓存未命中（Cache Miss）</strong>”。</p><p>缓存也可以当临时空间，存一些中间值，适合长的或者复杂的运算。继续餐馆的例子：假设CPU算完了一天的销售额，想把结果存到地址为150的地方。就像之前，数据不是直接存到RAM中，而是存在缓存中。这样不但存起来快一些、如果还要接着计算，取值也会快一些。</p><p>但是这会导致：缓存和RAM中的数据不一致。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214201154364.png" alt="image-20200214201154364"></p><p>因此缓存里每块空间有一个特殊标记，叫：“<strong>脏位（Dirty Bit）</strong>”。</p><p>同步一般发生在：当缓存满了而CPU又需要缓存的时候。在清理缓存腾出空间之前，会先检查“脏位”，如果是“脏”的话，在加载新内容之前，会把数据写回RAM。</p><p>![演示 (3)](<a href="https://longlongqin.gitee.io/image_save/images/assets/演示" target="_blank" rel="noopener">https://longlongqin.gitee.io/image_save/images/assets/演示</a> (3).gif)</p><h2 id="提升性能方法二：“指令流水线”"><a href="#提升性能方法二：“指令流水线”" class="headerlink" title="提升性能方法二：“指令流水线”"></a>提升性能方法二：“指令流水线”</h2><blockquote><p>指令流水线：instruction pipelining</p></blockquote><p>例如：如果你想要洗一整个的床单，但只有一个洗衣机和一个烘干机。</p><blockquote><p>选择一：按顺序，先放洗衣机洗30分钟，然后在烘干机30分钟。共计1小时。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214203334316.png" alt="image-20200214203334316"></p><p>选择二：像一中一样，先放一批床单到洗衣机30分钟，然后把它放到烘干机中。但是这时候要等30分钟才能烘干。此时，可以放另一批床单到 洗衣机（此时，洗衣机，烘干机在同时工作），依次，直到洗完所有床单。效率是一的2倍。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214203636909.png" alt="image-20200214203636909"></p></blockquote><p>处理器也可以这样设计，CPU是按顺序处理的：<strong>(读)取指(令)——&gt;解码——&gt;执行</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214203831692.png" alt="image-20200214203831692"></p><p>不断重复：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214203857837.png" alt="image-20200214203857837"></p><p>但是每个阶段都是用的CPU的不同部分，意味着可以并行处理：“执行”一个指令时，同时“解码”下一个指令，同时，“读取”下下条指令。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214204249010.png" alt="image-20200214204249010"></p><p>这样的流水线，每一个时钟周期执行1个指令，吞吐量乘3.</p><p>但是，和缓存一样，这也会带来一些问题：</p><blockquote><p>问题1：指令之间的依赖关系。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214204538900.png" alt="image-20200214204538900">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214204559995.png" alt="image-20200214204559995"></p><p>因此流水线处理器，要先弄清楚<em>数据依赖性</em>。必要时停止流水线，避免出问题。高端的CPU，会最小化流水线的停工时间，这叫“<strong>乱序执行</strong>”。</p><p>问题二：“条件跳转”，比如之前的JUMP NEGATIVE（类似循环跳转）。这些指令会改变程序的执行流。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205017629.png" alt="image-20200214205017629">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205037500.png" alt="image-20200214205037500"></p><p>空等会造成延迟。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205050629.png" alt="image-20200214205050629"></p><p>​ 技巧：“<strong>推测执行</strong>”</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205158772.png" alt="image-20200214205158772">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205214800.png" alt="image-20200214205214800">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205239401.png" alt="image-20200214205239401"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205303755.png" alt="image-20200214205303755">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205314350.png" alt="image-20200214205314350">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205323242.png" alt="image-20200214205323242">)<img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205340699.png" alt="image-20200214205340699"></p><p>为了尽可能减少清空流水线的次数，CPU厂商开发复杂的方法：“<strong>分支预测</strong>”。现在这种猜测的正确率超过90%。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205504704.png" alt="image-20200214205504704"></p><p>在理想情况下，CPU在一个时钟周期完成一个指令。但是“<strong>超标量处理器</strong>”的出现，一个时钟周期可以完成多个指令。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200214205918942.png" alt="image-20200214205918942"></p><p>用“<strong>多核处理器</strong>”【双核、四核处理器：意思是一个CPU芯片里，有多个独立的处理单元，”看起来就像有多个独立的CPU”。但因为他们整合紧密，可以共享一些资源如，缓存，使得多核可以合作运算。】。当多核不够时，可以用多个CPU。</p></blockquote><h1 id="10、早期的计算机编程"><a href="#10、早期的计算机编程" class="headerlink" title="10、早期的计算机编程"></a>10、早期的计算机编程</h1><p>​ 之前的程序是用<strong>插线板</strong>编程，到后来（1940年代晚期到1950年代初）<strong>内存</strong>的价格下降，容量上升，使得程序存入内存变得可行。程序存入内存中易于修改、方便CPU快速读取，这类机器叫做：“<strong>存储程序计算机（Stored-program Computers）</strong>”。内存足够时，还可以存储程序需要的数据（包括运行时产生的数据）。这种将程序和数据存储在一起的存储结构，叫“<strong>冯诺依曼结构</strong>”。</p><p>​ 冯诺依曼计算机的标志是，一个处理器（有算数逻辑单元）+数据寄存器+指令寄存器+指令地址寄存器+内存（负责存数据和指令）。</p><h1 id="11、编程语言发展史"><a href="#11、编程语言发展史" class="headerlink" title="11、编程语言发展史"></a>11、编程语言发展史</h1><p>​ 计算机只能处理二进制，其实，“<strong>机器语言（Machine Language）</strong>”或“<strong>机器码（Machine Code）</strong>”。在计算机早起，还必须要用机器码 些好吃呢供需，一般会先对程序进行高层次的功能描述，称为“<strong>伪代码（Pseudo-code）</strong>”，只是助于程序员理解无法让计算机运行，然后根据指令表将伪代码转换成二进制机器码，然后将机器码送入计算机中运行。</p><p>​ 在1940-1950年，程序员开发出一种新语言，更可读、更高层次，每个操作码分配一个简单名字，称为<strong>助记符（Mnemonics）</strong>，助记符后跟数据，形成完整的指令。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200215202238984.png" alt="image-20200215202238984"></p><p>所以与其写0和1的机器码，程序员可以直接写“LOAD_A 14”，这个语言称为<strong>汇编语言（Assembly Language）</strong>。当然计算机无法理解“LOAD_A 14”，所以程序员们写了一个程序来将文字指令自动转换成二进制指令，这个程序称为<strong>汇编器（Assembler）</strong>，$汇编器读取汇编语言写的程序，然后转换成机器码$。</p><p>随着发展，汇编器有越来越多的功能使得编程更加容易，其中一个功能就是自动分析JUMP地址。如下图，JUMP后面跟的是内存中的真实地址，如果我们在上方对程序进行修改，则后面的所有地址都会改变。所以<u>汇编器不用固定跳转地址</u>，而是让你插入可跳转的标签，当程序传入汇编器，汇编器就会自己推算出跳转地址，这样就程序员就无序过分关注细节。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-c044bd0bbaf2c1bc95398ca38ea36153_hd.jpg" alt="img"></p><p>​ $汇编代码例子$</p><p>汇编只是修饰了一下机器码，一般来说，<u>一条汇编指令对应一条机器指令</u>，所以汇编码和底层硬件连接很密切，程序员仍需要思考使用什么寄存器和内存地址。为了释放电脑的潜力，霍普设计了一个高级编程语言，叫做Arithmetic Language Version 0，简称A0。一行高级编程语言，可能会转换成几十条二进制指令。为此做到这种复杂转换，霍普在1952年创造了第一个<strong>编译器（Compiler）</strong>，编译器专门把高级语言转换成低级语言（比如汇编 或 机器码）。由此，高级编程语言就不用管寄存器或内存位置，编译器会解决这些细节。</p><p>在1950年，大多数编程语言和编译器只能运行在一种计算机中，如果更换计算机，就要重写所有代码，因此1959年开发一种通用编程语言，可以在不同机器上通用，最后诞生了一门高级、易于使用的语言<strong>普通面向商业语言（Common Business-Oriented Language，COBOL）</strong>。为了兼容不同底层硬件，每个计算机架构需要一个COBOL编译器，由此无论运行的计算机是什么，这些编译器可以接收相同的COBOL代码。如今大多数编程语言都是如此，不必接触CPU特有的汇编码和机器码。</p><h1 id="12、编程原理-语句和函数"><a href="#12、编程原理-语句和函数" class="headerlink" title="12、编程原理-语句和函数"></a>12、编程原理-语句和函数</h1><p><code>a=5;</code>是一个编程语言的<strong>语句</strong>。</p><p>程序由一个个指令组成。</p><h1 id="13、算法入门"><a href="#13、算法入门" class="headerlink" title="13、算法入门"></a>13、算法入门</h1><p><strong>算法</strong>：<strong>解决问题的具体步骤。</strong></p><h1 id="14、数据结构"><a href="#14、数据结构" class="headerlink" title="14、数据结构"></a>14、数据结构</h1><p>数据是以什么形式存在内存里呢？<strong>我们希望数据是结构化的，方便读取</strong>，由此发明了数据结构。</p><h2 id="14-1-数组Array"><a href="#14-1-数组Array" class="headerlink" title="14.1 数组Array"></a>14.1 数组Array</h2><p>一个变量只能存储一个值，而一个数组变量能够保存多个同类型值，并且数组的值是一个个连续存在内存中的。</p><p>为了取出数组中的某个值，我们需要指定一个<strong>下标（Index）</strong>。大多数编程语言中，数组的下标都从0开始。下图是数组保存在内存中的形式，为了简单，假设编译器从内存地址1000开始保存数组，数组中的内容就像图中那样顺序保存在内存中。定义该数组变量为<code>j</code>，则<code>j[0]</code>会取内存地址1000的数据来获得第一个元素的值， <code>j[5]</code> 则会去内存地址1000加5个偏移量得到内存地址1005中保存的数据。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-05e5d5a5004692369a9475bf3d6f886a_hd.jpg" alt="img"></p><p><strong>缺点：</strong>创建数组时就要固定大小，不能动态增加大小，并且数组在内存中是按顺序存储的，在中间插入一个值很困难。</p><h3 id="14-2-字符串String"><a href="#14-2-字符串String" class="headerlink" title="14.2 字符串String"></a>14.2 字符串String</h3><p>类似于数组，其实就是字母、数字、标点符号等构成的数组。我们在第4节中有讨论了计算机怎么存储字符的，通过ASCII或者Unicode编码，将字符转换为对应的二进制数。</p><p>写代码时，可以直接用引号括起来构建字符串<code>j=&quot;Hello World&quot;</code>， 其在内存中的存储形式如下图。<strong>注意：</strong>字符串在内存中以<strong>二进制0</strong>结尾，表示字符串结尾，用来给别的函数指示什么时候字符串结束了。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-b8b2ba66353be16cf7a7c96f744c9879_hd.jpg" alt="img"></p><h3 id="14-3-矩阵Matrix"><a href="#14-3-矩阵Matrix" class="headerlink" title="14.3 矩阵Matrix"></a>14.3 矩阵Matrix</h3><p>之前保存的都是一维数组，但是像电子表格或屏幕像素，都需要保存二维信息，所以这里就需要用到矩阵。</p><p>可以将矩阵看成是数组的数组，比如一个3x3矩阵， 相当于就是一个长度为3的数组，而这个数组中的每个元素又是一个长度为3的数组。矩阵保存在内存中的形式如下图所示，这里使用的是<u>行优先存储</u>，即优先将矩阵的每一行保存在内存的相邻位置，当一行保存完后，再保存下一行。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-45786350b76ab13bf59f20d2d2a0f432_hd.jpg" alt="img"></p><center>矩阵例子</center>![img](https://longlongqin.gitee.io/image_save/images/assets/v2-f4e8c5b992abea5477f71fcf39702a68_hd.jpg)<center>内存中的矩阵</center>为了获取一个值，需要两个小标，比如`j[2][1]`表示从内存地址1000偏移`2*3+1=7`位置，得到元素12。这里偏移量的计算方法是`行索引*列元素个数+列索引`。<p>我们不仅能构建二维矩阵，我们可以构建任意维度的矩阵。</p><h3 id="14-4-结构体Struct"><a href="#14-4-结构体Struct" class="headerlink" title="14.4 结构体Struct"></a>14.4 结构体Struct</h3><p>目前我们只将单个数字或字符存在数组或矩阵中，在数组中保存的都是相同类型的元素。<u>如果我们想把几个有关系的变量存储在一起，并且这些变量都是不同类型的</u>，我们就需要用到结构体。</p><p>…..</p><h1 id="16、软件工程"><a href="#16、软件工程" class="headerlink" title="16、软件工程"></a>16、软件工程</h1><p>为了写大型程序，程序员用各种工具和方法，所有这些形成了软件工程学科。</p><p>将大项目分解成小<strong>函数</strong>可以让很多人同时工作，由此他们无需关心整个项目，只要关心自己的函数就好了。</p><p>但是这种抽象程度还是不够，大型项目中可能还是会存在大量的函数，因此需要将函数打包成层级，将相关代码放在一起，打包成<strong>对象（Object）</strong>。比如汽车软件中，可能有几个和定速巡航有关的函数，因此我们可以包装一个“定速巡航对象”来打包这些函数，我们还可以更进一步，“定速巡航”只是引擎软件的一部分，可能还有“火花塞点火”、“燃油泵”和“散热器”等等，因此我们可以做一个“引擎对象”来打包所有子对象，并且除了子对象，引擎对象还会包含自己的函数，比如“开关引擎”，也会有自己的变量，比如汽车行驶里程数。总的来说，对象可以包含其他对象、函数和变量。然后当你想调用一个比较底层对象的函数时，只需要层层向下调用就行，比如<code>Car.Engine.CruiseControl.setCruiseSpeed(55)</code>。这种将函数打包成对象的思想称为<strong>面向对象编程（Object Oriented Programming）</strong>。相同的想法都是通过封装组件来隐藏复杂度。</p><p>把大型软件拆成一个个更小单元，会更适合团队合作。但是各个团队之间的代码是相互交织的，比如团队A实现的某个函数需要团队B的代码支持，因此团队需要<strong>文档（Documentation）</strong>来帮助理解代码都做什么，以及定义好的<strong>程序编程接口（Application Programming Interface，API）</strong>。这样，即使程序员不知道具体的实现细节，也能直接使用API调用相应的函数。并且API能控制哪些函数和数据是对外开放的，哪些是仅供对象内部使用的，面向对象的编程语言可以指定函数时<code>public</code>或<code>private</code>来设置权限，避免用户调用错了函数造成bug。如果标志为private，表示只有同一个对象内的其他函数能调用它， 所以在这个例子中，只有内部函数比如<code>setRPM</code>能够调用 <code>fireSparkPlug</code>函数，并且由于<code>setRPM</code>函数是public的，所以其他对象可以调用它。</p><blockquote><p><strong>面向对象编程的核心：</strong>隐藏复杂度，选择性的公布功能。</p></blockquote><p>现代软件开发者会使用专门的工具来写代码，工具里集成了很多功能帮助写代码、整理、编译和测试，这些软件称为<strong>集成开发环境（Integrated Development Environments，IDE）</strong>。</p><p>程序员一个重要的工作部分是给代码写文档，一般放在一个叫<code>README</code>的文件中， 文档也能直接写成注释放在源代码中。</p><p>除了IDE，还有一个重要软件帮助团队协作，称为<strong>源代码管理（Source Control）</strong>。比较大型的公司会将代码放在一个中心服务器上，称为<strong>代码仓库（Code Repository）</strong>。当程序员想改一段代码时，可以check out获得代码，然后开发者在自己电脑上编辑代码，当代码没有问题，所有测试都通过时，就能将代码放回代码仓库了，称为<strong>提交（Commit）</strong>。当代码被check out，并且可能被改过了，其他开发者就不会动这段代码，避免代码冲突和重复劳动。代码的主版本（master）应该总是编译正常，尽可能少bug。并且源代码管理可以跟踪所有变化，当出现bug时，全部或部分代码可以<strong>回滚（Rolled Back）</strong>到之前的稳定版本，并且也能记录下代码修改者。</p><p>测试代码一般由个人或小团队完成，测试可统称为<strong>质量保证测试（Quality Assurance Testing，QA）</strong>。<strong>“alpha version”</strong>软件一般很粗糙，错误很多，经常只在公司内部操作，而<strong>“beta version”</strong>软件指的是软件接近完成，但不是完全测试通过，公司有时会向公众发布beta版，以帮助发现问题，用户就像免费的QA团队。</p><h1 id="17、集成电路-amp-摩尔定律"><a href="#17、集成电路-amp-摩尔定律" class="headerlink" title="17、集成电路&amp;摩尔定律"></a>17、集成电路&amp;摩尔定律</h1><p>过去计算机的飞速发展，强烈依赖于硬件的发展。</p><p>大约1940年代-1960年代中期，计算机都由独立部件组成，称为<strong>分立元件（Discrete Components）</strong>，然后不同组件再用线连在一起。比如ENIAC有1万7千多个真空管，7万个电阻，1万个电容，7千个二极管，5百万个手工焊点。如果想要提升性能，就要加更多部件，这就导致了更多更复杂的电线，这个称为<strong>数字暴政（Tyranny of Numbers）</strong>问题。</p><p>到1950年代中期，晶体管开始商业化，开始用于计算机中，晶体管比电子管更小更快更可靠，但晶体管依然是分立元件。1959年，IBM把709计算机从原本的电子管全部换成晶体管，诞生了IBM 7090，速度快6倍，价格只有一半。晶体管标志着计算机2.0时代的到来，但是晶体管的出现还是没有解决数字暴政的问题，有十几万个独立元件的计算机不但难设计，而且难生产。</p><h2 id="集成电路（Integrated-Circuits，IC）："><a href="#集成电路（Integrated-Circuits，IC）：" class="headerlink" title="集成电路（Integrated Circuits，IC）："></a>集成电路（Integrated Circuits，IC）：</h2><p>到1960年代，这个问题的严重性达到顶点，解决方法就是引入一层新抽象，封装复杂性。突破性进展在1958年，与其把多个独立部件用电线连起来，拼装出计算机，我们把多个组件包在一起，变成一个新的独立组件，这个称为<strong>集成电路（Integrated Circuits，IC）</strong>。几个月后，仙童半导体就让集成电路变成现实，之前使用锗来做集成电路，但是锗很稀少且不稳定，仙童半导体使用<strong>硅</strong>，因为硅的蕴藏量丰富，也更稳定可靠。</p><p>起初，一个IC只有几个晶体管，但是也足以将逻辑门封装成独立组件，可以组合出无数种设计，但是最终还是要连起来，创造出更大更复杂的电路，比如计算机。所以创造出了<strong>印刷电路板（Printed Circuit Boards，PCB）</strong>，可以大规模生产，无需焊接或用一堆线，它通过蚀刻金属线的方式将零件连接到一起。把PCB和IC结合使用，可以大幅减少独立组件和电线，但做到相同的功能，而且更小更便宜更可靠。</p><p>不过即使组件再小，塞5个以上的晶体管还是很困难，为了实现更复杂设计，出现了全新的制作工艺——<strong>光刻（Photolithography）</strong>。简单来说，就是用光把复杂图案印到材料上，比如半导体。它只有几个基础操作，但是可以制作出复杂电路。</p><blockquote><ul><li>首先，我们从一片硅开始，称为<strong>晶圆（Wafer）</strong>，长得和薄饼干一样。并且硅是半导体，有时导电有时不导电，我们就可以控制导电时机，所以硅是做晶体管的绝佳材料。我们可以用晶圆做基础，把复杂金属电路放上去，来集成所有东西。</li><li>在硅片顶部加一层薄薄的<strong>氧化层（Oxide Layer）</strong>作为保护层，然后加一层特殊化学品称为<strong>光刻胶（Photoresist）</strong>，光刻胶被光照射后，就变得可溶，可以用一种特殊化学药剂洗掉。然后我们会在光刻胶上加一层<strong>光掩膜（Photomask）</strong>，当用强光照射时，挡住光的部分光刻胶就不会变化，而光照射到的地方，光刻胶就会发生化学变化，洗掉变化的光刻胶后，就会暴露出部分氧化层。然后通常用酸能洗掉氧化层暴露出的部分，就能蚀刻到硅层。然后再用另一种化学试剂清洗掉剩余的光刻胶，这样只剩下氧化层和晶圆了。我们想修改硅暴露出来的区域，让它们导电性更好，所以我们使用<strong>掺杂（Doping）</strong>，通过将磷渗透进暴露的硅，来改变电学性质。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-43b8796ff46c3bf12da90361caf3a74b_hd.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-b19ae3a9f85fb157495ee4a2a986c4b1_hd.jpg" alt="img"></p><ul><li>我们还需要几轮光刻法来做晶体管。还是叠加上氧化层、光刻胶和新的光掩膜，这样就能在掺杂区域上方开缺口，然后进行清洗蚀刻，再用另一种元素进行掺杂，把硅转换成另一种形式。为了控制深度，时机很重要，不要超过之前掺杂的区域，这样所有需要的组件都有了。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-0261b1e130471a85ebaea8f5df038bab_hd.jpg" alt="img"></p><ul><li>最后，在氧化层上做通道，这样可以用细小金属导线连接不同晶体管。首先用光刻胶和光掩膜，在氧化层上蚀刻出小通道。然后用新的处理方法称为<strong>金属化（Metalization）</strong>，在氧化层上放一层薄薄的金属，比如铝或铜，再加上光刻胶和光掩膜，然后融掉暴露的光刻胶，暴露出金属。最终清洗，只保留晶圆、氧化层和金属化，这样就做出了一个晶体管。它有三根线分别连接着硅的三个不同区域，每个区域的掺杂方式不同，这个叫<strong>双极型晶体管（Bipolar Junction Transistor）</strong>。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-b2d6dce62f3352d950dc12e238fc0099_hd.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-f099fd3eea9861f0ef822f76299e616c_hd.jpg" alt="img"></p><center>晶体管</center></blockquote><p>相同方法，光刻可以在一片硅上制作其他电子元件，比如电阻电容，而且相互连接的电路也做好了。</p><p><strong>并且通过调节光掩膜和光源之间的距离</strong>，光可以投射成任意角度，我们可以把光掩膜聚焦到极小的区域，制作出非常精细的细节，这样一片晶圆就能做出很多IC，整块都做完后，就可以切割然后包进微型芯片中，芯片的核心都是一小片IC。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-77dbe69c1ca5bcacd2c735dccfe11c7a_hd.jpg" alt="img"></p><p>随着光刻技术发展，晶体管变小，密度变高。1960年初，IC很少能超过5个晶体管，但到了1960年中期，市场上已经开始出现超过100个晶体管的IC。</p><h2 id="摩尔定律（Moore’s-Law）"><a href="#摩尔定律（Moore’s-Law）" class="headerlink" title="摩尔定律（Moore’s Law）:"></a>摩尔定律（Moore’s Law）:</h2><p>1965年，戈登·摩尔看到了发展趋势，提出<strong>摩尔定律（Moore’s Law）</strong>：<strong>每两年左右，得益于材料和制造技术的发展，同样大小的空间，能塞进两倍量的晶体管。</strong></p><p>晶体管更小密度更高，要移动的电荷量就越少，能快速切换状态，耗电更少。并且电路更紧凑，意味着信号延迟更低，导致时钟速度更快。</p><p>集成电路的出现，尤其是用来做微处理器，开启了<strong>计算机3.0时代</strong>。</p><p>到了2010年，一个IC中有10亿个晶体管。为了达到这种密度，光刻的分辨率从大约一万纳米，发展到如今的14纳米。</p><p>现代工程师设计电路时，不是手工一个个设计晶体管的，从1970年代开始，<strong>超大规模集成（Very-large-scale Integration，VLSI）</strong>软件用来自动生成芯片设计。用比如<strong>逻辑综合（Logic Synthesis）</strong>可以放一整个高级组件，比如内存缓存，软件会自动生成电路，做到尽可能高效，许多人认为这是<strong>计算机4.0时代</strong>的开始。</p><p><u>但是摩尔定律现在迎来了终结，进一步做小，会迎来两个问题：</u></p><ol><li>用光掩膜把图案弄到晶圆上，因为光的波长，精度已经到达极限。所以科学家在研制波长更短的光源，投射更小的形状。</li><li>当晶体管非常小，电极之间可能只距离几个原子，电子就会跳过间隙，称为<strong>量子隧道贯穿（Quantum Tunneling）</strong>，由此晶体管就不能正常工作了。</li></ol><h1 id="18、操作系统"><a href="#18、操作系统" class="headerlink" title="18、操作系统"></a>18、操作系统</h1><p>40 50年代的电脑，每次只能运行一个程序，程序员在打孔纸上写程序，然后再放入计算机中进行计算，一开始计算机速度比较慢，通常一个程序需要运行几天时间，所以放程序的时间还能忍受。但是随着计算机运算速度的告诉发展后，放程序的时间比程序运行时间还要长，我们就需要一种方式，让计算机自动运行，于是诞生了<strong>操作系统（Operation Systems，OS）</strong>。</p><p><strong>操作系统其实也是程序</strong>，<u>但它有操作硬件的特殊权限，可以运行和管理其他程序</u>。操作系统一般是开机第一个启动的程序，然后其他所有程序都由操作系统启动。从1950年代开始有操作系统，那时计算机开始变得更加强大， 第一个操作系统主要加强了程序加载方式，取代了手工加载程序的过程。</p><p>之前只能一次给一个程序，现在可以一次多个程序，当计算机运行完一个程序后，就会自动运行下一个程序，这样就不用浪费时间找下一个程序的纸卡，这称为<strong>批处理（Batch Processing）</strong>。</p><p>随着计算机的发展，计算机出现在大学和政府办公室，人们开始分享软件，但是有个问题。在哈佛1号和ENIAC那个时代，计算都是一次性的，程序员只需要给特定一台机器写代码，其中处理器、读卡器和打印机都是已知并且不会改变的。但是随着计算机越来越普遍，计算机配置并不总是相同的，比如计算机可能有相同的CPU但是不同的打印机等等，这样程序员不仅要担心程序，还要担心程序怎么和不同型号的打印机进行交互，以及计算机连着的其他设备，统称为<strong>外部设备（Peripherals）</strong>。和早期的外部设备交互是非常底层的，程序员需要了解设备的硬件细节，但是程序员又很少能拿到所有型号的设备来测试代码。所以一般是阅读手册然后尽可能编写代码。</p><p>所以为了能够更好地写软件，<em>操作系统就充当软件和硬件之间的媒介</em>。更具体的，操作系统提供API来抽象硬件，叫<strong>设备驱动程序（Device Drivers）</strong>。这样程序员可以通过标准化机制和<strong>输入输出硬件（Input &amp; Output，I/O）</strong>进行交互，而无需关注硬件型号以及具体硬件细节。</p><p>到1950年代末尾，电脑已经运行非常快了，处理器经常需要等待较慢的机械设备（比如打印机和读卡器），程序就阻塞在I/O上，而处理器什么都没有进行处理。英国曼彻斯特大学开始研发世界上第一台超级计算机Atlas，由于机器运算非常快，所以需要一种方式来尽可能利用更多的算力。他们于1962年年设计了一个程序叫Atlas Supervisor，<u>使得操作系统不仅能进行批处理，并且通过<strong>调度（Scheduling）</strong>还能在单个CPU上同时运行几个程序。</u></p><blockquote><p>比如我们需要调用print函数让Atlas打印一个变量值，由于打印机比CPU慢很多，所以print函数需要运行比较长的时间。与其等待打印机完成打印，Atlas会将该程序进行休眠，然后运行其他等待的并且可运行的程序。最终当打印机打印完后，会报告给Atlas，则Atlas会将之前的程序标记为“可运行”状态，然后在某个时刻会安排给CPU继续运行print函数下一行代码。由此，Atlas能够在CPU上运行一个程序，同时另一个程序在打印数据（这里是让打印机自己在打印，所以无需CPU进行参与），同时另一个程序读数据（这里只需要使用读卡器，不需要CPU）。</p></blockquote><p>Atlas配有4台读取器、4台打印机和8个磁带驱动器。使多个程序可以同时运行，在单个CPU上共享时间。操作系统的这种能力称为<strong>多任务处理（Multitasking）</strong>。但是同时运行多个程序存在一个<strong>问题</strong>，每个程序都会占用一些内存，当切换到另一个程序后，我们不能丢失这些内存中的数据。<strong>所以我们给每个程序分配专属内存块</strong>，比如我们计算机一共有10000个内存地址，然后程序A分配到了0-999的内存地址，程序B分配到1000到1999，以此类推。如果一个程序请求更多内存，操作系统就会决定是否同意，如果同意，就要决定分配哪些内存块，这就使得程序A可能会分配到非连续的内存块，使得程序员能难进行跟踪。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-352e87bdb554469c2ed3a5c8a26956bf_hd.jpg" alt="img"></p><center>内存中程序分配</center>**处理分配的内存不连续的情况--动态内存分配**<p>$如果同意，就要决定分配哪些内存块，这就使得程序A可能会分配到非连续的内存块，使得程序员能难进行跟踪。$</p><p>为了隐藏这种复杂性，操作系统会把内存地址进行虚拟化，称为<strong>虚拟内存（Virtual Memory）</strong>。程序可以假定内存总是从地址0开始，而实际的物理位置，被操作系统隐藏和抽象了。以程序B为例，它分配了内存地址1000到1999，但是对于程序B而言，它能看到的地址是0到999，操作系统会自动处理虚拟内存和物理内存之间的映射，所以程序B要地址42，实际需要物理地址1042。对于程序A，它被分配了分散的物理内存块，但是程序A并不知道，它所能看到的是连续的从0到1999的地址，当程序A读内存地址999时，会被映射到物理地址999，而当程序A读内存地址1000，则会被映射到物理地址2000。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-ab782154333eb8168c2a4d3da20a9895_hd.jpg" alt="img"></p><center>虚拟内存例子</center>这种机制使得程序的内存大小可以灵活增减，称为**动态内存分配（Dynamic Memory Allocation）**。对程序而言，内存看起来是连续的，为操作系统同时运行多个程序提供了极大的灵活性，程序员只需要根据连续的虚拟内存地址进行编程，无需考虑程序在实际物理内存中不连续的物理内存块。<p>同时给每个程序分配一个专用的内存块，可以使得隔离起来更方便。如果一个程序出错了，在内存中胡乱写数据，它只能在自己分配的内存块中进行操作，不会影响到其他程序的数据，这个称为<strong>内存保护（Memory Protection）</strong>。这对于防止恶意软件是否有效。Atlas是第一台提供虚拟内存和内存保护功能的操作系统。</p><p>到1970年代，大学会购买电脑给学生使用，此时计算机不仅能同时运行多个程序，还能让多个用户同时访问。多个用户使用<strong>终端（Terminal）</strong>来访问计算机（这里的终端只有键盘和屏幕，然后连接到计算机），终端本身并不具有处理能力。这样计算机不仅要能处理多个程序，还要处理多个用户，为了确保其中一人不会占满计算机资源，开发了<strong>分时操作系统（Time-Sharing）</strong>，指的是每个用户只能用一小部分处理器、内存等，因为计算机很快，所以即使只有一小部分资源，也足以完成很多任务。</p><p>早期分时操作系统中，最有影响力的是1969年发布的Multics，它是第一个从设计时就考虑到安全性的操作系统。开发人员不希望恶意用户访问不该访问的数据，这使得操作系统的复杂度远超当时的平均水平，通常内存的一半都要用来运行操作系统，这种过度设计使得Multics未能获得商业成功。所以研究员们重新打造了一个操作系统Unix，他们想把操作系统分成两部分：</p><blockquote><ol><li>操作系统的核心功能，比如内存管理，多任务和输入输出处理，这个称为<strong>内核（Kernel）</strong>。</li><li>一些有用的工具，但是他们不是内核的一部分，比如程序和运行库。</li></ol></blockquote><p>紧凑的内核意味着功能没有之前那么全面。当内核出现崩溃时，Multics有很多操作来进行恢复，但是Unix是没有办法恢复的，会直接调用一个panic函数，最初只能无限循环打印panic。这种简单性意味着Unix可以再更便宜的硬件上运行。1971年发布之后，就有人写了不同编程语言的编译器，甚至文字处理器，使得Unix迅速成为1970-80年代最流行的操作系统之一。</p><p>到1980年代早期，个人电脑逐渐出现，这些电脑比大型主机简单很多，主机一般在大学、公司和政府，因此操作系统也要变得简单。于1981年微软发布的磁盘操作系统MS-DOS只有160kb，虽然缺少多任务和保护内存这样的功能，意味着程序经常使系统崩溃，用户可以直接重启。即使在1985年发布的早期windos，也一样缺少内存保护功能，当程序错误时，就会出现蓝屏。</p><p>现代的操作系统包含了<strong>多任务</strong>、<strong>虚拟内存</strong>和<strong>内存保护机制</strong>，因此可以同时运行多个程序。</p><h1 id="19、内存-amp-存储介质"><a href="#19、内存-amp-存储介质" class="headerlink" title="19、内存&amp;存储介质"></a>19、内存&amp;存储介质</h1><p>一般来说，电脑<strong>内存</strong>是<strong>非永久性的（Non-Permanent）</strong>，如果电脑关机，则内存中的所有数据都会丢弃，所以内存叫<strong>易失性存储器（Volatile Memory）</strong>，还存在另一种<strong>存储器（Storage）</strong>，存储器（storage）和内存（memory）存在一定的不同。任何写入storage的数据，就会一直保存，直到被覆盖或删除，断点也不会丢失，称为<strong>非易失性（Non-volatile）</strong>。过去是易失性的速度快，非易失性的速度慢，但随着技术发展，两者的差异越来越小。</p><p>最早的存储介质是打孔纸卡以及打孔纸带，到1940年代，纸卡标准是80列x12行，能够存储960位数据。纸卡用了十几年，因为不用电而且便宜耐用，但是读取速度较慢，只能写入一次，对于存临时值，纸卡不好用，我们需要更大更灵活的存储方式。</p><h2 id="延迟线存储器："><a href="#延迟线存储器：" class="headerlink" title="延迟线存储器："></a>延迟线存储器：</h2><p>1944年时，出现了<strong>延迟线存储器（Delay Line Memory）</strong>。<strong>原理</strong>：假设你有一个装满液体（如水银）的管子，管子一端放着扬声器，另一端放着麦克风，当扬声器发出脉冲时，就会在管子内产生压力波，经过一段时间后压力波会传递到麦克风，然后麦克风将压力波转换为电信号，通过在麦克风后面接一个<strong>放大器（AMPLIFIER）</strong>，然后连回扬声器，我们就能用压力波的传播延迟来存储数据。假设有压力波代表1，没有代表0，扬声器发出一系列压力波，因为传播延时的原因，这些压力波会存在管子内，当撞击到麦克风后，又会通过扬声器重新回到管子，所以就能将数据保存在管子内。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200222172929235.png" alt="image-20200222172929235"></p><p>在1949年的EDVAC计算机中使用了延迟线存储器，总共有128条延迟线，每条能存352位，一共能保存45000位。这使得EDVAC成为最早的<strong>存储程序计算机</strong>之一。</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>但延迟线存储器的<strong>缺点</strong>是，每个时刻只能读一位数据，如果想访问一个特定的位，就要等待它从循环中出现，所以又被称为<strong>顺序存储器Sequential Memory）</strong>或者<strong>循环存储器（Cyclic-Access Memory）</strong>。而我们想要<strong>随机存取存储器（Random Access Memory）</strong>，可以随时访问任何位置。并且增加内存密度也是一个挑战，如果要将压力波变得更紧密，就会使其混在一起，所以出现了其他类型的延迟线存储器，比如<strong>磁致伸缩延迟存储器（Magnetostrictive Delay Lines）</strong>，它通过金属线的振动来代表数据。</p><h2 id="磁芯存储器："><a href="#磁芯存储器：" class="headerlink" title="磁芯存储器："></a>磁芯存储器：</h2><p>但是延迟线存储器在1950年代中期就过时了。因为出现了新技术，于是出现了，<strong>磁芯存储器（Magnetic Core Memory）</strong>，它用了环状磁圈，如果给磁芯绕上电线并施加电流，就能将其磁化在一个方向，如果关掉电流，磁芯还会保持磁化，如果施加了相反方向的电流，则磁化方向会翻转。这样我们就能通过磁化方向来存储0和1，就能用来存储1位。通过将磁芯排列成网格状，有线路负责选择行和列，也有电线贯穿每个磁芯，用于读写1位。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-c8e58ebec8d54b77be564e81463cd7de_hd.jpg" alt="img"></p><center>磁芯存储器</center>如果要存的数据超过1bit，就需要把磁芯存储器排列成网格：<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200222173626986.png" alt="image-20200222173626986"></p><p>1953年麻省理工的Whirlwind1计算机第一次大规模使用磁芯内存，磁芯排列使用32x32，用了16块板子，大约能存储16000位。不像延迟线存储器，磁芯存储器能随时访问任何一位，因此从1950年代中期成为主流，流行了20多年，将存储成本从1美元1位降低到了1美分左右。</p><h2 id="磁带："><a href="#磁带：" class="headerlink" title="磁带："></a>磁带：</h2><p>到1951年，UNIVAC电脑推出了一种新存储——<strong>磁带（Magnetic Tape）</strong>。磁带是纤薄柔软的一长条卷在轴上的磁性带子，磁带可以在<strong>磁带驱动器</strong>内前后移动，里面有一个缠绕了电线的<strong>写头（Write Head）</strong>，通过电流来产生磁场，导致磁带的一小部分被磁化，电流方向决定了极性，代表1和0。同样还有一个读头（Read Head），可以非破坏地检测极性来确定数据。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-1d9ac11988c8c3e7e54dc2c032bc21a4_hd.jpg" alt="img"></p><h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><p>磁带的主要缺点是访问速度，磁带是连续的，必须倒带或快进到特定位置。</p><p>50 60年代出现了类似的技术<strong>磁鼓存储器（Magnetic Drum Memory）</strong>,有一个金属圆管，盖满了磁性材料来记录数据，圆管会持续旋转，周围有数十个读写头，等圆管转到了正确的位置，读写头就会读或写数据。</p><p>但到了1970年代磁鼓存储器就不再生产了，但是磁鼓导致了<strong>硬盘（Hard Disk Drives）</strong>的发展，磁盘的好处是薄，可以叠在一起来提供更多表面积来存储数据。要访问某个特定位，一个读写磁头会上下移动，找到正确的磁盘，然后磁头会滑进去，就和磁鼓存储器一样，磁盘也会高速旋转，所以读写头要等到正确的部分旋转过来，这个称为<strong>寻道时间（Seek Time）</strong>。</p><p>以下是<strong>内存层次结构（Memory Hierarchy）</strong>，有一小部分高速且昂贵的内存，一部分稍慢且相对便宜的内存，还有更慢且更便宜的内存，这种混合可以在成本和速度之间取得平衡。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200222174311987.png" alt="image-20200222174311987"></p><p>其次还有<strong>软盘（Floppy Disk）</strong>，除了磁盘是软的，其他都一样。</p><p>后面出现的<strong>光盘（Compact Disk，CD）</strong>以及DVD，它们不使用磁性来保存数据，而是使用表面的小坑来造成光的不同反射，通过光学传感器捕获并解码为1和0。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200222174429795.png" alt="image-20200222174429795"></p><center>光盘表面</center>如今成本下降了更多的存储技术在朝**固态（Solid State）**前进，**机械硬盘（hard disk drive，HDD）**被**固态硬盘（Solid State Drive，SSD）**逐渐代替。由于SSD没有机械活动部件，里面都是集成电路。因为不存在机械活动，所以磁头不用等磁盘旋转，所以固态速度快很多，但是仍然比RAM慢很多，<u>所以现代计算机仍然使用存储层次结构</u>。<h1 id="20、文件系统"><a href="#20、文件系统" class="headerlink" title="20、文件系统"></a>20、文件系统</h1><p>上一节中介绍的数据存储。存储器可以在断电状态下长时间存上万亿位，所以非常适合用来存一整块有关系的<u>数据</u>（或者称为<strong>文件（Files）</strong>），比如文本文件、音乐文件、照片和视频。这一节将讨论文件是什么以及计算机是怎么管理文件的。</p><p>随意排列文件的数据是没有问题的，但按格式排列会更好，这个称为<strong>文件格式（File Format）</strong>。</p><p>首先看一个最简单的文件格式——<strong>文本文件（Txt File，txt）</strong>。就像其他文件一样，文本文件只是一长串二进制数，可以通过ASCII编码将其解码成对应文本。</p><h2 id="波形文件："><a href="#波形文件：" class="headerlink" title="波形文件："></a>波形文件：</h2><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200223201711965.png" alt="image-20200223201711965"></p><center>波形文件（WAV）</center>**波形文件（Wave File，WAV）**用于存音频数据。在正确读取数据之前，我们需要知道一些信息比如码率，以及是单声道还是立体声，这种描述数据的数据称为**元数据（Meta Data）**。元数据保存在文件开头，在实际数据之前，因此也叫**文件头（Header）**。以下是WAV文件的前44个字节，有些部分会根据数据进行变化。<p>[^元数据]: <strong>元数据</strong>（<strong>Metadata</strong>），又称<strong>中介数据</strong>、<strong>中继数据</strong>，为描述<a href="https://baike.baidu.com/item/数据/5947370" target="_blank" rel="noopener">数据</a>的数据（data about data），主要是描述数据<a href="https://baike.baidu.com/item/属性/1405051" target="_blank" rel="noopener">属性</a>（property）的<a href="https://baike.baidu.com/item/信息/111163" target="_blank" rel="noopener">信息</a>，用来支持如指示存储位置、<a href="https://baike.baidu.com/item/历史/360" target="_blank" rel="noopener">历史</a>数据、<a href="https://baike.baidu.com/item/资源/9089683" target="_blank" rel="noopener">资源</a>查找、文件记录等功能。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200223201307602.png" alt="image-20200223201307602"></p><center>WAV格式的数据的元数据</center>而音频数据就紧跟在元数据之后，也是一长串二进制数，这些数字代表每秒捕获多次的声音幅度。麦克风首先会对声音进行每秒上千次采样，每次采样可以用一个数字表示，声压越高数字越大，称为**振幅(Amplitude)**，这就是WAV文件中存储的数据。播放声音时，扬声器就会产生相同的波形。<h2 id="位图-Bitmap"><a href="#位图-Bitmap" class="headerlink" title="位图(Bitmap)"></a>位图(Bitmap)</h2><p>再来谈谈<strong>位图</strong>，其后缀为bmp，用于保存图片。。计算机中，图片由多个<strong>像素(Pixel)</strong>方块组成，每个像素由三种颜色组成：红、绿、蓝，叫<strong>“加色三原色”</strong>，混合在一起能产生其他颜色。类似于WAV文件，BMP文件开头也是元数据，有图片宽度、图片高度和颜色深度等等。现在假设图片宽高均为4个像素，颜色深度为24，也就是8位(bit)红色、8位绿色和9位蓝色，则每个颜色有0-255程度，然后依次保存每个位置的三原色数值。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200223202632500.png" alt="image-20200223202632500"></p><center>位图的元数据</center>![image-20200223203327886](https://longlongqin.gitee.io/image_save/images/assets/image-20200223203327886.png)<center>位图的数据</center>通过以上例子，可以知道，文件底层都是二进制数，为了知道文件是什么，文件格式就十分重要。<h2 id="计算机如何存储文件："><a href="#计算机如何存储文件：" class="headerlink" title="计算机如何存储文件："></a>计算机如何存储文件：</h2><p>最简单存储多个文件的方法是将文件<strong>连续存储</strong>，但是这样怎么知道文件开头和结尾在哪呢？存储器并没有文件的概念，它只是用来存储大量二进制数。所以我们需要特殊文件来记录其他文件的位置，这里称为<strong>目录文件（Directory File）</strong>，它通常保存在存储器最开头，方便寻找。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-46682a86deaa95c83bba62ae802f8120_hd.png" alt="img"></p><center>storage</center>在目录文件中，存有其它所有文件的名字，格式为`文件名+点+扩展名`， 扩展名有助于得知文件类型。目录文件还保存了文件的元数据，比如创建时间、最后修改时间、文件所有者、是否能读写，最重要的是记录了文件起始位置和长度。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200223203721221.png" alt="image-20200223203721221"></p><center>目录文件</center>如果要添加、删除文件或者更改文件名，必须更新整个目录文件。<p>目录文件以及对目录文件的管理，是最基本的<strong>文件系统（File System）</strong>的例子，文件系统专门负责管理文件。刚刚的例子叫<strong>平面文件系统（Flat File System）</strong>，因为所有文件都在同一层次。存在一个<strong>缺点</strong>：当我们想要对中间文件增加数据时，就会覆盖后续文件的数据。所以现代文件系统会做两个处理：</p><ol><li>将空间划分成一块块，会出现一些<strong>预留空间（Slack Space）</strong>，可以方便改动。同时文件数据都对齐到了相同大小，可以方便管理。使用这种方案，目录文件就要记录文件在哪些块中。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200223204243036.png" alt="image-20200223204243036"></p><ol start="2"><li>拆分文件保存在多个块中。假设todo.txt文件中加了一些数据，使得文件太大无法存在一个块中，则文件系统会分配一个没使用的块来容纳额外的数据，<u>则目录文件对每个文件就会记录不止一个块，而是多个块</u>。通过分配块，文件就可以轻松增加减小。如果想要删除carrie.bmp，只要在目录文件中删除对应记录就行，让这一块空间变成可用的，这样就不需要进行擦除，只需要直接删除记录就行。<strong>在那一块被新数据覆盖之前，数据还是保存在原处的。所以恢复删除数据是有可能的。</strong></li></ol><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200223204550449.png" alt="image-20200223204550449"></p><p>当文件过大，保存在若干个块中，这个称为<strong>碎片（Fragmentation）</strong>，碎片是增删改文件导致的，无法避免，但是会造成性能下降。解决方法是通过<strong>碎片整理（Defragmentation）</strong>，计算机会将数据来回一定，排列成正确的顺序，就能很方便地进行读写。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200223204701481.png" alt="image-20200223204701481"></p><center>碎片整理前</center>![image-20200223204733889](https://longlongqin.gitee.io/image_save/images/assets/image-20200223204733889.png)<center>碎片整理后</center>随着容量爆炸式增长，文件数量飞速增加，平面文件系统逐渐应付不来，所以出现了**分层文件系统（Hirerarchical File System）**，这里最大的变化就是每个文件夹中都有一个目录文件，并且目录文件不仅要指向文件，还要指向目录，还需要增加额外的元数据来区分文件和目录。<p><strong>优点</strong>：这种文件系统不仅可以做出无限深的文件夹，也可以让我们很轻松地移动文件，我们不需要移动任何数据块，只需要在两个目录文件中删增记录就行。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200223204831349.png" alt="image-20200223204831349"></p><center>分层文件</center>文件系统使我们不必关心文件在磁盘中的具体位置。<h1 id="21、压缩"><a href="#21、压缩" class="headerlink" title="21、压缩"></a>21、压缩</h1><p>之前介绍了文件格式，如何编码文字、声音和图片，但是它们的效率并不高，我们希望文件能小一点，这样就能保存大量文件，同时传输也会快一些，解决方法就是<strong>压缩（Compression）</strong>，把数据占用的空间压得更小，为此我们需要用更少的bit来表示数据。</p><p>以压缩图片为例，图片一般存成一长串像素值，为了知道一行在哪里结束，图像要有元数据，写明尺寸等属性。每个像素的颜色是三原色的组合，每个颜色用一个字节保存，数字范围是0~255（一个字节=8 bits，2^8^=256），由此一张<code>4*4</code>（16个像素）大小的图像，其中每个像素3个字节。则这个图片需要<code>4*4*3=</code>48字节。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200226140325517.png" alt="image-20200226140325517"></p><p>—》存成一长串像素值：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/image-20200226151330368.png" alt="image-20200226151330368"></p><center>图片一般存成一长串像素值</center>![img](https://longlongqin.gitee.io/image_save/images/assets/v2-202fff7eae740ec4451258a92c96eda0_720w.jpg)<center>前五个像素的表示</center>## 无损压缩：<p>一种压缩方法是减少重复信息，最简单的方法叫<strong>游程编码（Run-Length Encoding）</strong>，适合经常出现相同值的文件。比如上图中有7个连续相同的黄色像素块，我们可以插入一个额外字节来表示7个连续黄色像素，然后删掉后面重复的数据。为了让计算机分辨哪些字节时长度，那些字节是颜色，格式需要保持一致，所以我们需要给所有像素前面都标上长度。在这个例子中现在只需要24个字节，并且不损失任何信息。这个方法称为<strong>无损压缩（Lossless Compression）</strong>，没有丢失任何数据。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-315b1a99dd4902cb5d8a9c9d7a81cde1_720w.png" alt="img"></p><center>游程编码</center>另一种无损压缩方法叫做**DFTBA**，它用更紧凑的方式来表示数据块。首先我们需要一个字典，来保存代码和数据之间的对应关系。我们可以将图像看成一块一块，而不是一个个像素，为了简单，我们将2个像素当成一个块，由此我们可以得到下图的4个像素对，我们会对些像素对生成**紧凑代码（Compact Codes）**。这些块出现频率不同，我们通过霍夫曼树的方法对每一种情况进行编码，使得频率最高的块代码最短。然后我们就能通过code代替块来对图像进行压缩。这个例子中将48字节的数据压缩成了14位，但是同样也要把字典保存下来，所以还需要将字典加到数据前面，所以总共有30字节。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-e40dfa25fd9f55ddb49ac3c558b2415f_720w.jpg" alt="img"></p><center>使用霍夫曼树生成的块的编码</center>![img](https://longlongqin.gitee.io/image_save/images/assets/v2-557e83d3f9b5d120457fb8fe3fc9df87_720w.png)<center>压缩结果</center>![img](https://longlongqin.gitee.io/image_save/images/assets/v2-e688a0f2a014255ed2e3c9ba38855ed5_720w.png)<center>加上字典后的压缩结果</center>## 有损压缩：<p>“消除冗余”和“使用更紧凑表示方法”通常会组合起来一起使用，几乎所有无损压缩格式都用到它们。</p><p>无损压缩对于文本数据十分重要，但是有其他一些数据即使丢失了一部分也不会造成很大影响，通常会丢失人们无法注意到的信息，大部分<strong>有损压缩技术（Lossy Compression）</strong>都用到了这点。</p><p>以声音为例，人类听力并不是完美的，有些频率我们可以捕获，但是类似于超声波这类的频率我们根本听不见，所以录制音乐时，超声波数据是可以丢弃的，其次人类对人声十分敏感，所以应该尽可能保持原样。<strong>有损音频压缩（Lossy Audio Compressors）</strong>通过不同精度编码不同频段，这样人类听不出什么区别，也不会明显影响体验。比如电话中也用到了这个技术，这就使得在电话中的声音和现实中有所差别，用过这个技术才使得更多人同时打电话。如果网速变慢，压缩算法就会删掉更多的数据。压缩音频文件MP3和没压缩音频文件WAV或FLAC大小可以相差10倍。</p><p>这种删除人类无法感知的数据的方法称为<strong>感知编码（Perceptual Coding）</strong>。这也是各种有损压缩图像格式的基础，比如JPEG，人类的视觉系统也不是完美的，我们比较善于看到尖锐的对比，比如物体的边缘，但我们无法看出颜色的细微变化。JPEG由此将图像分解成8x8大小的像素块，然后删掉大量高频空间数据。比如以下这张图片，其中一个8x8像素，由于每个像素都有细微差异，所以无损压缩技术很难对其压缩，但是人眼很难看出这些细微差别，所以我们可以删除很多像素值，这样只占10%的原始数据，并且图像看起来没有什么区别。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-0dcede4590c5d2552a8fe9e4d5a45c95_720w.jpg" alt="img"></p><center>原图；8x8原始像素块；8x8压缩像素块；压缩图像</center>视频只是一长串连续图片，所以图片的很多方面也适用于视频，但视频也可以做一些小技巧，因为帧与帧之间有很多相同的像素，称为**时间冗余（Temporal Redundancy）**。我们不需每一帧都保存这些像素，可以只保存变化了的部分。更高级的视频压缩格式会更进一步，他们找出帧和帧之间相似的补丁，然后对他们应用简单变换，比如移动、旋转、变亮和变暗，这样就不用重复保存这些相似的补丁，直接对其进行变换就行。MPEG-4视频是常见的标准，可以比原文件小20倍到200倍。但是当压缩太严重时，没有足够空间更新补丁内的像素，就会出现以下问题。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-759970de261a610b53e2e652fc6f572c_720w.jpg" alt="img"></p><center>过度压缩造成的错误</center># 23、屏幕&2D图像显示<p>早期的文本任务通过打印机显示，因为屏幕分辨率较低，无法显示清晰的文字，而将计算结果的文字打印在纸上，有更高的对比度和分辨率，屏幕一般只用于跟踪程序的运行情况，比如寄存器的值，可以节约纸，并且屏幕更新很快，对临时值很匹配。</p><p>最早最有影响力的是<strong>阴极射线管（Cathode Ray Tube，CRT）</strong>，原理是将电子发射到有磷光体涂层的屏幕上，当电子撞击涂层时，会发光几分之一秒。并且因为电子是带电粒子，所以路径可以通过磁场进行控制。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-739424da713eed4b346efb1dc7543358_720w.jpg" alt="img"></p><center>CRT</center>这样就有两种方法来绘制图形：<ol><li>引导电子束描绘出形状，称为<strong>矢量扫描（Vector Scanning）</strong>。因为发光只持续一小会儿，如果重复速度足够快，就能得到清晰的图像。</li><li>第二种方法是按照固定路径，一行行从上到下、从左到右不断重复，只在特定的点打开电子束来绘制图形。这种方法称为<strong>光栅扫描（Raster Scanning）</strong>。用这种方法可以用很多小线段绘制图形，甚至文字。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-ec5217cfd4e2ebb1de1126112a830c20_720w.jpg" alt="img"></p><center>矢量扫描和光栅扫描</center>随着屏幕的发展，我们终于可以在屏幕上显示清晰的点，称为**像素（Pixel）**。**液晶显示器（Liquid Crystal Display，LCD）**也使用光栅扫描，每秒更新多次像素里红绿蓝的颜色。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-818d25d7f9bfa6d121e602a746837223_720w.jpg" alt="img"></p><center>LCD</center>但是早期计算机不使用像素，因为内存中需要保存像素对应的值，使其占用太多内存，所以需要一些特殊技巧来渲染图形，知道内存发展到足够用的地步。<p>所以早期计算机不保存大量像素值，而是直接保存符号，其中80x25个符号是最经典的，若干每个字符用8个字节表示，一共也才16000位。为此，需要特殊的硬件来从内存读取字符，转换成光栅图形，这样才能显示到屏幕上，这个称为<strong>字符生成器（Character Generator）</strong>，基本算是第一代显卡。</p><p>显卡内部有一小块<strong>只读存储器（Read Only Memory，ROM）</strong>存着每个字符的图形，称为<strong>点阵图案（Dot Matrix Patter）</strong>。如果显卡看到某个字符对应的二进制代码，它就会把该字符的点阵图案通过光栅扫描的方式显示在屏幕的适当位置。为了显示，字符生成器会访问内存中一块特殊区域，这块区域专为图形保留，称为<strong>屏幕缓冲区（Screen Buffer）</strong>，程序想显示文字时，就直接修改保存在这个区域的值就行。字符生成器这种方案用的内存很少，但只能画字符到屏幕上，无法绘制任意形状。</p><p>传统的ASCII编码的字符集太小，做不了很复杂的事情，因此对ASCII进行扩展增加更多的新字符，比如用于DOS的IBM CP437字符集，有些系统还会用额外的bit来定义字体颜色和背景颜色。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-9d82eef96cc809355690e396d46873bf_720w.jpg" alt="img"></p><center>IBM CP437字符集</center>为了绘制任意形状，同时不会占用太多内存，就要使用CRT上的**矢量模式**。所有东西都是由一系列线条组成的，完全不需要有文本的概念，如果要显示文字，直接用画线的形式进行显示。我们使用一个早期适量显示系统Vectrex的命令为例<ol><li>首先使用RESET命令来清空屏幕， 同时将电子枪的绘图点移动到坐标(0,0)，也就是屏幕左上角，并将线的亮度设为0。</li><li>调用MOVE_TO 50 50，就会将绘图点移动到坐标(50,50)。然后使用INTENSITY 100将强度设为100， 然后反复调用以上命令就会绘制出对应图形。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://longlongqin.gitee.io/image_save/images/assets/v2-4820ddaa8ce054742f05ea0afbbabab9_720w.jpg" alt="img"></p><p>这些命令也就占160位，比直接保存一个像素矩阵好很多。</p><p>类似于之前的字符生成器把内存里的字符转换成图形一样，这些矢量指令也保存在内存中，通过<strong>矢量图形卡（Vector Graphics Card）</strong>画在屏幕上。然后通过数百个命令按序保存在屏幕缓冲区中，就能绘制出十分复杂的图形。并且因为这些矢量都在内存中，程序就可以更新这些值，让图形随时间进行变化，就出现了动画。</p><p>1962年诞生的Sketchpad是一个巨大的里程碑，它是一个交互式图形界面，用于计算机辅助设计（CAD），它被认为是第一个完整的图形程序。为了与图形界面进行交互，Sketchpad使用了输入设备——<strong>光笔</strong>，就是一个有线连着电脑的触控笔，笔尖用光线传感器，可以检测到显示器的刷新，并且通过判断刷新时间，电脑也可以知道笔所在的位置。使用光笔和各种按钮，用户可以画线和其他各种简单图案。</p><p><u>最早真正使用像素的计算机和显示器出</u>现于1960年代末。内存中的位对应屏幕上的像素，称为<strong>位图显示（Bitmapped Display）</strong>，通过对像素的控制，我们能够完全绘制任意的图形。可以将图形想象成是一个巨大像素值矩阵，之前计算机将像素数据保存在内存中一个特殊区域，称为<strong>帧缓冲区（Frame Buffer）</strong>，但是后来保存在特殊的高速<strong>视频内存（Video RAM，VRAM）</strong>中，这个VRAM是在显卡上，这样访问速度更快。</p><p>在一个分辨率是60x35的8位灰度屏幕上，我们可用的颜色范围是0到255。如果我们想把(10,10)处的像素设为白色，可以使用frambuffer [10] [10]=255， 如果我们想要从(30,0)到(30,35)画一条直线，可以使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FOR y&#x3D;0 TO 35</span><br><span class="line">    framebuffer[30][y]&#x3D;255</span><br><span class="line">NEXT</span><br></pre></td></tr></table></figure><p>使用相同方法，通过修改像素值就可以绘制任意图像。并且程序可以操纵帧缓冲区内的像素数据，来实现交互式图形。</p><h1 id="28、计算机网络"><a href="#28、计算机网络" class="headerlink" title="28、计算机网络"></a>28、计算机网络</h1><p>第一个计算机网络出现在1950-1960年代，通常在公司或研究室内部使用，方便信息交换，称为<strong>球鞋网络（Sneakernet）</strong>，第二个好处在于共享物理资源，比如，与其每台电脑配一台打印机，不如大家共享一台联网的打印机。并且早期网络也会共享存储空间，因为为每台计算机都配存储器太过昂贵。</p><p>计算机近距离构成的小型网络称为<strong>局域网（Local Area Network，LAN）</strong>，局域网能小到是同一间房间内的两台计算机，或者大到校园内的上千台电脑。</p><p>尽管开发和部署了很多不同的LAN技术，其中最著名的是<strong>“以太网（Ethernet）”</strong>，以太网的最简单形式是：一条以太网电线连接数台计算机，当一台计算机要传数据给另一台计算机时它以<strong>电信号</strong>形式，将数据传入电缆中，由于电缆是共享的，所以连接在同一个网络里的其他计算机都能看到数据，但是所有计算机都不知道这些数据是给自己的还是给别人的。<u>为了解决这个问题</u>，以太网需要每台计算机有唯一的<strong>媒体访问控制地址（Media Access Control Address，MAC Address）</strong>，然后将MAC地址作为数据的前缀发送到网络中，所以计算机只需要监听以太网电缆，只要看到自己的MAC地址，才去接收处理数据。现在制造的每台计算机都自带唯一的MAC地址，用于以太网和无线网络。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://pic4.zhimg.com/80/v2-bd0dfa011a483016ac431b355610fefb_720w.jpg" alt="img"></p><center>以太网</center>但是共享载体有个很大的**弊端**：当网络流量比较小时，计算机可以等待载体清空，然后再传输他们的数据。但随着网络流量上升，两台计算机想同时写入数据的概率也会上升，这称为**冲突（Collision）**，就会使得传输的数据混乱。幸好计算机能够监听电线里的信号来检测冲突，最简单的解决方案就是看到冲突就停止传输，等待网络空闲后再试一次，问题是其他计算机也是这样打算的，其他等待的计算机可能在任何停顿间隙就闯入开始传输数据，这就导致了越来越多的冲突。<p>以太网的<strong>解决方法</strong>是：当计算机检测到冲突后，就会在重传之前等待一小段时间（因为要举例，假设是 1 秒好了），当然 如果所有计算机用同样的等待时间 是不行的，它们会在一秒后再次冲突。所以加入一个随机时间 一台计算机可能等1.3秒，另一台计算机等待1.5秒 。要是运气好 等1.3秒的计算机会醒来发现载体是空闲的 然后开始传输 ，当1.5秒的计算机醒来后 会发现载体被占用会等待其他计算机完成 ，来相互避开。当然这个并不能完全解决问题，还需要用到<strong>另一个技巧</strong>。如果一台计算机在传输数据期间检测到冲突，就等待“1秒+随机时间”，但是如果再次发生冲突，就表明有网络拥塞，这次不等1秒，而是等2秒 ，如果再次发生冲突 等4秒 然后8秒 16秒等等，直到成功传输。因为计算机的退避，冲突次数会大幅减少，使得数据能够再次流动起来，网络就变得顺畅了。<u>这种指数级增加等待时间的方法</u>称为<strong>指数退避（Exponential Backoff）</strong>，很多以太网和WiFi都用到这个技术。</p><p>但是即使有了以上的技术，想用一根网线连接整个大学的计算机还是不可能的，为了减少冲突同时提高效率，我们<u>需要减少同一载体中设备的数量</u>，载体和其中的设备总称为<strong>冲突域（Collision Domain）</strong>。以之前以太网为例，一根电缆连接了6台计算机，这个称为一个冲突域。为了减少冲突，我们可以用<strong>交换机（Switch）</strong>将它拆成两个冲突域。交换机位于两个更小的网络之间，在必要时才在两个网络之间传输数据，并且交换机会记录一个<strong>列表</strong>，写着哪个MAC地址位于哪边网络，所以当MAC A想要传数据给MAC C，交换机就不会将数据传到另一边的网络，同理如果MAC E传输数据给MAC F，交换机也不会将数据传到上面的网络，这使得两边的传输能同时进行。但是如果MAC F想传数据给A，数据就会通过交换机，使得两个网络都会被短暂占用。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/v2-059e0333f1ad801bb826f3f89afeb0a7_720w.jpg" alt="img"></p><center>一个以太网中加入一个交换机</center>即使最大型的网络——**互联网（Internet）**也是这样构建起来的，本质还是多个连在一起的稍小一点的网络，使得不同网络间可以传递数据。而大型网络有一个特点，从一台主机到另一台主机通常有多条线路（**解决的主要问题**），这就引出了另一个话题——**路由（Routing）（用来选择合适路线的方法）**。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/v2-618cd9d33b6ca884945143c2d8e3810e_720w.jpg" alt="img"></p><center>大型网络，两台主机之间存在多条线路</center>连接两台相隔遥远的计算机或网络，最简单的方法是分配一条专门的<u>通信线路</u>，早期的电话系统就是这样运作的，这种方法称为**电路交换（Circuit Switching）**，因为是对整个电路进行修改，来连接到正确目的地，所以这种方法不灵活且价格昂贵，并且总有闲置的路线。但是好处是你可以最大限度随意使用，无需共享。因此军队、银行和其他一些机构依然会购买专门线路来连接数据中心。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229164213580.png" alt="image-20200229164213580"></p><center>电路交换</center>传输数据的另一种方法是**报文交换（Message Switching）**，就像邮政系统一样。不像之前A和B之间有一条专有线路，这里消息会经过好几个站点，就类似于邮寄信封，信封会通过一个个中转站最终到达收件人手中，每个站点都知道下一站要发往哪里，因为站点都有自己一个**表格**，用来记录到达各个目的地，信件要如何传递。报文交换的**好处**是你可以用不同的路由，使得通信更可靠。比如如果其中一个城市由于降雪无法接收邮件时，就能换到另一个城市继续传递数据。这里，城市就相当于网络中的路由器一样。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229163941432.png" alt="image-20200229163941432"></p><center>报文交换</center>> 交换机是连接若干个主机的机器，用来解决冲突域问题。 > > 路由器是连接主机、路由器、交换机的机器，用来构建数据传输的线路。<p>信息沿着路由跳转的次数称为<strong>跳数（Hop Count）</strong>，通过记录跳数，可以分辨出路由问题。比如当路由A认为到达目的地最快的下一个路由是B，就将信息传递给路由B，而路由B则认为到达目的地最快的下一个路由是A，又将信息传递回给了路由A，这就使得信息在路由A和B之间踢皮球，但是这种错误可以通过在信息中实时记录的跳数来解决，如果某条信息的跳数很大，就说明路由有出问题，这个称为<strong>跳数限制（Hop Limit）</strong>。</p><p>而报文交换的<strong>缺点</strong>之一就是当报文较大时，会堵塞网络，因为这里要求将<u>整个报文</u>从一个路由传到下一个路由后，才能继续传递其他报文，当传输大报文时，其他报文要么等待它传递完，要么选择另一条效率较低的路线。<u><strong>解决</strong></u>方法就是将大报文分成很多小块，称为<strong>数据包（Packet）</strong>。和报文交换一样，每个数据包都有网络中的目的地址，因此路由器知道要发送到哪里，这个地址的具体格式由<strong>互联网协议（Internet Protocol，IP）</strong>定义。每个联网的计算机都需要一个<strong>IP地址（IP Address）</strong>，例如<code>172.217.7.238</code>。</p><blockquote><p>MAC地址用来标识每条计算机，而IP地址是对数据包而言的。</p></blockquote><p>路由器会平衡与其他路由器之间的负载，来确保传输可以快速可靠，称为<strong>拥塞控制 （Congestion Control）</strong>。有时候一个报文的多个数据包会经过不同线路，使得到达顺序也可能不相同，这对一些软件来说是存在问题的。幸运的是，在IP之上还有其他协议，<u>比如TCP/IP可以解决乱序问题</u>。</p><p>将数据拆分成多个小数据包，然后通过灵活的路由传递，非常高效且容错率高，这种方法称为<strong>分组交换（Packet Switching）</strong>。它的好处是可以去中心化，就没有单点失败问题。</p><p>如今全球的路由器协同工作，找出最高效的线路，用各种标准协议传输数据，比如<strong>因特网控制信息协议（Internet Control Message Protocol，ICMP）</strong>和<strong>边界网关协议（Border Gateway Protocol，BGP）</strong>。</p><p>网络是一堆管子组成的吗？ 额 算是吧。</p><h1 id="29、互联网"><a href="#29、互联网" class="headerlink" title="29、互联网"></a>29、互联网</h1><p>任意计算机都和一个巨大的分布式网络连接在一起，称为<strong>互联网（Internet）</strong>。</p><p>当你在家中通过计算机观看网上视频时，你的计算机首先需要连接到<strong>局域网LAN</strong>，这个局域网是由家里WiFi路由器连接的所有设备组成的。然后家里的局域网再通过路由器连接到<strong>广域网（Wide Area Network，WAN</strong>），广域网的路由器一般属于你的<strong>互联网服务提供商（Internet Service Provider，ISP）</strong>。在广域网里，首先会有一个区域性路由器，比如覆盖你所在街区的一个路由器，然后该路由器会连接到一个更大的广域网中，比如覆盖你所在的城市，可能再跳跃几次，最终会到达互联网主干，一般由一群超大型、带宽超高的路由器组成。</p><blockquote><p>即首先会连接到你家里的WiFi路由器构建的局域网，然后该路由器再连接到ISP提供的广域网中，该广域网是由很多层层递进的路由器构成的。</p></blockquote><p>比如要从YouTube中获得视频，数据包首先会到达互联网主干，沿着主干到达对应保存该视频文件的YouTube服务器，可能这里会跳4次到达互联网主干，然后跳两次穿过互联网主干，最终再跳4次到达YouTube服务器，所以总共会跳跃10次。</p><p>我们可以通过<code>traceroute</code>来看跳跃了几次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Windows上的Traceroute</span><br><span class="line">1.按开始按钮</span><br><span class="line">2.输入“ CMD”，然后按“ Enter”</span><br><span class="line">3.在命令提示符下，键入“ tracert dftba.com”</span><br><span class="line"></span><br><span class="line">在Mac上的Traceroute</span><br><span class="line">1.点击“转到”下拉菜单</span><br><span class="line">2.点击“实用程序”</span><br><span class="line">3.打开终端</span><br><span class="line">4.键入“ traceroute dftba.com”</span><br><span class="line"></span><br><span class="line">Linux上的Traceroute</span><br><span class="line">1.通过键入CTRL + Alt + T打开终端</span><br><span class="line">2.输入：“ traceroute dftba.com”</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229165556176.png" alt="image-20200229165556176"></p><center>通过traceroute查看到dftba.com中转的次数</center>经历了11次中转。<p>但是数据包到底是怎么传递过去的呢？如果传输时数据包丢失了，会发生什么？当我们在浏览器中输入网址时，浏览器怎么知道服务器的地址是什么呢？</p><p>就像上节介绍的，互联网是一个巨大分布式网络，如果要发送的数据较大，分组传输就会将数据拆成一个个较小的数据包进行传输。其中数据包要想在互联网上进行传输，就要符合<strong>互联网协议（Internet Protocol，IP）</strong>。类似于邮寄手写信一般，每封信都需要一个地址，并且地址必须是唯一的，并且信的大小和重量也是有限制的，否则信件就无法送达。IP数据包也是如此，因为IP是一个非常底层的协议，数据包的头部只包含目标地址（IP地址），意味着当数据包到达对方电脑时，计算机不知道要把数据包交给哪个程序（比如QQ或微信），因此需要在IP之上，开发更高级的协议。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229170514722.png" alt="image-20200229170514722"></p><center>数据包的结构</center>最简单常见的协议称为用户数据报协议（User Datagram Protocol，UDP）。UDP也有头部，位于data payload里面，在data之前。UDP头部里面包含了很多有用的信息，其中之一就是**端口号（Port Number）**，每个想访问网络的程序都要向操作系统申请一个端口号。所以当数据包到达时，接收方的操作系统会读取UDP头部里的端口号，来确定该数据包是要交给哪个软件的。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229170831643.png" alt="image-20200229170831643"></p><center>UDP</center>比如 Skype 会申请端口 3478，当一个数据包到达时接收方的操作系统会读 UDP 头部，读里面的端口号如果看到端口号是 3478，就把数据包交给 Skype。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229171417934.png" alt="image-20200229171417934"></p><center>端口号</center>![image-20200229170954885](assets/image-20200229170954885.png)<blockquote><p>IP协议通过IP地址把数据包送到正确的计算机内；UDP通过数据包里的端口号送到正确的程序。</p></blockquote><p>同时UDP的头部中还有<strong>校验和（Checksum）</strong>，通过对数据求和来检查数据是否正确。假设UDP数据包里原始数据是<code>89 111 33 32 58 41</code>， 最简单的计算校验和的方式就是，在发送数据包之前，计算机会把所有数据加在一起，计算出校验和364。在UDP中，校验和是以16位形式存储的，如果计算出来的和超过16位能表示的最大值，则高位数会被丢弃，只保留低位。当接收方计算机接收到这个数据包时，也会重复以上过程，如果计算出来的校验和和UDP中保存的校验和相同，代表数据是正常的，否则数据是出错的。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/v2-9211cf69881af0f8ba2e4a8e8b5ce8ee_720w.jpg" alt="img"></p><p>但是，UDP不提供数据修复或数据重发机制，当接收方知道数据损坏后，一般只是丢弃这个数据包。并且当发送方使用UDP协议发送数据包时，是无法得知数据包是否到达目的地的。有些程序并不在意以上问题，因为UDP十分简单且快速。比如<u>视频</u>通常使用UDP协议，当数据包丢失时，也就造成视频卡顿。</p><p>但是有些数据不能接受数据包丢失的问题，比如发送电子邮件时，所有数据必须到达，所以就需要<strong>传输控制协议（Transmission Control Protocol，TCP）</strong>。和UDP一样，它的头部也保存在数据之前，人们通常将<u>IP协议和TCP协议</u>统称为<strong>TCP/IP协议</strong>。TCP的头部中也包含端口号和校验和，并且TCP协议还提供更高级的功能：</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/v2-969988861bec7064179dd4e99b60dbf8_720w.png" alt="img"></p><center>TCP</center>1. TCP的数据包是<u>有序号</u>的，使得接收方可以通过这个序号将数据包排成正确顺序，即使到达时间不同。 2. TCP要求接收方的电脑收到数据包并校验和检查无误后，需要给发送方发送一个**确认码（Acknowledgement，ACK）**，代表数据包已经正确接收。当发送方接收到确认码后，就知道上一个数据包成功抵达了，发送方就会发送下一个数据包，如果这次发送方过了一段时间没有接收到确认码，则会重新发送一次。即使这里只是由于确认码延迟了，使得接收方那里有重复的数据包，但是通过序列号，可以直接删除重复的数据包。<p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229171954069.png" alt="image-20200229171954069"></p><p>并且数据包并不会一个个数据包进行传输，而是<strong>同时发送多个数据包</strong>，同时接收多个<strong>确认码(ACK)</strong>，这将大大提高效率，不用浪费时间等待确认码。并且通过确认码的成功率和来回时间，我们可以推测网络的拥塞程度，TCP通过这个信息，来调整同时发包数量来解决拥塞问题。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/v2-061760eadb27bb199a2a917547852efc_720w.jpg" alt="img"></p><p>简而言之，TCP可以处理乱序和丢包问题，并且可以根据拥塞情况自动调整传输率。</p><p>但是由于确认码数据包的存在，使得TCP需要传输的数据包数量翻了一倍，并且并没有传输更多信息，这对时间要求很高的程序代价太高，所以这类程序就会使用UDP协议（比如射击类游戏）。</p><p>当计算机访问一个网站时，需要两个东西<code>：IP地址（目标网站的地址）</code>和 <code>端口号（对应于你使用的计算机浏览器）</code>（例如：例如 <code>172.217.7.238 的 80 端口</code> 这是谷歌的 IP 地址和端口号）。但是通过IP地址访问网站十分不方便，所以互联网提供一个特殊服务，来将<strong>域名（Domain Name）</strong>和IP地址一一对应，称为<strong>域名系统（Dimain Name System，DNS）</strong>，一般DNS服务器都是由ISP提供的。当你在浏览器中输入网站域名时，浏览器就会去访问DNS服务器，DNS就会去查表，如果域名存在，则会返回浏览器对应IP地址，然后浏览器就会给这个IP地址发送TCP请求。</p><p>因为当前域名特别多，所以DNS不会将其保存成列表形式，而是将其保存成树状结构。最顶层是<strong>顶级域名（Top Level Domain，TLD）</strong>，比如<code>.com</code>和<code>.gov</code>；下一层是<strong>二级域名（Second Level Domain）</strong>， 比如<code>google.com</code>和<code>dftba.com</code>；再下一层是<strong>子域名（Sub-domain）</strong>，比如<code>images.google.com</code>等等。由于这个树结构特别大，因此这些数据分布在很多DNS服务器上，不同服务器负责树的不同部分。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229172611126.png" alt="image-20200229172611126"></p><center>域结构<center><p>总结上两节（28、29）的内容，其实计算机网络分成很多层次，接下来从最底层到最高层：</p><ol><li><strong>物理层（Physical Layer）</strong>，比如线路中的电信号，以及无线网络中的无线信号。</li><li><strong>数据链路层（Data Link Layer）</strong>负责操控物理层，其中包含MAC地址、冲突检测、指数回退以及其他一些底层协议。</li><li><strong>网络层（Network Layer）</strong>负责各种报文交换和路由技术。</li><li><strong>传输层（Transport Layer）</strong>负责在计算机之间进行点到点的传输，还会检测和修复错误，比如UDP和TCP协议。</li><li><strong>会话层（Session Layer）</strong>会使用TCP和UDP来创建连接，传递信息，然后关掉连接。</li></ol><p>以上是<strong>开放式系统互联通信参考模型（Open System Interconnection model，OSI）</strong>下的5层，这个框架将网络通信划分成了很多层，每一层处理各自的问题。这种抽象可以使得分工改进多个层，而无需考虑整体复杂性。并且OSI还有额外两层：<strong>表示层（Presentation Layer）</strong>和<strong>应用层（Application Layer）</strong>，在下一节中进行介绍。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229172753982.png" alt="image-20200229172753982"></p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/image-20200229172822261.png" alt="image-20200229172822261"></p><h1 id="30、万维网"><a href="#30、万维网" class="headerlink" title="30、万维网"></a>30、万维网</h1><p>前两节介绍的东西共同组成了互联网，这一节将向上抽象一层，来讨论<strong>万维网（World Wide Web）</strong>。万维网和互联网的概念完全不同，万维网是运行于互联网之上的，还有其他比如Skype、Instagram等也是运行在互联网之上的。<strong>互联网是用来传输数据的管道</strong>，各种程序都会使用到，<u>其中传输最多数据的程序就是万维网</u>，我们可以使用特殊的程序——<strong>浏览器（Web Browser）</strong>来访问万维网。</p><p>万维网的最基本单位是单个页面，里面包含内容，也有访问其他页面的链接，这些链接称为<strong>超链接（Hyperlink）</strong>。这些超链接形成巨大的互联网络，这也是万维网名字的由来。并且由于文字超链接的强大，它有一个特殊的名字——<strong>超文本（Hypertext）</strong>。如今超文本最常指向的是另一个页面，这些页面会被获取并由浏览器进行渲染。</p><p>为了使网页能够互相连接，每个网页需要一个唯一的地址，这个地址称为<strong>统一资源定位器（Uniform Resource Locator，URL）</strong>，比如<code>thecrashcourse.com/courses</code>就是一个页面URL。</p><p>当你访问<code>thecrashcourse.com</code>网址时，计算机首先会进行DNS查询，这里输入一个域名，然后DNS就会返回给浏览器对应的计算机IP地址。然后浏览器就会打开一个TCP连接到这个IP地址对应的计算机上，而这个计算机运行着一个特殊的软件——<strong>网络服务器（Web Server）</strong>，网络服务器的标准端口是80。此时，你的计算机就连接到了<code>thecrashcourse.com</code>对应的服务器了，下一步是向服务器请求<code>courses</code> 页面，这里就会用到<strong>超文本传输协议（Hypertext Transfer Protocol，HTTP）</strong>。</p><p>HTTP的第一个标准是1991年创建的HTTP 0.9，只有一个指令<code>GET</code> 。因为这里我们想要获取<code>courses</code>页面， 我们可以直接向服务器发送指令<code>GET/courses</code>， 该指令以ASCII编码发送到服务器，服务器会返回该网址对应的页面，然后浏览器就会将其渲染到屏幕上。如果用户点击了另一个链接，计算机就会重新发送一个GET请求。在之后的版本中，HTTP添加了新的状态码，会将其放在请求页面的前面，比如状态码200表示网页被正确找到了，状态码400-499代表客户端出错。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/v2-5c297a37758affab1974f221b51a678d_720w.jpg" alt="img"></p><p>因为超文本的存储和发送都是以普通文本形式进行的，编码可能是ASCII或者UTF-8，这样就无法表明什么是链接，什么只是普通的文本了，所以必须开发一种标记方法，因此出现了<strong>超文本标记语言（Hypertext Markup Language，HTML）</strong>，第一代HTML创建于1990年的0.8版本，有18种指令。</p><p><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="assets/v2-d1f17935f645f06fc006ff22a4d68d4b_720w.jpg" alt="img"></p><center>制作一个简单的网页</center>综上，网络浏览器可以和网络服务器沟通，不仅获取网页和媒体，并且还负责显示。<p>随着后期万维网日益繁荣，人们越来越需要搜索。起初人们会维护一个目录，来链接到其他网站，但是随着网络越来越大，人工编辑目录变得很不方便，所以开发了搜索引擎。</p><p>最早的搜索引擎是JumpStation，它有3个部分：</p><ol><li><p>通过爬虫来将新链接添加进自己的列表中。</p></li><li><p>不断扩张的索引，用来记录访问过的网页上出现了哪些词。</p></li><li><p>查询索引的搜索算法，比如输入了某个关键字，则包含这个关键字的网页就会显示出来。</p></li></ol><p>早期的搜索引擎的排名方式直接取决于搜索词在页面上的出现次数，但是有的网页会通过在页面中重复该关键字来提高排名。Google成名的很大原因就是提出了一种算法来解决这个问题，与其信任页面上的内容，搜索引擎会看其他网页有没有连接到这个网页。</p><p>最后提一个概念——<strong>网络中立性（Network Neutrality）</strong>，它指的是要对所有数据包都平等对待，速度和优先级都应该一样。</p><h1 id="31、计算机安全"><a href="#31、计算机安全" class="headerlink" title="31、计算机安全"></a>31、计算机安全</h1><p>计算机安全的范围和计算能力的发展速度一样快，我们可以把计算机安全，看成是保护系统和数据的<strong>保密性、完整性和可用性</strong>。</p><blockquote><p><strong>保密性（Secrecy）：</strong>只有有权限的人才能<strong>读取</strong>计算机系统和数据，比如黑客泄露别人的信用卡信息，就是攻击保密性。</p><p><strong>完整性（Integrity）：</strong>只有有权限的人才能<strong>使用和修改</strong>系统和数据，比如黑客假冒你发送邮件，就是攻击完整性。</p><p><strong>可用性（Availability）：</strong>有权限的人应该随时可以访问系统和数据，<strong>拒绝服务攻击（DDOS</strong>）就是黑客发送大量的假请求到服务器上，使得网站很慢或者直接挂掉，这就是攻击可用性。</p></blockquote><p>为了实现这三个目标，安全专家会从抽象层面想想敌人可能是谁，这个称为<strong>威胁模型分析（Threat Model）</strong>。模型会对攻击者有个大致的描述：能力如何、目标是什么、可能使用什么手段。攻击手段又称为<strong>攻击矢量（Attack Vector）</strong>。威胁模型分析能够让你为特定情境做好准备，不被可能的攻击手段所淹没。换句话说，要怎么保护，具体看要对抗谁。</p><p>通常威胁模型分析中，会以能力水平进行区分。在给定的威胁模型下，安全架构师要提供解决方案，来保持系统安全。</p><p>有很多保护计算机系统、网络和数据的方法。很多安全问题可以总结成<strong>两个问题</strong>：</p><ol><li>你是谁？</li><li>你能访问什么？</li></ol><p>权限应该给适合的人而拒绝错误的人，所以为了区分谁是谁，我们使用<strong>身份认证（Authentication）</strong>来让计算机得知使用者是谁。通常身份认证有三种，各有利弊：</p><ol><li><strong>你知道什么：</strong>这个是基于某种只有用户和计算机知道的秘密，比如用户名和密码。这是如今使用最广最容易实现的方法。但是如果黑客知道了你的密码就惨了，或者可以通过暴力攻击试了密码的所有可能来获取你的密码，有些系统会在你尝试若干次错误后阻止你继续尝试。即使增长密码也很容易破解，所以现在很多网站都要求大小写字母加特殊字符，来增加可能的密码。</li><li><strong>你有什么：</strong>这是基于用户特定的物体，比如钥匙和锁。这种方法可以避免被人猜中密码的问题，而且通常需要人在现场，所以远程攻击就更加困难了。</li><li><strong>你是什么：</strong>这是基于你，通过你自己的特征展示给计算机来进行验证，比如指纹识别器和红膜扫描仪，这些方法特别的安全，但是最好的识别技术十分昂贵。“你知道什么”和“你有什么”是确定性的，但是来自传感器的数据每次都不相同，所以“你是什么”是概率性的，系统可能认不出你，或者将其他人认成了你。并且这种方法另一个问题就是无法重设，你无法修改自己的指纹或者虹膜。</li></ol><p>每种方法都有优缺点，一般建议使用两种或两种以上的认证方式。</p><p>当系统知道了你是谁，接下来就需要知道你能访问什么，这个称为<strong>访问控制（Access Control）</strong>，因此需要一个规范，来说明谁能访问什么、修改什么和使用什么。这个可以通过<strong>权限（Permission）</strong>或<strong>访问控制列表（Access Control List，ACL）</strong>来实现，其中描述了用户对每个文件、文件夹和程序的访问权限。</p><blockquote><p>读权限：允许用户查看文件内容。</p><p>写权限：允许用户修改文件内容。</p><p>执行权限：运行用户运行文件。</p></blockquote><p>有些阻止需要不同层次的权限，则ACL的正确配置就十分重要。假设我们有三个访问级别：<strong>公开、机密和顶级机密</strong>。有个经典模型称为<strong>Bell-LaPadula模型</strong>，其中包含两条规则：</p><ol><li>用户不能<strong>read up</strong>，即不能读等级更高的信息。</li><li>用户不能<strong>write down</strong>，即用户不能写更低权限的信息，这样能避免高级别的信息不会泄漏到低级别的文件中。</li></ol><p>通过身份认证和权限控制，可以让计算机知道你是谁和你能访问什么，但是必须先保证做这些事的软硬件必须是可信的。但是仍然无法保证程序或计算机系统的安全，因为安全软件在理论上可能是安全的，但是实现时可能会不小心留下漏洞。但是我们有办法减少漏洞出现的可能性，比如一发现漏洞就马上修补。</p><p>大部分漏洞都是具体实现时出错了，所以为了减少执行错误，就要减少执行。系统级安全的圣杯之一是安全内核或可信计算机基础：一组尽可能少的操作系统软件，这个安全性是接近可验证的。</p><p>构建安全内核的挑战在于，要决定内核应该有什么（代码越少越好）。当最小化代码数量后，要是能保证代码是安全的，那就很好了。现在最好的验证代码安全性的手段是<strong>独立安全监察和质量验证（Independent Verification and Validation）</strong>，让一群安全行业内的软件开发者来审计代码，这也是为什么安全型代码几乎都是开源的。</p><p>但是即使这样，还是有可能被黑客攻破，因此程序开发者需要控制损失的最大程度，这个称为<strong>隔离（Ioslation）</strong>。要实现隔离，可以<strong>“沙盒”（sandbox）</strong>程序，操作系统通过给每个程序独立的内存块，使得别的程序是无法触及的，这样就能把程序放到沙盒中，即使沙盒被破坏了，也不会影响别的程序执行。并且一台计算机可以运行多个<strong>虚拟机（Virtual Machine）</strong>，使得每个虚拟机都在自己的沙盒中。</p><h1 id="32、黑客-amp-攻击"><a href="#32、黑客-amp-攻击" class="headerlink" title="32、黑客&amp;攻击"></a>32、黑客&amp;攻击</h1><p>黑客入侵最常见的方式不是通过技术，而是欺骗别人，这个称为<strong>社会工程学（Social Engineering）</strong>，通过欺骗别人来让人泄露秘密，或让人配置电脑系统来变得易于攻击。最常见的攻击是<strong>网络钓鱼（Phishing）</strong>，其次还有<strong>假托（Pretexting）</strong>，攻击者给某个公司打电话，假装是IT部门的人，攻击者的第一通电话一般会叫人转接，这样另一个接的时候，电话看起来就像内部的，然后让别人把电脑配置得易于入侵，或者让他们泄露机密信息，比如密码或网络配置。</p><p>邮件里带<strong>木马（trojan horse）</strong>也是常见手段，木马通常会伪装成无害的东西，比如照片或发票，但实际上是恶意软件，有的会偷数据，有的会加密文件。</p><p>如果攻击者无法用木马或电话欺骗，攻击者只能被迫使用其他手段，方法之一就是暴力破解，尝试所有可能的密码，直到进入系统，大多数现代系统会加长等待时间来抵御这种攻击，每次失败就加长等待时间，甚至超过一定次数后，完全封锁。现在出现了一种攻破方法称为<strong>NAND镜像</strong>，如果能物理接触到电脑，可以往内存上接几根线，复制整个内存，然后暴力尝试密码，直到设备让你等待。这时只要把复制的内容覆盖掉内存，本质上重置了内存，就不用等待，可以继续尝试密码。</p><p>如果无法物理接触到设备，就需要远程攻击，比如通过互联网，这一般需要攻击者利用系统漏洞，来获得某些能力或访问权限，称为<strong>漏洞利用（Exploit）</strong>。一种常见的漏洞利用叫<strong>缓冲区溢出（Buffer Overflow）</strong>，这里的缓冲区是指预留的一块内存空间，比如我们在系统登录界面输入用户名和密码，而系统是用缓冲区来存储输入值的，假设缓冲区大小为10，并且缓冲区前后肯定还有其他数据，当用户输入用户名和密码时，这些值就会被复制到缓冲区中来进行验证，而该方法会溢出缓冲区，比如输入超过10个字符的密码，会覆盖掉相邻的数据，有时会让程序或系统崩溃，因为重要值被垃圾数据覆盖掉了。这里只是让系统崩溃，但是攻击者可以输入有意义的新值到程序的内存中，比如把<code>is_admin</code>标志位的值改为true，有了任意修改内存的能力，黑客就可以绕过登录这类东西，甚至使用那个程序劫持整个系统。</p><p>有许多方法阻止缓冲区溢出，最简单的方法就是复制到内存之前先检查长度，称为<strong>边界检查（Bounds checking</strong>），许多现代编程语言都自带边界检查，程序也会随机存放变量在内存中的位置，这样黑客就不知道应该覆盖内存的哪部分，使得更容易让程序崩溃，而不是获得访问权限。程序也可以在缓冲区后，预留一些不用的空间，然后跟踪里面的值，看是否发生变化，来判断是否有攻击，这些不用的内存空间称为<strong>金丝雀（Canaries）</strong>。</p><p>另一种经典手段是<strong>代码注入（Code Injection）</strong>，最常用于攻击用数据库的网站。假设网页上有登录提示，当用户点击“登录”，输入文本就会发送服务器，服务器就会运行代码，检查用户名是否存在，如果存在就看密码是否匹配。为此服务器会执行一段sql查询代码，比如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">password</span> <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> username=<span class="string">'___'</span>;</span><br></pre></td></tr></table></figure><p>这里语句就是要从<code>users</code>表中查找<code>username</code>为<code>___</code>的密码<code>password</code>。 这里的<code>___</code>就是用户输入的用户名。由此攻击者就能把sql命令输入到用户名中，比如<code>whatever&#39;;DROP TABLE users;&#39;</code>，这时上面的查询语句就会变成</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">password</span> <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> username=<span class="string">'whatever'</span>;<span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">users</span>;';</span><br></pre></td></tr></table></figure><p>如果服务器存在用户名<code>wharever</code>，数据库就会返回密码， 当然我们无法得知密码是什么，所以服务器会拒绝我们；如果不存在用户名<code>wharever</code>，服务器会返回空密码或者直接错误，服务器也会拒绝我们。 但是我们关心的是后面的代码<code>DROP TABLE users;</code><strong>这个是我们注入的命令</strong>，这个命令是删掉users这张表。如今几乎所有服务器都会防御这种手段。</p><p>程序员需要认识到从外界输入的信息都是危险的，必须要好好检查，很多用户名和密码表单，不会让你直接输入特殊符号，比如分号或括号，来作为第一道防御。好的服务器也会清理输入，比如修改或删除特殊字符，然后才放到数据库查询语句中。</p><p>当软件制造者不知道的新漏洞被发现时，称为<strong>0day漏洞（Zero Day Vulnerability）</strong>，黑客就会抢在白帽程序员做出补丁之前尽可能利用漏洞。</p><p>如果有足够多的电脑有漏洞，让恶意程序可以自动地在电脑之间互相传播，称为<strong>蠕虫（Worm）</strong>。如果黑客拿下大量电脑，这些电脑可以组成<strong>僵尸网络（Botnet）</strong>，可以用于很多目的，比如发大量垃圾邮件等，用别人电脑的计算能力来挖比特币，或发起DDOS来攻击服务器。DDOS就是僵尸网络里的所有电脑发一大堆垃圾信息到服务器上，造成服务器的阻塞。</p></center></center><br><section class="widget copyright desktop mobile"><div class="content"><blockquote><p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p><p>本文永久链接是：<a href="https://www.longlongqin.top/archives/3ae1bc73.html">https://www.longlongqin.top/archives/3ae1bc73.html</a></p></blockquote></div></section><section class="widget qrcode desktop mobile"><div class="content article-entry"><fancybox><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/reward/AliPayOR.jpg" height="64px"></fancybox><fancybox><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/reward/WeChatPayOR.png" height="64px"></fancybox></div></section></div><section class="meta" id="footer-meta"><div class="new-meta-box"><div class="new-meta-item date" itemprop="dateUpdated" datetime="2020-04-01T10:49:13+08:00"><a class="notlink"><i class="fas fa-save" aria-hidden="true"></i><p>更新于：2020年4月1日</p></a></div><div class="new-meta-item meta-tags"><a class="tag" href="/tags/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE%E3%80%8B/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i><p>《计算机科学速成课》</p></a></div><div class="new-meta-item share -mob-share-list"><div class="-mob-share-list share-body"><a class="-mob-share-qq" rel="external nofollow noopener noreferrer noopener" href="http://connect.qq.com/widget/shareqq/index.html?url=https://www.longlongqin.top/archives/3ae1bc73.html&title=计算机科学速成课(总) - 龙龙‘S BLOG&summary=计算机科学速成课" target="_blank"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qq.png"> </a><a class="-mob-share-qzone" rel="external nofollow noopener noreferrer noopener" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://www.longlongqin.top/archives/3ae1bc73.html&title=计算机科学速成课(总) - 龙龙‘S BLOG&summary=计算机科学速成课" target="_blank"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qzone.png"> </a><a class="-mob-share-weibo" rel="external nofollow noopener noreferrer noopener" href="http://service.weibo.com/share/share.php?url=https://www.longlongqin.top/archives/3ae1bc73.html&title=计算机科学速成课(总) - 龙龙‘S BLOG&summary=计算机科学速成课" target="_blank"><img src="https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/image/loading.gif" data-original="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/weibo.png"></a></div></div></div></section><div class="prev-next"><a class="prev" href="/archives/b6a3dbf1.html"><p class="title"><i class="fas fa-chevron-left" aria-hidden="true"></i>LearnCpp chapter5</p><p class="content">LearnCpp chapter5https://www.learncpp.com5.1 操作符优先级 &amp; 结合律Operator precedence and associativit...</p></a><a class="next" href="/archives/5fc07ec4.html"><p class="title">LearnCpp chapter3<i class="fas fa-chevron-right" aria-hidden="true"></i></p><p class="content">LearnCpp-chapter3https://www.learncpp.com未完待续~~</p></a></div></section></article><article class="post white-box comments shadow"><section class="article typo"><p ct><i class="fas fa-comments"></i> 评论</p><section id="comments"><div id="valine_container" class="valine_thread"><i class="fas fa-spinner fa-spin fa-fw"></i></div></section></section></article><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,tags:"ams",macros:{href:"{}"}},options:{ignoreHtmlClass:"tex2jax_ignore|dno",skipHtmlTags:["script","noscript","style","textarea","pre","code"]}}</script><script>window.subData={title:"计算机科学速成课(总)",tools:!0}</script></div><aside class="l_side"><section class="widget toc-wrapper shadow desktop mobile"><header><i class="fas fa-list fa-fw" aria-hidden="true"></i><span class="name">本文目录</span></header><div class="content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#参考文章-："><span class="toc-text">###参考文章###：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2、电子计算机"><span class="toc-text">2、电子计算机</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3、布尔逻辑和逻辑门"><span class="toc-text">3、布尔逻辑和逻辑门</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5、算数逻辑单元（ALU）"><span class="toc-text">5、算数逻辑单元（ALU）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1）算数单元"><span class="toc-text">1）算数单元</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#半加器-A-half-adder"><span class="toc-text">(半加器)A half adder:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#全加器（Full-Adder）"><span class="toc-text">全加器（Full Adder）:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2）逻辑单元"><span class="toc-text">2）逻辑单元</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6、寄存器-amp-内存"><span class="toc-text">6、寄存器&amp;内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#寄存器："><span class="toc-text">寄存器：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7、中央处理器-CPU"><span class="toc-text">7、中央处理器(CPU)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9、高级CPU设计"><span class="toc-text">9、高级CPU设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#提升性能方法一：缓存"><span class="toc-text">提升性能方法一：缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#提升性能方法二：“指令流水线”"><span class="toc-text">提升性能方法二：“指令流水线”</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10、早期的计算机编程"><span class="toc-text">10、早期的计算机编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11、编程语言发展史"><span class="toc-text">11、编程语言发展史</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12、编程原理-语句和函数"><span class="toc-text">12、编程原理-语句和函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13、算法入门"><span class="toc-text">13、算法入门</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14、数据结构"><span class="toc-text">14、数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-1-数组Array"><span class="toc-text">14.1 数组Array</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-字符串String"><span class="toc-text">14.2 字符串String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-矩阵Matrix"><span class="toc-text">14.3 矩阵Matrix</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-结构体Struct"><span class="toc-text">14.4 结构体Struct</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16、软件工程"><span class="toc-text">16、软件工程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#17、集成电路-amp-摩尔定律"><span class="toc-text">17、集成电路&amp;摩尔定律</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#集成电路（Integrated-Circuits，IC）："><span class="toc-text">集成电路（Integrated Circuits，IC）：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#摩尔定律（Moore’s-Law）"><span class="toc-text">摩尔定律（Moore’s Law）:</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#18、操作系统"><span class="toc-text">18、操作系统</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#19、内存-amp-存储介质"><span class="toc-text">19、内存&amp;存储介质</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#延迟线存储器："><span class="toc-text">延迟线存储器：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#缺点："><span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#磁芯存储器："><span class="toc-text">磁芯存储器：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#磁带："><span class="toc-text">磁带：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#缺点：-1"><span class="toc-text">缺点：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#20、文件系统"><span class="toc-text">20、文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#波形文件："><span class="toc-text">波形文件：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#位图-Bitmap"><span class="toc-text">位图(Bitmap)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#计算机如何存储文件："><span class="toc-text">计算机如何存储文件：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#21、压缩"><span class="toc-text">21、压缩</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#28、计算机网络"><span class="toc-text">28、计算机网络</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#29、互联网"><span class="toc-text">29、互联网</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#30、万维网"><span class="toc-text">30、万维网</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#31、计算机安全"><span class="toc-text">31、计算机安全</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#32、黑客-amp-攻击"><span class="toc-text">32、黑客&amp;攻击</span></a></li></ol></div></section></aside><footer class="clearfix white"><br><br><div class="aplayer-container"><meting-js theme="#1BCDFC" autoplay volume="0.6" loop order="list" fixed="false" list-max-height="340px" server="netease" type="song" id="186453" list-folded="true"></meting-js></div><br><div class="social-wrapper"><a href="/atom.xml" class="social fas fa-rss flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="mailto:1198216723@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://github.com/longlongqin" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://music.163.com/#/user/home?id=285545421" class="social fas fa-headphones-alt flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a></div><red>&copy; 2020-2020 longlongqin 😊| powered by HEXO | theme volantis</red><br><yellow><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("03/01/2020 18:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="小站已运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒 "}setInterval("createtime()",250)</script></yellow><br><green><i class="fas fa-chart-area"></i> <span class="post-count">字数统计：129k</span></green>|<script type="text/javascript" src="https://v1.cnzz.com/z_stat.php?id=1278663994&web_id=1278663994"></script><br><cyan>博客内容遵循</cyan><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank"><cyan>署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</cyan></a></footer><script>setLoadingBarProgress(80)</script><script>setLoadingBarProgress(60)</script></div><a class="s-top fas fa-arrow-up fa-fw" href="javascript:void(0)"></a></div><script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script><script>var SEARCH_SERVICE="hexo",ROOT="/";ROOT.endsWith("/")||(ROOT+="/")</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script><script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script><script type="text/javascript">$(function(){Waves.attach(".flat-btn",["waves-button"]),Waves.attach(".float-btn",["waves-button","waves-float"]),Waves.attach(".float-btn-light",["waves-button","waves-float","waves-light"]),Waves.attach(".flat-box",["waves-block"]),Waves.attach(".float-box",["waves-block","waves-float"]),Waves.attach(".waves-image"),Waves.init()})</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script><script type="text/javascript">$(function(){var n=["https://cdn.jsdelivr.net/gh/longlongqin/CDN-for-HEXO_BLOG/background/4.jpg"];!function(n){for(var o=n.length;o--;){var r=Math.floor(Math.random()*o),t=n[r];n[r]=n[o],n[o]=t}}(n),$(".cover").backstretch(n,{duration:"20000",fade:"1500"})})</script><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js" async></script><script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js" async></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.0/js/valine.js"></script><script>var GUEST_INFO=["nick","mail","link"],guest_info="nick,mail,link".split(",").filter(function(i){return-1<GUEST_INFO.indexOf(i)}),notify=!1,verify=!1,valine=new Valine;valine.init({el:"#valine_container",notify:notify,verify:verify,guest_info:guest_info,appId:"TYFUId8Xuddv6nUYuVUHJbac-gzGzoHsz",appKey:"bCYkC8WKY7n8VjI7K2g8MMJ3",placeholder:"快来评论吧~",pageSize:"10",avatar:"mp",lang:"zh-cn",visitor:"false",highlight:"true"})</script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1.4/js/app.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.1/js/search.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script><script>!function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copyed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-clipboard-check');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPYED';
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-exclamation-triangle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
      });
    }
    initCopyCode();
  }(window, document);</script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>let LAZY_LOAD_IMAGE = "[object Object]";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });</script><script>setLoadingBarProgress(100)</script><script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)t=c[r],0<=(n=t.getBoundingClientRect()).bottom&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this);</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script></body></html>